{"file_name": "/home/qj213/afp-2021-10-22/thys/BTree/BTree_ImpSet.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BTree", "problem_names": ["lemma split_relation_alt: \n  \"split_relation as (ls,rs) i = (as = ls@rs \\<and> i = length ls)\"", "lemma split_relation_length: \"split_relation xs (ls,rs) (length xs) = (ls = xs \\<and> rs = [])\"", "lemma list_assn_prod_map: \"list_assn (A \\<times>\\<^sub>a B) xs ys = list_assn B (map snd xs) (map snd ys) * list_assn A (map fst xs) (map fst ys)\"", "lemma id_assn_list: \"h \\<Turnstile> list_assn id_assn (xs::'a list) ys \\<Longrightarrow> xs = ys\"", "lemma snd_map_help:\n  \"x \\<le> length tsi \\<Longrightarrow>\n       (\\<forall>j<x. snd (tsi ! j) = ((map snd tsi)!j))\"\n  \"x < length tsi \\<Longrightarrow> snd (tsi!x) = ((map snd tsi)!x)\"", "lemma split_ismeq: \"((a::nat) \\<le> b \\<and> X) = ((a < b \\<and> X) \\<or> (a = b \\<and> X))\"", "lemma split_relation_map: \"split_relation as (ls,rs) i \\<Longrightarrow> split_relation (map f as) (map f ls, map f rs) i\"", "lemma split_relation_access: \"\\<lbrakk>split_relation as (ls,rs) i; rs = r#rrs\\<rbrakk> \\<Longrightarrow> as!i = r\"", "lemma index_to_elem_all: \"(\\<forall>j<length xs. P (xs!j)) = (\\<forall>x \\<in> set xs. P x)\"", "lemma index_to_elem: \"n < length xs \\<Longrightarrow> (\\<forall>j<n. P (xs!j)) = (\\<forall>x \\<in> set (take n xs). P x)\"", "lemma split_half_rule[sep_heap_rules]: \"<\n    is_pfa c tsi a\n  * list_assn R ts tsi> \n    split_half a\n  <\\<lambda>i. \n      is_pfa c tsi a\n    * list_assn R ts tsi\n    * \\<up>(i = length ts div 2 \\<and>  split_relation ts (BTree_Set.split_half ts) i)>\"", "lemma P_imp_Q_implies_P: \"P \\<Longrightarrow> (Q \\<longrightarrow> P)\"", "lemma  \"sorted_less (inorder t) \\<Longrightarrow>\n   <btree_assn k t ti>\n     isin ti x\n   <\\<lambda>r. btree_assn k t ti * \\<up>(abs_split.isin t x = r)>\\<^sub>t\"", "lemma node\\<^sub>i_rule: assumes c_cap: \"2*k \\<le> c\" \"c \\<le> 4*k+1\"\n  shows \"<is_pfa c tsi (a,n) * list_assn ((btree_assn k) \\<times>\\<^sub>a id_assn) ts tsi * btree_assn k t ti>\n  node\\<^sub>i k (a,n) ti\n  <\\<lambda>r. btupi_assn k (abs_split.node\\<^sub>i k ts t) r >\\<^sub>t\"", "lemma node\\<^sub>i_no_split: \"length ts \\<le> 2*k \\<Longrightarrow> abs_split.node\\<^sub>i k ts t = abs_split.T\\<^sub>i (Node ts t)\"", "lemma node\\<^sub>i_rule_app: \"\\<lbrakk>2*k \\<le> c; c \\<le> 4*k+1\\<rbrakk> \\<Longrightarrow>\n<is_pfa c (tsi' @ [(li, ai)]) (aa, al) *\n   blist_assn k ls tsi' *\n   btree_assn k l li *\n   id_assn a ai *\n   btree_assn k r ri> node\\<^sub>i k (aa, al) ri\n <btupi_assn k (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t\"", "lemma node\\<^sub>i_rule_ins2: \"\\<lbrakk>2*k \\<le> c; c \\<le> 4*k+1; length ls = length lsi\\<rbrakk> \\<Longrightarrow>\n <is_pfa c (lsi @ (li, ai) # (ri,a'i) # rsi) (aa, al) *\n   blist_assn k ls lsi *\n   btree_assn k l li *\n   id_assn a ai *\n   btree_assn k r ri *\n   id_assn a' a'i *\n   blist_assn k rs rsi *\n   btree_assn k t ti> node\\<^sub>i k (aa, al)\n          ti <btupi_assn k (abs_split.node\\<^sub>i k (ls @ (l, a) # (r,a') # rs) t)>\\<^sub>t\"", "lemma ins_rule:\n  \"sorted_less (inorder t) \\<Longrightarrow> <btree_assn k t ti>\n  ins k x ti\n  <\\<lambda>r. btupi_assn k (abs_split.ins k x t) r>\\<^sub>t\"", "lemma insert_rule:\n  assumes \"k > 0\" \"sorted_less (inorder t)\"\n  shows \"<btree_assn k t ti>\n  insert k x ti\n  <\\<lambda>r. btree_assn k (abs_split.insert k x t) r>\\<^sub>t\"", "lemma insert_rule':\n  shows \"<btree_assn (Suc k) t ti * \\<up>(abs_split.invar_inorder (Suc k) t \\<and> sorted_less (inorder t))>\n  insert (Suc k) x ti\n  <\\<lambda>ri.\\<exists>\\<^sub>Ar. btree_assn (Suc k) r ri * \\<up>(abs_split.invar_inorder (Suc k) r \\<and> sorted_less (inorder r) \\<and> inorder r = (ins_list x (inorder t)))>\\<^sub>t\"", "lemma node\\<^sub>i_rule_ins: \"\\<lbrakk>2*k \\<le> c; c \\<le> 4*k+1; length ls = length lsi\\<rbrakk> \\<Longrightarrow>\n <is_pfa c (lsi @ (li, ai) # rsi) (aa, al) *\n   blist_assn k ls lsi *\n   btree_assn k l li *\n   id_assn a ai *\n   blist_assn k rs rsi *\n   btree_assn k t ti> node\\<^sub>i k (aa, al)\n          ti <btupi_assn k (abs_split.node\\<^sub>i k (ls @ (l, a) # rs) t)>\\<^sub>t\"", "lemma empty_rule:\n  shows \"<emp>\n  empty\n  <\\<lambda>r. btree_assn k (abs_split.empty_btree) r>\""], "translations": [["", "lemma split_relation_alt: \n  \"split_relation as (ls,rs) i = (as = ls@rs \\<and> i = length ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split_relation as (ls, rs) i = (as = ls @ rs \\<and> i = length ls)", "by (auto simp add: split_relation_def)"], ["", "lemma split_relation_length: \"split_relation xs (ls,rs) (length xs) = (ls = xs \\<and> rs = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split_relation xs (ls, rs) (length xs) = (ls = xs \\<and> rs = [])", "by (simp add: split_relation_def)"], ["", "(* auxiliary lemmas on assns *)\n(* simp? not sure if it always makes things more easy *)"], ["", "lemma list_assn_prod_map: \"list_assn (A \\<times>\\<^sub>a B) xs ys = list_assn B (map snd xs) (map snd ys) * list_assn A (map fst xs) (map fst ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn (A \\<times>\\<^sub>a B) xs ys =\n    list_assn B (separators xs) (separators ys) *\n    list_assn A (subtrees xs) (subtrees ys)", "apply(induct \"(A \\<times>\\<^sub>a B)\" xs ys rule: list_assn.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. list_assn (A \\<times>\\<^sub>a B) [] [] =\n    list_assn B (separators []) (separators []) *\n    list_assn A (subtrees []) (subtrees [])\n 2. \\<And>a as c cs.\n       list_assn (A \\<times>\\<^sub>a B) as cs =\n       list_assn B (separators as) (separators cs) *\n       list_assn A (subtrees as) (subtrees cs) \\<Longrightarrow>\n       list_assn (A \\<times>\\<^sub>a B) (a # as) (c # cs) =\n       list_assn B (separators (a # as)) (separators (c # cs)) *\n       list_assn A (subtrees (a # as)) (subtrees (c # cs))\n 3. \\<And>v va.\n       list_assn (A \\<times>\\<^sub>a B) (v # va) [] =\n       list_assn B (separators (v # va)) (separators []) *\n       list_assn A (subtrees (v # va)) (subtrees [])\n 4. \\<And>v va.\n       list_assn (A \\<times>\\<^sub>a B) [] (v # va) =\n       list_assn B (separators []) (separators (v # va)) *\n       list_assn A (subtrees []) (subtrees (v # va))", "apply(auto simp add: ab_semigroup_mult_class.mult.left_commute ent_star_mono star_aci(2) star_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* concrete *)"], ["", "lemma id_assn_list: \"h \\<Turnstile> list_assn id_assn (xs::'a list) ys \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> list_assn id_assn xs ys \\<Longrightarrow> xs = ys", "apply(induction \"id_assn::('a \\<Rightarrow> 'a \\<Rightarrow> assn)\" xs ys rule: list_assn.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. h \\<Turnstile> list_assn id_assn [] [] \\<Longrightarrow> [] = []\n 2. \\<And>a as c cs.\n       \\<lbrakk>h \\<Turnstile> list_assn id_assn as cs \\<Longrightarrow>\n                as = cs;\n        h \\<Turnstile> list_assn id_assn (a # as) (c # cs)\\<rbrakk>\n       \\<Longrightarrow> a # as = c # cs\n 3. \\<And>v va.\n       h \\<Turnstile> list_assn id_assn (v # va) [] \\<Longrightarrow>\n       v # va = []\n 4. \\<And>v va.\n       h \\<Turnstile> list_assn id_assn [] (v # va) \\<Longrightarrow>\n       [] = v # va", "apply(auto simp add: less_Suc_eq_0_disj pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma snd_map_help:\n  \"x \\<le> length tsi \\<Longrightarrow>\n       (\\<forall>j<x. snd (tsi ! j) = ((map snd tsi)!j))\"\n  \"x < length tsi \\<Longrightarrow> snd (tsi!x) = ((map snd tsi)!x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> length tsi \\<Longrightarrow>\n     \\<forall>j<x. snd (tsi ! j) = separators tsi ! j) &&&\n    (x < length tsi \\<Longrightarrow> snd (tsi ! x) = separators tsi ! x)", "by auto"], ["", "lemma split_ismeq: \"((a::nat) \\<le> b \\<and> X) = ((a < b \\<and> X) \\<or> (a = b \\<and> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> b \\<and> X) = (a < b \\<and> X \\<or> a = b \\<and> X)", "by auto"], ["", "lemma split_relation_map: \"split_relation as (ls,rs) i \\<Longrightarrow> split_relation (map f as) (map f ls, map f rs) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split_relation as (ls, rs) i \\<Longrightarrow>\n    split_relation (map f as) (map f ls, map f rs) i", "apply(induction as arbitrary: ls rs i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ls rs i.\n       split_relation [] (ls, rs) i \\<Longrightarrow>\n       split_relation (map f []) (map f ls, map f rs) i\n 2. \\<And>a as ls rs i.\n       \\<lbrakk>\\<And>ls rs i.\n                   split_relation as (ls, rs) i \\<Longrightarrow>\n                   split_relation (map f as) (map f ls, map f rs) i;\n        split_relation (a # as) (ls, rs) i\\<rbrakk>\n       \\<Longrightarrow> split_relation (map f (a # as))\n                          (map f ls, map f rs) i", "apply(auto simp add: split_relation_def take_map drop_Cons')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length as \\<Longrightarrow>\n                   map f (drop i as) = drop i (map f as);\n        i \\<le> Suc (length as); 0 < i\\<rbrakk>\n       \\<Longrightarrow> map f (take i (a # as)) = take i (f a # map f as)", "apply(metis list.simps(9) take_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma split_relation_access: \"\\<lbrakk>split_relation as (ls,rs) i; rs = r#rrs\\<rbrakk> \\<Longrightarrow> as!i = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>split_relation as (ls, rs) i; rs = r # rrs\\<rbrakk>\n    \\<Longrightarrow> as ! i = r", "by (simp add: split_relation_alt)"], ["", "lemma index_to_elem_all: \"(\\<forall>j<length xs. P (xs!j)) = (\\<forall>x \\<in> set xs. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>j<length xs. P (xs ! j)) = (\\<forall>x\\<in>set xs. P x)", "by (simp add: all_set_conv_nth)"], ["", "lemma index_to_elem: \"n < length xs \\<Longrightarrow> (\\<forall>j<n. P (xs!j)) = (\\<forall>x \\<in> set (take n xs). P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow>\n    (\\<forall>j<n. P (xs ! j)) = (\\<forall>x\\<in>set (take n xs). P x)", "by (simp add: all_set_conv_nth)"], ["", "(* ----------------- *)"], ["", "definition split_half :: \"('a::heap \\<times> 'b::{heap}) pfarray \\<Rightarrow> nat Heap\"\n  where\n    \"split_half a \\<equiv> do {\n  l \\<leftarrow> pfa_length a;\n  return (l div 2)\n}\""], ["", "lemma split_half_rule[sep_heap_rules]: \"<\n    is_pfa c tsi a\n  * list_assn R ts tsi> \n    split_half a\n  <\\<lambda>i. \n      is_pfa c tsi a\n    * list_assn R ts tsi\n    * \\<up>(i = length ts div 2 \\<and>  split_relation ts (BTree_Set.split_half ts) i)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c tsi a * list_assn R ts tsi> BTree_ImpSet.split_half a\n    <\\<lambda>i.\n        is_pfa c tsi a * list_assn R ts tsi *\n        \\<up>\n         (i = length ts div 2 \\<and>\n          split_relation ts (BTree_Set.split_half ts) i)>", "unfolding split_half_def split_relation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c tsi a * list_assn R ts tsi>\n    pfa_length a \\<bind> (\\<lambda>l. return (l div 2))\n    <\\<lambda>i.\n        is_pfa c tsi a * list_assn R ts tsi *\n        \\<up>\n         (i = length ts div 2 \\<and>\n          (case BTree_Set.split_half ts of\n           (as, bs) \\<Rightarrow>\n             \\<lambda>i.\n                i \\<le> length ts \\<and>\n                as = take i ts \\<and> bs = drop i ts)\n           i)>", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> is_pfa c tsi a * list_assn R ts tsi \\<Longrightarrow>\n       <is_pfa c tsi a * list_assn R ts tsi>\n       pfa_length a \\<bind> (\\<lambda>l. return (l div 2))\n       <\\<lambda>i.\n           is_pfa c tsi a * list_assn R ts tsi *\n           \\<up>\n            (i = length ts div 2 \\<and>\n             (case BTree_Set.split_half ts of\n              (as, bs) \\<Rightarrow>\n                \\<lambda>i.\n                   i \\<le> length ts \\<and>\n                   as = take i ts \\<and> bs = drop i ts)\n              i)>", "apply(sep_auto dest!: list_assn_len mod_starD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"The imperative split locale\""], ["", "text \"This locale extends the abstract split locale,\nassuming that we are provided with an imperative program\nthat refines the abstract split function.\""], ["", "locale imp_split = abs_split: BTree_Set.split split\n  for split::\n    \"('a btree \\<times> 'a::{heap,default,linorder}) list \\<Rightarrow> 'a\n       \\<Rightarrow> ('a btree \\<times> 'a) list \\<times> ('a btree \\<times> 'a) list\" +\n  fixes imp_split:: \"('a btnode ref option \\<times> 'a::{heap,default,linorder}) pfarray \\<Rightarrow> 'a \\<Rightarrow> nat Heap\"\n  assumes imp_split_rule [sep_heap_rules]:\"sorted_less (separators ts) \\<Longrightarrow>\n   <is_pfa c tsi (a,n)\n  * blist_assn k ts tsi> \n    imp_split (a,n) p \n  <\\<lambda>i. \n    is_pfa c tsi (a,n)\n    * blist_assn k ts tsi\n    * \\<up>(split_relation ts (split ts p) i)>\\<^sub>t\"\nbegin"], ["", "subsection \"Membership\""], ["", "partial_function (heap) isin :: \"'a btnode ref option \\<Rightarrow> 'a \\<Rightarrow>  bool Heap\"\n  where\n    \"isin p x = \n  (case p of\n     None \\<Rightarrow> return False |\n     (Some a) \\<Rightarrow> do {\n       node \\<leftarrow> !a;\n       i \\<leftarrow> imp_split (kvs node) x;\n       tsl \\<leftarrow> pfa_length (kvs node);\n       if i < tsl then do {\n         s \\<leftarrow> pfa_get (kvs node) i;\n         let (sub,sep) = s in\n         if x = sep then\n           return True\n         else\n           isin sub x\n       } else\n           isin (last node) x\n    }\n)\""], ["", "subsection \"Insertion\""], ["", "datatype 'b btupi = \n  T\\<^sub>i \"'b btnode ref option\" |\n  Up\\<^sub>i \"'b btnode ref option\" \"'b\" \"'b btnode ref option\""], ["", "fun btupi_assn where\n  \"btupi_assn k (abs_split.T\\<^sub>i l) (T\\<^sub>i li) =\n   btree_assn k l li\" |\n  \"btupi_assn k (abs_split.Up\\<^sub>i l a r) (Up\\<^sub>i li ai ri) =\n   btree_assn k l li * id_assn a ai * btree_assn k r ri\" |\n  \"btupi_assn _ _ _ = false\""], ["", "definition node\\<^sub>i :: \"nat \\<Rightarrow> ('a btnode ref option \\<times> 'a) pfarray \\<Rightarrow> 'a btnode ref option \\<Rightarrow> 'a btupi Heap\" where\n  \"node\\<^sub>i k a ti \\<equiv> do {\n    n \\<leftarrow> pfa_length a;\n    if n \\<le> 2*k then do {\n      a' \\<leftarrow> pfa_shrink_cap (2*k) a;\n      l \\<leftarrow> ref (Btnode a' ti);\n      return (T\\<^sub>i (Some l))\n    }\n    else do {\n      b \\<leftarrow> (pfa_empty (2*k) :: ('a btnode ref option \\<times> 'a) pfarray Heap);\n      i \\<leftarrow> split_half a;\n      m \\<leftarrow> pfa_get a i;\n      b' \\<leftarrow> pfa_drop a (i+1) b;\n      a' \\<leftarrow> pfa_shrink i a;\n      a'' \\<leftarrow> pfa_shrink_cap (2*k) a';\n      let (sub,sep) = m in do {\n        l \\<leftarrow> ref (Btnode a'' sub);\n        r \\<leftarrow> ref (Btnode b' ti);\n        return (Up\\<^sub>i (Some l) sep (Some r))\n      }\n    }\n}\""], ["", "partial_function (heap) ins :: \"nat \\<Rightarrow> 'a \\<Rightarrow> 'a btnode ref option \\<Rightarrow> 'a btupi Heap\"\n  where\n    \"ins k x apo = (case apo of\n  None \\<Rightarrow> \n    return (Up\\<^sub>i None x None) |\n  (Some ap) \\<Rightarrow> do {\n    a \\<leftarrow> !ap;\n    i \\<leftarrow> imp_split (kvs a) x;\n    tsl \\<leftarrow> pfa_length (kvs a);\n    if i < tsl then do {\n      s \\<leftarrow> pfa_get (kvs a) i;\n      let (sub,sep) = s in\n      if sep = x then\n        return (T\\<^sub>i apo)\n      else do {\n        r \\<leftarrow> ins k x sub;\n        case r of \n          (T\\<^sub>i lp) \\<Rightarrow> do {\n            pfa_set (kvs a) i (lp,sep);\n            return (T\\<^sub>i apo)\n          } |\n          (Up\\<^sub>i lp x' rp) \\<Rightarrow> do {\n            pfa_set (kvs a) i (rp,sep);\n            if tsl < 2*k then do {\n                kvs' \\<leftarrow> pfa_insert (kvs a) i (lp,x');\n                ap := (Btnode kvs' (last a));\n                return (T\\<^sub>i apo)\n            } else do {\n              kvs' \\<leftarrow> pfa_insert_grow (kvs a) i (lp,x');\n              node\\<^sub>i k kvs' (last a)\n            }\n          }\n        }\n      }\n    else do {\n      r \\<leftarrow> ins k x (last a);\n      case r of \n        (T\\<^sub>i lp) \\<Rightarrow> do {\n          ap := (Btnode (kvs a) lp);\n          return (T\\<^sub>i apo)\n        } |\n        (Up\\<^sub>i lp x' rp) \\<Rightarrow> \n          if tsl < 2*k then do {\n            kvs' \\<leftarrow> pfa_append (kvs a) (lp,x');\n            ap := (Btnode kvs' rp);\n            return (T\\<^sub>i apo)\n          } else do {\n            kvs' \\<leftarrow> pfa_append_grow' (kvs a) (lp,x');\n            node\\<^sub>i k kvs' rp\n        }\n    }\n  }\n)\""], ["", "(*fun tree\\<^sub>i::\"'a up\\<^sub>i \\<Rightarrow> 'a btree\" where\n  \"tree\\<^sub>i (T\\<^sub>i sub) = sub\" |\n  \"tree\\<^sub>i (Up\\<^sub>i l a r) = (Node [(l,a)] r)\" \n\nfun insert::\"nat \\<Rightarrow> 'a \\<Rightarrow> 'a btree \\<Rightarrow> 'a btree\" where\n  \"insert k x t = tree\\<^sub>i (ins k x t)\"\n*)"], ["", "definition insert :: \"nat \\<Rightarrow> ('a::{heap,default,linorder}) \\<Rightarrow> 'a btnode ref option \\<Rightarrow> 'a btnode ref option Heap\" where\n  \"insert \\<equiv> \\<lambda>k x ti. do {\n  ti' \\<leftarrow> ins k x ti;\n  case ti' of\n     T\\<^sub>i sub \\<Rightarrow> return sub |\n     Up\\<^sub>i l a r \\<Rightarrow> do {\n        kvs \\<leftarrow> pfa_init (2*k) (l,a) 1;\n        t' \\<leftarrow> ref (Btnode kvs r);\n        return (Some t')\n      }\n}\""], ["", "subsection \"Deletion\""], ["", "text \"Note that the below operations have not been verified to\nrefine the abstract set operations.\""], ["", "(* rebalance middle tree gets a list of trees, an index pointing to\nthe position of sub/sep and a last tree *)"], ["", "definition rebalance_middle_tree:: \"nat \\<Rightarrow> (('a::{default,heap,linorder}) btnode ref option \\<times> 'a) pfarray \\<Rightarrow> nat \\<Rightarrow> 'a btnode ref option \\<Rightarrow> 'a btnode Heap\"\n  where\n    \"rebalance_middle_tree \\<equiv> \\<lambda> k tsi i r_ti. (\n  case r_ti of\n  None \\<Rightarrow> do {\n    return (Btnode tsi r_ti)\n  } |\n  Some p_t \\<Rightarrow> do {\n      ti \\<leftarrow> !p_t;\n      (r_sub,sep) \\<leftarrow> pfa_get tsi i;\n      case r_sub of (Some p_sub) \\<Rightarrow>  do {\n      sub \\<leftarrow> !p_sub;\n      l_sub \\<leftarrow> pfa_length (kvs sub);\n      l_tts \\<leftarrow> pfa_length (kvs ti);\n      if l_sub \\<ge> k \\<and> l_tts \\<ge> k then do {\n        return (Btnode tsi r_ti)\n      } else do {\n        l_tsi \\<leftarrow> pfa_length tsi;\n        if l_tsi = i then do {\n          mts' \\<leftarrow> pfa_append_extend_grow (kvs sub) (last sub,sep) (kvs ti);\n          res_node\\<^sub>i \\<leftarrow> node\\<^sub>i k mts' (last ti);\n          case res_node\\<^sub>i of\n            T\\<^sub>i u \\<Rightarrow> return (Btnode tsi u) |\n            Up\\<^sub>i l a r \\<Rightarrow> do {\n              tsi' \\<leftarrow> pfa_append tsi (l,a);\n              return (Btnode tsi' r)\n            }\n        } else do {\n          (r_rsub,rsep) \\<leftarrow> pfa_get tsi (i+1);\n          case r_rsub of Some p_rsub \\<Rightarrow> do {\n            rsub \\<leftarrow> !p_rsub;\n            mts' \\<leftarrow> pfa_append_extend_grow (kvs sub) (last sub,sep) (kvs rsub);\n            res_node\\<^sub>i \\<leftarrow> node\\<^sub>i k mts' (last rsub);\n            case res_node\\<^sub>i of\n             T\\<^sub>i u \\<Rightarrow> do {\n              tsi' \\<leftarrow> pfa_set tsi (i+1) (u,rsep);              \n              tsi'' \\<leftarrow> pfa_delete tsi' i;\n              return (Btnode tsi'' r_ti)\n            } |\n             Up\\<^sub>i l a r \\<Rightarrow> do {\n              tsi' \\<leftarrow> pfa_set tsi i (l,a);\n              tsi'' \\<leftarrow> pfa_set tsi' (i+1) (r,rsep);\n              return (Btnode tsi'' r_ti)\n            }\n          }\n        }\n      }\n  }\n})\n\""], ["", "definition rebalance_last_tree:: \"nat \\<Rightarrow> (('a::{default,heap,linorder}) btnode ref option \\<times> 'a) pfarray \\<Rightarrow> 'a btnode ref option \\<Rightarrow> 'a btnode Heap\"\n  where\n    \"rebalance_last_tree \\<equiv> \\<lambda>k tsi ti. do {\n   l_tsi \\<leftarrow> pfa_length tsi;\n   rebalance_middle_tree k tsi (l_tsi-1) ti\n}\""], ["", "partial_function (heap) split_max ::\"nat \\<Rightarrow> ('a::{default,heap,linorder}) btnode ref option \\<Rightarrow> ('a btnode ref option \\<times> 'a) Heap\"\n  where\n    \"split_max k r_t = (case r_t of Some p_t \\<Rightarrow> do {\n   t \\<leftarrow> !p_t;\n   (case t of Btnode tsi r_ti \\<Rightarrow>\n     case r_ti of None \\<Rightarrow> do {\n      (sub,sep) \\<leftarrow> pfa_last tsi;\n      tsi' \\<leftarrow> pfa_butlast tsi;\n      p_t := Btnode tsi' sub;\n      return (Some p_t, sep)\n  } |\n    _ \\<Rightarrow> do {\n      (sub,sep) \\<leftarrow> split_max k r_ti;\n      p_t' \\<leftarrow> rebalance_last_tree k tsi sub;\n      p_t := p_t';\n      return (Some p_t, sep)\n  })\n})\n\""], ["", "partial_function (heap) del ::\"nat \\<Rightarrow> 'a \\<Rightarrow> ('a::{default,heap,linorder}) btnode ref option \\<Rightarrow> 'a btnode ref option Heap\"\n  where\n    \"del k x ti = (case ti of None \\<Rightarrow> return None |\n   Some p \\<Rightarrow> do {\n   node \\<leftarrow> !p;\n   i \\<leftarrow> imp_split (kvs node) x;\n   tsl \\<leftarrow> pfa_length (kvs node);\n   if i < tsl then do {\n     s \\<leftarrow> pfa_get (kvs node) i;\n     let (sub,sep) = s in\n     if x \\<noteq> sep then do {\n       sub' \\<leftarrow> del k x sub;\n       kvs' \\<leftarrow> pfa_set (kvs node) i (sub',sep);\n       node' \\<leftarrow> rebalance_middle_tree k kvs' i (last node);\n       ti' \\<leftarrow> ref node';\n       return (Some ti')\n      }\n     else if sub = None then do{\n       pfa_delete (kvs node) i;\n       return ti\n     }\n     else do {\n        sm \\<leftarrow> split_max k sub;\n        kvs' \\<leftarrow> pfa_set (kvs node) i sm;\n        node' \\<leftarrow> rebalance_middle_tree k kvs' i (last node);\n        ti' \\<leftarrow> ref node';\n        return (Some ti')\n     }\n   } else do {\n       t' \\<leftarrow> del k x (last node);\n       node' \\<leftarrow> rebalance_last_tree k (kvs node) t';\n       ti' \\<leftarrow> ref node';\n       return (Some ti')\n    }\n})\n\""], ["", "partial_function (heap) reduce_root ::\"('a::{default,heap,linorder}) btnode ref option \\<Rightarrow> 'a btnode ref option Heap\"\n  where\n    \"reduce_root ti = (case ti of\n  None \\<Rightarrow> return None |\n  Some p_t \\<Rightarrow> do {\n    node \\<leftarrow> !p_t;\n    tsl \\<leftarrow> pfa_length (kvs node);\n    case tsl of 0 \\<Rightarrow> return (last node) |\n    _ \\<Rightarrow> return ti\n})\""], ["", "partial_function (heap) delete ::\"nat \\<Rightarrow> 'a \\<Rightarrow> ('a::{default,heap,linorder}) btnode ref option \\<Rightarrow> 'a btnode ref option Heap\"\n  where\n    \"delete k x ti = do {\n  ti' \\<leftarrow> del k x ti;\n  reduce_root ti'\n}\""], ["", "subsection \"Refinement of the abstract B-tree operations\""], ["", "definition empty ::\"('a::{default,heap,linorder}) btnode ref option Heap\"\n  where \"empty = return None\""], ["", "lemma P_imp_Q_implies_P: \"P \\<Longrightarrow> (Q \\<longrightarrow> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow> Q \\<longrightarrow> P", "by simp"], ["", "lemma  \"sorted_less (inorder t) \\<Longrightarrow>\n   <btree_assn k t ti>\n     isin ti x\n   <\\<lambda>r. btree_assn k t ti * \\<up>(abs_split.isin t x = r)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder t) \\<Longrightarrow>\n    <btree_assn k t\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k t ti * \\<up> (abs_split.isin t x = r)>\\<^sub>t", "proof(induction t x arbitrary: ti rule: abs_split.isin.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y ti.\n       sorted_less (inorder Leaf) \\<Longrightarrow>\n       <btree_assn k Leaf\n         ti> isin ti\n              y <\\<lambda>r.\n                    btree_assn k Leaf ti *\n                    \\<up> (abs_split.isin Leaf y = r)>\\<^sub>t\n 2. \\<And>ts t y ti.\n       \\<lbrakk>\\<And>x ya ti.\n                   \\<lbrakk>(x, ya) = split ts y; ya = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> isin ti\n      y <\\<lambda>r.\n            btree_assn k t ti * \\<up> (abs_split.isin t y = r)>\\<^sub>t;\n        \\<And>x ya x21 x22 xa yaa ti.\n           \\<lbrakk>(x, ya) = split ts y; ya = x21 # x22; (xa, yaa) = x21;\n            y \\<noteq> yaa; sorted_less (inorder xa)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xa\n                               ti> isin ti\n                                    y <\\<lambda>r.\n    btree_assn k xa ti * \\<up> (abs_split.isin xa y = r)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> isin ti\n                                y <\\<lambda>r.\nbtree_assn k (Node ts t) ti *\n\\<up> (abs_split.isin (Node ts t) y = r)>\\<^sub>t", "case (1 x)"], ["proof (state)\nthis:\n  sorted_less (inorder Leaf)\n\ngoal (2 subgoals):\n 1. \\<And>y ti.\n       sorted_less (inorder Leaf) \\<Longrightarrow>\n       <btree_assn k Leaf\n         ti> isin ti\n              y <\\<lambda>r.\n                    btree_assn k Leaf ti *\n                    \\<up> (abs_split.isin Leaf y = r)>\\<^sub>t\n 2. \\<And>ts t y ti.\n       \\<lbrakk>\\<And>x ya ti.\n                   \\<lbrakk>(x, ya) = split ts y; ya = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> isin ti\n      y <\\<lambda>r.\n            btree_assn k t ti * \\<up> (abs_split.isin t y = r)>\\<^sub>t;\n        \\<And>x ya x21 x22 xa yaa ti.\n           \\<lbrakk>(x, ya) = split ts y; ya = x21 # x22; (xa, yaa) = x21;\n            y \\<noteq> yaa; sorted_less (inorder xa)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xa\n                               ti> isin ti\n                                    y <\\<lambda>r.\n    btree_assn k xa ti * \\<up> (abs_split.isin xa y = r)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> isin ti\n                                y <\\<lambda>r.\nbtree_assn k (Node ts t) ti *\n\\<up> (abs_split.isin (Node ts t) y = r)>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  sorted_less (inorder Leaf)", "show ?case"], ["proof (prove)\nusing this:\n  sorted_less (inorder Leaf)\n\ngoal (1 subgoal):\n 1. <btree_assn k Leaf\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k Leaf ti *\n                 \\<up> (abs_split.isin Leaf x = r)>\\<^sub>t", "apply(subst isin.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder Leaf) \\<Longrightarrow>\n    <btree_assn k Leaf\n      ti> case ti of None \\<Rightarrow> return False\n          | Some a \\<Rightarrow>\n              !a \\<bind>\n              (\\<lambda>node.\n                  imp_split (kvs node) x \\<bind>\n                  (\\<lambda>i.\n                      pfa_length (kvs node) \\<bind>\n                      (\\<lambda>tsl.\n                          if i < tsl\n                          then pfa_get (kvs node) i \\<bind>\n                               (\\<lambda>s.\n                                   let (sub, sep) = s\n                                   in if x = sep then return True\nelse isin sub x)\n                          else isin (BTree_Imp.last node)\n                                x))) <\\<lambda>r.\n   btree_assn k Leaf ti * \\<up> (abs_split.isin Leaf x = r)>\\<^sub>t", "apply (cases ti)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_less (inorder Leaf); ti = None\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k Leaf\n                        ti> case ti of None \\<Rightarrow> return False\n                            | Some a \\<Rightarrow>\n                                !a \\<bind>\n                                (\\<lambda>node.\n                                    imp_split (kvs node) x \\<bind>\n                                    (\\<lambda>i.\n  pfa_length (kvs node) \\<bind>\n  (\\<lambda>tsl.\n      if i < tsl\n      then pfa_get (kvs node) i \\<bind>\n           (\\<lambda>s.\n               let (sub, sep) = s\n               in if x = sep then return True else isin sub x)\n      else isin (BTree_Imp.last node)\n            x))) <\\<lambda>r.\n                     btree_assn k Leaf ti *\n                     \\<up> (abs_split.isin Leaf x = r)>\\<^sub>t\n 2. \\<And>a.\n       \\<lbrakk>sorted_less (inorder Leaf); ti = Some a\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k Leaf\n                           ti> case ti of None \\<Rightarrow> return False\n                               | Some a \\<Rightarrow>\n                                   !a \\<bind>\n                                   (\\<lambda>node.\n imp_split (kvs node) x \\<bind>\n (\\<lambda>i.\n     pfa_length (kvs node) \\<bind>\n     (\\<lambda>tsl.\n         if i < tsl\n         then pfa_get (kvs node) i \\<bind>\n              (\\<lambda>s.\n                  let (sub, sep) = s\n                  in if x = sep then return True else isin sub x)\n         else isin (BTree_Imp.last node)\n               x))) <\\<lambda>r.\n                        btree_assn k Leaf ti *\n                        \\<up> (abs_split.isin Leaf x = r)>\\<^sub>t", "apply (auto simp add: return_cons_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <btree_assn k Leaf\n    ti> isin ti\n         x <\\<lambda>r.\n               btree_assn k Leaf ti *\n               \\<up> (abs_split.isin Leaf x = r)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>ts t y ti.\n       \\<lbrakk>\\<And>x ya ti.\n                   \\<lbrakk>(x, ya) = split ts y; ya = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> isin ti\n      y <\\<lambda>r.\n            btree_assn k t ti * \\<up> (abs_split.isin t y = r)>\\<^sub>t;\n        \\<And>x ya x21 x22 xa yaa ti.\n           \\<lbrakk>(x, ya) = split ts y; ya = x21 # x22; (xa, yaa) = x21;\n            y \\<noteq> yaa; sorted_less (inorder xa)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xa\n                               ti> isin ti\n                                    y <\\<lambda>r.\n    btree_assn k xa ti * \\<up> (abs_split.isin xa y = r)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> isin ti\n                                y <\\<lambda>r.\nbtree_assn k (Node ts t) ti *\n\\<up> (abs_split.isin (Node ts t) y = r)>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts t y ti.\n       \\<lbrakk>\\<And>x ya ti.\n                   \\<lbrakk>(x, ya) = split ts y; ya = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> isin ti\n      y <\\<lambda>r.\n            btree_assn k t ti * \\<up> (abs_split.isin t y = r)>\\<^sub>t;\n        \\<And>x ya x21 x22 xa yaa ti.\n           \\<lbrakk>(x, ya) = split ts y; ya = x21 # x22; (xa, yaa) = x21;\n            y \\<noteq> yaa; sorted_less (inorder xa)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xa\n                               ti> isin ti\n                                    y <\\<lambda>r.\n    btree_assn k xa ti * \\<up> (abs_split.isin xa y = r)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> isin ti\n                                y <\\<lambda>r.\nbtree_assn k (Node ts t) ti *\n\\<up> (abs_split.isin (Node ts t) y = r)>\\<^sub>t", "case (2 ts t x)"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = [];\n   sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> <btree_assn k t\n                      ?ti> isin ?ti\n                            x <\\<lambda>r.\n                                  btree_assn k t ?ti *\n                                  \\<up> (abs_split.isin t x = r)>\\<^sub>t\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = ?x21.0 # ?x22.0;\n   (?xa, ?yaa) = ?x21.0; x \\<noteq> ?yaa; sorted_less (inorder ?xa)\\<rbrakk>\n  \\<Longrightarrow> <btree_assn k ?xa\n                      ?ti> isin ?ti\n                            x <\\<lambda>r.\n                                  btree_assn k ?xa ?ti *\n                                  \\<up> (abs_split.isin ?xa x = r)>\\<^sub>t\n  sorted_less (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>ts t y ti.\n       \\<lbrakk>\\<And>x ya ti.\n                   \\<lbrakk>(x, ya) = split ts y; ya = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> isin ti\n      y <\\<lambda>r.\n            btree_assn k t ti * \\<up> (abs_split.isin t y = r)>\\<^sub>t;\n        \\<And>x ya x21 x22 xa yaa ti.\n           \\<lbrakk>(x, ya) = split ts y; ya = x21 # x22; (xa, yaa) = x21;\n            y \\<noteq> yaa; sorted_less (inorder xa)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xa\n                               ti> isin ti\n                                    y <\\<lambda>r.\n    btree_assn k xa ti * \\<up> (abs_split.isin xa y = r)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> isin ti\n                                y <\\<lambda>r.\nbtree_assn k (Node ts t) ti *\n\\<up> (abs_split.isin (Node ts t) y = r)>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = [];\n   sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> <btree_assn k t\n                      ?ti> isin ?ti\n                            x <\\<lambda>r.\n                                  btree_assn k t ?ti *\n                                  \\<up> (abs_split.isin t x = r)>\\<^sub>t\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = ?x21.0 # ?x22.0;\n   (?xa, ?yaa) = ?x21.0; x \\<noteq> ?yaa; sorted_less (inorder ?xa)\\<rbrakk>\n  \\<Longrightarrow> <btree_assn k ?xa\n                      ?ti> isin ?ti\n                            x <\\<lambda>r.\n                                  btree_assn k ?xa ?ti *\n                                  \\<up> (abs_split.isin ?xa x = r)>\\<^sub>t\n  sorted_less (inorder (Node ts t))", "obtain ls rs where list_split[simp]: \"split ts x = (ls,rs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = [];\n   sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> <btree_assn k t\n                      ?ti> isin ?ti\n                            x <\\<lambda>r.\n                                  btree_assn k t ?ti *\n                                  \\<up> (abs_split.isin t x = r)>\\<^sub>t\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = ?x21.0 # ?x22.0;\n   (?xa, ?yaa) = ?x21.0; x \\<noteq> ?yaa; sorted_less (inorder ?xa)\\<rbrakk>\n  \\<Longrightarrow> <btree_assn k ?xa\n                      ?ti> isin ?ti\n                            x <\\<lambda>r.\n                                  btree_assn k ?xa ?ti *\n                                  \\<up> (abs_split.isin ?xa x = r)>\\<^sub>t\n  sorted_less (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. (\\<And>ls rs.\n        split ts x = (ls, rs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split ts x\")"], ["proof (state)\nthis:\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. \\<And>ts t y ti.\n       \\<lbrakk>\\<And>x ya ti.\n                   \\<lbrakk>(x, ya) = split ts y; ya = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> isin ti\n      y <\\<lambda>r.\n            btree_assn k t ti * \\<up> (abs_split.isin t y = r)>\\<^sub>t;\n        \\<And>x ya x21 x22 xa yaa ti.\n           \\<lbrakk>(x, ya) = split ts y; ya = x21 # x22; (xa, yaa) = x21;\n            y \\<noteq> yaa; sorted_less (inorder xa)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xa\n                               ti> isin ti\n                                    y <\\<lambda>r.\n    btree_assn k xa ti * \\<up> (abs_split.isin xa y = r)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> isin ti\n                                y <\\<lambda>r.\nbtree_assn k (Node ts t) ti *\n\\<up> (abs_split.isin (Node ts t) y = r)>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  split ts x = (ls, rs)", "show ?case"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "proof (cases rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, rs); rs = []\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> isin ti\n                             x <\\<lambda>r.\n                                   btree_assn k (Node ts t) ti *\n                                   \\<up>\n                                    (abs_split.isin (Node ts t) x =\n                                     r)>\\<^sub>t\n 2. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> isin ti\n                                x <\\<lambda>r.\nbtree_assn k (Node ts t) ti *\n\\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "(* NOTE: induction condition trivial here *)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, rs); rs = []\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> isin ti\n                             x <\\<lambda>r.\n                                   btree_assn k (Node ts t) ti *\n                                   \\<up>\n                                    (abs_split.isin (Node ts t) x =\n                                     r)>\\<^sub>t\n 2. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> isin ti\n                                x <\\<lambda>r.\nbtree_assn k (Node ts t) ti *\n\\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "case [simp]: Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, rs); rs = []\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> isin ti\n                             x <\\<lambda>r.\n                                   btree_assn k (Node ts t) ti *\n                                   \\<up>\n                                    (abs_split.isin (Node ts t) x =\n                                     r)>\\<^sub>t\n 2. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> isin ti\n                                x <\\<lambda>r.\nbtree_assn k (Node ts t) ti *\n\\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "apply(subst isin.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> case ti of None \\<Rightarrow> return False\n          | Some a \\<Rightarrow>\n              !a \\<bind>\n              (\\<lambda>node.\n                  imp_split (kvs node) x \\<bind>\n                  (\\<lambda>i.\n                      pfa_length (kvs node) \\<bind>\n                      (\\<lambda>tsl.\n                          if i < tsl\n                          then pfa_get (kvs node) i \\<bind>\n                               (\\<lambda>s.\n                                   let (sub, sep) = s\n                                   in if x = sep then return True\nelse isin sub x)\n                          else isin (BTree_Imp.last node)\n                                x))) <\\<lambda>r.\n   btree_assn k (Node ts t) ti *\n   \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. ti = Some x \\<Longrightarrow> sorted_less (separators ts)\n 2. \\<And>x tsi ti tsi' xaa xb.\n       \\<lbrakk>ti = Some x; xaa = Btnode tsi ti\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' tsi * blist_assn k ts tsi' *\n                          \\<up> (split_relation ts (split ts x) xb) *\n                          true *\n                          (x \\<mapsto>\\<^sub>r xaa * btree_assn k t ti)>\n                         pfa_length tsi \\<bind>\n                         (\\<lambda>tsl.\n                             if xb < tsl\n                             then pfa_get tsi xb \\<bind>\n                                  (\\<lambda>(sub, sep).\nif x = sep then return True else isin sub x)\n                             else isin ti x)\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin t x = r)>", "using \"2.prems\" sorted_inorder_separators"], ["proof (prove)\nusing this:\n  sorted_less (inorder (Node ts t))\n  sorted_less (inorder (Node ?ts ?t)) \\<Longrightarrow>\n  sorted_less (separators ?ts)\n\ngoal (2 subgoals):\n 1. \\<And>x. ti = Some x \\<Longrightarrow> sorted_less (separators ts)\n 2. \\<And>x tsi ti tsi' xaa xb.\n       \\<lbrakk>ti = Some x; xaa = Btnode tsi ti\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' tsi * blist_assn k ts tsi' *\n                          \\<up> (split_relation ts (split ts x) xb) *\n                          true *\n                          (x \\<mapsto>\\<^sub>r xaa * btree_assn k t ti)>\n                         pfa_length tsi \\<bind>\n                         (\\<lambda>tsl.\n                             if xb < tsl\n                             then pfa_get tsi xb \\<bind>\n                                  (\\<lambda>(sub, sep).\nif x = sep then return True else isin sub x)\n                             else isin ti x)\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin t x = r)>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi' xaa xb.\n       \\<lbrakk>ti = Some x; xaa = Btnode tsi ti\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' tsi * blist_assn k ts tsi' *\n                          \\<up> (split_relation ts (split ts x) xb) *\n                          true *\n                          (x \\<mapsto>\\<^sub>r xaa * btree_assn k t ti)>\n                         pfa_length tsi \\<bind>\n                         (\\<lambda>tsl.\n                             if xb < tsl\n                             then pfa_get tsi xb \\<bind>\n                                  (\\<lambda>(sub, sep).\nif x = sep then return True else isin sub x)\n                             else isin ti x)\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin t x = r)>", "apply(auto simp add: split_relation_def dest!: sym[of \"[]\"] mod_starD list_assn_len)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b ti tsi'.\n       \\<lbrakk>ti = Some x; ls = ts\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          (x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                           btree_assn k t ti) *\n                          true>\n                         pfa_length (a, b) \\<bind>\n                         (\\<lambda>tsl.\n                             if length ts < tsl\n                             then pfa_get (a, b) (length ts) \\<bind>\n                                  (\\<lambda>(sub, sep).\nif x = sep then return True else isin sub x)\n                             else isin ti x)\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin t x = r)>", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b ti tsi' h.\n       \\<lbrakk>ti = Some x; ls = ts;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi' (a, b) * blist_assn k ts tsi' *\n        (x \\<mapsto>\\<^sub>r Btnode (a, b) ti * btree_assn k t ti) *\n        true\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          (x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                           btree_assn k t ti) *\n                          true>\n                         pfa_length (a, b) \\<bind>\n                         (\\<lambda>tsl.\n                             if length ts < tsl\n                             then pfa_get (a, b) (length ts) \\<bind>\n                                  (\\<lambda>(sub, sep).\nif x = sep then return True else isin sub x)\n                             else isin ti x)\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin t x = r)>", "apply(auto simp add: split_relation_def dest!: sym[of \"[]\"] mod_starD list_assn_len)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b ti tsi' ac bc af bf ag bg ai bi.\n       \\<lbrakk>ti = Some x; ls = ts; in_range (ac, bc);\n        (af, bf) \\<Turnstile> is_pfa (2 * k) tsi' (a, b);\n        length ts = length tsi';\n        (ag, bg) \\<Turnstile> x \\<mapsto>\\<^sub>r Btnode (a, b) ti;\n        (ai, bi) \\<Turnstile> btree_assn k t ti\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          (x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                           btree_assn k t ti) *\n                          true>\n                         pfa_length (a, b) \\<bind>\n                         (\\<lambda>tsl.\n                             if length tsi' < tsl\n                             then pfa_get (a, b) (length ts) \\<bind>\n                                  (\\<lambda>(sub, sep).\nif x = sep then return True else isin sub x)\n                             else isin ti x)\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin t x = r)>", "using 2(3)"], ["proof (prove)\nusing this:\n  sorted_less (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>x a b ti tsi' ac bc af bf ag bg ai bi.\n       \\<lbrakk>ti = Some x; ls = ts; in_range (ac, bc);\n        (af, bf) \\<Turnstile> is_pfa (2 * k) tsi' (a, b);\n        length ts = length tsi';\n        (ag, bg) \\<Turnstile> x \\<mapsto>\\<^sub>r Btnode (a, b) ti;\n        (ai, bi) \\<Turnstile> btree_assn k t ti\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          (x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                           btree_assn k t ti) *\n                          true>\n                         pfa_length (a, b) \\<bind>\n                         (\\<lambda>tsl.\n                             if length tsi' < tsl\n                             then pfa_get (a, b) (length ts) \\<bind>\n                                  (\\<lambda>(sub, sep).\nif x = sep then return True else isin sub x)\n                             else isin ti x)\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin t x = r)>", "apply(sep_auto heap: \"2.IH\"(1)[of ls \"[]\"] simp add: sorted_wrt_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> isin ti\n         x <\\<lambda>r.\n               btree_assn k (Node ts t) ti *\n               \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> isin ti\n                                x <\\<lambda>r.\nbtree_assn k (Node ts t) ti *\n\\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> isin ti\n                                x <\\<lambda>r.\nbtree_assn k (Node ts t) ti *\n\\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "case [simp]: (Cons h rrs)"], ["proof (state)\nthis:\n  rs = h # rrs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> isin ti\n                                x <\\<lambda>r.\nbtree_assn k (Node ts t) ti *\n\\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "obtain sub sep where h_split[simp]: \"h = (sub,sep)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        h = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases h)"], ["proof (state)\nthis:\n  h = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> isin ti\n                                x <\\<lambda>r.\nbtree_assn k (Node ts t) ti *\n\\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "proof (cases \"sep = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sep = x \\<Longrightarrow>\n    <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t\n 2. sep \\<noteq> x \\<Longrightarrow>\n    <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "(* NOTE: no induction required here, only vacuous counter cases generated *)"], ["proof (state)\ngoal (2 subgoals):\n 1. sep = x \\<Longrightarrow>\n    <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t\n 2. sep \\<noteq> x \\<Longrightarrow>\n    <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "case [simp]: True"], ["proof (state)\nthis:\n  sep = x\n\ngoal (2 subgoals):\n 1. sep = x \\<Longrightarrow>\n    <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t\n 2. sep \\<noteq> x \\<Longrightarrow>\n    <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  sep = x", "show ?thesis"], ["proof (prove)\nusing this:\n  sep = x\n\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "apply(simp split: list.splits prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t) ti> isin ti x\n    <\\<lambda>r. btree_assn k (Node ts t) ti * true * \\<up> r>", "apply(subst isin.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t) ti>\n    case ti of None \\<Rightarrow> return False\n    | Some a \\<Rightarrow>\n        !a \\<bind>\n        (\\<lambda>node.\n            imp_split (kvs node) x \\<bind>\n            (\\<lambda>i.\n                pfa_length (kvs node) \\<bind>\n                (\\<lambda>tsl.\n                    if i < tsl\n                    then pfa_get (kvs node) i \\<bind>\n                         (\\<lambda>s.\n                             let (sub, sep) = s\n                             in if x = sep then return True else isin sub x)\n                    else isin (BTree_Imp.last node) x)))\n    <\\<lambda>r. btree_assn k (Node ts t) ti * true * \\<up> r>", "using \"2.prems\" sorted_inorder_separators"], ["proof (prove)\nusing this:\n  sorted_less (inorder (Node ts t))\n  sorted_less (inorder (Node ?ts ?t)) \\<Longrightarrow>\n  sorted_less (separators ?ts)\n\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t) ti>\n    case ti of None \\<Rightarrow> return False\n    | Some a \\<Rightarrow>\n        !a \\<bind>\n        (\\<lambda>node.\n            imp_split (kvs node) x \\<bind>\n            (\\<lambda>i.\n                pfa_length (kvs node) \\<bind>\n                (\\<lambda>tsl.\n                    if i < tsl\n                    then pfa_get (kvs node) i \\<bind>\n                         (\\<lambda>s.\n                             let (sub, sep) = s\n                             in if x = sep then return True else isin sub x)\n                    else isin (BTree_Imp.last node) x)))\n    <\\<lambda>r. btree_assn k (Node ts t) ti * true * \\<up> r>", "apply(sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b ti tsi' xb suba sep.\n       \\<lbrakk>sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, x) # rrs) xb;\n        xb < length tsi'; tsi' ! xb = (suba, sep); x \\<noteq> sep\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin suba x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> r>\n 2. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, x) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> r>", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b ti tsi' xb suba sep h.\n       \\<lbrakk>sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, x) # rrs) xb;\n        xb < length tsi'; tsi' ! xb = (suba, sep); x \\<noteq> sep;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi' (a, b) * blist_assn k ts tsi' *\n        x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n        btree_assn k t ti *\n        true\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin suba x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> r>\n 2. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, x) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> r>", "apply(auto simp add: split_relation_alt list_assn_append_Cons_left dest!: mod_starD list_assn_len)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, x) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> r>", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b ti tsi' xb xaa h.\n       \\<lbrakk>sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, x) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi';\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi' (a, b) * blist_assn k ts tsi' *\n        x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n        btree_assn k t ti *\n        true\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> r>", "apply(auto simp add: split_relation_def dest!: sym[of \"[]\"] mod_starD list_assn_len)[]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> isin ti\n         x <\\<lambda>r.\n               btree_assn k (Node ts t) ti *\n               \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "case [simp]: False"], ["proof (state)\nthis:\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> isin ti\n           x <\\<lambda>r.\n                 btree_assn k (Node ts t) ti *\n                 \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t", "apply(simp split: list.splits prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = sep \\<longrightarrow> <btree_assn k (Node ts t) ti> isin ti sep\n     <\\<lambda>r. btree_assn k (Node ts t) ti * true * \\<up> r>) \\<and>\n    (x \\<noteq> sep \\<longrightarrow> <btree_assn k (Node ts t) ti>\n     isin ti x\n     <\\<lambda>r.\n         btree_assn k (Node ts t) ti * true *\n         \\<up> (abs_split.isin sub x = r)>)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = sep \\<Longrightarrow>\n    <btree_assn k (Node ts t) ti> isin ti sep\n    <\\<lambda>r. btree_assn k (Node ts t) ti * true * \\<up> r>\n 2. x \\<noteq> sep \\<Longrightarrow>\n    <btree_assn k (Node ts t) ti> isin ti x\n    <\\<lambda>r.\n        btree_assn k (Node ts t) ti * true *\n        \\<up> (abs_split.isin sub x = r)>", "using False"], ["proof (prove)\nusing this:\n  sep \\<noteq> x\n\ngoal (2 subgoals):\n 1. x = sep \\<Longrightarrow>\n    <btree_assn k (Node ts t) ti> isin ti sep\n    <\\<lambda>r. btree_assn k (Node ts t) ti * true * \\<up> r>\n 2. x \\<noteq> sep \\<Longrightarrow>\n    <btree_assn k (Node ts t) ti> isin ti x\n    <\\<lambda>r.\n        btree_assn k (Node ts t) ti * true *\n        \\<up> (abs_split.isin sub x = r)>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> sep \\<Longrightarrow>\n    <btree_assn k (Node ts t) ti> isin ti x\n    <\\<lambda>r.\n        btree_assn k (Node ts t) ti * true *\n        \\<up> (abs_split.isin sub x = r)>", "apply(subst isin.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> sep \\<Longrightarrow>\n    <btree_assn k (Node ts t) ti>\n    case ti of None \\<Rightarrow> return False\n    | Some a \\<Rightarrow>\n        !a \\<bind>\n        (\\<lambda>node.\n            imp_split (kvs node) x \\<bind>\n            (\\<lambda>i.\n                pfa_length (kvs node) \\<bind>\n                (\\<lambda>tsl.\n                    if i < tsl\n                    then pfa_get (kvs node) i \\<bind>\n                         (\\<lambda>s.\n                             let (sub, sep) = s\n                             in if x = sep then return True else isin sub x)\n                    else isin (BTree_Imp.last node) x)))\n    <\\<lambda>r.\n        btree_assn k (Node ts t) ti * true *\n        \\<up> (abs_split.isin sub x = r)>", "using \"2.prems\" sorted_inorder_separators"], ["proof (prove)\nusing this:\n  sorted_less (inorder (Node ts t))\n  sorted_less (inorder (Node ?ts ?t)) \\<Longrightarrow>\n  sorted_less (separators ?ts)\n\ngoal (1 subgoal):\n 1. x \\<noteq> sep \\<Longrightarrow>\n    <btree_assn k (Node ts t) ti>\n    case ti of None \\<Rightarrow> return False\n    | Some a \\<Rightarrow>\n        !a \\<bind>\n        (\\<lambda>node.\n            imp_split (kvs node) x \\<bind>\n            (\\<lambda>i.\n                pfa_length (kvs node) \\<bind>\n                (\\<lambda>tsl.\n                    if i < tsl\n                    then pfa_get (kvs node) i \\<bind>\n                         (\\<lambda>s.\n                             let (sub, sep) = s\n                             in if x = sep then return True else isin sub x)\n                    else isin (BTree_Imp.last node) x)))\n    <\\<lambda>r.\n        btree_assn k (Node ts t) ti * true *\n        \\<up> (abs_split.isin sub x = r)>", "apply(sep_auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a b ti tsi' xb suba xd aa ba.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xb < length tsi'; tsi' ! xb = (suba, x); xd;\n        (aa, ba) \\<Turnstile>\n        is_pfa (2 * k) tsi' (a, b) * blist_assn k ts tsi' *\n        x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n        btree_assn k t ti *\n        true\\<rbrakk>\n       \\<Longrightarrow> abs_split.isin sub x\n 2. \\<And>x a b ti tsi' xb xaa xc suba sepa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; xb < length tsi'; tsi' ! xb = (suba, sepa);\n        xc = (suba, sepa); x \\<noteq> sepa\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin suba x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>\n 3. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>", "(*eliminate vacuous case*)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a b ti tsi' xb suba xd aa ba.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xb < length tsi'; tsi' ! xb = (suba, x); xd;\n        (aa, ba) \\<Turnstile>\n        is_pfa (2 * k) tsi' (a, b) * blist_assn k ts tsi' *\n        x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n        btree_assn k t ti *\n        true\\<rbrakk>\n       \\<Longrightarrow> abs_split.isin sub x\n 2. \\<And>x a b ti tsi' xb xaa xc suba sepa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; xb < length tsi'; tsi' ! xb = (suba, sepa);\n        xc = (suba, sepa); x \\<noteq> sepa\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin suba x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>\n 3. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>", "apply(auto simp add: split_relation_alt list_assn_append_Cons_left dest!:  mod_starD list_assn_len)[]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b ti tsi' xb xaa xc suba sepa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; xb < length tsi'; tsi' ! xb = (suba, sepa);\n        xc = (suba, sepa); x \\<noteq> sepa\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin suba x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>\n 2. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>", "(* simplify towards induction step *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b ti tsi' xb xaa xc suba sepa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; xb < length tsi'; tsi' ! xb = (suba, sepa);\n        xc = (suba, sepa); x \\<noteq> sepa\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin suba x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>\n 2. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>", "apply(auto simp add: split_relation_alt list_assn_append_Cons_left dest!: mod_starD list_assn_len)[]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b ti tsi' suba sepa.\n       \\<lbrakk>x \\<noteq> sep;\n        sorted_less\n         (inorder_list ls @\n          inorder sub @ sep # inorder_list rrs @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; ts = ls @ (sub, sep) # rrs; length ls < length tsi';\n        tsi' ! length ls = (suba, sepa); x \\<noteq> sepa\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Azs1 z zs2.\n                             is_pfa (2 * k) tsi' (a, b) *\n                             (blist_assn k ls zs1 *\n                              (btree_assn k \\<times>\\<^sub>a id_assn)\n                               (sub, sep) z *\n                              blist_assn k rrs zs2) *\n                             x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                             btree_assn k t ti *\n                             true *\n                             \\<up> (zs1 @ z # zs2 = tsi')>\n                         isin suba x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi' zs1 z zs2.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                (blist_assn k ls zs1 *\n                                 (btree_assn k \\<times>\\<^sub>a id_assn)\n                                  (sub, sep) z *\n                                 blist_assn k rrs zs2) *\n                                true *\n                                \\<up>\n                                 (zs1 @ z # zs2 = tsi' \\<and>\n                                  abs_split.isin sub x = r)>\n 2. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>", "(* NOTE show that z = (suba, sepa) *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b ti tsi' suba sepa.\n       \\<lbrakk>x \\<noteq> sep;\n        sorted_less\n         (inorder_list ls @\n          inorder sub @ sep # inorder_list rrs @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; ts = ls @ (sub, sep) # rrs; length ls < length tsi';\n        tsi' ! length ls = (suba, sepa); x \\<noteq> sepa\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Azs1 z zs2.\n                             is_pfa (2 * k) tsi' (a, b) *\n                             (blist_assn k ls zs1 *\n                              (btree_assn k \\<times>\\<^sub>a id_assn)\n                               (sub, sep) z *\n                              blist_assn k rrs zs2) *\n                             x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                             btree_assn k t ti *\n                             true *\n                             \\<up> (zs1 @ z # zs2 = tsi')>\n                         isin suba x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi' zs1 z zs2.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                (blist_assn k ls zs1 *\n                                 (btree_assn k \\<times>\\<^sub>a id_assn)\n                                  (sub, sep) z *\n                                 blist_assn k rrs zs2) *\n                                true *\n                                \\<up>\n                                 (zs1 @ z # zs2 = tsi' \\<and>\n                                  abs_split.isin sub x = r)>\n 2. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>", "apply(rule norm_pre_ex_rule)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b ti tsi' suba sepa zs1 z zs2.\n       \\<lbrakk>x \\<noteq> sep;\n        sorted_less\n         (inorder_list ls @\n          inorder sub @ sep # inorder_list rrs @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; ts = ls @ (sub, sep) # rrs; length ls < length tsi';\n        tsi' ! length ls = (suba, sepa); x \\<noteq> sepa\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          (blist_assn k ls zs1 *\n                           (btree_assn k \\<times>\\<^sub>a id_assn)\n                            (sub, sep) z *\n                           blist_assn k rrs zs2) *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true *\n                          \\<up> (zs1 @ z # zs2 = tsi')>\n                         isin suba x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi' zs1 z zs2.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                (blist_assn k ls zs1 *\n                                 (btree_assn k \\<times>\\<^sub>a id_assn)\n                                  (sub, sep) z *\n                                 blist_assn k rrs zs2) *\n                                true *\n                                \\<up>\n                                 (zs1 @ z # zs2 = tsi' \\<and>\n                                  abs_split.isin sub x = r)>\n 2. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b ti tsi' suba sepa zs1 z zs2 h.\n       \\<lbrakk>x \\<noteq> sep;\n        sorted_less\n         (inorder_list ls @\n          inorder sub @ sep # inorder_list rrs @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; ts = ls @ (sub, sep) # rrs; length ls < length tsi';\n        tsi' ! length ls = (suba, sepa); x \\<noteq> sepa;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi' (a, b) *\n        (blist_assn k ls zs1 *\n         (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n         blist_assn k rrs zs2) *\n        x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n        btree_assn k t ti *\n        true *\n        \\<up> (zs1 @ z # zs2 = tsi')\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          (blist_assn k ls zs1 *\n                           (btree_assn k \\<times>\\<^sub>a id_assn)\n                            (sub, sep) z *\n                           blist_assn k rrs zs2) *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true *\n                          \\<up> (zs1 @ z # zs2 = tsi')>\n                         isin suba x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi' zs1 z zs2.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                (blist_assn k ls zs1 *\n                                 (btree_assn k \\<times>\\<^sub>a id_assn)\n                                  (sub, sep) z *\n                                 blist_assn k rrs zs2) *\n                                true *\n                                \\<up>\n                                 (zs1 @ z # zs2 = tsi' \\<and>\n                                  abs_split.isin sub x = r)>\n 2. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>", "subgoal for p tsi n ti xsi suba sepa zs1 z zs2 _"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true *\n     \\<up> (zs1 @ z # zs2 = xsi)\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) xsi (tsi, n) *\n                       (blist_assn k ls zs1 *\n                        (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep)\n                         z *\n                        blist_assn k rrs zs2) *\n                       p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                       btree_assn k t ti *\n                       true *\n                       \\<up> (zs1 @ z # zs2 = xsi)>\n                      isin suba x\n                      <\\<lambda>r.\n                          \\<exists>\\<^sub>Atsi ti tsi' zs1 z zs2.\n                             p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                             btree_assn k t ti *\n                             is_pfa (2 * k) tsi' tsi *\n                             (blist_assn k ls zs1 *\n                              (btree_assn k \\<times>\\<^sub>a id_assn)\n                               (sub, sep) z *\n                              blist_assn k rrs zs2) *\n                             true *\n                             \\<up>\n                              (zs1 @ z # zs2 = tsi' \\<and>\n                               abs_split.isin sub x = r)>", "apply(subgoal_tac \"z = (suba, sepa)\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 * (btree_assn k sub suba * id_assn sep sepa) *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true \\<and>\n     zs1 @ (suba, sepa) # zs2 = xsi;\n     z = (suba, sepa)\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) xsi (tsi, n) *\n                       (blist_assn k ls zs1 *\n                        (btree_assn k sub suba * id_assn sep sepa) *\n                        blist_assn k rrs zs2) *\n                       p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                       btree_assn k t ti *\n                       true>\n                      isin suba x\n                      <\\<lambda>r.\n                          \\<exists>\\<^sub>Atsi ti tsi' zs1 z zs2.\n                             p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                             btree_assn k t ti *\n                             is_pfa (2 * k) tsi' tsi *\n                             (blist_assn k ls zs1 *\n                              (btree_assn k \\<times>\\<^sub>a id_assn)\n                               (sub, sep) z *\n                              blist_assn k rrs zs2) *\n                             true *\n                             \\<up>\n                              (zs1 @ z # zs2 = tsi' \\<and>\n                               abs_split.isin sub x = r)>\n 2. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true *\n     \\<up> (zs1 @ z # zs2 = xsi)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "using 2(3)"], ["proof (prove)\nusing this:\n  sorted_less (inorder (Node ts t))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 * (btree_assn k sub suba * id_assn sep sepa) *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true \\<and>\n     zs1 @ (suba, sepa) # zs2 = xsi;\n     z = (suba, sepa)\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) xsi (tsi, n) *\n                       (blist_assn k ls zs1 *\n                        (btree_assn k sub suba * id_assn sep sepa) *\n                        blist_assn k rrs zs2) *\n                       p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                       btree_assn k t ti *\n                       true>\n                      isin suba x\n                      <\\<lambda>r.\n                          \\<exists>\\<^sub>Atsi ti tsi' zs1 z zs2.\n                             p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                             btree_assn k t ti *\n                             is_pfa (2 * k) tsi' tsi *\n                             (blist_assn k ls zs1 *\n                              (btree_assn k \\<times>\\<^sub>a id_assn)\n                               (sub, sep) z *\n                              blist_assn k rrs zs2) *\n                             true *\n                             \\<up>\n                              (zs1 @ z # zs2 = tsi' \\<and>\n                               abs_split.isin sub x = r)>\n 2. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true *\n     \\<up> (zs1 @ z # zs2 = xsi)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "apply(sep_auto\n              heap:\"2.IH\"(2)[of ls rs h rrs sub sep]\n              simp add: sorted_wrt_append)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>x \\<noteq> sep;\n     \\<And>ts t.\n        sorted_less (inorder_list ts) \\<and>\n        sorted_less (inorder t) \\<and>\n        (\\<forall>y\\<in>set ts.\n            \\<forall>x.\n               (\\<exists>uu_ uua_.\n                   (uua_, uu_) = y \\<and>\n                   (x = uu_ \\<or>\n                    x \\<in> set (inorder uua_))) \\<longrightarrow>\n               (\\<forall>xa\\<in>set (inorder t). x < xa)) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa); x \\<noteq> sepa;\n     z = (suba, sepa); sorted_less (inorder_list ls);\n     h_ \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepa *\n     blist_assn k rrs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true;\n     xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n     \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                        {xa.\n                         \\<exists>uu_ uua_.\n                            (uua_, uu_) = x \\<and>\n                            (xa = uu_ \\<or>\n                             xa \\<in> set (inorder uua_))}) \\<union>\n                    set (inorder t).\n        sep < x;\n     sorted_less (inorder_list rrs); sorted_less (inorder t);\n     \\<forall>y\\<in>set rrs.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           (\\<forall>xa\\<in>set (inorder t). x < xa);\n     \\<forall>x\\<in>set (inorder sub).\n        x < sep \\<and>\n        (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                             {xa.\n                              \\<exists>uu_ uua_.\n                                 (uua_, uu_) = x \\<and>\n                                 (xa = uu_ \\<or>\n                                  xa \\<in> set (inorder uua_))}) \\<union>\n                         set (inorder t).\n            x < xa);\n     \\<forall>y\\<in>set ls.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           x < sep \\<and>\n           (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                            ((\\<Union>x\\<in>set rrs.\n                                 {xa.\n                                  \\<exists>uu_ uua_.\n                                     (uua_, uu_) = x \\<and>\n                                     (xa = uu_ \\<or>\nxa \\<in> set (inorder uua_))}) \\<union>\n                             set (inorder t)).\n               x < xa)\\<rbrakk>\n    \\<Longrightarrow> (ls, (sub, sep) # rrs) =\n                      split (ls @ (sub, sep) # rrs) x\n 2. \\<lbrakk>x \\<noteq> sep;\n     \\<And>ts t.\n        sorted_less (inorder_list ts) \\<and>\n        sorted_less (inorder t) \\<and>\n        (\\<forall>y\\<in>set ts.\n            \\<forall>x.\n               (\\<exists>uu_ uua_.\n                   (uua_, uu_) = y \\<and>\n                   (x = uu_ \\<or>\n                    x \\<in> set (inorder uua_))) \\<longrightarrow>\n               (\\<forall>xa\\<in>set (inorder t). x < xa)) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa); x \\<noteq> sepa;\n     z = (suba, sepa); sorted_less (inorder_list ls);\n     h_ \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepa *\n     blist_assn k rrs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true;\n     xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n     \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                        {xa.\n                         \\<exists>uu_ uua_.\n                            (uua_, uu_) = x \\<and>\n                            (xa = uu_ \\<or>\n                             xa \\<in> set (inorder uua_))}) \\<union>\n                    set (inorder t).\n        sep < x;\n     sorted_less (inorder_list rrs); sorted_less (inorder t);\n     \\<forall>y\\<in>set rrs.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           (\\<forall>xa\\<in>set (inorder t). x < xa);\n     \\<forall>x\\<in>set (inorder sub).\n        x < sep \\<and>\n        (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                             {xa.\n                              \\<exists>uu_ uua_.\n                                 (uua_, uu_) = x \\<and>\n                                 (xa = uu_ \\<or>\n                                  xa \\<in> set (inorder uua_))}) \\<union>\n                         set (inorder t).\n            x < xa);\n     \\<forall>y\\<in>set ls.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           x < sep \\<and>\n           (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                            ((\\<Union>x\\<in>set rrs.\n                                 {xa.\n                                  \\<exists>uu_ uua_.\n                                     (uua_, uu_) = x \\<and>\n                                     (xa = uu_ \\<or>\nxa \\<in> set (inorder uua_))}) \\<union>\n                             set (inorder t)).\n               x < xa)\\<rbrakk>\n    \\<Longrightarrow> rs = h # rrs\n 3. \\<lbrakk>x \\<noteq> sep;\n     \\<And>ts t.\n        sorted_less (inorder_list ts) \\<and>\n        sorted_less (inorder t) \\<and>\n        (\\<forall>y\\<in>set ts.\n            \\<forall>x.\n               (\\<exists>uu_ uua_.\n                   (uua_, uu_) = y \\<and>\n                   (x = uu_ \\<or>\n                    x \\<in> set (inorder uua_))) \\<longrightarrow>\n               (\\<forall>xa\\<in>set (inorder t). x < xa)) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa); x \\<noteq> sepa;\n     z = (suba, sepa); sorted_less (inorder_list ls);\n     h_ \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepa *\n     blist_assn k rrs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true;\n     xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n     \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                        {xa.\n                         \\<exists>uu_ uua_.\n                            (uua_, uu_) = x \\<and>\n                            (xa = uu_ \\<or>\n                             xa \\<in> set (inorder uua_))}) \\<union>\n                    set (inorder t).\n        sep < x;\n     sorted_less (inorder_list rrs); sorted_less (inorder t);\n     \\<forall>y\\<in>set rrs.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           (\\<forall>xa\\<in>set (inorder t). x < xa);\n     \\<forall>x\\<in>set (inorder sub).\n        x < sep \\<and>\n        (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                             {xa.\n                              \\<exists>uu_ uua_.\n                                 (uua_, uu_) = x \\<and>\n                                 (xa = uu_ \\<or>\n                                  xa \\<in> set (inorder uua_))}) \\<union>\n                         set (inorder t).\n            x < xa);\n     \\<forall>y\\<in>set ls.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           x < sep \\<and>\n           (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                            ((\\<Union>x\\<in>set rrs.\n                                 {xa.\n                                  \\<exists>uu_ uua_.\n                                     (uua_, uu_) = x \\<and>\n                                     (xa = uu_ \\<or>\nxa \\<in> set (inorder uua_))}) \\<union>\n                             set (inorder t)).\n               x < xa)\\<rbrakk>\n    \\<Longrightarrow> (sub, sep) = h\n 4. \\<lbrakk>x \\<noteq> sep;\n     \\<And>ts t.\n        sorted_less (inorder_list ts) \\<and>\n        sorted_less (inorder t) \\<and>\n        (\\<forall>y\\<in>set ts.\n            \\<forall>x.\n               (\\<exists>uu_ uua_.\n                   (uua_, uu_) = y \\<and>\n                   (x = uu_ \\<or>\n                    x \\<in> set (inorder uua_))) \\<longrightarrow>\n               (\\<forall>xa\\<in>set (inorder t). x < xa)) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa); x \\<noteq> sepa;\n     z = (suba, sepa); sorted_less (inorder_list ls);\n     h_ \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepa *\n     blist_assn k rrs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true;\n     xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n     \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                        {xa.\n                         \\<exists>uu_ uua_.\n                            (uua_, uu_) = x \\<and>\n                            (xa = uu_ \\<or>\n                             xa \\<in> set (inorder uua_))}) \\<union>\n                    set (inorder t).\n        sep < x;\n     sorted_less (inorder_list rrs); sorted_less (inorder t);\n     \\<forall>y\\<in>set rrs.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           (\\<forall>xa\\<in>set (inorder t). x < xa);\n     \\<forall>x\\<in>set (inorder sub).\n        x < sep \\<and>\n        (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                             {xa.\n                              \\<exists>uu_ uua_.\n                                 (uua_, uu_) = x \\<and>\n                                 (xa = uu_ \\<or>\n                                  xa \\<in> set (inorder uua_))}) \\<union>\n                         set (inorder t).\n            x < xa);\n     \\<forall>y\\<in>set ls.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           x < sep \\<and>\n           (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                            ((\\<Union>x\\<in>set rrs.\n                                 {xa.\n                                  \\<exists>uu_ uua_.\n                                     (uua_, uu_) = x \\<and>\n                                     (xa = uu_ \\<or>\nxa \\<in> set (inorder uua_))}) \\<union>\n                             set (inorder t)).\n               x < xa)\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> sep\n 5. \\<lbrakk>x \\<noteq> sep;\n     \\<And>ts t.\n        sorted_less (inorder_list ts) \\<and>\n        sorted_less (inorder t) \\<and>\n        (\\<forall>y\\<in>set ts.\n            \\<forall>x.\n               (\\<exists>uu_ uua_.\n                   (uua_, uu_) = y \\<and>\n                   (x = uu_ \\<or>\n                    x \\<in> set (inorder uua_))) \\<longrightarrow>\n               (\\<forall>xa\\<in>set (inorder t). x < xa)) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa); x \\<noteq> sepa;\n     z = (suba, sepa); sorted_less (inorder_list ls);\n     h_ \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepa *\n     blist_assn k rrs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true;\n     xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n     \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                        {xa.\n                         \\<exists>uu_ uua_.\n                            (uua_, uu_) = x \\<and>\n                            (xa = uu_ \\<or>\n                             xa \\<in> set (inorder uua_))}) \\<union>\n                    set (inorder t).\n        sep < x;\n     sorted_less (inorder_list rrs); sorted_less (inorder t);\n     \\<forall>y\\<in>set rrs.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           (\\<forall>xa\\<in>set (inorder t). x < xa);\n     \\<forall>x\\<in>set (inorder sub).\n        x < sep \\<and>\n        (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                             {xa.\n                              \\<exists>uu_ uua_.\n                                 (uua_, uu_) = x \\<and>\n                                 (xa = uu_ \\<or>\n                                  xa \\<in> set (inorder uua_))}) \\<union>\n                         set (inorder t).\n            x < xa);\n     \\<forall>y\\<in>set ls.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           x < sep \\<and>\n           (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                            ((\\<Union>x\\<in>set rrs.\n                                 {xa.\n                                  \\<exists>uu_ uua_.\n                                     (uua_, uu_) = x \\<and>\n                                     (xa = uu_ \\<or>\nxa \\<in> set (inorder uua_))}) \\<union>\n                             set (inorder t)).\n               x < xa)\\<rbrakk>\n    \\<Longrightarrow> sorted_less (inorder sub)\n 6. \\<And>x.\n       \\<lbrakk>x \\<noteq> sep;\n        \\<And>ts t.\n           sorted_less (inorder_list ts) \\<and>\n           sorted_less (inorder t) \\<and>\n           (\\<forall>y\\<in>set ts.\n               \\<forall>x.\n                  (\\<exists>uu_ uua_.\n                      (uua_, uu_) = y \\<and>\n                      (x = uu_ \\<or>\n                       x \\<in> set (inorder uua_))) \\<longrightarrow>\n                  (\\<forall>xa\\<in>set (inorder t).\n                      x < xa)) \\<Longrightarrow>\n           sorted_less (separators ts);\n        tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa);\n        x \\<noteq> sepa; z = (suba, sepa); sorted_less (inorder_list ls);\n        h_ \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepa *\n        blist_assn k rrs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n        btree_assn k t ti *\n        true;\n        xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n        \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                           {xa.\n                            \\<exists>uu_ uua_.\n                               (uua_, uu_) = x \\<and>\n                               (xa = uu_ \\<or>\n                                xa \\<in> set (inorder uua_))}) \\<union>\n                       set (inorder t).\n           sep < x;\n        sorted_less (inorder_list rrs); sorted_less (inorder t);\n        \\<forall>y\\<in>set rrs.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              (\\<forall>xa\\<in>set (inorder t). x < xa);\n        \\<forall>x\\<in>set (inorder sub).\n           x < sep \\<and>\n           (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                                {xa.\n                                 \\<exists>uu_ uua_.\n                                    (uua_, uu_) = x \\<and>\n                                    (xa = uu_ \\<or>\n                                     xa \\<in> set (inorder uua_))}) \\<union>\n                            set (inorder t).\n               x < xa);\n        \\<forall>y\\<in>set ls.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              x < sep \\<and>\n              (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                               ((\\<Union>x\\<in>set rrs.\n                                    {xa.\n                                     \\<exists>uu_ uua_.\n  (uua_, uu_) = x \\<and>\n  (xa = uu_ \\<or> xa \\<in> set (inorder uua_))}) \\<union>\n                                set (inorder t)).\n                  x < xa)\\<rbrakk>\n       \\<Longrightarrow> btree_assn k sub suba *\n                         \\<up> (abs_split.isin sub x = x) *\n                         true *\n                         (is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                           (tsi, n) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepa *\n                          blist_assn k rrs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                          btree_assn k t ti *\n                          true) \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Atsi ti tsi' zs1 z zs2.\n                            p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                            btree_assn k t ti *\n                            is_pfa (2 * k) tsi' tsi *\n                            blist_assn k ls zs1 *\n                            (btree_assn k \\<times>\\<^sub>a id_assn)\n                             (sub, sep) z *\n                            blist_assn k rrs zs2 *\n                            true *\n                            \\<up>\n                             (zs1 @ z # zs2 = tsi' \\<and>\n                              abs_split.isin sub x = x)\n 7. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true *\n     \\<up> (zs1 @ z # zs2 = xsi)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "using list_split Cons h_split"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  rs = h # rrs\n  h = (sub, sep)\n\ngoal (7 subgoals):\n 1. \\<lbrakk>x \\<noteq> sep;\n     \\<And>ts t.\n        sorted_less (inorder_list ts) \\<and>\n        sorted_less (inorder t) \\<and>\n        (\\<forall>y\\<in>set ts.\n            \\<forall>x.\n               (\\<exists>uu_ uua_.\n                   (uua_, uu_) = y \\<and>\n                   (x = uu_ \\<or>\n                    x \\<in> set (inorder uua_))) \\<longrightarrow>\n               (\\<forall>xa\\<in>set (inorder t). x < xa)) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa); x \\<noteq> sepa;\n     z = (suba, sepa); sorted_less (inorder_list ls);\n     h_ \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepa *\n     blist_assn k rrs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true;\n     xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n     \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                        {xa.\n                         \\<exists>uu_ uua_.\n                            (uua_, uu_) = x \\<and>\n                            (xa = uu_ \\<or>\n                             xa \\<in> set (inorder uua_))}) \\<union>\n                    set (inorder t).\n        sep < x;\n     sorted_less (inorder_list rrs); sorted_less (inorder t);\n     \\<forall>y\\<in>set rrs.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           (\\<forall>xa\\<in>set (inorder t). x < xa);\n     \\<forall>x\\<in>set (inorder sub).\n        x < sep \\<and>\n        (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                             {xa.\n                              \\<exists>uu_ uua_.\n                                 (uua_, uu_) = x \\<and>\n                                 (xa = uu_ \\<or>\n                                  xa \\<in> set (inorder uua_))}) \\<union>\n                         set (inorder t).\n            x < xa);\n     \\<forall>y\\<in>set ls.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           x < sep \\<and>\n           (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                            ((\\<Union>x\\<in>set rrs.\n                                 {xa.\n                                  \\<exists>uu_ uua_.\n                                     (uua_, uu_) = x \\<and>\n                                     (xa = uu_ \\<or>\nxa \\<in> set (inorder uua_))}) \\<union>\n                             set (inorder t)).\n               x < xa)\\<rbrakk>\n    \\<Longrightarrow> (ls, (sub, sep) # rrs) =\n                      split (ls @ (sub, sep) # rrs) x\n 2. \\<lbrakk>x \\<noteq> sep;\n     \\<And>ts t.\n        sorted_less (inorder_list ts) \\<and>\n        sorted_less (inorder t) \\<and>\n        (\\<forall>y\\<in>set ts.\n            \\<forall>x.\n               (\\<exists>uu_ uua_.\n                   (uua_, uu_) = y \\<and>\n                   (x = uu_ \\<or>\n                    x \\<in> set (inorder uua_))) \\<longrightarrow>\n               (\\<forall>xa\\<in>set (inorder t). x < xa)) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa); x \\<noteq> sepa;\n     z = (suba, sepa); sorted_less (inorder_list ls);\n     h_ \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepa *\n     blist_assn k rrs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true;\n     xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n     \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                        {xa.\n                         \\<exists>uu_ uua_.\n                            (uua_, uu_) = x \\<and>\n                            (xa = uu_ \\<or>\n                             xa \\<in> set (inorder uua_))}) \\<union>\n                    set (inorder t).\n        sep < x;\n     sorted_less (inorder_list rrs); sorted_less (inorder t);\n     \\<forall>y\\<in>set rrs.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           (\\<forall>xa\\<in>set (inorder t). x < xa);\n     \\<forall>x\\<in>set (inorder sub).\n        x < sep \\<and>\n        (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                             {xa.\n                              \\<exists>uu_ uua_.\n                                 (uua_, uu_) = x \\<and>\n                                 (xa = uu_ \\<or>\n                                  xa \\<in> set (inorder uua_))}) \\<union>\n                         set (inorder t).\n            x < xa);\n     \\<forall>y\\<in>set ls.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           x < sep \\<and>\n           (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                            ((\\<Union>x\\<in>set rrs.\n                                 {xa.\n                                  \\<exists>uu_ uua_.\n                                     (uua_, uu_) = x \\<and>\n                                     (xa = uu_ \\<or>\nxa \\<in> set (inorder uua_))}) \\<union>\n                             set (inorder t)).\n               x < xa)\\<rbrakk>\n    \\<Longrightarrow> rs = h # rrs\n 3. \\<lbrakk>x \\<noteq> sep;\n     \\<And>ts t.\n        sorted_less (inorder_list ts) \\<and>\n        sorted_less (inorder t) \\<and>\n        (\\<forall>y\\<in>set ts.\n            \\<forall>x.\n               (\\<exists>uu_ uua_.\n                   (uua_, uu_) = y \\<and>\n                   (x = uu_ \\<or>\n                    x \\<in> set (inorder uua_))) \\<longrightarrow>\n               (\\<forall>xa\\<in>set (inorder t). x < xa)) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa); x \\<noteq> sepa;\n     z = (suba, sepa); sorted_less (inorder_list ls);\n     h_ \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepa *\n     blist_assn k rrs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true;\n     xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n     \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                        {xa.\n                         \\<exists>uu_ uua_.\n                            (uua_, uu_) = x \\<and>\n                            (xa = uu_ \\<or>\n                             xa \\<in> set (inorder uua_))}) \\<union>\n                    set (inorder t).\n        sep < x;\n     sorted_less (inorder_list rrs); sorted_less (inorder t);\n     \\<forall>y\\<in>set rrs.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           (\\<forall>xa\\<in>set (inorder t). x < xa);\n     \\<forall>x\\<in>set (inorder sub).\n        x < sep \\<and>\n        (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                             {xa.\n                              \\<exists>uu_ uua_.\n                                 (uua_, uu_) = x \\<and>\n                                 (xa = uu_ \\<or>\n                                  xa \\<in> set (inorder uua_))}) \\<union>\n                         set (inorder t).\n            x < xa);\n     \\<forall>y\\<in>set ls.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           x < sep \\<and>\n           (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                            ((\\<Union>x\\<in>set rrs.\n                                 {xa.\n                                  \\<exists>uu_ uua_.\n                                     (uua_, uu_) = x \\<and>\n                                     (xa = uu_ \\<or>\nxa \\<in> set (inorder uua_))}) \\<union>\n                             set (inorder t)).\n               x < xa)\\<rbrakk>\n    \\<Longrightarrow> (sub, sep) = h\n 4. \\<lbrakk>x \\<noteq> sep;\n     \\<And>ts t.\n        sorted_less (inorder_list ts) \\<and>\n        sorted_less (inorder t) \\<and>\n        (\\<forall>y\\<in>set ts.\n            \\<forall>x.\n               (\\<exists>uu_ uua_.\n                   (uua_, uu_) = y \\<and>\n                   (x = uu_ \\<or>\n                    x \\<in> set (inorder uua_))) \\<longrightarrow>\n               (\\<forall>xa\\<in>set (inorder t). x < xa)) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa); x \\<noteq> sepa;\n     z = (suba, sepa); sorted_less (inorder_list ls);\n     h_ \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepa *\n     blist_assn k rrs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true;\n     xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n     \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                        {xa.\n                         \\<exists>uu_ uua_.\n                            (uua_, uu_) = x \\<and>\n                            (xa = uu_ \\<or>\n                             xa \\<in> set (inorder uua_))}) \\<union>\n                    set (inorder t).\n        sep < x;\n     sorted_less (inorder_list rrs); sorted_less (inorder t);\n     \\<forall>y\\<in>set rrs.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           (\\<forall>xa\\<in>set (inorder t). x < xa);\n     \\<forall>x\\<in>set (inorder sub).\n        x < sep \\<and>\n        (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                             {xa.\n                              \\<exists>uu_ uua_.\n                                 (uua_, uu_) = x \\<and>\n                                 (xa = uu_ \\<or>\n                                  xa \\<in> set (inorder uua_))}) \\<union>\n                         set (inorder t).\n            x < xa);\n     \\<forall>y\\<in>set ls.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           x < sep \\<and>\n           (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                            ((\\<Union>x\\<in>set rrs.\n                                 {xa.\n                                  \\<exists>uu_ uua_.\n                                     (uua_, uu_) = x \\<and>\n                                     (xa = uu_ \\<or>\nxa \\<in> set (inorder uua_))}) \\<union>\n                             set (inorder t)).\n               x < xa)\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> sep\n 5. \\<lbrakk>x \\<noteq> sep;\n     \\<And>ts t.\n        sorted_less (inorder_list ts) \\<and>\n        sorted_less (inorder t) \\<and>\n        (\\<forall>y\\<in>set ts.\n            \\<forall>x.\n               (\\<exists>uu_ uua_.\n                   (uua_, uu_) = y \\<and>\n                   (x = uu_ \\<or>\n                    x \\<in> set (inorder uua_))) \\<longrightarrow>\n               (\\<forall>xa\\<in>set (inorder t). x < xa)) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa); x \\<noteq> sepa;\n     z = (suba, sepa); sorted_less (inorder_list ls);\n     h_ \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepa *\n     blist_assn k rrs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true;\n     xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n     \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                        {xa.\n                         \\<exists>uu_ uua_.\n                            (uua_, uu_) = x \\<and>\n                            (xa = uu_ \\<or>\n                             xa \\<in> set (inorder uua_))}) \\<union>\n                    set (inorder t).\n        sep < x;\n     sorted_less (inorder_list rrs); sorted_less (inorder t);\n     \\<forall>y\\<in>set rrs.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           (\\<forall>xa\\<in>set (inorder t). x < xa);\n     \\<forall>x\\<in>set (inorder sub).\n        x < sep \\<and>\n        (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                             {xa.\n                              \\<exists>uu_ uua_.\n                                 (uua_, uu_) = x \\<and>\n                                 (xa = uu_ \\<or>\n                                  xa \\<in> set (inorder uua_))}) \\<union>\n                         set (inorder t).\n            x < xa);\n     \\<forall>y\\<in>set ls.\n        \\<forall>x.\n           (\\<exists>uu_ uua_.\n               (uua_, uu_) = y \\<and>\n               (x = uu_ \\<or> x \\<in> set (inorder uua_))) \\<longrightarrow>\n           x < sep \\<and>\n           (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                            ((\\<Union>x\\<in>set rrs.\n                                 {xa.\n                                  \\<exists>uu_ uua_.\n                                     (uua_, uu_) = x \\<and>\n                                     (xa = uu_ \\<or>\nxa \\<in> set (inorder uua_))}) \\<union>\n                             set (inorder t)).\n               x < xa)\\<rbrakk>\n    \\<Longrightarrow> sorted_less (inorder sub)\n 6. \\<And>x.\n       \\<lbrakk>x \\<noteq> sep;\n        \\<And>ts t.\n           sorted_less (inorder_list ts) \\<and>\n           sorted_less (inorder t) \\<and>\n           (\\<forall>y\\<in>set ts.\n               \\<forall>x.\n                  (\\<exists>uu_ uua_.\n                      (uua_, uu_) = y \\<and>\n                      (x = uu_ \\<or>\n                       x \\<in> set (inorder uua_))) \\<longrightarrow>\n                  (\\<forall>xa\\<in>set (inorder t).\n                      x < xa)) \\<Longrightarrow>\n           sorted_less (separators ts);\n        tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa);\n        x \\<noteq> sepa; z = (suba, sepa); sorted_less (inorder_list ls);\n        h_ \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepa *\n        blist_assn k rrs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n        btree_assn k t ti *\n        true;\n        xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n        \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                           {xa.\n                            \\<exists>uu_ uua_.\n                               (uua_, uu_) = x \\<and>\n                               (xa = uu_ \\<or>\n                                xa \\<in> set (inorder uua_))}) \\<union>\n                       set (inorder t).\n           sep < x;\n        sorted_less (inorder_list rrs); sorted_less (inorder t);\n        \\<forall>y\\<in>set rrs.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              (\\<forall>xa\\<in>set (inorder t). x < xa);\n        \\<forall>x\\<in>set (inorder sub).\n           x < sep \\<and>\n           (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                                {xa.\n                                 \\<exists>uu_ uua_.\n                                    (uua_, uu_) = x \\<and>\n                                    (xa = uu_ \\<or>\n                                     xa \\<in> set (inorder uua_))}) \\<union>\n                            set (inorder t).\n               x < xa);\n        \\<forall>y\\<in>set ls.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              x < sep \\<and>\n              (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                               ((\\<Union>x\\<in>set rrs.\n                                    {xa.\n                                     \\<exists>uu_ uua_.\n  (uua_, uu_) = x \\<and>\n  (xa = uu_ \\<or> xa \\<in> set (inorder uua_))}) \\<union>\n                                set (inorder t)).\n                  x < xa)\\<rbrakk>\n       \\<Longrightarrow> btree_assn k sub suba *\n                         \\<up> (abs_split.isin sub x = x) *\n                         true *\n                         (is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                           (tsi, n) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepa *\n                          blist_assn k rrs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                          btree_assn k t ti *\n                          true) \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Atsi ti tsi' zs1 z zs2.\n                            p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                            btree_assn k t ti *\n                            is_pfa (2 * k) tsi' tsi *\n                            blist_assn k ls zs1 *\n                            (btree_assn k \\<times>\\<^sub>a id_assn)\n                             (sub, sep) z *\n                            blist_assn k rrs zs2 *\n                            true *\n                            \\<up>\n                             (zs1 @ z # zs2 = tsi' \\<and>\n                              abs_split.isin sub x = x)\n 7. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true *\n     \\<up> (zs1 @ z # zs2 = xsi)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> sep;\n        \\<And>ts t.\n           sorted_less (inorder_list ts) \\<and>\n           sorted_less (inorder t) \\<and>\n           (\\<forall>y\\<in>set ts.\n               \\<forall>x.\n                  (\\<exists>uu_ uua_.\n                      (uua_, uu_) = y \\<and>\n                      (x = uu_ \\<or>\n                       x \\<in> set (inorder uua_))) \\<longrightarrow>\n                  (\\<forall>xa\\<in>set (inorder t).\n                      x < xa)) \\<Longrightarrow>\n           sorted_less (separators ts);\n        tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa);\n        x \\<noteq> sepa; z = (suba, sepa); sorted_less (inorder_list ls);\n        h_ \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepa *\n        blist_assn k rrs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n        btree_assn k t ti *\n        true;\n        xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n        \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                           {xa.\n                            \\<exists>uu_ uua_.\n                               (uua_, uu_) = x \\<and>\n                               (xa = uu_ \\<or>\n                                xa \\<in> set (inorder uua_))}) \\<union>\n                       set (inorder t).\n           sep < x;\n        sorted_less (inorder_list rrs); sorted_less (inorder t);\n        \\<forall>y\\<in>set rrs.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              (\\<forall>xa\\<in>set (inorder t). x < xa);\n        \\<forall>x\\<in>set (inorder sub).\n           x < sep \\<and>\n           (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                                {xa.\n                                 \\<exists>uu_ uua_.\n                                    (uua_, uu_) = x \\<and>\n                                    (xa = uu_ \\<or>\n                                     xa \\<in> set (inorder uua_))}) \\<union>\n                            set (inorder t).\n               x < xa);\n        \\<forall>y\\<in>set ls.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              x < sep \\<and>\n              (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                               ((\\<Union>x\\<in>set rrs.\n                                    {xa.\n                                     \\<exists>uu_ uua_.\n  (uua_, uu_) = x \\<and>\n  (xa = uu_ \\<or> xa \\<in> set (inorder uua_))}) \\<union>\n                                set (inorder t)).\n                  x < xa);\n        split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n       \\<Longrightarrow> abs_split.isin sub x = x \\<longrightarrow>\n                         (btree_assn k sub suba *\n                          (is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                            (tsi, n) *\n                           blist_assn k ls zs1 *\n                           id_assn sep sepa *\n                           blist_assn k rrs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                           btree_assn k t ti) *\n                          true \\<Longrightarrow>\\<^sub>A\n                          \\<exists>\\<^sub>Atsi ti tsi' zs1 z zs2.\n                             p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                             btree_assn k t ti *\n                             is_pfa (2 * k) tsi' tsi *\n                             blist_assn k ls zs1 *\n                             (btree_assn k \\<times>\\<^sub>a id_assn)\n                              (sub, sep) z *\n                             blist_assn k rrs zs2 *\n                             true *\n                             \\<up> (zs1 @ z # zs2 = tsi'))\n 2. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true \\<and>\n     zs1 @ z # zs2 = xsi;\n     split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "(* proof that previous assumptions hold later *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> sep;\n        \\<And>ts t.\n           sorted_less (inorder_list ts) \\<and>\n           sorted_less (inorder t) \\<and>\n           (\\<forall>y\\<in>set ts.\n               \\<forall>x.\n                  (\\<exists>uu_ uua_.\n                      (uua_, uu_) = y \\<and>\n                      (x = uu_ \\<or>\n                       x \\<in> set (inorder uua_))) \\<longrightarrow>\n                  (\\<forall>xa\\<in>set (inorder t).\n                      x < xa)) \\<Longrightarrow>\n           sorted_less (separators ts);\n        tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa);\n        x \\<noteq> sepa; z = (suba, sepa); sorted_less (inorder_list ls);\n        h_ \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepa *\n        blist_assn k rrs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n        btree_assn k t ti *\n        true;\n        xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n        \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                           {xa.\n                            \\<exists>uu_ uua_.\n                               (uua_, uu_) = x \\<and>\n                               (xa = uu_ \\<or>\n                                xa \\<in> set (inorder uua_))}) \\<union>\n                       set (inorder t).\n           sep < x;\n        sorted_less (inorder_list rrs); sorted_less (inorder t);\n        \\<forall>y\\<in>set rrs.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              (\\<forall>xa\\<in>set (inorder t). x < xa);\n        \\<forall>x\\<in>set (inorder sub).\n           x < sep \\<and>\n           (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                                {xa.\n                                 \\<exists>uu_ uua_.\n                                    (uua_, uu_) = x \\<and>\n                                    (xa = uu_ \\<or>\n                                     xa \\<in> set (inorder uua_))}) \\<union>\n                            set (inorder t).\n               x < xa);\n        \\<forall>y\\<in>set ls.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              x < sep \\<and>\n              (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                               ((\\<Union>x\\<in>set rrs.\n                                    {xa.\n                                     \\<exists>uu_ uua_.\n  (uua_, uu_) = x \\<and>\n  (xa = uu_ \\<or> xa \\<in> set (inorder uua_))}) \\<union>\n                                set (inorder t)).\n                  x < xa);\n        split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n       \\<Longrightarrow> abs_split.isin sub x = x \\<longrightarrow>\n                         (btree_assn k sub suba *\n                          (is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                            (tsi, n) *\n                           blist_assn k ls zs1 *\n                           id_assn sep sepa *\n                           blist_assn k rrs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                           btree_assn k t ti) *\n                          true \\<Longrightarrow>\\<^sub>A\n                          \\<exists>\\<^sub>Atsi ti tsi' zs1 z zs2.\n                             p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                             btree_assn k t ti *\n                             is_pfa (2 * k) tsi' tsi *\n                             blist_assn k ls zs1 *\n                             (btree_assn k \\<times>\\<^sub>a id_assn)\n                              (sub, sep) z *\n                             blist_assn k rrs zs2 *\n                             true *\n                             \\<up> (zs1 @ z # zs2 = tsi'))\n 2. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true \\<and>\n     zs1 @ z # zs2 = xsi;\n     split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "apply(rule P_imp_Q_implies_P)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> sep;\n        \\<And>ts t.\n           sorted_less (inorder_list ts) \\<and>\n           sorted_less (inorder t) \\<and>\n           (\\<forall>y\\<in>set ts.\n               \\<forall>x.\n                  (\\<exists>uu_ uua_.\n                      (uua_, uu_) = y \\<and>\n                      (x = uu_ \\<or>\n                       x \\<in> set (inorder uua_))) \\<longrightarrow>\n                  (\\<forall>xa\\<in>set (inorder t).\n                      x < xa)) \\<Longrightarrow>\n           sorted_less (separators ts);\n        tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa);\n        x \\<noteq> sepa; z = (suba, sepa); sorted_less (inorder_list ls);\n        h_ \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepa *\n        blist_assn k rrs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n        btree_assn k t ti *\n        true;\n        xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n        \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                           {xa.\n                            \\<exists>uu_ uua_.\n                               (uua_, uu_) = x \\<and>\n                               (xa = uu_ \\<or>\n                                xa \\<in> set (inorder uua_))}) \\<union>\n                       set (inorder t).\n           sep < x;\n        sorted_less (inorder_list rrs); sorted_less (inorder t);\n        \\<forall>y\\<in>set rrs.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              (\\<forall>xa\\<in>set (inorder t). x < xa);\n        \\<forall>x\\<in>set (inorder sub).\n           x < sep \\<and>\n           (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                                {xa.\n                                 \\<exists>uu_ uua_.\n                                    (uua_, uu_) = x \\<and>\n                                    (xa = uu_ \\<or>\n                                     xa \\<in> set (inorder uua_))}) \\<union>\n                            set (inorder t).\n               x < xa);\n        \\<forall>y\\<in>set ls.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              x < sep \\<and>\n              (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                               ((\\<Union>x\\<in>set rrs.\n                                    {xa.\n                                     \\<exists>uu_ uua_.\n  (uua_, uu_) = x \\<and>\n  (xa = uu_ \\<or> xa \\<in> set (inorder uua_))}) \\<union>\n                                set (inorder t)).\n                  x < xa);\n        split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n       \\<Longrightarrow> btree_assn k sub suba *\n                         (is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                           (tsi, n) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepa *\n                          blist_assn k rrs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                          btree_assn k t ti) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Atsi ti tsi' zs1 z zs2.\n                            p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                            btree_assn k t ti *\n                            is_pfa (2 * k) tsi' tsi *\n                            blist_assn k ls zs1 *\n                            (btree_assn k \\<times>\\<^sub>a id_assn)\n                             (sub, sep) z *\n                            blist_assn k rrs zs2 *\n                            true *\n                            \\<up> (zs1 @ z # zs2 = tsi')\n 2. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true \\<and>\n     zs1 @ z # zs2 = xsi;\n     split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "apply(rule ent_ex_postI[where x=\"(tsi,n)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> sep;\n        \\<And>ts t.\n           sorted_less (inorder_list ts) \\<and>\n           sorted_less (inorder t) \\<and>\n           (\\<forall>y\\<in>set ts.\n               \\<forall>x.\n                  (\\<exists>uu_ uua_.\n                      (uua_, uu_) = y \\<and>\n                      (x = uu_ \\<or>\n                       x \\<in> set (inorder uua_))) \\<longrightarrow>\n                  (\\<forall>xa\\<in>set (inorder t).\n                      x < xa)) \\<Longrightarrow>\n           sorted_less (separators ts);\n        tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa);\n        x \\<noteq> sepa; z = (suba, sepa); sorted_less (inorder_list ls);\n        h_ \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepa *\n        blist_assn k rrs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n        btree_assn k t ti *\n        true;\n        xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n        \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                           {xa.\n                            \\<exists>uu_ uua_.\n                               (uua_, uu_) = x \\<and>\n                               (xa = uu_ \\<or>\n                                xa \\<in> set (inorder uua_))}) \\<union>\n                       set (inorder t).\n           sep < x;\n        sorted_less (inorder_list rrs); sorted_less (inorder t);\n        \\<forall>y\\<in>set rrs.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              (\\<forall>xa\\<in>set (inorder t). x < xa);\n        \\<forall>x\\<in>set (inorder sub).\n           x < sep \\<and>\n           (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                                {xa.\n                                 \\<exists>uu_ uua_.\n                                    (uua_, uu_) = x \\<and>\n                                    (xa = uu_ \\<or>\n                                     xa \\<in> set (inorder uua_))}) \\<union>\n                            set (inorder t).\n               x < xa);\n        \\<forall>y\\<in>set ls.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              x < sep \\<and>\n              (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                               ((\\<Union>x\\<in>set rrs.\n                                    {xa.\n                                     \\<exists>uu_ uua_.\n  (uua_, uu_) = x \\<and>\n  (xa = uu_ \\<or> xa \\<in> set (inorder uua_))}) \\<union>\n                                set (inorder t)).\n                  x < xa);\n        split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n       \\<Longrightarrow> btree_assn k sub suba *\n                         (is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                           (tsi, n) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepa *\n                          blist_assn k rrs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                          btree_assn k t ti) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Ati tsi' zs1 z zs2.\n                            p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                            btree_assn k t ti *\n                            is_pfa (2 * k) tsi' (tsi, n) *\n                            blist_assn k ls zs1 *\n                            (btree_assn k \\<times>\\<^sub>a id_assn)\n                             (sub, sep) z *\n                            blist_assn k rrs zs2 *\n                            true *\n                            \\<up> (zs1 @ z # zs2 = tsi')\n 2. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true \\<and>\n     zs1 @ z # zs2 = xsi;\n     split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "apply(rule ent_ex_postI[where x=\"ti\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> sep;\n        \\<And>ts t.\n           sorted_less (inorder_list ts) \\<and>\n           sorted_less (inorder t) \\<and>\n           (\\<forall>y\\<in>set ts.\n               \\<forall>x.\n                  (\\<exists>uu_ uua_.\n                      (uua_, uu_) = y \\<and>\n                      (x = uu_ \\<or>\n                       x \\<in> set (inorder uua_))) \\<longrightarrow>\n                  (\\<forall>xa\\<in>set (inorder t).\n                      x < xa)) \\<Longrightarrow>\n           sorted_less (separators ts);\n        tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa);\n        x \\<noteq> sepa; z = (suba, sepa); sorted_less (inorder_list ls);\n        h_ \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepa *\n        blist_assn k rrs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n        btree_assn k t ti *\n        true;\n        xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n        \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                           {xa.\n                            \\<exists>uu_ uua_.\n                               (uua_, uu_) = x \\<and>\n                               (xa = uu_ \\<or>\n                                xa \\<in> set (inorder uua_))}) \\<union>\n                       set (inorder t).\n           sep < x;\n        sorted_less (inorder_list rrs); sorted_less (inorder t);\n        \\<forall>y\\<in>set rrs.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              (\\<forall>xa\\<in>set (inorder t). x < xa);\n        \\<forall>x\\<in>set (inorder sub).\n           x < sep \\<and>\n           (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                                {xa.\n                                 \\<exists>uu_ uua_.\n                                    (uua_, uu_) = x \\<and>\n                                    (xa = uu_ \\<or>\n                                     xa \\<in> set (inorder uua_))}) \\<union>\n                            set (inorder t).\n               x < xa);\n        \\<forall>y\\<in>set ls.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              x < sep \\<and>\n              (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                               ((\\<Union>x\\<in>set rrs.\n                                    {xa.\n                                     \\<exists>uu_ uua_.\n  (uua_, uu_) = x \\<and>\n  (xa = uu_ \\<or> xa \\<in> set (inorder uua_))}) \\<union>\n                                set (inorder t)).\n                  x < xa);\n        split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n       \\<Longrightarrow> btree_assn k sub suba *\n                         (is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                           (tsi, n) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepa *\n                          blist_assn k rrs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                          btree_assn k t ti) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Atsi' zs1 z zs2.\n                            p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                            btree_assn k t ti *\n                            is_pfa (2 * k) tsi' (tsi, n) *\n                            blist_assn k ls zs1 *\n                            (btree_assn k \\<times>\\<^sub>a id_assn)\n                             (sub, sep) z *\n                            blist_assn k rrs zs2 *\n                            true *\n                            \\<up> (zs1 @ z # zs2 = tsi')\n 2. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true \\<and>\n     zs1 @ z # zs2 = xsi;\n     split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "apply(rule ent_ex_postI[where x=\"(zs1 @ (suba, sepa) # zs2)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> sep;\n        \\<And>ts t.\n           sorted_less (inorder_list ts) \\<and>\n           sorted_less (inorder t) \\<and>\n           (\\<forall>y\\<in>set ts.\n               \\<forall>x.\n                  (\\<exists>uu_ uua_.\n                      (uua_, uu_) = y \\<and>\n                      (x = uu_ \\<or>\n                       x \\<in> set (inorder uua_))) \\<longrightarrow>\n                  (\\<forall>xa\\<in>set (inorder t).\n                      x < xa)) \\<Longrightarrow>\n           sorted_less (separators ts);\n        tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa);\n        x \\<noteq> sepa; z = (suba, sepa); sorted_less (inorder_list ls);\n        h_ \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepa *\n        blist_assn k rrs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n        btree_assn k t ti *\n        true;\n        xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n        \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                           {xa.\n                            \\<exists>uu_ uua_.\n                               (uua_, uu_) = x \\<and>\n                               (xa = uu_ \\<or>\n                                xa \\<in> set (inorder uua_))}) \\<union>\n                       set (inorder t).\n           sep < x;\n        sorted_less (inorder_list rrs); sorted_less (inorder t);\n        \\<forall>y\\<in>set rrs.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              (\\<forall>xa\\<in>set (inorder t). x < xa);\n        \\<forall>x\\<in>set (inorder sub).\n           x < sep \\<and>\n           (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                                {xa.\n                                 \\<exists>uu_ uua_.\n                                    (uua_, uu_) = x \\<and>\n                                    (xa = uu_ \\<or>\n                                     xa \\<in> set (inorder uua_))}) \\<union>\n                            set (inorder t).\n               x < xa);\n        \\<forall>y\\<in>set ls.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              x < sep \\<and>\n              (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                               ((\\<Union>x\\<in>set rrs.\n                                    {xa.\n                                     \\<exists>uu_ uua_.\n  (uua_, uu_) = x \\<and>\n  (xa = uu_ \\<or> xa \\<in> set (inorder uua_))}) \\<union>\n                                set (inorder t)).\n                  x < xa);\n        split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n       \\<Longrightarrow> btree_assn k sub suba *\n                         (is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                           (tsi, n) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepa *\n                          blist_assn k rrs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                          btree_assn k t ti) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Azs1a z zs2a.\n                            p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                            btree_assn k t ti *\n                            is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                             (tsi, n) *\n                            blist_assn k ls zs1a *\n                            (btree_assn k \\<times>\\<^sub>a id_assn)\n                             (sub, sep) z *\n                            blist_assn k rrs zs2a *\n                            true *\n                            \\<up>\n                             (zs1a @ z # zs2a = zs1 @ (suba, sepa) # zs2)\n 2. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true \\<and>\n     zs1 @ z # zs2 = xsi;\n     split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "apply(rule ent_ex_postI[where x=\"zs1\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> sep;\n        \\<And>ts t.\n           sorted_less (inorder_list ts) \\<and>\n           sorted_less (inorder t) \\<and>\n           (\\<forall>y\\<in>set ts.\n               \\<forall>x.\n                  (\\<exists>uu_ uua_.\n                      (uua_, uu_) = y \\<and>\n                      (x = uu_ \\<or>\n                       x \\<in> set (inorder uua_))) \\<longrightarrow>\n                  (\\<forall>xa\\<in>set (inorder t).\n                      x < xa)) \\<Longrightarrow>\n           sorted_less (separators ts);\n        tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa);\n        x \\<noteq> sepa; z = (suba, sepa); sorted_less (inorder_list ls);\n        h_ \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepa *\n        blist_assn k rrs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n        btree_assn k t ti *\n        true;\n        xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n        \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                           {xa.\n                            \\<exists>uu_ uua_.\n                               (uua_, uu_) = x \\<and>\n                               (xa = uu_ \\<or>\n                                xa \\<in> set (inorder uua_))}) \\<union>\n                       set (inorder t).\n           sep < x;\n        sorted_less (inorder_list rrs); sorted_less (inorder t);\n        \\<forall>y\\<in>set rrs.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              (\\<forall>xa\\<in>set (inorder t). x < xa);\n        \\<forall>x\\<in>set (inorder sub).\n           x < sep \\<and>\n           (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                                {xa.\n                                 \\<exists>uu_ uua_.\n                                    (uua_, uu_) = x \\<and>\n                                    (xa = uu_ \\<or>\n                                     xa \\<in> set (inorder uua_))}) \\<union>\n                            set (inorder t).\n               x < xa);\n        \\<forall>y\\<in>set ls.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              x < sep \\<and>\n              (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                               ((\\<Union>x\\<in>set rrs.\n                                    {xa.\n                                     \\<exists>uu_ uua_.\n  (uua_, uu_) = x \\<and>\n  (xa = uu_ \\<or> xa \\<in> set (inorder uua_))}) \\<union>\n                                set (inorder t)).\n                  x < xa);\n        split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n       \\<Longrightarrow> btree_assn k sub suba *\n                         (is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                           (tsi, n) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepa *\n                          blist_assn k rrs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                          btree_assn k t ti) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Az zs2a.\n                            p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                            btree_assn k t ti *\n                            is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                             (tsi, n) *\n                            blist_assn k ls zs1 *\n                            (btree_assn k \\<times>\\<^sub>a id_assn)\n                             (sub, sep) z *\n                            blist_assn k rrs zs2a *\n                            true *\n                            \\<up>\n                             (zs1 @ z # zs2a = zs1 @ (suba, sepa) # zs2)\n 2. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true \\<and>\n     zs1 @ z # zs2 = xsi;\n     split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "apply(rule ent_ex_postI[where x=\"z\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> sep;\n        \\<And>ts t.\n           sorted_less (inorder_list ts) \\<and>\n           sorted_less (inorder t) \\<and>\n           (\\<forall>y\\<in>set ts.\n               \\<forall>x.\n                  (\\<exists>uu_ uua_.\n                      (uua_, uu_) = y \\<and>\n                      (x = uu_ \\<or>\n                       x \\<in> set (inorder uua_))) \\<longrightarrow>\n                  (\\<forall>xa\\<in>set (inorder t).\n                      x < xa)) \\<Longrightarrow>\n           sorted_less (separators ts);\n        tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa);\n        x \\<noteq> sepa; z = (suba, sepa); sorted_less (inorder_list ls);\n        h_ \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepa *\n        blist_assn k rrs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n        btree_assn k t ti *\n        true;\n        xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n        \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                           {xa.\n                            \\<exists>uu_ uua_.\n                               (uua_, uu_) = x \\<and>\n                               (xa = uu_ \\<or>\n                                xa \\<in> set (inorder uua_))}) \\<union>\n                       set (inorder t).\n           sep < x;\n        sorted_less (inorder_list rrs); sorted_less (inorder t);\n        \\<forall>y\\<in>set rrs.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              (\\<forall>xa\\<in>set (inorder t). x < xa);\n        \\<forall>x\\<in>set (inorder sub).\n           x < sep \\<and>\n           (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                                {xa.\n                                 \\<exists>uu_ uua_.\n                                    (uua_, uu_) = x \\<and>\n                                    (xa = uu_ \\<or>\n                                     xa \\<in> set (inorder uua_))}) \\<union>\n                            set (inorder t).\n               x < xa);\n        \\<forall>y\\<in>set ls.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              x < sep \\<and>\n              (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                               ((\\<Union>x\\<in>set rrs.\n                                    {xa.\n                                     \\<exists>uu_ uua_.\n  (uua_, uu_) = x \\<and>\n  (xa = uu_ \\<or> xa \\<in> set (inorder uua_))}) \\<union>\n                                set (inorder t)).\n                  x < xa);\n        split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n       \\<Longrightarrow> btree_assn k sub suba *\n                         (is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                           (tsi, n) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepa *\n                          blist_assn k rrs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                          btree_assn k t ti) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Azs2a.\n                            p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                            btree_assn k t ti *\n                            is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                             (tsi, n) *\n                            blist_assn k ls zs1 *\n                            (btree_assn k \\<times>\\<^sub>a id_assn)\n                             (sub, sep) z *\n                            blist_assn k rrs zs2a *\n                            true *\n                            \\<up>\n                             (zs1 @ z # zs2a = zs1 @ (suba, sepa) # zs2)\n 2. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true \\<and>\n     zs1 @ z # zs2 = xsi;\n     split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "apply(rule ent_ex_postI[where x=\"zs2\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> sep;\n        \\<And>ts t.\n           sorted_less (inorder_list ts) \\<and>\n           sorted_less (inorder t) \\<and>\n           (\\<forall>y\\<in>set ts.\n               \\<forall>x.\n                  (\\<exists>uu_ uua_.\n                      (uua_, uu_) = y \\<and>\n                      (x = uu_ \\<or>\n                       x \\<in> set (inorder uua_))) \\<longrightarrow>\n                  (\\<forall>xa\\<in>set (inorder t).\n                      x < xa)) \\<Longrightarrow>\n           sorted_less (separators ts);\n        tia__ = Some p; ts = ls @ (sub, sep) # rrs;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepa) # zs2) ! length ls = (suba, sepa);\n        x \\<noteq> sepa; z = (suba, sepa); sorted_less (inorder_list ls);\n        h_ \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2) (tsi, n) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepa *\n        blist_assn k rrs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n        btree_assn k t ti *\n        true;\n        xsi = zs1 @ (suba, sepa) # zs2; sorted_less (inorder sub);\n        \\<forall>x\\<in>(\\<Union>x\\<in>set rrs.\n                           {xa.\n                            \\<exists>uu_ uua_.\n                               (uua_, uu_) = x \\<and>\n                               (xa = uu_ \\<or>\n                                xa \\<in> set (inorder uua_))}) \\<union>\n                       set (inorder t).\n           sep < x;\n        sorted_less (inorder_list rrs); sorted_less (inorder t);\n        \\<forall>y\\<in>set rrs.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              (\\<forall>xa\\<in>set (inorder t). x < xa);\n        \\<forall>x\\<in>set (inorder sub).\n           x < sep \\<and>\n           (\\<forall>xa\\<in>(\\<Union>x\\<in>set rrs.\n                                {xa.\n                                 \\<exists>uu_ uua_.\n                                    (uua_, uu_) = x \\<and>\n                                    (xa = uu_ \\<or>\n                                     xa \\<in> set (inorder uua_))}) \\<union>\n                            set (inorder t).\n               x < xa);\n        \\<forall>y\\<in>set ls.\n           \\<forall>x.\n              (\\<exists>uu_ uua_.\n                  (uua_, uu_) = y \\<and>\n                  (x = uu_ \\<or>\n                   x \\<in> set (inorder uua_))) \\<longrightarrow>\n              x < sep \\<and>\n              (\\<forall>xa\\<in>set (inorder sub) \\<union>\n                               ((\\<Union>x\\<in>set rrs.\n                                    {xa.\n                                     \\<exists>uu_ uua_.\n  (uua_, uu_) = x \\<and>\n  (xa = uu_ \\<or> xa \\<in> set (inorder uua_))}) \\<union>\n                                set (inorder t)).\n                  x < xa);\n        split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n       \\<Longrightarrow> btree_assn k sub suba *\n                         (is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                           (tsi, n) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepa *\n                          blist_assn k rrs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                          btree_assn k t ti) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n                         btree_assn k t ti *\n                         is_pfa (2 * k) (zs1 @ (suba, sepa) # zs2)\n                          (tsi, n) *\n                         blist_assn k ls zs1 *\n                         (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep)\n                          z *\n                         blist_assn k rrs zs2 *\n                         true *\n                         \\<up> (zs1 @ z # zs2 = zs1 @ (suba, sepa) # zs2)\n 2. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true \\<and>\n     zs1 @ z # zs2 = xsi;\n     split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true \\<and>\n     zs1 @ z # zs2 = xsi;\n     split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "(* prove subgoal_tac assumption *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> sep;\n     sorted_less\n      (inorder_list ls @ inorder sub @ sep # inorder_list rrs @ inorder t);\n     \\<And>ts t.\n        sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n        sorted_less (separators ts);\n     tia__ = Some p; ts = ls @ (sub, sep) # rrs; length ls < length xsi;\n     xsi ! length ls = (suba, sepa); x \\<noteq> sepa;\n     h_ \\<Turnstile>\n     is_pfa (2 * k) xsi (tsi, n) *\n     (blist_assn k ls zs1 *\n      (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep) z *\n      blist_assn k rrs zs2) *\n     p \\<mapsto>\\<^sub>r Btnode (tsi, n) ti *\n     btree_assn k t ti *\n     true \\<and>\n     zs1 @ z # zs2 = xsi;\n     split (ls @ (sub, sep) # rrs) x = (ls, (sub, sep) # rrs)\\<rbrakk>\n    \\<Longrightarrow> z = (suba, sepa)", "apply (metis (no_types, lifting) list_assn_aux_ineq_len list_assn_len nth_append_length star_false_left star_false_right)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>", "(* eliminate last vacuous case *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b ti tsi' xb xaa h.\n       \\<lbrakk>x \\<noteq> sep; sorted_less (inorder_list ts @ inorder t);\n        \\<And>ts t.\n           sorted_less (inorder_list ts @ inorder t) \\<Longrightarrow>\n           sorted_less (separators ts);\n        ti = Some x; split_relation ts (ls, (sub, sep) # rrs) xb;\n        xaa = length tsi'; \\<not> xb < length tsi';\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi' (a, b) * blist_assn k ts tsi' *\n        x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n        btree_assn k t ti *\n        true\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true>\n                         isin ti x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Atsi ti tsi'.\n                                x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                                btree_assn k t ti *\n                                is_pfa (2 * k) tsi' tsi *\n                                blist_assn k ts tsi' *\n                                true *\n                                \\<up> (abs_split.isin sub x = r)>", "apply(auto simp add: split_relation_def dest!: mod_starD list_assn_len)[]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> isin ti\n         x <\\<lambda>r.\n               btree_assn k (Node ts t) ti *\n               \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> isin ti\n         x <\\<lambda>r.\n               btree_assn k (Node ts t) ti *\n               \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> isin ti\n         x <\\<lambda>r.\n               btree_assn k (Node ts t) ti *\n               \\<up> (abs_split.isin (Node ts t) x = r)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "declare abs_split.node\\<^sub>i.simps [simp add]"], ["", "lemma node\\<^sub>i_rule: assumes c_cap: \"2*k \\<le> c\" \"c \\<le> 4*k+1\"\n  shows \"<is_pfa c tsi (a,n) * list_assn ((btree_assn k) \\<times>\\<^sub>a id_assn) ts tsi * btree_assn k t ti>\n  node\\<^sub>i k (a,n) ti\n  <\\<lambda>r. btupi_assn k (abs_split.node\\<^sub>i k ts t) r >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n     btree_assn k t\n      ti> node\\<^sub>i k (a, n)\n           ti <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t", "proof (cases \"length ts \\<le> 2*k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n     btree_assn k t\n      ti> node\\<^sub>i k (a, n)\n           ti <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t\n 2. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n     btree_assn k t\n      ti> node\\<^sub>i k (a, n)\n           ti <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t", "case [simp]: True"], ["proof (state)\nthis:\n  length ts \\<le> 2 * k\n\ngoal (2 subgoals):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n     btree_assn k t\n      ti> node\\<^sub>i k (a, n)\n           ti <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t\n 2. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n     btree_assn k t\n      ti> node\\<^sub>i k (a, n)\n           ti <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  length ts \\<le> 2 * k", "show ?thesis"], ["proof (prove)\nusing this:\n  length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n     btree_assn k t\n      ti> node\\<^sub>i k (a, n)\n           ti <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t", "apply(subst node\\<^sub>i_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n     btree_assn k t\n      ti> pfa_length (a, n) \\<bind>\n          (\\<lambda>na.\n              if na \\<le> 2 * k\n              then pfa_shrink_cap (2 * k) (a, n) \\<bind>\n                   (\\<lambda>a'.\n                       ref (Btnode a' ti) \\<bind>\n                       (\\<lambda>l. return (T\\<^sub>i (Some l))))\n              else pfa_empty (2 * k) \\<bind>\n                   (\\<lambda>b.\n                       BTree_ImpSet.split_half (a, n) \\<bind>\n                       (\\<lambda>i.\n                           pfa_get (a, n) i \\<bind>\n                           (\\<lambda>m.\n                               pfa_drop (a, n) (i + 1) b \\<bind>\n                               (\\<lambda>b'.\n                                   pfa_shrink i (a, n) \\<bind>\n                                   (\\<lambda>a'.\n pfa_shrink_cap (2 * k) a' \\<bind>\n (\\<lambda>a''.\n     let (sub, sep) = m\n     in ref (Btnode a'' sub) \\<bind>\n        (\\<lambda>l.\n            ref (Btnode b' ti) \\<bind>\n            (\\<lambda>r.\n                return\n                 (Up\\<^sub>i (Some l) sep\n                   (Some\n                     r))))))))))) <btupi_assn k\n                                    (abs_split.node\\<^sub>i k ts t)>\\<^sub>t", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>length ts \\<le> 2 * k;\n        h \\<Turnstile>\n        is_pfa c tsi (a, n) * blist_assn k ts tsi *\n        btree_assn k t ti\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_length (a, n) \\<bind>\n                               (\\<lambda>na.\n                                   if na \\<le> 2 * k\n                                   then pfa_shrink_cap (2 * k)\n   (a, n) \\<bind>\n  (\\<lambda>a'.\n      ref (Btnode a' ti) \\<bind> (\\<lambda>l. return (T\\<^sub>i (Some l))))\n                                   else pfa_empty (2 * k) \\<bind>\n  (\\<lambda>b.\n      BTree_ImpSet.split_half (a, n) \\<bind>\n      (\\<lambda>i.\n          pfa_get (a, n) i \\<bind>\n          (\\<lambda>m.\n              pfa_drop (a, n) (i + 1) b \\<bind>\n              (\\<lambda>b'.\n                  pfa_shrink i (a, n) \\<bind>\n                  (\\<lambda>a'.\n                      pfa_shrink_cap (2 * k) a' \\<bind>\n                      (\\<lambda>a''.\n                          let (sub, sep) = m\n                          in ref (Btnode a'' sub) \\<bind>\n                             (\\<lambda>l.\n                                 ref (Btnode b' ti) \\<bind>\n                                 (\\<lambda>r.\n                                     return\n(Up\\<^sub>i (Some l) sep\n  (Some r))))))))))) <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t", "apply(sep_auto dest!: mod_starD list_assn_len)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ab bb ac bc.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> n \\<le> 2 * k\n 2. \\<And>ab bb ac bc x.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> 2 * k \\<le> c\n 3. \\<And>ab bb ac bc x xa.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi xa * true *\n                          (blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode xa ti) \\<bind>\n                                 (\\<lambda>l.\n                                     return\n(T\\<^sub>i\n  (Some l))) <btupi_assn k (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t\n 4. \\<And>ab bb ac bc x.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; \\<not> length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_empty (2 * k) \\<bind>\n                               (\\<lambda>b.\n                                   BTree_ImpSet.split_half (a, n) \\<bind>\n                                   (\\<lambda>i.\n pfa_get (a, n) i \\<bind>\n (\\<lambda>m.\n     pfa_drop (a, n) (i + 1) b \\<bind>\n     (\\<lambda>b'.\n         pfa_shrink i (a, n) \\<bind>\n         (\\<lambda>a'.\n             pfa_shrink_cap (2 * k) a' \\<bind>\n             (\\<lambda>a''.\n                 case m of\n                 (sub, sep) \\<Rightarrow>\n                   ref (Btnode a'' sub) \\<bind>\n                   (\\<lambda>l.\n                       ref (Btnode b' ti) \\<bind>\n                       (\\<lambda>r.\n                           return\n                            (Up\\<^sub>i (Some l) sep\n                              (Some\n                                r)))))))))) <btupi_assn k\n        (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t", "apply(sep_auto simp add: is_pfa_def)[]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab bb ac bc x.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> 2 * k \\<le> c\n 2. \\<And>ab bb ac bc x xa.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi xa * true *\n                          (blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode xa ti) \\<bind>\n                                 (\\<lambda>l.\n                                     return\n(T\\<^sub>i\n  (Some l))) <btupi_assn k (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t\n 3. \\<And>ab bb ac bc x.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; \\<not> length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_empty (2 * k) \\<bind>\n                               (\\<lambda>b.\n                                   BTree_ImpSet.split_half (a, n) \\<bind>\n                                   (\\<lambda>i.\n pfa_get (a, n) i \\<bind>\n (\\<lambda>m.\n     pfa_drop (a, n) (i + 1) b \\<bind>\n     (\\<lambda>b'.\n         pfa_shrink i (a, n) \\<bind>\n         (\\<lambda>a'.\n             pfa_shrink_cap (2 * k) a' \\<bind>\n             (\\<lambda>a''.\n                 case m of\n                 (sub, sep) \\<Rightarrow>\n                   ref (Btnode a'' sub) \\<bind>\n                   (\\<lambda>l.\n                       ref (Btnode b' ti) \\<bind>\n                       (\\<lambda>r.\n                           return\n                            (Up\\<^sub>i (Some l) sep\n                              (Some\n                                r)))))))))) <btupi_assn k\n        (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t", "using c_cap"], ["proof (prove)\nusing this:\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n\ngoal (3 subgoals):\n 1. \\<And>ab bb ac bc x.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> 2 * k \\<le> c\n 2. \\<And>ab bb ac bc x xa.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi xa * true *\n                          (blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode xa ti) \\<bind>\n                                 (\\<lambda>l.\n                                     return\n(T\\<^sub>i\n  (Some l))) <btupi_assn k (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t\n 3. \\<And>ab bb ac bc x.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; \\<not> length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_empty (2 * k) \\<bind>\n                               (\\<lambda>b.\n                                   BTree_ImpSet.split_half (a, n) \\<bind>\n                                   (\\<lambda>i.\n pfa_get (a, n) i \\<bind>\n (\\<lambda>m.\n     pfa_drop (a, n) (i + 1) b \\<bind>\n     (\\<lambda>b'.\n         pfa_shrink i (a, n) \\<bind>\n         (\\<lambda>a'.\n             pfa_shrink_cap (2 * k) a' \\<bind>\n             (\\<lambda>a''.\n                 case m of\n                 (sub, sep) \\<Rightarrow>\n                   ref (Btnode a'' sub) \\<bind>\n                   (\\<lambda>l.\n                       ref (Btnode b' ti) \\<bind>\n                       (\\<lambda>r.\n                           return\n                            (Up\\<^sub>i (Some l) sep\n                              (Some\n                                r)))))))))) <btupi_assn k\n        (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t", "apply(sep_auto simp add: is_pfa_def)[]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ac bc x xa.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi xa * true *\n                          (blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode xa ti) \\<bind>\n                                 (\\<lambda>l.\n                                     return\n(T\\<^sub>i\n  (Some l))) <btupi_assn k (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t\n 2. \\<And>ab bb ac bc x.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; \\<not> length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_empty (2 * k) \\<bind>\n                               (\\<lambda>b.\n                                   BTree_ImpSet.split_half (a, n) \\<bind>\n                                   (\\<lambda>i.\n pfa_get (a, n) i \\<bind>\n (\\<lambda>m.\n     pfa_drop (a, n) (i + 1) b \\<bind>\n     (\\<lambda>b'.\n         pfa_shrink i (a, n) \\<bind>\n         (\\<lambda>a'.\n             pfa_shrink_cap (2 * k) a' \\<bind>\n             (\\<lambda>a''.\n                 case m of\n                 (sub, sep) \\<Rightarrow>\n                   ref (Btnode a'' sub) \\<bind>\n                   (\\<lambda>l.\n                       ref (Btnode b' ti) \\<bind>\n                       (\\<lambda>r.\n                           return\n                            (Up\\<^sub>i (Some l) sep\n                              (Some\n                                r)))))))))) <btupi_assn k\n        (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t", "apply(sep_auto  dest!: mod_starD list_assn_len)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ac bc x.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; \\<not> length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_empty (2 * k) \\<bind>\n                               (\\<lambda>b.\n                                   BTree_ImpSet.split_half (a, n) \\<bind>\n                                   (\\<lambda>i.\n pfa_get (a, n) i \\<bind>\n (\\<lambda>m.\n     pfa_drop (a, n) (i + 1) b \\<bind>\n     (\\<lambda>b'.\n         pfa_shrink i (a, n) \\<bind>\n         (\\<lambda>a'.\n             pfa_shrink_cap (2 * k) a' \\<bind>\n             (\\<lambda>a''.\n                 case m of\n                 (sub, sep) \\<Rightarrow>\n                   ref (Btnode a'' sub) \\<bind>\n                   (\\<lambda>l.\n                       ref (Btnode b' ti) \\<bind>\n                       (\\<lambda>r.\n                           return\n                            (Up\\<^sub>i (Some l) sep\n                              (Some\n                                r)))))))))) <btupi_assn k\n        (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t", "using True"], ["proof (prove)\nusing this:\n  length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. \\<And>ab bb ac bc x.\n       \\<lbrakk>(ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; \\<not> length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_empty (2 * k) \\<bind>\n                               (\\<lambda>b.\n                                   BTree_ImpSet.split_half (a, n) \\<bind>\n                                   (\\<lambda>i.\n pfa_get (a, n) i \\<bind>\n (\\<lambda>m.\n     pfa_drop (a, n) (i + 1) b \\<bind>\n     (\\<lambda>b'.\n         pfa_shrink i (a, n) \\<bind>\n         (\\<lambda>a'.\n             pfa_shrink_cap (2 * k) a' \\<bind>\n             (\\<lambda>a''.\n                 case m of\n                 (sub, sep) \\<Rightarrow>\n                   ref (Btnode a'' sub) \\<bind>\n                   (\\<lambda>l.\n                       ref (Btnode b' ti) \\<bind>\n                       (\\<lambda>r.\n                           return\n                            (Up\\<^sub>i (Some l) sep\n                              (Some\n                                r)))))))))) <btupi_assn k\n        (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t", "apply(sep_auto dest!: mod_starD list_assn_len)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n   btree_assn k t\n    ti> node\\<^sub>i k (a, n)\n         ti <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n     btree_assn k t\n      ti> node\\<^sub>i k (a, n)\n           ti <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n     btree_assn k t\n      ti> node\\<^sub>i k (a, n)\n           ti <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t", "case [simp]: False"], ["proof (state)\nthis:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n     btree_assn k t\n      ti> node\\<^sub>i k (a, n)\n           ti <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  \\<not> length ts \\<le> 2 * k", "obtain ls sub sep rs where\n    split_half_eq: \"BTree_Set.split_half ts = (ls,(sub,sep)#rs)\""], ["proof (prove)\nusing this:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. (\\<And>ls sub sep rs.\n        BTree_Set.split_half ts = (ls, (sub, sep) # rs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using abs_split.node\\<^sub>i_cases"], ["proof (prove)\nusing this:\n  \\<not> length ts \\<le> 2 * k\n  length ?xs \\<le> ?k \\<or>\n  (\\<exists>ls sub sep rs. BTree_Set.split_half ?xs = (ls, (sub, sep) # rs))\n\ngoal (1 subgoal):\n 1. (\\<And>ls sub sep rs.\n        BTree_Set.split_half ts = (ls, (sub, sep) # rs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  BTree_Set.split_half ts = (ls, (sub, sep) # rs)\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n     btree_assn k t\n      ti> node\\<^sub>i k (a, n)\n           ti <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  BTree_Set.split_half ts = (ls, (sub, sep) # rs)", "show ?thesis"], ["proof (prove)\nusing this:\n  BTree_Set.split_half ts = (ls, (sub, sep) # rs)\n\ngoal (1 subgoal):\n 1. <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n     btree_assn k t\n      ti> node\\<^sub>i k (a, n)\n           ti <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t", "apply(subst node\\<^sub>i_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. BTree_Set.split_half ts = (ls, (sub, sep) # rs) \\<Longrightarrow>\n    <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n     btree_assn k t\n      ti> pfa_length (a, n) \\<bind>\n          (\\<lambda>na.\n              if na \\<le> 2 * k\n              then pfa_shrink_cap (2 * k) (a, n) \\<bind>\n                   (\\<lambda>a'.\n                       ref (Btnode a' ti) \\<bind>\n                       (\\<lambda>l. return (T\\<^sub>i (Some l))))\n              else pfa_empty (2 * k) \\<bind>\n                   (\\<lambda>b.\n                       BTree_ImpSet.split_half (a, n) \\<bind>\n                       (\\<lambda>i.\n                           pfa_get (a, n) i \\<bind>\n                           (\\<lambda>m.\n                               pfa_drop (a, n) (i + 1) b \\<bind>\n                               (\\<lambda>b'.\n                                   pfa_shrink i (a, n) \\<bind>\n                                   (\\<lambda>a'.\n pfa_shrink_cap (2 * k) a' \\<bind>\n (\\<lambda>a''.\n     let (sub, sep) = m\n     in ref (Btnode a'' sub) \\<bind>\n        (\\<lambda>l.\n            ref (Btnode b' ti) \\<bind>\n            (\\<lambda>r.\n                return\n                 (Up\\<^sub>i (Some l) sep\n                   (Some\n                     r))))))))))) <btupi_assn k\n                                    (abs_split.node\\<^sub>i k ts t)>\\<^sub>t", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>BTree_Set.split_half ts = (ls, (sub, sep) # rs);\n        h \\<Turnstile>\n        is_pfa c tsi (a, n) * blist_assn k ts tsi *\n        btree_assn k t ti\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_length (a, n) \\<bind>\n                               (\\<lambda>na.\n                                   if na \\<le> 2 * k\n                                   then pfa_shrink_cap (2 * k)\n   (a, n) \\<bind>\n  (\\<lambda>a'.\n      ref (Btnode a' ti) \\<bind> (\\<lambda>l. return (T\\<^sub>i (Some l))))\n                                   else pfa_empty (2 * k) \\<bind>\n  (\\<lambda>b.\n      BTree_ImpSet.split_half (a, n) \\<bind>\n      (\\<lambda>i.\n          pfa_get (a, n) i \\<bind>\n          (\\<lambda>m.\n              pfa_drop (a, n) (i + 1) b \\<bind>\n              (\\<lambda>b'.\n                  pfa_shrink i (a, n) \\<bind>\n                  (\\<lambda>a'.\n                      pfa_shrink_cap (2 * k) a' \\<bind>\n                      (\\<lambda>a''.\n                          let (sub, sep) = m\n                          in ref (Btnode a'' sub) \\<bind>\n                             (\\<lambda>l.\n                                 ref (Btnode b' ti) \\<bind>\n                                 (\\<lambda>r.\n                                     return\n(Up\\<^sub>i (Some l) sep\n  (Some r))))))))))) <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t", "apply(sep_auto dest!: mod_starD list_assn_len)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ab bb ac bc.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> n \\<le> 2 * k\n 2. \\<And>ab bb ac bc x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> 2 * k \\<le> c\n 3. \\<And>ab bb ac bc x xa.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi xa * true *\n                          (blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode xa ti) \\<bind>\n                                 (\\<lambda>l.\n                                     return\n(T\\<^sub>i\n  (Some\n    l))) <btupi_assn k\n           (abs_split.Up\\<^sub>i (Node (take (length tsi div 2) ts) sub) sep\n             (Node rs t))>\\<^sub>t\n 4. \\<And>ab bb ac bc x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; \\<not> length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_empty (2 * k) \\<bind>\n                               (\\<lambda>b.\n                                   BTree_ImpSet.split_half (a, n) \\<bind>\n                                   (\\<lambda>i.\n pfa_get (a, n) i \\<bind>\n (\\<lambda>m.\n     pfa_drop (a, n) (i + 1) b \\<bind>\n     (\\<lambda>b'.\n         pfa_shrink i (a, n) \\<bind>\n         (\\<lambda>a'.\n             pfa_shrink_cap (2 * k) a' \\<bind>\n             (\\<lambda>a''.\n                 case m of\n                 (sub, sep) \\<Rightarrow>\n                   ref (Btnode a'' sub) \\<bind>\n                   (\\<lambda>l.\n                       ref (Btnode b' ti) \\<bind>\n                       (\\<lambda>r.\n                           return\n                            (Up\\<^sub>i (Some l) sep\n                              (Some\n                                r)))))))))) <btupi_assn k\n        (abs_split.Up\\<^sub>i (Node (take (length tsi div 2) ts) sub) sep\n          (Node rs t))>\\<^sub>t", "apply(sep_auto simp add:  split_relation_alt split_relation_length is_pfa_def dest!: mod_starD list_assn_len)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab bb ac bc x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> 2 * k \\<le> c\n 2. \\<And>ab bb ac bc x xa.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi xa * true *\n                          (blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode xa ti) \\<bind>\n                                 (\\<lambda>l.\n                                     return\n(T\\<^sub>i\n  (Some\n    l))) <btupi_assn k\n           (abs_split.Up\\<^sub>i (Node (take (length tsi div 2) ts) sub) sep\n             (Node rs t))>\\<^sub>t\n 3. \\<And>ab bb ac bc x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; \\<not> length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_empty (2 * k) \\<bind>\n                               (\\<lambda>b.\n                                   BTree_ImpSet.split_half (a, n) \\<bind>\n                                   (\\<lambda>i.\n pfa_get (a, n) i \\<bind>\n (\\<lambda>m.\n     pfa_drop (a, n) (i + 1) b \\<bind>\n     (\\<lambda>b'.\n         pfa_shrink i (a, n) \\<bind>\n         (\\<lambda>a'.\n             pfa_shrink_cap (2 * k) a' \\<bind>\n             (\\<lambda>a''.\n                 case m of\n                 (sub, sep) \\<Rightarrow>\n                   ref (Btnode a'' sub) \\<bind>\n                   (\\<lambda>l.\n                       ref (Btnode b' ti) \\<bind>\n                       (\\<lambda>r.\n                           return\n                            (Up\\<^sub>i (Some l) sep\n                              (Some\n                                r)))))))))) <btupi_assn k\n        (abs_split.Up\\<^sub>i (Node (take (length tsi div 2) ts) sub) sep\n          (Node rs t))>\\<^sub>t", "using False"], ["proof (prove)\nusing this:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (3 subgoals):\n 1. \\<And>ab bb ac bc x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> 2 * k \\<le> c\n 2. \\<And>ab bb ac bc x xa.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi xa * true *\n                          (blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode xa ti) \\<bind>\n                                 (\\<lambda>l.\n                                     return\n(T\\<^sub>i\n  (Some\n    l))) <btupi_assn k\n           (abs_split.Up\\<^sub>i (Node (take (length tsi div 2) ts) sub) sep\n             (Node rs t))>\\<^sub>t\n 3. \\<And>ab bb ac bc x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; \\<not> length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_empty (2 * k) \\<bind>\n                               (\\<lambda>b.\n                                   BTree_ImpSet.split_half (a, n) \\<bind>\n                                   (\\<lambda>i.\n pfa_get (a, n) i \\<bind>\n (\\<lambda>m.\n     pfa_drop (a, n) (i + 1) b \\<bind>\n     (\\<lambda>b'.\n         pfa_shrink i (a, n) \\<bind>\n         (\\<lambda>a'.\n             pfa_shrink_cap (2 * k) a' \\<bind>\n             (\\<lambda>a''.\n                 case m of\n                 (sub, sep) \\<Rightarrow>\n                   ref (Btnode a'' sub) \\<bind>\n                   (\\<lambda>l.\n                       ref (Btnode b' ti) \\<bind>\n                       (\\<lambda>r.\n                           return\n                            (Up\\<^sub>i (Some l) sep\n                              (Some\n                                r)))))))))) <btupi_assn k\n        (abs_split.Up\\<^sub>i (Node (take (length tsi div 2) ts) sub) sep\n          (Node rs t))>\\<^sub>t", "apply(sep_auto simp add: split_relation_alt )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ac bc x xa.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi xa * true *\n                          (blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode xa ti) \\<bind>\n                                 (\\<lambda>l.\n                                     return\n(T\\<^sub>i\n  (Some\n    l))) <btupi_assn k\n           (abs_split.Up\\<^sub>i (Node (take (length tsi div 2) ts) sub) sep\n             (Node rs t))>\\<^sub>t\n 2. \\<And>ab bb ac bc x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; \\<not> length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_empty (2 * k) \\<bind>\n                               (\\<lambda>b.\n                                   BTree_ImpSet.split_half (a, n) \\<bind>\n                                   (\\<lambda>i.\n pfa_get (a, n) i \\<bind>\n (\\<lambda>m.\n     pfa_drop (a, n) (i + 1) b \\<bind>\n     (\\<lambda>b'.\n         pfa_shrink i (a, n) \\<bind>\n         (\\<lambda>a'.\n             pfa_shrink_cap (2 * k) a' \\<bind>\n             (\\<lambda>a''.\n                 case m of\n                 (sub, sep) \\<Rightarrow>\n                   ref (Btnode a'' sub) \\<bind>\n                   (\\<lambda>l.\n                       ref (Btnode b' ti) \\<bind>\n                       (\\<lambda>r.\n                           return\n                            (Up\\<^sub>i (Some l) sep\n                              (Some\n                                r)))))))))) <btupi_assn k\n        (abs_split.Up\\<^sub>i (Node (take (length tsi div 2) ts) sub) sep\n          (Node rs t))>\\<^sub>t", "using False"], ["proof (prove)\nusing this:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (2 subgoals):\n 1. \\<And>ab bb ac bc x xa.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi xa * true *\n                          (blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode xa ti) \\<bind>\n                                 (\\<lambda>l.\n                                     return\n(T\\<^sub>i\n  (Some\n    l))) <btupi_assn k\n           (abs_split.Up\\<^sub>i (Node (take (length tsi div 2) ts) sub) sep\n             (Node rs t))>\\<^sub>t\n 2. \\<And>ab bb ac bc x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; \\<not> length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_empty (2 * k) \\<bind>\n                               (\\<lambda>b.\n                                   BTree_ImpSet.split_half (a, n) \\<bind>\n                                   (\\<lambda>i.\n pfa_get (a, n) i \\<bind>\n (\\<lambda>m.\n     pfa_drop (a, n) (i + 1) b \\<bind>\n     (\\<lambda>b'.\n         pfa_shrink i (a, n) \\<bind>\n         (\\<lambda>a'.\n             pfa_shrink_cap (2 * k) a' \\<bind>\n             (\\<lambda>a''.\n                 case m of\n                 (sub, sep) \\<Rightarrow>\n                   ref (Btnode a'' sub) \\<bind>\n                   (\\<lambda>l.\n                       ref (Btnode b' ti) \\<bind>\n                       (\\<lambda>r.\n                           return\n                            (Up\\<^sub>i (Some l) sep\n                              (Some\n                                r)))))))))) <btupi_assn k\n        (abs_split.Up\\<^sub>i (Node (take (length tsi div 2) ts) sub) sep\n          (Node rs t))>\\<^sub>t", "apply(sep_auto simp add: is_pfa_def)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ac bc x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        x = length tsi; \\<not> length tsi \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                          btree_assn k t\n                           ti> pfa_empty (2 * k) \\<bind>\n                               (\\<lambda>b.\n                                   BTree_ImpSet.split_half (a, n) \\<bind>\n                                   (\\<lambda>i.\n pfa_get (a, n) i \\<bind>\n (\\<lambda>m.\n     pfa_drop (a, n) (i + 1) b \\<bind>\n     (\\<lambda>b'.\n         pfa_shrink i (a, n) \\<bind>\n         (\\<lambda>a'.\n             pfa_shrink_cap (2 * k) a' \\<bind>\n             (\\<lambda>a''.\n                 case m of\n                 (sub, sep) \\<Rightarrow>\n                   ref (Btnode a'' sub) \\<bind>\n                   (\\<lambda>l.\n                       ref (Btnode b' ti) \\<bind>\n                       (\\<lambda>r.\n                           return\n                            (Up\\<^sub>i (Some l) sep\n                              (Some\n                                r)))))))))) <btupi_assn k\n        (abs_split.Up\\<^sub>i (Node (take (length tsi div 2) ts) sub) sep\n          (Node rs t))>\\<^sub>t", "apply(sep_auto)[]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab bb ac bc aa ba.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> Suc (length tsi div 2) \\<le> n\n 2. \\<And>ab bb ac bc aa b aaa ba.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> n - Suc (length tsi div 2) \\<le> 2 * k\n 3. \\<And>ab bb ac bc aa b aaa ba x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (dsti', dn') \\<Rightarrow>\n                             is_pfa c tsi (a, n) *\n                             is_pfa (2 * k)\n                              (drop (Suc (length tsi div 2)) tsi)\n                              (dsti', dn') *\n                             \\<up> (dsti' = aa)) *\n                          (blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> pfa_shrink (length tsi div 2)\n                                  (a, n) \\<bind>\n                                 (\\<lambda>a'.\n                                     pfa_shrink_cap (2 * k) a' \\<bind>\n                                     (\\<lambda>a''.\n   ref (Btnode a'' aaa) \\<bind>\n   (\\<lambda>l.\n       ref (Btnode x ti) \\<bind>\n       (\\<lambda>r.\n           return\n            (Up\\<^sub>i (Some l) ba\n              (Some\n                r)))))) <btupi_assn k\n                          (abs_split.Up\\<^sub>i\n                            (Node (take (length tsi div 2) ts) sub) sep\n                            (Node rs t))>\\<^sub>t", "apply(sep_auto simp add: is_pfa_def split_relation_alt)[]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ac bc aa b aaa ba.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> n - Suc (length tsi div 2) \\<le> 2 * k\n 2. \\<And>ab bb ac bc aa b aaa ba x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (dsti', dn') \\<Rightarrow>\n                             is_pfa c tsi (a, n) *\n                             is_pfa (2 * k)\n                              (drop (Suc (length tsi div 2)) tsi)\n                              (dsti', dn') *\n                             \\<up> (dsti' = aa)) *\n                          (blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> pfa_shrink (length tsi div 2)\n                                  (a, n) \\<bind>\n                                 (\\<lambda>a'.\n                                     pfa_shrink_cap (2 * k) a' \\<bind>\n                                     (\\<lambda>a''.\n   ref (Btnode a'' aaa) \\<bind>\n   (\\<lambda>l.\n       ref (Btnode x ti) \\<bind>\n       (\\<lambda>r.\n           return\n            (Up\\<^sub>i (Some l) ba\n              (Some\n                r)))))) <btupi_assn k\n                          (abs_split.Up\\<^sub>i\n                            (Node (take (length tsi div 2) ts) sub) sep\n                            (Node rs t))>\\<^sub>t", "using c_cap"], ["proof (prove)\nusing this:\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n\ngoal (2 subgoals):\n 1. \\<And>ab bb ac bc aa b aaa ba.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> n - Suc (length tsi div 2) \\<le> 2 * k\n 2. \\<And>ab bb ac bc aa b aaa ba x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (dsti', dn') \\<Rightarrow>\n                             is_pfa c tsi (a, n) *\n                             is_pfa (2 * k)\n                              (drop (Suc (length tsi div 2)) tsi)\n                              (dsti', dn') *\n                             \\<up> (dsti' = aa)) *\n                          (blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> pfa_shrink (length tsi div 2)\n                                  (a, n) \\<bind>\n                                 (\\<lambda>a'.\n                                     pfa_shrink_cap (2 * k) a' \\<bind>\n                                     (\\<lambda>a''.\n   ref (Btnode a'' aaa) \\<bind>\n   (\\<lambda>l.\n       ref (Btnode x ti) \\<bind>\n       (\\<lambda>r.\n           return\n            (Up\\<^sub>i (Some l) ba\n              (Some\n                r)))))) <btupi_assn k\n                          (abs_split.Up\\<^sub>i\n                            (Node (take (length tsi div 2) ts) sub) sep\n                            (Node rs t))>\\<^sub>t", "apply(sep_auto simp add: is_pfa_def)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ac bc aa b aaa ba x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (dsti', dn') \\<Rightarrow>\n                             is_pfa c tsi (a, n) *\n                             is_pfa (2 * k)\n                              (drop (Suc (length tsi div 2)) tsi)\n                              (dsti', dn') *\n                             \\<up> (dsti' = aa)) *\n                          (blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> pfa_shrink (length tsi div 2)\n                                  (a, n) \\<bind>\n                                 (\\<lambda>a'.\n                                     pfa_shrink_cap (2 * k) a' \\<bind>\n                                     (\\<lambda>a''.\n   ref (Btnode a'' aaa) \\<bind>\n   (\\<lambda>l.\n       ref (Btnode x ti) \\<bind>\n       (\\<lambda>r.\n           return\n            (Up\\<^sub>i (Some l) ba\n              (Some\n                r)))))) <btupi_assn k\n                          (abs_split.Up\\<^sub>i\n                            (Node (take (length tsi div 2) ts) sub) sep\n                            (Node rs t))>\\<^sub>t", "apply(sep_auto)[]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab bb ac bc aa ba.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> length tsi div 2 \\<le> 2 * k\n 2. \\<And>ab bb ac bc aa aaa ba b.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> 2 * k \\<le> c\n 3. \\<And>ab bb ac bc aa aaa ba b x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (take (length tsi div 2) tsi) x *\n                          true *\n                          (is_pfa (2 * k)\n                            (drop (Suc (length tsi div 2)) tsi) (aa, b) *\n                           blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode x aaa) \\<bind>\n                                 (\\<lambda>l.\n                                     ref (Btnode (aa, b) ti) \\<bind>\n                                     (\\<lambda>r.\n   return\n    (Up\\<^sub>i (Some l) ba\n      (Some\n        r)))) <btupi_assn k\n                (abs_split.Up\\<^sub>i\n                  (Node (take (length tsi div 2) ts) sub) sep\n                  (Node rs t))>\\<^sub>t", "using c_cap"], ["proof (prove)\nusing this:\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n\ngoal (3 subgoals):\n 1. \\<And>ab bb ac bc aa ba.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> length tsi div 2 \\<le> 2 * k\n 2. \\<And>ab bb ac bc aa aaa ba b.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> 2 * k \\<le> c\n 3. \\<And>ab bb ac bc aa aaa ba b x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (take (length tsi div 2) tsi) x *\n                          true *\n                          (is_pfa (2 * k)\n                            (drop (Suc (length tsi div 2)) tsi) (aa, b) *\n                           blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode x aaa) \\<bind>\n                                 (\\<lambda>l.\n                                     ref (Btnode (aa, b) ti) \\<bind>\n                                     (\\<lambda>r.\n   return\n    (Up\\<^sub>i (Some l) ba\n      (Some\n        r)))) <btupi_assn k\n                (abs_split.Up\\<^sub>i\n                  (Node (take (length tsi div 2) ts) sub) sep\n                  (Node rs t))>\\<^sub>t", "apply(sep_auto simp add: is_pfa_def)[]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ac bc aa aaa ba b.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> 2 * k \\<le> c\n 2. \\<And>ab bb ac bc aa aaa ba b x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (take (length tsi div 2) tsi) x *\n                          true *\n                          (is_pfa (2 * k)\n                            (drop (Suc (length tsi div 2)) tsi) (aa, b) *\n                           blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode x aaa) \\<bind>\n                                 (\\<lambda>l.\n                                     ref (Btnode (aa, b) ti) \\<bind>\n                                     (\\<lambda>r.\n   return\n    (Up\\<^sub>i (Some l) ba\n      (Some\n        r)))) <btupi_assn k\n                (abs_split.Up\\<^sub>i\n                  (Node (take (length tsi div 2) ts) sub) sep\n                  (Node rs t))>\\<^sub>t", "using c_cap"], ["proof (prove)\nusing this:\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n\ngoal (2 subgoals):\n 1. \\<And>ab bb ac bc aa aaa ba b.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> 2 * k \\<le> c\n 2. \\<And>ab bb ac bc aa aaa ba b x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (take (length tsi div 2) tsi) x *\n                          true *\n                          (is_pfa (2 * k)\n                            (drop (Suc (length tsi div 2)) tsi) (aa, b) *\n                           blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode x aaa) \\<bind>\n                                 (\\<lambda>l.\n                                     ref (Btnode (aa, b) ti) \\<bind>\n                                     (\\<lambda>r.\n   return\n    (Up\\<^sub>i (Some l) ba\n      (Some\n        r)))) <btupi_assn k\n                (abs_split.Up\\<^sub>i\n                  (Node (take (length tsi div 2) ts) sub) sep\n                  (Node rs t))>\\<^sub>t", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ac bc aa aaa ba b x.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (take (length tsi div 2) tsi) x *\n                          true *\n                          (is_pfa (2 * k)\n                            (drop (Suc (length tsi div 2)) tsi) (aa, b) *\n                           blist_assn k ts tsi *\n                           btree_assn k t\n                            ti)> ref (Btnode x aaa) \\<bind>\n                                 (\\<lambda>l.\n                                     ref (Btnode (aa, b) ti) \\<bind>\n                                     (\\<lambda>r.\n   return\n    (Up\\<^sub>i (Some l) ba\n      (Some\n        r)))) <btupi_assn k\n                (abs_split.Up\\<^sub>i\n                  (Node (take (length tsi div 2) ts) sub) sep\n                  (Node rs t))>\\<^sub>t", "apply(vcg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ac bc aa aaa ba b x xa xb xc.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> xb \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                         xa \\<mapsto>\\<^sub>r Btnode x aaa *\n                         is_pfa (2 * k) (take (length tsi div 2) tsi) x *\n                         is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                          (aa, b) *\n                         blist_assn k ts tsi *\n                         btree_assn k t ti *\n                         true *\n                         \\<up>\n                          (xc =\n                           Up\\<^sub>i (Some xa) ba\n                            (Some xb)) \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.Up\\<^sub>i\n                            (Node (take (length tsi div 2) ts) sub) sep\n                            (Node rs t))\n                          xc *\n                         true", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ac bc aa aaa ba b x xa xb xc.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> xc =\n                         Up\\<^sub>i (Some xa) ba (Some xb) \\<longrightarrow>\n                         (xb \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          xa \\<mapsto>\\<^sub>r Btnode x aaa *\n                          is_pfa (2 * k) (take (length tsi div 2) tsi) x *\n                          is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                           (aa, b) *\n                          blist_assn k ts tsi *\n                          btree_assn k t ti *\n                          true \\<Longrightarrow>\\<^sub>A\n                          \\<exists>\\<^sub>Atsia ti tsi' tsib tia tsi'a.\n                             xa \\<mapsto>\\<^sub>r Btnode tsib tia *\n                             btree_assn k sub tia *\n                             is_pfa (2 * k) tsi'a tsib *\n                             blist_assn k (take (length tsi div 2) ts)\n                              tsi'a *\n                             id_assn sep ba *\n                             (xb \\<mapsto>\\<^sub>r Btnode tsia ti *\n                              btree_assn k t ti *\n                              is_pfa (2 * k) tsi' tsia *\n                              blist_assn k rs tsi') *\n                             true)", "apply(rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ac bc aa aaa ba b x xa xb xc.\n       \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n        ls = take (length tsi div 2) ts;\n        (ab, bb) \\<Turnstile> btree_assn k t ti;\n        (ac, bc) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n        \\<not> length tsi \\<le> 2 * k;\n        split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n         (length tsi div 2);\n        tsi ! (length tsi div 2) = (aaa, ba);\n        xc = Up\\<^sub>i (Some xa) ba (Some xb)\\<rbrakk>\n       \\<Longrightarrow> xb \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                         xa \\<mapsto>\\<^sub>r Btnode x aaa *\n                         is_pfa (2 * k) (take (length tsi div 2) tsi) x *\n                         is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                          (aa, b) *\n                         blist_assn k ts tsi *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Atsia ti tsi' tsib tia tsi'a.\n                            xa \\<mapsto>\\<^sub>r Btnode tsib tia *\n                            btree_assn k sub tia *\n                            is_pfa (2 * k) tsi'a tsib *\n                            blist_assn k (take (length tsi div 2) ts)\n                             tsi'a *\n                            id_assn sep ba *\n                            (xb \\<mapsto>\\<^sub>r Btnode tsia ti *\n                             btree_assn k t ti *\n                             is_pfa (2 * k) tsi' tsia *\n                             blist_assn k rs tsi') *\n                            true", "subgoal for  _ _ _ _ rsa subi ba rn lsi al ar _"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n      (length tsi div 2);\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts tsi *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsia ti tsi' tsib tia tsi'a.\n                         al \\<mapsto>\\<^sub>r Btnode tsib tia *\n                         btree_assn k sub tia *\n                         is_pfa (2 * k) tsi'a tsib *\n                         blist_assn k (take (length tsi div 2) ts) tsi'a *\n                         id_assn sep ba *\n                         (ar \\<mapsto>\\<^sub>r Btnode tsia ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) tsi' tsia *\n                          blist_assn k rs tsi') *\n                         true", "thm ent_ex_postI"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n      (length tsi div 2);\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts tsi *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsia ti tsi' tsib tia tsi'a.\n                         al \\<mapsto>\\<^sub>r Btnode tsib tia *\n                         btree_assn k sub tia *\n                         is_pfa (2 * k) tsi'a tsib *\n                         blist_assn k (take (length tsi div 2) ts) tsi'a *\n                         id_assn sep ba *\n                         (ar \\<mapsto>\\<^sub>r Btnode tsia ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) tsi' tsia *\n                          blist_assn k rs tsi') *\n                         true", "thm ent_ex_postI[where x=\"take (length tsi div 2) tsi\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n      (length tsi div 2);\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts tsi *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsia ti tsi' tsib tia tsi'a.\n                         al \\<mapsto>\\<^sub>r Btnode tsib tia *\n                         btree_assn k sub tia *\n                         is_pfa (2 * k) tsi'a tsib *\n                         blist_assn k (take (length tsi div 2) ts) tsi'a *\n                         id_assn sep ba *\n                         (ar \\<mapsto>\\<^sub>r Btnode tsia ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) tsi' tsia *\n                          blist_assn k rs tsi') *\n                         true", "(* instantiate right hand side *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n      (length tsi div 2);\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts tsi *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsia ti tsi' tsib tia tsi'a.\n                         al \\<mapsto>\\<^sub>r Btnode tsib tia *\n                         btree_assn k sub tia *\n                         is_pfa (2 * k) tsi'a tsib *\n                         blist_assn k (take (length tsi div 2) ts) tsi'a *\n                         id_assn sep ba *\n                         (ar \\<mapsto>\\<^sub>r Btnode tsia ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) tsi' tsia *\n                          blist_assn k rs tsi') *\n                         true", "apply(rule ent_ex_postI[where x=\"(rsa,rn)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n      (length tsi div 2);\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts tsi *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Ati tsi' tsia tia tsi'a.\n                         al \\<mapsto>\\<^sub>r Btnode tsia tia *\n                         btree_assn k sub tia *\n                         is_pfa (2 * k) tsi'a tsia *\n                         blist_assn k (take (length tsi div 2) ts) tsi'a *\n                         id_assn sep ba *\n                         (ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) tsi' (rsa, rn) *\n                          blist_assn k rs tsi') *\n                         true", "apply(rule ent_ex_postI[where x=\"ti\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n      (length tsi div 2);\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts tsi *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsi' tsia tia tsi'a.\n                         al \\<mapsto>\\<^sub>r Btnode tsia tia *\n                         btree_assn k sub tia *\n                         is_pfa (2 * k) tsi'a tsia *\n                         blist_assn k (take (length tsi div 2) ts) tsi'a *\n                         id_assn sep ba *\n                         (ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) tsi' (rsa, rn) *\n                          blist_assn k rs tsi') *\n                         true", "apply(rule ent_ex_postI[where x=\"(drop (Suc (length tsi div 2)) tsi)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n      (length tsi div 2);\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts tsi *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsia tia tsi'.\n                         al \\<mapsto>\\<^sub>r Btnode tsia tia *\n                         btree_assn k sub tia *\n                         is_pfa (2 * k) tsi' tsia *\n                         blist_assn k (take (length tsi div 2) ts) tsi' *\n                         id_assn sep ba *\n                         (ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                           (rsa, rn) *\n                          blist_assn k rs\n                           (drop (Suc (length tsi div 2)) tsi)) *\n                         true", "apply(rule ent_ex_postI[where x=\"lsi\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n      (length tsi div 2);\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts tsi *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atia tsi'.\n                         al \\<mapsto>\\<^sub>r Btnode lsi tia *\n                         btree_assn k sub tia *\n                         is_pfa (2 * k) tsi' lsi *\n                         blist_assn k (take (length tsi div 2) ts) tsi' *\n                         id_assn sep ba *\n                         (ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                           (rsa, rn) *\n                          blist_assn k rs\n                           (drop (Suc (length tsi div 2)) tsi)) *\n                         true", "apply(rule ent_ex_postI[where x=\"subi\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n      (length tsi div 2);\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts tsi *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsi'.\n                         al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                         btree_assn k sub subi *\n                         is_pfa (2 * k) tsi' lsi *\n                         blist_assn k (take (length tsi div 2) ts) tsi' *\n                         id_assn sep ba *\n                         (ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                           (rsa, rn) *\n                          blist_assn k rs\n                           (drop (Suc (length tsi div 2)) tsi)) *\n                         true", "apply(rule ent_ex_postI[where x=\"take (length tsi div 2) tsi\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n      (length tsi div 2);\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts tsi *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      btree_assn k sub subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      blist_assn k (take (length tsi div 2) ts)\n                       (take (length tsi div 2) tsi) *\n                      id_assn sep ba *\n                      (ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                       btree_assn k t ti *\n                       is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                        (rsa, rn) *\n                       blist_assn k rs\n                        (drop (Suc (length tsi div 2)) tsi)) *\n                      true", "(* introduce equality between equality of split tsi/ts and original lists *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     split_relation ts (take (length tsi div 2) ts, (sub, sep) # rs)\n      (length tsi div 2);\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts tsi *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      btree_assn k sub subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      blist_assn k (take (length tsi div 2) ts)\n                       (take (length tsi div 2) tsi) *\n                      id_assn sep ba *\n                      (ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                       btree_assn k t ti *\n                       is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                        (rsa, rn) *\n                       blist_assn k rs\n                        (drop (Suc (length tsi div 2)) tsi)) *\n                      true", "apply(simp add: split_relation_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts tsi *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      btree_assn k sub subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      blist_assn k (take (length tsi div 2) ts)\n                       (take (length tsi div 2) tsi) *\n                      id_assn sep ba *\n                      (ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                       btree_assn k t ti *\n                       is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                        (rsa, rn) *\n                       blist_assn k rs\n                        (drop (Suc (length tsi div 2)) tsi)) *\n                      true", "apply(subgoal_tac \"tsi =\n            take (length tsi div 2) tsi @ (subi, ba) # drop (Suc (length tsi div 2)) tsi\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts tsi *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      btree_assn k sub subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      blist_assn k (take (length tsi div 2) ts)\n                       (take (length tsi div 2) tsi) *\n                      id_assn sep ba *\n                      (ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                       btree_assn k t ti *\n                       is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                        (rsa, rn) *\n                       blist_assn k rs\n                        (drop (Suc (length tsi div 2)) tsi)) *\n                      true\n 2. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> tsi =\n                      take (length tsi div 2) tsi @\n                      (subi, ba) # drop (Suc (length tsi div 2)) tsi", "apply(rule back_subst[where a=\"blist_assn k ts (take (length tsi div 2) tsi @ (subi, ba) # (drop (Suc (length tsi div 2)) tsi))\" and b=\"blist_assn k ts tsi\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k ts\n                       (take (length tsi div 2) tsi @\n                        (subi, ba) # drop (Suc (length tsi div 2)) tsi) *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      btree_assn k sub subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      blist_assn k (take (length tsi div 2) ts)\n                       (take (length tsi div 2) tsi) *\n                      id_assn sep ba *\n                      (ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                       btree_assn k t ti *\n                       is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                        (rsa, rn) *\n                       blist_assn k rs\n                        (drop (Suc (length tsi div 2)) tsi)) *\n                      true\n 2. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> blist_assn k ts\n                       (take (length tsi div 2) tsi @\n                        (subi, ba) # drop (Suc (length tsi div 2)) tsi) =\n                      blist_assn k ts tsi\n 3. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> tsi =\n                      take (length tsi div 2) tsi @\n                      (subi, ba) # drop (Suc (length tsi div 2)) tsi", "apply(rule back_subst[where a=\"blist_assn k (take (length tsi div 2) ts @ (sub, sep) # rs)\" and b=\"blist_assn k ts\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      blist_assn k\n                       (take (length tsi div 2) ts @ (sub, sep) # rs)\n                       (take (length tsi div 2) tsi @\n                        (subi, ba) # drop (Suc (length tsi div 2)) tsi) *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      btree_assn k sub subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      blist_assn k (take (length tsi div 2) ts)\n                       (take (length tsi div 2) tsi) *\n                      id_assn sep ba *\n                      (ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                       btree_assn k t ti *\n                       is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                        (rsa, rn) *\n                       blist_assn k rs\n                        (drop (Suc (length tsi div 2)) tsi)) *\n                      true\n 2. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> blist_assn k\n                       (take (length tsi div 2) ts @ (sub, sep) # rs) =\n                      blist_assn k ts\n 3. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> blist_assn k ts\n                       (take (length tsi div 2) tsi @\n                        (subi, ba) # drop (Suc (length tsi div 2)) tsi) =\n                      blist_assn k ts tsi\n 4. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> tsi =\n                      take (length tsi div 2) tsi @\n                      (subi, ba) # drop (Suc (length tsi div 2)) tsi", "apply(subst list_assn_aux_append_Cons)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> length (take (length tsi div 2) ts) =\n                      length (take (length tsi div 2) tsi)\n 2. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      (blist_assn k (take (length tsi div 2) ts)\n                        (take (length tsi div 2) tsi) *\n                       (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep)\n                        (subi, ba) *\n                       blist_assn k rs\n                        (drop (Suc (length tsi div 2)) tsi)) *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      btree_assn k sub subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      blist_assn k (take (length tsi div 2) ts)\n                       (take (length tsi div 2) tsi) *\n                      id_assn sep ba *\n                      (ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                       btree_assn k t ti *\n                       is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                        (rsa, rn) *\n                       blist_assn k rs\n                        (drop (Suc (length tsi div 2)) tsi)) *\n                      true\n 3. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> blist_assn k\n                       (take (length tsi div 2) ts @ (sub, sep) # rs) =\n                      blist_assn k ts\n 4. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> blist_assn k ts\n                       (take (length tsi div 2) tsi @\n                        (subi, ba) # drop (Suc (length tsi div 2)) tsi) =\n                      blist_assn k ts tsi\n 5. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> tsi =\n                      take (length tsi div 2) tsi @\n                      (subi, ba) # drop (Suc (length tsi div 2)) tsi", "apply sep_auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                       (rsa, rn) *\n                      (blist_assn k (take (length tsi div 2) ts)\n                        (take (length tsi div 2) tsi) *\n                       (btree_assn k \\<times>\\<^sub>a id_assn) (sub, sep)\n                        (subi, ba) *\n                       blist_assn k rs\n                        (drop (Suc (length tsi div 2)) tsi)) *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      al \\<mapsto>\\<^sub>r Btnode lsi subi *\n                      btree_assn k sub subi *\n                      is_pfa (2 * k) (take (length tsi div 2) tsi) lsi *\n                      blist_assn k (take (length tsi div 2) ts)\n                       (take (length tsi div 2) tsi) *\n                      id_assn sep ba *\n                      (ar \\<mapsto>\\<^sub>r Btnode (rsa, rn) ti *\n                       btree_assn k t ti *\n                       is_pfa (2 * k) (drop (Suc (length tsi div 2)) tsi)\n                        (rsa, rn) *\n                       blist_assn k rs\n                        (drop (Suc (length tsi div 2)) tsi)) *\n                      true\n 2. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> blist_assn k\n                       (take (length tsi div 2) ts @ (sub, sep) # rs) =\n                      blist_assn k ts\n 3. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> blist_assn k ts\n                       (take (length tsi div 2) tsi @\n                        (subi, ba) # drop (Suc (length tsi div 2)) tsi) =\n                      blist_assn k ts tsi\n 4. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> tsi =\n                      take (length tsi div 2) tsi @\n                      (subi, ba) # drop (Suc (length tsi div 2)) tsi", "apply sep_auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> blist_assn k\n                       (take (length tsi div 2) ts @ (sub, sep) # rs) =\n                      blist_assn k ts\n 2. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> blist_assn k ts\n                       (take (length tsi div 2) tsi @\n                        (subi, ba) # drop (Suc (length tsi div 2)) tsi) =\n                      blist_assn k ts tsi\n 3. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> tsi =\n                      take (length tsi div 2) tsi @\n                      (subi, ba) # drop (Suc (length tsi div 2)) tsi", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar);\n     tsi =\n     take (length tsi div 2) tsi @\n     (subi, ba) # drop (Suc (length tsi div 2)) tsi\\<rbrakk>\n    \\<Longrightarrow> blist_assn k ts\n                       (take (length tsi div 2) tsi @\n                        (subi, ba) # drop (Suc (length tsi div 2)) tsi) =\n                      blist_assn k ts tsi\n 2. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> tsi =\n                      take (length tsi div 2) tsi @\n                      (subi, ba) # drop (Suc (length tsi div 2)) tsi", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> tsi =\n                      take (length tsi div 2) tsi @\n                      (subi, ba) # drop (Suc (length tsi div 2)) tsi", "apply(rule back_subst[where a=\"tsi ! (length tsi div 2)\" and b=\"(subi, ba)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> tsi =\n                      take (length tsi div 2) tsi @\n                      tsi ! (length tsi div 2) #\n                      drop (Suc (length tsi div 2)) tsi\n 2. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> tsi ! (length tsi div 2) = (subi, ba)", "apply(rule id_take_nth_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> length tsi div 2 < length tsi\n 2. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> tsi ! (length tsi div 2) = (subi, ba)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length tsi div 2) ts = (sub, sep) # rs;\n     ls = take (length tsi div 2) ts;\n     (ab_, bb_) \\<Turnstile> btree_assn k t ti;\n     (ac_, bc_) \\<Turnstile> is_pfa c tsi (a, n); length ts = length tsi;\n     \\<not> length tsi \\<le> 2 * k;\n     ts = take (length tsi div 2) ts @ (sub, sep) # rs;\n     tsi ! (length tsi div 2) = (subi, ba);\n     xc_ = Up\\<^sub>i (Some al) ba (Some ar)\\<rbrakk>\n    \\<Longrightarrow> tsi ! (length tsi div 2) = (subi, ba)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <is_pfa c tsi (a, n) * blist_assn k ts tsi *\n   btree_assn k t\n    ti> node\\<^sub>i k (a, n)\n         ti <btupi_assn k (abs_split.node\\<^sub>i k ts t)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "declare abs_split.node\\<^sub>i.simps [simp del]"], ["", "lemma node\\<^sub>i_no_split: \"length ts \\<le> 2*k \\<Longrightarrow> abs_split.node\\<^sub>i k ts t = abs_split.T\\<^sub>i (Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    abs_split.node\\<^sub>i k ts t = abs_split.T\\<^sub>i (Node ts t)", "by (simp add: abs_split.node\\<^sub>i.simps)"], ["", "lemma node\\<^sub>i_rule_app: \"\\<lbrakk>2*k \\<le> c; c \\<le> 4*k+1\\<rbrakk> \\<Longrightarrow>\n<is_pfa c (tsi' @ [(li, ai)]) (aa, al) *\n   blist_assn k ls tsi' *\n   btree_assn k l li *\n   id_assn a ai *\n   btree_assn k r ri> node\\<^sub>i k (aa, al) ri\n <btupi_assn k (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (tsi' @ [(li, ai)]) (aa, al) *\n                       blist_assn k ls tsi' *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       btree_assn k r\n                        ri> node\\<^sub>i k (aa, al)\n                             ri <btupi_assn k\n                                  (abs_split.node\\<^sub>i k (ls @ [(l, a)])\n                                    r)>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (tsi' @ [(li, ai)]) (aa, al) *\n                       blist_assn k ls tsi' *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       btree_assn k r\n                        ri> node\\<^sub>i k (aa, al)\n                             ri <btupi_assn k\n                                  (abs_split.node\\<^sub>i k (ls @ [(l, a)])\n                                    r)>\\<^sub>t", "note node\\<^sub>i_rule[of k c \"(tsi' @ [(li, ai)])\" aa al \"(ls @ [(l, a)])\" r ri]"], ["proof (state)\nthis:\n  \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n  \\<Longrightarrow> <is_pfa c (tsi' @ [(li, ai)]) (aa, al) *\n                     blist_assn k (ls @ [(l, a)]) (tsi' @ [(li, ai)]) *\n                     btree_assn k r\n                      ri> node\\<^sub>i k (aa, al)\n                           ri <btupi_assn k\n                                (abs_split.node\\<^sub>i k (ls @ [(l, a)])\n                                  r)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (tsi' @ [(li, ai)]) (aa, al) *\n                       blist_assn k ls tsi' *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       btree_assn k r\n                        ri> node\\<^sub>i k (aa, al)\n                             ri <btupi_assn k\n                                  (abs_split.node\\<^sub>i k (ls @ [(l, a)])\n                                    r)>\\<^sub>t", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n  \\<Longrightarrow> <is_pfa c (tsi' @ [(li, ai)]) (aa, al) *\n                     blist_assn k (ls @ [(l, a)]) (tsi' @ [(li, ai)]) *\n                     btree_assn k r\n                      ri> node\\<^sub>i k (aa, al)\n                           ri <btupi_assn k\n                                (abs_split.node\\<^sub>i k (ls @ [(l, a)])\n                                  r)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (tsi' @ [(li, ai)]) (aa, al) *\n                       blist_assn k ls tsi' *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       btree_assn k r\n                        ri> node\\<^sub>i k (aa, al)\n                             ri <btupi_assn k\n                                  (abs_split.node\\<^sub>i k (ls @ [(l, a)])\n                                    r)>\\<^sub>t", "assume \"2*k \\<le> c\" \"c \\<le> 4*k+1\""], ["proof (state)\nthis:\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (tsi' @ [(li, ai)]) (aa, al) *\n                       blist_assn k ls tsi' *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       btree_assn k r\n                        ri> node\\<^sub>i k (aa, al)\n                             ri <btupi_assn k\n                                  (abs_split.node\\<^sub>i k (ls @ [(l, a)])\n                                    r)>\\<^sub>t", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n  \\<Longrightarrow> <is_pfa c (tsi' @ [(li, ai)]) (aa, al) *\n                     blist_assn k (ls @ [(l, a)]) (tsi' @ [(li, ai)]) *\n                     btree_assn k r\n                      ri> node\\<^sub>i k (aa, al)\n                           ri <btupi_assn k\n                                (abs_split.node\\<^sub>i k (ls @ [(l, a)])\n                                  r)>\\<^sub>t\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n  \\<Longrightarrow> <is_pfa c (tsi' @ [(li, ai)]) (aa, al) *\n                     blist_assn k (ls @ [(l, a)]) (tsi' @ [(li, ai)]) *\n                     btree_assn k r\n                      ri> node\\<^sub>i k (aa, al)\n                           ri <btupi_assn k\n                                (abs_split.node\\<^sub>i k (ls @ [(l, a)])\n                                  r)>\\<^sub>t\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n\ngoal (1 subgoal):\n 1. <is_pfa c (tsi' @ [(li, ai)]) (aa, al) * blist_assn k ls tsi' *\n     btree_assn k l li *\n     id_assn a ai *\n     btree_assn k r\n      ri> node\\<^sub>i k (aa, al)\n           ri <btupi_assn k\n                (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t", "by (simp add: mult.left_assoc)"], ["proof (state)\nthis:\n  <is_pfa c (tsi' @ [(li, ai)]) (aa, al) * blist_assn k ls tsi' *\n   btree_assn k l li *\n   id_assn a ai *\n   btree_assn k r\n    ri> node\\<^sub>i k (aa, al)\n         ri <btupi_assn k\n              (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma node\\<^sub>i_rule_ins2: \"\\<lbrakk>2*k \\<le> c; c \\<le> 4*k+1; length ls = length lsi\\<rbrakk> \\<Longrightarrow>\n <is_pfa c (lsi @ (li, ai) # (ri,a'i) # rsi) (aa, al) *\n   blist_assn k ls lsi *\n   btree_assn k l li *\n   id_assn a ai *\n   btree_assn k r ri *\n   id_assn a' a'i *\n   blist_assn k rs rsi *\n   btree_assn k t ti> node\\<^sub>i k (aa, al)\n          ti <btupi_assn k (abs_split.node\\<^sub>i k (ls @ (l, a) # (r,a') # rs) t)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1;\n     length ls = length lsi\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # (ri, a'i) # rsi)\n                        (aa, al) *\n                       blist_assn k ls lsi *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       btree_assn k r ri *\n                       id_assn a' a'i *\n                       blist_assn k rs rsi *\n                       btree_assn k t\n                        ti> node\\<^sub>i k (aa, al)\n                             ti <btupi_assn k\n                                  (abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # (r, a') # rs) t)>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1;\n     length ls = length lsi\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # (ri, a'i) # rsi)\n                        (aa, al) *\n                       blist_assn k ls lsi *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       btree_assn k r ri *\n                       id_assn a' a'i *\n                       blist_assn k rs rsi *\n                       btree_assn k t\n                        ti> node\\<^sub>i k (aa, al)\n                             ti <btupi_assn k\n                                  (abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # (r, a') # rs) t)>\\<^sub>t", "assume [simp]: \"2*k \\<le> c\" \"c \\<le> 4*k+1\" \"length ls = length lsi\""], ["proof (state)\nthis:\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n  length ls = length lsi\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1;\n     length ls = length lsi\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # (ri, a'i) # rsi)\n                        (aa, al) *\n                       blist_assn k ls lsi *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       btree_assn k r ri *\n                       id_assn a' a'i *\n                       blist_assn k rs rsi *\n                       btree_assn k t\n                        ti> node\\<^sub>i k (aa, al)\n                             ti <btupi_assn k\n                                  (abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # (r, a') # rs) t)>\\<^sub>t", "moreover"], ["proof (state)\nthis:\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n  length ls = length lsi\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1;\n     length ls = length lsi\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # (ri, a'i) # rsi)\n                        (aa, al) *\n                       blist_assn k ls lsi *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       btree_assn k r ri *\n                       id_assn a' a'i *\n                       blist_assn k rs rsi *\n                       btree_assn k t\n                        ti> node\\<^sub>i k (aa, al)\n                             ti <btupi_assn k\n                                  (abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # (r, a') # rs) t)>\\<^sub>t", "note node\\<^sub>i_rule[of k c \"(lsi @ (li, ai) # (ri,a'i) # rsi)\" aa al \"(ls @ (l, a) # (r,a') # rs)\" t ti]"], ["proof (state)\nthis:\n  \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n  \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # (ri, a'i) # rsi) (aa, al) *\n                     blist_assn k (ls @ (l, a) # (r, a') # rs)\n                      (lsi @ (li, ai) # (ri, a'i) # rsi) *\n                     btree_assn k t\n                      ti> node\\<^sub>i k (aa, al)\n                           ti <btupi_assn k\n                                (abs_split.node\\<^sub>i k\n                                  (ls @ (l, a) # (r, a') # rs) t)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1;\n     length ls = length lsi\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # (ri, a'i) # rsi)\n                        (aa, al) *\n                       blist_assn k ls lsi *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       btree_assn k r ri *\n                       id_assn a' a'i *\n                       blist_assn k rs rsi *\n                       btree_assn k t\n                        ti> node\\<^sub>i k (aa, al)\n                             ti <btupi_assn k\n                                  (abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # (r, a') # rs) t)>\\<^sub>t", "ultimately"], ["proof (chain)\npicking this:\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n  length ls = length lsi\n  \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n  \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # (ri, a'i) # rsi) (aa, al) *\n                     blist_assn k (ls @ (l, a) # (r, a') # rs)\n                      (lsi @ (li, ai) # (ri, a'i) # rsi) *\n                     btree_assn k t\n                      ti> node\\<^sub>i k (aa, al)\n                           ti <btupi_assn k\n                                (abs_split.node\\<^sub>i k\n                                  (ls @ (l, a) # (r, a') # rs) t)>\\<^sub>t", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n  length ls = length lsi\n  \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n  \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # (ri, a'i) # rsi) (aa, al) *\n                     blist_assn k (ls @ (l, a) # (r, a') # rs)\n                      (lsi @ (li, ai) # (ri, a'i) # rsi) *\n                     btree_assn k t\n                      ti> node\\<^sub>i k (aa, al)\n                           ti <btupi_assn k\n                                (abs_split.node\\<^sub>i k\n                                  (ls @ (l, a) # (r, a') # rs) t)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. <is_pfa c (lsi @ (li, ai) # (ri, a'i) # rsi) (aa, al) *\n     blist_assn k ls lsi *\n     btree_assn k l li *\n     id_assn a ai *\n     btree_assn k r ri *\n     id_assn a' a'i *\n     blist_assn k rs rsi *\n     btree_assn k t\n      ti> node\\<^sub>i k (aa, al)\n           ti <btupi_assn k\n                (abs_split.node\\<^sub>i k (ls @ (l, a) # (r, a') # rs)\n                  t)>\\<^sub>t", "by (simp add: mult.left_assoc list_assn_aux_append_Cons)"], ["proof (state)\nthis:\n  <is_pfa c (lsi @ (li, ai) # (ri, a'i) # rsi) (aa, al) *\n   blist_assn k ls lsi *\n   btree_assn k l li *\n   id_assn a ai *\n   btree_assn k r ri *\n   id_assn a' a'i *\n   blist_assn k rs rsi *\n   btree_assn k t\n    ti> node\\<^sub>i k (aa, al)\n         ti <btupi_assn k\n              (abs_split.node\\<^sub>i k (ls @ (l, a) # (r, a') # rs)\n                t)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ins_rule:\n  \"sorted_less (inorder t) \\<Longrightarrow> <btree_assn k t ti>\n  ins k x ti\n  <\\<lambda>r. btupi_assn k (abs_split.ins k x t) r>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder t) \\<Longrightarrow>\n    <btree_assn k t\n      ti> ins k x ti <btupi_assn k (abs_split.ins k x t)>\\<^sub>t", "proof (induction k x t arbitrary: ti rule: abs_split.ins.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k x ti.\n       sorted_less (inorder Leaf) \\<Longrightarrow>\n       <btree_assn k Leaf\n         ti> ins k x ti <btupi_assn k (abs_split.ins k x Leaf)>\\<^sub>t\n 2. \\<And>k x ts t ti.\n       \\<lbrakk>\\<And>xa y ti.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> ins k x ti <btupi_assn k (abs_split.ins k x t)>\\<^sub>t;\n        \\<And>xa y x21 x22 xb ya ti.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xb\n                               ti> ins k x\n                                    ti <btupi_assn k\n   (abs_split.ins k x xb)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "case (1 k x)"], ["proof (state)\nthis:\n  sorted_less (inorder Leaf)\n\ngoal (2 subgoals):\n 1. \\<And>k x ti.\n       sorted_less (inorder Leaf) \\<Longrightarrow>\n       <btree_assn k Leaf\n         ti> ins k x ti <btupi_assn k (abs_split.ins k x Leaf)>\\<^sub>t\n 2. \\<And>k x ts t ti.\n       \\<lbrakk>\\<And>xa y ti.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> ins k x ti <btupi_assn k (abs_split.ins k x t)>\\<^sub>t;\n        \\<And>xa y x21 x22 xb ya ti.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xb\n                               ti> ins k x\n                                    ti <btupi_assn k\n   (abs_split.ins k x xb)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  sorted_less (inorder Leaf)", "show ?case"], ["proof (prove)\nusing this:\n  sorted_less (inorder Leaf)\n\ngoal (1 subgoal):\n 1. <btree_assn k Leaf\n      ti> ins k x ti <btupi_assn k (abs_split.ins k x Leaf)>\\<^sub>t", "apply(subst ins.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder Leaf) \\<Longrightarrow>\n    <btree_assn k Leaf\n      ti> case ti of None \\<Rightarrow> return (Up\\<^sub>i None x None)\n          | Some ap \\<Rightarrow>\n              !ap \\<bind>\n              (\\<lambda>a.\n                  imp_split (kvs a) x \\<bind>\n                  (\\<lambda>i.\n                      pfa_length (kvs a) \\<bind>\n                      (\\<lambda>tsl.\n                          if i < tsl\n                          then pfa_get (kvs a) i \\<bind>\n                               (\\<lambda>s.\n                                   let (sub, sep) = s\n                                   in if sep = x then return (T\\<^sub>i ti)\nelse ins k x sub \\<bind>\n     case_btupi\n      (\\<lambda>lp.\n          pfa_set (kvs a) i (lp, sep) \\<bind>\n          (\\<lambda>_. return (T\\<^sub>i ti)))\n      (\\<lambda>lp x' rp.\n          pfa_set (kvs a) i (rp, sep) \\<bind>\n          (\\<lambda>_.\n              if tsl < 2 * k\n              then pfa_insert (kvs a) i (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       ap := Btnode kvs' (BTree_Imp.last a) \\<bind>\n                       (\\<lambda>_. return (T\\<^sub>i ti)))\n              else pfa_insert_grow (kvs a) i (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n                          else ins k x (BTree_Imp.last a) \\<bind>\n                               case_btupi\n                                (\\<lambda>lp.\n                                    ap := Btnode (kvs a) lp \\<bind>\n                                    (\\<lambda>_. return (T\\<^sub>i ti)))\n                                (\\<lambda>lp x' rp.\n                                    if tsl < 2 * k\n                                    then pfa_append (kvs a) (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       ap := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i ti)))\n                                    else pfa_append_grow' (kvs a)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       node\\<^sub>i k kvs'\n        rp))))) <btupi_assn k (abs_split.ins k x Leaf)>\\<^sub>t", "apply (sep_auto simp add: pure_app_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <btree_assn k Leaf\n    ti> ins k x ti <btupi_assn k (abs_split.ins k x Leaf)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>k x ts t ti.\n       \\<lbrakk>\\<And>xa y ti.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> ins k x ti <btupi_assn k (abs_split.ins k x t)>\\<^sub>t;\n        \\<And>xa y x21 x22 xb ya ti.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xb\n                               ti> ins k x\n                                    ti <btupi_assn k\n   (abs_split.ins k x xb)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k x ts t ti.\n       \\<lbrakk>\\<And>xa y ti.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> ins k x ti <btupi_assn k (abs_split.ins k x t)>\\<^sub>t;\n        \\<And>xa y x21 x22 xb ya ti.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xb\n                               ti> ins k x\n                                    ti <btupi_assn k\n   (abs_split.ins k x xb)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "case (2 k x ts t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> <btree_assn k t\n                      ?ti> ins k x\n                            ?ti <btupi_assn k (abs_split.ins k x t)>\\<^sub>t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; sorted_less (inorder ?xb)\\<rbrakk>\n  \\<Longrightarrow> <btree_assn k ?xb\n                      ?ti> ins k x\n                            ?ti <btupi_assn k\n                                  (abs_split.ins k x ?xb)>\\<^sub>t\n  sorted_less (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>k x ts t ti.\n       \\<lbrakk>\\<And>xa y ti.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> ins k x ti <btupi_assn k (abs_split.ins k x t)>\\<^sub>t;\n        \\<And>xa y x21 x22 xb ya ti.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xb\n                               ti> ins k x\n                                    ti <btupi_assn k\n   (abs_split.ins k x xb)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "obtain ls rrs where list_split: \"split ts x = (ls,rrs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ls rrs.\n        split ts x = (ls, rrs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split ts x\")"], ["proof (state)\nthis:\n  split ts x = (ls, rrs)\n\ngoal (1 subgoal):\n 1. \\<And>k x ts t ti.\n       \\<lbrakk>\\<And>xa y ti.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> ins k x ti <btupi_assn k (abs_split.ins k x t)>\\<^sub>t;\n        \\<And>xa y x21 x22 xb ya ti.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xb\n                               ti> ins k x\n                                    ti <btupi_assn k\n   (abs_split.ins k x xb)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "have [simp]: \"sorted_less (separators ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (separators ts)", "using \"2.prems\" sorted_inorder_separators"], ["proof (prove)\nusing this:\n  sorted_less (inorder (Node ts t))\n  sorted_less (inorder (Node ?ts ?t)) \\<Longrightarrow>\n  sorted_less (separators ?ts)\n\ngoal (1 subgoal):\n 1. sorted_less (separators ts)", "by simp"], ["proof (state)\nthis:\n  sorted_less (separators ts)\n\ngoal (1 subgoal):\n 1. \\<And>k x ts t ti.\n       \\<lbrakk>\\<And>xa y ti.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> ins k x ti <btupi_assn k (abs_split.ins k x t)>\\<^sub>t;\n        \\<And>xa y x21 x22 xb ya ti.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xb\n                               ti> ins k x\n                                    ti <btupi_assn k\n   (abs_split.ins k x xb)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "have [simp]: \"sorted_less (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder t)", "using \"2.prems\" sorted_inorder_induct_last"], ["proof (prove)\nusing this:\n  sorted_less (inorder (Node ts t))\n  sorted_less (inorder (Node ?ts ?t)) \\<Longrightarrow>\n  sorted_less (inorder ?t)\n\ngoal (1 subgoal):\n 1. sorted_less (inorder t)", "by simp"], ["proof (state)\nthis:\n  sorted_less (inorder t)\n\ngoal (1 subgoal):\n 1. \\<And>k x ts t ti.\n       \\<lbrakk>\\<And>xa y ti.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> <btree_assn k t\n ti> ins k x ti <btupi_assn k (abs_split.ins k x t)>\\<^sub>t;\n        \\<And>xa y x21 x22 xb ya ti.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> <btree_assn k xb\n                               ti> ins k x\n                                    ti <btupi_assn k\n   (abs_split.ins k x xb)>\\<^sub>t;\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "proof (cases rrs)"], ["proof (state)\ngoal (2 subgoals):\n 1. rrs = [] \\<Longrightarrow>\n    <btree_assn k (Node ts t)\n      ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t\n 2. \\<And>a list.\n       rrs = a # list \\<Longrightarrow>\n       <btree_assn k (Node ts t)\n         ti> ins k x\n              ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "case Nil"], ["proof (state)\nthis:\n  rrs = []\n\ngoal (2 subgoals):\n 1. rrs = [] \\<Longrightarrow>\n    <btree_assn k (Node ts t)\n      ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t\n 2. \\<And>a list.\n       rrs = a # list \\<Longrightarrow>\n       <btree_assn k (Node ts t)\n         ti> ins k x\n              ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  rrs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  rrs = []\n\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "proof (cases \"abs_split.ins k x t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>rrs = [];\n        abs_split.ins k x t = abs_split.T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rrs = [];\n        abs_split.ins k x t = abs_split.Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "case (T\\<^sub>i a)"], ["proof (state)\nthis:\n  abs_split.ins k x t = abs_split.T\\<^sub>i a\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>rrs = [];\n        abs_split.ins k x t = abs_split.T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rrs = [];\n        abs_split.ins k x t = abs_split.Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  abs_split.ins k x t = abs_split.T\\<^sub>i a", "show ?thesis"], ["proof (prove)\nusing this:\n  abs_split.ins k x t = abs_split.T\\<^sub>i a\n\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "apply(subst ins.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_split.ins k x t = abs_split.T\\<^sub>i a \\<Longrightarrow>\n    <btree_assn k (Node ts t)\n      ti> case ti of None \\<Rightarrow> return (Up\\<^sub>i None x None)\n          | Some ap \\<Rightarrow>\n              !ap \\<bind>\n              (\\<lambda>a.\n                  imp_split (kvs a) x \\<bind>\n                  (\\<lambda>i.\n                      pfa_length (kvs a) \\<bind>\n                      (\\<lambda>tsl.\n                          if i < tsl\n                          then pfa_get (kvs a) i \\<bind>\n                               (\\<lambda>s.\n                                   let (sub, sep) = s\n                                   in if sep = x then return (T\\<^sub>i ti)\nelse ins k x sub \\<bind>\n     case_btupi\n      (\\<lambda>lp.\n          pfa_set (kvs a) i (lp, sep) \\<bind>\n          (\\<lambda>_. return (T\\<^sub>i ti)))\n      (\\<lambda>lp x' rp.\n          pfa_set (kvs a) i (rp, sep) \\<bind>\n          (\\<lambda>_.\n              if tsl < 2 * k\n              then pfa_insert (kvs a) i (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       ap := Btnode kvs' (BTree_Imp.last a) \\<bind>\n                       (\\<lambda>_. return (T\\<^sub>i ti)))\n              else pfa_insert_grow (kvs a) i (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n                          else ins k x (BTree_Imp.last a) \\<bind>\n                               case_btupi\n                                (\\<lambda>lp.\n                                    ap := Btnode (kvs a) lp \\<bind>\n                                    (\\<lambda>_. return (T\\<^sub>i ti)))\n                                (\\<lambda>lp x' rp.\n                                    if tsl < 2 * k\n                                    then pfa_append (kvs a) (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       ap := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i ti)))\n                                    else pfa_append_grow' (kvs a)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       node\\<^sub>i k kvs'\n        rp))))) <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x aa b ti tsi' xb sub.\n       \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some x;\n        split_relation ts (split ts x) xb; xb < length tsi';\n        tsi' ! xb = (sub, x)\\<rbrakk>\n       \\<Longrightarrow> is_pfa (2 * k) tsi' (aa, b) *\n                         blist_assn k ts tsi' *\n                         x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (case split ts x of\n                           (ls, []) \\<Rightarrow>\n                             abs_split.T\\<^sub>i (Node ls a)\n                           | (ls, (sub, sep) # rs) \\<Rightarrow>\n                               if sep = x\n                               then abs_split.T\\<^sub>i (Node ts t)\n                               else case abs_split.ins k x sub of\n                                    abs_split.T\\<^sub>i a \\<Rightarrow>\nabs_split.T\\<^sub>i (Node (ls @ (a, sep) # rs) t)\n                                    | abs_split.Up\\<^sub>i l a\n r \\<Rightarrow>\n  abs_split.node\\<^sub>i k (ls @ (l, a) # (r, sep) # rs) t)\n                          (T\\<^sub>i (Some x)) *\n                         true\n 2. \\<And>x aa b ti tsi' xb xaa xc sub sep.\n       \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some x;\n        split_relation ts (split ts x) xb; xaa = length tsi';\n        xb < length tsi'; tsi' ! xb = (sub, sep); xc = (sub, sep);\n        sep \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (aa, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x sub \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (aa, b) xb (lp, sep) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (aa, b) xb (rp, sep) \\<bind>\n                                     (\\<lambda>_.\n   if length tsi' < 2 * k\n   then pfa_insert (aa, b) xb (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (aa, b) xb (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (case split ts x of\n                      (ls, []) \\<Rightarrow> abs_split.T\\<^sub>i (Node ls a)\n                      | (ls, (sub, sep) # rs) \\<Rightarrow>\n                          if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                          else case abs_split.ins k x sub of\n                               abs_split.T\\<^sub>i a \\<Rightarrow>\n                                 abs_split.T\\<^sub>i\n                                  (Node (ls @ (a, sep) # rs) t)\n                               | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                   abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # (r, sep) # rs)\n                                    t)>\\<^sub>t\n 3. \\<And>x aa b ti tsi' xb xaa.\n       \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some x;\n        split_relation ts (split ts x) xb; xaa = length tsi';\n        \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (aa, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length tsi' < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (case split ts x of\n                 (ls, []) \\<Rightarrow> abs_split.T\\<^sub>i (Node ls a)\n                 | (ls, (sub, sep) # rs) \\<Rightarrow>\n                     if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                     else case abs_split.ins k x sub of\n                          abs_split.T\\<^sub>i a \\<Rightarrow>\n                            abs_split.T\\<^sub>i\n                             (Node (ls @ (a, sep) # rs) t)\n                          | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                              abs_split.node\\<^sub>i k\n                               (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "subgoal for p tsil tsin tti"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some p;\n     split_relation ts (split ts x) xb_; xb_ < length tsi'_;\n     tsi'_ ! xb_ = (sub_, x)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k) tsi'_ (tsil, tsin) *\n                      blist_assn k ts tsi'_ *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                      btree_assn k t tti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      btupi_assn k\n                       (case split ts x of\n                        (ls, []) \\<Rightarrow>\n                          abs_split.T\\<^sub>i (Node ls a)\n                        | (ls, (sub, sep) # rs) \\<Rightarrow>\n                            if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                            else case abs_split.ins k x sub of\n                                 abs_split.T\\<^sub>i a \\<Rightarrow>\n                                   abs_split.T\\<^sub>i\n                                    (Node (ls @ (a, sep) # rs) t)\n                                 | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                     abs_split.node\\<^sub>i k\n(ls @ (l, a) # (r, sep) # rs) t)\n                       (T\\<^sub>i (Some p)) *\n                      true", "using Nil list_split"], ["proof (prove)\nusing this:\n  rrs = []\n  split ts x = (ls, rrs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some p;\n     split_relation ts (split ts x) xb_; xb_ < length tsi'_;\n     tsi'_ ! xb_ = (sub_, x)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k) tsi'_ (tsil, tsin) *\n                      blist_assn k ts tsi'_ *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                      btree_assn k t tti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      btupi_assn k\n                       (case split ts x of\n                        (ls, []) \\<Rightarrow>\n                          abs_split.T\\<^sub>i (Node ls a)\n                        | (ls, (sub, sep) # rs) \\<Rightarrow>\n                            if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                            else case abs_split.ins k x sub of\n                                 abs_split.T\\<^sub>i a \\<Rightarrow>\n                                   abs_split.T\\<^sub>i\n                                    (Node (ls @ (a, sep) # rs) t)\n                                 | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                     abs_split.node\\<^sub>i k\n(ls @ (l, a) # (r, sep) # rs) t)\n                       (T\\<^sub>i (Some p)) *\n                      true", "by (simp add: list_assn_aux_ineq_len split_relation_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x aa b ti tsi' xb xaa xc sub sep.\n       \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some x;\n        split_relation ts (split ts x) xb; xaa = length tsi';\n        xb < length tsi'; tsi' ! xb = (sub, sep); xc = (sub, sep);\n        sep \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (aa, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x sub \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (aa, b) xb (lp, sep) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (aa, b) xb (rp, sep) \\<bind>\n                                     (\\<lambda>_.\n   if length tsi' < 2 * k\n   then pfa_insert (aa, b) xb (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (aa, b) xb (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (case split ts x of\n                      (ls, []) \\<Rightarrow> abs_split.T\\<^sub>i (Node ls a)\n                      | (ls, (sub, sep) # rs) \\<Rightarrow>\n                          if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                          else case abs_split.ins k x sub of\n                               abs_split.T\\<^sub>i a \\<Rightarrow>\n                                 abs_split.T\\<^sub>i\n                                  (Node (ls @ (a, sep) # rs) t)\n                               | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                   abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # (r, sep) # rs)\n                                    t)>\\<^sub>t\n 2. \\<And>x aa b ti tsi' xb xaa.\n       \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some x;\n        split_relation ts (split ts x) xb; xaa = length tsi';\n        \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (aa, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length tsi' < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (case split ts x of\n                 (ls, []) \\<Rightarrow> abs_split.T\\<^sub>i (Node ls a)\n                 | (ls, (sub, sep) # rs) \\<Rightarrow>\n                     if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                     else case abs_split.ins k x sub of\n                          abs_split.T\\<^sub>i a \\<Rightarrow>\n                            abs_split.T\\<^sub>i\n                             (Node (ls @ (a, sep) # rs) t)\n                          | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                              abs_split.node\\<^sub>i k\n                               (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "subgoal for p tsil tsin tti tsi' i tsin' _ sub sep"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some p;\n     split_relation ts (split ts x) i; tsin' = length tsi'; i < length tsi';\n     tsi' ! i = (sub, sep); xc_ = (sub, sep); sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) tsi' (tsil, tsin) *\n                       blist_assn k ts tsi' *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                       btree_assn k t tti *\n                       true> ins k x sub \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  pfa_set (tsil, tsin) i (lp, sep) \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  pfa_set (tsil, tsin) i (rp, sep) \\<bind>\n                                  (\\<lambda>_.\nif length tsi' < 2 * k\nthen pfa_insert (tsil, tsin) i (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         p := Btnode kvs' tti \\<bind>\n         (\\<lambda>_. return (T\\<^sub>i (Some p))))\nelse pfa_insert_grow (tsil, tsin) i (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         node\\<^sub>i k kvs'\n          tti))) <btupi_assn k\n                   (case split ts x of\n                    (ls, []) \\<Rightarrow> abs_split.T\\<^sub>i (Node ls a)\n                    | (ls, (sub, sep) # rs) \\<Rightarrow>\n                        if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                        else case abs_split.ins k x sub of\n                             abs_split.T\\<^sub>i a \\<Rightarrow>\n                               abs_split.T\\<^sub>i\n                                (Node (ls @ (a, sep) # rs) t)\n                             | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                 abs_split.node\\<^sub>i k\n                                  (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some p;\n        split_relation ts (split ts x) i; tsin' = length tsi';\n        i < length tsi'; tsi' ! i = (sub, sep); xc_ = (sub, sep);\n        sep \\<noteq> x;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi' (tsil, tsin) * blist_assn k ts tsi' *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        btree_assn k t tti *\n        true\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ts tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          btree_assn k t tti *\n                          true> ins k x sub \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (tsil, tsin) i\n(lp, sep) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some p))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (tsil, tsin) i\n(rp, sep) \\<bind>\n                                     (\\<lambda>_.\n   if length tsi' < 2 * k\n   then pfa_insert (tsil, tsin) i (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            p := Btnode kvs' tti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some p))))\n   else pfa_insert_grow (tsil, tsin) i (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             tti))) <btupi_assn k\n                      (case split ts x of\n                       (ls, []) \\<Rightarrow>\n                         abs_split.T\\<^sub>i (Node ls a)\n                       | (ls, (sub, sep) # rs) \\<Rightarrow>\n                           if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                           else case abs_split.ins k x sub of\n                                abs_split.T\\<^sub>i a \\<Rightarrow>\n                                  abs_split.T\\<^sub>i\n                                   (Node (ls @ (a, sep) # rs) t)\n                                | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                    abs_split.node\\<^sub>i k\n                                     (ls @ (l, a) # (r, sep) # rs)\n                                     t)>\\<^sub>t", "using Nil list_split"], ["proof (prove)\nusing this:\n  rrs = []\n  split ts x = (ls, rrs)\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some p;\n        split_relation ts (split ts x) i; tsin' = length tsi';\n        i < length tsi'; tsi' ! i = (sub, sep); xc_ = (sub, sep);\n        sep \\<noteq> x;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi' (tsil, tsin) * blist_assn k ts tsi' *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        btree_assn k t tti *\n        true\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ts tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          btree_assn k t tti *\n                          true> ins k x sub \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (tsil, tsin) i\n(lp, sep) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some p))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (tsil, tsin) i\n(rp, sep) \\<bind>\n                                     (\\<lambda>_.\n   if length tsi' < 2 * k\n   then pfa_insert (tsil, tsin) i (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            p := Btnode kvs' tti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some p))))\n   else pfa_insert_grow (tsil, tsin) i (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             tti))) <btupi_assn k\n                      (case split ts x of\n                       (ls, []) \\<Rightarrow>\n                         abs_split.T\\<^sub>i (Node ls a)\n                       | (ls, (sub, sep) # rs) \\<Rightarrow>\n                           if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                           else case abs_split.ins k x sub of\n                                abs_split.T\\<^sub>i a \\<Rightarrow>\n                                  abs_split.T\\<^sub>i\n                                   (Node (ls @ (a, sep) # rs) t)\n                                | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                    abs_split.node\\<^sub>i k\n                                     (ls @ (l, a) # (r, sep) # rs)\n                                     t)>\\<^sub>t", "by (simp add: list_assn_aux_ineq_len split_relation_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x aa b ti tsi' xb xaa.\n       \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some x;\n        split_relation ts (split ts x) xb; xaa = length tsi';\n        \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (aa, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length tsi' < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (case split ts x of\n                 (ls, []) \\<Rightarrow> abs_split.T\\<^sub>i (Node ls a)\n                 | (ls, (sub, sep) # rs) \\<Rightarrow>\n                     if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                     else case abs_split.ins k x sub of\n                          abs_split.T\\<^sub>i a \\<Rightarrow>\n                            abs_split.T\\<^sub>i\n                             (Node (ls @ (a, sep) # rs) t)\n                          | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                              abs_split.node\\<^sub>i k\n                               (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "subgoal for p tsil tsin tti tsi'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some p;\n     split_relation ts (split ts x) xb_; xaa_ = length tsi';\n     \\<not> xb_ < length tsi'\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) tsi' (tsil, tsin) *\n                       blist_assn k ts tsi' *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                       btree_assn k t tti *\n                       true> ins k x tti \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  if length tsi' < 2 * k\n                                  then pfa_append (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     p := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                  else pfa_append_grow' (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     node\\<^sub>i k kvs'\n      rp)) <btupi_assn k\n             (case split ts x of\n              (ls, []) \\<Rightarrow> abs_split.T\\<^sub>i (Node ls a)\n              | (ls, (sub, sep) # rs) \\<Rightarrow>\n                  if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                  else case abs_split.ins k x sub of\n                       abs_split.T\\<^sub>i a \\<Rightarrow>\n                         abs_split.T\\<^sub>i (Node (ls @ (a, sep) # rs) t)\n                       | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                           abs_split.node\\<^sub>i k\n                            (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "thm \"2.IH\"(1)[of ls rrs tti]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some p;\n     split_relation ts (split ts x) xb_; xaa_ = length tsi';\n     \\<not> xb_ < length tsi'\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) tsi' (tsil, tsin) *\n                       blist_assn k ts tsi' *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                       btree_assn k t tti *\n                       true> ins k x tti \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  if length tsi' < 2 * k\n                                  then pfa_append (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     p := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                  else pfa_append_grow' (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     node\\<^sub>i k kvs'\n      rp)) <btupi_assn k\n             (case split ts x of\n              (ls, []) \\<Rightarrow> abs_split.T\\<^sub>i (Node ls a)\n              | (ls, (sub, sep) # rs) \\<Rightarrow>\n                  if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                  else case abs_split.ins k x sub of\n                       abs_split.T\\<^sub>i a \\<Rightarrow>\n                         abs_split.T\\<^sub>i (Node (ls @ (a, sep) # rs) t)\n                       | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                           abs_split.node\\<^sub>i k\n                            (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "using Nil list_split T\\<^sub>i"], ["proof (prove)\nusing this:\n  rrs = []\n  split ts x = (ls, rrs)\n  abs_split.ins k x t = abs_split.T\\<^sub>i a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.T\\<^sub>i a; ti = Some p;\n     split_relation ts (split ts x) xb_; xaa_ = length tsi';\n     \\<not> xb_ < length tsi'\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) tsi' (tsil, tsin) *\n                       blist_assn k ts tsi' *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                       btree_assn k t tti *\n                       true> ins k x tti \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  if length tsi' < 2 * k\n                                  then pfa_append (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     p := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                  else pfa_append_grow' (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     node\\<^sub>i k kvs'\n      rp)) <btupi_assn k\n             (case split ts x of\n              (ls, []) \\<Rightarrow> abs_split.T\\<^sub>i (Node ls a)\n              | (ls, (sub, sep) # rs) \\<Rightarrow>\n                  if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                  else case abs_split.ins k x sub of\n                       abs_split.T\\<^sub>i a \\<Rightarrow>\n                         abs_split.T\\<^sub>i (Node (ls @ (a, sep) # rs) t)\n                       | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                           abs_split.node\\<^sub>i k\n                            (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "apply(sep_auto split!: list.splits simp add: split_relation_alt\n              heap add: \"2.IH\"(1)[of ls rrs tti])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>ti = Some p; xaa_ = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.T\\<^sub>i a; ts = ls;\n        xb_ = length ls\\<rbrakk>\n       \\<Longrightarrow> <btupi_assn k (abs_split.T\\<^sub>i a) x *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> case x of\n                                T\\<^sub>i lp \\<Rightarrow>\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p)))\n                                | Up\\<^sub>i lp x' rp \\<Rightarrow>\n                                    if length tsi' < 2 * k\n                                    then pfa_append (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       p := Btnode kvs' rp \\<bind>\n       (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                    else pfa_append_grow' (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       node\\<^sub>i k kvs'\n        rp) <btupi_assn k (abs_split.T\\<^sub>i (Node ls a))>\\<^sub>t", "subgoal for ai"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ti = Some p; xaa_ = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.T\\<^sub>i a; ts = ls;\n     xb_ = length ls\\<rbrakk>\n    \\<Longrightarrow> <btupi_assn k (abs_split.T\\<^sub>i a) ai *\n                       is_pfa (2 * k) tsi' (tsil, tsin) *\n                       blist_assn k ls tsi' *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                       true> case ai of\n                             T\\<^sub>i lp \\<Rightarrow>\n                               p := Btnode (tsil, tsin) lp \\<bind>\n                               (\\<lambda>_. return (T\\<^sub>i (Some p)))\n                             | Up\\<^sub>i lp x' rp \\<Rightarrow>\n                                 if length tsi' < 2 * k\n                                 then pfa_append (tsil, tsin)\n (lp, x') \\<bind>\n(\\<lambda>kvs'.\n    p := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                 else pfa_append_grow' (tsil, tsin)\n (lp, x') \\<bind>\n(\\<lambda>kvs'.\n    node\\<^sub>i k kvs'\n     rp) <btupi_assn k (abs_split.T\\<^sub>i (Node ls a))>\\<^sub>t", "apply(cases ai)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ti = Some p; xaa_ = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.T\\<^sub>i a; ts = ls;\n        xb_ = length ls; ai = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> <btupi_assn k (abs_split.T\\<^sub>i a) ai *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> case ai of\n                                T\\<^sub>i lp \\<Rightarrow>\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p)))\n                                | Up\\<^sub>i lp x' rp \\<Rightarrow>\n                                    if length tsi' < 2 * k\n                                    then pfa_append (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       p := Btnode kvs' rp \\<bind>\n       (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                    else pfa_append_grow' (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       node\\<^sub>i k kvs'\n        rp) <btupi_assn k (abs_split.T\\<^sub>i (Node ls a))>\\<^sub>t\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>ti = Some p; xaa_ = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.T\\<^sub>i a; ts = ls;\n        xb_ = length ls; ai = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btupi_assn k (abs_split.T\\<^sub>i a) ai *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> case ai of\n                                T\\<^sub>i lp \\<Rightarrow>\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p)))\n                                | Up\\<^sub>i lp x' rp \\<Rightarrow>\n                                    if length tsi' < 2 * k\n                                    then pfa_append (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       p := Btnode kvs' rp \\<bind>\n       (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                    else pfa_append_grow' (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       node\\<^sub>i k kvs'\n        rp) <btupi_assn k (abs_split.T\\<^sub>i (Node ls a))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>ti = Some p; xaa_ = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.T\\<^sub>i a; ts = ls;\n        xb_ = length ls; ai = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btupi_assn k (abs_split.T\\<^sub>i a) ai *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> case ai of\n                                T\\<^sub>i lp \\<Rightarrow>\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p)))\n                                | Up\\<^sub>i lp x' rp \\<Rightarrow>\n                                    if length tsi' < 2 * k\n                                    then pfa_append (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       p := Btnode kvs' rp \\<bind>\n       (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                    else pfa_append_grow' (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       node\\<^sub>i k kvs'\n        rp) <btupi_assn k (abs_split.T\\<^sub>i (Node ls a))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rrs = [];\n        abs_split.ins k x t = abs_split.Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rrs = [];\n        abs_split.ins k x t = abs_split.Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "case (Up\\<^sub>i l a r)"], ["proof (state)\nthis:\n  abs_split.ins k x t = abs_split.Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rrs = [];\n        abs_split.ins k x t = abs_split.Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  abs_split.ins k x t = abs_split.Up\\<^sub>i l a r", "show ?thesis"], ["proof (prove)\nusing this:\n  abs_split.ins k x t = abs_split.Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "apply(subst ins.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_split.ins k x t = abs_split.Up\\<^sub>i l a r \\<Longrightarrow>\n    <btree_assn k (Node ts t)\n      ti> case ti of None \\<Rightarrow> return (Up\\<^sub>i None x None)\n          | Some ap \\<Rightarrow>\n              !ap \\<bind>\n              (\\<lambda>a.\n                  imp_split (kvs a) x \\<bind>\n                  (\\<lambda>i.\n                      pfa_length (kvs a) \\<bind>\n                      (\\<lambda>tsl.\n                          if i < tsl\n                          then pfa_get (kvs a) i \\<bind>\n                               (\\<lambda>s.\n                                   let (sub, sep) = s\n                                   in if sep = x then return (T\\<^sub>i ti)\nelse ins k x sub \\<bind>\n     case_btupi\n      (\\<lambda>lp.\n          pfa_set (kvs a) i (lp, sep) \\<bind>\n          (\\<lambda>_. return (T\\<^sub>i ti)))\n      (\\<lambda>lp x' rp.\n          pfa_set (kvs a) i (rp, sep) \\<bind>\n          (\\<lambda>_.\n              if tsl < 2 * k\n              then pfa_insert (kvs a) i (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       ap := Btnode kvs' (BTree_Imp.last a) \\<bind>\n                       (\\<lambda>_. return (T\\<^sub>i ti)))\n              else pfa_insert_grow (kvs a) i (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n                          else ins k x (BTree_Imp.last a) \\<bind>\n                               case_btupi\n                                (\\<lambda>lp.\n                                    ap := Btnode (kvs a) lp \\<bind>\n                                    (\\<lambda>_. return (T\\<^sub>i ti)))\n                                (\\<lambda>lp x' rp.\n                                    if tsl < 2 * k\n                                    then pfa_append (kvs a) (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       ap := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i ti)))\n                                    else pfa_append_grow' (kvs a)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       node\\<^sub>i k kvs'\n        rp))))) <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x aa b ti tsi' xb sub.\n       \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r;\n        ti = Some x; split_relation ts (split ts x) xb; xb < length tsi';\n        tsi' ! xb = (sub, x)\\<rbrakk>\n       \\<Longrightarrow> is_pfa (2 * k) tsi' (aa, b) *\n                         blist_assn k ts tsi' *\n                         x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (case split ts x of\n                           (ls, []) \\<Rightarrow>\n                             abs_split.node\\<^sub>i k (ls @ [(l, a)]) r\n                           | (ls, (sub, sep) # rs) \\<Rightarrow>\n                               if sep = x\n                               then abs_split.T\\<^sub>i (Node ts t)\n                               else case abs_split.ins k x sub of\n                                    abs_split.T\\<^sub>i a \\<Rightarrow>\nabs_split.T\\<^sub>i (Node (ls @ (a, sep) # rs) t)\n                                    | abs_split.Up\\<^sub>i l a\n r \\<Rightarrow>\n  abs_split.node\\<^sub>i k (ls @ (l, a) # (r, sep) # rs) t)\n                          (T\\<^sub>i (Some x)) *\n                         true\n 2. \\<And>x aa b ti tsi' xb xaa xc sub sep.\n       \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r;\n        ti = Some x; split_relation ts (split ts x) xb; xaa = length tsi';\n        xb < length tsi'; tsi' ! xb = (sub, sep); xc = (sub, sep);\n        sep \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (aa, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x sub \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (aa, b) xb (lp, sep) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (aa, b) xb (rp, sep) \\<bind>\n                                     (\\<lambda>_.\n   if length tsi' < 2 * k\n   then pfa_insert (aa, b) xb (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (aa, b) xb (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (case split ts x of\n                      (ls, []) \\<Rightarrow>\n                        abs_split.node\\<^sub>i k (ls @ [(l, a)]) r\n                      | (ls, (sub, sep) # rs) \\<Rightarrow>\n                          if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                          else case abs_split.ins k x sub of\n                               abs_split.T\\<^sub>i a \\<Rightarrow>\n                                 abs_split.T\\<^sub>i\n                                  (Node (ls @ (a, sep) # rs) t)\n                               | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                   abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # (r, sep) # rs)\n                                    t)>\\<^sub>t\n 3. \\<And>x aa b ti tsi' xb xaa.\n       \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r;\n        ti = Some x; split_relation ts (split ts x) xb; xaa = length tsi';\n        \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (aa, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length tsi' < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (case split ts x of\n                 (ls, []) \\<Rightarrow>\n                   abs_split.node\\<^sub>i k (ls @ [(l, a)]) r\n                 | (ls, (sub, sep) # rs) \\<Rightarrow>\n                     if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                     else case abs_split.ins k x sub of\n                          abs_split.T\\<^sub>i a \\<Rightarrow>\n                            abs_split.T\\<^sub>i\n                             (Node (ls @ (a, sep) # rs) t)\n                          | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                              abs_split.node\\<^sub>i k\n                               (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "subgoal for p tsil tsin tti"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ti = Some p;\n     split_relation ts (split ts x) xb_; xb_ < length tsi'_;\n     tsi'_ ! xb_ = (sub_, x)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k) tsi'_ (tsil, tsin) *\n                      blist_assn k ts tsi'_ *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                      btree_assn k t tti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      btupi_assn k\n                       (case split ts x of\n                        (ls, []) \\<Rightarrow>\n                          abs_split.node\\<^sub>i k (ls @ [(l, a)]) r\n                        | (ls, (sub, sep) # rs) \\<Rightarrow>\n                            if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                            else case abs_split.ins k x sub of\n                                 abs_split.T\\<^sub>i a \\<Rightarrow>\n                                   abs_split.T\\<^sub>i\n                                    (Node (ls @ (a, sep) # rs) t)\n                                 | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                     abs_split.node\\<^sub>i k\n(ls @ (l, a) # (r, sep) # rs) t)\n                       (T\\<^sub>i (Some p)) *\n                      true", "using Nil list_split"], ["proof (prove)\nusing this:\n  rrs = []\n  split ts x = (ls, rrs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ti = Some p;\n     split_relation ts (split ts x) xb_; xb_ < length tsi'_;\n     tsi'_ ! xb_ = (sub_, x)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k) tsi'_ (tsil, tsin) *\n                      blist_assn k ts tsi'_ *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                      btree_assn k t tti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      btupi_assn k\n                       (case split ts x of\n                        (ls, []) \\<Rightarrow>\n                          abs_split.node\\<^sub>i k (ls @ [(l, a)]) r\n                        | (ls, (sub, sep) # rs) \\<Rightarrow>\n                            if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                            else case abs_split.ins k x sub of\n                                 abs_split.T\\<^sub>i a \\<Rightarrow>\n                                   abs_split.T\\<^sub>i\n                                    (Node (ls @ (a, sep) # rs) t)\n                                 | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                     abs_split.node\\<^sub>i k\n(ls @ (l, a) # (r, sep) # rs) t)\n                       (T\\<^sub>i (Some p)) *\n                      true", "by (simp add: list_assn_aux_ineq_len split_relation_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x aa b ti tsi' xb xaa xc sub sep.\n       \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r;\n        ti = Some x; split_relation ts (split ts x) xb; xaa = length tsi';\n        xb < length tsi'; tsi' ! xb = (sub, sep); xc = (sub, sep);\n        sep \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (aa, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x sub \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (aa, b) xb (lp, sep) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (aa, b) xb (rp, sep) \\<bind>\n                                     (\\<lambda>_.\n   if length tsi' < 2 * k\n   then pfa_insert (aa, b) xb (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (aa, b) xb (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (case split ts x of\n                      (ls, []) \\<Rightarrow>\n                        abs_split.node\\<^sub>i k (ls @ [(l, a)]) r\n                      | (ls, (sub, sep) # rs) \\<Rightarrow>\n                          if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                          else case abs_split.ins k x sub of\n                               abs_split.T\\<^sub>i a \\<Rightarrow>\n                                 abs_split.T\\<^sub>i\n                                  (Node (ls @ (a, sep) # rs) t)\n                               | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                   abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # (r, sep) # rs)\n                                    t)>\\<^sub>t\n 2. \\<And>x aa b ti tsi' xb xaa.\n       \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r;\n        ti = Some x; split_relation ts (split ts x) xb; xaa = length tsi';\n        \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (aa, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length tsi' < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (case split ts x of\n                 (ls, []) \\<Rightarrow>\n                   abs_split.node\\<^sub>i k (ls @ [(l, a)]) r\n                 | (ls, (sub, sep) # rs) \\<Rightarrow>\n                     if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                     else case abs_split.ins k x sub of\n                          abs_split.T\\<^sub>i a \\<Rightarrow>\n                            abs_split.T\\<^sub>i\n                             (Node (ls @ (a, sep) # rs) t)\n                          | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                              abs_split.node\\<^sub>i k\n                               (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "subgoal for p tsil tsin tti tsi' i tsin' _ sub sep"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ti = Some p;\n     split_relation ts (split ts x) i; tsin' = length tsi'; i < length tsi';\n     tsi' ! i = (sub, sep); xc_ = (sub, sep); sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) tsi' (tsil, tsin) *\n                       blist_assn k ts tsi' *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                       btree_assn k t tti *\n                       true> ins k x sub \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  pfa_set (tsil, tsin) i (lp, sep) \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  pfa_set (tsil, tsin) i (rp, sep) \\<bind>\n                                  (\\<lambda>_.\nif length tsi' < 2 * k\nthen pfa_insert (tsil, tsin) i (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         p := Btnode kvs' tti \\<bind>\n         (\\<lambda>_. return (T\\<^sub>i (Some p))))\nelse pfa_insert_grow (tsil, tsin) i (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         node\\<^sub>i k kvs'\n          tti))) <btupi_assn k\n                   (case split ts x of\n                    (ls, []) \\<Rightarrow>\n                      abs_split.node\\<^sub>i k (ls @ [(l, a)]) r\n                    | (ls, (sub, sep) # rs) \\<Rightarrow>\n                        if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                        else case abs_split.ins k x sub of\n                             abs_split.T\\<^sub>i a \\<Rightarrow>\n                               abs_split.T\\<^sub>i\n                                (Node (ls @ (a, sep) # rs) t)\n                             | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                 abs_split.node\\<^sub>i k\n                                  (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "using Nil list_split"], ["proof (prove)\nusing this:\n  rrs = []\n  split ts x = (ls, rrs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ti = Some p;\n     split_relation ts (split ts x) i; tsin' = length tsi'; i < length tsi';\n     tsi' ! i = (sub, sep); xc_ = (sub, sep); sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) tsi' (tsil, tsin) *\n                       blist_assn k ts tsi' *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                       btree_assn k t tti *\n                       true> ins k x sub \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  pfa_set (tsil, tsin) i (lp, sep) \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  pfa_set (tsil, tsin) i (rp, sep) \\<bind>\n                                  (\\<lambda>_.\nif length tsi' < 2 * k\nthen pfa_insert (tsil, tsin) i (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         p := Btnode kvs' tti \\<bind>\n         (\\<lambda>_. return (T\\<^sub>i (Some p))))\nelse pfa_insert_grow (tsil, tsin) i (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         node\\<^sub>i k kvs'\n          tti))) <btupi_assn k\n                   (case split ts x of\n                    (ls, []) \\<Rightarrow>\n                      abs_split.node\\<^sub>i k (ls @ [(l, a)]) r\n                    | (ls, (sub, sep) # rs) \\<Rightarrow>\n                        if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                        else case abs_split.ins k x sub of\n                             abs_split.T\\<^sub>i a \\<Rightarrow>\n                               abs_split.T\\<^sub>i\n                                (Node (ls @ (a, sep) # rs) t)\n                             | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                 abs_split.node\\<^sub>i k\n                                  (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "by (simp add: list_assn_aux_ineq_len split_relation_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x aa b ti tsi' xb xaa.\n       \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r;\n        ti = Some x; split_relation ts (split ts x) xb; xaa = length tsi';\n        \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (aa, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length tsi' < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (case split ts x of\n                 (ls, []) \\<Rightarrow>\n                   abs_split.node\\<^sub>i k (ls @ [(l, a)]) r\n                 | (ls, (sub, sep) # rs) \\<Rightarrow>\n                     if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                     else case abs_split.ins k x sub of\n                          abs_split.T\\<^sub>i a \\<Rightarrow>\n                            abs_split.T\\<^sub>i\n                             (Node (ls @ (a, sep) # rs) t)\n                          | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                              abs_split.node\\<^sub>i k\n                               (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "subgoal for p tsil tsin tti tsi' i tsin'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ti = Some p;\n     split_relation ts (split ts x) i; tsin' = length tsi';\n     \\<not> i < length tsi'\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) tsi' (tsil, tsin) *\n                       blist_assn k ts tsi' *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                       btree_assn k t tti *\n                       true> ins k x tti \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  if length tsi' < 2 * k\n                                  then pfa_append (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     p := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                  else pfa_append_grow' (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     node\\<^sub>i k kvs'\n      rp)) <btupi_assn k\n             (case split ts x of\n              (ls, []) \\<Rightarrow>\n                abs_split.node\\<^sub>i k (ls @ [(l, a)]) r\n              | (ls, (sub, sep) # rs) \\<Rightarrow>\n                  if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                  else case abs_split.ins k x sub of\n                       abs_split.T\\<^sub>i a \\<Rightarrow>\n                         abs_split.T\\<^sub>i (Node (ls @ (a, sep) # rs) t)\n                       | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                           abs_split.node\\<^sub>i k\n                            (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "thm \"2.IH\"(1)[of ls rrs tti]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ti = Some p;\n     split_relation ts (split ts x) i; tsin' = length tsi';\n     \\<not> i < length tsi'\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) tsi' (tsil, tsin) *\n                       blist_assn k ts tsi' *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                       btree_assn k t tti *\n                       true> ins k x tti \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  if length tsi' < 2 * k\n                                  then pfa_append (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     p := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                  else pfa_append_grow' (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     node\\<^sub>i k kvs'\n      rp)) <btupi_assn k\n             (case split ts x of\n              (ls, []) \\<Rightarrow>\n                abs_split.node\\<^sub>i k (ls @ [(l, a)]) r\n              | (ls, (sub, sep) # rs) \\<Rightarrow>\n                  if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                  else case abs_split.ins k x sub of\n                       abs_split.T\\<^sub>i a \\<Rightarrow>\n                         abs_split.T\\<^sub>i (Node (ls @ (a, sep) # rs) t)\n                       | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                           abs_split.node\\<^sub>i k\n                            (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "using Nil list_split Up\\<^sub>i"], ["proof (prove)\nusing this:\n  rrs = []\n  split ts x = (ls, rrs)\n  abs_split.ins k x t = abs_split.Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ti = Some p;\n     split_relation ts (split ts x) i; tsin' = length tsi';\n     \\<not> i < length tsi'\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) tsi' (tsil, tsin) *\n                       blist_assn k ts tsi' *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                       btree_assn k t tti *\n                       true> ins k x tti \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  if length tsi' < 2 * k\n                                  then pfa_append (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     p := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                  else pfa_append_grow' (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     node\\<^sub>i k kvs'\n      rp)) <btupi_assn k\n             (case split ts x of\n              (ls, []) \\<Rightarrow>\n                abs_split.node\\<^sub>i k (ls @ [(l, a)]) r\n              | (ls, (sub, sep) # rs) \\<Rightarrow>\n                  if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                  else case abs_split.ins k x sub of\n                       abs_split.T\\<^sub>i a \\<Rightarrow>\n                         abs_split.T\\<^sub>i (Node (ls @ (a, sep) # rs) t)\n                       | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                           abs_split.node\\<^sub>i k\n                            (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "apply(sep_auto split!: list.splits \n              simp add: split_relation_alt\n              heap add: \"2.IH\"(1)[of ls rrs tti])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls\\<rbrakk>\n       \\<Longrightarrow> <btupi_assn k (abs_split.Up\\<^sub>i l a r) x *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> case x of\n                                T\\<^sub>i lp \\<Rightarrow>\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p)))\n                                | Up\\<^sub>i lp x' rp \\<Rightarrow>\n                                    if length tsi' < 2 * k\n                                    then pfa_append (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       p := Btnode kvs' rp \\<bind>\n       (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                    else pfa_append_grow' (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       node\\<^sub>i k kvs'\n        rp) <btupi_assn k\n              (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t", "subgoal for ai"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls\\<rbrakk>\n    \\<Longrightarrow> <btupi_assn k (abs_split.Up\\<^sub>i l a r) ai *\n                       is_pfa (2 * k) tsi' (tsil, tsin) *\n                       blist_assn k ls tsi' *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                       true> case ai of\n                             T\\<^sub>i lp \\<Rightarrow>\n                               p := Btnode (tsil, tsin) lp \\<bind>\n                               (\\<lambda>_. return (T\\<^sub>i (Some p)))\n                             | Up\\<^sub>i lp x' rp \\<Rightarrow>\n                                 if length tsi' < 2 * k\n                                 then pfa_append (tsil, tsin)\n (lp, x') \\<bind>\n(\\<lambda>kvs'.\n    p := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                 else pfa_append_grow' (tsil, tsin)\n (lp, x') \\<bind>\n(\\<lambda>kvs'.\n    node\\<^sub>i k kvs'\n     rp) <btupi_assn k (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t", "apply(cases ai)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls; ai = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> <btupi_assn k (abs_split.Up\\<^sub>i l a r) ai *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> case ai of\n                                T\\<^sub>i lp \\<Rightarrow>\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p)))\n                                | Up\\<^sub>i lp x' rp \\<Rightarrow>\n                                    if length tsi' < 2 * k\n                                    then pfa_append (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       p := Btnode kvs' rp \\<bind>\n       (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                    else pfa_append_grow' (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       node\\<^sub>i k kvs'\n        rp) <btupi_assn k\n              (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls; ai = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btupi_assn k (abs_split.Up\\<^sub>i l a r) ai *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> case ai of\n                                T\\<^sub>i lp \\<Rightarrow>\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p)))\n                                | Up\\<^sub>i lp x' rp \\<Rightarrow>\n                                    if length tsi' < 2 * k\n                                    then pfa_append (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       p := Btnode kvs' rp \\<bind>\n       (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                    else pfa_append_grow' (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       node\\<^sub>i k kvs'\n        rp) <btupi_assn k\n              (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls; ai = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btupi_assn k (abs_split.Up\\<^sub>i l a r) ai *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> case ai of\n                                T\\<^sub>i lp \\<Rightarrow>\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p)))\n                                | Up\\<^sub>i lp x' rp \\<Rightarrow>\n                                    if length tsi' < 2 * k\n                                    then pfa_append (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       p := Btnode kvs' rp \\<bind>\n       (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                    else pfa_append_grow' (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       node\\<^sub>i k kvs'\n        rp) <btupi_assn k\n              (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 h.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls; ai = Up\\<^sub>i x21 x22 x23;\n        h \\<Turnstile>\n        btupi_assn k (abs_split.Up\\<^sub>i l a r) ai *\n        is_pfa (2 * k) tsi' (tsil, tsin) *\n        blist_assn k ls tsi' *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        true\\<rbrakk>\n       \\<Longrightarrow> <btupi_assn k (abs_split.Up\\<^sub>i l a r) ai *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> case ai of\n                                T\\<^sub>i lp \\<Rightarrow>\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p)))\n                                | Up\\<^sub>i lp x' rp \\<Rightarrow>\n                                    if length tsi' < 2 * k\n                                    then pfa_append (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       p := Btnode kvs' rp \\<bind>\n       (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                    else pfa_append_grow' (tsil, tsin)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       node\\<^sub>i k kvs'\n        rp) <btupi_assn k\n              (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 x23 aa b.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls; ai = Up\\<^sub>i x21 x22 x23;\n        (aa, b) \\<Turnstile>\n        btree_assn k l x21 * id_assn a x22 * btree_assn k r x23 *\n        is_pfa (2 * k) tsi' (tsil, tsin) *\n        blist_assn k ls tsi' *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        true;\n        length tsi' < 2 * k\\<rbrakk>\n       \\<Longrightarrow> tsin < 2 * k\n 2. \\<And>x21 x22 x23 aa b x.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls; ai = Up\\<^sub>i x21 x22 x23;\n        (aa, b) \\<Turnstile>\n        btree_assn k l x21 * id_assn a x22 * btree_assn k r x23 *\n        is_pfa (2 * k) tsi' (tsil, tsin) *\n        blist_assn k ls tsi' *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        true;\n        length tsi' < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (a', n') \\<Rightarrow>\n                             is_pfa (2 * k) (tsi' @ [(x21, x22)]) (a', n') *\n                             \\<up> (a' = tsil \\<and> n' = tsin + 1)) *\n                          (btree_assn k l x21 * id_assn a x22 *\n                           btree_assn k r x23 *\n                           blist_assn k ls tsi' *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                           true)> p := Btnode x x23 \\<bind>\n                                  (\\<lambda>_.\nreturn\n (T\\<^sub>i\n   (Some\n     p))) <btupi_assn k\n            (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t\n 3. \\<And>x21 x22 x23 aa b.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls; ai = Up\\<^sub>i x21 x22 x23;\n        (aa, b) \\<Turnstile>\n        btree_assn k l x21 * id_assn a x22 * btree_assn k r x23 *\n        is_pfa (2 * k) tsi' (tsil, tsin) *\n        blist_assn k ls tsi' *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        true;\n        \\<not> length tsi' < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k l x21 * id_assn a x22 *\n                          btree_assn k r x23 *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> pfa_append_grow' (tsil, tsin)\n                                 (x21, x22) \\<bind>\n                                (\\<lambda>kvs'.\n                                    node\\<^sub>i k kvs'\n                                     x23) <btupi_assn k\n      (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t", "apply(auto dest!: mod_starD simp add: is_pfa_def)[]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23 aa b x.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls; ai = Up\\<^sub>i x21 x22 x23;\n        (aa, b) \\<Turnstile>\n        btree_assn k l x21 * id_assn a x22 * btree_assn k r x23 *\n        is_pfa (2 * k) tsi' (tsil, tsin) *\n        blist_assn k ls tsi' *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        true;\n        length tsi' < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (a', n') \\<Rightarrow>\n                             is_pfa (2 * k) (tsi' @ [(x21, x22)]) (a', n') *\n                             \\<up> (a' = tsil \\<and> n' = tsin + 1)) *\n                          (btree_assn k l x21 * id_assn a x22 *\n                           btree_assn k r x23 *\n                           blist_assn k ls tsi' *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                           true)> p := Btnode x x23 \\<bind>\n                                  (\\<lambda>_.\nreturn\n (T\\<^sub>i\n   (Some\n     p))) <btupi_assn k\n            (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t\n 2. \\<And>x21 x22 x23 aa b.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls; ai = Up\\<^sub>i x21 x22 x23;\n        (aa, b) \\<Turnstile>\n        btree_assn k l x21 * id_assn a x22 * btree_assn k r x23 *\n        is_pfa (2 * k) tsi' (tsil, tsin) *\n        blist_assn k ls tsi' *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        true;\n        \\<not> length tsi' < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k l x21 * id_assn a x22 *\n                          btree_assn k r x23 *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> pfa_append_grow' (tsil, tsin)\n                                 (x21, x22) \\<bind>\n                                (\\<lambda>kvs'.\n                                    node\\<^sub>i k kvs'\n                                     x23) <btupi_assn k\n      (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t", "apply (sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23 aa b.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls; ai = Up\\<^sub>i x21 x22 x23;\n        (aa, b) \\<Turnstile>\n        btree_assn k l x21 * id_assn a x22 * btree_assn k r x23 *\n        is_pfa (2 * k) tsi' (tsil, tsin) *\n        blist_assn k ls tsi' *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        true;\n        length tsi' < 2 * k\\<rbrakk>\n       \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) x23 *\n                         is_pfa (2 * k) (tsi' @ [(x21, x22)])\n                          (tsil, Suc tsin) *\n                         btree_assn k l x21 *\n                         id_assn a x22 *\n                         btree_assn k r x23 *\n                         blist_assn k ls tsi' *\n                         true \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)\n                          (T\\<^sub>i (Some p)) *\n                         true\n 2. \\<And>x21 x22 x23 aa b.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls; ai = Up\\<^sub>i x21 x22 x23;\n        (aa, b) \\<Turnstile>\n        btree_assn k l x21 * id_assn a x22 * btree_assn k r x23 *\n        is_pfa (2 * k) tsi' (tsil, tsin) *\n        blist_assn k ls tsi' *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        true;\n        \\<not> length tsi' < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k l x21 * id_assn a x22 *\n                          btree_assn k r x23 *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> pfa_append_grow' (tsil, tsin)\n                                 (x21, x22) \\<bind>\n                                (\\<lambda>kvs'.\n                                    node\\<^sub>i k kvs'\n                                     x23) <btupi_assn k\n      (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t", "subgoal for li ai ri"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls; ai__ = Up\\<^sub>i li ai ri;\n     (aa_, b_) \\<Turnstile>\n     btree_assn k l li * id_assn a ai * btree_assn k r ri *\n     is_pfa (2 * k) tsi' (tsil, tsin) *\n     blist_assn k ls tsi' *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n     true;\n     length tsi' < 2 * k\\<rbrakk>\n    \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ri *\n                      is_pfa (2 * k) (tsi' @ [(li, ai)]) (tsil, Suc tsin) *\n                      btree_assn k l li *\n                      id_assn a ai *\n                      btree_assn k r ri *\n                      blist_assn k ls tsi' *\n                      true \\<Longrightarrow>\\<^sub>A\n                      btupi_assn k\n                       (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)\n                       (T\\<^sub>i (Some p)) *\n                      true", "(* no split case *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls; ai__ = Up\\<^sub>i li ai ri;\n     (aa_, b_) \\<Turnstile>\n     btree_assn k l li * id_assn a ai * btree_assn k r ri *\n     is_pfa (2 * k) tsi' (tsil, tsin) *\n     blist_assn k ls tsi' *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n     true;\n     length tsi' < 2 * k\\<rbrakk>\n    \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ri *\n                      is_pfa (2 * k) (tsi' @ [(li, ai)]) (tsil, Suc tsin) *\n                      btree_assn k l li *\n                      id_assn a ai *\n                      btree_assn k r ri *\n                      blist_assn k ls tsi' *\n                      true \\<Longrightarrow>\\<^sub>A\n                      btupi_assn k\n                       (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)\n                       (T\\<^sub>i (Some p)) *\n                      true", "apply(subgoal_tac \"length (ls @ [(l,a)]) \\<le> 2*k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls; ai__ = Up\\<^sub>i li ai ri;\n     (aa_, b_) \\<Turnstile>\n     btree_assn k l li * id_assn a ai * btree_assn k r ri *\n     is_pfa (2 * k) tsi' (tsil, tsin) *\n     blist_assn k ls tsi' *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n     true;\n     length tsi' < 2 * k; length (ls @ [(l, a)]) \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ri *\n                      is_pfa (2 * k) (tsi' @ [(li, ai)]) (tsil, Suc tsin) *\n                      btree_assn k l li *\n                      id_assn a ai *\n                      btree_assn k r ri *\n                      blist_assn k ls tsi' *\n                      true \\<Longrightarrow>\\<^sub>A\n                      btupi_assn k\n                       (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)\n                       (T\\<^sub>i (Some p)) *\n                      true\n 2. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls; ai__ = Up\\<^sub>i li ai ri;\n     (aa_, b_) \\<Turnstile>\n     btree_assn k l li * id_assn a ai * btree_assn k r ri *\n     is_pfa (2 * k) tsi' (tsil, tsin) *\n     blist_assn k ls tsi' *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n     true;\n     length tsi' < 2 * k\\<rbrakk>\n    \\<Longrightarrow> length (ls @ [(l, a)]) \\<le> 2 * k", "apply(simp add: node\\<^sub>i_no_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls; ai__ = Up\\<^sub>i li ai ri;\n     (aa_, b_) \\<Turnstile>\n     btree_assn k l li * id_assn a ai * btree_assn k r ri *\n     is_pfa (2 * k) tsi' (tsil, tsin) *\n     blist_assn k ls tsi' *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n     true;\n     Suc (length ls) \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ri *\n                      is_pfa (2 * k) (tsi' @ [(li, ai)]) (tsil, Suc tsin) *\n                      btree_assn k l li *\n                      id_assn a ai *\n                      btree_assn k r ri *\n                      blist_assn k ls tsi' *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsi ti tsi'.\n                         p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                         btree_assn k r ti *\n                         is_pfa (2 * k) tsi' tsi *\n                         blist_assn k (ls @ [(l, a)]) tsi' *\n                         true\n 2. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls; ai__ = Up\\<^sub>i li ai ri;\n     (aa_, b_) \\<Turnstile>\n     btree_assn k l li * id_assn a ai * btree_assn k r ri *\n     is_pfa (2 * k) tsi' (tsil, tsin) *\n     blist_assn k ls tsi' *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n     true;\n     length tsi' < 2 * k\\<rbrakk>\n    \\<Longrightarrow> length (ls @ [(l, a)]) \\<le> 2 * k", "apply(rule ent_ex_postI[where x=\"(tsil,Suc tsin)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls; ai__ = Up\\<^sub>i li ai ri;\n     (aa_, b_) \\<Turnstile>\n     btree_assn k l li * id_assn a ai * btree_assn k r ri *\n     is_pfa (2 * k) tsi' (tsil, tsin) *\n     blist_assn k ls tsi' *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n     true;\n     Suc (length ls) \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ri *\n                      is_pfa (2 * k) (tsi' @ [(li, ai)]) (tsil, Suc tsin) *\n                      btree_assn k l li *\n                      id_assn a ai *\n                      btree_assn k r ri *\n                      blist_assn k ls tsi' *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Ati tsi'.\n                         p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ti *\n                         btree_assn k r ti *\n                         is_pfa (2 * k) tsi' (tsil, Suc tsin) *\n                         blist_assn k (ls @ [(l, a)]) tsi' *\n                         true\n 2. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls; ai__ = Up\\<^sub>i li ai ri;\n     (aa_, b_) \\<Turnstile>\n     btree_assn k l li * id_assn a ai * btree_assn k r ri *\n     is_pfa (2 * k) tsi' (tsil, tsin) *\n     blist_assn k ls tsi' *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n     true;\n     length tsi' < 2 * k\\<rbrakk>\n    \\<Longrightarrow> length (ls @ [(l, a)]) \\<le> 2 * k", "apply(rule ent_ex_postI[where x=\"ri\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls; ai__ = Up\\<^sub>i li ai ri;\n     (aa_, b_) \\<Turnstile>\n     btree_assn k l li * id_assn a ai * btree_assn k r ri *\n     is_pfa (2 * k) tsi' (tsil, tsin) *\n     blist_assn k ls tsi' *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n     true;\n     Suc (length ls) \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ri *\n                      is_pfa (2 * k) (tsi' @ [(li, ai)]) (tsil, Suc tsin) *\n                      btree_assn k l li *\n                      id_assn a ai *\n                      btree_assn k r ri *\n                      blist_assn k ls tsi' *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsi'.\n                         p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ri *\n                         btree_assn k r ri *\n                         is_pfa (2 * k) tsi' (tsil, Suc tsin) *\n                         blist_assn k (ls @ [(l, a)]) tsi' *\n                         true\n 2. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls; ai__ = Up\\<^sub>i li ai ri;\n     (aa_, b_) \\<Turnstile>\n     btree_assn k l li * id_assn a ai * btree_assn k r ri *\n     is_pfa (2 * k) tsi' (tsil, tsin) *\n     blist_assn k ls tsi' *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n     true;\n     length tsi' < 2 * k\\<rbrakk>\n    \\<Longrightarrow> length (ls @ [(l, a)]) \\<le> 2 * k", "apply(rule ent_ex_postI[where x=\"tsi' @ [(li, ai)]\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls; ai__ = Up\\<^sub>i li ai ri;\n     (aa_, b_) \\<Turnstile>\n     btree_assn k l li * id_assn a ai * btree_assn k r ri *\n     is_pfa (2 * k) tsi' (tsil, tsin) *\n     blist_assn k ls tsi' *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n     true;\n     Suc (length ls) \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ri *\n                      is_pfa (2 * k) (tsi' @ [(li, ai)]) (tsil, Suc tsin) *\n                      btree_assn k l li *\n                      id_assn a ai *\n                      btree_assn k r ri *\n                      blist_assn k ls tsi' *\n                      true \\<Longrightarrow>\\<^sub>A\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ri *\n                      btree_assn k r ri *\n                      is_pfa (2 * k) (tsi' @ [(li, ai)]) (tsil, Suc tsin) *\n                      blist_assn k (ls @ [(l, a)]) (tsi' @ [(li, ai)]) *\n                      true\n 2. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls; ai__ = Up\\<^sub>i li ai ri;\n     (aa_, b_) \\<Turnstile>\n     btree_assn k l li * id_assn a ai * btree_assn k r ri *\n     is_pfa (2 * k) tsi' (tsil, tsin) *\n     blist_assn k ls tsi' *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n     true;\n     length tsi' < 2 * k\\<rbrakk>\n    \\<Longrightarrow> length (ls @ [(l, a)]) \\<le> 2 * k", "apply(sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ti = Some p; tsin' = length tsi';\n     \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n     abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n     i = length ls; ai__ = Up\\<^sub>i li ai ri;\n     (aa_, b_) \\<Turnstile>\n     btree_assn k l li * id_assn a ai * btree_assn k r ri *\n     is_pfa (2 * k) tsi' (tsil, tsin) *\n     blist_assn k ls tsi' *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n     true;\n     length tsi' < 2 * k\\<rbrakk>\n    \\<Longrightarrow> length (ls @ [(l, a)]) \\<le> 2 * k", "apply (sep_auto dest!: mod_starD list_assn_len simp add: is_pfa_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 aa b.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls; ai = Up\\<^sub>i x21 x22 x23;\n        (aa, b) \\<Turnstile>\n        btree_assn k l x21 * id_assn a x22 * btree_assn k r x23 *\n        is_pfa (2 * k) tsi' (tsil, tsin) *\n        blist_assn k ls tsi' *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        true;\n        \\<not> length tsi' < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k l x21 * id_assn a x22 *\n                          btree_assn k r x23 *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> pfa_append_grow' (tsil, tsin)\n                                 (x21, x22) \\<bind>\n                                (\\<lambda>kvs'.\n                                    node\\<^sub>i k kvs'\n                                     x23) <btupi_assn k\n      (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t", "(* split case*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 aa b.\n       \\<lbrakk>ti = Some p; tsin' = length tsi';\n        \\<not> length ls < length tsi'; rrs = []; split ls x = (ls, []);\n        abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; ts = ls;\n        i = length ls; ai = Up\\<^sub>i x21 x22 x23;\n        (aa, b) \\<Turnstile>\n        btree_assn k l x21 * id_assn a x22 * btree_assn k r x23 *\n        is_pfa (2 * k) tsi' (tsil, tsin) *\n        blist_assn k ls tsi' *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        true;\n        \\<not> length tsi' < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k l x21 * id_assn a x22 *\n                          btree_assn k r x23 *\n                          is_pfa (2 * k) tsi' (tsil, tsin) *\n                          blist_assn k ls tsi' *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          true> pfa_append_grow' (tsil, tsin)\n                                 (x21, x22) \\<bind>\n                                (\\<lambda>kvs'.\n                                    node\\<^sub>i k kvs'\n                                     x23) <btupi_assn k\n      (abs_split.node\\<^sub>i k (ls @ [(l, a)]) r)>\\<^sub>t", "apply(sep_auto heap add: node\\<^sub>i_rule_app)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rrs = a # list \\<Longrightarrow>\n       <btree_assn k (Node ts t)\n         ti> ins k x\n              ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rrs = a # list \\<Longrightarrow>\n       <btree_assn k (Node ts t)\n         ti> ins k x\n              ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "case (Cons a rs)"], ["proof (state)\nthis:\n  rrs = a # rs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rrs = a # list \\<Longrightarrow>\n       <btree_assn k (Node ts t)\n         ti> ins k x\n              ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "obtain sub sep where a_split: \"a = (sub,sep)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        a = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rrs = a # list \\<Longrightarrow>\n       <btree_assn k (Node ts t)\n         ti> ins k x\n              ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  a = (sub, sep)", "have [simp]: \"sorted_less (inorder sub)\""], ["proof (prove)\nusing this:\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. sorted_less (inorder sub)", "using \"2.prems\" abs_split.split_axioms list_split Cons sorted_inorder_induct_subtree split_def"], ["proof (prove)\nusing this:\n  a = (sub, sep)\n  sorted_less (inorder (Node ts t))\n  split split\n  split ts x = (ls, rrs)\n  rrs = a # rs\n  sorted_less\n   (inorder (Node (?ls @ (?sub, ?sep) # ?rs) ?t)) \\<Longrightarrow>\n  sorted_less (inorder ?sub)\n  split ?split \\<equiv>\n  (\\<forall>xs p ls rs.\n      ?split xs p = (ls, rs) \\<longrightarrow> xs = ls @ rs) \\<and>\n  (\\<forall>xs p ls sub sep rs.\n      ?split xs p = (ls @ [(sub, sep)], rs) \\<longrightarrow>\n      sorted_less (separators xs) \\<longrightarrow> sep < p) \\<and>\n  (\\<forall>xs p ls sub sep rs.\n      ?split xs p = (ls, (sub, sep) # rs) \\<longrightarrow>\n      sorted_less (separators xs) \\<longrightarrow> p \\<le> sep)\n\ngoal (1 subgoal):\n 1. sorted_less (inorder sub)", "by fastforce"], ["proof (state)\nthis:\n  sorted_less (inorder sub)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rrs = a # list \\<Longrightarrow>\n       <btree_assn k (Node ts t)\n         ti> ins k x\n              ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  sorted_less (inorder sub)", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_less (inorder sub)\n\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "proof(cases \"x = sep\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_less (inorder sub); x = sep\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.ins k x (Node ts t))>\\<^sub>t\n 2. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.ins k x (Node ts t))>\\<^sub>t", "case True"], ["proof (state)\nthis:\n  x = sep\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_less (inorder sub); x = sep\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.ins k x (Node ts t))>\\<^sub>t\n 2. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.ins k x (Node ts t))>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "apply(subst ins.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> case ti of None \\<Rightarrow> return (Up\\<^sub>i None x None)\n          | Some ap \\<Rightarrow>\n              !ap \\<bind>\n              (\\<lambda>a.\n                  imp_split (kvs a) x \\<bind>\n                  (\\<lambda>i.\n                      pfa_length (kvs a) \\<bind>\n                      (\\<lambda>tsl.\n                          if i < tsl\n                          then pfa_get (kvs a) i \\<bind>\n                               (\\<lambda>s.\n                                   let (sub, sep) = s\n                                   in if sep = x then return (T\\<^sub>i ti)\nelse ins k x sub \\<bind>\n     case_btupi\n      (\\<lambda>lp.\n          pfa_set (kvs a) i (lp, sep) \\<bind>\n          (\\<lambda>_. return (T\\<^sub>i ti)))\n      (\\<lambda>lp x' rp.\n          pfa_set (kvs a) i (rp, sep) \\<bind>\n          (\\<lambda>_.\n              if tsl < 2 * k\n              then pfa_insert (kvs a) i (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       ap := Btnode kvs' (BTree_Imp.last a) \\<bind>\n                       (\\<lambda>_. return (T\\<^sub>i ti)))\n              else pfa_insert_grow (kvs a) i (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n                          else ins k x (BTree_Imp.last a) \\<bind>\n                               case_btupi\n                                (\\<lambda>lp.\n                                    ap := Btnode (kvs a) lp \\<bind>\n                                    (\\<lambda>_. return (T\\<^sub>i ti)))\n                                (\\<lambda>lp x' rp.\n                                    if tsl < 2 * k\n                                    then pfa_append (kvs a) (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       ap := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i ti)))\n                                    else pfa_append_grow' (kvs a)\n    (lp, x') \\<bind>\n   (\\<lambda>kvs'.\n       node\\<^sub>i k kvs'\n        rp))))) <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a b ti tsi' xb sub.\n       \\<lbrakk>ti = Some x; split_relation ts (split ts x) xb;\n        xb < length tsi'; tsi' ! xb = (sub, x)\\<rbrakk>\n       \\<Longrightarrow> is_pfa (2 * k) tsi' (a, b) * blist_assn k ts tsi' *\n                         x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (case split ts x of\n                           (ls, []) \\<Rightarrow>\n                             case abs_split.ins k x t of\n                             abs_split.T\\<^sub>i a \\<Rightarrow>\n                               abs_split.T\\<^sub>i (Node ls a)\n                             | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                                 abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                           | (ls, (sub, sep) # rs) \\<Rightarrow>\n                               if sep = x\n                               then abs_split.T\\<^sub>i (Node ts t)\n                               else case abs_split.ins k x sub of\n                                    abs_split.T\\<^sub>i a \\<Rightarrow>\nabs_split.T\\<^sub>i (Node (ls @ (a, sep) # rs) t)\n                                    | abs_split.Up\\<^sub>i l a\n r \\<Rightarrow>\n  abs_split.node\\<^sub>i k (ls @ (l, a) # (r, sep) # rs) t)\n                          (T\\<^sub>i (Some x)) *\n                         true\n 2. \\<And>x a b ti tsi' xb xaa xc sub sep.\n       \\<lbrakk>ti = Some x; split_relation ts (split ts x) xb;\n        xaa = length tsi'; xb < length tsi'; tsi' ! xb = (sub, sep);\n        xc = (sub, sep); sep \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x sub \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (a, b) xb (lp, sep) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (a, b) xb (rp, sep) \\<bind>\n                                     (\\<lambda>_.\n   if length tsi' < 2 * k\n   then pfa_insert (a, b) xb (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (a, b) xb (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (case split ts x of\n                      (ls, []) \\<Rightarrow>\n                        case abs_split.ins k x t of\n                        abs_split.T\\<^sub>i a \\<Rightarrow>\n                          abs_split.T\\<^sub>i (Node ls a)\n                        | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                            abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                      | (ls, (sub, sep) # rs) \\<Rightarrow>\n                          if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                          else case abs_split.ins k x sub of\n                               abs_split.T\\<^sub>i a \\<Rightarrow>\n                                 abs_split.T\\<^sub>i\n                                  (Node (ls @ (a, sep) # rs) t)\n                               | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                   abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # (r, sep) # rs)\n                                    t)>\\<^sub>t\n 3. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>ti = Some x; split_relation ts (split ts x) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (a, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length tsi' < 2 * k\n                                     then pfa_append (a, b) (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (a, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (case split ts x of\n                 (ls, []) \\<Rightarrow>\n                   case abs_split.ins k x t of\n                   abs_split.T\\<^sub>i a \\<Rightarrow>\n                     abs_split.T\\<^sub>i (Node ls a)\n                   | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                       abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                 | (ls, (sub, sep) # rs) \\<Rightarrow>\n                     if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                     else case abs_split.ins k x sub of\n                          abs_split.T\\<^sub>i a \\<Rightarrow>\n                            abs_split.T\\<^sub>i\n                             (Node (ls @ (a, sep) # rs) t)\n                          | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                              abs_split.node\\<^sub>i k\n                               (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "subgoal for p tsil tsin tti tsi j subi"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ti = Some p; split_relation ts (split ts x) j; j < length tsi;\n     tsi ! j = (subi, x)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k) tsi (tsil, tsin) *\n                      blist_assn k ts tsi *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                      btree_assn k t tti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      btupi_assn k\n                       (case split ts x of\n                        (ls, []) \\<Rightarrow>\n                          case abs_split.ins k x t of\n                          abs_split.T\\<^sub>i a \\<Rightarrow>\n                            abs_split.T\\<^sub>i (Node ls a)\n                          | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                              abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                        | (ls, (sub, sep) # rs) \\<Rightarrow>\n                            if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                            else case abs_split.ins k x sub of\n                                 abs_split.T\\<^sub>i a \\<Rightarrow>\n                                   abs_split.T\\<^sub>i\n                                    (Node (ls @ (a, sep) # rs) t)\n                                 | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                     abs_split.node\\<^sub>i k\n(ls @ (l, a) # (r, sep) # rs) t)\n                       (T\\<^sub>i (Some p)) *\n                      true", "using Cons list_split a_split True"], ["proof (prove)\nusing this:\n  rrs = a # rs\n  split ts x = (ls, rrs)\n  a = (sub, sep)\n  x = sep\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ti = Some p; split_relation ts (split ts x) j; j < length tsi;\n     tsi ! j = (subi, x)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k) tsi (tsil, tsin) *\n                      blist_assn k ts tsi *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                      btree_assn k t tti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      btupi_assn k\n                       (case split ts x of\n                        (ls, []) \\<Rightarrow>\n                          case abs_split.ins k x t of\n                          abs_split.T\\<^sub>i a \\<Rightarrow>\n                            abs_split.T\\<^sub>i (Node ls a)\n                          | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                              abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                        | (ls, (sub, sep) # rs) \\<Rightarrow>\n                            if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                            else case abs_split.ins k x sub of\n                                 abs_split.T\\<^sub>i a \\<Rightarrow>\n                                   abs_split.T\\<^sub>i\n                                    (Node (ls @ (a, sep) # rs) t)\n                                 | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                     abs_split.node\\<^sub>i k\n(ls @ (l, a) # (r, sep) # rs) t)\n                       (T\\<^sub>i (Some p)) *\n                      true", "by sep_auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b ti tsi' xb xaa xc sub sep.\n       \\<lbrakk>ti = Some x; split_relation ts (split ts x) xb;\n        xaa = length tsi'; xb < length tsi'; tsi' ! xb = (sub, sep);\n        xc = (sub, sep); sep \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x sub \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (a, b) xb (lp, sep) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (a, b) xb (rp, sep) \\<bind>\n                                     (\\<lambda>_.\n   if length tsi' < 2 * k\n   then pfa_insert (a, b) xb (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (a, b) xb (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (case split ts x of\n                      (ls, []) \\<Rightarrow>\n                        case abs_split.ins k x t of\n                        abs_split.T\\<^sub>i a \\<Rightarrow>\n                          abs_split.T\\<^sub>i (Node ls a)\n                        | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                            abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                      | (ls, (sub, sep) # rs) \\<Rightarrow>\n                          if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                          else case abs_split.ins k x sub of\n                               abs_split.T\\<^sub>i a \\<Rightarrow>\n                                 abs_split.T\\<^sub>i\n                                  (Node (ls @ (a, sep) # rs) t)\n                               | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                   abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # (r, sep) # rs)\n                                    t)>\\<^sub>t\n 2. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>ti = Some x; split_relation ts (split ts x) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (a, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length tsi' < 2 * k\n                                     then pfa_append (a, b) (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (a, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (case split ts x of\n                 (ls, []) \\<Rightarrow>\n                   case abs_split.ins k x t of\n                   abs_split.T\\<^sub>i a \\<Rightarrow>\n                     abs_split.T\\<^sub>i (Node ls a)\n                   | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                       abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                 | (ls, (sub, sep) # rs) \\<Rightarrow>\n                     if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                     else case abs_split.ins k x sub of\n                          abs_split.T\\<^sub>i a \\<Rightarrow>\n                            abs_split.T\\<^sub>i\n                             (Node (ls @ (a, sep) # rs) t)\n                          | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                              abs_split.node\\<^sub>i k\n                               (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "subgoal for p tsil tsin tti tsi j _ _ subi sepi"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ti = Some p; split_relation ts (split ts x) j;\n     xaa_ = length tsi; j < length tsi; tsi ! j = (subi, sepi);\n     xc_ = (subi, sepi); sepi \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) tsi (tsil, tsin) *\n                       blist_assn k ts tsi *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                       btree_assn k t tti *\n                       true> ins k x subi \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  pfa_set (tsil, tsin) j (lp, sepi) \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  pfa_set (tsil, tsin) j (rp, sepi) \\<bind>\n                                  (\\<lambda>_.\nif length tsi < 2 * k\nthen pfa_insert (tsil, tsin) j (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         p := Btnode kvs' tti \\<bind>\n         (\\<lambda>_. return (T\\<^sub>i (Some p))))\nelse pfa_insert_grow (tsil, tsin) j (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         node\\<^sub>i k kvs'\n          tti))) <btupi_assn k\n                   (case split ts x of\n                    (ls, []) \\<Rightarrow>\n                      case abs_split.ins k x t of\n                      abs_split.T\\<^sub>i a \\<Rightarrow>\n                        abs_split.T\\<^sub>i (Node ls a)\n                      | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                          abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                    | (ls, (sub, sep) # rs) \\<Rightarrow>\n                        if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                        else case abs_split.ins k x sub of\n                             abs_split.T\\<^sub>i a \\<Rightarrow>\n                               abs_split.T\\<^sub>i\n                                (Node (ls @ (a, sep) # rs) t)\n                             | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                 abs_split.node\\<^sub>i k\n                                  (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>ti = Some p; split_relation ts (split ts x) j;\n        xaa_ = length tsi; j < length tsi; tsi ! j = (subi, sepi);\n        xc_ = (subi, sepi); sepi \\<noteq> x;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi (tsil, tsin) * blist_assn k ts tsi *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        btree_assn k t tti *\n        true\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi (tsil, tsin) *\n                          blist_assn k ts tsi *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          btree_assn k t tti *\n                          true> ins k x subi \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (tsil, tsin) j\n(lp, sepi) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some p))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (tsil, tsin) j\n(rp, sepi) \\<bind>\n                                     (\\<lambda>_.\n   if length tsi < 2 * k\n   then pfa_insert (tsil, tsin) j (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            p := Btnode kvs' tti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some p))))\n   else pfa_insert_grow (tsil, tsin) j (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             tti))) <btupi_assn k\n                      (case split ts x of\n                       (ls, []) \\<Rightarrow>\n                         case abs_split.ins k x t of\n                         abs_split.T\\<^sub>i a \\<Rightarrow>\n                           abs_split.T\\<^sub>i (Node ls a)\n                         | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                             abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                       | (ls, (sub, sep) # rs) \\<Rightarrow>\n                           if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                           else case abs_split.ins k x sub of\n                                abs_split.T\\<^sub>i a \\<Rightarrow>\n                                  abs_split.T\\<^sub>i\n                                   (Node (ls @ (a, sep) # rs) t)\n                                | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                    abs_split.node\\<^sub>i k\n                                     (ls @ (l, a) # (r, sep) # rs)\n                                     t)>\\<^sub>t", "using Cons list_split a_split True"], ["proof (prove)\nusing this:\n  rrs = a # rs\n  split ts x = (ls, rrs)\n  a = (sub, sep)\n  x = sep\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>ti = Some p; split_relation ts (split ts x) j;\n        xaa_ = length tsi; j < length tsi; tsi ! j = (subi, sepi);\n        xc_ = (subi, sepi); sepi \\<noteq> x;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi (tsil, tsin) * blist_assn k ts tsi *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        btree_assn k t tti *\n        true\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi (tsil, tsin) *\n                          blist_assn k ts tsi *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          btree_assn k t tti *\n                          true> ins k x subi \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (tsil, tsin) j\n(lp, sepi) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some p))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (tsil, tsin) j\n(rp, sepi) \\<bind>\n                                     (\\<lambda>_.\n   if length tsi < 2 * k\n   then pfa_insert (tsil, tsin) j (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            p := Btnode kvs' tti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some p))))\n   else pfa_insert_grow (tsil, tsin) j (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             tti))) <btupi_assn k\n                      (case split ts x of\n                       (ls, []) \\<Rightarrow>\n                         case abs_split.ins k x t of\n                         abs_split.T\\<^sub>i a \\<Rightarrow>\n                           abs_split.T\\<^sub>i (Node ls a)\n                         | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                             abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                       | (ls, (sub, sep) # rs) \\<Rightarrow>\n                           if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                           else case abs_split.ins k x sub of\n                                abs_split.T\\<^sub>i a \\<Rightarrow>\n                                  abs_split.T\\<^sub>i\n                                   (Node (ls @ (a, sep) # rs) t)\n                                | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                    abs_split.node\\<^sub>i k\n                                     (ls @ (l, a) # (r, sep) # rs)\n                                     t)>\\<^sub>t", "apply(subgoal_tac \"sepi = sep\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<lbrakk>ti = Some p; split_relation ts (split ts x) j;\n        xaa_ = length tsi; j < length tsi; tsi ! j = (subi, sepi);\n        xc_ = (subi, sepi); sepi \\<noteq> x;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi (tsil, tsin) * blist_assn k ts tsi *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        btree_assn k t tti *\n        true;\n        rrs = a # rs; split ts x = (ls, rrs); a = (sub, sep); x = sep;\n        sepi = sep\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi (tsil, tsin) *\n                          blist_assn k ts tsi *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          btree_assn k t tti *\n                          true> ins k x subi \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (tsil, tsin) j\n(lp, sepi) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some p))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (tsil, tsin) j\n(rp, sepi) \\<bind>\n                                     (\\<lambda>_.\n   if length tsi < 2 * k\n   then pfa_insert (tsil, tsin) j (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            p := Btnode kvs' tti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some p))))\n   else pfa_insert_grow (tsil, tsin) j (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             tti))) <btupi_assn k\n                      (case split ts x of\n                       (ls, []) \\<Rightarrow>\n                         case abs_split.ins k x t of\n                         abs_split.T\\<^sub>i a \\<Rightarrow>\n                           abs_split.T\\<^sub>i (Node ls a)\n                         | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                             abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                       | (ls, (sub, sep) # rs) \\<Rightarrow>\n                           if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                           else case abs_split.ins k x sub of\n                                abs_split.T\\<^sub>i a \\<Rightarrow>\n                                  abs_split.T\\<^sub>i\n                                   (Node (ls @ (a, sep) # rs) t)\n                                | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                                    abs_split.node\\<^sub>i k\n                                     (ls @ (l, a) # (r, sep) # rs)\n                                     t)>\\<^sub>t\n 2. \\<And>h.\n       \\<lbrakk>ti = Some p; split_relation ts (split ts x) j;\n        xaa_ = length tsi; j < length tsi; tsi ! j = (subi, sepi);\n        xc_ = (subi, sepi); sepi \\<noteq> x;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi (tsil, tsin) * blist_assn k ts tsi *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        btree_assn k t tti *\n        true;\n        rrs = a # rs; split ts x = (ls, rrs); a = (sub, sep);\n        x = sep\\<rbrakk>\n       \\<Longrightarrow> sepi = sep", "apply (sep_auto simp add: split_relation_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>ti = Some p; split_relation ts (split ts x) j;\n        xaa_ = length tsi; j < length tsi; tsi ! j = (subi, sepi);\n        xc_ = (subi, sepi); sepi \\<noteq> x;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi (tsil, tsin) * blist_assn k ts tsi *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        btree_assn k t tti *\n        true;\n        rrs = a # rs; split ts x = (ls, rrs); a = (sub, sep);\n        x = sep\\<rbrakk>\n       \\<Longrightarrow> sepi = sep", "apply(sep_auto simp add: list_assn_prod_map dest!: mod_starD id_assn_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ad bd af bf ag bg aj bj.\n       \\<lbrakk>ti = Some p; split_relation ts (ls, (sub, sep) # rs) j;\n        xaa_ = length tsi; j < length tsi; tsi ! j = (subi, sepi);\n        xc_ = (subi, sepi); sepi \\<noteq> sep; rrs = (sub, sep) # rs;\n        split ts sep = (ls, (sub, sep) # rs); a = (sub, sep); x = sep;\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t tti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti;\n        (ag, bg) \\<Turnstile> is_pfa (2 * k) tsi (tsil, tsin);\n        (aj, bj) \\<Turnstile>\n        list_assn (btree_assn k) (subtrees ts) (subtrees tsi);\n        separators ts = separators tsi\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis length_map snd_conv snd_map_help(2) split_relation_access)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b ti tsi' xb xaa.\n       \\<lbrakk>ti = Some x; split_relation ts (split ts x) xb;\n        xaa = length tsi'; \\<not> xb < length tsi'\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' (a, b) *\n                          blist_assn k ts tsi' *\n                          x \\<mapsto>\\<^sub>r Btnode (a, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (a, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length tsi' < 2 * k\n                                     then pfa_append (a, b) (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (a, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (case split ts x of\n                 (ls, []) \\<Rightarrow>\n                   case abs_split.ins k x t of\n                   abs_split.T\\<^sub>i a \\<Rightarrow>\n                     abs_split.T\\<^sub>i (Node ls a)\n                   | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                       abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                 | (ls, (sub, sep) # rs) \\<Rightarrow>\n                     if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                     else case abs_split.ins k x sub of\n                          abs_split.T\\<^sub>i a \\<Rightarrow>\n                            abs_split.T\\<^sub>i\n                             (Node (ls @ (a, sep) # rs) t)\n                          | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                              abs_split.node\\<^sub>i k\n                               (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "subgoal for p tsil tsin tti tsi j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ti = Some p; split_relation ts (split ts x) j;\n     xaa_ = length tsi; \\<not> j < length tsi\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) tsi (tsil, tsin) *\n                       blist_assn k ts tsi *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                       btree_assn k t tti *\n                       true> ins k x tti \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  if length tsi < 2 * k\n                                  then pfa_append (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     p := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                  else pfa_append_grow' (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     node\\<^sub>i k kvs'\n      rp)) <btupi_assn k\n             (case split ts x of\n              (ls, []) \\<Rightarrow>\n                case abs_split.ins k x t of\n                abs_split.T\\<^sub>i a \\<Rightarrow>\n                  abs_split.T\\<^sub>i (Node ls a)\n                | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                    abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n              | (ls, (sub, sep) # rs) \\<Rightarrow>\n                  if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                  else case abs_split.ins k x sub of\n                       abs_split.T\\<^sub>i a \\<Rightarrow>\n                         abs_split.T\\<^sub>i (Node (ls @ (a, sep) # rs) t)\n                       | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                           abs_split.node\\<^sub>i k\n                            (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>ti = Some p; split_relation ts (split ts x) j;\n        xaa_ = length tsi; \\<not> j < length tsi;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi (tsil, tsin) * blist_assn k ts tsi *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        btree_assn k t tti *\n        true\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi (tsil, tsin) *\n                          blist_assn k ts tsi *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          btree_assn k t tti *\n                          true> ins k x tti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     p := Btnode (tsil, tsin) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some p))))\n                                 (\\<lambda>lp x' rp.\n                                     if length tsi < 2 * k\n                                     then pfa_append (tsil, tsin)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        p := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                     else pfa_append_grow' (tsil, tsin)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (case split ts x of\n                 (ls, []) \\<Rightarrow>\n                   case abs_split.ins k x t of\n                   abs_split.T\\<^sub>i a \\<Rightarrow>\n                     abs_split.T\\<^sub>i (Node ls a)\n                   | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                       abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                 | (ls, (sub, sep) # rs) \\<Rightarrow>\n                     if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                     else case abs_split.ins k x sub of\n                          abs_split.T\\<^sub>i a \\<Rightarrow>\n                            abs_split.T\\<^sub>i\n                             (Node (ls @ (a, sep) # rs) t)\n                          | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                              abs_split.node\\<^sub>i k\n                               (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "using Cons list_split"], ["proof (prove)\nusing this:\n  rrs = a # rs\n  split ts x = (ls, rrs)\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>ti = Some p; split_relation ts (split ts x) j;\n        xaa_ = length tsi; \\<not> j < length tsi;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi (tsil, tsin) * blist_assn k ts tsi *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n        btree_assn k t tti *\n        true\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi (tsil, tsin) *\n                          blist_assn k ts tsi *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) tti *\n                          btree_assn k t tti *\n                          true> ins k x tti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     p := Btnode (tsil, tsin) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some p))))\n                                 (\\<lambda>lp x' rp.\n                                     if length tsi < 2 * k\n                                     then pfa_append (tsil, tsin)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        p := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                     else pfa_append_grow' (tsil, tsin)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (case split ts x of\n                 (ls, []) \\<Rightarrow>\n                   case abs_split.ins k x t of\n                   abs_split.T\\<^sub>i a \\<Rightarrow>\n                     abs_split.T\\<^sub>i (Node ls a)\n                   | abs_split.Up\\<^sub>i l a x \\<Rightarrow>\n                       abs_split.node\\<^sub>i k (ls @ [(l, a)]) x\n                 | (ls, (sub, sep) # rs) \\<Rightarrow>\n                     if sep = x then abs_split.T\\<^sub>i (Node ts t)\n                     else case abs_split.ins k x sub of\n                          abs_split.T\\<^sub>i a \\<Rightarrow>\n                            abs_split.T\\<^sub>i\n                             (Node (ls @ (a, sep) # rs) t)\n                          | abs_split.Up\\<^sub>i l a r \\<Rightarrow>\n                              abs_split.node\\<^sub>i k\n                               (ls @ (l, a) # (r, sep) # rs) t)>\\<^sub>t", "by (sep_auto simp add: split_relation_alt dest!: mod_starD list_assn_len)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.ins k x (Node ts t))>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.ins k x (Node ts t))>\\<^sub>t", "case False"], ["proof (state)\nthis:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.ins k x (Node ts t))>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> sep", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "proof (cases \"abs_split.ins k x sub\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x \\<noteq> sep;\n        abs_split.ins k x sub = abs_split.T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "case (T\\<^sub>i a')"], ["proof (state)\nthis:\n  abs_split.ins k x sub = abs_split.T\\<^sub>i a'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x \\<noteq> sep;\n        abs_split.ins k x sub = abs_split.T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  abs_split.ins k x sub = abs_split.T\\<^sub>i a'", "show ?thesis"], ["proof (prove)\nusing this:\n  abs_split.ins k x sub = abs_split.T\\<^sub>i a'\n\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "apply(auto simp add: Cons list_split a_split False)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n     sep = x\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n     sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.T\\<^sub>i\n                                    (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "using False"], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n     sep = x\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n     sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.T\\<^sub>i\n                                    (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n     sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.T\\<^sub>i\n                                    (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply(subst ins.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n     sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> case ti of\n                            None \\<Rightarrow>\n                              return (Up\\<^sub>i None x None)\n                            | Some ap \\<Rightarrow>\n                                !ap \\<bind>\n                                (\\<lambda>a.\n                                    imp_split (kvs a) x \\<bind>\n                                    (\\<lambda>i.\n  pfa_length (kvs a) \\<bind>\n  (\\<lambda>tsl.\n      if i < tsl\n      then pfa_get (kvs a) i \\<bind>\n           (\\<lambda>s.\n               let (sub, sep) = s\n               in if sep = x then return (T\\<^sub>i ti)\n                  else ins k x sub \\<bind>\n                       case_btupi\n                        (\\<lambda>lp.\n                            pfa_set (kvs a) i (lp, sep) \\<bind>\n                            (\\<lambda>_. return (T\\<^sub>i ti)))\n                        (\\<lambda>lp x' rp.\n                            pfa_set (kvs a) i (rp, sep) \\<bind>\n                            (\\<lambda>_.\n                                if tsl < 2 * k\n                                then pfa_insert (kvs a) i (lp, x') \\<bind>\n                                     (\\<lambda>kvs'.\n   ap := Btnode kvs' (BTree_Imp.last a) \\<bind>\n   (\\<lambda>_. return (T\\<^sub>i ti)))\n                                else pfa_insert_grow (kvs a) i\n(lp, x') \\<bind>\n                                     (\\<lambda>kvs'.\n   node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n      else ins k x (BTree_Imp.last a) \\<bind>\n           case_btupi\n            (\\<lambda>lp.\n                ap := Btnode (kvs a) lp \\<bind>\n                (\\<lambda>_. return (T\\<^sub>i ti)))\n            (\\<lambda>lp x' rp.\n                if tsl < 2 * k\n                then pfa_append (kvs a) (lp, x') \\<bind>\n                     (\\<lambda>kvs'.\n                         ap := Btnode kvs' rp \\<bind>\n                         (\\<lambda>_. return (T\\<^sub>i ti)))\n                else pfa_append_grow' (kvs a) (lp, x') \\<bind>\n                     (\\<lambda>kvs'.\n                         node\\<^sub>i k kvs'\n                          rp))))) <btupi_assn k\n                                    (abs_split.T\\<^sub>i\n(Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = None\\<rbrakk>\n       \\<Longrightarrow> btree_assn k (Node ts t) None *\n                         \\<up>\n                          (x =\n                           Up\\<^sub>i None x None) \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.T\\<^sub>i\n                            (Node (ls @ (a', sep) # rs) t))\n                          x *\n                         true\n 2. \\<And>x.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> !x \\<bind>\n                               (\\<lambda>a.\n                                   imp_split (kvs a) x \\<bind>\n                                   (\\<lambda>i.\n pfa_length (kvs a) \\<bind>\n (\\<lambda>tsl.\n     if i < tsl\n     then pfa_get (kvs a) i \\<bind>\n          (\\<lambda>s.\n              case s of\n              (sub, sep) \\<Rightarrow>\n                if sep = x then return (T\\<^sub>i ti)\n                else ins k x sub \\<bind>\n                     case_btupi\n                      (\\<lambda>lp.\n                          pfa_set (kvs a) i (lp, sep) \\<bind>\n                          (\\<lambda>_. return (T\\<^sub>i ti)))\n                      (\\<lambda>lp x' rp.\n                          pfa_set (kvs a) i (rp, sep) \\<bind>\n                          (\\<lambda>_.\n                              if tsl < 2 * k\n                              then pfa_insert (kvs a) i (lp, x') \\<bind>\n                                   (\\<lambda>kvs'.\n x := Btnode kvs' (BTree_Imp.last a) \\<bind>\n (\\<lambda>_. return (T\\<^sub>i ti)))\n                              else pfa_insert_grow (kvs a) i\n                                    (lp, x') \\<bind>\n                                   (\\<lambda>kvs'.\n node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n     else ins k x (BTree_Imp.last a) \\<bind>\n          case_btupi\n           (\\<lambda>lp.\n               x := Btnode (kvs a) lp \\<bind>\n               (\\<lambda>_. return (T\\<^sub>i ti)))\n           (\\<lambda>lp x' rp.\n               if tsl < 2 * k\n               then pfa_append (kvs a) (lp, x') \\<bind>\n                    (\\<lambda>kvs'.\n                        x := Btnode kvs' rp \\<bind>\n                        (\\<lambda>_. return (T\\<^sub>i ti)))\n               else pfa_append_grow' (kvs a) (lp, x') \\<bind>\n                    (\\<lambda>kvs'.\n                        node\\<^sub>i k kvs'\n                         rp))))) <btupi_assn k\n                                   (abs_split.T\\<^sub>i\n                                     (Node (ls @ (a', sep) # rs)\n t))>\\<^sub>t", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Atsi ti tsi'.\n                             x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                             btree_assn k t ti *\n                             is_pfa (2 * k) tsi' tsi *\n                             blist_assn k ts\n                              tsi'> !x \\<bind>\n                                    (\\<lambda>a.\n  imp_split (kvs a) x \\<bind>\n  (\\<lambda>i.\n      pfa_length (kvs a) \\<bind>\n      (\\<lambda>tsl.\n          if i < tsl\n          then pfa_get (kvs a) i \\<bind>\n               (\\<lambda>s.\n                   case s of\n                   (sub, sep) \\<Rightarrow>\n                     if sep = x then return (T\\<^sub>i (Some x))\n                     else ins k x sub \\<bind>\n                          case_btupi\n                           (\\<lambda>lp.\n                               pfa_set (kvs a) i (lp, sep) \\<bind>\n                               (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                           (\\<lambda>lp x' rp.\n                               pfa_set (kvs a) i (rp, sep) \\<bind>\n                               (\\<lambda>_.\n                                   if tsl < 2 * k\n                                   then pfa_insert (kvs a) i\n   (lp, x') \\<bind>\n  (\\<lambda>kvs'.\n      x := Btnode kvs' (BTree_Imp.last a) \\<bind>\n      (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                   else pfa_insert_grow (kvs a) i\n   (lp, x') \\<bind>\n  (\\<lambda>kvs'. node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n          else ins k x (BTree_Imp.last a) \\<bind>\n               case_btupi\n                (\\<lambda>lp.\n                    x := Btnode (kvs a) lp \\<bind>\n                    (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                (\\<lambda>lp x' rp.\n                    if tsl < 2 * k\n                    then pfa_append (kvs a) (lp, x') \\<bind>\n                         (\\<lambda>kvs'.\n                             x := Btnode kvs' rp \\<bind>\n                             (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                    else pfa_append_grow' (kvs a) (lp, x') \\<bind>\n                         (\\<lambda>kvs'.\n                             node\\<^sub>i k kvs'\n                              rp))))) <btupi_assn k\n  (abs_split.T\\<^sub>i (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply(rule norm_pre_ex_rule)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi'.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x\\<rbrakk>\n       \\<Longrightarrow> <x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) tsi' tsi *\n                          blist_assn k ts\n                           tsi'> !x \\<bind>\n                                 (\\<lambda>a.\n                                     imp_split (kvs a) x \\<bind>\n                                     (\\<lambda>i.\n   pfa_length (kvs a) \\<bind>\n   (\\<lambda>tsl.\n       if i < tsl\n       then pfa_get (kvs a) i \\<bind>\n            (\\<lambda>s.\n                case s of\n                (sub, sep) \\<Rightarrow>\n                  if sep = x then return (T\\<^sub>i (Some x))\n                  else ins k x sub \\<bind>\n                       case_btupi\n                        (\\<lambda>lp.\n                            pfa_set (kvs a) i (lp, sep) \\<bind>\n                            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                        (\\<lambda>lp x' rp.\n                            pfa_set (kvs a) i (rp, sep) \\<bind>\n                            (\\<lambda>_.\n                                if tsl < 2 * k\n                                then pfa_insert (kvs a) i (lp, x') \\<bind>\n                                     (\\<lambda>kvs'.\n   x := Btnode kvs' (BTree_Imp.last a) \\<bind>\n   (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                else pfa_insert_grow (kvs a) i\n(lp, x') \\<bind>\n                                     (\\<lambda>kvs'.\n   node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n       else ins k x (BTree_Imp.last a) \\<bind>\n            case_btupi\n             (\\<lambda>lp.\n                 x := Btnode (kvs a) lp \\<bind>\n                 (\\<lambda>_. return (T\\<^sub>i (Some x))))\n             (\\<lambda>lp x' rp.\n                 if tsl < 2 * k\n                 then pfa_append (kvs a) (lp, x') \\<bind>\n                      (\\<lambda>kvs'.\n                          x := Btnode kvs' rp \\<bind>\n                          (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                 else pfa_append_grow' (kvs a) (lp, x') \\<bind>\n                      (\\<lambda>kvs'.\n                          node\\<^sub>i k kvs'\n                           rp))))) <btupi_assn k\n                                     (abs_split.T\\<^sub>i\n (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "(* at this point, we want to introduce the split, and after that tease the\n  hoare triple assumptions out of the bracket, s.t. we don't split twice *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi'.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x\\<rbrakk>\n       \\<Longrightarrow> <x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) tsi' tsi *\n                          blist_assn k ts\n                           tsi'> !x \\<bind>\n                                 (\\<lambda>a.\n                                     imp_split (kvs a) x \\<bind>\n                                     (\\<lambda>i.\n   pfa_length (kvs a) \\<bind>\n   (\\<lambda>tsl.\n       if i < tsl\n       then pfa_get (kvs a) i \\<bind>\n            (\\<lambda>s.\n                case s of\n                (sub, sep) \\<Rightarrow>\n                  if sep = x then return (T\\<^sub>i (Some x))\n                  else ins k x sub \\<bind>\n                       case_btupi\n                        (\\<lambda>lp.\n                            pfa_set (kvs a) i (lp, sep) \\<bind>\n                            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                        (\\<lambda>lp x' rp.\n                            pfa_set (kvs a) i (rp, sep) \\<bind>\n                            (\\<lambda>_.\n                                if tsl < 2 * k\n                                then pfa_insert (kvs a) i (lp, x') \\<bind>\n                                     (\\<lambda>kvs'.\n   x := Btnode kvs' (BTree_Imp.last a) \\<bind>\n   (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                else pfa_insert_grow (kvs a) i\n(lp, x') \\<bind>\n                                     (\\<lambda>kvs'.\n   node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n       else ins k x (BTree_Imp.last a) \\<bind>\n            case_btupi\n             (\\<lambda>lp.\n                 x := Btnode (kvs a) lp \\<bind>\n                 (\\<lambda>_. return (T\\<^sub>i (Some x))))\n             (\\<lambda>lp x' rp.\n                 if tsl < 2 * k\n                 then pfa_append (kvs a) (lp, x') \\<bind>\n                      (\\<lambda>kvs'.\n                          x := Btnode kvs' rp \\<bind>\n                          (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                 else pfa_append_grow' (kvs a) (lp, x') \\<bind>\n                      (\\<lambda>kvs'.\n                          node\\<^sub>i k kvs'\n                           rp))))) <btupi_assn k\n                                     (abs_split.T\\<^sub>i\n (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x tsi ti tsi' xaa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti\\<rbrakk>\n       \\<Longrightarrow> <x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) tsi' tsi *\n                          blist_assn k ts tsi'>\n                         imp_split tsi x\n                         <?R33 x tsi ti tsi' (Btnode tsi ti)>\n 2. \\<And>x tsi ti tsi' xaa xb.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti\\<rbrakk>\n       \\<Longrightarrow> <?R33 x tsi ti tsi' xaa\n                           xb> pfa_length tsi \\<bind>\n                               (\\<lambda>tsl.\n                                   if xb < tsl\n                                   then pfa_get tsi xb \\<bind>\n  (\\<lambda>(sub, sep).\n      if sep = x then return (T\\<^sub>i (Some x))\n      else ins k x sub \\<bind>\n           case_btupi\n            (\\<lambda>lp.\n                pfa_set tsi xb (lp, sep) \\<bind>\n                (\\<lambda>_. return (T\\<^sub>i (Some x))))\n            (\\<lambda>lp x' rp.\n                pfa_set tsi xb (rp, sep) \\<bind>\n                (\\<lambda>_.\n                    if tsl < 2 * k\n                    then pfa_insert tsi xb (lp, x') \\<bind>\n                         (\\<lambda>kvs'.\n                             x := Btnode kvs' ti \\<bind>\n                             (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                    else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                         (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n                                   else ins k x ti \\<bind>\n  case_btupi\n   (\\<lambda>lp.\n       x := Btnode tsi lp \\<bind> (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   (\\<lambda>lp x' rp.\n       if tsl < 2 * k\n       then pfa_append tsi (lp, x') \\<bind>\n            (\\<lambda>kvs'.\n                x := Btnode kvs' rp \\<bind>\n                (\\<lambda>_. return (T\\<^sub>i (Some x))))\n       else pfa_append_grow' tsi (lp, x') \\<bind>\n            (\\<lambda>kvs'.\n                node\\<^sub>i k kvs'\n                 rp))) <btupi_assn k\n                         (abs_split.T\\<^sub>i\n                           (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi' xaa xb.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' tsi * blist_assn k ts tsi' *\n                          \\<up> (split_relation ts (split ts x) xb) *\n                          true *\n                          (x \\<mapsto>\\<^sub>r xaa *\n                           btree_assn k t\n                            ti)> pfa_length tsi \\<bind>\n                                 (\\<lambda>tsl.\n                                     if xb < tsl\n                                     then pfa_get tsi xb \\<bind>\n    (\\<lambda>(sub, sep).\n        if sep = x then return (T\\<^sub>i (Some x))\n        else ins k x sub \\<bind>\n             case_btupi\n              (\\<lambda>lp.\n                  pfa_set tsi xb (lp, sep) \\<bind>\n                  (\\<lambda>_. return (T\\<^sub>i (Some x))))\n              (\\<lambda>lp x' rp.\n                  pfa_set tsi xb (rp, sep) \\<bind>\n                  (\\<lambda>_.\n                      if tsl < 2 * k\n                      then pfa_insert tsi xb (lp, x') \\<bind>\n                           (\\<lambda>kvs'.\n                               x := Btnode kvs' ti \\<bind>\n                               (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                      else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                           (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n                                     else ins k x ti \\<bind>\n    case_btupi\n     (\\<lambda>lp.\n         x := Btnode tsi lp \\<bind>\n         (\\<lambda>_. return (T\\<^sub>i (Some x))))\n     (\\<lambda>lp x' rp.\n         if tsl < 2 * k\n         then pfa_append tsi (lp, x') \\<bind>\n              (\\<lambda>kvs'.\n                  x := Btnode kvs' rp \\<bind>\n                  (\\<lambda>_. return (T\\<^sub>i (Some x))))\n         else pfa_append_grow' tsi (lp, x') \\<bind>\n              (\\<lambda>kvs'.\n                  node\\<^sub>i k kvs'\n                   rp))) <btupi_assn k\n                           (abs_split.T\\<^sub>i\n                             (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "using list_split Cons"], ["proof (prove)\nusing this:\n  split ts x = (ls, rrs)\n  rrs = a # rs\n\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi' xaa xb.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' tsi * blist_assn k ts tsi' *\n                          \\<up> (split_relation ts (split ts x) xb) *\n                          true *\n                          (x \\<mapsto>\\<^sub>r xaa *\n                           btree_assn k t\n                            ti)> pfa_length tsi \\<bind>\n                                 (\\<lambda>tsl.\n                                     if xb < tsl\n                                     then pfa_get tsi xb \\<bind>\n    (\\<lambda>(sub, sep).\n        if sep = x then return (T\\<^sub>i (Some x))\n        else ins k x sub \\<bind>\n             case_btupi\n              (\\<lambda>lp.\n                  pfa_set tsi xb (lp, sep) \\<bind>\n                  (\\<lambda>_. return (T\\<^sub>i (Some x))))\n              (\\<lambda>lp x' rp.\n                  pfa_set tsi xb (rp, sep) \\<bind>\n                  (\\<lambda>_.\n                      if tsl < 2 * k\n                      then pfa_insert tsi xb (lp, x') \\<bind>\n                           (\\<lambda>kvs'.\n                               x := Btnode kvs' ti \\<bind>\n                               (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                      else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                           (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n                                     else ins k x ti \\<bind>\n    case_btupi\n     (\\<lambda>lp.\n         x := Btnode tsi lp \\<bind>\n         (\\<lambda>_. return (T\\<^sub>i (Some x))))\n     (\\<lambda>lp x' rp.\n         if tsl < 2 * k\n         then pfa_append tsi (lp, x') \\<bind>\n              (\\<lambda>kvs'.\n                  x := Btnode kvs' rp \\<bind>\n                  (\\<lambda>_. return (T\\<^sub>i (Some x))))\n         else pfa_append_grow' tsi (lp, x') \\<bind>\n              (\\<lambda>kvs'.\n                  node\\<^sub>i k kvs'\n                   rp))) <btupi_assn k\n                           (abs_split.T\\<^sub>i\n                             (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply(simp add: split_relation_alt list_assn_append_Cons_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi' xaa xb.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti;\n        split ts x = (ls, a # rs); rrs = a # rs\\<rbrakk>\n       \\<Longrightarrow> ts = ls @ a # rs \\<and>\n                         xb = length ls \\<longrightarrow>\n                         <\\<exists>\\<^sub>Azs1 z zs2.\n                             is_pfa (2 * k) tsi' tsi *\n                             (blist_assn k ls zs1 *\n                              (btree_assn k \\<times>\\<^sub>a id_assn) a z *\n                              blist_assn k rs zs2) *\n                             (x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                              btree_assn k t ti) *\n                             true *\n                             \\<up>\n                              (zs1 @ z # zs2 =\n                               tsi')> pfa_length tsi \\<bind>\n(\\<lambda>tsl.\n    if length ls < tsl\n    then pfa_get tsi xb \\<bind>\n         (\\<lambda>(sub, sep).\n             if sep = x then return (T\\<^sub>i (Some x))\n             else ins k x sub \\<bind>\n                  case_btupi\n                   (\\<lambda>lp.\n                       pfa_set tsi xb (lp, sep) \\<bind>\n                       (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                   (\\<lambda>lp x' rp.\n                       pfa_set tsi xb (rp, sep) \\<bind>\n                       (\\<lambda>_.\n                           if tsl < 2 * k\n                           then pfa_insert tsi xb (lp, x') \\<bind>\n                                (\\<lambda>kvs'.\n                                    x := Btnode kvs' ti \\<bind>\n                                    (\\<lambda>_.\n  return (T\\<^sub>i (Some x))))\n                           else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                                (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n    else ins k x ti \\<bind>\n         case_btupi\n          (\\<lambda>lp.\n              x := Btnode tsi lp \\<bind>\n              (\\<lambda>_. return (T\\<^sub>i (Some x))))\n          (\\<lambda>lp x' rp.\n              if tsl < 2 * k\n              then pfa_append tsi (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       x := Btnode kvs' rp \\<bind>\n                       (\\<lambda>_. return (T\\<^sub>i (Some x))))\n              else pfa_append_grow' tsi (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       node\\<^sub>i k kvs'\n                        rp))) <btupi_assn k\n                                (abs_split.T\\<^sub>i\n                                  (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi' xaa xb.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti;\n        split ts x = (ls, a # rs); rrs = a # rs;\n        ts = ls @ a # rs \\<and> xb = length ls\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Azs1 z zs2.\n                             is_pfa (2 * k) tsi' tsi *\n                             (blist_assn k ls zs1 *\n                              (btree_assn k \\<times>\\<^sub>a id_assn) a z *\n                              blist_assn k rs zs2) *\n                             (x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                              btree_assn k t ti) *\n                             true *\n                             \\<up>\n                              (zs1 @ z # zs2 =\n                               tsi')> pfa_length tsi \\<bind>\n(\\<lambda>tsl.\n    if length ls < tsl\n    then pfa_get tsi xb \\<bind>\n         (\\<lambda>(sub, sep).\n             if sep = x then return (T\\<^sub>i (Some x))\n             else ins k x sub \\<bind>\n                  case_btupi\n                   (\\<lambda>lp.\n                       pfa_set tsi xb (lp, sep) \\<bind>\n                       (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                   (\\<lambda>lp x' rp.\n                       pfa_set tsi xb (rp, sep) \\<bind>\n                       (\\<lambda>_.\n                           if tsl < 2 * k\n                           then pfa_insert tsi xb (lp, x') \\<bind>\n                                (\\<lambda>kvs'.\n                                    x := Btnode kvs' ti \\<bind>\n                                    (\\<lambda>_.\n  return (T\\<^sub>i (Some x))))\n                           else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                                (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n    else ins k x ti \\<bind>\n         case_btupi\n          (\\<lambda>lp.\n              x := Btnode tsi lp \\<bind>\n              (\\<lambda>_. return (T\\<^sub>i (Some x))))\n          (\\<lambda>lp x' rp.\n              if tsl < 2 * k\n              then pfa_append tsi (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       x := Btnode kvs' rp \\<bind>\n                       (\\<lambda>_. return (T\\<^sub>i (Some x))))\n              else pfa_append_grow' tsi (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       node\\<^sub>i k kvs'\n                        rp))) <btupi_assn k\n                                (abs_split.T\\<^sub>i\n                                  (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply(rule norm_pre_ex_rule)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi' xaa xb zs1 z zs2.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti;\n        split ts x = (ls, a # rs); rrs = a # rs;\n        ts = ls @ a # rs \\<and> xb = length ls\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' tsi *\n                          (blist_assn k ls zs1 *\n                           (btree_assn k \\<times>\\<^sub>a id_assn) a z *\n                           blist_assn k rs zs2) *\n                          (x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                           btree_assn k t ti) *\n                          true *\n                          \\<up>\n                           (zs1 @ z # zs2 =\n                            tsi')> pfa_length tsi \\<bind>\n                                   (\\<lambda>tsl.\n if length ls < tsl\n then pfa_get tsi xb \\<bind>\n      (\\<lambda>(sub, sep).\n          if sep = x then return (T\\<^sub>i (Some x))\n          else ins k x sub \\<bind>\n               case_btupi\n                (\\<lambda>lp.\n                    pfa_set tsi xb (lp, sep) \\<bind>\n                    (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                (\\<lambda>lp x' rp.\n                    pfa_set tsi xb (rp, sep) \\<bind>\n                    (\\<lambda>_.\n                        if tsl < 2 * k\n                        then pfa_insert tsi xb (lp, x') \\<bind>\n                             (\\<lambda>kvs'.\n                                 x := Btnode kvs' ti \\<bind>\n                                 (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                        else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                             (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n else ins k x ti \\<bind>\n      case_btupi\n       (\\<lambda>lp.\n           x := Btnode tsi lp \\<bind>\n           (\\<lambda>_. return (T\\<^sub>i (Some x))))\n       (\\<lambda>lp x' rp.\n           if tsl < 2 * k\n           then pfa_append tsi (lp, x') \\<bind>\n                (\\<lambda>kvs'.\n                    x := Btnode kvs' rp \\<bind>\n                    (\\<lambda>_. return (T\\<^sub>i (Some x))))\n           else pfa_append_grow' tsi (lp, x') \\<bind>\n                (\\<lambda>kvs'.\n                    node\\<^sub>i k kvs'\n                     rp))) <btupi_assn k\n                             (abs_split.T\\<^sub>i\n                               (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi' xaa xb zs1 z zs2 h.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti;\n        split ts x = (ls, a # rs); rrs = a # rs;\n        ts = ls @ a # rs \\<and> xb = length ls;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi' tsi *\n        (blist_assn k ls zs1 * (btree_assn k \\<times>\\<^sub>a id_assn) a z *\n         blist_assn k rs zs2) *\n        (x \\<mapsto>\\<^sub>r Btnode tsi ti * btree_assn k t ti) *\n        true *\n        \\<up> (zs1 @ z # zs2 = tsi')\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' tsi *\n                          (blist_assn k ls zs1 *\n                           (btree_assn k \\<times>\\<^sub>a id_assn) a z *\n                           blist_assn k rs zs2) *\n                          (x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                           btree_assn k t ti) *\n                          true *\n                          \\<up>\n                           (zs1 @ z # zs2 =\n                            tsi')> pfa_length tsi \\<bind>\n                                   (\\<lambda>tsl.\n if length ls < tsl\n then pfa_get tsi xb \\<bind>\n      (\\<lambda>(sub, sep).\n          if sep = x then return (T\\<^sub>i (Some x))\n          else ins k x sub \\<bind>\n               case_btupi\n                (\\<lambda>lp.\n                    pfa_set tsi xb (lp, sep) \\<bind>\n                    (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                (\\<lambda>lp x' rp.\n                    pfa_set tsi xb (rp, sep) \\<bind>\n                    (\\<lambda>_.\n                        if tsl < 2 * k\n                        then pfa_insert tsi xb (lp, x') \\<bind>\n                             (\\<lambda>kvs'.\n                                 x := Btnode kvs' ti \\<bind>\n                                 (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                        else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                             (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n else ins k x ti \\<bind>\n      case_btupi\n       (\\<lambda>lp.\n           x := Btnode tsi lp \\<bind>\n           (\\<lambda>_. return (T\\<^sub>i (Some x))))\n       (\\<lambda>lp x' rp.\n           if tsl < 2 * k\n           then pfa_append tsi (lp, x') \\<bind>\n                (\\<lambda>kvs'.\n                    x := Btnode kvs' rp \\<bind>\n                    (\\<lambda>_. return (T\\<^sub>i (Some x))))\n           else pfa_append_grow' tsi (lp, x') \\<bind>\n                (\\<lambda>kvs'.\n                    node\\<^sub>i k kvs'\n                     rp))) <btupi_assn k\n                             (abs_split.T\\<^sub>i\n                               (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x aa b ti zs1 aaa ba zs2 ab bb suba.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (aaa, ba) # zs2) ! length ls = (suba, x)\\<rbrakk>\n       \\<Longrightarrow> is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                         blist_assn k ls zs1 *\n                         (btree_assn k \\<times>\\<^sub>a id_assn) a\n                          (aaa, ba) *\n                         blist_assn k rs zs2 *\n                         x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         x \\<mapsto>\\<^sub>r\n                         Btnode\n                          (?tsi'155 x aa b ti zs1 aaa ba zs2 ab bb suba)\n                          (?tsi'156 x aa b ti zs1 aaa ba zs2 ab bb suba) *\n                         btree_assn k t\n                          (?tsi'156 x aa b ti zs1 aaa ba zs2 ab bb suba) *\n                         is_pfa (2 * k)\n                          (?tsi'157 x aa b ti zs1 aaa ba zs2 ab bb suba)\n                          (?tsi'155 x aa b ti zs1 aaa ba zs2 ab bb suba) *\n                         blist_assn k (ls @ (a', sep) # rs)\n                          (?tsi'157 x aa b ti zs1 aaa ba zs2 ab bb suba) *\n                         true\n 2. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa xb suba sepa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        length ls < length (zs1 @ (aaa, ba) # zs2);\n        (zs1 @ (aaa, ba) # zs2) ! length ls = (suba, sepa);\n        xb = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x suba \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (aa, b) (length ls)\n(lp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (aa, b) (length ls)\n(rp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   if length (zs1 @ (aaa, ba) # zs2) < 2 * k\n   then pfa_insert (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (abs_split.T\\<^sub>i\n                       (Node (ls @ (a', sep) # rs) t))>\\<^sub>t\n 3. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        \\<not> length ls < length (zs1 @ (aaa, ba) # zs2)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length (zs1 @ (aaa, ba) # zs2)\n  < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (abs_split.T\\<^sub>i\n                  (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "(* discard wrong branch *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x aa b ti zs1 aaa ba zs2 ab bb suba.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (aaa, ba) # zs2) ! length ls = (suba, x)\\<rbrakk>\n       \\<Longrightarrow> is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                         blist_assn k ls zs1 *\n                         (btree_assn k \\<times>\\<^sub>a id_assn) a\n                          (aaa, ba) *\n                         blist_assn k rs zs2 *\n                         x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         x \\<mapsto>\\<^sub>r\n                         Btnode\n                          (?tsi'155 x aa b ti zs1 aaa ba zs2 ab bb suba)\n                          (?tsi'156 x aa b ti zs1 aaa ba zs2 ab bb suba) *\n                         btree_assn k t\n                          (?tsi'156 x aa b ti zs1 aaa ba zs2 ab bb suba) *\n                         is_pfa (2 * k)\n                          (?tsi'157 x aa b ti zs1 aaa ba zs2 ab bb suba)\n                          (?tsi'155 x aa b ti zs1 aaa ba zs2 ab bb suba) *\n                         blist_assn k (ls @ (a', sep) # rs)\n                          (?tsi'157 x aa b ti zs1 aaa ba zs2 ab bb suba) *\n                         true\n 2. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa xb suba sepa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        length ls < length (zs1 @ (aaa, ba) # zs2);\n        (zs1 @ (aaa, ba) # zs2) ! length ls = (suba, sepa);\n        xb = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x suba \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (aa, b) (length ls)\n(lp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (aa, b) (length ls)\n(rp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   if length (zs1 @ (aaa, ba) # zs2) < 2 * k\n   then pfa_insert (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (abs_split.T\\<^sub>i\n                       (Node (ls @ (a', sep) # rs) t))>\\<^sub>t\n 3. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        \\<not> length ls < length (zs1 @ (aaa, ba) # zs2)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length (zs1 @ (aaa, ba) # zs2)\n  < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (abs_split.T\\<^sub>i\n                  (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "subgoal for p tsil tsin ti zs1 subi sepi zs2 _ _ suba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a'; sep \\<noteq> x;\n     tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs); rrs = a # rs;\n     ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, x)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2)\n                       (tsil, tsin) *\n                      blist_assn k ls zs1 *\n                      (btree_assn k \\<times>\\<^sub>a id_assn) a\n                       (subi, sepi) *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      p \\<mapsto>\\<^sub>r\n                      Btnode\n                       (tsi'__ p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba)\n                       (tsi'a__ p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba) *\n                      btree_assn k t\n                       (tsi'a__ p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba) *\n                      is_pfa (2 * k)\n                       (tsi' p tsil tsin ti zs1 subi sepi zs2 ab_ bb_ suba)\n                       (tsi'__ p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba) *\n                      blist_assn k (ls @ (a', sep) # rs)\n                       (tsi' p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba) *\n                      true", "apply(subgoal_tac \"sepi  = x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a'; sep \\<noteq> x;\n     tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs); rrs = a # rs;\n     ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, x); sepi = x\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2)\n                       (tsil, tsin) *\n                      blist_assn k ls zs1 *\n                      (btree_assn k \\<times>\\<^sub>a id_assn) a\n                       (subi, sepi) *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      p \\<mapsto>\\<^sub>r\n                      Btnode\n                       (tsi'__ p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba)\n                       (tsi'a__ p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba) *\n                      btree_assn k t\n                       (tsi'a__ p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba) *\n                      is_pfa (2 * k)\n                       (tsi' p tsil tsin ti zs1 subi sepi zs2 ab_ bb_ suba)\n                       (tsi'__ p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba) *\n                      blist_assn k (ls @ (a', sep) # rs)\n                       (tsi' p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba) *\n                      true\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a'; sep \\<noteq> x;\n     tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs); rrs = a # rs;\n     ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, x)\\<rbrakk>\n    \\<Longrightarrow> sepi = x", "using list_split Cons a_split"], ["proof (prove)\nusing this:\n  split ts x = (ls, rrs)\n  rrs = a # rs\n  a = (sub, sep)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a'; sep \\<noteq> x;\n     tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs); rrs = a # rs;\n     ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, x); sepi = x\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2)\n                       (tsil, tsin) *\n                      blist_assn k ls zs1 *\n                      (btree_assn k \\<times>\\<^sub>a id_assn) a\n                       (subi, sepi) *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      p \\<mapsto>\\<^sub>r\n                      Btnode\n                       (tsi'__ p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba)\n                       (tsi'a__ p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba) *\n                      btree_assn k t\n                       (tsi'a__ p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba) *\n                      is_pfa (2 * k)\n                       (tsi' p tsil tsin ti zs1 subi sepi zs2 ab_ bb_ suba)\n                       (tsi'__ p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba) *\n                      blist_assn k (ls @ (a', sep) # rs)\n                       (tsi' p tsil tsin ti zs1 subi sepi zs2 ab_ bb_\n                         suba) *\n                      true\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a'; sep \\<noteq> x;\n     tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs); rrs = a # rs;\n     ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, x)\\<rbrakk>\n    \\<Longrightarrow> sepi = x", "apply(auto  dest!:  mod_starD )[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a'; sep \\<noteq> x;\n     tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs); rrs = a # rs;\n     ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, x)\\<rbrakk>\n    \\<Longrightarrow> sepi = x", "apply(auto dest!:  mod_starD list_assn_len)[]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa xb suba sepa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        length ls < length (zs1 @ (aaa, ba) # zs2);\n        (zs1 @ (aaa, ba) # zs2) ! length ls = (suba, sepa);\n        xb = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x suba \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (aa, b) (length ls)\n(lp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (aa, b) (length ls)\n(rp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   if length (zs1 @ (aaa, ba) # zs2) < 2 * k\n   then pfa_insert (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (abs_split.T\\<^sub>i\n                       (Node (ls @ (a', sep) # rs) t))>\\<^sub>t\n 2. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        \\<not> length ls < length (zs1 @ (aaa, ba) # zs2)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length (zs1 @ (aaa, ba) # zs2)\n  < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (abs_split.T\\<^sub>i\n                  (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "(* actual induction branch *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa xb suba sepa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        length ls < length (zs1 @ (aaa, ba) # zs2);\n        (zs1 @ (aaa, ba) # zs2) ! length ls = (suba, sepa);\n        xb = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x suba \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (aa, b) (length ls)\n(lp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (aa, b) (length ls)\n(rp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   if length (zs1 @ (aaa, ba) # zs2) < 2 * k\n   then pfa_insert (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (abs_split.T\\<^sub>i\n                       (Node (ls @ (a', sep) # rs) t))>\\<^sub>t\n 2. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        \\<not> length ls < length (zs1 @ (aaa, ba) # zs2)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length (zs1 @ (aaa, ba) # zs2)\n  < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (abs_split.T\\<^sub>i\n                  (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "subgoal for p tsil tsin ti zs1 subi sepi zs2 _ _ n z suba sepa"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a'; sep \\<noteq> x;\n     tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs); rrs = a # rs;\n     ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = length (zs1 @ (subi, sepi) # zs2);\n     length ls < length (zs1 @ (subi, sepi) # zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2)\n                        (tsil, tsin) *\n                       blist_assn k ls zs1 *\n                       (btree_assn k \\<times>\\<^sub>a id_assn) a\n                        (subi, sepi) *\n                       blist_assn k rs zs2 *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                       btree_assn k t ti *\n                       true> ins k x suba \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  pfa_set (tsil, tsin) (length ls)\n                                   (lp, sepa) \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  pfa_set (tsil, tsin) (length ls)\n                                   (rp, sepa) \\<bind>\n                                  (\\<lambda>_.\nif length (zs1 @ (subi, sepi) # zs2) < 2 * k\nthen pfa_insert (tsil, tsin) (length ls) (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         p := Btnode kvs' ti \\<bind>\n         (\\<lambda>_. return (T\\<^sub>i (Some p))))\nelse pfa_insert_grow (tsil, tsin) (length ls) (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         node\\<^sub>i k kvs'\n          ti))) <btupi_assn k\n                  (abs_split.T\\<^sub>i\n                    (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply (cases a, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        (btree_assn k aa subi * id_assn b sepi) *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2)\n                           (tsil, tsin) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k aa subi * id_assn b sepi) *\n                          blist_assn k rs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          btree_assn k t ti *\n                          true> ins k x suba \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (tsil, tsin) (length ls)\n(lp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some p))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (tsil, tsin) (length ls)\n(rp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   if Suc (length zs1 + length zs2) < 2 * k\n   then pfa_insert (tsil, tsin) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            p := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some p))))\n   else pfa_insert_grow (tsil, tsin) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (abs_split.T\\<^sub>i\n                       (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply(subgoal_tac \"subi = suba\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        (btree_assn k aa suba * id_assn b sepi) *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; a = (aa, b); subi = suba\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                           (tsil, tsin) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k aa suba * id_assn b sepi) *\n                          blist_assn k rs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          btree_assn k t ti *\n                          true> ins k x suba \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (tsil, tsin) (length ls)\n(lp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some p))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (tsil, tsin) (length ls)\n(rp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   if Suc (length zs1 + length zs2) < 2 * k\n   then pfa_insert (tsil, tsin) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            p := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some p))))\n   else pfa_insert_grow (tsil, tsin) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (abs_split.T\\<^sub>i\n                       (Node (ls @ (a', sep) # rs) t))>\\<^sub>t\n 2. \\<And>aa b.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        (btree_assn k aa subi * id_assn b sepi) *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> subi = suba", "using list_split a_split T\\<^sub>i False"], ["proof (prove)\nusing this:\n  split ts x = (ls, rrs)\n  a = (sub, sep)\n  abs_split.ins k x sub = abs_split.T\\<^sub>i a'\n  x \\<noteq> sep\n\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        (btree_assn k aa suba * id_assn b sepi) *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; a = (aa, b); subi = suba\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                           (tsil, tsin) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k aa suba * id_assn b sepi) *\n                          blist_assn k rs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          btree_assn k t ti *\n                          true> ins k x suba \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (tsil, tsin) (length ls)\n(lp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some p))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (tsil, tsin) (length ls)\n(rp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   if Suc (length zs1 + length zs2) < 2 * k\n   then pfa_insert (tsil, tsin) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            p := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some p))))\n   else pfa_insert_grow (tsil, tsin) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (abs_split.T\\<^sub>i\n                       (Node (ls @ (a', sep) # rs) t))>\\<^sub>t\n 2. \\<And>aa b.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        (btree_assn k aa subi * id_assn b sepi) *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> subi = suba", "apply (vcg heap: 2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k aa suba *\n        id_assn b sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; (sub, sep) = (aa, b);\n        subi = suba; a = (aa, b);\n        abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        x \\<noteq> sep\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> x\n 2. \\<And>aa b.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k aa suba *\n        id_assn b sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; (sub, sep) = (aa, b);\n        subi = suba; a = (aa, b);\n        abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        x \\<noteq> sep\\<rbrakk>\n       \\<Longrightarrow> sorted_less (inorder aa)\n 3. \\<And>aa b x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k aa suba *\n        id_assn b sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; (sub, sep) = (aa, b);\n        subi = suba; a = (aa, b);\n        abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        x \\<noteq> sep\\<rbrakk>\n       \\<Longrightarrow> <btupi_assn k (abs_split.ins k x aa) x * true *\n                          (is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                            (tsil, tsin) *\n                           blist_assn k ls zs1 *\n                           id_assn b sepi *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> case x of\n                                  T\\<^sub>i lp \\<Rightarrow>\n                                    pfa_set (tsil, tsin) (length ls)\n                                     (lp, sepa) \\<bind>\n                                    (\\<lambda>_.\n  return (T\\<^sub>i (Some p)))\n                                  | Up\\<^sub>i lp x' rp \\<Rightarrow>\npfa_set (tsil, tsin) (length ls) (rp, sepa) \\<bind>\n(\\<lambda>_.\n    if Suc (length zs1 + length zs2) < 2 * k\n    then pfa_insert (tsil, tsin) (length ls) (lp, x') \\<bind>\n         (\\<lambda>kvs'.\n             p := Btnode kvs' ti \\<bind>\n             (\\<lambda>_. return (T\\<^sub>i (Some p))))\n    else pfa_insert_grow (tsil, tsin) (length ls) (lp, x') \\<bind>\n         (\\<lambda>kvs'.\n             node\\<^sub>i k kvs'\n              ti)) <btupi_assn k\n                     (abs_split.T\\<^sub>i\n                       (Node (ls @ (a', sep) # rs) t))>\\<^sub>t\n 4. \\<And>aa b.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        (btree_assn k aa subi * id_assn b sepi) *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> subi = suba", "apply(auto split!: btupi.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        x \\<noteq> sep\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k a' x1 *\n                          (is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                            (tsil, tsin) *\n                           blist_assn k ls zs1 *\n                           id_assn sep sepi *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti) *\n                          true> pfa_set (tsil, tsin) (length ls)\n                                 (x1, sepa) \\<bind>\n                                (\\<lambda>_.\n                                    return\n                                     (T\\<^sub>i\n (Some\n   p))) <btupi_assn k\n          (abs_split.T\\<^sub>i (Node (ls @ (a', sep) # rs) t))>\\<^sub>t\n 2. \\<And>aa b.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        (btree_assn k aa subi * id_assn b sepi) *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> subi = suba", "(* careful progression for manual value insertion *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        x \\<noteq> sep\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k a' x1 *\n                          (is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                            (tsil, tsin) *\n                           blist_assn k ls zs1 *\n                           id_assn sep sepi *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti) *\n                          true> pfa_set (tsil, tsin) (length ls)\n                                 (x1, sepa) \\<bind>\n                                (\\<lambda>_.\n                                    return\n                                     (T\\<^sub>i\n (Some\n   p))) <btupi_assn k\n          (abs_split.T\\<^sub>i (Node (ls @ (a', sep) # rs) t))>\\<^sub>t\n 2. \\<And>aa b.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        (btree_assn k aa subi * id_assn b sepi) *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> subi = suba", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> length ls < length (zs1 @ (suba, sepi) # zs2)\n 2. \\<And>x1 x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        x \\<noteq> sep\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k)\n                           ((zs1 @ (suba, sepi) # zs2)\n                            [length ls := (x1, sepa)])\n                           x *\n                          \\<up> (x = (tsil, tsin)) *\n                          (btree_assn k a' x1 * blist_assn k ls zs1 *\n                           id_assn sep sepi *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> return\n                                   (T\\<^sub>i\n                                     (Some\n p)) <btupi_assn k\n       (abs_split.T\\<^sub>i (Node (ls @ (a', sep) # rs) t))>\\<^sub>t\n 3. \\<And>aa b.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        (btree_assn k aa subi * id_assn b sepi) *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> subi = suba", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        x \\<noteq> sep\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k)\n                           ((zs1 @ (suba, sepi) # zs2)\n                            [length ls := (x1, sepa)])\n                           x *\n                          \\<up> (x = (tsil, tsin)) *\n                          (btree_assn k a' x1 * blist_assn k ls zs1 *\n                           id_assn sep sepi *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> return\n                                   (T\\<^sub>i\n                                     (Some\n p)) <btupi_assn k\n       (abs_split.T\\<^sub>i (Node (ls @ (a', sep) # rs) t))>\\<^sub>t\n 2. \\<And>aa b.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        (btree_assn k aa subi * id_assn b sepi) *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> subi = suba", "apply vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x xaa.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n        x = (tsil, tsin)\\<rbrakk>\n       \\<Longrightarrow> is_pfa (2 * k)\n                          ((zs1 @ (suba, sepi) # zs2)\n                           [length ls := (x1, sepa)])\n                          (tsil, tsin) *\n                         btree_assn k a' x1 *\n                         blist_assn k ls zs1 *\n                         id_assn sep sepi *\n                         blist_assn k rs zs2 *\n                         p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                         btree_assn k t ti *\n                         true *\n                         \\<up>\n                          (xaa =\n                           T\\<^sub>i (Some p)) \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.T\\<^sub>i\n                            (Node (ls @ (a', sep) # rs) t))\n                          xaa *\n                         true\n 2. \\<And>aa b.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        (btree_assn k aa subi * id_assn b sepi) *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> subi = suba", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x xaa.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n        x = (tsil, tsin)\\<rbrakk>\n       \\<Longrightarrow> xaa = T\\<^sub>i (Some p) \\<longrightarrow>\n                         (is_pfa (2 * k)\n                           ((zs1 @ (suba, sepi) # zs2)\n                            [length ls := (x1, sepa)])\n                           (tsil, tsin) *\n                          btree_assn k a' x1 *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepi *\n                          blist_assn k rs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          btree_assn k t ti *\n                          true \\<Longrightarrow>\\<^sub>A\n                          \\<exists>\\<^sub>Atsi ti tsi'.\n                             p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                             btree_assn k t ti *\n                             is_pfa (2 * k) tsi' tsi *\n                             blist_assn k (ls @ (a', sep) # rs) tsi' *\n                             true)\n 2. \\<And>aa b.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        (btree_assn k aa subi * id_assn b sepi) *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> subi = suba", "subgoal for a'i q r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n     q = (tsil, tsin)\\<rbrakk>\n    \\<Longrightarrow> r = T\\<^sub>i (Some p) \\<longrightarrow>\n                      (is_pfa (2 * k)\n                        ((zs1 @ (suba, sepi) # zs2)\n                         [length ls := (a'i, sepa)])\n                        (tsil, tsin) *\n                       btree_assn k a' a'i *\n                       blist_assn k ls zs1 *\n                       id_assn sep sepi *\n                       blist_assn k rs zs2 *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                       btree_assn k t ti *\n                       true \\<Longrightarrow>\\<^sub>A\n                       \\<exists>\\<^sub>Atsi ti tsi'.\n                          p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) tsi' tsi *\n                          blist_assn k (ls @ (a', sep) # rs) tsi' *\n                          true)", "apply(rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n     q = (tsil, tsin); r = T\\<^sub>i (Some p)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k)\n                       ((zs1 @ (suba, sepi) # zs2)\n                        [length ls := (a'i, sepa)])\n                       (tsil, tsin) *\n                      btree_assn k a' a'i *\n                      blist_assn k ls zs1 *\n                      id_assn sep sepi *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsi ti tsi'.\n                         p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                         btree_assn k t ti *\n                         is_pfa (2 * k) tsi' tsi *\n                         blist_assn k (ls @ (a', sep) # rs) tsi' *\n                         true", "apply(simp add: list_assn_append_Cons_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n     q = (tsil, tsin); r = T\\<^sub>i (Some p)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k)\n                       ((zs1 @ (suba, sepi) # zs2)\n                        [length ls := (a'i, sepa)])\n                       (tsil, tsin) *\n                      btree_assn k a' a'i *\n                      blist_assn k ls zs1 *\n                      id_assn sep sepi *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsi ti tsi' zs1 z zs2.\n                         p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                         btree_assn k t ti *\n                         is_pfa (2 * k) tsi' tsi *\n                         (blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) (a', sep)\n                           z *\n                          blist_assn k rs zs2) *\n                         true *\n                         \\<up> (zs1 @ z # zs2 = tsi')", "apply(rule ent_ex_postI[where x=\"(tsil,tsin)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n     q = (tsil, tsin); r = T\\<^sub>i (Some p)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k)\n                       ((zs1 @ (suba, sepi) # zs2)\n                        [length ls := (a'i, sepa)])\n                       (tsil, tsin) *\n                      btree_assn k a' a'i *\n                      blist_assn k ls zs1 *\n                      id_assn sep sepi *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Ati tsi' zs1 z zs2.\n                         p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                         btree_assn k t ti *\n                         is_pfa (2 * k) tsi' (tsil, tsin) *\n                         (blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) (a', sep)\n                           z *\n                          blist_assn k rs zs2) *\n                         true *\n                         \\<up> (zs1 @ z # zs2 = tsi')", "apply(rule ent_ex_postI[where x=\"ti\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n     q = (tsil, tsin); r = T\\<^sub>i (Some p)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k)\n                       ((zs1 @ (suba, sepi) # zs2)\n                        [length ls := (a'i, sepa)])\n                       (tsil, tsin) *\n                      btree_assn k a' a'i *\n                      blist_assn k ls zs1 *\n                      id_assn sep sepi *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsi' zs1 z zs2.\n                         p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                         btree_assn k t ti *\n                         is_pfa (2 * k) tsi' (tsil, tsin) *\n                         (blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) (a', sep)\n                           z *\n                          blist_assn k rs zs2) *\n                         true *\n                         \\<up> (zs1 @ z # zs2 = tsi')", "apply(rule ent_ex_postI[where x=\"(zs1 @ (a'i, sepi) # zs2)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n     q = (tsil, tsin); r = T\\<^sub>i (Some p)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k)\n                       ((zs1 @ (suba, sepi) # zs2)\n                        [length ls := (a'i, sepa)])\n                       (tsil, tsin) *\n                      btree_assn k a' a'i *\n                      blist_assn k ls zs1 *\n                      id_assn sep sepi *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Azs1a z zs2a.\n                         p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                         btree_assn k t ti *\n                         is_pfa (2 * k) (zs1 @ (a'i, sepi) # zs2)\n                          (tsil, tsin) *\n                         (blist_assn k ls zs1a *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) (a', sep)\n                           z *\n                          blist_assn k rs zs2a) *\n                         true *\n                         \\<up> (zs1a @ z # zs2a = zs1 @ (a'i, sepi) # zs2)", "apply(rule ent_ex_postI[where x=\"zs1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n     q = (tsil, tsin); r = T\\<^sub>i (Some p)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k)\n                       ((zs1 @ (suba, sepi) # zs2)\n                        [length ls := (a'i, sepa)])\n                       (tsil, tsin) *\n                      btree_assn k a' a'i *\n                      blist_assn k ls zs1 *\n                      id_assn sep sepi *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Az zs2a.\n                         p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                         btree_assn k t ti *\n                         is_pfa (2 * k) (zs1 @ (a'i, sepi) # zs2)\n                          (tsil, tsin) *\n                         (blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) (a', sep)\n                           z *\n                          blist_assn k rs zs2a) *\n                         true *\n                         \\<up> (zs1 @ z # zs2a = zs1 @ (a'i, sepi) # zs2)", "apply(rule ent_ex_postI[where x=\"(a'i,sep)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n     q = (tsil, tsin); r = T\\<^sub>i (Some p)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k)\n                       ((zs1 @ (suba, sepi) # zs2)\n                        [length ls := (a'i, sepa)])\n                       (tsil, tsin) *\n                      btree_assn k a' a'i *\n                      blist_assn k ls zs1 *\n                      id_assn sep sepi *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Azs2a.\n                         p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                         btree_assn k t ti *\n                         is_pfa (2 * k) (zs1 @ (a'i, sepi) # zs2)\n                          (tsil, tsin) *\n                         (blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) (a', sep)\n                           (a'i, sep) *\n                          blist_assn k rs zs2a) *\n                         true *\n                         \\<up>\n                          (zs1 @ (a'i, sep) # zs2a =\n                           zs1 @ (a'i, sepi) # zs2)", "apply(rule ent_ex_postI[where x=\"zs2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n     q = (tsil, tsin); r = T\\<^sub>i (Some p)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k)\n                       ((zs1 @ (suba, sepi) # zs2)\n                        [length ls := (a'i, sepa)])\n                       (tsil, tsin) *\n                      btree_assn k a' a'i *\n                      blist_assn k ls zs1 *\n                      id_assn sep sepi *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      is_pfa (2 * k) (zs1 @ (a'i, sepi) # zs2)\n                       (tsil, tsin) *\n                      (blist_assn k ls zs1 *\n                       (btree_assn k \\<times>\\<^sub>a id_assn) (a', sep)\n                        (a'i, sep) *\n                       blist_assn k rs zs2) *\n                      true *\n                      \\<up>\n                       (zs1 @ (a'i, sep) # zs2 = zs1 @ (a'i, sepi) # zs2)", "apply sep_auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n        q = (tsil, tsin); r = T\\<^sub>i (Some p);\n        (aa, b) \\<Turnstile>\n        is_pfa (2 * k)\n         ((zs1 @ (suba, sepi) # zs2)[length ls := (a'i, sepa)])\n         (tsil, tsin) *\n        btree_assn k a' a'i *\n        blist_assn k ls zs1 *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true\\<rbrakk>\n       \\<Longrightarrow> sep = sepi\n 2. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n     q = (tsil, tsin); r = T\\<^sub>i (Some p)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k)\n                       ((zs1 @ (suba, sepi) # zs2)\n                        [length ls := (a'i, sepa)])\n                       (tsil, tsin) *\n                      btree_assn k a' a'i *\n                      blist_assn k ls zs1 *\n                      id_assn sep sepi *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      is_pfa (2 * k) (zs1 @ (a'i, sepi) # zs2)\n                       (tsil, tsin) *\n                      (blist_assn k ls zs1 *\n                       (btree_assn k a' a'i * id_assn sep sep) *\n                       blist_assn k rs zs2) *\n                      true", "apply (simp add: pure_app_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     rrs = (sub, sep) # rs; ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     abs_split.ins k x sub = abs_split.T\\<^sub>i a'; x \\<noteq> sep;\n     q = (tsil, tsin); r = T\\<^sub>i (Some p)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k)\n                       ((zs1 @ (suba, sepi) # zs2)\n                        [length ls := (a'i, sepa)])\n                       (tsil, tsin) *\n                      btree_assn k a' a'i *\n                      blist_assn k ls zs1 *\n                      id_assn sep sepi *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      is_pfa (2 * k) (zs1 @ (a'i, sepi) # zs2)\n                       (tsil, tsin) *\n                      (blist_assn k ls zs1 *\n                       (btree_assn k a' a'i * id_assn sep sep) *\n                       blist_assn k rs zs2) *\n                      true", "apply(sep_auto dest!:  mod_starD list_assn_len)[]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; tia__ = Some p;\n        split (ls @ (aa, b) # rs) x = (ls, (aa, b) # rs);\n        rrs = (aa, b) # rs; ts = ls @ (aa, b) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        (btree_assn k aa subi * id_assn b sepi) *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> subi = suba", "apply (metis list_assn_aux_ineq_len Pair_inject list_assn_len nth_append_length star_false_left star_false_right)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a';\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        \\<not> length ls < length (zs1 @ (aaa, ba) # zs2)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length (zs1 @ (aaa, ba) # zs2)\n  < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (abs_split.T\\<^sub>i\n                  (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "subgoal for p tsil tsin ti zs1 subi sepi zs2 _ _ suba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.T\\<^sub>i a'; sep \\<noteq> x;\n     tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs); rrs = a # rs;\n     ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     suba = length (zs1 @ (subi, sepi) # zs2);\n     \\<not> length ls < length (zs1 @ (subi, sepi) # zs2)\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2)\n                        (tsil, tsin) *\n                       blist_assn k ls zs1 *\n                       (btree_assn k \\<times>\\<^sub>a id_assn) a\n                        (subi, sepi) *\n                       blist_assn k rs zs2 *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                       btree_assn k t ti *\n                       true> ins k x ti \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  if length (zs1 @ (subi, sepi) # zs2)\n                                     < 2 * k\n                                  then pfa_append (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     p := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                  else pfa_append_grow' (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     node\\<^sub>i k kvs'\n      rp)) <btupi_assn k\n             (abs_split.T\\<^sub>i (Node (ls @ (a', sep) # rs) t))>\\<^sub>t", "apply(auto dest!:  mod_starD list_assn_len)[]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "case (Up\\<^sub>i l w r)"], ["proof (state)\nthis:\n  abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> ins k x\n                                ti <btupi_assn k\n                                     (abs_split.ins k x\n (Node ts t))>\\<^sub>t", "then"], ["proof (chain)\npicking this:\n  abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r", "show ?thesis"], ["proof (prove)\nusing this:\n  abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r\n\ngoal (1 subgoal):\n 1. <btree_assn k (Node ts t)\n      ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t", "apply(auto simp add: Cons list_split a_split False)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep = x\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.node\\<^sub>i k\n                                    (ls @ (l, w) # (r, sep) # rs)\n                                    t)>\\<^sub>t", "using False"], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep = x\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.T\\<^sub>i (Node ts t))>\\<^sub>t\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.node\\<^sub>i k\n                                    (ls @ (l, w) # (r, sep) # rs)\n                                    t)>\\<^sub>t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> ins k x\n                             ti <btupi_assn k\n                                  (abs_split.node\\<^sub>i k\n                                    (ls @ (l, w) # (r, sep) # rs)\n                                    t)>\\<^sub>t", "apply(subst ins.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <btree_assn k (Node ts t)\n                        ti> case ti of\n                            None \\<Rightarrow>\n                              return (Up\\<^sub>i None x None)\n                            | Some ap \\<Rightarrow>\n                                !ap \\<bind>\n                                (\\<lambda>a.\n                                    imp_split (kvs a) x \\<bind>\n                                    (\\<lambda>i.\n  pfa_length (kvs a) \\<bind>\n  (\\<lambda>tsl.\n      if i < tsl\n      then pfa_get (kvs a) i \\<bind>\n           (\\<lambda>s.\n               let (sub, sep) = s\n               in if sep = x then return (T\\<^sub>i ti)\n                  else ins k x sub \\<bind>\n                       case_btupi\n                        (\\<lambda>lp.\n                            pfa_set (kvs a) i (lp, sep) \\<bind>\n                            (\\<lambda>_. return (T\\<^sub>i ti)))\n                        (\\<lambda>lp x' rp.\n                            pfa_set (kvs a) i (rp, sep) \\<bind>\n                            (\\<lambda>_.\n                                if tsl < 2 * k\n                                then pfa_insert (kvs a) i (lp, x') \\<bind>\n                                     (\\<lambda>kvs'.\n   ap := Btnode kvs' (BTree_Imp.last a) \\<bind>\n   (\\<lambda>_. return (T\\<^sub>i ti)))\n                                else pfa_insert_grow (kvs a) i\n(lp, x') \\<bind>\n                                     (\\<lambda>kvs'.\n   node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n      else ins k x (BTree_Imp.last a) \\<bind>\n           case_btupi\n            (\\<lambda>lp.\n                ap := Btnode (kvs a) lp \\<bind>\n                (\\<lambda>_. return (T\\<^sub>i ti)))\n            (\\<lambda>lp x' rp.\n                if tsl < 2 * k\n                then pfa_append (kvs a) (lp, x') \\<bind>\n                     (\\<lambda>kvs'.\n                         ap := Btnode kvs' rp \\<bind>\n                         (\\<lambda>_. return (T\\<^sub>i ti)))\n                else pfa_append_grow' (kvs a) (lp, x') \\<bind>\n                     (\\<lambda>kvs'.\n                         node\\<^sub>i k kvs'\n                          rp))))) <btupi_assn k\n                                    (abs_split.node\\<^sub>i k\n(ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = None\\<rbrakk>\n       \\<Longrightarrow> btree_assn k (Node ts t) None *\n                         \\<up>\n                          (x =\n                           Up\\<^sub>i None x None) \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          x *\n                         true\n 2. \\<And>x.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k (Node ts t)\n                           ti> !x \\<bind>\n                               (\\<lambda>a.\n                                   imp_split (kvs a) x \\<bind>\n                                   (\\<lambda>i.\n pfa_length (kvs a) \\<bind>\n (\\<lambda>tsl.\n     if i < tsl\n     then pfa_get (kvs a) i \\<bind>\n          (\\<lambda>s.\n              case s of\n              (sub, sep) \\<Rightarrow>\n                if sep = x then return (T\\<^sub>i ti)\n                else ins k x sub \\<bind>\n                     case_btupi\n                      (\\<lambda>lp.\n                          pfa_set (kvs a) i (lp, sep) \\<bind>\n                          (\\<lambda>_. return (T\\<^sub>i ti)))\n                      (\\<lambda>lp x' rp.\n                          pfa_set (kvs a) i (rp, sep) \\<bind>\n                          (\\<lambda>_.\n                              if tsl < 2 * k\n                              then pfa_insert (kvs a) i (lp, x') \\<bind>\n                                   (\\<lambda>kvs'.\n x := Btnode kvs' (BTree_Imp.last a) \\<bind>\n (\\<lambda>_. return (T\\<^sub>i ti)))\n                              else pfa_insert_grow (kvs a) i\n                                    (lp, x') \\<bind>\n                                   (\\<lambda>kvs'.\n node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n     else ins k x (BTree_Imp.last a) \\<bind>\n          case_btupi\n           (\\<lambda>lp.\n               x := Btnode (kvs a) lp \\<bind>\n               (\\<lambda>_. return (T\\<^sub>i ti)))\n           (\\<lambda>lp x' rp.\n               if tsl < 2 * k\n               then pfa_append (kvs a) (lp, x') \\<bind>\n                    (\\<lambda>kvs'.\n                        x := Btnode kvs' rp \\<bind>\n                        (\\<lambda>_. return (T\\<^sub>i ti)))\n               else pfa_append_grow' (kvs a) (lp, x') \\<bind>\n                    (\\<lambda>kvs'.\n                        node\\<^sub>i k kvs'\n                         rp))))) <btupi_assn k\n                                   (abs_split.node\\<^sub>i k\n                                     (ls @ (l, w) # (r, sep) # rs)\n                                     t)>\\<^sub>t", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Atsi ti tsi'.\n                             x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                             btree_assn k t ti *\n                             is_pfa (2 * k) tsi' tsi *\n                             blist_assn k ts\n                              tsi'> !x \\<bind>\n                                    (\\<lambda>a.\n  imp_split (kvs a) x \\<bind>\n  (\\<lambda>i.\n      pfa_length (kvs a) \\<bind>\n      (\\<lambda>tsl.\n          if i < tsl\n          then pfa_get (kvs a) i \\<bind>\n               (\\<lambda>s.\n                   case s of\n                   (sub, sep) \\<Rightarrow>\n                     if sep = x then return (T\\<^sub>i (Some x))\n                     else ins k x sub \\<bind>\n                          case_btupi\n                           (\\<lambda>lp.\n                               pfa_set (kvs a) i (lp, sep) \\<bind>\n                               (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                           (\\<lambda>lp x' rp.\n                               pfa_set (kvs a) i (rp, sep) \\<bind>\n                               (\\<lambda>_.\n                                   if tsl < 2 * k\n                                   then pfa_insert (kvs a) i\n   (lp, x') \\<bind>\n  (\\<lambda>kvs'.\n      x := Btnode kvs' (BTree_Imp.last a) \\<bind>\n      (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                   else pfa_insert_grow (kvs a) i\n   (lp, x') \\<bind>\n  (\\<lambda>kvs'. node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n          else ins k x (BTree_Imp.last a) \\<bind>\n               case_btupi\n                (\\<lambda>lp.\n                    x := Btnode (kvs a) lp \\<bind>\n                    (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                (\\<lambda>lp x' rp.\n                    if tsl < 2 * k\n                    then pfa_append (kvs a) (lp, x') \\<bind>\n                         (\\<lambda>kvs'.\n                             x := Btnode kvs' rp \\<bind>\n                             (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                    else pfa_append_grow' (kvs a) (lp, x') \\<bind>\n                         (\\<lambda>kvs'.\n                             node\\<^sub>i k kvs'\n                              rp))))) <btupi_assn k\n  (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply(rule norm_pre_ex_rule)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi'.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x\\<rbrakk>\n       \\<Longrightarrow> <x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) tsi' tsi *\n                          blist_assn k ts\n                           tsi'> !x \\<bind>\n                                 (\\<lambda>a.\n                                     imp_split (kvs a) x \\<bind>\n                                     (\\<lambda>i.\n   pfa_length (kvs a) \\<bind>\n   (\\<lambda>tsl.\n       if i < tsl\n       then pfa_get (kvs a) i \\<bind>\n            (\\<lambda>s.\n                case s of\n                (sub, sep) \\<Rightarrow>\n                  if sep = x then return (T\\<^sub>i (Some x))\n                  else ins k x sub \\<bind>\n                       case_btupi\n                        (\\<lambda>lp.\n                            pfa_set (kvs a) i (lp, sep) \\<bind>\n                            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                        (\\<lambda>lp x' rp.\n                            pfa_set (kvs a) i (rp, sep) \\<bind>\n                            (\\<lambda>_.\n                                if tsl < 2 * k\n                                then pfa_insert (kvs a) i (lp, x') \\<bind>\n                                     (\\<lambda>kvs'.\n   x := Btnode kvs' (BTree_Imp.last a) \\<bind>\n   (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                else pfa_insert_grow (kvs a) i\n(lp, x') \\<bind>\n                                     (\\<lambda>kvs'.\n   node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n       else ins k x (BTree_Imp.last a) \\<bind>\n            case_btupi\n             (\\<lambda>lp.\n                 x := Btnode (kvs a) lp \\<bind>\n                 (\\<lambda>_. return (T\\<^sub>i (Some x))))\n             (\\<lambda>lp x' rp.\n                 if tsl < 2 * k\n                 then pfa_append (kvs a) (lp, x') \\<bind>\n                      (\\<lambda>kvs'.\n                          x := Btnode kvs' rp \\<bind>\n                          (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                 else pfa_append_grow' (kvs a) (lp, x') \\<bind>\n                      (\\<lambda>kvs'.\n                          node\\<^sub>i k kvs'\n                           rp))))) <btupi_assn k\n                                     (abs_split.node\\<^sub>i k\n (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "(* at this point, we want to introduce the split, and after that tease the\n  hoare triple assumptions out of the bracket, s.t. we don't split twice *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi'.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x\\<rbrakk>\n       \\<Longrightarrow> <x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) tsi' tsi *\n                          blist_assn k ts\n                           tsi'> !x \\<bind>\n                                 (\\<lambda>a.\n                                     imp_split (kvs a) x \\<bind>\n                                     (\\<lambda>i.\n   pfa_length (kvs a) \\<bind>\n   (\\<lambda>tsl.\n       if i < tsl\n       then pfa_get (kvs a) i \\<bind>\n            (\\<lambda>s.\n                case s of\n                (sub, sep) \\<Rightarrow>\n                  if sep = x then return (T\\<^sub>i (Some x))\n                  else ins k x sub \\<bind>\n                       case_btupi\n                        (\\<lambda>lp.\n                            pfa_set (kvs a) i (lp, sep) \\<bind>\n                            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                        (\\<lambda>lp x' rp.\n                            pfa_set (kvs a) i (rp, sep) \\<bind>\n                            (\\<lambda>_.\n                                if tsl < 2 * k\n                                then pfa_insert (kvs a) i (lp, x') \\<bind>\n                                     (\\<lambda>kvs'.\n   x := Btnode kvs' (BTree_Imp.last a) \\<bind>\n   (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                else pfa_insert_grow (kvs a) i\n(lp, x') \\<bind>\n                                     (\\<lambda>kvs'.\n   node\\<^sub>i k kvs' (BTree_Imp.last a)))))\n       else ins k x (BTree_Imp.last a) \\<bind>\n            case_btupi\n             (\\<lambda>lp.\n                 x := Btnode (kvs a) lp \\<bind>\n                 (\\<lambda>_. return (T\\<^sub>i (Some x))))\n             (\\<lambda>lp x' rp.\n                 if tsl < 2 * k\n                 then pfa_append (kvs a) (lp, x') \\<bind>\n                      (\\<lambda>kvs'.\n                          x := Btnode kvs' rp \\<bind>\n                          (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                 else pfa_append_grow' (kvs a) (lp, x') \\<bind>\n                      (\\<lambda>kvs'.\n                          node\\<^sub>i k kvs'\n                           rp))))) <btupi_assn k\n                                     (abs_split.node\\<^sub>i k\n (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x tsi ti tsi' xaa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti\\<rbrakk>\n       \\<Longrightarrow> <x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                          btree_assn k t ti *\n                          is_pfa (2 * k) tsi' tsi *\n                          blist_assn k ts tsi'>\n                         imp_split tsi x\n                         <?R33 x tsi ti tsi' (Btnode tsi ti)>\n 2. \\<And>x tsi ti tsi' xaa xb.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti\\<rbrakk>\n       \\<Longrightarrow> <?R33 x tsi ti tsi' xaa\n                           xb> pfa_length tsi \\<bind>\n                               (\\<lambda>tsl.\n                                   if xb < tsl\n                                   then pfa_get tsi xb \\<bind>\n  (\\<lambda>(sub, sep).\n      if sep = x then return (T\\<^sub>i (Some x))\n      else ins k x sub \\<bind>\n           case_btupi\n            (\\<lambda>lp.\n                pfa_set tsi xb (lp, sep) \\<bind>\n                (\\<lambda>_. return (T\\<^sub>i (Some x))))\n            (\\<lambda>lp x' rp.\n                pfa_set tsi xb (rp, sep) \\<bind>\n                (\\<lambda>_.\n                    if tsl < 2 * k\n                    then pfa_insert tsi xb (lp, x') \\<bind>\n                         (\\<lambda>kvs'.\n                             x := Btnode kvs' ti \\<bind>\n                             (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                    else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                         (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n                                   else ins k x ti \\<bind>\n  case_btupi\n   (\\<lambda>lp.\n       x := Btnode tsi lp \\<bind> (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   (\\<lambda>lp x' rp.\n       if tsl < 2 * k\n       then pfa_append tsi (lp, x') \\<bind>\n            (\\<lambda>kvs'.\n                x := Btnode kvs' rp \\<bind>\n                (\\<lambda>_. return (T\\<^sub>i (Some x))))\n       else pfa_append_grow' tsi (lp, x') \\<bind>\n            (\\<lambda>kvs'.\n                node\\<^sub>i k kvs'\n                 rp))) <btupi_assn k\n                         (abs_split.node\\<^sub>i k\n                           (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi' xaa xb.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' tsi * blist_assn k ts tsi' *\n                          \\<up> (split_relation ts (split ts x) xb) *\n                          true *\n                          (x \\<mapsto>\\<^sub>r xaa *\n                           btree_assn k t\n                            ti)> pfa_length tsi \\<bind>\n                                 (\\<lambda>tsl.\n                                     if xb < tsl\n                                     then pfa_get tsi xb \\<bind>\n    (\\<lambda>(sub, sep).\n        if sep = x then return (T\\<^sub>i (Some x))\n        else ins k x sub \\<bind>\n             case_btupi\n              (\\<lambda>lp.\n                  pfa_set tsi xb (lp, sep) \\<bind>\n                  (\\<lambda>_. return (T\\<^sub>i (Some x))))\n              (\\<lambda>lp x' rp.\n                  pfa_set tsi xb (rp, sep) \\<bind>\n                  (\\<lambda>_.\n                      if tsl < 2 * k\n                      then pfa_insert tsi xb (lp, x') \\<bind>\n                           (\\<lambda>kvs'.\n                               x := Btnode kvs' ti \\<bind>\n                               (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                      else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                           (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n                                     else ins k x ti \\<bind>\n    case_btupi\n     (\\<lambda>lp.\n         x := Btnode tsi lp \\<bind>\n         (\\<lambda>_. return (T\\<^sub>i (Some x))))\n     (\\<lambda>lp x' rp.\n         if tsl < 2 * k\n         then pfa_append tsi (lp, x') \\<bind>\n              (\\<lambda>kvs'.\n                  x := Btnode kvs' rp \\<bind>\n                  (\\<lambda>_. return (T\\<^sub>i (Some x))))\n         else pfa_append_grow' tsi (lp, x') \\<bind>\n              (\\<lambda>kvs'.\n                  node\\<^sub>i k kvs'\n                   rp))) <btupi_assn k\n                           (abs_split.node\\<^sub>i k\n                             (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "using list_split Cons"], ["proof (prove)\nusing this:\n  split ts x = (ls, rrs)\n  rrs = a # rs\n\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi' xaa xb.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' tsi * blist_assn k ts tsi' *\n                          \\<up> (split_relation ts (split ts x) xb) *\n                          true *\n                          (x \\<mapsto>\\<^sub>r xaa *\n                           btree_assn k t\n                            ti)> pfa_length tsi \\<bind>\n                                 (\\<lambda>tsl.\n                                     if xb < tsl\n                                     then pfa_get tsi xb \\<bind>\n    (\\<lambda>(sub, sep).\n        if sep = x then return (T\\<^sub>i (Some x))\n        else ins k x sub \\<bind>\n             case_btupi\n              (\\<lambda>lp.\n                  pfa_set tsi xb (lp, sep) \\<bind>\n                  (\\<lambda>_. return (T\\<^sub>i (Some x))))\n              (\\<lambda>lp x' rp.\n                  pfa_set tsi xb (rp, sep) \\<bind>\n                  (\\<lambda>_.\n                      if tsl < 2 * k\n                      then pfa_insert tsi xb (lp, x') \\<bind>\n                           (\\<lambda>kvs'.\n                               x := Btnode kvs' ti \\<bind>\n                               (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                      else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                           (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n                                     else ins k x ti \\<bind>\n    case_btupi\n     (\\<lambda>lp.\n         x := Btnode tsi lp \\<bind>\n         (\\<lambda>_. return (T\\<^sub>i (Some x))))\n     (\\<lambda>lp x' rp.\n         if tsl < 2 * k\n         then pfa_append tsi (lp, x') \\<bind>\n              (\\<lambda>kvs'.\n                  x := Btnode kvs' rp \\<bind>\n                  (\\<lambda>_. return (T\\<^sub>i (Some x))))\n         else pfa_append_grow' tsi (lp, x') \\<bind>\n              (\\<lambda>kvs'.\n                  node\\<^sub>i k kvs'\n                   rp))) <btupi_assn k\n                           (abs_split.node\\<^sub>i k\n                             (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply(simp add: split_relation_alt list_assn_append_Cons_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi' xaa xb.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti;\n        split ts x = (ls, a # rs); rrs = a # rs\\<rbrakk>\n       \\<Longrightarrow> ts = ls @ a # rs \\<and>\n                         xb = length ls \\<longrightarrow>\n                         <\\<exists>\\<^sub>Azs1 z zs2.\n                             is_pfa (2 * k) tsi' tsi *\n                             (blist_assn k ls zs1 *\n                              (btree_assn k \\<times>\\<^sub>a id_assn) a z *\n                              blist_assn k rs zs2) *\n                             (x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                              btree_assn k t ti) *\n                             true *\n                             \\<up>\n                              (zs1 @ z # zs2 =\n                               tsi')> pfa_length tsi \\<bind>\n(\\<lambda>tsl.\n    if length ls < tsl\n    then pfa_get tsi xb \\<bind>\n         (\\<lambda>(sub, sep).\n             if sep = x then return (T\\<^sub>i (Some x))\n             else ins k x sub \\<bind>\n                  case_btupi\n                   (\\<lambda>lp.\n                       pfa_set tsi xb (lp, sep) \\<bind>\n                       (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                   (\\<lambda>lp x' rp.\n                       pfa_set tsi xb (rp, sep) \\<bind>\n                       (\\<lambda>_.\n                           if tsl < 2 * k\n                           then pfa_insert tsi xb (lp, x') \\<bind>\n                                (\\<lambda>kvs'.\n                                    x := Btnode kvs' ti \\<bind>\n                                    (\\<lambda>_.\n  return (T\\<^sub>i (Some x))))\n                           else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                                (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n    else ins k x ti \\<bind>\n         case_btupi\n          (\\<lambda>lp.\n              x := Btnode tsi lp \\<bind>\n              (\\<lambda>_. return (T\\<^sub>i (Some x))))\n          (\\<lambda>lp x' rp.\n              if tsl < 2 * k\n              then pfa_append tsi (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       x := Btnode kvs' rp \\<bind>\n                       (\\<lambda>_. return (T\\<^sub>i (Some x))))\n              else pfa_append_grow' tsi (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       node\\<^sub>i k kvs'\n                        rp))) <btupi_assn k\n                                (abs_split.node\\<^sub>i k\n                                  (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi' xaa xb.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti;\n        split ts x = (ls, a # rs); rrs = a # rs;\n        ts = ls @ a # rs \\<and> xb = length ls\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Azs1 z zs2.\n                             is_pfa (2 * k) tsi' tsi *\n                             (blist_assn k ls zs1 *\n                              (btree_assn k \\<times>\\<^sub>a id_assn) a z *\n                              blist_assn k rs zs2) *\n                             (x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                              btree_assn k t ti) *\n                             true *\n                             \\<up>\n                              (zs1 @ z # zs2 =\n                               tsi')> pfa_length tsi \\<bind>\n(\\<lambda>tsl.\n    if length ls < tsl\n    then pfa_get tsi xb \\<bind>\n         (\\<lambda>(sub, sep).\n             if sep = x then return (T\\<^sub>i (Some x))\n             else ins k x sub \\<bind>\n                  case_btupi\n                   (\\<lambda>lp.\n                       pfa_set tsi xb (lp, sep) \\<bind>\n                       (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                   (\\<lambda>lp x' rp.\n                       pfa_set tsi xb (rp, sep) \\<bind>\n                       (\\<lambda>_.\n                           if tsl < 2 * k\n                           then pfa_insert tsi xb (lp, x') \\<bind>\n                                (\\<lambda>kvs'.\n                                    x := Btnode kvs' ti \\<bind>\n                                    (\\<lambda>_.\n  return (T\\<^sub>i (Some x))))\n                           else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                                (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n    else ins k x ti \\<bind>\n         case_btupi\n          (\\<lambda>lp.\n              x := Btnode tsi lp \\<bind>\n              (\\<lambda>_. return (T\\<^sub>i (Some x))))\n          (\\<lambda>lp x' rp.\n              if tsl < 2 * k\n              then pfa_append tsi (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       x := Btnode kvs' rp \\<bind>\n                       (\\<lambda>_. return (T\\<^sub>i (Some x))))\n              else pfa_append_grow' tsi (lp, x') \\<bind>\n                   (\\<lambda>kvs'.\n                       node\\<^sub>i k kvs'\n                        rp))) <btupi_assn k\n                                (abs_split.node\\<^sub>i k\n                                  (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply(rule norm_pre_ex_rule)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi' xaa xb zs1 z zs2.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti;\n        split ts x = (ls, a # rs); rrs = a # rs;\n        ts = ls @ a # rs \\<and> xb = length ls\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' tsi *\n                          (blist_assn k ls zs1 *\n                           (btree_assn k \\<times>\\<^sub>a id_assn) a z *\n                           blist_assn k rs zs2) *\n                          (x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                           btree_assn k t ti) *\n                          true *\n                          \\<up>\n                           (zs1 @ z # zs2 =\n                            tsi')> pfa_length tsi \\<bind>\n                                   (\\<lambda>tsl.\n if length ls < tsl\n then pfa_get tsi xb \\<bind>\n      (\\<lambda>(sub, sep).\n          if sep = x then return (T\\<^sub>i (Some x))\n          else ins k x sub \\<bind>\n               case_btupi\n                (\\<lambda>lp.\n                    pfa_set tsi xb (lp, sep) \\<bind>\n                    (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                (\\<lambda>lp x' rp.\n                    pfa_set tsi xb (rp, sep) \\<bind>\n                    (\\<lambda>_.\n                        if tsl < 2 * k\n                        then pfa_insert tsi xb (lp, x') \\<bind>\n                             (\\<lambda>kvs'.\n                                 x := Btnode kvs' ti \\<bind>\n                                 (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                        else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                             (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n else ins k x ti \\<bind>\n      case_btupi\n       (\\<lambda>lp.\n           x := Btnode tsi lp \\<bind>\n           (\\<lambda>_. return (T\\<^sub>i (Some x))))\n       (\\<lambda>lp x' rp.\n           if tsl < 2 * k\n           then pfa_append tsi (lp, x') \\<bind>\n                (\\<lambda>kvs'.\n                    x := Btnode kvs' rp \\<bind>\n                    (\\<lambda>_. return (T\\<^sub>i (Some x))))\n           else pfa_append_grow' tsi (lp, x') \\<bind>\n                (\\<lambda>kvs'.\n                    node\\<^sub>i k kvs'\n                     rp))) <btupi_assn k\n                             (abs_split.node\\<^sub>i k\n                               (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x tsi ti tsi' xaa xb zs1 z zs2 h.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; xaa = Btnode tsi ti;\n        split ts x = (ls, a # rs); rrs = a # rs;\n        ts = ls @ a # rs \\<and> xb = length ls;\n        h \\<Turnstile>\n        is_pfa (2 * k) tsi' tsi *\n        (blist_assn k ls zs1 * (btree_assn k \\<times>\\<^sub>a id_assn) a z *\n         blist_assn k rs zs2) *\n        (x \\<mapsto>\\<^sub>r Btnode tsi ti * btree_assn k t ti) *\n        true *\n        \\<up> (zs1 @ z # zs2 = tsi')\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) tsi' tsi *\n                          (blist_assn k ls zs1 *\n                           (btree_assn k \\<times>\\<^sub>a id_assn) a z *\n                           blist_assn k rs zs2) *\n                          (x \\<mapsto>\\<^sub>r Btnode tsi ti *\n                           btree_assn k t ti) *\n                          true *\n                          \\<up>\n                           (zs1 @ z # zs2 =\n                            tsi')> pfa_length tsi \\<bind>\n                                   (\\<lambda>tsl.\n if length ls < tsl\n then pfa_get tsi xb \\<bind>\n      (\\<lambda>(sub, sep).\n          if sep = x then return (T\\<^sub>i (Some x))\n          else ins k x sub \\<bind>\n               case_btupi\n                (\\<lambda>lp.\n                    pfa_set tsi xb (lp, sep) \\<bind>\n                    (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                (\\<lambda>lp x' rp.\n                    pfa_set tsi xb (rp, sep) \\<bind>\n                    (\\<lambda>_.\n                        if tsl < 2 * k\n                        then pfa_insert tsi xb (lp, x') \\<bind>\n                             (\\<lambda>kvs'.\n                                 x := Btnode kvs' ti \\<bind>\n                                 (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                        else pfa_insert_grow tsi xb (lp, x') \\<bind>\n                             (\\<lambda>kvs'. node\\<^sub>i k kvs' ti))))\n else ins k x ti \\<bind>\n      case_btupi\n       (\\<lambda>lp.\n           x := Btnode tsi lp \\<bind>\n           (\\<lambda>_. return (T\\<^sub>i (Some x))))\n       (\\<lambda>lp x' rp.\n           if tsl < 2 * k\n           then pfa_append tsi (lp, x') \\<bind>\n                (\\<lambda>kvs'.\n                    x := Btnode kvs' rp \\<bind>\n                    (\\<lambda>_. return (T\\<^sub>i (Some x))))\n           else pfa_append_grow' tsi (lp, x') \\<bind>\n                (\\<lambda>kvs'.\n                    node\\<^sub>i k kvs'\n                     rp))) <btupi_assn k\n                             (abs_split.node\\<^sub>i k\n                               (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x aa b ti zs1 aaa ba zs2 ab bb suba.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (aaa, ba) # zs2) ! length ls = (suba, x)\\<rbrakk>\n       \\<Longrightarrow> is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                         blist_assn k ls zs1 *\n                         (btree_assn k \\<times>\\<^sub>a id_assn) a\n                          (aaa, ba) *\n                         blist_assn k rs zs2 *\n                         x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          (T\\<^sub>i (Some x)) *\n                         true\n 2. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa xb suba sepa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        length ls < length (zs1 @ (aaa, ba) # zs2);\n        (zs1 @ (aaa, ba) # zs2) ! length ls = (suba, sepa);\n        xb = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x suba \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (aa, b) (length ls)\n(lp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (aa, b) (length ls)\n(rp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   if length (zs1 @ (aaa, ba) # zs2) < 2 * k\n   then pfa_insert (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                       t)>\\<^sub>t\n 3. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        \\<not> length ls < length (zs1 @ (aaa, ba) # zs2)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length (zs1 @ (aaa, ba) # zs2)\n  < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                  t)>\\<^sub>t", "(* discard wrong branch *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x aa b ti zs1 aaa ba zs2 ab bb suba.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (aaa, ba) # zs2) ! length ls = (suba, x)\\<rbrakk>\n       \\<Longrightarrow> is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                         blist_assn k ls zs1 *\n                         (btree_assn k \\<times>\\<^sub>a id_assn) a\n                          (aaa, ba) *\n                         blist_assn k rs zs2 *\n                         x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          (T\\<^sub>i (Some x)) *\n                         true\n 2. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa xb suba sepa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        length ls < length (zs1 @ (aaa, ba) # zs2);\n        (zs1 @ (aaa, ba) # zs2) ! length ls = (suba, sepa);\n        xb = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x suba \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (aa, b) (length ls)\n(lp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (aa, b) (length ls)\n(rp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   if length (zs1 @ (aaa, ba) # zs2) < 2 * k\n   then pfa_insert (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                       t)>\\<^sub>t\n 3. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        \\<not> length ls < length (zs1 @ (aaa, ba) # zs2)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length (zs1 @ (aaa, ba) # zs2)\n  < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                  t)>\\<^sub>t", "subgoal for p tsil tsin ti zs1 subi sepi zs2 _ _ suba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, x)\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2)\n                       (tsil, tsin) *\n                      blist_assn k ls zs1 *\n                      (btree_assn k \\<times>\\<^sub>a id_assn) a\n                       (subi, sepi) *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      btupi_assn k\n                       (abs_split.node\\<^sub>i k\n                         (ls @ (l, w) # (r, sep) # rs) t)\n                       (T\\<^sub>i (Some p)) *\n                      true", "apply(subgoal_tac \"sepi  = x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, x); sepi = x\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2)\n                       (tsil, tsin) *\n                      blist_assn k ls zs1 *\n                      (btree_assn k \\<times>\\<^sub>a id_assn) a\n                       (subi, sepi) *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      btupi_assn k\n                       (abs_split.node\\<^sub>i k\n                         (ls @ (l, w) # (r, sep) # rs) t)\n                       (T\\<^sub>i (Some p)) *\n                      true\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, x)\\<rbrakk>\n    \\<Longrightarrow> sepi = x", "using list_split Cons a_split"], ["proof (prove)\nusing this:\n  split ts x = (ls, rrs)\n  rrs = a # rs\n  a = (sub, sep)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, x); sepi = x\\<rbrakk>\n    \\<Longrightarrow> is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2)\n                       (tsil, tsin) *\n                      blist_assn k ls zs1 *\n                      (btree_assn k \\<times>\\<^sub>a id_assn) a\n                       (subi, sepi) *\n                      blist_assn k rs zs2 *\n                      p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                      btree_assn k t ti *\n                      true \\<Longrightarrow>\\<^sub>A\n                      btupi_assn k\n                       (abs_split.node\\<^sub>i k\n                         (ls @ (l, w) # (r, sep) # rs) t)\n                       (T\\<^sub>i (Some p)) *\n                      true\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, x)\\<rbrakk>\n    \\<Longrightarrow> sepi = x", "apply(auto  dest!:  mod_starD )[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, x)\\<rbrakk>\n    \\<Longrightarrow> sepi = x", "apply(auto dest!:  mod_starD list_assn_len)[]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa xb suba sepa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        length ls < length (zs1 @ (aaa, ba) # zs2);\n        (zs1 @ (aaa, ba) # zs2) ! length ls = (suba, sepa);\n        xb = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x suba \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (aa, b) (length ls)\n(lp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (aa, b) (length ls)\n(rp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   if length (zs1 @ (aaa, ba) # zs2) < 2 * k\n   then pfa_insert (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                       t)>\\<^sub>t\n 2. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        \\<not> length ls < length (zs1 @ (aaa, ba) # zs2)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length (zs1 @ (aaa, ba) # zs2)\n  < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                  t)>\\<^sub>t", "(* actual induction branch *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa xb suba sepa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        length ls < length (zs1 @ (aaa, ba) # zs2);\n        (zs1 @ (aaa, ba) # zs2) ! length ls = (suba, sepa);\n        xb = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x suba \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     pfa_set (aa, b) (length ls)\n(lp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     pfa_set (aa, b) (length ls)\n(rp, sepa) \\<bind>\n                                     (\\<lambda>_.\n   if length (zs1 @ (aaa, ba) # zs2) < 2 * k\n   then pfa_insert (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            x := Btnode kvs' ti \\<bind>\n            (\\<lambda>_. return (T\\<^sub>i (Some x))))\n   else pfa_insert_grow (aa, b) (length ls) (lp, x') \\<bind>\n        (\\<lambda>kvs'.\n            node\\<^sub>i k kvs'\n             ti))) <btupi_assn k\n                     (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                       t)>\\<^sub>t\n 2. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        \\<not> length ls < length (zs1 @ (aaa, ba) # zs2)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length (zs1 @ (aaa, ba) # zs2)\n  < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                  t)>\\<^sub>t", "subgoal for p tsil tsin ti zs1 subi sepi zs2 _ _ n z suba sepa"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = length (zs1 @ (subi, sepi) # zs2);\n     length ls < length (zs1 @ (subi, sepi) # zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2)\n                        (tsil, tsin) *\n                       blist_assn k ls zs1 *\n                       (btree_assn k \\<times>\\<^sub>a id_assn) a\n                        (subi, sepi) *\n                       blist_assn k rs zs2 *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                       btree_assn k t ti *\n                       true> ins k x suba \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  pfa_set (tsil, tsin) (length ls)\n                                   (lp, sepa) \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  pfa_set (tsil, tsin) (length ls)\n                                   (rp, sepa) \\<bind>\n                                  (\\<lambda>_.\nif length (zs1 @ (subi, sepi) # zs2) < 2 * k\nthen pfa_insert (tsil, tsin) (length ls) (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         p := Btnode kvs' ti \\<bind>\n         (\\<lambda>_. return (T\\<^sub>i (Some p))))\nelse pfa_insert_grow (tsil, tsin) (length ls) (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         node\\<^sub>i k kvs'\n          ti))) <btupi_assn k\n                  (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                    t)>\\<^sub>t", "apply(subgoal_tac \"subi = suba\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (suba, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                        (tsil, tsin) *\n                       blist_assn k ls zs1 *\n                       (btree_assn k \\<times>\\<^sub>a id_assn) a\n                        (suba, sepi) *\n                       blist_assn k rs zs2 *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                       btree_assn k t ti *\n                       true> ins k x suba \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  pfa_set (tsil, tsin) (length ls)\n                                   (lp, sepa) \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  pfa_set (tsil, tsin) (length ls)\n                                   (rp, sepa) \\<bind>\n                                  (\\<lambda>_.\nif Suc (length zs1 + length zs2) < 2 * k\nthen pfa_insert (tsil, tsin) (length ls) (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         p := Btnode kvs' ti \\<bind>\n         (\\<lambda>_. return (T\\<^sub>i (Some p))))\nelse pfa_insert_grow (tsil, tsin) (length ls) (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         node\\<^sub>i k kvs'\n          ti))) <btupi_assn k\n                  (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                    t)>\\<^sub>t\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = length (zs1 @ (subi, sepi) # zs2);\n     length ls < length (zs1 @ (subi, sepi) # zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> subi = suba", "thm 2(2)[of ls rrs a rs sub sep]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (suba, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                        (tsil, tsin) *\n                       blist_assn k ls zs1 *\n                       (btree_assn k \\<times>\\<^sub>a id_assn) a\n                        (suba, sepi) *\n                       blist_assn k rs zs2 *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                       btree_assn k t ti *\n                       true> ins k x suba \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  pfa_set (tsil, tsin) (length ls)\n                                   (lp, sepa) \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  pfa_set (tsil, tsin) (length ls)\n                                   (rp, sepa) \\<bind>\n                                  (\\<lambda>_.\nif Suc (length zs1 + length zs2) < 2 * k\nthen pfa_insert (tsil, tsin) (length ls) (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         p := Btnode kvs' ti \\<bind>\n         (\\<lambda>_. return (T\\<^sub>i (Some p))))\nelse pfa_insert_grow (tsil, tsin) (length ls) (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         node\\<^sub>i k kvs'\n          ti))) <btupi_assn k\n                  (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                    t)>\\<^sub>t\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = length (zs1 @ (subi, sepi) # zs2);\n     length ls < length (zs1 @ (subi, sepi) # zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> subi = suba", "using list_split a_split Cons Up\\<^sub>i False"], ["proof (prove)\nusing this:\n  split ts x = (ls, rrs)\n  a = (sub, sep)\n  rrs = a # rs\n  abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r\n  x \\<noteq> sep\n\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (suba, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                        (tsil, tsin) *\n                       blist_assn k ls zs1 *\n                       (btree_assn k \\<times>\\<^sub>a id_assn) a\n                        (suba, sepi) *\n                       blist_assn k rs zs2 *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                       btree_assn k t ti *\n                       true> ins k x suba \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  pfa_set (tsil, tsin) (length ls)\n                                   (lp, sepa) \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  pfa_set (tsil, tsin) (length ls)\n                                   (rp, sepa) \\<bind>\n                                  (\\<lambda>_.\nif Suc (length zs1 + length zs2) < 2 * k\nthen pfa_insert (tsil, tsin) (length ls) (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         p := Btnode kvs' ti \\<bind>\n         (\\<lambda>_. return (T\\<^sub>i (Some p))))\nelse pfa_insert_grow (tsil, tsin) (length ls) (lp, x') \\<bind>\n     (\\<lambda>kvs'.\n         node\\<^sub>i k kvs'\n          ti))) <btupi_assn k\n                  (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                    t)>\\<^sub>t\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = length (zs1 @ (subi, sepi) # zs2);\n     length ls < length (zs1 @ (subi, sepi) # zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> subi = suba", "apply (sep_auto heap: 2(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        x \\<noteq> sep\\<rbrakk>\n       \\<Longrightarrow> <btupi_assn k (abs_split.Up\\<^sub>i l w r) x *\n                          is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                           (tsil, tsin) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepi *\n                          blist_assn k rs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          btree_assn k t ti *\n                          true> case x of\n                                T\\<^sub>i lp \\<Rightarrow>\n                                  pfa_set (tsil, tsin) (length ls)\n                                   (lp, sepa) \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p)))\n                                | Up\\<^sub>i lp x' rp \\<Rightarrow>\n                                    pfa_set (tsil, tsin) (length ls)\n                                     (rp, sepa) \\<bind>\n                                    (\\<lambda>_.\n  if Suc (length zs1 + length zs2) < 2 * k\n  then pfa_insert (tsil, tsin) (length ls) (lp, x') \\<bind>\n       (\\<lambda>kvs'.\n           p := Btnode kvs' ti \\<bind>\n           (\\<lambda>_. return (T\\<^sub>i (Some p))))\n  else pfa_insert_grow (tsil, tsin) (length ls) (lp, x') \\<bind>\n       (\\<lambda>kvs'.\n           node\\<^sub>i k kvs'\n            ti)) <btupi_assn k\n                   (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                     t)>\\<^sub>t\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = length (zs1 @ (subi, sepi) # zs2);\n     length ls < length (zs1 @ (subi, sepi) # zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> subi = suba", "apply(auto split!: btupi.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k l x21 * id_assn w x22 *\n                          btree_assn k r x23 *\n                          is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                           (tsil, tsin) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepi *\n                          blist_assn k rs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          btree_assn k t ti *\n                          true> pfa_set (tsil, tsin) (length ls)\n                                 (x23, sepa) \\<bind>\n                                (\\<lambda>_.\n                                    pfa_insert (tsil, tsin) (length ls)\n                                     (x21, x22) \\<bind>\n                                    (\\<lambda>kvs'.\n  p := Btnode kvs' ti \\<bind>\n  (\\<lambda>_.\n      return\n       (T\\<^sub>i\n         (Some\n           p))))) <btupi_assn k\n                    (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                      t)>\\<^sub>t\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k l x21 * id_assn w x22 *\n                          btree_assn k r x23 *\n                          is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                           (tsil, tsin) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepi *\n                          blist_assn k rs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          btree_assn k t ti *\n                          true> pfa_set (tsil, tsin) (length ls)\n                                 (x23, sepa) \\<bind>\n                                (\\<lambda>_.\n                                    pfa_insert_grow (tsil, tsin) (length ls)\n                                     (x21, x22) \\<bind>\n                                    (\\<lambda>kvs'.\n  node\\<^sub>i k kvs'\n   ti)) <btupi_assn k\n          (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n            t)>\\<^sub>t\n 3. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> subi = suba", "(* careful progression for manual value insertion *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k l x21 * id_assn w x22 *\n                          btree_assn k r x23 *\n                          is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                           (tsil, tsin) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepi *\n                          blist_assn k rs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          btree_assn k t ti *\n                          true> pfa_set (tsil, tsin) (length ls)\n                                 (x23, sepa) \\<bind>\n                                (\\<lambda>_.\n                                    pfa_insert (tsil, tsin) (length ls)\n                                     (x21, x22) \\<bind>\n                                    (\\<lambda>kvs'.\n  p := Btnode kvs' ti \\<bind>\n  (\\<lambda>_.\n      return\n       (T\\<^sub>i\n         (Some\n           p))))) <btupi_assn k\n                    (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                      t)>\\<^sub>t\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k l x21 * id_assn w x22 *\n                          btree_assn k r x23 *\n                          is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                           (tsil, tsin) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepi *\n                          blist_assn k rs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          btree_assn k t ti *\n                          true> pfa_set (tsil, tsin) (length ls)\n                                 (x23, sepa) \\<bind>\n                                (\\<lambda>_.\n                                    pfa_insert_grow (tsil, tsin) (length ls)\n                                     (x21, x22) \\<bind>\n                                    (\\<lambda>kvs'.\n  node\\<^sub>i k kvs'\n   ti)) <btupi_assn k\n          (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n            t)>\\<^sub>t\n 3. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> subi = suba", "apply vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     rrs = (sub, sep) # rs;\n     abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n     Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n    \\<Longrightarrow> length ls < length (zs1 @ (suba, sepi) # zs2)\n 2. \\<And>x21 x22 x23 x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k)\n                           ((zs1 @ (suba, sepi) # zs2)\n                            [length ls := (x23, sepa)])\n                           x *\n                          \\<up> (x = (tsil, tsin)) *\n                          (btree_assn k l x21 * id_assn w x22 *\n                           btree_assn k r x23 *\n                           blist_assn k ls zs1 *\n                           id_assn sep sepi *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> pfa_insert (tsil, tsin) (length ls)\n                                   (x21, x22) \\<bind>\n                                  (\\<lambda>kvs'.\np := Btnode kvs' ti \\<bind>\n(\\<lambda>_.\n    return\n     (T\\<^sub>i\n       (Some\n         p)))) <btupi_assn k\n                 (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                   t)>\\<^sub>t\n 3. \\<And>x21 x22 x23.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k l x21 * id_assn w x22 *\n                          btree_assn k r x23 *\n                          is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                           (tsil, tsin) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepi *\n                          blist_assn k rs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          btree_assn k t ti *\n                          true> pfa_set (tsil, tsin) (length ls)\n                                 (x23, sepa) \\<bind>\n                                (\\<lambda>_.\n                                    pfa_insert_grow (tsil, tsin) (length ls)\n                                     (x21, x22) \\<bind>\n                                    (\\<lambda>kvs'.\n  node\\<^sub>i k kvs'\n   ti)) <btupi_assn k\n          (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n            t)>\\<^sub>t\n 4. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> subi = suba", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 x23 x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k)\n                           ((zs1 @ (suba, sepi) # zs2)\n                            [length ls := (x23, sepa)])\n                           x *\n                          \\<up> (x = (tsil, tsin)) *\n                          (btree_assn k l x21 * id_assn w x22 *\n                           btree_assn k r x23 *\n                           blist_assn k ls zs1 *\n                           id_assn sep sepi *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> pfa_insert (tsil, tsin) (length ls)\n                                   (x21, x22) \\<bind>\n                                  (\\<lambda>kvs'.\np := Btnode kvs' ti \\<bind>\n(\\<lambda>_.\n    return\n     (T\\<^sub>i\n       (Some\n         p)))) <btupi_assn k\n                 (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                   t)>\\<^sub>t\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k l x21 * id_assn w x22 *\n                          btree_assn k r x23 *\n                          is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                           (tsil, tsin) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepi *\n                          blist_assn k rs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          btree_assn k t ti *\n                          true> pfa_set (tsil, tsin) (length ls)\n                                 (x23, sepa) \\<bind>\n                                (\\<lambda>_.\n                                    pfa_insert_grow (tsil, tsin) (length ls)\n                                     (x21, x22) \\<bind>\n                                    (\\<lambda>kvs'.\n  node\\<^sub>i k kvs'\n   ti)) <btupi_assn k\n          (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n            t)>\\<^sub>t\n 3. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> subi = suba", "subgoal for li wi ri u"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     rrs = (sub, sep) # rs;\n     abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n     Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k)\n                        ((zs1 @ (suba, sepi) # zs2)\n                         [length ls := (ri, sepa)])\n                        u *\n                       \\<up> (u = (tsil, tsin)) *\n                       (btree_assn k l li * id_assn w wi *\n                        btree_assn k r ri *\n                        blist_assn k ls zs1 *\n                        id_assn sep sepi *\n                        blist_assn k rs zs2 *\n                        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                        btree_assn k t ti *\n                        true)> pfa_insert (tsil, tsin) (length ls)\n                                (li, wi) \\<bind>\n                               (\\<lambda>kvs'.\n                                   p := Btnode kvs' ti \\<bind>\n                                   (\\<lambda>_.\n return\n  (T\\<^sub>i\n    (Some\n      p)))) <btupi_assn k\n              (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                t)>\\<^sub>t", "(* no split case *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     rrs = (sub, sep) # rs;\n     abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n     Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k)\n                        ((zs1 @ (suba, sepi) # zs2)\n                         [length ls := (ri, sepa)])\n                        u *\n                       \\<up> (u = (tsil, tsin)) *\n                       (btree_assn k l li * id_assn w wi *\n                        btree_assn k r ri *\n                        blist_assn k ls zs1 *\n                        id_assn sep sepi *\n                        blist_assn k rs zs2 *\n                        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                        btree_assn k t ti *\n                        true)> pfa_insert (tsil, tsin) (length ls)\n                                (li, wi) \\<bind>\n                               (\\<lambda>kvs'.\n                                   p := Btnode kvs' ti \\<bind>\n                                   (\\<lambda>_.\n return\n  (T\\<^sub>i\n    (Some\n      p)))) <btupi_assn k\n              (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                t)>\\<^sub>t", "apply (cases u,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> aa = tsil \\<and> b = tsin \\<longrightarrow>\n                         <is_pfa (2 * k)\n                           ((zs1 @ (suba, sepi) # zs2)\n                            [length ls := (ri, sepa)])\n                           (tsil, tsin) *\n                          (btree_assn k l li * id_assn w wi *\n                           btree_assn k r ri *\n                           blist_assn k ls zs1 *\n                           id_assn sep sepi *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti) *\n                          true> pfa_insert (tsil, tsin) (length ls)\n                                 (li, wi) \\<bind>\n                                (\\<lambda>kvs'.\n                                    p := Btnode kvs' ti \\<bind>\n                                    (\\<lambda>_.\n  return\n   (T\\<^sub>i\n     (Some\n       p)))) <btupi_assn k\n               (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                 t)>\\<^sub>t", "apply (sep_auto dest!: mod_starD list_assn_len heap: pfa_insert_grow_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> length zs1 \\<le> tsin\n 2. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> tsin < 2 * k\n 3. \\<And>ab bb ad bd af bf al bl am bm x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (a', n') \\<Rightarrow>\n                             is_pfa (2 * k)\n                              (take (length zs1) (zs1 @ (ri, sep) # zs2) @\n                               (li, wi) #\n                               drop (length zs1) (zs1 @ (ri, sep) # zs2))\n                              (a', n') *\n                             \\<up> (n' = tsin + 1 \\<and> tsil = a')) *\n                          (btree_assn k l li * id_assn w wi *\n                           btree_assn k r ri *\n                           blist_assn k ls zs1 *\n                           id_assn sep sep *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> p := Btnode x ti \\<bind>\n                                  (\\<lambda>_.\nreturn\n (T\\<^sub>i\n   (Some\n     p))) <btupi_assn k\n            (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n              t)>\\<^sub>t", "apply (simp add: is_pfa_def)[]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        \\<exists>l'.\n           (am, bm) \\<Turnstile> tsil \\<mapsto>\\<^sub>a l' \\<and>\n           2 * k = length l' \\<and>\n           tsin \\<le> 2 * k \\<and> zs1 @ (suba, sep) # zs2 = take tsin l';\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> length zs1 \\<le> tsin\n 2. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> tsin < 2 * k\n 3. \\<And>ab bb ad bd af bf al bl am bm x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (a', n') \\<Rightarrow>\n                             is_pfa (2 * k)\n                              (take (length zs1) (zs1 @ (ri, sep) # zs2) @\n                               (li, wi) #\n                               drop (length zs1) (zs1 @ (ri, sep) # zs2))\n                              (a', n') *\n                             \\<up> (n' = tsin + 1 \\<and> tsil = a')) *\n                          (btree_assn k l li * id_assn w wi *\n                           btree_assn k r ri *\n                           blist_assn k ls zs1 *\n                           id_assn sep sep *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> p := Btnode x ti \\<bind>\n                                  (\\<lambda>_.\nreturn\n (T\\<^sub>i\n   (Some\n     p))) <btupi_assn k\n            (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n              t)>\\<^sub>t", "apply (metis le_less_linear length_append length_take less_not_refl min.absorb2 trans_less_add1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> tsin < 2 * k\n 2. \\<And>ab bb ad bd af bf al bl am bm x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (a', n') \\<Rightarrow>\n                             is_pfa (2 * k)\n                              (take (length zs1) (zs1 @ (ri, sep) # zs2) @\n                               (li, wi) #\n                               drop (length zs1) (zs1 @ (ri, sep) # zs2))\n                              (a', n') *\n                             \\<up> (n' = tsin + 1 \\<and> tsil = a')) *\n                          (btree_assn k l li * id_assn w wi *\n                           btree_assn k r ri *\n                           blist_assn k ls zs1 *\n                           id_assn sep sep *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> p := Btnode x ti \\<bind>\n                                  (\\<lambda>_.\nreturn\n (T\\<^sub>i\n   (Some\n     p))) <btupi_assn k\n            (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n              t)>\\<^sub>t", "apply(simp add: is_pfa_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        \\<exists>l'.\n           (am, bm) \\<Turnstile> tsil \\<mapsto>\\<^sub>a l' \\<and>\n           2 * k = length l' \\<and>\n           tsin \\<le> 2 * k \\<and> zs1 @ (suba, sep) # zs2 = take tsin l';\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> tsin < 2 * k\n 2. \\<And>ab bb ad bd af bf al bl am bm x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (a', n') \\<Rightarrow>\n                             is_pfa (2 * k)\n                              (take (length zs1) (zs1 @ (ri, sep) # zs2) @\n                               (li, wi) #\n                               drop (length zs1) (zs1 @ (ri, sep) # zs2))\n                              (a', n') *\n                             \\<up> (n' = tsin + 1 \\<and> tsil = a')) *\n                          (btree_assn k l li * id_assn w wi *\n                           btree_assn k r ri *\n                           blist_assn k ls zs1 *\n                           id_assn sep sep *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> p := Btnode x ti \\<bind>\n                                  (\\<lambda>_.\nreturn\n (T\\<^sub>i\n   (Some\n     p))) <btupi_assn k\n            (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n              t)>\\<^sub>t", "apply (metis add_Suc_right length_Cons length_append length_take min.absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ad bd af bf al bl am bm x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (a', n') \\<Rightarrow>\n                             is_pfa (2 * k)\n                              (take (length zs1) (zs1 @ (ri, sep) # zs2) @\n                               (li, wi) #\n                               drop (length zs1) (zs1 @ (ri, sep) # zs2))\n                              (a', n') *\n                             \\<up> (n' = tsin + 1 \\<and> tsil = a')) *\n                          (btree_assn k l li * id_assn w wi *\n                           btree_assn k r ri *\n                           blist_assn k ls zs1 *\n                           id_assn sep sep *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> p := Btnode x ti \\<bind>\n                                  (\\<lambda>_.\nreturn\n (T\\<^sub>i\n   (Some\n     p))) <btupi_assn k\n            (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n              t)>\\<^sub>t", "apply(sep_auto split: prod.splits  dest!: mod_starD list_assn_len)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ti *\n                         is_pfa (2 * k) (zs1 @ (li, wi) # (ri, sep) # zs2)\n                          (tsil, Suc tsin) *\n                         btree_assn k l li *\n                         id_assn w wi *\n                         btree_assn k r ri *\n                         blist_assn k ls zs1 *\n                         id_assn sep sep *\n                         blist_assn k rs zs2 *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          (T\\<^sub>i (Some p)) *\n                         true", "(* no split case *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ti *\n                         is_pfa (2 * k) (zs1 @ (li, wi) # (ri, sep) # zs2)\n                          (tsil, Suc tsin) *\n                         btree_assn k l li *\n                         id_assn w wi *\n                         btree_assn k r ri *\n                         blist_assn k ls zs1 *\n                         id_assn sep sep *\n                         blist_assn k rs zs2 *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          (T\\<^sub>i (Some p)) *\n                         true", "apply(subgoal_tac \"length (ls @ [(l,w)]) \\<le> 2*k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1; length (ls @ [(l, w)]) \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ti *\n                         is_pfa (2 * k) (zs1 @ (li, wi) # (ri, sep) # zs2)\n                          (tsil, Suc tsin) *\n                         btree_assn k l li *\n                         id_assn w wi *\n                         btree_assn k r ri *\n                         blist_assn k ls zs1 *\n                         id_assn sep sep *\n                         blist_assn k rs zs2 *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          (T\\<^sub>i (Some p)) *\n                         true\n 2. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> length (ls @ [(l, w)]) \\<le> 2 * k", "apply(simp add: node\\<^sub>i_no_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ti *\n                         is_pfa (2 * k) (zs1 @ (li, wi) # (ri, sep) # zs2)\n                          (tsil, Suc tsin) *\n                         btree_assn k l li *\n                         id_assn w wi *\n                         btree_assn k r ri *\n                         blist_assn k ls zs1 *\n                         id_assn sep sep *\n                         blist_assn k rs zs2 *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Atsi ti tsi'.\n                            p \\<mapsto>\\<^sub>r Btnode tsi ti *\n                            btree_assn k t ti *\n                            is_pfa (2 * k) tsi' tsi *\n                            blist_assn k (ls @ (l, w) # (r, sep) # rs)\n                             tsi' *\n                            true\n 2. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> length (ls @ [(l, w)]) \\<le> 2 * k", "apply(rule ent_ex_postI[where x=\"(tsil,Suc tsin)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ti *\n                         is_pfa (2 * k) (zs1 @ (li, wi) # (ri, sep) # zs2)\n                          (tsil, Suc tsin) *\n                         btree_assn k l li *\n                         id_assn w wi *\n                         btree_assn k r ri *\n                         blist_assn k ls zs1 *\n                         id_assn sep sep *\n                         blist_assn k rs zs2 *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Ati tsi'.\n                            p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ti *\n                            btree_assn k t ti *\n                            is_pfa (2 * k) tsi' (tsil, Suc tsin) *\n                            blist_assn k (ls @ (l, w) # (r, sep) # rs)\n                             tsi' *\n                            true\n 2. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> length (ls @ [(l, w)]) \\<le> 2 * k", "apply(rule ent_ex_postI[where x=\"ti\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ti *\n                         is_pfa (2 * k) (zs1 @ (li, wi) # (ri, sep) # zs2)\n                          (tsil, Suc tsin) *\n                         btree_assn k l li *\n                         id_assn w wi *\n                         btree_assn k r ri *\n                         blist_assn k ls zs1 *\n                         id_assn sep sep *\n                         blist_assn k rs zs2 *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Atsi'.\n                            p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ti *\n                            btree_assn k t ti *\n                            is_pfa (2 * k) tsi' (tsil, Suc tsin) *\n                            blist_assn k (ls @ (l, w) # (r, sep) # rs)\n                             tsi' *\n                            true\n 2. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> length (ls @ [(l, w)]) \\<le> 2 * k", "apply(rule ent_ex_postI[where x=\"(zs1 @ (li, wi) # (ri, sep) # zs2)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ti *\n                         is_pfa (2 * k) (zs1 @ (li, wi) # (ri, sep) # zs2)\n                          (tsil, Suc tsin) *\n                         btree_assn k l li *\n                         id_assn w wi *\n                         btree_assn k r ri *\n                         blist_assn k ls zs1 *\n                         id_assn sep sep *\n                         blist_assn k rs zs2 *\n                         btree_assn k t ti *\n                         true \\<Longrightarrow>\\<^sub>A\n                         p \\<mapsto>\\<^sub>r Btnode (tsil, Suc tsin) ti *\n                         btree_assn k t ti *\n                         is_pfa (2 * k) (zs1 @ (li, wi) # (ri, sep) # zs2)\n                          (tsil, Suc tsin) *\n                         blist_assn k (ls @ (l, w) # (r, sep) # rs)\n                          (zs1 @ (li, wi) # (ri, sep) # zs2) *\n                         true\n 2. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> length (ls @ [(l, w)]) \\<le> 2 * k", "apply(sep_auto dest!: mod_starD list_assn_len)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> length (ls @ [(l, w)]) \\<le> 2 * k", "apply (sep_auto dest!: mod_starD list_assn_len simp add: is_pfa_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k l x21 * id_assn w x22 *\n                          btree_assn k r x23 *\n                          is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2)\n                           (tsil, tsin) *\n                          blist_assn k ls zs1 *\n                          id_assn sep sepi *\n                          blist_assn k rs zs2 *\n                          p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          btree_assn k t ti *\n                          true> pfa_set (tsil, tsin) (length ls)\n                                 (x23, sepa) \\<bind>\n                                (\\<lambda>_.\n                                    pfa_insert_grow (tsil, tsin) (length ls)\n                                     (x21, x22) \\<bind>\n                                    (\\<lambda>kvs'.\n  node\\<^sub>i k kvs'\n   ti)) <btupi_assn k\n          (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n            t)>\\<^sub>t\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> subi = suba", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     rrs = (sub, sep) # rs;\n     abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n     \\<not> Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n    \\<Longrightarrow> length ls < length (zs1 @ (suba, sepi) # zs2)\n 2. \\<And>x21 x22 x23 x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k)\n                           ((zs1 @ (suba, sepi) # zs2)\n                            [length ls := (x23, sepa)])\n                           x *\n                          \\<up> (x = (tsil, tsin)) *\n                          (btree_assn k l x21 * id_assn w x22 *\n                           btree_assn k r x23 *\n                           blist_assn k ls zs1 *\n                           id_assn sep sepi *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> pfa_insert_grow (tsil, tsin) (length ls)\n                                   (x21, x22) \\<bind>\n                                  (\\<lambda>kvs'.\nnode\\<^sub>i k kvs'\n ti) <btupi_assn k\n       (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t\n 3. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> subi = suba", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23 x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k)\n                           ((zs1 @ (suba, sepi) # zs2)\n                            [length ls := (x23, sepa)])\n                           x *\n                          \\<up> (x = (tsil, tsin)) *\n                          (btree_assn k l x21 * id_assn w x22 *\n                           btree_assn k r x23 *\n                           blist_assn k ls zs1 *\n                           id_assn sep sepi *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> pfa_insert_grow (tsil, tsin) (length ls)\n                                   (x21, x22) \\<bind>\n                                  (\\<lambda>kvs'.\nnode\\<^sub>i k kvs'\n ti) <btupi_assn k\n       (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t\n 2. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> subi = suba", "subgoal for x21 x22 x23 u"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     rrs = (sub, sep) # rs;\n     abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n     \\<not> Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k)\n                        ((zs1 @ (suba, sepi) # zs2)\n                         [length ls := (x23, sepa)])\n                        u *\n                       \\<up> (u = (tsil, tsin)) *\n                       (btree_assn k l x21 * id_assn w x22 *\n                        btree_assn k r x23 *\n                        blist_assn k ls zs1 *\n                        id_assn sep sepi *\n                        blist_assn k rs zs2 *\n                        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                        btree_assn k t ti *\n                        true)> pfa_insert_grow (tsil, tsin) (length ls)\n                                (x21, x22) \\<bind>\n                               (\\<lambda>kvs'.\n                                   node\\<^sub>i k kvs'\n                                    ti) <btupi_assn k\n    (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "(* split case *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tia__ = Some p;\n     split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n     ts = ls @ (sub, sep) # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     btree_assn k sub suba *\n     id_assn sep sepi *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n     rrs = (sub, sep) # rs;\n     abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n     \\<not> Suc (length zs1 + length zs2) < 2 * k\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k)\n                        ((zs1 @ (suba, sepi) # zs2)\n                         [length ls := (x23, sepa)])\n                        u *\n                       \\<up> (u = (tsil, tsin)) *\n                       (btree_assn k l x21 * id_assn w x22 *\n                        btree_assn k r x23 *\n                        blist_assn k ls zs1 *\n                        id_assn sep sepi *\n                        blist_assn k rs zs2 *\n                        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                        btree_assn k t ti *\n                        true)> pfa_insert_grow (tsil, tsin) (length ls)\n                                (x21, x22) \\<bind>\n                               (\\<lambda>kvs'.\n                                   node\\<^sub>i k kvs'\n                                    ti) <btupi_assn k\n    (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply (cases u,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> aa = tsil \\<and> b = tsin \\<longrightarrow>\n                         <is_pfa (2 * k)\n                           ((zs1 @ (suba, sepi) # zs2)\n                            [length ls := (x23, sepa)])\n                           (tsil, tsin) *\n                          (btree_assn k l x21 * id_assn w x22 *\n                           btree_assn k r x23 *\n                           blist_assn k ls zs1 *\n                           id_assn sep sepi *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti) *\n                          true> pfa_insert_grow (tsil, tsin) (length ls)\n                                 (x21, x22) \\<bind>\n                                (\\<lambda>kvs'.\n                                    node\\<^sub>i k kvs'\n                                     ti) <btupi_assn k\n     (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "thm pfa_insert_grow_rule[where ?l=\"((zs1 @ (suba, sepi) # zs2)[length ls := (x23, sepa)])\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs;\n        (ab_, bb_) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sepi) # zs2) (tsil, tsin) *\n        blist_assn k ls zs1 *\n        btree_assn k sub suba *\n        id_assn sep sepi *\n        blist_assn k rs zs2 *\n        p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n        btree_assn k t ti *\n        true;\n        n = Suc (length zs1 + length zs2);\n        length ls < Suc (length zs1 + length zs2);\n        (zs1 @ (suba, sepi) # zs2) ! length ls = (suba, sepa);\n        z = (suba, sepa); sepa \\<noteq> x; subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> aa = tsil \\<and> b = tsin \\<longrightarrow>\n                         <is_pfa (2 * k)\n                           ((zs1 @ (suba, sepi) # zs2)\n                            [length ls := (x23, sepa)])\n                           (tsil, tsin) *\n                          (btree_assn k l x21 * id_assn w x22 *\n                           btree_assn k r x23 *\n                           blist_assn k ls zs1 *\n                           id_assn sep sepi *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti) *\n                          true> pfa_insert_grow (tsil, tsin) (length ls)\n                                 (x21, x22) \\<bind>\n                                (\\<lambda>kvs'.\n                                    node\\<^sub>i k kvs'\n                                     ti) <btupi_assn k\n     (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply (sep_auto dest!: mod_starD list_assn_len heap: pfa_insert_grow_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> length zs1 \\<le> tsin\n 2. \\<And>ab bb ad bd af bf al bl am bm x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (a', n') \\<Rightarrow>\n                             is_pfa (max (2 * k) (tsin + 1))\n                              (take (length zs1) (zs1 @ (x23, sep) # zs2) @\n                               (x21, x22) #\n                               drop (length zs1) (zs1 @ (x23, sep) # zs2))\n                              (a', n') *\n                             \\<up>\n                              (n' = tsin + 1 \\<and> tsin \\<le> 2 * k)) *\n                          true *\n                          (btree_assn k l x21 * id_assn w x22 *\n                           btree_assn k r x23 *\n                           blist_assn k ls zs1 *\n                           id_assn sep sep *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> node\\<^sub>i k x\n                                   ti <btupi_assn k\n  (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply (simp add: is_pfa_def)[]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        \\<exists>l'.\n           (am, bm) \\<Turnstile> tsil \\<mapsto>\\<^sub>a l' \\<and>\n           2 * k = length l' \\<and>\n           tsin \\<le> 2 * k \\<and> zs1 @ (suba, sep) # zs2 = take tsin l';\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> length zs1 \\<le> tsin\n 2. \\<And>ab bb ad bd af bf al bl am bm x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (a', n') \\<Rightarrow>\n                             is_pfa (max (2 * k) (tsin + 1))\n                              (take (length zs1) (zs1 @ (x23, sep) # zs2) @\n                               (x21, x22) #\n                               drop (length zs1) (zs1 @ (x23, sep) # zs2))\n                              (a', n') *\n                             \\<up>\n                              (n' = tsin + 1 \\<and> tsin \\<le> 2 * k)) *\n                          true *\n                          (btree_assn k l x21 * id_assn w x22 *\n                           btree_assn k r x23 *\n                           blist_assn k ls zs1 *\n                           id_assn sep sep *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> node\\<^sub>i k x\n                                   ti <btupi_assn k\n  (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply (metis le_less_linear length_append length_take less_not_refl min.absorb2 trans_less_add1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ad bd af bf al bl am bm x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (a', n') \\<Rightarrow>\n                             is_pfa (max (2 * k) (tsin + 1))\n                              (take (length zs1) (zs1 @ (x23, sep) # zs2) @\n                               (x21, x22) #\n                               drop (length zs1) (zs1 @ (x23, sep) # zs2))\n                              (a', n') *\n                             \\<up>\n                              (n' = tsin + 1 \\<and> tsin \\<le> 2 * k)) *\n                          true *\n                          (btree_assn k l x21 * id_assn w x22 *\n                           btree_assn k r x23 *\n                           blist_assn k ls zs1 *\n                           id_assn sep sep *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti *\n                           true)> node\\<^sub>i k x\n                                   ti <btupi_assn k\n  (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply(auto split: prod.splits  dest!: mod_starD list_assn_len)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ad bd af bf al bl am bm x1.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1; tsin \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (max (2 * k) (Suc tsin))\n                           (zs1 @ (x21, x22) # (x23, sep) # zs2)\n                           (x1, Suc tsin) *\n                          (btree_assn k l x21 * id_assn w x22 *\n                           btree_assn k r x23 *\n                           blist_assn k ls zs1 *\n                           id_assn sep sep *\n                           blist_assn k rs zs2 *\n                           p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                           btree_assn k t ti) *\n                          true> node\\<^sub>i k (x1, Suc tsin)\n                                 ti <btupi_assn k\n(abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs) t)>\\<^sub>t", "apply (vcg heap: node\\<^sub>i_rule_ins2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1; tsin \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> 2 * k \\<le> max (2 * k) (Suc tsin)\n 2. \\<And>ab bb ad bd af bf al bl am bm x1.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1; tsin \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> max (2 * k) (Suc tsin) \\<le> 4 * k + 1\n 3. \\<And>ab bb ad bd af bf al bl am bm x1.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1; tsin \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> length ls = length zs1\n 4. \\<And>ab bb ad bd af bf al bl am bm x1 x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1; tsin \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          x *\n                         true *\n                         (p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          true) \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          x *\n                         true", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm x1.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1; tsin \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> max (2 * k) (Suc tsin) \\<le> 4 * k + 1\n 2. \\<And>ab bb ad bd af bf al bl am bm x1.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1; tsin \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> length ls = length zs1\n 3. \\<And>ab bb ad bd af bf al bl am bm x1 x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1; tsin \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          x *\n                         true *\n                         (p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          true) \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          x *\n                         true", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bb ad bd af bf al bl am bm x1.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1; tsin \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> length ls = length zs1\n 2. \\<And>ab bb ad bd af bf al bl am bm x1 x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1; tsin \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          x *\n                         true *\n                         (p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          true) \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          x *\n                         true", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bb ad bd af bf al bl am bm x1 x.\n       \\<lbrakk>tia__ = Some p;\n        split (ls @ (sub, sep) # rs) x = (ls, (sub, sep) # rs);\n        ts = ls @ (sub, sep) # rs; n = Suc (length zs1 + length zs2);\n        sepi = sep; z = (suba, sep); subi = suba; a = (sub, sep);\n        rrs = (sub, sep) # rs;\n        abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r; x \\<noteq> sep;\n        \\<not> Suc (length zs1 + length zs2) < 2 * k; u = (tsil, tsin);\n        in_range (ab, bb); (ad, bd) \\<Turnstile> btree_assn k t ti;\n        (af, bf) \\<Turnstile> p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti;\n        length rs = length zs2; sepa = sep;\n        (al, bl) \\<Turnstile> btree_assn k sub suba;\n        (am, bm) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (suba, sep) # zs2) (tsil, tsin);\n        length ls = length zs1; tsin \\<le> 2 * k\\<rbrakk>\n       \\<Longrightarrow> btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          x *\n                         true *\n                         (p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                          true) \\<Longrightarrow>\\<^sub>A\n                         btupi_assn k\n                          (abs_split.node\\<^sub>i k\n                            (ls @ (l, w) # (r, sep) # rs) t)\n                          x *\n                         true", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     n = Suc (length zs1 + length zs2);\n     length ls < Suc (length zs1 + length zs2);\n     (zs1 @ (subi, sepi) # zs2) ! length ls = (suba, sepa);\n     z = (suba, sepa); sepa \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> subi = suba", "apply(auto dest!:  mod_starD list_assn_len)[]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x aa b ti zs1 aaa ba zs2 ab bb xaa.\n       \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n        sep \\<noteq> x; ti = Some x; split (ls @ a # rs) x = (ls, a # rs);\n        rrs = a # rs; ts = ls @ a # rs;\n        (ab, bb) \\<Turnstile>\n        is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n        blist_assn k ls zs1 *\n        (btree_assn k \\<times>\\<^sub>a id_assn) a (aaa, ba) *\n        blist_assn k rs zs2 *\n        x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n        btree_assn k t ti *\n        true;\n        xaa = length (zs1 @ (aaa, ba) # zs2);\n        \\<not> length ls < length (zs1 @ (aaa, ba) # zs2)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (aaa, ba) # zs2) (aa, b) *\n                          blist_assn k ls zs1 *\n                          (btree_assn k \\<times>\\<^sub>a id_assn) a\n                           (aaa, ba) *\n                          blist_assn k rs zs2 *\n                          x \\<mapsto>\\<^sub>r Btnode (aa, b) ti *\n                          btree_assn k t ti *\n                          true> ins k x ti \\<bind>\n                                case_btupi\n                                 (\\<lambda>lp.\n                                     x := Btnode (aa, b) lp \\<bind>\n                                     (\\<lambda>_.\n   return (T\\<^sub>i (Some x))))\n                                 (\\<lambda>lp x' rp.\n                                     if length (zs1 @ (aaa, ba) # zs2)\n  < 2 * k\n                                     then pfa_append (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        x := Btnode kvs' rp \\<bind>\n        (\\<lambda>_. return (T\\<^sub>i (Some x))))\n                                     else pfa_append_grow' (aa, b)\n     (lp, x') \\<bind>\n    (\\<lambda>kvs'.\n        node\\<^sub>i k kvs'\n         rp)) <btupi_assn k\n                (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n                  t)>\\<^sub>t", "subgoal for p tsil tsin ti zs1 subi sepi zs2 _ _ suba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x sub = abs_split.Up\\<^sub>i l w r;\n     sep \\<noteq> x; tia__ = Some p; split (ls @ a # rs) x = (ls, a # rs);\n     rrs = a # rs; ts = ls @ a # rs;\n     (ab_, bb_) \\<Turnstile>\n     is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2) (tsil, tsin) *\n     blist_assn k ls zs1 *\n     (btree_assn k \\<times>\\<^sub>a id_assn) a (subi, sepi) *\n     blist_assn k rs zs2 *\n     p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n     btree_assn k t ti *\n     true;\n     suba = length (zs1 @ (subi, sepi) # zs2);\n     \\<not> length ls < length (zs1 @ (subi, sepi) # zs2)\\<rbrakk>\n    \\<Longrightarrow> <is_pfa (2 * k) (zs1 @ (subi, sepi) # zs2)\n                        (tsil, tsin) *\n                       blist_assn k ls zs1 *\n                       (btree_assn k \\<times>\\<^sub>a id_assn) a\n                        (subi, sepi) *\n                       blist_assn k rs zs2 *\n                       p \\<mapsto>\\<^sub>r Btnode (tsil, tsin) ti *\n                       btree_assn k t ti *\n                       true> ins k x ti \\<bind>\n                             case_btupi\n                              (\\<lambda>lp.\n                                  p := Btnode (tsil, tsin) lp \\<bind>\n                                  (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                              (\\<lambda>lp x' rp.\n                                  if length (zs1 @ (subi, sepi) # zs2)\n                                     < 2 * k\n                                  then pfa_append (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     p := Btnode kvs' rp \\<bind> (\\<lambda>_. return (T\\<^sub>i (Some p))))\n                                  else pfa_append_grow' (tsil, tsin)\n  (lp, x') \\<bind>\n (\\<lambda>kvs'.\n     node\\<^sub>i k kvs'\n      rp)) <btupi_assn k\n             (abs_split.node\\<^sub>i k (ls @ (l, w) # (r, sep) # rs)\n               t)>\\<^sub>t", "apply(auto dest!:  mod_starD list_assn_len)[]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <btree_assn k (Node ts t)\n    ti> ins k x ti <btupi_assn k (abs_split.ins k x (Node ts t))>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "text \"The imperative insert refines the abstract insert.\""], ["", "lemma insert_rule:\n  assumes \"k > 0\" \"sorted_less (inorder t)\"\n  shows \"<btree_assn k t ti>\n  insert k x ti\n  <\\<lambda>r. btree_assn k (abs_split.insert k x t) r>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_assn k t\n      ti> local.insert k x\n           ti <btree_assn k (abs_split.insert k x t)>\\<^sub>t", "unfolding insert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_assn k t\n      ti> ins k x ti \\<bind>\n          case_btupi return\n           (\\<lambda>l a r.\n               pfa_init (2 * k) (l, a) 1 \\<bind>\n               (\\<lambda>kvs.\n                   ref (Btnode kvs r) \\<bind>\n                   (\\<lambda>t'.\n                       return\n                        (Some\n                          t')))) <btree_assn k\n                                   (abs_split.insert k x t)>\\<^sub>t", "apply(cases \"abs_split.ins k x t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       abs_split.ins k x t = abs_split.T\\<^sub>i x1 \\<Longrightarrow>\n       <btree_assn k t\n         ti> ins k x ti \\<bind>\n             case_btupi return\n              (\\<lambda>l a r.\n                  pfa_init (2 * k) (l, a) 1 \\<bind>\n                  (\\<lambda>kvs.\n                      ref (Btnode kvs r) \\<bind>\n                      (\\<lambda>t'.\n                          return\n                           (Some\n                             t')))) <btree_assn k\n(abs_split.insert k x t)>\\<^sub>t\n 2. \\<And>x21 x22 x23.\n       abs_split.ins k x t =\n       abs_split.Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       <btree_assn k t\n         ti> ins k x ti \\<bind>\n             case_btupi return\n              (\\<lambda>l a r.\n                  pfa_init (2 * k) (l, a) 1 \\<bind>\n                  (\\<lambda>kvs.\n                      ref (Btnode kvs r) \\<bind>\n                      (\\<lambda>t'.\n                          return\n                           (Some\n                             t')))) <btree_assn k\n(abs_split.insert k x t)>\\<^sub>t", "apply(sep_auto split!: btupi.splits heap: ins_rule[OF assms(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       abs_split.ins k x t =\n       abs_split.Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       <btree_assn k t\n         ti> ins k x ti \\<bind>\n             case_btupi return\n              (\\<lambda>l a r.\n                  pfa_init (2 * k) (l, a) 1 \\<bind>\n                  (\\<lambda>kvs.\n                      ref (Btnode kvs r) \\<bind>\n                      (\\<lambda>t'.\n                          return\n                           (Some\n                             t')))) <btree_assn k\n(abs_split.insert k x t)>\\<^sub>t", "using assms"], ["proof (prove)\nusing this:\n  0 < k\n  sorted_less (inorder t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       abs_split.ins k x t =\n       abs_split.Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       <btree_assn k t\n         ti> ins k x ti \\<bind>\n             case_btupi return\n              (\\<lambda>l a r.\n                  pfa_init (2 * k) (l, a) 1 \\<bind>\n                  (\\<lambda>kvs.\n                      ref (Btnode kvs r) \\<bind>\n                      (\\<lambda>t'.\n                          return\n                           (Some\n                             t')))) <btree_assn k\n(abs_split.insert k x t)>\\<^sub>t", "apply(vcg heap: ins_rule[OF assms(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 xa.\n       \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i x21 x22 x23;\n        0 < k; sorted_less (inorder t)\\<rbrakk>\n       \\<Longrightarrow> <btupi_assn k (abs_split.Up\\<^sub>i x21 x22 x23)\n                           xa *\n                          true> case xa of\n                                T\\<^sub>i x \\<Rightarrow> return x\n                                | Up\\<^sub>i l a r \\<Rightarrow>\n                                    pfa_init (2 * k) (l, a) 1 \\<bind>\n                                    (\\<lambda>kvs.\n  ref (Btnode kvs r) \\<bind>\n  (\\<lambda>t'.\n      return (Some t'))) <btree_assn k (abs_split.insert k x t)>\\<^sub>t", "apply(simp split!: btupi.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x21a x22a x23a.\n       \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i x21 x22 x23;\n        0 < k; sorted_less (inorder t)\\<rbrakk>\n       \\<Longrightarrow> <btree_assn k x21 x21a * id_assn x22 x22a *\n                          btree_assn k x23 x23a *\n                          true> pfa_init (2 * k) (x21a, x22a)\n                                 (Suc 0) \\<bind>\n                                (\\<lambda>kvs.\n                                    ref (Btnode kvs x23a) \\<bind>\n                                    (\\<lambda>t'.\n  return (Some t'))) <btree_assn k (Node [(x21, x22)] x23)>\\<^sub>t", "apply(vcg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i x21 x22 x23;\n        0 < k; sorted_less (inorder t)\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> 2 * k\n 2. \\<And>x21 x22 x23 x21a x22a x23a xa.\n       \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i x21 x22 x23;\n        0 < k; sorted_less (inorder t)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (replicate (Suc 0) (x21a, x22a))\n                           xa *\n                          (btree_assn k x21 x21a * id_assn x22 x22a *\n                           btree_assn k x23 x23a *\n                           true)> ref (Btnode xa x23a) \\<bind>\n                                  (\\<lambda>t'.\nreturn (Some t')) <btree_assn k (Node [(x21, x22)] x23)>\\<^sub>t", "apply auto[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x21a x22a x23a xa.\n       \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i x21 x22 x23;\n        0 < k; sorted_less (inorder t)\\<rbrakk>\n       \\<Longrightarrow> <is_pfa (2 * k) (replicate (Suc 0) (x21a, x22a))\n                           xa *\n                          (btree_assn k x21 x21a * id_assn x22 x22a *\n                           btree_assn k x23 x23a *\n                           true)> ref (Btnode xa x23a) \\<bind>\n                                  (\\<lambda>t'.\nreturn (Some t')) <btree_assn k (Node [(x21, x22)] x23)>\\<^sub>t", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x21a x22a x23a xa xaa xb.\n       \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i x21 x22 x23;\n        0 < k; sorted_less (inorder t)\\<rbrakk>\n       \\<Longrightarrow> xaa \\<mapsto>\\<^sub>r Btnode xa x23a *\n                         is_pfa (2 * k) (replicate (Suc 0) (x21a, x22a))\n                          xa *\n                         btree_assn k x21 x21a *\n                         id_assn x22 x22a *\n                         btree_assn k x23 x23a *\n                         true *\n                         \\<up> (xb = Some xaa) \\<Longrightarrow>\\<^sub>A\n                         btree_assn k (Node [(x21, x22)] x23) xb * true", "apply auto[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x21a x22a x23a a b xa.\n       \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i x21 x22 x23;\n        0 < k; sorted_less (inorder t)\\<rbrakk>\n       \\<Longrightarrow> xa \\<mapsto>\\<^sub>r Btnode (a, b) x23a *\n                         is_pfa (2 * k) [(x21a, x22a)] (a, b) *\n                         btree_assn k x21 x21a *\n                         id_assn x22 x22a *\n                         btree_assn k x23 x23a *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Atsi ti tsi'.\n                            xa \\<mapsto>\\<^sub>r Btnode tsi ti *\n                            btree_assn k x23 ti *\n                            is_pfa (2 * k) tsi' tsi *\n                            blist_assn k [(x21, x22)] tsi' *\n                            true", "subgoal for l a r li ai ri tsa tsn ti"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; 0 < k;\n     sorted_less (inorder t)\\<rbrakk>\n    \\<Longrightarrow> ti \\<mapsto>\\<^sub>r Btnode (tsa, tsn) ri *\n                      is_pfa (2 * k) [(li, ai)] (tsa, tsn) *\n                      btree_assn k l li *\n                      id_assn a ai *\n                      btree_assn k r ri *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsi ti tsi'.\n                         ti \\<mapsto>\\<^sub>r Btnode tsi ti *\n                         btree_assn k r ti *\n                         is_pfa (2 * k) tsi' tsi *\n                         blist_assn k [(l, a)] tsi' *\n                         true", "apply(rule ent_ex_postI[where x=\"(tsa,tsn)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; 0 < k;\n     sorted_less (inorder t)\\<rbrakk>\n    \\<Longrightarrow> ti \\<mapsto>\\<^sub>r Btnode (tsa, tsn) ri *\n                      is_pfa (2 * k) [(li, ai)] (tsa, tsn) *\n                      btree_assn k l li *\n                      id_assn a ai *\n                      btree_assn k r ri *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Ati tsi'.\n                         ti \\<mapsto>\\<^sub>r Btnode (tsa, tsn) ti *\n                         btree_assn k r ti *\n                         is_pfa (2 * k) tsi' (tsa, tsn) *\n                         blist_assn k [(l, a)] tsi' *\n                         true", "apply(rule ent_ex_postI[where x=\"ri\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; 0 < k;\n     sorted_less (inorder t)\\<rbrakk>\n    \\<Longrightarrow> ti \\<mapsto>\\<^sub>r Btnode (tsa, tsn) ri *\n                      is_pfa (2 * k) [(li, ai)] (tsa, tsn) *\n                      btree_assn k l li *\n                      id_assn a ai *\n                      btree_assn k r ri *\n                      true \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Atsi'.\n                         ti \\<mapsto>\\<^sub>r Btnode (tsa, tsn) ri *\n                         btree_assn k r ri *\n                         is_pfa (2 * k) tsi' (tsa, tsn) *\n                         blist_assn k [(l, a)] tsi' *\n                         true", "apply(rule ent_ex_postI[where x=\"[(li, ai)]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_split.ins k x t = abs_split.Up\\<^sub>i l a r; 0 < k;\n     sorted_less (inorder t)\\<rbrakk>\n    \\<Longrightarrow> ti \\<mapsto>\\<^sub>r Btnode (tsa, tsn) ri *\n                      is_pfa (2 * k) [(li, ai)] (tsa, tsn) *\n                      btree_assn k l li *\n                      id_assn a ai *\n                      btree_assn k r ri *\n                      true \\<Longrightarrow>\\<^sub>A\n                      ti \\<mapsto>\\<^sub>r Btnode (tsa, tsn) ri *\n                      btree_assn k r ri *\n                      is_pfa (2 * k) [(li, ai)] (tsa, tsn) *\n                      blist_assn k [(l, a)] [(li, ai)] *\n                      true", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \"The \\\"pure\\\" resulting rule follows automatically.\""], ["", "lemma insert_rule':\n  shows \"<btree_assn (Suc k) t ti * \\<up>(abs_split.invar_inorder (Suc k) t \\<and> sorted_less (inorder t))>\n  insert (Suc k) x ti\n  <\\<lambda>ri.\\<exists>\\<^sub>Ar. btree_assn (Suc k) r ri * \\<up>(abs_split.invar_inorder (Suc k) r \\<and> sorted_less (inorder r) \\<and> inorder r = (ins_list x (inorder t)))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_assn (Suc k) t ti *\n     \\<up>\n      (abs_split.invar_inorder (Suc k) t \\<and>\n       sorted_less\n        (inorder\n          t))> local.insert (Suc k) x\n                ti <\\<lambda>r.\n                       \\<exists>\\<^sub>Ara.\n                          btree_assn (Suc k) ra r *\n                          \\<up>\n                           (abs_split.invar_inorder (Suc k) ra \\<and>\n                            sorted_less (inorder ra) \\<and>\n                            inorder ra = ins_list x (inorder t))>\\<^sub>t", "using abs_split.insert_bal abs_split.insert_order abs_split.insert_inorder"], ["proof (prove)\nusing this:\n  bal ?t \\<Longrightarrow> bal (abs_split.insert ?k ?x ?t)\n  \\<lbrakk>0 < ?k; root_order ?k ?t\\<rbrakk>\n  \\<Longrightarrow> root_order ?k (abs_split.insert ?k ?x ?t)\n  sorted_less (inorder ?t) \\<Longrightarrow>\n  inorder (abs_split.insert ?k ?x ?t) = ins_list ?x (inorder ?t)\n\ngoal (1 subgoal):\n 1. <btree_assn (Suc k) t ti *\n     \\<up>\n      (abs_split.invar_inorder (Suc k) t \\<and>\n       sorted_less\n        (inorder\n          t))> local.insert (Suc k) x\n                ti <\\<lambda>r.\n                       \\<exists>\\<^sub>Ara.\n                          btree_assn (Suc k) ra r *\n                          \\<up>\n                           (abs_split.invar_inorder (Suc k) ra \\<and>\n                            sorted_less (inorder ra) \\<and>\n                            inorder ra = ins_list x (inorder t))>\\<^sub>t", "by (sep_auto heap: insert_rule simp add: sorted_ins_list)"], ["", "lemma node\\<^sub>i_rule_ins: \"\\<lbrakk>2*k \\<le> c; c \\<le> 4*k+1; length ls = length lsi\\<rbrakk> \\<Longrightarrow>\n <is_pfa c (lsi @ (li, ai) # rsi) (aa, al) *\n   blist_assn k ls lsi *\n   btree_assn k l li *\n   id_assn a ai *\n   blist_assn k rs rsi *\n   btree_assn k t ti> node\\<^sub>i k (aa, al)\n          ti <btupi_assn k (abs_split.node\\<^sub>i k (ls @ (l, a) # rs) t)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1;\n     length ls = length lsi\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # rsi) (aa, al) *\n                       blist_assn k ls lsi *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       blist_assn k rs rsi *\n                       btree_assn k t\n                        ti> node\\<^sub>i k (aa, al)\n                             ti <btupi_assn k\n                                  (abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # rs) t)>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1;\n     length ls = length lsi\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # rsi) (aa, al) *\n                       blist_assn k ls lsi *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       blist_assn k rs rsi *\n                       btree_assn k t\n                        ti> node\\<^sub>i k (aa, al)\n                             ti <btupi_assn k\n                                  (abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # rs) t)>\\<^sub>t", "assume [simp]: \"2*k \\<le> c\" \"c \\<le> 4*k+1\" \"length ls = length lsi\""], ["proof (state)\nthis:\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n  length ls = length lsi\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1;\n     length ls = length lsi\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # rsi) (aa, al) *\n                       blist_assn k ls lsi *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       blist_assn k rs rsi *\n                       btree_assn k t\n                        ti> node\\<^sub>i k (aa, al)\n                             ti <btupi_assn k\n                                  (abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # rs) t)>\\<^sub>t", "moreover"], ["proof (state)\nthis:\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n  length ls = length lsi\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1;\n     length ls = length lsi\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # rsi) (aa, al) *\n                       blist_assn k ls lsi *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       blist_assn k rs rsi *\n                       btree_assn k t\n                        ti> node\\<^sub>i k (aa, al)\n                             ti <btupi_assn k\n                                  (abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # rs) t)>\\<^sub>t", "note node\\<^sub>i_rule[of k c \"(lsi @ (li, ai) # rsi)\" aa al \"(ls @ (l, a) # rs)\" t ti]"], ["proof (state)\nthis:\n  \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n  \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # rsi) (aa, al) *\n                     blist_assn k (ls @ (l, a) # rs)\n                      (lsi @ (li, ai) # rsi) *\n                     btree_assn k t\n                      ti> node\\<^sub>i k (aa, al)\n                           ti <btupi_assn k\n                                (abs_split.node\\<^sub>i k (ls @ (l, a) # rs)\n                                  t)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1;\n     length ls = length lsi\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # rsi) (aa, al) *\n                       blist_assn k ls lsi *\n                       btree_assn k l li *\n                       id_assn a ai *\n                       blist_assn k rs rsi *\n                       btree_assn k t\n                        ti> node\\<^sub>i k (aa, al)\n                             ti <btupi_assn k\n                                  (abs_split.node\\<^sub>i k\n                                    (ls @ (l, a) # rs) t)>\\<^sub>t", "ultimately"], ["proof (chain)\npicking this:\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n  length ls = length lsi\n  \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n  \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # rsi) (aa, al) *\n                     blist_assn k (ls @ (l, a) # rs)\n                      (lsi @ (li, ai) # rsi) *\n                     btree_assn k t\n                      ti> node\\<^sub>i k (aa, al)\n                           ti <btupi_assn k\n                                (abs_split.node\\<^sub>i k (ls @ (l, a) # rs)\n                                  t)>\\<^sub>t", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * k \\<le> c\n  c \\<le> 4 * k + 1\n  length ls = length lsi\n  \\<lbrakk>2 * k \\<le> c; c \\<le> 4 * k + 1\\<rbrakk>\n  \\<Longrightarrow> <is_pfa c (lsi @ (li, ai) # rsi) (aa, al) *\n                     blist_assn k (ls @ (l, a) # rs)\n                      (lsi @ (li, ai) # rsi) *\n                     btree_assn k t\n                      ti> node\\<^sub>i k (aa, al)\n                           ti <btupi_assn k\n                                (abs_split.node\\<^sub>i k (ls @ (l, a) # rs)\n                                  t)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. <is_pfa c (lsi @ (li, ai) # rsi) (aa, al) * blist_assn k ls lsi *\n     btree_assn k l li *\n     id_assn a ai *\n     blist_assn k rs rsi *\n     btree_assn k t\n      ti> node\\<^sub>i k (aa, al)\n           ti <btupi_assn k\n                (abs_split.node\\<^sub>i k (ls @ (l, a) # rs) t)>\\<^sub>t", "by (simp add: mult.left_assoc list_assn_aux_append_Cons)"], ["proof (state)\nthis:\n  <is_pfa c (lsi @ (li, ai) # rsi) (aa, al) * blist_assn k ls lsi *\n   btree_assn k l li *\n   id_assn a ai *\n   blist_assn k rs rsi *\n   btree_assn k t\n    ti> node\\<^sub>i k (aa, al)\n         ti <btupi_assn k\n              (abs_split.node\\<^sub>i k (ls @ (l, a) # rs) t)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma empty_rule:\n  shows \"<emp>\n  empty\n  <\\<lambda>r. btree_assn k (abs_split.empty_btree) r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> local.empty <btree_assn k abs_split.empty_btree>", "apply(subst empty_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> return None <btree_assn k abs_split.empty_btree>", "apply(sep_auto simp add: abs_split.empty_btree_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}