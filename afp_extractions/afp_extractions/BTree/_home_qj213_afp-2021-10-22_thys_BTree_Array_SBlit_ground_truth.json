{"file_name": "/home/qj213/afp-2021-10-22/thys/BTree/Array_SBlit.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BTree", "problem_names": ["lemma sblit_rule[sep_heap_rules]:\n  assumes LEN:\n    \"si+len \\<le> length lsrc\"\n    and DST_SM: \"di \\<le> si\"\n  shows\n    \"< src \\<mapsto>\\<^sub>a lsrc  >\n    sblit src si di len\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take di lsrc @ take len (drop si lsrc) @ drop (di+len) lsrc)\n    >\"", "lemma rblit_rule[sep_heap_rules]:\n  assumes LEN: \"si+len \\<le> length lsrc\" \"di+len \\<le> length ldst\"\n  shows\n    \"< src \\<mapsto>\\<^sub>a lsrc \n      * dst \\<mapsto>\\<^sub>a ldst >\n    rblit src si dst di len\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a lsrc \n      * dst \\<mapsto>\\<^sub>a (take di ldst @ take len (drop si lsrc) @ drop (di+len) ldst)\n    >\"", "lemma srblit_rule[sep_heap_rules]:\n  assumes LEN:\n    \"di+len \\<le> length lsrc\"\n    and DST_GR: \"di \\<ge> si\"\n  shows\n    \"< src \\<mapsto>\\<^sub>a lsrc  >\n    srblit src si di len\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take di lsrc @ take len (drop si lsrc) @ drop (di+len) lsrc)\n    >\"", "lemma safe_sblit_rule[sep_heap_rules]:\n  assumes LEN:\n    \"len > 0 \\<longrightarrow> di+len \\<le> length lsrc \\<and> si+len \\<le> length lsrc\"\n  shows\n    \"< src \\<mapsto>\\<^sub>a lsrc  >\n    safe_sblit src si di len\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take di lsrc @ take len (drop si lsrc) @ drop (di+len) lsrc)\n    >\"", "lemma [code]:\n  \"safe_sblit src si di len \n      = safe_sblit' src (integer_of_nat si) (integer_of_nat di) \n          (integer_of_nat len)\"", "lemma array_shr_rule[sep_heap_rules]:\n  \"< src \\<mapsto>\\<^sub>a lsrc  >\n    array_shr src i k\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take (i+k) lsrc @ take (length lsrc - (i+k)) (drop i lsrc))\n    >\"", "lemma array_shr_rule_alt:\n  \"< src \\<mapsto>\\<^sub>a lsrc  >\n    array_shr src i k\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take (length lsrc) (take (i+k) lsrc @ (drop i lsrc)))\n    >\"", "lemma array_shl_rule[sep_heap_rules]:\n  \"\n    < src \\<mapsto>\\<^sub>a lsrc  >\n    array_shl src i k\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take (i-k) lsrc @ (drop i lsrc) @ drop (i - k + (length lsrc - i)) lsrc)\n    >\"", "lemma array_shl_rule_alt:\n  \"\n    \\<lbrakk>i \\<le> length lsrc; k \\<le> i\\<rbrakk> \\<Longrightarrow>\n    < src \\<mapsto>\\<^sub>a lsrc  >\n    array_shl src i k\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take (i-k) lsrc @ (drop i lsrc) @ drop (length lsrc - k) lsrc)\n    >\""], "translations": [["", "lemma sblit_rule[sep_heap_rules]:\n  assumes LEN:\n    \"si+len \\<le> length lsrc\"\n    and DST_SM: \"di \\<le> si\"\n  shows\n    \"< src \\<mapsto>\\<^sub>a lsrc  >\n    sblit src si di len\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take di lsrc @ take len (drop si lsrc) @ drop (di+len) lsrc)\n    >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> sblit src si di len\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>", "unfolding sblit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> blit src si src di len\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>", "using LEN DST_SM"], ["proof (prove)\nusing this:\n  si + len \\<le> length lsrc\n  di \\<le> si\n\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> blit src si src di len\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>", "proof (induction len arbitrary: lsrc si di)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>lsrc si di.\n       \\<lbrakk>si + 0 \\<le> length lsrc; di \\<le> si\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc> blit src si src di 0\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take 0 (drop si lsrc) @ drop (di + 0) lsrc)>\n 2. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>si + len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     blit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        si + Suc len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         blit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "case 0"], ["proof (state)\nthis:\n  si + 0 \\<le> length lsrc\n  di \\<le> si\n\ngoal (2 subgoals):\n 1. \\<And>lsrc si di.\n       \\<lbrakk>si + 0 \\<le> length lsrc; di \\<le> si\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc> blit src si src di 0\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take 0 (drop si lsrc) @ drop (di + 0) lsrc)>\n 2. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>si + len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     blit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        si + Suc len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         blit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "thus ?case"], ["proof (prove)\nusing this:\n  si + 0 \\<le> length lsrc\n  di \\<le> si\n\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> blit src si src di 0\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take di lsrc @ take 0 (drop si lsrc) @ drop (di + 0) lsrc)>", "by sep_auto"], ["proof (state)\nthis:\n  <src \\<mapsto>\\<^sub>a lsrc> blit src si src di 0\n  <\\<lambda>_.\n      src \\<mapsto>\\<^sub>a\n      (take di lsrc @ take 0 (drop si lsrc) @ drop (di + 0) lsrc)>\n\ngoal (1 subgoal):\n 1. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>si + len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     blit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        si + Suc len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         blit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>si + len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     blit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        si + Suc len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         blit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "case (Suc len)"], ["proof (state)\nthis:\n  \\<lbrakk>?si + len \\<le> length ?lsrc; ?di \\<le> ?si\\<rbrakk>\n  \\<Longrightarrow> <src \\<mapsto>\\<^sub>a ?lsrc> blit src ?si src ?di len\n                    <\\<lambda>_.\n                        src \\<mapsto>\\<^sub>a\n                        (take ?di ?lsrc @\n                         take len (drop ?si ?lsrc) @\n                         drop (?di + len) ?lsrc)>\n  si + Suc len \\<le> length lsrc\n  di \\<le> si\n\ngoal (1 subgoal):\n 1. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>si + len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     blit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        si + Suc len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         blit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "note [sep_heap_rules] = Suc.IH"], ["proof (state)\nthis:\n  \\<lbrakk>?si + len \\<le> length ?lsrc; ?di \\<le> ?si\\<rbrakk>\n  \\<Longrightarrow> <src \\<mapsto>\\<^sub>a ?lsrc> blit src ?si src ?di len\n                    <\\<lambda>_.\n                        src \\<mapsto>\\<^sub>a\n                        (take ?di ?lsrc @\n                         take len (drop ?si ?lsrc) @\n                         drop (?di + len) ?lsrc)>\n\ngoal (1 subgoal):\n 1. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>si + len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     blit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        si + Suc len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         blit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "have [simp]: \"\\<And>x. lsrc ! si # take len (drop (Suc si) lsrc) @ x\n      = take (Suc len) (drop si lsrc) @ x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       lsrc ! si # take len (drop (Suc si) lsrc) @ x =\n       take (Suc len) (drop si lsrc) @ x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. lsrc ! si # take len (drop (Suc si) lsrc) =\n    take (Suc len) (drop si lsrc)", "by (metis Suc.prems(1) add_Suc_right Cons_nth_drop_Suc\n        less_Suc_eq_le add.commute not_less_eq take_Suc_Cons \n        Nat.trans_le_add2)"], ["proof (state)\nthis:\n  lsrc ! si # take len (drop (Suc si) lsrc) @ ?x =\n  take (Suc len) (drop si lsrc) @ ?x\n\ngoal (1 subgoal):\n 1. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>si + len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     blit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        si + Suc len \\<le> length lsrc; di \\<le> si\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         blit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "from Suc.prems"], ["proof (chain)\npicking this:\n  si + Suc len \\<le> length lsrc\n  di \\<le> si", "show ?case"], ["proof (prove)\nusing this:\n  si + Suc len \\<le> length lsrc\n  di \\<le> si\n\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> blit src si src di (Suc len)\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take di lsrc @\n         take (Suc len) (drop si lsrc) @ drop (di + Suc len) lsrc)>", "by (sep_auto simp: take_update_last drop_upd_irrelevant)"], ["proof (state)\nthis:\n  <src \\<mapsto>\\<^sub>a lsrc> blit src si src di (Suc len)\n  <\\<lambda>_.\n      src \\<mapsto>\\<^sub>a\n      (take di lsrc @\n       take (Suc len) (drop si lsrc) @ drop (di + Suc len) lsrc)>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"A reverse blit\""], ["", "text \"The function rblit may be used to copy elements a defined offset to the right\""], ["", "(* Right BLIT or Reverse BLIT *)"], ["", "primrec rblit :: \"_ array \\<Rightarrow> nat \\<Rightarrow> _ array \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> unit Heap\" where\n  \"rblit _ _ _ _ 0 = return ()\"\n| \"rblit src si dst di (Suc l) = do {\n      x \\<leftarrow> Array.nth src (si+l);\n      Array.upd (di+l) x dst;\n      rblit src si dst di l\n    }\""], ["", "text \"For separated arrays it is equivalent to normal blit.\n      The proof follows similarly to the corresponding proof for blit.\""], ["", "lemma rblit_rule[sep_heap_rules]:\n  assumes LEN: \"si+len \\<le> length lsrc\" \"di+len \\<le> length ldst\"\n  shows\n    \"< src \\<mapsto>\\<^sub>a lsrc \n      * dst \\<mapsto>\\<^sub>a ldst >\n    rblit src si dst di len\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a lsrc \n      * dst \\<mapsto>\\<^sub>a (take di ldst @ take len (drop si lsrc) @ drop (di+len) ldst)\n    >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc * dst \\<mapsto>\\<^sub>a ldst>\n    rblit src si dst di len\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a lsrc *\n        dst \\<mapsto>\\<^sub>a\n        (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>", "using LEN"], ["proof (prove)\nusing this:\n  si + len \\<le> length lsrc\n  di + len \\<le> length ldst\n\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc * dst \\<mapsto>\\<^sub>a ldst>\n    rblit src si dst di len\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a lsrc *\n        dst \\<mapsto>\\<^sub>a\n        (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>", "proof (induction len arbitrary: ldst)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ldst.\n       \\<lbrakk>si + 0 \\<le> length lsrc; di + 0 \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         rblit src si dst di 0\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take 0 (drop si lsrc) @ drop (di + 0) ldst)>\n 2. \\<And>len ldst.\n       \\<lbrakk>\\<And>ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     rblit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         rblit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "case 0"], ["proof (state)\nthis:\n  si + 0 \\<le> length lsrc\n  di + 0 \\<le> length ldst\n\ngoal (2 subgoals):\n 1. \\<And>ldst.\n       \\<lbrakk>si + 0 \\<le> length lsrc; di + 0 \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         rblit src si dst di 0\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take 0 (drop si lsrc) @ drop (di + 0) ldst)>\n 2. \\<And>len ldst.\n       \\<lbrakk>\\<And>ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     rblit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         rblit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "thus ?case"], ["proof (prove)\nusing this:\n  si + 0 \\<le> length lsrc\n  di + 0 \\<le> length ldst\n\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc * dst \\<mapsto>\\<^sub>a ldst>\n    rblit src si dst di 0\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a lsrc *\n        dst \\<mapsto>\\<^sub>a\n        (take di ldst @ take 0 (drop si lsrc) @ drop (di + 0) ldst)>", "by sep_auto"], ["proof (state)\nthis:\n  <src \\<mapsto>\\<^sub>a lsrc * dst \\<mapsto>\\<^sub>a ldst>\n  rblit src si dst di 0\n  <\\<lambda>_.\n      src \\<mapsto>\\<^sub>a lsrc *\n      dst \\<mapsto>\\<^sub>a\n      (take di ldst @ take 0 (drop si lsrc) @ drop (di + 0) ldst)>\n\ngoal (1 subgoal):\n 1. \\<And>len ldst.\n       \\<lbrakk>\\<And>ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     rblit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         rblit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>len ldst.\n       \\<lbrakk>\\<And>ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     rblit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         rblit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "case (Suc len)"], ["proof (state)\nthis:\n  \\<lbrakk>si + len \\<le> length lsrc; di + len \\<le> length ?ldst\\<rbrakk>\n  \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                     dst \\<mapsto>\\<^sub>a ?ldst>\n                    rblit src si dst di len\n                    <\\<lambda>_.\n                        src \\<mapsto>\\<^sub>a lsrc *\n                        dst \\<mapsto>\\<^sub>a\n                        (take di ?ldst @\n                         take len (drop si lsrc) @ drop (di + len) ?ldst)>\n  si + Suc len \\<le> length lsrc\n  di + Suc len \\<le> length ldst\n\ngoal (1 subgoal):\n 1. \\<And>len ldst.\n       \\<lbrakk>\\<And>ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     rblit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         rblit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "note [sep_heap_rules] = Suc.IH"], ["proof (state)\nthis:\n  \\<lbrakk>si + len \\<le> length lsrc; di + len \\<le> length ?ldst\\<rbrakk>\n  \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                     dst \\<mapsto>\\<^sub>a ?ldst>\n                    rblit src si dst di len\n                    <\\<lambda>_.\n                        src \\<mapsto>\\<^sub>a lsrc *\n                        dst \\<mapsto>\\<^sub>a\n                        (take di ?ldst @\n                         take len (drop si lsrc) @ drop (di + len) ?ldst)>\n\ngoal (1 subgoal):\n 1. \\<And>len ldst.\n       \\<lbrakk>\\<And>ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     rblit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         rblit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "have [simp]: \"drop (di + len) (ldst[di + len := lsrc ! (si + len)])\n      = lsrc ! (si + len) #  drop (Suc (di + len)) ldst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (di + len) (ldst[di + len := lsrc ! (si + len)]) =\n    lsrc ! (si + len) # drop (Suc (di + len)) ldst", "by (metis Cons_nth_drop_Suc Suc.prems(2) Suc_le_eq add_Suc_right drop_upd_irrelevant length_list_update lessI nth_list_update_eq)"], ["proof (state)\nthis:\n  drop (di + len) (ldst[di + len := lsrc ! (si + len)]) =\n  lsrc ! (si + len) # drop (Suc (di + len)) ldst\n\ngoal (1 subgoal):\n 1. \\<And>len ldst.\n       \\<lbrakk>\\<And>ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     rblit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         rblit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "have \"take len (drop si lsrc) @ [lsrc ! (si + len)] = take (Suc len) (drop si lsrc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take len (drop si lsrc) @ [lsrc ! (si + len)] =\n    take (Suc len) (drop si lsrc)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take len (drop si lsrc) @ [lsrc ! (si + len)] =\n    take (Suc len) (drop si lsrc)", "have \"len < length (drop si lsrc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len < length (drop si lsrc)", "using Suc.prems(1)"], ["proof (prove)\nusing this:\n  si + Suc len \\<le> length lsrc\n\ngoal (1 subgoal):\n 1. len < length (drop si lsrc)", "by force"], ["proof (state)\nthis:\n  len < length (drop si lsrc)\n\ngoal (1 subgoal):\n 1. take len (drop si lsrc) @ [lsrc ! (si + len)] =\n    take (Suc len) (drop si lsrc)", "then"], ["proof (chain)\npicking this:\n  len < length (drop si lsrc)", "show \"take len (drop si lsrc) @ [lsrc ! (si + len)] = take (Suc len) (drop si lsrc)\""], ["proof (prove)\nusing this:\n  len < length (drop si lsrc)\n\ngoal (1 subgoal):\n 1. take len (drop si lsrc) @ [lsrc ! (si + len)] =\n    take (Suc len) (drop si lsrc)", "by (metis (no_types) Suc.prems(1) add_leD1 nth_drop take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take len (drop si lsrc) @ [lsrc ! (si + len)] =\n  take (Suc len) (drop si lsrc)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  take len (drop si lsrc) @ [lsrc ! (si + len)] =\n  take (Suc len) (drop si lsrc)\n\ngoal (1 subgoal):\n 1. \\<And>len ldst.\n       \\<lbrakk>\\<And>ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     rblit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         rblit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "then"], ["proof (chain)\npicking this:\n  take len (drop si lsrc) @ [lsrc ! (si + len)] =\n  take (Suc len) (drop si lsrc)", "have [simp]: \"\\<And>x. take len (drop si lsrc) @\n     lsrc ! (si + len) # x = take (Suc len) (drop si lsrc) @ x\""], ["proof (prove)\nusing this:\n  take len (drop si lsrc) @ [lsrc ! (si + len)] =\n  take (Suc len) (drop si lsrc)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       take len (drop si lsrc) @ lsrc ! (si + len) # x =\n       take (Suc len) (drop si lsrc) @ x", "by simp"], ["proof (state)\nthis:\n  take len (drop si lsrc) @ lsrc ! (si + len) # ?x =\n  take (Suc len) (drop si lsrc) @ ?x\n\ngoal (1 subgoal):\n 1. \\<And>len ldst.\n       \\<lbrakk>\\<And>ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     rblit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         rblit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "from Suc.prems"], ["proof (chain)\npicking this:\n  si + Suc len \\<le> length lsrc\n  di + Suc len \\<le> length ldst", "show ?case"], ["proof (prove)\nusing this:\n  si + Suc len \\<le> length lsrc\n  di + Suc len \\<le> length ldst\n\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc * dst \\<mapsto>\\<^sub>a ldst>\n    rblit src si dst di (Suc len)\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a lsrc *\n        dst \\<mapsto>\\<^sub>a\n        (take di ldst @\n         take (Suc len) (drop si lsrc) @ drop (di + Suc len) ldst)>", "by (sep_auto simp: take_update_last drop_upd_irrelevant)"], ["proof (state)\nthis:\n  <src \\<mapsto>\\<^sub>a lsrc * dst \\<mapsto>\\<^sub>a ldst>\n  rblit src si dst di (Suc len)\n  <\\<lambda>_.\n      src \\<mapsto>\\<^sub>a lsrc *\n      dst \\<mapsto>\\<^sub>a\n      (take di ldst @\n       take (Suc len) (drop si lsrc) @ drop (di + Suc len) ldst)>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"srblit a s d l \\<equiv> rblit a s a d l\""], ["", "text \"However, within arrays we can now copy to the right.\""], ["", "lemma srblit_rule[sep_heap_rules]:\n  assumes LEN:\n    \"di+len \\<le> length lsrc\"\n    and DST_GR: \"di \\<ge> si\"\n  shows\n    \"< src \\<mapsto>\\<^sub>a lsrc  >\n    srblit src si di len\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take di lsrc @ take len (drop si lsrc) @ drop (di+len) lsrc)\n    >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> srblit src si di len\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>", "unfolding srblit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> rblit src si src di len\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>", "using LEN DST_GR"], ["proof (prove)\nusing this:\n  di + len \\<le> length lsrc\n  si \\<le> di\n\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> rblit src si src di len\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>", "proof (induction len arbitrary: lsrc si di)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>lsrc si di.\n       \\<lbrakk>di + 0 \\<le> length lsrc; si \\<le> di\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc> rblit src si src di 0\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take 0 (drop si lsrc) @ drop (di + 0) lsrc)>\n 2. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>di + len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     rblit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        di + Suc len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         rblit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "case 0"], ["proof (state)\nthis:\n  di + 0 \\<le> length lsrc\n  si \\<le> di\n\ngoal (2 subgoals):\n 1. \\<And>lsrc si di.\n       \\<lbrakk>di + 0 \\<le> length lsrc; si \\<le> di\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc> rblit src si src di 0\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take 0 (drop si lsrc) @ drop (di + 0) lsrc)>\n 2. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>di + len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     rblit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        di + Suc len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         rblit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "thus ?case"], ["proof (prove)\nusing this:\n  di + 0 \\<le> length lsrc\n  si \\<le> di\n\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> rblit src si src di 0\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take di lsrc @ take 0 (drop si lsrc) @ drop (di + 0) lsrc)>", "by sep_auto"], ["proof (state)\nthis:\n  <src \\<mapsto>\\<^sub>a lsrc> rblit src si src di 0\n  <\\<lambda>_.\n      src \\<mapsto>\\<^sub>a\n      (take di lsrc @ take 0 (drop si lsrc) @ drop (di + 0) lsrc)>\n\ngoal (1 subgoal):\n 1. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>di + len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     rblit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        di + Suc len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         rblit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>di + len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     rblit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        di + Suc len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         rblit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "case (Suc len)"], ["proof (state)\nthis:\n  \\<lbrakk>?di + len \\<le> length ?lsrc; ?si \\<le> ?di\\<rbrakk>\n  \\<Longrightarrow> <src \\<mapsto>\\<^sub>a ?lsrc> rblit src ?si src ?di len\n                    <\\<lambda>_.\n                        src \\<mapsto>\\<^sub>a\n                        (take ?di ?lsrc @\n                         take len (drop ?si ?lsrc) @\n                         drop (?di + len) ?lsrc)>\n  di + Suc len \\<le> length lsrc\n  si \\<le> di\n\ngoal (1 subgoal):\n 1. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>di + len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     rblit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        di + Suc len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         rblit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "note [sep_heap_rules] = Suc.IH"], ["proof (state)\nthis:\n  \\<lbrakk>?di + len \\<le> length ?lsrc; ?si \\<le> ?di\\<rbrakk>\n  \\<Longrightarrow> <src \\<mapsto>\\<^sub>a ?lsrc> rblit src ?si src ?di len\n                    <\\<lambda>_.\n                        src \\<mapsto>\\<^sub>a\n                        (take ?di ?lsrc @\n                         take len (drop ?si ?lsrc) @\n                         drop (?di + len) ?lsrc)>\n\ngoal (1 subgoal):\n 1. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>di + len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     rblit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        di + Suc len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         rblit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "have[simp]: \"take len (drop si (lsrc[di + len := lsrc ! (si + len)]))\n        = take len (drop si lsrc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take len (drop si (lsrc[di + len := lsrc ! (si + len)])) =\n    take len (drop si lsrc)", "sledgehammer"], ["proof (prove)\ngoal (1 subgoal):\n 1. take len (drop si (lsrc[di + len := lsrc ! (si + len)])) =\n    take len (drop si lsrc)", "by (metis Suc.prems(2) ab_semigroup_add_class.add.commute add_le_cancel_right take_drop take_update_cancel)"], ["proof (state)\nthis:\n  take len (drop si (lsrc[di + len := lsrc ! (si + len)])) =\n  take len (drop si lsrc)\n\ngoal (1 subgoal):\n 1. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>di + len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     rblit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        di + Suc len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         rblit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "have [simp]: \"drop (di + len) (lsrc[di + len := lsrc ! (si + len)])\n         = lsrc ! (si+len) # drop (Suc di + len) lsrc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (di + len) (lsrc[di + len := lsrc ! (si + len)]) =\n    lsrc ! (si + len) # drop (Suc di + len) lsrc", "by (metis Suc.prems(1) add_Suc_right add_Suc_shift add_less_cancel_left append_take_drop_id le_imp_less_Suc le_refl plus_1_eq_Suc same_append_eq take_update_cancel upd_conv_take_nth_drop)"], ["proof (state)\nthis:\n  drop (di + len) (lsrc[di + len := lsrc ! (si + len)]) =\n  lsrc ! (si + len) # drop (Suc di + len) lsrc\n\ngoal (1 subgoal):\n 1. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>di + len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     rblit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        di + Suc len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         rblit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "have \"take len (drop si lsrc) @\n     [lsrc ! (si + len)] = take (Suc len) (drop si lsrc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take len (drop si lsrc) @ [lsrc ! (si + len)] =\n    take (Suc len) (drop si lsrc)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take len (drop si lsrc) @ [lsrc ! (si + len)] =\n    take (Suc len) (drop si lsrc)", "have \"len < length lsrc - si\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len < length lsrc - si", "using Suc.prems(1) Suc.prems(2)"], ["proof (prove)\nusing this:\n  di + Suc len \\<le> length lsrc\n  si \\<le> di\n\ngoal (1 subgoal):\n 1. len < length lsrc - si", "by linarith"], ["proof (state)\nthis:\n  len < length lsrc - si\n\ngoal (1 subgoal):\n 1. take len (drop si lsrc) @ [lsrc ! (si + len)] =\n    take (Suc len) (drop si lsrc)", "then"], ["proof (chain)\npicking this:\n  len < length lsrc - si", "show ?thesis"], ["proof (prove)\nusing this:\n  len < length lsrc - si\n\ngoal (1 subgoal):\n 1. take len (drop si lsrc) @ [lsrc ! (si + len)] =\n    take (Suc len) (drop si lsrc)", "by (metis (no_types) Suc.prems(1) Suc.prems(2) add_leD1 le_add_diff_inverse length_drop nth_drop take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take len (drop si lsrc) @ [lsrc ! (si + len)] =\n  take (Suc len) (drop si lsrc)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  take len (drop si lsrc) @ [lsrc ! (si + len)] =\n  take (Suc len) (drop si lsrc)\n\ngoal (1 subgoal):\n 1. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>di + len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     rblit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        di + Suc len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         rblit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "then"], ["proof (chain)\npicking this:\n  take len (drop si lsrc) @ [lsrc ! (si + len)] =\n  take (Suc len) (drop si lsrc)", "have [simp]: \"\\<And>x. take len (drop si lsrc) @\n     lsrc ! (si + len) # x = take (Suc len) (drop si lsrc) @ x\""], ["proof (prove)\nusing this:\n  take len (drop si lsrc) @ [lsrc ! (si + len)] =\n  take (Suc len) (drop si lsrc)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       take len (drop si lsrc) @ lsrc ! (si + len) # x =\n       take (Suc len) (drop si lsrc) @ x", "by simp"], ["proof (state)\nthis:\n  take len (drop si lsrc) @ lsrc ! (si + len) # ?x =\n  take (Suc len) (drop si lsrc) @ ?x\n\ngoal (1 subgoal):\n 1. \\<And>len lsrc si di.\n       \\<lbrakk>\\<And>lsrc si di.\n                   \\<lbrakk>di + len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                                     rblit src si src di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a\n   (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>;\n        di + Suc len \\<le> length lsrc; si \\<le> di\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         rblit src si src di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) lsrc)>", "from Suc.prems"], ["proof (chain)\npicking this:\n  di + Suc len \\<le> length lsrc\n  si \\<le> di", "show ?case"], ["proof (prove)\nusing this:\n  di + Suc len \\<le> length lsrc\n  si \\<le> di\n\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> rblit src si src di (Suc len)\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take di lsrc @\n         take (Suc len) (drop si lsrc) @ drop (di + Suc len) lsrc)>", "by (sep_auto simp: take_update_last drop_upd_irrelevant)"], ["proof (state)\nthis:\n  <src \\<mapsto>\\<^sub>a lsrc> rblit src si src di (Suc len)\n  <\\<lambda>_.\n      src \\<mapsto>\\<^sub>a\n      (take di lsrc @\n       take (Suc len) (drop si lsrc) @ drop (di + Suc len) lsrc)>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Modeling target language blit\""], ["", "text \"For convenience, a function that is oblivious to the direction of the shift\n      is defined.\""], ["", "definition \"safe_sblit a s d l \\<equiv> \n    if s > d then\n      sblit a s d l\n    else\n      srblit a s d l\n\""], ["", "text \"We obtain a heap rule similar to the one of blit,\n      but for copying within one array.\""], ["", "lemma safe_sblit_rule[sep_heap_rules]:\n  assumes LEN:\n    \"len > 0 \\<longrightarrow> di+len \\<le> length lsrc \\<and> si+len \\<le> length lsrc\"\n  shows\n    \"< src \\<mapsto>\\<^sub>a lsrc  >\n    safe_sblit src si di len\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take di lsrc @ take len (drop si lsrc) @ drop (di+len) lsrc)\n    >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> safe_sblit src si di len\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>", "unfolding safe_sblit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc>\n    if di < si then sblit src si di len else srblit src si di len\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>", "using LEN"], ["proof (prove)\nusing this:\n  0 < len \\<longrightarrow>\n  di + len \\<le> length lsrc \\<and> si + len \\<le> length lsrc\n\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc>\n    if di < si then sblit src si di len else srblit src si di len\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take di lsrc @ take len (drop si lsrc) @ drop (di + len) lsrc)>", "apply(cases len)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < len \\<longrightarrow>\n             di + len \\<le> length lsrc \\<and> si + len \\<le> length lsrc;\n     len = 0\\<rbrakk>\n    \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                      if di < si then sblit src si di len\n                      else srblit src si di len\n                      <\\<lambda>_.\n                          src \\<mapsto>\\<^sub>a\n                          (take di lsrc @\n                           take len (drop si lsrc) @ drop (di + len) lsrc)>\n 2. \\<And>nat.\n       \\<lbrakk>0 < len \\<longrightarrow>\n                di + len \\<le> length lsrc \\<and>\n                si + len \\<le> length lsrc;\n        len = Suc nat\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         if di < si then sblit src si di len\n                         else srblit src si di len\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take len (drop si lsrc) @\n                              drop (di + len) lsrc)>", "apply(sep_auto simp add: sblit_def srblit_def)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>0 < len \\<longrightarrow>\n                di + len \\<le> length lsrc \\<and>\n                si + len \\<le> length lsrc;\n        len = Suc nat\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc>\n                         if di < si then sblit src si di len\n                         else srblit src si di len\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a\n                             (take di lsrc @\n                              take len (drop si lsrc) @\n                              drop (di + len) lsrc)>", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Compare this to blit_rule *)"], ["", "thm blit_rule"], ["", "thm safe_sblit_rule"], ["", "subsection \"Code Generator Setup\""], ["", "text \"Note that the requirement for correctness\n      is even weaker here than in SML.\n      We therefore manually handle the case where length is 0 (in which case nothing happens at all).\""], ["", "code_printing code_module \"array_sblit\" \\<rightharpoonup> (SML)\n  \\<open>\n   fun array_sblit src si di len = (\n      if len > 0 then\n        ArraySlice.copy {\n          di = IntInf.toInt di,\n          src = ArraySlice.slice (src,IntInf.toInt si,SOME (IntInf.toInt len)),\n          dst = src}\n      else ()\n    )\n\\<close>"], ["", "definition safe_sblit' where\n  [code del]: \"safe_sblit' src si di len \n      = safe_sblit src (nat_of_integer si) (nat_of_integer di) \n          (nat_of_integer len)\""], ["", "lemma [code]:\n  \"safe_sblit src si di len \n      = safe_sblit' src (integer_of_nat si) (integer_of_nat di) \n          (integer_of_nat len)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_sblit src si di len =\n    safe_sblit' src (integer_of_nat si) (integer_of_nat di)\n     (integer_of_nat len)", "by (simp add: safe_sblit'_def)"], ["", "(* TODO: Export to other languages: OCaml, Haskell *)"], ["", "code_printing constant safe_sblit' \\<rightharpoonup>\n  (SML) \"(fn/ ()/ => /array'_sblit _ _ _ _)\"\n  and (Scala) \"{ ('_: Unit)/=>/\n      def safescopy(src: Array['_], srci: Int, dsti: Int, len: Int) = {\n       if (len > 0)\n          System.arraycopy(src, srci, src, dsti, len)\n        else\n          ()\n      }\n      safescopy(_.array,_.toInt,_.toInt,_.toInt)\n    }\""], ["", "export_code safe_sblit checking SML Scala"], ["", "subsection \"Derived operations\""], ["", "definition array_shr where\n  \"array_shr a i k \\<equiv> do {\n  l \\<leftarrow> Array.len a;\n  safe_sblit a i (i+k) (l-(i+k))\n}\""], ["", "find_theorems \"Array.len\""], ["", "lemma array_shr_rule[sep_heap_rules]:\n  \"< src \\<mapsto>\\<^sub>a lsrc  >\n    array_shr src i k\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take (i+k) lsrc @ take (length lsrc - (i+k)) (drop i lsrc))\n    >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> array_shr src i k\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take (i + k) lsrc @ take (length lsrc - (i + k)) (drop i lsrc))>", "unfolding array_shr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc>\n    Array.len src \\<bind>\n    (\\<lambda>l. safe_sblit src i (i + k) (l - (i + k)))\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take (i + k) lsrc @ take (length lsrc - (i + k)) (drop i lsrc))>", "by sep_auto"], ["", "lemma array_shr_rule_alt:\n  \"< src \\<mapsto>\\<^sub>a lsrc  >\n    array_shr src i k\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take (length lsrc) (take (i+k) lsrc @ (drop i lsrc)))\n    >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> array_shr src i k\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        take (length lsrc) (take (i + k) lsrc @ drop i lsrc)>", "by (sep_auto simp add: min_def)"], ["", "definition array_shl where\n  \"array_shl a i k \\<equiv> do {\n  l \\<leftarrow> Array.len a;\n  safe_sblit a i (i-k) (l-i)\n}\n\""], ["", "lemma array_shl_rule[sep_heap_rules]:\n  \"\n    < src \\<mapsto>\\<^sub>a lsrc  >\n    array_shl src i k\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take (i-k) lsrc @ (drop i lsrc) @ drop (i - k + (length lsrc - i)) lsrc)\n    >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc> array_shl src i k\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take (i - k) lsrc @\n         drop i lsrc @ drop (i - k + (length lsrc - i)) lsrc)>", "unfolding array_shl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc>\n    Array.len src \\<bind> (\\<lambda>l. safe_sblit src i (i - k) (l - i))\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a\n        (take (i - k) lsrc @\n         drop i lsrc @ drop (i - k + (length lsrc - i)) lsrc)>", "by sep_auto"], ["", "lemma array_shl_rule_alt:\n  \"\n    \\<lbrakk>i \\<le> length lsrc; k \\<le> i\\<rbrakk> \\<Longrightarrow>\n    < src \\<mapsto>\\<^sub>a lsrc  >\n    array_shl src i k\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a (take (i-k) lsrc @ (drop i lsrc) @ drop (length lsrc - k) lsrc)\n    >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> length lsrc; k \\<le> i\\<rbrakk>\n    \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc> array_shl src i k\n                      <\\<lambda>_.\n                          src \\<mapsto>\\<^sub>a\n                          (take (i - k) lsrc @\n                           drop i lsrc @ drop (length lsrc - k) lsrc)>", "by sep_auto"], ["", "end"]]}