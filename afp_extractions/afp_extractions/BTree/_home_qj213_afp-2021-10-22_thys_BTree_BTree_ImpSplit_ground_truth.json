{"file_name": "/home/qj213/afp-2021-10-22/thys/BTree/BTree_ImpSplit.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BTree", "problem_names": ["lemma lin_split_rule: \"\n< is_pfa c xs (a,n)>\n lin_split (a,n) p\n <\\<lambda>i. is_pfa c xs (a,n) * \\<up>(i\\<le>n \\<and> (\\<forall>j<i. snd (xs!j) < p) \\<and> (i<n \\<longrightarrow> snd (xs!i)\\<ge>p))>\\<^sub>t\"", "lemma bin'_split_rule: \"\nsorted_less xs \\<Longrightarrow>\n< is_pfa c xs (a,n)>\n bin'_split (a,n) p\n <\\<lambda>l. is_pfa c xs (a,n) * \\<up>(l \\<le> n \\<and> (\\<forall>j<l. xs!j < p) \\<and> (l<n \\<longrightarrow> xs!l\\<ge>p)) >\\<^sub>t\"", "lemma nth_take_eq: \"take n ls = take n ls' \\<Longrightarrow> i < n \\<Longrightarrow> ls!i = ls'!i\"", "lemma map_snd_sorted_less: \"\\<lbrakk>sorted_less (map snd xs); i < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> snd (xs ! i) < snd (xs ! j)\"", "lemma map_snd_sorted_lesseq: \"\\<lbrakk>sorted_less (map snd xs); i \\<le> j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> snd (xs ! i) \\<le> snd (xs ! j)\"", "lemma bin_split_rule: \"\nsorted_less (map snd xs) \\<Longrightarrow>\n< is_pfa c xs (a,n)>\n bin_split (a,n) p\n <\\<lambda>l. is_pfa c xs (a,n) * \\<up>(l \\<le> n \\<and> (\\<forall>j<l. snd(xs!j) < p) \\<and> (l<n \\<longrightarrow> snd(xs!l)\\<ge>p)) >\\<^sub>t\"", "lemma abs_split_full: \"\\<forall>(_,s) \\<in> set xs. s < p \\<Longrightarrow> abs_split xs p = (xs,[])\"", "lemma abs_split_split:\n  assumes \"n < length xs\" \n    and \"(\\<forall>(_,s) \\<in> set (take n xs). s < p)\"\n    and \" (case (xs!n) of (_,s) \\<Rightarrow> \\<not>(s < p))\"\n  shows \"abs_split xs p = (take n xs, drop n xs)\"", "lemma split_rule_abs_split: \n  shows\n    \"sorted_less (separators ts) \\<Longrightarrow> <\n    is_pfa c tsi (a,n)\n  * list_assn (A \\<times>\\<^sub>a id_assn) ts tsi> \n    split_fun (a,n) p \n  <\\<lambda>i. \n    is_pfa c tsi (a,n)\n    * list_assn (A \\<times>\\<^sub>a id_assn) ts tsi\n    * \\<up>(split_relation ts (abs_split ts p) i)>\\<^sub>t\""], "translations": [["", "lemma lin_split_rule: \"\n< is_pfa c xs (a,n)>\n lin_split (a,n) p\n <\\<lambda>i. is_pfa c xs (a,n) * \\<up>(i\\<le>n \\<and> (\\<forall>j<i. snd (xs!j) < p) \\<and> (i<n \\<longrightarrow> snd (xs!i)\\<ge>p))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c xs\n      (a, n)> lin_split (a, n)\n               p <\\<lambda>r.\n                     is_pfa c xs (a, n) *\n                     \\<up>\n                      (r \\<le> n \\<and>\n                       (\\<forall>j<r. snd (xs ! j) < p) \\<and>\n                       (r < n \\<longrightarrow>\n                        p \\<le> snd (xs ! r)))>\\<^sub>t", "unfolding lin_split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c xs\n      (a, n)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>p.\n                    heap_WHILET\n                     (\\<lambda>i.\n                         if i < n\n                         then Array.nth a i \\<bind>\n                              (\\<lambda>(uu_, s). return (s < p))\n                         else return False)\n                     (\\<lambda>i. return (i + 1)) 0 \\<bind>\n                    return)\n               p <\\<lambda>r.\n                     is_pfa c xs (a, n) *\n                     \\<up>\n                      (r \\<le> n \\<and>\n                       (\\<forall>j<r. snd (xs ! j) < p) \\<and>\n                       (r < n \\<longrightarrow>\n                        p \\<le> snd (xs ! r)))>\\<^sub>t", "supply R = heap_WHILET_rule''[where \n      R = \"measure (\\<lambda>i. n - i)\"\n      and I = \"\\<lambda>i. is_pfa c xs (a,n) * \\<up>(i\\<le>n \\<and> (\\<forall>j<i. snd (xs!j) < p))\"\n      and b = \"\\<lambda>i. i<n \\<and> snd (xs!i) < p\"\n      and Q=\"\\<lambda>i. is_pfa c xs (a,n) * \\<up>(i\\<le>n \\<and> (\\<forall>j<i. snd (xs!j) < p) \\<and> (i<n \\<longrightarrow> snd (xs!i)\\<ge>p))\"\n      ]"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c xs\n      (a, n)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>p.\n                    heap_WHILET\n                     (\\<lambda>i.\n                         if i < n\n                         then Array.nth a i \\<bind>\n                              (\\<lambda>(uu_, s). return (s < p))\n                         else return False)\n                     (\\<lambda>i. return (i + 1)) 0 \\<bind>\n                    return)\n               p <\\<lambda>r.\n                     is_pfa c xs (a, n) *\n                     \\<up>\n                      (r \\<le> n \\<and>\n                       (\\<forall>j<r. snd (xs ! j) < p) \\<and>\n                       (r < n \\<longrightarrow>\n                        p \\<le> snd (xs ! r)))>\\<^sub>t", "thm R"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c xs\n      (a, n)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>p.\n                    heap_WHILET\n                     (\\<lambda>i.\n                         if i < n\n                         then Array.nth a i \\<bind>\n                              (\\<lambda>(uu_, s). return (s < p))\n                         else return False)\n                     (\\<lambda>i. return (i + 1)) 0 \\<bind>\n                    return)\n               p <\\<lambda>r.\n                     is_pfa c xs (a, n) *\n                     \\<up>\n                      (r \\<le> n \\<and>\n                       (\\<forall>j<r. snd (xs ! j) < p) \\<and>\n                       (r < n \\<longrightarrow>\n                        p \\<le> snd (xs ! r)))>\\<^sub>t", "apply (sep_auto  decon: R simp: less_Suc_eq is_pfa_def) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>l' s l'a b uu_ aa ba.\n       \\<lbrakk>c = length l'a; n \\<le> length l'a; xs = take n l'a; s < n;\n        length l' = length l'a; take n l' = take n l'a;\n        \\<forall>j<s. snd (l' ! j) < p; l'a ! s = (uu_, b);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true; b < p\\<rbrakk>\n       \\<Longrightarrow> snd (l' ! s) < p\n 2. \\<And>l' s l'a b uu_ aa ba.\n       \\<lbrakk>c = length l'a; n \\<le> length l'a; xs = take n l'a; s < n;\n        length l' = length l'a; take n l' = take n l'a;\n        \\<forall>j<s. snd (l' ! j) < p; l'a ! s = (uu_, b);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        snd (l' ! s) < p\\<rbrakk>\n       \\<Longrightarrow> b < p\n 3. \\<And>l' s.\n       \\<lbrakk>c = length l'; n \\<le> length l'; xs = take n l';\n        \\<not> s < n\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Al'a.\n                             a \\<mapsto>\\<^sub>a l'a * true *\n                             \\<up>\n                              (length l' = length l'a \\<and>\n                               take n l' = take n l'a \\<and>\n                               s = n \\<and>\n                               (\\<forall>j<s. snd (take n l' ! j) < p))>\n                         return False\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  s = n \\<and>\n                                  (\\<forall>j<s.\nsnd (take n l' ! j) < p) \\<and>\n                                  \\<not> r)>\n 4. \\<And>l' s.\n       \\<lbrakk>c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        s < n \\<and> snd (xs ! s) < p\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c xs (a, n) *\n                          \\<up>\n                           (s \\<le> n \\<and>\n                            (\\<forall>j<s. snd (xs ! j) < p)) *\n                          true> return\n                                 (Suc s) <\\<lambda>r.\n       is_pfa c xs (a, n) *\n       \\<up> (r \\<le> n \\<and> (\\<forall>j<r. snd (xs ! j) < p)) *\n       \\<up> ((r, s) \\<in> measure ((-) n))>\\<^sub>t\n 5. \\<And>l' s.\n       \\<lbrakk>c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (s < n \\<and> snd (xs ! s) < p)\\<rbrakk>\n       \\<Longrightarrow> is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s.\n                               snd (xs ! j) < p)) \\<Longrightarrow>\\<^sub>A\n                         is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s. snd (xs ! j) < p) \\<and>\n                           (s < n \\<longrightarrow> p \\<le> snd (xs ! s)))\n 6. \\<And>l' x.\n       c = length l' \\<and>\n       n \\<le> c \\<and> xs = take n l' \\<Longrightarrow>\n       is_pfa c xs (a, n) *\n       \\<up>\n        (x \\<le> n \\<and>\n         (\\<forall>j<x. snd (xs ! j) < p) \\<and>\n         (x < n \\<longrightarrow> p \\<le> snd (xs ! x))) *\n       true \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Al'a.\n          a \\<mapsto>\\<^sub>a l'a * true *\n          \\<up>\n           (length l' = length l'a \\<and>\n            n \\<le> length l' \\<and>\n            take n l' = take n l'a \\<and>\n            x \\<le> n \\<and>\n            (\\<forall>j<x. snd (take n l' ! j) < p) \\<and>\n            (x < n \\<longrightarrow> p \\<le> snd (take n l' ! x)))", "apply (metis nth_take snd_eqD)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l' s l'a b uu_ aa ba.\n       \\<lbrakk>c = length l'a; n \\<le> length l'a; xs = take n l'a; s < n;\n        length l' = length l'a; take n l' = take n l'a;\n        \\<forall>j<s. snd (l' ! j) < p; l'a ! s = (uu_, b);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        snd (l' ! s) < p\\<rbrakk>\n       \\<Longrightarrow> b < p\n 2. \\<And>l' s.\n       \\<lbrakk>c = length l'; n \\<le> length l'; xs = take n l';\n        \\<not> s < n\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Al'a.\n                             a \\<mapsto>\\<^sub>a l'a * true *\n                             \\<up>\n                              (length l' = length l'a \\<and>\n                               take n l' = take n l'a \\<and>\n                               s = n \\<and>\n                               (\\<forall>j<s. snd (take n l' ! j) < p))>\n                         return False\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  s = n \\<and>\n                                  (\\<forall>j<s.\nsnd (take n l' ! j) < p) \\<and>\n                                  \\<not> r)>\n 3. \\<And>l' s.\n       \\<lbrakk>c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        s < n \\<and> snd (xs ! s) < p\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c xs (a, n) *\n                          \\<up>\n                           (s \\<le> n \\<and>\n                            (\\<forall>j<s. snd (xs ! j) < p)) *\n                          true> return\n                                 (Suc s) <\\<lambda>r.\n       is_pfa c xs (a, n) *\n       \\<up> (r \\<le> n \\<and> (\\<forall>j<r. snd (xs ! j) < p)) *\n       \\<up> ((r, s) \\<in> measure ((-) n))>\\<^sub>t\n 4. \\<And>l' s.\n       \\<lbrakk>c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (s < n \\<and> snd (xs ! s) < p)\\<rbrakk>\n       \\<Longrightarrow> is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s.\n                               snd (xs ! j) < p)) \\<Longrightarrow>\\<^sub>A\n                         is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s. snd (xs ! j) < p) \\<and>\n                           (s < n \\<longrightarrow> p \\<le> snd (xs ! s)))\n 5. \\<And>l' x.\n       c = length l' \\<and>\n       n \\<le> c \\<and> xs = take n l' \\<Longrightarrow>\n       is_pfa c xs (a, n) *\n       \\<up>\n        (x \\<le> n \\<and>\n         (\\<forall>j<x. snd (xs ! j) < p) \\<and>\n         (x < n \\<longrightarrow> p \\<le> snd (xs ! x))) *\n       true \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Al'a.\n          a \\<mapsto>\\<^sub>a l'a * true *\n          \\<up>\n           (length l' = length l'a \\<and>\n            n \\<le> length l' \\<and>\n            take n l' = take n l'a \\<and>\n            x \\<le> n \\<and>\n            (\\<forall>j<x. snd (take n l' ! j) < p) \\<and>\n            (x < n \\<longrightarrow> p \\<le> snd (take n l' ! x)))", "apply (metis nth_take snd_eqD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l' s.\n       \\<lbrakk>c = length l'; n \\<le> length l'; xs = take n l';\n        \\<not> s < n\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Al'a.\n                             a \\<mapsto>\\<^sub>a l'a * true *\n                             \\<up>\n                              (length l' = length l'a \\<and>\n                               take n l' = take n l'a \\<and>\n                               s = n \\<and>\n                               (\\<forall>j<s. snd (take n l' ! j) < p))>\n                         return False\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  s = n \\<and>\n                                  (\\<forall>j<s.\nsnd (take n l' ! j) < p) \\<and>\n                                  \\<not> r)>\n 2. \\<And>l' s.\n       \\<lbrakk>c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        s < n \\<and> snd (xs ! s) < p\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c xs (a, n) *\n                          \\<up>\n                           (s \\<le> n \\<and>\n                            (\\<forall>j<s. snd (xs ! j) < p)) *\n                          true> return\n                                 (Suc s) <\\<lambda>r.\n       is_pfa c xs (a, n) *\n       \\<up> (r \\<le> n \\<and> (\\<forall>j<r. snd (xs ! j) < p)) *\n       \\<up> ((r, s) \\<in> measure ((-) n))>\\<^sub>t\n 3. \\<And>l' s.\n       \\<lbrakk>c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (s < n \\<and> snd (xs ! s) < p)\\<rbrakk>\n       \\<Longrightarrow> is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s.\n                               snd (xs ! j) < p)) \\<Longrightarrow>\\<^sub>A\n                         is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s. snd (xs ! j) < p) \\<and>\n                           (s < n \\<longrightarrow> p \\<le> snd (xs ! s)))\n 4. \\<And>l' x.\n       c = length l' \\<and>\n       n \\<le> c \\<and> xs = take n l' \\<Longrightarrow>\n       is_pfa c xs (a, n) *\n       \\<up>\n        (x \\<le> n \\<and>\n         (\\<forall>j<x. snd (xs ! j) < p) \\<and>\n         (x < n \\<longrightarrow> p \\<le> snd (xs ! x))) *\n       true \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Al'a.\n          a \\<mapsto>\\<^sub>a l'a * true *\n          \\<up>\n           (length l' = length l'a \\<and>\n            n \\<le> length l' \\<and>\n            take n l' = take n l'a \\<and>\n            x \\<le> n \\<and>\n            (\\<forall>j<x. snd (take n l' ! j) < p) \\<and>\n            (x < n \\<longrightarrow> p \\<le> snd (take n l' ! x)))", "apply (sep_auto simp: is_pfa_def less_Suc_eq)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l' l'a x aa b j.\n       \\<lbrakk>c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a;\n        \\<forall>j<n. snd (l' ! j) < p; \\<not> x;\n        (aa, b) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true; j < n\\<rbrakk>\n       \\<Longrightarrow> snd (l'a ! j) < p\n 2. \\<And>l' s.\n       \\<lbrakk>c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        s < n \\<and> snd (xs ! s) < p\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c xs (a, n) *\n                          \\<up>\n                           (s \\<le> n \\<and>\n                            (\\<forall>j<s. snd (xs ! j) < p)) *\n                          true> return\n                                 (Suc s) <\\<lambda>r.\n       is_pfa c xs (a, n) *\n       \\<up> (r \\<le> n \\<and> (\\<forall>j<r. snd (xs ! j) < p)) *\n       \\<up> ((r, s) \\<in> measure ((-) n))>\\<^sub>t\n 3. \\<And>l' s.\n       \\<lbrakk>c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (s < n \\<and> snd (xs ! s) < p)\\<rbrakk>\n       \\<Longrightarrow> is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s.\n                               snd (xs ! j) < p)) \\<Longrightarrow>\\<^sub>A\n                         is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s. snd (xs ! j) < p) \\<and>\n                           (s < n \\<longrightarrow> p \\<le> snd (xs ! s)))\n 4. \\<And>l' x.\n       c = length l' \\<and>\n       n \\<le> c \\<and> xs = take n l' \\<Longrightarrow>\n       is_pfa c xs (a, n) *\n       \\<up>\n        (x \\<le> n \\<and>\n         (\\<forall>j<x. snd (xs ! j) < p) \\<and>\n         (x < n \\<longrightarrow> p \\<le> snd (xs ! x))) *\n       true \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Al'a.\n          a \\<mapsto>\\<^sub>a l'a * true *\n          \\<up>\n           (length l' = length l'a \\<and>\n            n \\<le> length l' \\<and>\n            take n l' = take n l'a \\<and>\n            x \\<le> n \\<and>\n            (\\<forall>j<x. snd (take n l' ! j) < p) \\<and>\n            (x < n \\<longrightarrow> p \\<le> snd (take n l' ! x)))", "apply (metis nth_take)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l' s.\n       \\<lbrakk>c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        s < n \\<and> snd (xs ! s) < p\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c xs (a, n) *\n                          \\<up>\n                           (s \\<le> n \\<and>\n                            (\\<forall>j<s. snd (xs ! j) < p)) *\n                          true> return\n                                 (Suc s) <\\<lambda>r.\n       is_pfa c xs (a, n) *\n       \\<up> (r \\<le> n \\<and> (\\<forall>j<r. snd (xs ! j) < p)) *\n       \\<up> ((r, s) \\<in> measure ((-) n))>\\<^sub>t\n 2. \\<And>l' s.\n       \\<lbrakk>c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (s < n \\<and> snd (xs ! s) < p)\\<rbrakk>\n       \\<Longrightarrow> is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s.\n                               snd (xs ! j) < p)) \\<Longrightarrow>\\<^sub>A\n                         is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s. snd (xs ! j) < p) \\<and>\n                           (s < n \\<longrightarrow> p \\<le> snd (xs ! s)))\n 3. \\<And>l' x.\n       c = length l' \\<and>\n       n \\<le> c \\<and> xs = take n l' \\<Longrightarrow>\n       is_pfa c xs (a, n) *\n       \\<up>\n        (x \\<le> n \\<and>\n         (\\<forall>j<x. snd (xs ! j) < p) \\<and>\n         (x < n \\<longrightarrow> p \\<le> snd (xs ! x))) *\n       true \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Al'a.\n          a \\<mapsto>\\<^sub>a l'a * true *\n          \\<up>\n           (length l' = length l'a \\<and>\n            n \\<le> length l' \\<and>\n            take n l' = take n l'a \\<and>\n            x \\<le> n \\<and>\n            (\\<forall>j<x. snd (take n l' ! j) < p) \\<and>\n            (x < n \\<longrightarrow> p \\<le> snd (take n l' ! x)))", "apply(sep_auto simp: is_pfa_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l' s l'a aa b j.\n       \\<lbrakk>c = length l'a; s < n; snd (l' ! s) < p; n \\<le> length l'a;\n        xs = take n l'a; length l' = length l'a; take n l' = take n l'a;\n        \\<forall>j<s. snd (l' ! j) < p;\n        (aa, b) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        j < Suc s\\<rbrakk>\n       \\<Longrightarrow> snd (l'a ! j) < p\n 2. \\<And>l' s l'a.\n       \\<lbrakk>c = length l'a; s < n; snd (l' ! s) < p; n \\<le> length l'a;\n        xs = take n l'a; length l' = length l'a; take n l' = take n l'a;\n        \\<forall>j<s. snd (l' ! j) < p;\n        \\<exists>h. h \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true\\<rbrakk>\n       \\<Longrightarrow> n - Suc s < n - s\n 3. \\<And>l' s.\n       \\<lbrakk>c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (s < n \\<and> snd (xs ! s) < p)\\<rbrakk>\n       \\<Longrightarrow> is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s.\n                               snd (xs ! j) < p)) \\<Longrightarrow>\\<^sub>A\n                         is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s. snd (xs ! j) < p) \\<and>\n                           (s < n \\<longrightarrow> p \\<le> snd (xs ! s)))\n 4. \\<And>l' x.\n       c = length l' \\<and>\n       n \\<le> c \\<and> xs = take n l' \\<Longrightarrow>\n       is_pfa c xs (a, n) *\n       \\<up>\n        (x \\<le> n \\<and>\n         (\\<forall>j<x. snd (xs ! j) < p) \\<and>\n         (x < n \\<longrightarrow> p \\<le> snd (xs ! x))) *\n       true \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Al'a.\n          a \\<mapsto>\\<^sub>a l'a * true *\n          \\<up>\n           (length l' = length l'a \\<and>\n            n \\<le> length l' \\<and>\n            take n l' = take n l'a \\<and>\n            x \\<le> n \\<and>\n            (\\<forall>j<x. snd (take n l' ! j) < p) \\<and>\n            (x < n \\<longrightarrow> p \\<le> snd (take n l' ! x)))", "apply (metis le_simps(3) less_Suc_eq less_le_trans nth_take)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l' s l'a.\n       \\<lbrakk>c = length l'a; s < n; snd (l' ! s) < p; n \\<le> length l'a;\n        xs = take n l'a; length l' = length l'a; take n l' = take n l'a;\n        \\<forall>j<s. snd (l' ! j) < p;\n        \\<exists>h. h \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true\\<rbrakk>\n       \\<Longrightarrow> n - Suc s < n - s\n 2. \\<And>l' s.\n       \\<lbrakk>c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (s < n \\<and> snd (xs ! s) < p)\\<rbrakk>\n       \\<Longrightarrow> is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s.\n                               snd (xs ! j) < p)) \\<Longrightarrow>\\<^sub>A\n                         is_pfa c xs (a, n) *\n                         \\<up>\n                          (s \\<le> n \\<and>\n                           (\\<forall>j<s. snd (xs ! j) < p) \\<and>\n                           (s < n \\<longrightarrow> p \\<le> snd (xs ! s)))\n 3. \\<And>l' x.\n       c = length l' \\<and>\n       n \\<le> c \\<and> xs = take n l' \\<Longrightarrow>\n       is_pfa c xs (a, n) *\n       \\<up>\n        (x \\<le> n \\<and>\n         (\\<forall>j<x. snd (xs ! j) < p) \\<and>\n         (x < n \\<longrightarrow> p \\<le> snd (xs ! x))) *\n       true \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Al'a.\n          a \\<mapsto>\\<^sub>a l'a * true *\n          \\<up>\n           (length l' = length l'a \\<and>\n            n \\<le> length l' \\<and>\n            take n l' = take n l'a \\<and>\n            x \\<le> n \\<and>\n            (\\<forall>j<x. snd (take n l' ! j) < p) \\<and>\n            (x < n \\<longrightarrow> p \\<le> snd (take n l' ! x)))", "apply(sep_auto simp: is_pfa_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Binary split\""], ["", "text \"To obtain an efficient B-Tree implementation, we prefer a binary split\nfunction.\nTo explore the searching procedure\nand the resulting proof, we first implement the split on singleton arrays.\""], ["", "definition bin'_split :: \"'b::{heap,linorder} array_list \\<Rightarrow> 'b \\<Rightarrow> nat Heap\"\n  where\n    \"bin'_split \\<equiv> \\<lambda>(a,n) p. do {\n  (low',high') \\<leftarrow> heap_WHILET \n    (\\<lambda>(low,high). return (low < high)) \n    (\\<lambda>(low,high). let mid = ((low  + high) div 2) in\n     do {\n      s \\<leftarrow> Array.nth a mid;\n      if p < s then\n         return (low, mid)\n      else if p > s then\n         return (mid+1, high)\n      else return (mid,mid)\n     }) \n    (0::nat,n);\n  return low'\n}\""], ["", "thm sorted_wrt_nth_less"], ["", "(* alternative: replace (\\<forall>j<l. xs!j < p) by (l > 0 \\<longrightarrow> xs!(l-1) < p)*)"], ["", "lemma bin'_split_rule: \"\nsorted_less xs \\<Longrightarrow>\n< is_pfa c xs (a,n)>\n bin'_split (a,n) p\n <\\<lambda>l. is_pfa c xs (a,n) * \\<up>(l \\<le> n \\<and> (\\<forall>j<l. xs!j < p) \\<and> (l<n \\<longrightarrow> xs!l\\<ge>p)) >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less xs \\<Longrightarrow>\n    <is_pfa c xs\n      (a, n)> bin'_split (a, n)\n               p <\\<lambda>r.\n                     is_pfa c xs (a, n) *\n                     \\<up>\n                      (r \\<le> n \\<and>\n                       (\\<forall>j<r. xs ! j < p) \\<and>\n                       (r < n \\<longrightarrow> p \\<le> xs ! r))>\\<^sub>t", "unfolding bin'_split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less xs \\<Longrightarrow>\n    <is_pfa c xs\n      (a, n)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>p.\n                    heap_WHILET (\\<lambda>(low, high). return (low < high))\n                     (\\<lambda>(low, high).\n                         let mid = (low + high) div 2\n                         in Array.nth a mid \\<bind>\n                            (\\<lambda>s.\n                                if p < s then return (low, mid)\n                                else if s < p then return (mid + 1, high)\n                                     else return (mid, mid)))\n                     (0, n) \\<bind>\n                    (\\<lambda>(low', high'). return low'))\n               p <\\<lambda>r.\n                     is_pfa c xs (a, n) *\n                     \\<up>\n                      (r \\<le> n \\<and>\n                       (\\<forall>j<r. xs ! j < p) \\<and>\n                       (r < n \\<longrightarrow> p \\<le> xs ! r))>\\<^sub>t", "supply R = heap_WHILET_rule''[where \n      R = \"measure (\\<lambda>(l,h). h-l)\"\n      and I = \"\\<lambda>(l,h). is_pfa c xs (a,n) * \\<up>(l\\<le>h \\<and> h \\<le> n \\<and> (\\<forall>j<l. xs!j < p) \\<and> (h<n \\<longrightarrow> xs!h\\<ge>p))\"\n      and b = \"\\<lambda>(l,h). l<h\"\n      and Q=\"\\<lambda>(l,h). is_pfa c xs (a,n) * \\<up>(l \\<le> n \\<and> (\\<forall>j<l. xs!j < p) \\<and> (l<n \\<longrightarrow> xs!l\\<ge>p))\"\n      ]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less xs \\<Longrightarrow>\n    <is_pfa c xs\n      (a, n)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>p.\n                    heap_WHILET (\\<lambda>(low, high). return (low < high))\n                     (\\<lambda>(low, high).\n                         let mid = (low + high) div 2\n                         in Array.nth a mid \\<bind>\n                            (\\<lambda>s.\n                                if p < s then return (low, mid)\n                                else if s < p then return (mid + 1, high)\n                                     else return (mid, mid)))\n                     (0, n) \\<bind>\n                    (\\<lambda>(low', high'). return low'))\n               p <\\<lambda>r.\n                     is_pfa c xs (a, n) *\n                     \\<up>\n                      (r \\<le> n \\<and>\n                       (\\<forall>j<r. xs ! j < p) \\<and>\n                       (r < n \\<longrightarrow> p \\<le> xs ! r))>\\<^sub>t", "thm R"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less xs \\<Longrightarrow>\n    <is_pfa c xs\n      (a, n)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>p.\n                    heap_WHILET (\\<lambda>(low, high). return (low < high))\n                     (\\<lambda>(low, high).\n                         let mid = (low + high) div 2\n                         in Array.nth a mid \\<bind>\n                            (\\<lambda>s.\n                                if p < s then return (low, mid)\n                                else if s < p then return (mid + 1, high)\n                                     else return (mid, mid)))\n                     (0, n) \\<bind>\n                    (\\<lambda>(low', high'). return low'))\n               p <\\<lambda>r.\n                     is_pfa c xs (a, n) *\n                     \\<up>\n                      (r \\<le> n \\<and>\n                       (\\<forall>j<r. xs ! j < p) \\<and>\n                       (r < n \\<longrightarrow> p \\<le> xs ! r))>\\<^sub>t", "apply (sep_auto decon: R simp: less_Suc_eq is_pfa_def) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>l' aa l'a aaa ba j.\n       \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n        l'a ! ((aa + n) div 2) < p;\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        j < (aa + n) div 2\\<rbrakk>\n       \\<Longrightarrow> l'a ! j < p\n 2. \\<And>l' aa b l'a aaa ba j.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n        l'a ! ((aa + b) div 2) < p;\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n       \\<Longrightarrow> l'a ! j < p\n 3. \\<And>l' aa b l'a xa.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n        b < n \\<longrightarrow> p \\<le> l' ! b;\n        \\<not> l'a ! ((aa + b) div 2) < p; p < l'a ! ((aa + b) div 2);\n        xa = l'a ! ((aa + b) div 2)\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         return (aa, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   take n l'a ! j < p) \\<and>\n                                     (h < n \\<longrightarrow>\np \\<le> l' ! h))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 4. \\<And>l' aa b l'a xa.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n        b < n \\<longrightarrow> p \\<le> l' ! b;\n        \\<not> l'a ! ((aa + b) div 2) < p; p = l'a ! ((aa + b) div 2);\n        xa = l'a ! ((aa + b) div 2)\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         return ((aa + b) div 2, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   take n l'a ! j < l'a ! ((aa + b) div 2)) \\<and>\n                                     (h < n \\<longrightarrow>\nl'a ! ((aa + b) div 2) \\<le> l' ! h))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 5. \\<And>l' s.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> xs ! h))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (l < n \\<longrightarrow> p \\<le> xs ! l)))\n 6. \\<And>l' x.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. xs ! j < p) \\<and>\n                               (l < n \\<longrightarrow> p \\<le> xs ! l))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r. take n l' ! j < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> take n l' ! r))>", "subgoal for l' aa l'a aaa ba j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "assume 0: \"n \\<le> length l'a\""], ["proof (state)\nthis:\n  n \\<le> length l'a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "assume a: \"l'a ! ((aa + n) div 2) < p\""], ["proof (state)\nthis:\n  l'a ! ((aa + n) div 2) < p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "moreover"], ["proof (state)\nthis:\n  l'a ! ((aa + n) div 2) < p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "assume \"aa < n\""], ["proof (state)\nthis:\n  aa < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "ultimately"], ["proof (chain)\npicking this:\n  l'a ! ((aa + n) div 2) < p\n  aa < n", "have b: \"((aa+n)div 2) < n\""], ["proof (prove)\nusing this:\n  l'a ! ((aa + n) div 2) < p\n  aa < n\n\ngoal (1 subgoal):\n 1. (aa + n) div 2 < n", "by linarith"], ["proof (state)\nthis:\n  (aa + n) div 2 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "then"], ["proof (chain)\npicking this:\n  (aa + n) div 2 < n", "have \"(take n l'a) ! ((aa + n) div 2) < p\""], ["proof (prove)\nusing this:\n  (aa + n) div 2 < n\n\ngoal (1 subgoal):\n 1. take n l'a ! ((aa + n) div 2) < p", "using a"], ["proof (prove)\nusing this:\n  (aa + n) div 2 < n\n  l'a ! ((aa + n) div 2) < p\n\ngoal (1 subgoal):\n 1. take n l'a ! ((aa + n) div 2) < p", "by auto"], ["proof (state)\nthis:\n  take n l'a ! ((aa + n) div 2) < p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "moreover"], ["proof (state)\nthis:\n  take n l'a ! ((aa + n) div 2) < p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "assume \"sorted_less (take n l'a)\""], ["proof (state)\nthis:\n  sorted_less (take n l'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "ultimately"], ["proof (chain)\npicking this:\n  take n l'a ! ((aa + n) div 2) < p\n  sorted_less (take n l'a)", "have \"\\<And>j. j < (aa+n)div 2 \\<Longrightarrow> (take n l'a) ! j < (take n l'a) ! ((aa + n) div 2)\""], ["proof (prove)\nusing this:\n  take n l'a ! ((aa + n) div 2) < p\n  sorted_less (take n l'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < (aa + n) div 2 \\<Longrightarrow>\n       take n l'a ! j < take n l'a ! ((aa + n) div 2)", "using\n        sorted_wrt_nth_less[where ?P=\"(<)\" and xs=\"(take n l'a)\" and ?j=\"((aa + n) div 2)\"]\n        a b \"0\""], ["proof (prove)\nusing this:\n  take n l'a ! ((aa + n) div 2) < p\n  sorted_less (take n l'a)\n  \\<lbrakk>sorted_less (take n l'a); ?i < (aa + n) div 2;\n   (aa + n) div 2 < length (take n l'a)\\<rbrakk>\n  \\<Longrightarrow> take n l'a ! ?i < take n l'a ! ((aa + n) div 2)\n  l'a ! ((aa + n) div 2) < p\n  (aa + n) div 2 < n\n  n \\<le> length l'a\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < (aa + n) div 2 \\<Longrightarrow>\n       take n l'a ! j < take n l'a ! ((aa + n) div 2)", "by auto"], ["proof (state)\nthis:\n  ?j < (aa + n) div 2 \\<Longrightarrow>\n  take n l'a ! ?j < take n l'a ! ((aa + n) div 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "moreover"], ["proof (state)\nthis:\n  ?j < (aa + n) div 2 \\<Longrightarrow>\n  take n l'a ! ?j < take n l'a ! ((aa + n) div 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j__ < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j__ < p", "assume \"j < (aa+n) div 2\""], ["proof (state)\nthis:\n  j < (aa + n) div 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + n) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j__ < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j__ < p", "ultimately"], ["proof (chain)\npicking this:\n  ?j < (aa + n) div 2 \\<Longrightarrow>\n  take n l'a ! ?j < take n l'a ! ((aa + n) div 2)\n  j < (aa + n) div 2", "show \"l'a ! j < p\""], ["proof (prove)\nusing this:\n  ?j < (aa + n) div 2 \\<Longrightarrow>\n  take n l'a ! ?j < take n l'a ! ((aa + n) div 2)\n  j < (aa + n) div 2\n\ngoal (1 subgoal):\n 1. l'a ! j < p", "using \"0\" b"], ["proof (prove)\nusing this:\n  ?j < (aa + n) div 2 \\<Longrightarrow>\n  take n l'a ! ?j < take n l'a ! ((aa + n) div 2)\n  j < (aa + n) div 2\n  n \\<le> length l'a\n  (aa + n) div 2 < n\n\ngoal (1 subgoal):\n 1. l'a ! j < p", "using \\<open>take n l'a ! ((aa + n) div 2) < p\\<close> dual_order.strict_trans"], ["proof (prove)\nusing this:\n  ?j < (aa + n) div 2 \\<Longrightarrow>\n  take n l'a ! ?j < take n l'a ! ((aa + n) div 2)\n  j < (aa + n) div 2\n  n \\<le> length l'a\n  (aa + n) div 2 < n\n  take n l'a ! ((aa + n) div 2) < p\n  \\<lbrakk>?b < ?a; ?c < ?b\\<rbrakk> \\<Longrightarrow> ?c < ?a\n\ngoal (1 subgoal):\n 1. l'a ! j < p", "by auto"], ["proof (state)\nthis:\n  l'a ! j < p\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l' aa b l'a aaa ba j.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n        l'a ! ((aa + b) div 2) < p;\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n       \\<Longrightarrow> l'a ! j < p\n 2. \\<And>l' aa b l'a xa.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n        b < n \\<longrightarrow> p \\<le> l' ! b;\n        \\<not> l'a ! ((aa + b) div 2) < p; p < l'a ! ((aa + b) div 2);\n        xa = l'a ! ((aa + b) div 2)\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         return (aa, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   take n l'a ! j < p) \\<and>\n                                     (h < n \\<longrightarrow>\np \\<le> l' ! h))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 3. \\<And>l' aa b l'a xa.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n        b < n \\<longrightarrow> p \\<le> l' ! b;\n        \\<not> l'a ! ((aa + b) div 2) < p; p = l'a ! ((aa + b) div 2);\n        xa = l'a ! ((aa + b) div 2)\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         return ((aa + b) div 2, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   take n l'a ! j < l'a ! ((aa + b) div 2)) \\<and>\n                                     (h < n \\<longrightarrow>\nl'a ! ((aa + b) div 2) \\<le> l' ! h))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 4. \\<And>l' s.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> xs ! h))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (l < n \\<longrightarrow> p \\<le> xs ! l)))\n 5. \\<And>l' x.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. xs ! j < p) \\<and>\n                               (l < n \\<longrightarrow> p \\<le> xs ! l))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r. take n l' ! j < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> take n l' ! r))>", "subgoal for l' aa b l'a aaa ba j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "assume t0: \"n \\<le> length l'a\""], ["proof (state)\nthis:\n  n \\<le> length l'a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "assume t1: \"aa < b\""], ["proof (state)\nthis:\n  aa < b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "assume a: \"l'a ! ((aa + b) div 2) < p\""], ["proof (state)\nthis:\n  l'a ! ((aa + b) div 2) < p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "moreover"], ["proof (state)\nthis:\n  l'a ! ((aa + b) div 2) < p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "assume \"b \\<le> n\""], ["proof (state)\nthis:\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "ultimately"], ["proof (chain)\npicking this:\n  l'a ! ((aa + b) div 2) < p\n  b \\<le> n", "have b: \"((aa+b)div 2) < n\""], ["proof (prove)\nusing this:\n  l'a ! ((aa + b) div 2) < p\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. (aa + b) div 2 < n", "using t1"], ["proof (prove)\nusing this:\n  l'a ! ((aa + b) div 2) < p\n  b \\<le> n\n  aa < b\n\ngoal (1 subgoal):\n 1. (aa + b) div 2 < n", "by linarith"], ["proof (state)\nthis:\n  (aa + b) div 2 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "then"], ["proof (chain)\npicking this:\n  (aa + b) div 2 < n", "have \"(take n l'a) ! ((aa + b) div 2) < p\""], ["proof (prove)\nusing this:\n  (aa + b) div 2 < n\n\ngoal (1 subgoal):\n 1. take n l'a ! ((aa + b) div 2) < p", "using a"], ["proof (prove)\nusing this:\n  (aa + b) div 2 < n\n  l'a ! ((aa + b) div 2) < p\n\ngoal (1 subgoal):\n 1. take n l'a ! ((aa + b) div 2) < p", "by auto"], ["proof (state)\nthis:\n  take n l'a ! ((aa + b) div 2) < p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "moreover"], ["proof (state)\nthis:\n  take n l'a ! ((aa + b) div 2) < p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "assume \"sorted_less (take n l'a)\""], ["proof (state)\nthis:\n  sorted_less (take n l'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "ultimately"], ["proof (chain)\npicking this:\n  take n l'a ! ((aa + b) div 2) < p\n  sorted_less (take n l'a)", "have \"\\<And>j. j < (aa+b)div 2 \\<Longrightarrow> (take n l'a) ! j < (take n l'a) ! ((aa + b) div 2)\""], ["proof (prove)\nusing this:\n  take n l'a ! ((aa + b) div 2) < p\n  sorted_less (take n l'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < (aa + b) div 2 \\<Longrightarrow>\n       take n l'a ! j < take n l'a ! ((aa + b) div 2)", "using\n        sorted_wrt_nth_less[where ?P=\"(<)\" and xs=\"(take n l'a)\" and ?j=\"((aa + b) div 2)\"]\n        a b t0"], ["proof (prove)\nusing this:\n  take n l'a ! ((aa + b) div 2) < p\n  sorted_less (take n l'a)\n  \\<lbrakk>sorted_less (take n l'a); ?i < (aa + b) div 2;\n   (aa + b) div 2 < length (take n l'a)\\<rbrakk>\n  \\<Longrightarrow> take n l'a ! ?i < take n l'a ! ((aa + b) div 2)\n  l'a ! ((aa + b) div 2) < p\n  (aa + b) div 2 < n\n  n \\<le> length l'a\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < (aa + b) div 2 \\<Longrightarrow>\n       take n l'a ! j < take n l'a ! ((aa + b) div 2)", "by auto"], ["proof (state)\nthis:\n  ?j < (aa + b) div 2 \\<Longrightarrow>\n  take n l'a ! ?j < take n l'a ! ((aa + b) div 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "moreover"], ["proof (state)\nthis:\n  ?j < (aa + b) div 2 \\<Longrightarrow>\n  take n l'a ! ?j < take n l'a ! ((aa + b) div 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < p", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j__ < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j__ < p", "assume \"j < (aa+b) div 2\""], ["proof (state)\nthis:\n  j < (aa + b) div 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n     l'a ! ((aa + b) div 2) < p;\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j__ < (aa + b) div 2; p \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j__ < p", "ultimately"], ["proof (chain)\npicking this:\n  ?j < (aa + b) div 2 \\<Longrightarrow>\n  take n l'a ! ?j < take n l'a ! ((aa + b) div 2)\n  j < (aa + b) div 2", "show \"l'a ! j < p\""], ["proof (prove)\nusing this:\n  ?j < (aa + b) div 2 \\<Longrightarrow>\n  take n l'a ! ?j < take n l'a ! ((aa + b) div 2)\n  j < (aa + b) div 2\n\ngoal (1 subgoal):\n 1. l'a ! j < p", "using t0 b"], ["proof (prove)\nusing this:\n  ?j < (aa + b) div 2 \\<Longrightarrow>\n  take n l'a ! ?j < take n l'a ! ((aa + b) div 2)\n  j < (aa + b) div 2\n  n \\<le> length l'a\n  (aa + b) div 2 < n\n\ngoal (1 subgoal):\n 1. l'a ! j < p", "using \\<open>take n l'a ! ((aa + b) div 2) < p\\<close> dual_order.strict_trans"], ["proof (prove)\nusing this:\n  ?j < (aa + b) div 2 \\<Longrightarrow>\n  take n l'a ! ?j < take n l'a ! ((aa + b) div 2)\n  j < (aa + b) div 2\n  n \\<le> length l'a\n  (aa + b) div 2 < n\n  take n l'a ! ((aa + b) div 2) < p\n  \\<lbrakk>?b < ?a; ?c < ?b\\<rbrakk> \\<Longrightarrow> ?c < ?a\n\ngoal (1 subgoal):\n 1. l'a ! j < p", "by auto"], ["proof (state)\nthis:\n  l'a ! j < p\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l' aa b l'a xa.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n        b < n \\<longrightarrow> p \\<le> l' ! b;\n        \\<not> l'a ! ((aa + b) div 2) < p; p < l'a ! ((aa + b) div 2);\n        xa = l'a ! ((aa + b) div 2)\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         return (aa, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   take n l'a ! j < p) \\<and>\n                                     (h < n \\<longrightarrow>\np \\<le> l' ! h))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 2. \\<And>l' aa b l'a xa.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n        b < n \\<longrightarrow> p \\<le> l' ! b;\n        \\<not> l'a ! ((aa + b) div 2) < p; p = l'a ! ((aa + b) div 2);\n        xa = l'a ! ((aa + b) div 2)\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         return ((aa + b) div 2, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   take n l'a ! j < l'a ! ((aa + b) div 2)) \\<and>\n                                     (h < n \\<longrightarrow>\nl'a ! ((aa + b) div 2) \\<le> l' ! h))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 3. \\<And>l' s.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> xs ! h))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (l < n \\<longrightarrow> p \\<le> xs ! l)))\n 4. \\<And>l' x.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. xs ! j < p) \\<and>\n                               (l < n \\<longrightarrow> p \\<le> xs ! l))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r. take n l' ! j < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> take n l' ! r))>", "apply sep_auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l' aa l'a aaa ba.\n       \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; \\<forall>j<aa. l'a ! j < p;\n        p < l'a ! ((aa + n) div 2); (aa + n) div 2 < n;\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true\\<rbrakk>\n       \\<Longrightarrow> p \\<le> l' ! ((aa + n) div 2)\n 2. \\<And>l' aa b l'a aaa ba.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n        p < l'a ! ((aa + b) div 2); (aa + b) div 2 < n;\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        p \\<le> l' ! b\\<rbrakk>\n       \\<Longrightarrow> p \\<le> l' ! ((aa + b) div 2)\n 3. \\<And>l' aa b l'a xa.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n        b < n \\<longrightarrow> p \\<le> l' ! b;\n        \\<not> l'a ! ((aa + b) div 2) < p; p = l'a ! ((aa + b) div 2);\n        xa = l'a ! ((aa + b) div 2)\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         return ((aa + b) div 2, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   take n l'a ! j < l'a ! ((aa + b) div 2)) \\<and>\n                                     (h < n \\<longrightarrow>\nl'a ! ((aa + b) div 2) \\<le> l' ! h))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 4. \\<And>l' s.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> xs ! h))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (l < n \\<longrightarrow> p \\<le> xs ! l)))\n 5. \\<And>l' x.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. xs ! j < p) \\<and>\n                               (l < n \\<longrightarrow> p \\<le> xs ! l))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r. take n l' ! j < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> take n l' ! r))>", "apply (metis le_less nth_take)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l' aa b l'a aaa ba.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n        p < l'a ! ((aa + b) div 2); (aa + b) div 2 < n;\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        p \\<le> l' ! b\\<rbrakk>\n       \\<Longrightarrow> p \\<le> l' ! ((aa + b) div 2)\n 2. \\<And>l' aa b l'a xa.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n        b < n \\<longrightarrow> p \\<le> l' ! b;\n        \\<not> l'a ! ((aa + b) div 2) < p; p = l'a ! ((aa + b) div 2);\n        xa = l'a ! ((aa + b) div 2)\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         return ((aa + b) div 2, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   take n l'a ! j < l'a ! ((aa + b) div 2)) \\<and>\n                                     (h < n \\<longrightarrow>\nl'a ! ((aa + b) div 2) \\<le> l' ! h))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 3. \\<And>l' s.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> xs ! h))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (l < n \\<longrightarrow> p \\<le> xs ! l)))\n 4. \\<And>l' x.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. xs ! j < p) \\<and>\n                               (l < n \\<longrightarrow> p \\<le> xs ! l))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r. take n l' ! j < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> take n l' ! r))>", "apply (metis le_less nth_take)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l' aa b l'a xa.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n; \\<forall>j<aa. l'a ! j < p;\n        b < n \\<longrightarrow> p \\<le> l' ! b;\n        \\<not> l'a ! ((aa + b) div 2) < p; p = l'a ! ((aa + b) div 2);\n        xa = l'a ! ((aa + b) div 2)\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         return ((aa + b) div 2, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   take n l'a ! j < l'a ! ((aa + b) div 2)) \\<and>\n                                     (h < n \\<longrightarrow>\nl'a ! ((aa + b) div 2) \\<le> l' ! h))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 2. \\<And>l' s.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> xs ! h))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (l < n \\<longrightarrow> p \\<le> xs ! l)))\n 3. \\<And>l' x.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. xs ! j < p) \\<and>\n                               (l < n \\<longrightarrow> p \\<le> xs ! l))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r. take n l' ! j < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> take n l' ! r))>", "apply sep_auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l' aa l'a aaa ba j.\n       \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a;\n        \\<forall>j<aa. l'a ! j < l'a ! ((aa + n) div 2);\n        p = l'a ! ((aa + n) div 2);\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        j < (aa + n) div 2\\<rbrakk>\n       \\<Longrightarrow> l'a ! j < l'a ! ((aa + n) div 2)\n 2. \\<And>l' aa b l'a aaa ba j.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n        p = l'a ! ((aa + b) div 2);\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        j < (aa + b) div 2; l'a ! ((aa + b) div 2) \\<le> l' ! b\\<rbrakk>\n       \\<Longrightarrow> l'a ! j < l'a ! ((aa + b) div 2)\n 3. \\<And>l' aa b l'a.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n        b < n \\<longrightarrow> l'a ! ((aa + b) div 2) \\<le> l' ! b;\n        p = l'a ! ((aa + b) div 2);\n        \\<exists>h. h \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        (aa + b) div 2 < n\\<rbrakk>\n       \\<Longrightarrow> l'a ! ((aa + b) div 2) \\<le> l' ! ((aa + b) div 2)\n 4. \\<And>l' s.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> xs ! h))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (l < n \\<longrightarrow> p \\<le> xs ! l)))\n 5. \\<And>l' x.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. xs ! j < p) \\<and>\n                               (l < n \\<longrightarrow> p \\<le> xs ! l))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r. take n l' ! j < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> take n l' ! r))>", "subgoal for l' aa l'a aaa ba j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + n) div 2);\n     p = l'a ! ((aa + n) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + n) div 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + n) div 2);\n     p = l'a ! ((aa + n) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + n) div 2)", "assume t0: \"aa < n\""], ["proof (state)\nthis:\n  aa < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + n) div 2);\n     p = l'a ! ((aa + n) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + n) div 2)", "assume t1: \" n \\<le> length l'a\""], ["proof (state)\nthis:\n  n \\<le> length l'a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + n) div 2);\n     p = l'a ! ((aa + n) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + n) div 2)", "assume t4: \"sorted_less (take n l'a)\""], ["proof (state)\nthis:\n  sorted_less (take n l'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + n) div 2);\n     p = l'a ! ((aa + n) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + n) div 2)", "assume t5: \"j < (aa + n) div 2\""], ["proof (state)\nthis:\n  j < (aa + n) div 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + n) div 2);\n     p = l'a ! ((aa + n) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + n) div 2)", "have \"(aa+n) div 2 < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (aa + n) div 2 < n", "using t0"], ["proof (prove)\nusing this:\n  aa < n\n\ngoal (1 subgoal):\n 1. (aa + n) div 2 < n", "by linarith"], ["proof (state)\nthis:\n  (aa + n) div 2 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + n) div 2);\n     p = l'a ! ((aa + n) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + n) div 2)", "then"], ["proof (chain)\npicking this:\n  (aa + n) div 2 < n", "have \"(take n l'a) ! j < (take n l'a) ! ((aa + n) div 2)\""], ["proof (prove)\nusing this:\n  (aa + n) div 2 < n\n\ngoal (1 subgoal):\n 1. take n l'a ! j < take n l'a ! ((aa + n) div 2)", "using t0 sorted_wrt_nth_less[where xs=\"take n l'a\" and ?j=\"((aa + n) div 2)\"]\n        t1 t4 t5"], ["proof (prove)\nusing this:\n  (aa + n) div 2 < n\n  aa < n\n  \\<lbrakk>sorted_wrt ?P (take n l'a); ?i < (aa + n) div 2;\n   (aa + n) div 2 < length (take n l'a)\\<rbrakk>\n  \\<Longrightarrow> ?P (take n l'a ! ?i) (take n l'a ! ((aa + n) div 2))\n  n \\<le> length l'a\n  sorted_less (take n l'a)\n  j < (aa + n) div 2\n\ngoal (1 subgoal):\n 1. take n l'a ! j < take n l'a ! ((aa + n) div 2)", "by auto"], ["proof (state)\nthis:\n  take n l'a ! j < take n l'a ! ((aa + n) div 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < n; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + n) div 2);\n     p = l'a ! ((aa + n) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + n) div 2\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + n) div 2)", "then"], ["proof (chain)\npicking this:\n  take n l'a ! j < take n l'a ! ((aa + n) div 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  take n l'a ! j < take n l'a ! ((aa + n) div 2)\n\ngoal (1 subgoal):\n 1. l'a ! j < l'a ! ((aa + n) div 2)", "using \\<open>(aa + n) div 2 < n\\<close> t5"], ["proof (prove)\nusing this:\n  take n l'a ! j < take n l'a ! ((aa + n) div 2)\n  (aa + n) div 2 < n\n  j < (aa + n) div 2\n\ngoal (1 subgoal):\n 1. l'a ! j < l'a ! ((aa + n) div 2)", "by auto"], ["proof (state)\nthis:\n  l'a ! j < l'a ! ((aa + n) div 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l' aa b l'a aaa ba j.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n        p = l'a ! ((aa + b) div 2);\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        j < (aa + b) div 2; l'a ! ((aa + b) div 2) \\<le> l' ! b\\<rbrakk>\n       \\<Longrightarrow> l'a ! j < l'a ! ((aa + b) div 2)\n 2. \\<And>l' aa b l'a.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n        b < n \\<longrightarrow> l'a ! ((aa + b) div 2) \\<le> l' ! b;\n        p = l'a ! ((aa + b) div 2);\n        \\<exists>h. h \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        (aa + b) div 2 < n\\<rbrakk>\n       \\<Longrightarrow> l'a ! ((aa + b) div 2) \\<le> l' ! ((aa + b) div 2)\n 3. \\<And>l' s.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> xs ! h))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (l < n \\<longrightarrow> p \\<le> xs ! l)))\n 4. \\<And>l' x.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. xs ! j < p) \\<and>\n                               (l < n \\<longrightarrow> p \\<le> xs ! l))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r. take n l' ! j < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> take n l' ! r))>", "subgoal for l' aa b l'a aaa ba j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n     p = l'a ! ((aa + b) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; l'a ! ((aa + b) div 2) \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + b) div 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n     p = l'a ! ((aa + b) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; l'a ! ((aa + b) div 2) \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + b) div 2)", "assume t0: \"aa < b\""], ["proof (state)\nthis:\n  aa < b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n     p = l'a ! ((aa + b) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; l'a ! ((aa + b) div 2) \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + b) div 2)", "assume t1: \" n \\<le> length l'a\""], ["proof (state)\nthis:\n  n \\<le> length l'a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n     p = l'a ! ((aa + b) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; l'a ! ((aa + b) div 2) \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + b) div 2)", "assume t3: \"b \\<le> n\""], ["proof (state)\nthis:\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n     p = l'a ! ((aa + b) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; l'a ! ((aa + b) div 2) \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + b) div 2)", "assume t4: \"sorted_less (take n l'a)\""], ["proof (state)\nthis:\n  sorted_less (take n l'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n     p = l'a ! ((aa + b) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; l'a ! ((aa + b) div 2) \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + b) div 2)", "assume t5: \"j < (aa + b) div 2\""], ["proof (state)\nthis:\n  j < (aa + b) div 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n     p = l'a ! ((aa + b) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; l'a ! ((aa + b) div 2) \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + b) div 2)", "have \"(aa+b) div 2 < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (aa + b) div 2 < n", "using t3 t0"], ["proof (prove)\nusing this:\n  b \\<le> n\n  aa < b\n\ngoal (1 subgoal):\n 1. (aa + b) div 2 < n", "by linarith"], ["proof (state)\nthis:\n  (aa + b) div 2 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n     p = l'a ! ((aa + b) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; l'a ! ((aa + b) div 2) \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + b) div 2)", "then"], ["proof (chain)\npicking this:\n  (aa + b) div 2 < n", "have \"(take n l'a) ! j < (take n l'a) ! ((aa + b) div 2)\""], ["proof (prove)\nusing this:\n  (aa + b) div 2 < n\n\ngoal (1 subgoal):\n 1. take n l'a ! j < take n l'a ! ((aa + b) div 2)", "using t0 sorted_wrt_nth_less[where xs=\"take n l'a\" and ?j=\"((aa + b) div 2)\"]\n        t1 t4 t5"], ["proof (prove)\nusing this:\n  (aa + b) div 2 < n\n  aa < b\n  \\<lbrakk>sorted_wrt ?P (take n l'a); ?i < (aa + b) div 2;\n   (aa + b) div 2 < length (take n l'a)\\<rbrakk>\n  \\<Longrightarrow> ?P (take n l'a ! ?i) (take n l'a ! ((aa + b) div 2))\n  n \\<le> length l'a\n  sorted_less (take n l'a)\n  j < (aa + b) div 2\n\ngoal (1 subgoal):\n 1. take n l'a ! j < take n l'a ! ((aa + b) div 2)", "by auto"], ["proof (state)\nthis:\n  take n l'a ! j < take n l'a ! ((aa + b) div 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n     n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n     take n l' = take n l'a; b \\<le> n;\n     \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n     p = l'a ! ((aa + b) div 2);\n     (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n     j < (aa + b) div 2; l'a ! ((aa + b) div 2) \\<le> l' ! b\\<rbrakk>\n    \\<Longrightarrow> l'a ! j < l'a ! ((aa + b) div 2)", "then"], ["proof (chain)\npicking this:\n  take n l'a ! j < take n l'a ! ((aa + b) div 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  take n l'a ! j < take n l'a ! ((aa + b) div 2)\n\ngoal (1 subgoal):\n 1. l'a ! j < l'a ! ((aa + b) div 2)", "using \\<open>(aa + b) div 2 < n\\<close> t5"], ["proof (prove)\nusing this:\n  take n l'a ! j < take n l'a ! ((aa + b) div 2)\n  (aa + b) div 2 < n\n  j < (aa + b) div 2\n\ngoal (1 subgoal):\n 1. l'a ! j < l'a ! ((aa + b) div 2)", "by auto"], ["proof (state)\nthis:\n  l'a ! j < l'a ! ((aa + b) div 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l' aa b l'a.\n       \\<lbrakk>sorted_less (take n l'a); aa < b; c = length l'a;\n        n \\<le> length l'a; xs = take n l'a; length l' = length l'a;\n        take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. l'a ! j < l'a ! ((aa + b) div 2);\n        b < n \\<longrightarrow> l'a ! ((aa + b) div 2) \\<le> l' ! b;\n        p = l'a ! ((aa + b) div 2);\n        \\<exists>h. h \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        (aa + b) div 2 < n\\<rbrakk>\n       \\<Longrightarrow> l'a ! ((aa + b) div 2) \\<le> l' ! ((aa + b) div 2)\n 2. \\<And>l' s.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> xs ! h))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (l < n \\<longrightarrow> p \\<le> xs ! l)))\n 3. \\<And>l' x.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. xs ! j < p) \\<and>\n                               (l < n \\<longrightarrow> p \\<le> xs ! l))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r. take n l' ! j < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> take n l' ! r))>", "apply (metis nth_take order_mono_setup.refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l' s.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> xs ! h))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. xs ! j < p) \\<and>\n                              (l < n \\<longrightarrow> p \\<le> xs ! l)))\n 2. \\<And>l' x.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. xs ! j < p) \\<and>\n                               (l < n \\<longrightarrow> p \\<le> xs ! l))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r. take n l' ! j < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> take n l' ! r))>", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l' x.\n       \\<lbrakk>sorted_less (take n l');\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. xs ! j < p) \\<and>\n                               (l < n \\<longrightarrow> p \\<le> xs ! l))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r. take n l' ! j < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> take n l' ! r))>", "apply (sep_auto simp add: is_pfa_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \"Then, using the same loop invariant, a binary split for B-tree-like arrays\nis derived in a straightforward manner.\""], ["", "definition bin_split :: \"('a::heap \\<times> 'b::{heap,linorder}) pfarray \\<Rightarrow> 'b \\<Rightarrow> nat Heap\"\n  where\n    \"bin_split \\<equiv> \\<lambda>(a,n) p. do {\n  (low',high') \\<leftarrow> heap_WHILET \n    (\\<lambda>(low,high). return (low < high)) \n    (\\<lambda>(low,high). let mid = ((low  + high) div 2) in\n     do {\n      (_,s) \\<leftarrow> Array.nth a mid;\n      if p < s then\n         return (low, mid)\n      else if p > s then\n         return (mid+1, high)\n      else return (mid,mid)\n     }) \n    (0::nat,n);\n  return low'\n}\""], ["", "thm nth_take"], ["", "lemma nth_take_eq: \"take n ls = take n ls' \\<Longrightarrow> i < n \\<Longrightarrow> ls!i = ls'!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>take n ls = take n ls'; i < n\\<rbrakk>\n    \\<Longrightarrow> ls ! i = ls' ! i", "by (metis nth_take)"], ["", "lemma map_snd_sorted_less: \"\\<lbrakk>sorted_less (map snd xs); i < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> snd (xs ! i) < snd (xs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (separators xs); i < j; j < length xs\\<rbrakk>\n    \\<Longrightarrow> snd (xs ! i) < snd (xs ! j)", "by (metis (mono_tags, hide_lams) length_map less_trans nth_map sorted_wrt_iff_nth_less)"], ["", "lemma map_snd_sorted_lesseq: \"\\<lbrakk>sorted_less (map snd xs); i \\<le> j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> snd (xs ! i) \\<le> snd (xs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (separators xs); i \\<le> j; j < length xs\\<rbrakk>\n    \\<Longrightarrow> snd (xs ! i) \\<le> snd (xs ! j)", "by (metis eq_iff less_imp_le map_snd_sorted_less order.not_eq_order_implies_strict)"], ["", "lemma bin_split_rule: \"\nsorted_less (map snd xs) \\<Longrightarrow>\n< is_pfa c xs (a,n)>\n bin_split (a,n) p\n <\\<lambda>l. is_pfa c xs (a,n) * \\<up>(l \\<le> n \\<and> (\\<forall>j<l. snd(xs!j) < p) \\<and> (l<n \\<longrightarrow> snd(xs!l)\\<ge>p)) >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (separators xs) \\<Longrightarrow>\n    <is_pfa c xs\n      (a, n)> bin_split (a, n)\n               p <\\<lambda>r.\n                     is_pfa c xs (a, n) *\n                     \\<up>\n                      (r \\<le> n \\<and>\n                       (\\<forall>j<r. snd (xs ! j) < p) \\<and>\n                       (r < n \\<longrightarrow>\n                        p \\<le> snd (xs ! r)))>\\<^sub>t", "(* this works in principle, as demonstrated above *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (separators xs) \\<Longrightarrow>\n    <is_pfa c xs\n      (a, n)> bin_split (a, n)\n               p <\\<lambda>r.\n                     is_pfa c xs (a, n) *\n                     \\<up>\n                      (r \\<le> n \\<and>\n                       (\\<forall>j<r. snd (xs ! j) < p) \\<and>\n                       (r < n \\<longrightarrow>\n                        p \\<le> snd (xs ! r)))>\\<^sub>t", "unfolding bin_split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (separators xs) \\<Longrightarrow>\n    <is_pfa c xs\n      (a, n)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>p.\n                    heap_WHILET (\\<lambda>(low, high). return (low < high))\n                     (\\<lambda>(low, high).\n                         let mid = (low + high) div 2\n                         in Array.nth a mid \\<bind>\n                            (\\<lambda>(uu_, s).\n                                if p < s then return (low, mid)\n                                else if s < p then return (mid + 1, high)\n                                     else return (mid, mid)))\n                     (0, n) \\<bind>\n                    (\\<lambda>(low', high'). return low'))\n               p <\\<lambda>r.\n                     is_pfa c xs (a, n) *\n                     \\<up>\n                      (r \\<le> n \\<and>\n                       (\\<forall>j<r. snd (xs ! j) < p) \\<and>\n                       (r < n \\<longrightarrow>\n                        p \\<le> snd (xs ! r)))>\\<^sub>t", "supply R = heap_WHILET_rule''[where \n      R = \"measure (\\<lambda>(l,h). h-l)\"\n      and I = \"\\<lambda>(l,h). is_pfa c xs (a,n) * \\<up>(l\\<le>h \\<and> h \\<le> n \\<and> (\\<forall>j<l. snd (xs!j) < p) \\<and> (h<n \\<longrightarrow> snd (xs!h)\\<ge>p))\"\n      and b = \"\\<lambda>(l,h). l<h\"\n      and Q=\"\\<lambda>(l,h). is_pfa c xs (a,n) * \\<up>(l \\<le> n \\<and> (\\<forall>j<l. snd (xs!j) < p) \\<and> (l<n \\<longrightarrow> snd (xs!l)\\<ge>p))\"\n      ]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (separators xs) \\<Longrightarrow>\n    <is_pfa c xs\n      (a, n)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>p.\n                    heap_WHILET (\\<lambda>(low, high). return (low < high))\n                     (\\<lambda>(low, high).\n                         let mid = (low + high) div 2\n                         in Array.nth a mid \\<bind>\n                            (\\<lambda>(uu_, s).\n                                if p < s then return (low, mid)\n                                else if s < p then return (mid + 1, high)\n                                     else return (mid, mid)))\n                     (0, n) \\<bind>\n                    (\\<lambda>(low', high'). return low'))\n               p <\\<lambda>r.\n                     is_pfa c xs (a, n) *\n                     \\<up>\n                      (r \\<le> n \\<and>\n                       (\\<forall>j<r. snd (xs ! j) < p) \\<and>\n                       (r < n \\<longrightarrow>\n                        p \\<le> snd (xs ! r)))>\\<^sub>t", "thm R"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (separators xs) \\<Longrightarrow>\n    <is_pfa c xs\n      (a, n)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>p.\n                    heap_WHILET (\\<lambda>(low, high). return (low < high))\n                     (\\<lambda>(low, high).\n                         let mid = (low + high) div 2\n                         in Array.nth a mid \\<bind>\n                            (\\<lambda>(uu_, s).\n                                if p < s then return (low, mid)\n                                else if s < p then return (mid + 1, high)\n                                     else return (mid, mid)))\n                     (0, n) \\<bind>\n                    (\\<lambda>(low', high'). return low'))\n               p <\\<lambda>r.\n                     is_pfa c xs (a, n) *\n                     \\<up>\n                      (r \\<le> n \\<and>\n                       (\\<forall>j<r. snd (xs ! j) < p) \\<and>\n                       (r < n \\<longrightarrow>\n                        p \\<le> snd (xs ! r)))>\\<^sub>t", "apply (sep_auto decon: R simp: less_Suc_eq is_pfa_def) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l' aa l'a ba uu_ aaa bb.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < n;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a;\n        \\<forall>j<aa. snd (l'a ! j) < p;\n        l'a ! ((aa + n) div 2) = (uu_, ba); p < ba; (aa + n) div 2 < n;\n        (aaa, bb) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true\\<rbrakk>\n       \\<Longrightarrow> p \\<le> snd (l' ! ((aa + n) div 2))\n 2. \\<And>l' aa b l'a ba uu_ aaa bb.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < p;\n        l'a ! ((aa + b) div 2) = (uu_, ba); p < ba; (aa + b) div 2 < n;\n        (aaa, bb) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        p \\<le> snd (l' ! b)\\<rbrakk>\n       \\<Longrightarrow> p \\<le> snd (l' ! ((aa + b) div 2))\n 3. \\<And>l' aa b l'a aaa ba uu_ s.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < p;\n        b < n \\<longrightarrow> p \\<le> snd (l' ! b); (aaa, ba) = (uu_, s);\n        l'a ! ((aa + b) div 2) = (uu_, s); \\<not> p < s\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         if s < p then return ((aa + b) div 2 + 1, b)\n                         else return ((aa + b) div 2, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   snd (take n l'a ! j) < p) \\<and>\n                                     (h < n \\<longrightarrow>\np \\<le> snd (l' ! h)))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 4. \\<And>l' s.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> snd\n  (xs ! h)))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (l < n \\<longrightarrow>\n                               p \\<le> snd (xs ! l))))\n 5. \\<And>l' x.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                               (l < n \\<longrightarrow>\n                                p \\<le> snd (xs ! l)))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r.\nsnd (take n l' ! j) < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> snd (take n l' ! r)))>", "apply(auto dest!: sndI nth_take_eq[of n _ _ \"(_ + _) div 2\"])[]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l' aa b l'a ba uu_ aaa bb.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < p;\n        l'a ! ((aa + b) div 2) = (uu_, ba); p < ba; (aa + b) div 2 < n;\n        (aaa, bb) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        p \\<le> snd (l' ! b)\\<rbrakk>\n       \\<Longrightarrow> p \\<le> snd (l' ! ((aa + b) div 2))\n 2. \\<And>l' aa b l'a aaa ba uu_ s.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < p;\n        b < n \\<longrightarrow> p \\<le> snd (l' ! b); (aaa, ba) = (uu_, s);\n        l'a ! ((aa + b) div 2) = (uu_, s); \\<not> p < s\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         if s < p then return ((aa + b) div 2 + 1, b)\n                         else return ((aa + b) div 2, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   snd (take n l'a ! j) < p) \\<and>\n                                     (h < n \\<longrightarrow>\np \\<le> snd (l' ! h)))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 3. \\<And>l' s.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> snd\n  (xs ! h)))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (l < n \\<longrightarrow>\n                               p \\<le> snd (xs ! l))))\n 4. \\<And>l' x.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                               (l < n \\<longrightarrow>\n                                p \\<le> snd (xs ! l)))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r.\nsnd (take n l' ! j) < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> snd (take n l' ! r)))>", "apply(auto dest!: sndI nth_take_eq[of n _ _ \"(_ + _) div 2\"])[]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l' aa b l'a aaa ba uu_ s.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < p;\n        b < n \\<longrightarrow> p \\<le> snd (l' ! b); (aaa, ba) = (uu_, s);\n        l'a ! ((aa + b) div 2) = (uu_, s); \\<not> p < s\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         if s < p then return ((aa + b) div 2 + 1, b)\n                         else return ((aa + b) div 2, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   snd (take n l'a ! j) < p) \\<and>\n                                     (h < n \\<longrightarrow>\np \\<le> snd (l' ! h)))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 2. \\<And>l' s.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> snd\n  (xs ! h)))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (l < n \\<longrightarrow>\n                               p \\<le> snd (xs ! l))))\n 3. \\<And>l' x.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                               (l < n \\<longrightarrow>\n                                p \\<le> snd (xs ! l)))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r.\nsnd (take n l' ! j) < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> snd (take n l' ! r)))>", "apply (sep_auto dest!: sndI )"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l' aa l'a aaa ba j.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < n;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a;\n        \\<forall>j<aa. snd (l'a ! j) < p; snd (l'a ! ((aa + n) div 2)) < p;\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        j < Suc ((aa + n) div 2)\\<rbrakk>\n       \\<Longrightarrow> snd (l'a ! j) < p\n 2. \\<And>l' aa b l'a aaa ba j.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < p; snd (l'a ! ((aa + b) div 2)) < p;\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        j < Suc ((aa + b) div 2); p \\<le> snd (l' ! b)\\<rbrakk>\n       \\<Longrightarrow> snd (l'a ! j) < p\n 3. \\<And>l' aa b l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < p;\n        b < n \\<longrightarrow> p \\<le> snd (l' ! b);\n        \\<not> p < snd (l'a ! ((aa + b) div 2));\n        snd (l'a ! ((aa + b) div 2)) = p\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         return ((aa + b) div 2, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   snd (take n l'a ! j) < p) \\<and>\n                                     (h < n \\<longrightarrow>\np \\<le> snd (l' ! h)))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 4. \\<And>l' s.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> snd\n  (xs ! h)))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (l < n \\<longrightarrow>\n                               p \\<le> snd (xs ! l))))\n 5. \\<And>l' x.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                               (l < n \\<longrightarrow>\n                                p \\<le> snd (xs ! l)))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r.\nsnd (take n l' ! j) < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> snd (take n l' ! r)))>", "subgoal for ls i ls' _ _ j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (separators (take n ls')); i < n; c = length ls';\n     n \\<le> length ls'; xs = take n ls'; length ls = length ls';\n     take n ls = take n ls'; \\<forall>j<i. snd (ls' ! j) < p;\n     snd (ls' ! ((i + n) div 2)) < p;\n     (aaa_, ba_) \\<Turnstile> a \\<mapsto>\\<^sub>a ls' * true;\n     j < Suc ((i + n) div 2)\\<rbrakk>\n    \\<Longrightarrow> snd (ls' ! j) < p", "using map_snd_sorted_lesseq[of \"take n ls'\" j \"(i + n) div 2\"] \n      less_mult_imp_div_less"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_less (separators (take n ls')); j \\<le> (i + n) div 2;\n   (i + n) div 2 < length (take n ls')\\<rbrakk>\n  \\<Longrightarrow> snd (take n ls' ! j)\n                    \\<le> snd (take n ls' ! ((i + n) div 2))\n  ?m < ?i * ?n \\<Longrightarrow> ?m div ?n < ?i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (separators (take n ls')); i < n; c = length ls';\n     n \\<le> length ls'; xs = take n ls'; length ls = length ls';\n     take n ls = take n ls'; \\<forall>j<i. snd (ls' ! j) < p;\n     snd (ls' ! ((i + n) div 2)) < p;\n     (aaa_, ba_) \\<Turnstile> a \\<mapsto>\\<^sub>a ls' * true;\n     j < Suc ((i + n) div 2)\\<rbrakk>\n    \\<Longrightarrow> snd (ls' ! j) < p", "apply(auto)[]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l' aa b l'a aaa ba j.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < p; snd (l'a ! ((aa + b) div 2)) < p;\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        j < Suc ((aa + b) div 2); p \\<le> snd (l' ! b)\\<rbrakk>\n       \\<Longrightarrow> snd (l'a ! j) < p\n 2. \\<And>l' aa b l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < p;\n        b < n \\<longrightarrow> p \\<le> snd (l' ! b);\n        \\<not> p < snd (l'a ! ((aa + b) div 2));\n        snd (l'a ! ((aa + b) div 2)) = p\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         return ((aa + b) div 2, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   snd (take n l'a ! j) < p) \\<and>\n                                     (h < n \\<longrightarrow>\np \\<le> snd (l' ! h)))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 3. \\<And>l' s.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> snd\n  (xs ! h)))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (l < n \\<longrightarrow>\n                               p \\<le> snd (xs ! l))))\n 4. \\<And>l' x.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                               (l < n \\<longrightarrow>\n                                p \\<le> snd (xs ! l)))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r.\nsnd (take n l' ! j) < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> snd (take n l' ! r)))>", "subgoal for ls i j ls' _ _ j'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (separators (take n ls')); i < j; c = length ls';\n     n \\<le> length ls'; xs = take n ls'; length ls = length ls';\n     take n ls = take n ls'; j \\<le> n; \\<forall>j<i. snd (ls' ! j) < p;\n     snd (ls' ! ((i + j) div 2)) < p;\n     (aaa_, ba_) \\<Turnstile> a \\<mapsto>\\<^sub>a ls' * true;\n     j' < Suc ((i + j) div 2); p \\<le> snd (ls ! j)\\<rbrakk>\n    \\<Longrightarrow> snd (ls' ! j') < p", "using map_snd_sorted_lesseq[of \"take n ls'\" j' \"(i + j) div 2\"] \n      less_mult_imp_div_less"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_less (separators (take n ls')); j' \\<le> (i + j) div 2;\n   (i + j) div 2 < length (take n ls')\\<rbrakk>\n  \\<Longrightarrow> snd (take n ls' ! j')\n                    \\<le> snd (take n ls' ! ((i + j) div 2))\n  ?m < ?i * ?n \\<Longrightarrow> ?m div ?n < ?i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (separators (take n ls')); i < j; c = length ls';\n     n \\<le> length ls'; xs = take n ls'; length ls = length ls';\n     take n ls = take n ls'; j \\<le> n; \\<forall>j<i. snd (ls' ! j) < p;\n     snd (ls' ! ((i + j) div 2)) < p;\n     (aaa_, ba_) \\<Turnstile> a \\<mapsto>\\<^sub>a ls' * true;\n     j' < Suc ((i + j) div 2); p \\<le> snd (ls ! j)\\<rbrakk>\n    \\<Longrightarrow> snd (ls' ! j') < p", "apply(auto)[]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l' aa b l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < p;\n        b < n \\<longrightarrow> p \\<le> snd (l' ! b);\n        \\<not> p < snd (l'a ! ((aa + b) div 2));\n        snd (l'a ! ((aa + b) div 2)) = p\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l'a * true>\n                         return ((aa + b) div 2, (aa + b) div 2)\n                         <\\<lambda>r.\n                             (case r of\n                              (l, h) \\<Rightarrow>\n                                \\<exists>\\<^sub>Al'aa.\n                                   a \\<mapsto>\\<^sub>a l'aa *\n                                   \\<up>\n                                    (length l'a = length l'aa \\<and>\n                                     take n l'a = take n l'aa) *\n                                   \\<up>\n                                    (l \\<le> h \\<and>\n                                     h \\<le> n \\<and>\n                                     (\\<forall>j<l.\n   snd (take n l'a ! j) < p) \\<and>\n                                     (h < n \\<longrightarrow>\np \\<le> snd (l' ! h)))) *\n                             true *\n                             \\<up>\n                              ((case r of (l, h) \\<Rightarrow> h - l)\n                               < b - aa)>\n 2. \\<And>l' s.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> snd\n  (xs ! h)))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (l < n \\<longrightarrow>\n                               p \\<le> snd (xs ! l))))\n 3. \\<And>l' x.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                               (l < n \\<longrightarrow>\n                                p \\<le> snd (xs ! l)))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r.\nsnd (take n l' ! j) < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> snd (take n l' ! r)))>", "apply sep_auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l' aa l'a aaa ba j.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < n;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a;\n        \\<forall>j<aa. snd (l'a ! j) < snd (l'a ! ((aa + n) div 2));\n        p = snd (l'a ! ((aa + n) div 2));\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        j < (aa + n) div 2\\<rbrakk>\n       \\<Longrightarrow> snd (l'a ! j) < snd (l'a ! ((aa + n) div 2))\n 2. \\<And>l' aa b l'a aaa ba j.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < snd (l'a ! ((aa + b) div 2));\n        p = snd (l'a ! ((aa + b) div 2));\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        j < (aa + b) div 2;\n        snd (l'a ! ((aa + b) div 2)) \\<le> snd (l' ! b)\\<rbrakk>\n       \\<Longrightarrow> snd (l'a ! j) < snd (l'a ! ((aa + b) div 2))\n 3. \\<And>l' aa b l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < snd (l'a ! ((aa + b) div 2));\n        b < n \\<longrightarrow>\n        snd (l'a ! ((aa + b) div 2)) \\<le> snd (l' ! b);\n        p = snd (l'a ! ((aa + b) div 2));\n        \\<exists>h. h \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        (aa + b) div 2 < n\\<rbrakk>\n       \\<Longrightarrow> snd (l'a ! ((aa + b) div 2))\n                         \\<le> snd (l' ! ((aa + b) div 2))\n 4. \\<And>l' s.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> snd\n  (xs ! h)))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (l < n \\<longrightarrow>\n                               p \\<le> snd (xs ! l))))\n 5. \\<And>l' x.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                               (l < n \\<longrightarrow>\n                                p \\<le> snd (xs ! l)))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r.\nsnd (take n l' ! j) < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> snd (take n l' ! r)))>", "subgoal for ls i ls' _ _ j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (separators (take n ls')); i < n; c = length ls';\n     n \\<le> length ls'; xs = take n ls'; length ls = length ls';\n     take n ls = take n ls';\n     \\<forall>j<i. snd (ls' ! j) < snd (ls' ! ((i + n) div 2));\n     p = snd (ls' ! ((i + n) div 2));\n     (aaa_, ba_) \\<Turnstile> a \\<mapsto>\\<^sub>a ls' * true;\n     j < (i + n) div 2\\<rbrakk>\n    \\<Longrightarrow> snd (ls' ! j) < snd (ls' ! ((i + n) div 2))", "using map_snd_sorted_less[of \"take n ls'\" j \"(i + n) div 2\"] \n      less_mult_imp_div_less"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_less (separators (take n ls')); j < (i + n) div 2;\n   (i + n) div 2 < length (take n ls')\\<rbrakk>\n  \\<Longrightarrow> snd (take n ls' ! j)\n                    < snd (take n ls' ! ((i + n) div 2))\n  ?m < ?i * ?n \\<Longrightarrow> ?m div ?n < ?i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (separators (take n ls')); i < n; c = length ls';\n     n \\<le> length ls'; xs = take n ls'; length ls = length ls';\n     take n ls = take n ls';\n     \\<forall>j<i. snd (ls' ! j) < snd (ls' ! ((i + n) div 2));\n     p = snd (ls' ! ((i + n) div 2));\n     (aaa_, ba_) \\<Turnstile> a \\<mapsto>\\<^sub>a ls' * true;\n     j < (i + n) div 2\\<rbrakk>\n    \\<Longrightarrow> snd (ls' ! j) < snd (ls' ! ((i + n) div 2))", "apply(auto)[]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l' aa b l'a aaa ba j.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < snd (l'a ! ((aa + b) div 2));\n        p = snd (l'a ! ((aa + b) div 2));\n        (aaa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        j < (aa + b) div 2;\n        snd (l'a ! ((aa + b) div 2)) \\<le> snd (l' ! b)\\<rbrakk>\n       \\<Longrightarrow> snd (l'a ! j) < snd (l'a ! ((aa + b) div 2))\n 2. \\<And>l' aa b l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < snd (l'a ! ((aa + b) div 2));\n        b < n \\<longrightarrow>\n        snd (l'a ! ((aa + b) div 2)) \\<le> snd (l' ! b);\n        p = snd (l'a ! ((aa + b) div 2));\n        \\<exists>h. h \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        (aa + b) div 2 < n\\<rbrakk>\n       \\<Longrightarrow> snd (l'a ! ((aa + b) div 2))\n                         \\<le> snd (l' ! ((aa + b) div 2))\n 3. \\<And>l' s.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> snd\n  (xs ! h)))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (l < n \\<longrightarrow>\n                               p \\<le> snd (xs ! l))))\n 4. \\<And>l' x.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                               (l < n \\<longrightarrow>\n                                p \\<le> snd (xs ! l)))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r.\nsnd (take n l' ! j) < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> snd (take n l' ! r)))>", "subgoal for ls i j ls' _ _ j'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (separators (take n ls')); i < j; c = length ls';\n     n \\<le> length ls'; xs = take n ls'; length ls = length ls';\n     take n ls = take n ls'; j \\<le> n;\n     \\<forall>ja<i. snd (ls' ! ja) < snd (ls' ! ((i + j) div 2));\n     p = snd (ls' ! ((i + j) div 2));\n     (aaa_, ba_) \\<Turnstile> a \\<mapsto>\\<^sub>a ls' * true;\n     j' < (i + j) div 2;\n     snd (ls' ! ((i + j) div 2)) \\<le> snd (ls ! j)\\<rbrakk>\n    \\<Longrightarrow> snd (ls' ! j') < snd (ls' ! ((i + j) div 2))", "using map_snd_sorted_less[of \"take n ls'\" j' \"(i + j) div 2\"] \n      less_mult_imp_div_less"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_less (separators (take n ls')); j' < (i + j) div 2;\n   (i + j) div 2 < length (take n ls')\\<rbrakk>\n  \\<Longrightarrow> snd (take n ls' ! j')\n                    < snd (take n ls' ! ((i + j) div 2))\n  ?m < ?i * ?n \\<Longrightarrow> ?m div ?n < ?i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (separators (take n ls')); i < j; c = length ls';\n     n \\<le> length ls'; xs = take n ls'; length ls = length ls';\n     take n ls = take n ls'; j \\<le> n;\n     \\<forall>ja<i. snd (ls' ! ja) < snd (ls' ! ((i + j) div 2));\n     p = snd (ls' ! ((i + j) div 2));\n     (aaa_, ba_) \\<Turnstile> a \\<mapsto>\\<^sub>a ls' * true;\n     j' < (i + j) div 2;\n     snd (ls' ! ((i + j) div 2)) \\<le> snd (ls ! j)\\<rbrakk>\n    \\<Longrightarrow> snd (ls' ! j') < snd (ls' ! ((i + j) div 2))", "apply(auto)[]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l' aa b l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a)); aa < b;\n        c = length l'a; n \\<le> length l'a; xs = take n l'a;\n        length l' = length l'a; take n l' = take n l'a; b \\<le> n;\n        \\<forall>j<aa. snd (l'a ! j) < snd (l'a ! ((aa + b) div 2));\n        b < n \\<longrightarrow>\n        snd (l'a ! ((aa + b) div 2)) \\<le> snd (l' ! b);\n        p = snd (l'a ! ((aa + b) div 2));\n        \\<exists>h. h \\<Turnstile> a \\<mapsto>\\<^sub>a l'a * true;\n        (aa + b) div 2 < n\\<rbrakk>\n       \\<Longrightarrow> snd (l'a ! ((aa + b) div 2))\n                         \\<le> snd (l' ! ((aa + b) div 2))\n 2. \\<And>l' s.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> snd\n  (xs ! h)))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (l < n \\<longrightarrow>\n                               p \\<le> snd (xs ! l))))\n 3. \\<And>l' x.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                               (l < n \\<longrightarrow>\n                                p \\<le> snd (xs ! l)))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r.\nsnd (take n l' ! j) < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> snd (take n l' ! r)))>", "apply (metis le_less nth_take_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l' s.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l';\n        \\<not> (case s of (l, h) \\<Rightarrow> l < h)\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> h \\<and>\n                              h \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (h < n \\<longrightarrow>\n                               p \\<le> snd\n  (xs ! h)))) \\<Longrightarrow>\\<^sub>A\n                         (case s of\n                          (l, h) \\<Rightarrow>\n                            is_pfa c xs (a, n) *\n                            \\<up>\n                             (l \\<le> n \\<and>\n                              (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                              (l < n \\<longrightarrow>\n                               p \\<le> snd (xs ! l))))\n 2. \\<And>l' x.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                               (l < n \\<longrightarrow>\n                                p \\<le> snd (xs ! l)))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r.\nsnd (take n l' ! j) < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> snd (take n l' ! r)))>", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l' x.\n       \\<lbrakk>sorted_less (separators (take n l'));\n        c = length l' \\<and> n \\<le> c \\<and> xs = take n l'\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (l, h) \\<Rightarrow>\n                             is_pfa c xs (a, n) *\n                             \\<up>\n                              (l \\<le> n \\<and>\n                               (\\<forall>j<l. snd (xs ! j) < p) \\<and>\n                               (l < n \\<longrightarrow>\n                                p \\<le> snd (xs ! l)))) *\n                          true>\n                         case x of (low', high') \\<Rightarrow> return low'\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Al'a.\n                                a \\<mapsto>\\<^sub>a l'a * true *\n                                \\<up>\n                                 (length l' = length l'a \\<and>\n                                  n \\<le> length l' \\<and>\n                                  take n l' = take n l'a \\<and>\n                                  r \\<le> n \\<and>\n                                  (\\<forall>j<r.\nsnd (take n l' ! j) < p) \\<and>\n                                  (r < n \\<longrightarrow>\n                                   p \\<le> snd (take n l' ! r)))>", "apply (sep_auto simp add: is_pfa_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Refinement of an abstract split\""], ["", "text \"We provide a certain abstract split function\nthat is particularly easy to analyse. The idea of this function is due to Peter Lammich.\""], ["", "definition \"abs_split xs x = (takeWhile (\\<lambda>(_,s). s<x) xs, dropWhile (\\<lambda>(_,s). s<x) xs)\""], ["", "interpretation btree_abs_search: split abs_split"], ["proof (prove)\ngoal (1 subgoal):\n 1. split abs_split", "unfolding abs_split_def sym[OF linear_split_alt]"], ["proof (prove)\ngoal (1 subgoal):\n 1. split linear_split", "by unfold_locales"], ["", "text \\<open>Any function that yields the heap rule\nwe have obtained for bin\\_split and lin\\_split also\nrefines this abstract split.\\<close>"], ["", "locale imp_split_smeq =\n  fixes split_fun :: \"('a::{heap,default,linorder} btnode ref option \\<times> 'a) array \\<times> nat \\<Rightarrow> 'a \\<Rightarrow> nat Heap\"\n  assumes split_rule: \"sorted_less (separators xs) \\<Longrightarrow> \n <is_pfa c xs (a, n)>\n   split_fun (a, n) (p::'a)\n  <\\<lambda>r. is_pfa c xs (a, n) *\n                 \\<up> (r \\<le> n \\<and>\n                   (\\<forall>j<r. snd (xs ! j) < p) \\<and>\n                   (r < n \\<longrightarrow> p \\<le> snd (xs ! r)))>\\<^sub>t\"\nbegin"], ["", "lemma abs_split_full: \"\\<forall>(_,s) \\<in> set xs. s < p \\<Longrightarrow> abs_split xs p = (xs,[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(uu_, s)\\<in>set xs. s < p \\<Longrightarrow>\n    abs_split xs p = (xs, [])", "by (simp add: abs_split_def)"], ["", "lemma abs_split_split:\n  assumes \"n < length xs\" \n    and \"(\\<forall>(_,s) \\<in> set (take n xs). s < p)\"\n    and \" (case (xs!n) of (_,s) \\<Rightarrow> \\<not>(s < p))\"\n  shows \"abs_split xs p = (take n xs, drop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_split xs p = (take n xs, drop n xs)", "using assms"], ["proof (prove)\nusing this:\n  n < length xs\n  \\<forall>(uu_, s)\\<in>set (take n xs). s < p\n  case xs ! n of (x, s) \\<Rightarrow> \\<not> s < p\n\ngoal (1 subgoal):\n 1. abs_split xs p = (take n xs, drop n xs)", "apply (auto simp add: abs_split_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>n < length xs;\n        \\<forall>x\\<in>set (take n xs).\n           case x of (uu_, s) \\<Rightarrow> s < p;\n        xs ! n = (x, y); \\<not> y < p\\<rbrakk>\n       \\<Longrightarrow> takeWhile (\\<lambda>(uu_, s). s < p) xs = take n xs\n 2. \\<And>x y.\n       \\<lbrakk>n < length xs;\n        \\<forall>x\\<in>set (take n xs).\n           case x of (uu_, s) \\<Rightarrow> s < p;\n        xs ! n = (x, y); \\<not> y < p\\<rbrakk>\n       \\<Longrightarrow> dropWhile (\\<lambda>(uu_, s). s < p) xs = drop n xs", "apply (metis (mono_tags, lifting) id_take_nth_drop old.prod.case takeWhile_eq_all_conv takeWhile_tail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>n < length xs;\n        \\<forall>x\\<in>set (take n xs).\n           case x of (uu_, s) \\<Rightarrow> s < p;\n        xs ! n = (x, y); \\<not> y < p\\<rbrakk>\n       \\<Longrightarrow> dropWhile (\\<lambda>(uu_, s). s < p) xs = drop n xs", "by (metis (no_types, lifting) Cons_nth_drop_Suc case_prod_conv dropWhile.simps(2) dropWhile_append2 id_take_nth_drop)"], ["", "lemma split_rule_abs_split: \n  shows\n    \"sorted_less (separators ts) \\<Longrightarrow> <\n    is_pfa c tsi (a,n)\n  * list_assn (A \\<times>\\<^sub>a id_assn) ts tsi> \n    split_fun (a,n) p \n  <\\<lambda>i. \n    is_pfa c tsi (a,n)\n    * list_assn (A \\<times>\\<^sub>a id_assn) ts tsi\n    * \\<up>(split_relation ts (abs_split ts p) i)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (separators ts) \\<Longrightarrow>\n    <is_pfa c tsi (a, n) *\n     list_assn (A \\<times>\\<^sub>a id_assn) ts\n      tsi> split_fun (a, n)\n            p <\\<lambda>r.\n                  is_pfa c tsi (a, n) *\n                  list_assn (A \\<times>\\<^sub>a id_assn) ts tsi *\n                  \\<up> (split_relation ts (abs_split ts p) r)>\\<^sub>t", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>sorted_less (separators ts);\n        h \\<Turnstile>\n        is_pfa c tsi (a, n) *\n        list_assn (A \\<times>\\<^sub>a id_assn) ts tsi\\<rbrakk>\n       \\<Longrightarrow> <is_pfa c tsi (a, n) *\n                          list_assn (A \\<times>\\<^sub>a id_assn) ts\n                           tsi> split_fun (a, n)\n                                 p <\\<lambda>r.\n is_pfa c tsi (a, n) * list_assn (A \\<times>\\<^sub>a id_assn) ts tsi *\n \\<up> (split_relation ts (abs_split ts p) r)>\\<^sub>t", "apply (sep_auto heap: split_rule dest!: mod_starD id_assn_list\n      simp add: list_assn_prod_map split_ismeq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba ad bd x ac bc af bf ag bg.\n       \\<lbrakk>sorted_less (separators tsi);\n        (aa, ba) \\<Turnstile> is_pfa c tsi (a, n);\n        (ad, bd) \\<Turnstile> list_assn A (subtrees ts) (subtrees tsi);\n        separators ts = separators tsi; in_range (ac, bc);\n        (af, bf) \\<Turnstile> list_assn A (subtrees ts) (subtrees tsi);\n        (ag, bg) \\<Turnstile> is_pfa c tsi (a, n); x < n;\n        \\<forall>j<x. snd (tsi ! j) < p; p \\<le> snd (tsi ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x\n 2. \\<And>aa ba ad bd ac bc af bf ag bg.\n       \\<lbrakk>sorted_less (separators tsi);\n        (aa, ba) \\<Turnstile> is_pfa c tsi (a, n);\n        (ad, bd) \\<Turnstile> list_assn A (subtrees ts) (subtrees tsi);\n        separators ts = separators tsi; in_range (ac, bc);\n        (af, bf) \\<Turnstile> list_assn A (subtrees ts) (subtrees tsi);\n        (ag, bg) \\<Turnstile> is_pfa c tsi (a, n);\n        \\<forall>j<n. snd (tsi ! j) < p\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) n\n 3. \\<And>aa ba ad bd ac bc af bf ag bg.\n       \\<lbrakk>sorted_less (separators tsi);\n        (aa, ba) \\<Turnstile> is_pfa c tsi (a, n);\n        (ad, bd) \\<Turnstile> list_assn A (subtrees ts) (subtrees tsi);\n        separators ts = separators tsi; in_range (ac, bc);\n        (af, bf) \\<Turnstile> list_assn A (subtrees ts) (subtrees tsi);\n        (ag, bg) \\<Turnstile> is_pfa c tsi (a, n);\n        \\<forall>j<n. snd (tsi ! j) < p; p \\<le> snd (tsi ! n)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) n", "apply(auto simp add: is_pfa_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba ad bd x ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        x < n; \\<forall>j<x. snd (l'a ! j) < p; p \\<le> snd (l'a ! x);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x\n 2. \\<And>aa ba ad bd ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        \\<forall>j<n. snd (l'a ! j) < p;\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) n\n 3. \\<And>aa ba ad bd ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        \\<forall>j<n. snd (l'a ! j) < p; p \\<le> snd (take n l'a ! n);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) n", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>aa ba ad bd x ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        x < n; \\<forall>j<x. snd (l'a ! j) < p; p \\<le> snd (l'a ! x);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x\n 2. \\<And>aa ba ad bd ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        \\<forall>j<n. snd (l'a ! j) < p;\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) n\n 3. \\<And>aa ba ad bd ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        \\<forall>j<n. snd (l'a ! j) < p; p \\<le> snd (take n l'a ! n);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) n", "fix h l'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>aa ba ad bd x ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        x < n; \\<forall>j<x. snd (l'a ! j) < p; p \\<le> snd (l'a ! x);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x\n 2. \\<And>aa ba ad bd ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        \\<forall>j<n. snd (l'a ! j) < p;\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) n\n 3. \\<And>aa ba ad bd ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        \\<forall>j<n. snd (l'a ! j) < p; p \\<le> snd (take n l'a ! n);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) n", "assume heap_init:\n    \"h \\<Turnstile> a \\<mapsto>\\<^sub>a l'\"\n    \"map snd ts = (map snd (take n l'))\"\n    \"n \\<le> length l'\""], ["proof (state)\nthis:\n  h \\<Turnstile> a \\<mapsto>\\<^sub>a l'\n  separators ts = separators (take n l')\n  n \\<le> length l'\n\ngoal (3 subgoals):\n 1. \\<And>aa ba ad bd x ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        x < n; \\<forall>j<x. snd (l'a ! j) < p; p \\<le> snd (l'a ! x);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x\n 2. \\<And>aa ba ad bd ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        \\<forall>j<n. snd (l'a ! j) < p;\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) n\n 3. \\<And>aa ba ad bd ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        \\<forall>j<n. snd (l'a ! j) < p; p \\<le> snd (take n l'a ! n);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) n", "show full_thm: \"\\<forall>j<n. snd (l' ! j) < p \\<Longrightarrow>\n       split_relation ts (abs_split ts p) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<n. snd (l' ! j) < p \\<Longrightarrow>\n    split_relation ts (abs_split ts p) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>j<n. snd (l' ! j) < p \\<Longrightarrow>\n    split_relation ts (abs_split ts p) n", "assume sm_list: \"\\<forall>j<n. snd (l' ! j) < p\""], ["proof (state)\nthis:\n  \\<forall>j<n. snd (l' ! j) < p\n\ngoal (1 subgoal):\n 1. \\<forall>j<n. snd (l' ! j) < p \\<Longrightarrow>\n    split_relation ts (abs_split ts p) n", "then"], ["proof (chain)\npicking this:\n  \\<forall>j<n. snd (l' ! j) < p", "have \"\\<forall>j < length (map snd (take n l')). ((map snd (take n l'))!j) < p\""], ["proof (prove)\nusing this:\n  \\<forall>j<n. snd (l' ! j) < p\n\ngoal (1 subgoal):\n 1. \\<forall>j<length (separators (take n l')).\n       separators (take n l') ! j < p", "by simp"], ["proof (state)\nthis:\n  \\<forall>j<length (separators (take n l')). separators (take n l') ! j < p\n\ngoal (1 subgoal):\n 1. \\<forall>j<n. snd (l' ! j) < p \\<Longrightarrow>\n    split_relation ts (abs_split ts p) n", "then"], ["proof (chain)\npicking this:\n  \\<forall>j<length (separators (take n l')). separators (take n l') ! j < p", "have \"\\<forall>j<length (map snd ts). ((map snd ts)!j) < p\""], ["proof (prove)\nusing this:\n  \\<forall>j<length (separators (take n l')). separators (take n l') ! j < p\n\ngoal (1 subgoal):\n 1. \\<forall>j<length (separators ts). separators ts ! j < p", "using heap_init"], ["proof (prove)\nusing this:\n  \\<forall>j<length (separators (take n l')). separators (take n l') ! j < p\n  h \\<Turnstile> a \\<mapsto>\\<^sub>a l'\n  separators ts = separators (take n l')\n  n \\<le> length l'\n\ngoal (1 subgoal):\n 1. \\<forall>j<length (separators ts). separators ts ! j < p", "by simp"], ["proof (state)\nthis:\n  \\<forall>j<length (separators ts). separators ts ! j < p\n\ngoal (1 subgoal):\n 1. \\<forall>j<n. snd (l' ! j) < p \\<Longrightarrow>\n    split_relation ts (abs_split ts p) n", "then"], ["proof (chain)\npicking this:\n  \\<forall>j<length (separators ts). separators ts ! j < p", "have \"\\<forall>(_,s) \\<in> set ts. s < p\""], ["proof (prove)\nusing this:\n  \\<forall>j<length (separators ts). separators ts ! j < p\n\ngoal (1 subgoal):\n 1. \\<forall>(uu_, s)\\<in>set ts. s < p", "by (metis case_prod_unfold in_set_conv_nth length_map nth_map)"], ["proof (state)\nthis:\n  \\<forall>(uu_, s)\\<in>set ts. s < p\n\ngoal (1 subgoal):\n 1. \\<forall>j<n. snd (l' ! j) < p \\<Longrightarrow>\n    split_relation ts (abs_split ts p) n", "then"], ["proof (chain)\npicking this:\n  \\<forall>(uu_, s)\\<in>set ts. s < p", "have \"abs_split ts p = (ts, [])\""], ["proof (prove)\nusing this:\n  \\<forall>(uu_, s)\\<in>set ts. s < p\n\ngoal (1 subgoal):\n 1. abs_split ts p = (ts, [])", "using abs_split_full[of ts p]"], ["proof (prove)\nusing this:\n  \\<forall>(uu_, s)\\<in>set ts. s < p\n  \\<forall>(uu_, s)\\<in>set ts. s < p \\<Longrightarrow>\n  abs_split ts p = (ts, [])\n\ngoal (1 subgoal):\n 1. abs_split ts p = (ts, [])", "by simp"], ["proof (state)\nthis:\n  abs_split ts p = (ts, [])\n\ngoal (1 subgoal):\n 1. \\<forall>j<n. snd (l' ! j) < p \\<Longrightarrow>\n    split_relation ts (abs_split ts p) n", "then"], ["proof (chain)\npicking this:\n  abs_split ts p = (ts, [])", "show \"split_relation ts (abs_split ts p) n\""], ["proof (prove)\nusing this:\n  abs_split ts p = (ts, [])\n\ngoal (1 subgoal):\n 1. split_relation ts (abs_split ts p) n", "using split_relation_length"], ["proof (prove)\nusing this:\n  abs_split ts p = (ts, [])\n  split_relation ?xs (?ls, ?rs) (length ?xs) = (?ls = ?xs \\<and> ?rs = [])\n\ngoal (1 subgoal):\n 1. split_relation ts (abs_split ts p) n", "by (metis heap_init(2) heap_init(3) length_map length_take min.absorb2)"], ["proof (state)\nthis:\n  split_relation ts (abs_split ts p) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j<n. snd (l' ! j) < p \\<Longrightarrow>\n  split_relation ts (abs_split ts p) n\n\ngoal (2 subgoals):\n 1. \\<And>aa ba ad bd x ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        x < n; \\<forall>j<x. snd (l'a ! j) < p; p \\<le> snd (l'a ! x);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x\n 2. \\<And>aa ba ad bd ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        \\<forall>j<n. snd (l'a ! j) < p; p \\<le> snd (take n l'a ! n);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) n", "then"], ["proof (chain)\npicking this:\n  \\<forall>j<n. snd (l' ! j) < p \\<Longrightarrow>\n  split_relation ts (abs_split ts p) n", "show \"\\<forall>j<n. snd (l' ! j) < p \\<Longrightarrow>\n       p \\<le> snd (take n l' ! n) \\<Longrightarrow>\n       split_relation ts (abs_split ts p) n\""], ["proof (prove)\nusing this:\n  \\<forall>j<n. snd (l' ! j) < p \\<Longrightarrow>\n  split_relation ts (abs_split ts p) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>j<n. snd (l' ! j) < p;\n     p \\<le> snd (take n l' ! n)\\<rbrakk>\n    \\<Longrightarrow> split_relation ts (abs_split ts p) n", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>j<n. snd (l' ! j) < p;\n   p \\<le> snd (take n l' ! n)\\<rbrakk>\n  \\<Longrightarrow> split_relation ts (abs_split ts p) n\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ad bd x ac bc af bf ag bg l' l'a.\n       \\<lbrakk>sorted_less (separators (take n l'a));\n        (ad, bd) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        separators ts = separators (take n l'a); in_range (ac, bc);\n        (af, bf) \\<Turnstile>\n        list_assn A (subtrees ts) (subtrees (take n l'a));\n        x < n; \\<forall>j<x. snd (l'a ! j) < p; p \\<le> snd (l'a ! x);\n        (aa, ba) \\<Turnstile> a \\<mapsto>\\<^sub>a l';\n        (ag, bg) \\<Turnstile> a \\<mapsto>\\<^sub>a l'a; c = length l'a;\n        length l' = length l'a; tsi = take n l'a; n \\<le> length l'a;\n        take n l' = take n l'a\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "show part_thm: \"\\<And>x. x < n \\<Longrightarrow>\n       \\<forall>j<x. snd (l' ! j) < p \\<Longrightarrow>\n       p \\<le> snd (l' ! x) \\<Longrightarrow> split_relation ts (abs_split ts p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "assume x_sm_len: \"x < n\""], ["proof (state)\nthis:\n  x < n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "moreover"], ["proof (state)\nthis:\n  x < n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "assume sm_list: \"\\<forall>j<x. snd (l' ! j) < p\""], ["proof (state)\nthis:\n  \\<forall>j<x. snd (l' ! j) < p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "ultimately"], ["proof (chain)\npicking this:\n  x < n\n  \\<forall>j<x. snd (l' ! j) < p", "have \"\\<forall>j<x. ((map snd l') ! j) < p\""], ["proof (prove)\nusing this:\n  x < n\n  \\<forall>j<x. snd (l' ! j) < p\n\ngoal (1 subgoal):\n 1. \\<forall>j<x. separators l' ! j < p", "using heap_init"], ["proof (prove)\nusing this:\n  x < n\n  \\<forall>j<x. snd (l' ! j) < p\n  h \\<Turnstile> a \\<mapsto>\\<^sub>a l'\n  separators ts = separators (take n l')\n  n \\<le> length l'\n\ngoal (1 subgoal):\n 1. \\<forall>j<x. separators l' ! j < p", "by auto"], ["proof (state)\nthis:\n  \\<forall>j<x. separators l' ! j < p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "then"], ["proof (chain)\npicking this:\n  \\<forall>j<x. separators l' ! j < p", "have \"\\<forall>j<x. ((map snd ts)!j) < p\""], ["proof (prove)\nusing this:\n  \\<forall>j<x. separators l' ! j < p\n\ngoal (1 subgoal):\n 1. \\<forall>j<x. separators ts ! j < p", "using heap_init  x_sm_len"], ["proof (prove)\nusing this:\n  \\<forall>j<x. separators l' ! j < p\n  h \\<Turnstile> a \\<mapsto>\\<^sub>a l'\n  separators ts = separators (take n l')\n  n \\<le> length l'\n  x < n\n\ngoal (1 subgoal):\n 1. \\<forall>j<x. separators ts ! j < p", "by auto"], ["proof (state)\nthis:\n  \\<forall>j<x. separators ts ! j < p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "moreover"], ["proof (state)\nthis:\n  \\<forall>j<x. separators ts ! j < p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "have x_sm_len_ts: \"x < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < n", "using heap_init x_sm_len"], ["proof (prove)\nusing this:\n  h \\<Turnstile> a \\<mapsto>\\<^sub>a l'\n  separators ts = separators (take n l')\n  n \\<le> length l'\n  x < n\n\ngoal (1 subgoal):\n 1. x < n", "by auto"], ["proof (state)\nthis:\n  x < n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>j<x. separators ts ! j < p\n  x < n", "have \"\\<forall>(_,x) \\<in> set (take x ts). x < p\""], ["proof (prove)\nusing this:\n  \\<forall>j<x. separators ts ! j < p\n  x < n\n\ngoal (1 subgoal):\n 1. \\<forall>(uu_, x)\\<in>set (take x ts). x < p", "by (auto simp add: in_set_conv_nth  min.absorb2)+"], ["proof (state)\nthis:\n  \\<forall>(uu_, x)\\<in>set (take x ts). x < p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "moreover"], ["proof (state)\nthis:\n  \\<forall>(uu_, x)\\<in>set (take x ts). x < p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "assume \"p \\<le> snd (l' ! x)\""], ["proof (state)\nthis:\n  p \\<le> snd (l' ! x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "then"], ["proof (chain)\npicking this:\n  p \\<le> snd (l' ! x)", "have \"case l'!x of (_,s) \\<Rightarrow> \\<not>(s < p)\""], ["proof (prove)\nusing this:\n  p \\<le> snd (l' ! x)\n\ngoal (1 subgoal):\n 1. case l' ! x of (x, s) \\<Rightarrow> \\<not> s < p", "by (simp add: case_prod_unfold)"], ["proof (state)\nthis:\n  case l' ! x of (x, s) \\<Rightarrow> \\<not> s < p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "then"], ["proof (chain)\npicking this:\n  case l' ! x of (x, s) \\<Rightarrow> \\<not> s < p", "have \"case ts!x of (_,s) \\<Rightarrow> \\<not>(s < p)\""], ["proof (prove)\nusing this:\n  case l' ! x of (x, s) \\<Rightarrow> \\<not> s < p\n\ngoal (1 subgoal):\n 1. case ts ! x of (x, s) \\<Rightarrow> \\<not> s < p", "using heap_init x_sm_len x_sm_len_ts"], ["proof (prove)\nusing this:\n  case l' ! x of (x, s) \\<Rightarrow> \\<not> s < p\n  h \\<Turnstile> a \\<mapsto>\\<^sub>a l'\n  separators ts = separators (take n l')\n  n \\<le> length l'\n  x < n\n  x < n\n\ngoal (1 subgoal):\n 1. case ts ! x of (x, s) \\<Rightarrow> \\<not> s < p", "by (metis (mono_tags, lifting) case_prod_unfold length_map length_take min.absorb2 nth_take snd_map_help(2))"], ["proof (state)\nthis:\n  case ts ! x of (x, s) \\<Rightarrow> \\<not> s < p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>(uu_, x)\\<in>set (take x ts). x < p\n  case ts ! x of (x, s) \\<Rightarrow> \\<not> s < p", "have \"abs_split ts p = (take x ts, drop x ts)\""], ["proof (prove)\nusing this:\n  \\<forall>(uu_, x)\\<in>set (take x ts). x < p\n  case ts ! x of (x, s) \\<Rightarrow> \\<not> s < p\n\ngoal (1 subgoal):\n 1. abs_split ts p = (take x ts, drop x ts)", "using x_sm_len_ts abs_split_split[of x ts p] heap_init"], ["proof (prove)\nusing this:\n  \\<forall>(uu_, x)\\<in>set (take x ts). x < p\n  case ts ! x of (x, s) \\<Rightarrow> \\<not> s < p\n  x < n\n  \\<lbrakk>x < length ts; \\<forall>(uu_, s)\\<in>set (take x ts). s < p;\n   case ts ! x of (x, s) \\<Rightarrow> \\<not> s < p\\<rbrakk>\n  \\<Longrightarrow> abs_split ts p = (take x ts, drop x ts)\n  h \\<Turnstile> a \\<mapsto>\\<^sub>a l'\n  separators ts = separators (take n l')\n  n \\<le> length l'\n\ngoal (1 subgoal):\n 1. abs_split ts p = (take x ts, drop x ts)", "by (metis length_map length_take min.absorb2)"], ["proof (state)\nthis:\n  abs_split ts p = (take x ts, drop x ts)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<forall>j<x. snd (l' ! j) < p;\n        p \\<le> snd (l' ! x)\\<rbrakk>\n       \\<Longrightarrow> split_relation ts (abs_split ts p) x", "then"], ["proof (chain)\npicking this:\n  abs_split ts p = (take x ts, drop x ts)", "show \"split_relation ts (abs_split ts p) x\""], ["proof (prove)\nusing this:\n  abs_split ts p = (take x ts, drop x ts)\n\ngoal (1 subgoal):\n 1. split_relation ts (abs_split ts p) x", "using x_sm_len_ts"], ["proof (prove)\nusing this:\n  abs_split ts p = (take x ts, drop x ts)\n  x < n\n\ngoal (1 subgoal):\n 1. split_relation ts (abs_split ts p) x", "by (metis append_take_drop_id heap_init(2) heap_init(3) length_map length_take less_imp_le_nat min.absorb2 split_relation_alt)"], ["proof (state)\nthis:\n  split_relation ts (abs_split ts p) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x < n; \\<forall>j<?x. snd (l' ! j) < p;\n   p \\<le> snd (l' ! ?x)\\<rbrakk>\n  \\<Longrightarrow> split_relation ts (abs_split ts p) ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale imp_split abs_split split_fun"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_split abs_split split_fun", "apply(unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts c tsi a n k p.\n       sorted_less (separators ts) \\<Longrightarrow>\n       <is_pfa c tsi (a, n) *\n        blist_assn k ts\n         tsi> split_fun (a, n)\n               p <\\<lambda>r.\n                     is_pfa c tsi (a, n) * blist_assn k ts tsi *\n                     \\<up> (split_relation ts (abs_split ts p) r)>\\<^sub>t", "apply(sep_auto heap: split_rule_abs_split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \"Obtaining executable code\""], ["", "text \"In order to obtain fully defined functions,\nwe need to plug our split function implementations\ninto the locales we introduced previously.\""], ["", "interpretation btree_imp_linear_split: imp_split_smeq lin_split"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_split_smeq lin_split", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs c a n p.\n       sorted_less (separators xs) \\<Longrightarrow>\n       <is_pfa c xs\n         (a, n)> lin_split (a, n)\n                  p <\\<lambda>r.\n                        is_pfa c xs (a, n) *\n                        \\<up>\n                         (r \\<le> n \\<and>\n                          (\\<forall>j<r. snd (xs ! j) < p) \\<and>\n                          (r < n \\<longrightarrow>\n                           p \\<le> snd (xs ! r)))>\\<^sub>t", "apply(sep_auto heap: lin_split_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \"Obtaining actual code turns out to be slightly more difficult\n  due to the use of locales. However, we successfully obtain\nthe B-tree insertion and membership query with binary search splitting.\""], ["", "global_interpretation btree_imp_binary_split: imp_split_smeq bin_split\n  defines btree_isin = btree_imp_binary_split.isin\n    and btree_ins = btree_imp_binary_split.ins\n    and btree_insert = btree_imp_binary_split.insert\n    and btree_empty = btree_imp_binary_split.empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_split_smeq bin_split", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs c a n p.\n       sorted_less (separators xs) \\<Longrightarrow>\n       <is_pfa c xs\n         (a, n)> bin_split (a, n)\n                  p <\\<lambda>r.\n                        is_pfa c xs (a, n) *\n                        \\<up>\n                         (r \\<le> n \\<and>\n                          (\\<forall>j<r. snd (xs ! j) < p) \\<and>\n                          (r < n \\<longrightarrow>\n                           p \\<le> snd (xs ! r)))>\\<^sub>t", "apply(sep_auto heap: bin_split_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "thm btree_imp_binary_split.ins.simps"], ["", "declare btree_imp_binary_split.ins.simps[code] btree_imp_binary_split.isin.simps[code]"], ["", "export_code btree_empty btree_isin btree_insert checking SML Scala"], ["", "export_code btree_empty btree_isin btree_insert in SML module_name BTreeInsert"], ["", "export_code btree_empty btree_isin btree_insert in Scala module_name BTreeInsert"], ["", "end"]]}