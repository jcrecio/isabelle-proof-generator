{"file_name": "/home/qj213/afp-2021-10-22/thys/BTree/Partially_Filled_Array.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BTree", "problem_names": ["lemma is_pfa_prec[safe_constraint_rules]: \"precise (is_pfa c)\"", "lemma pfa_init_rule[sep_heap_rules]: \"n \\<le> N \\<Longrightarrow> < emp > pfa_init N x n <is_pfa N (replicate n x)>\"", "lemma pfa_empty_rule[sep_heap_rules]: \"< emp > pfa_empty N <is_pfa N []>\"", "lemma pfa_length_rule[sep_heap_rules]: \"\n  <is_pfa c l a> \n    pfa_length a\n  <\\<lambda>r. is_pfa c l a * \\<up>(r=length l)>\"", "lemma pfa_capacity_rule[sep_heap_rules]: \"\n  <is_pfa c l a> \n    pfa_capacity a\n  <\\<lambda>r. is_pfa c l a * \\<up>(c=r)>\"", "lemma pfa_is_empty_rule[sep_heap_rules]: \"\n  <is_pfa c l a> \n    pfa_is_empty a\n  <\\<lambda>r. is_pfa c l a * \\<up>(r\\<longleftrightarrow>(l=[]))>\"", "lemma pfa_append_rule[sep_heap_rules]: \"\n   n < c  \\<Longrightarrow>\n    < is_pfa c l (a,n) > \n      pfa_append (a,n) x \n    <\\<lambda>(a',n'). is_pfa c (l@[x]) (a',n') * \\<up>(a' = a \\<and> n' = n+1) >\"", "lemma pfa_last_rule[sep_heap_rules]: \"\n  l\\<noteq>[] \\<Longrightarrow>\n  <is_pfa c l a> \n    pfa_last a\n  <\\<lambda>r. is_pfa c l a * \\<up>(r=last l)>\"", "lemma pfa_butlast_rule[sep_heap_rules]: \"\n  <is_pfa c l (a,n)> \n    pfa_butlast (a,n)\n  <\\<lambda>(a',n'). is_pfa c (butlast l) (a',n') * \\<up>(a' = a)>\"", "lemma pfa_get_rule[sep_heap_rules]: \"\n  i < length l \\<Longrightarrow>\n  < is_pfa c l a> \n    pfa_get a i\n  <\\<lambda>r. is_pfa c l a * \\<up>((l!i) = r)>\"", "lemma pfa_set_rule[sep_heap_rules]: \"\n    i<length l \\<Longrightarrow>\n    <is_pfa c l a> \n      pfa_set a i x\n    <\\<lambda>a'. is_pfa c (l[i:=x]) a' * \\<up>(a' = a)>\"", "lemma pfa_shrink_rule[sep_heap_rules]: \"\n   k \\<le> length l \\<Longrightarrow>\n    < is_pfa c l (a,n) > \n      pfa_shrink k (a,n)\n    <\\<lambda>(a',n'). is_pfa c (take k l) (a',n') * \\<up>(n' = k \\<and> a'=a) >\"", "lemma pfa_shrink_cap_rule_preserve[sep_heap_rules]: \"\n   \\<lbrakk>n \\<le> k; k \\<le> c\\<rbrakk> \\<Longrightarrow>\n    < is_pfa c l (a,n) > \n      pfa_shrink_cap k (a,n)\n    <\\<lambda>a'. is_pfa k l a' >\\<^sub>t\"", "lemma pfa_shrink_cap_rule: \"\n   \\<lbrakk>k \\<le> c\\<rbrakk> \\<Longrightarrow>\n    < is_pfa c l a > \n      pfa_shrink_cap k a\n    <\\<lambda>a'. is_pfa k (take k l) a' >\\<^sub>t\"", "lemma array_ensure_rule[sep_heap_rules]:\n  shows \"\n      < a\\<mapsto>\\<^sub>ala > \n        array_ensure a s x \n      <\\<lambda>a'. a'\\<mapsto>\\<^sub>a (la @ replicate (s-length la) x)>\\<^sub>t\"", "lemma pfa_ensure_rule[sep_heap_rules]: \"\n    < is_pfa c l (a,n) > \n      pfa_ensure (a,n) k\n    <\\<lambda>(a',n'). is_pfa (max c k) l (a',n') * \\<up>(n' = n \\<and> c \\<ge> n)>\\<^sub>t\"", "lemma pfa_copy_rule[sep_heap_rules]:\n  \"< is_pfa c l a >\n   pfa_copy a\n   <\\<lambda>r. is_pfa c l a * is_pfa c l r>\\<^sub>t\"", "lemma min_nat: \"min a (a+b) = (a::nat)\"", "lemma pfa_blit_rule[sep_heap_rules]:\n  assumes LEN: \"si+len \\<le> sn\" \"di \\<le> dn\" \"di+len \\<le> dc\"\n  shows\n    \"< is_pfa sc src (srci,sn)\n      * is_pfa dc dst (dsti,dn) >\n    pfa_blit (srci,sn) si (dsti,dn) di len\n    <\\<lambda>_. is_pfa sc src (srci,sn)\n      * is_pfa dc (take di dst @ take len (drop si src) @ drop (di+len) dst) (dsti,max (di+len) dn)\n    >\"", "lemma pfa_drop_rule[sep_heap_rules]:\n  assumes LEN: \"k \\<le> sn\" \"(sn-k) \\<le> dc\"\n  shows\n    \"< is_pfa sc src (srci,sn)\n      * is_pfa dc dst (dsti,dn) >\n    pfa_drop (srci,sn) k (dsti,dn)\n    <\\<lambda>(dsti',dn'). is_pfa sc src (srci,sn)\n      * is_pfa dc (drop k src) (dsti',dn')\n      * \\<up>(dsti' = dsti)\n    >\"", "lemma pfa_append_grow_full_rule[sep_heap_rules]: \"n = c \\<Longrightarrow>\n     <is_pfa c l (a,n)>\n  array_grow a (c+1) x\n      <\\<lambda>a'. is_pfa (c+1) (l@[x]) (a',n+1)>\\<^sub>t\"", "lemma pfa_append_grow_less_rule: \"n < c \\<Longrightarrow>\n <is_pfa c l (a,n)>\n    Array.upd n x a\n<\\<lambda>a'. is_pfa c (l@[x]) (a',n+1)>\\<^sub>t\"", "lemma pfa_append_grow_rule[sep_heap_rules]: \"\n  <is_pfa c l (a,n)>\n  pfa_append_grow (a,n) x \n  <\\<lambda>(a',n'). is_pfa (if c = n then c+1 else c) (l@[x]) (a',n') * \\<up>(n'=n+1 \\<and> c \\<ge> n)>\\<^sub>t\"", "lemma pfa_append_grow'_rule[sep_heap_rules]: \"\n  <is_pfa c l (a,n)>\n  pfa_append_grow' (a,n) x \n  <\\<lambda>(a',n'). is_pfa (max (n+1) c) (l@[x]) (a',n') * \\<up>(n'=n+1 \\<and> c \\<ge> n)>\\<^sub>t\"", "lemma list_update_last: \"length ls = Suc i \\<Longrightarrow> ls[i:=x] = (take i ls)@[x]\"", "lemma pfa_insert_rule[sep_heap_rules]:\n  \"\\<lbrakk>i \\<le> n; n < c\\<rbrakk> \\<Longrightarrow>\n  <is_pfa c l (a,n)>\n  pfa_insert (a,n) i x \n  <\\<lambda>(a',n'). is_pfa c (take i l@x#drop i l) (a',n') * \\<up>(n' = n+1 \\<and> a=a')>\"", "lemma pfa_insert_grow_rule: \n  \"i \\<le> n \\<Longrightarrow>\n  <is_pfa c l (a,n)>\n  pfa_insert_grow (a,n) i x \n  <\\<lambda>(a',n'). is_pfa (max c (n+1)) (take i l@x#drop i l) (a',n') * \\<up>(n'=n+1 \\<and> c \\<ge> n)>\\<^sub>t\"", "lemma pfa_extend_rule: \n  \"n+m \\<le> c \\<Longrightarrow>\n  <is_pfa c l1 (a,n) * is_pfa d l2 (b,m)>\n  pfa_extend (a,n) (b,m) \n  <\\<lambda>(a',n'). is_pfa c (l1@l2) (a',n') * \\<up>(a' = a \\<and> n'=n+m) * is_pfa d l2 (b,m)>\\<^sub>t\"", "lemma pfa_extend_grow_rule: \n  \"<is_pfa c l1 (a,n) * is_pfa d l2 (b,m)>\n  pfa_extend_grow (a,n) (b,m) \n  <\\<lambda>(a',n'). is_pfa (max c (n+m)) (l1@l2) (a',n') * \\<up>(n'=n+m \\<and> c \\<ge> n) * is_pfa d l2 (b,m)>\\<^sub>t\"", "lemma pfa_append_extend_grow_rule: \n  \"<is_pfa c l1 (a,n) * is_pfa d l2 (b,m)>\n  pfa_append_extend_grow (a,n) x (b,m) \n  <\\<lambda>(a',n'). is_pfa (max c (n+m+1)) (l1@x#l2) (a',n') * \\<up>(n'=n+m+1 \\<and> c \\<ge> n) * is_pfa d l2 (b,m)>\\<^sub>t\"", "lemma pfa_delete_rule[sep_heap_rules]:\n  \"i < n \\<Longrightarrow>\n  <is_pfa c l (a,n)>\n  pfa_delete (a,n) i\n  <\\<lambda>(a',n'). is_pfa c (take i l@drop (i+1) l) (a',n') * \\<up>(n' = n-1 \\<and> a=a')>\""], "translations": [["", "lemma is_pfa_prec[safe_constraint_rules]: \"precise (is_pfa c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise (is_pfa c)", "unfolding is_pfa_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. precise\n     (\\<lambda>l (a, n).\n         \\<exists>\\<^sub>Al'.\n            a \\<mapsto>\\<^sub>a l' *\n            \\<up> (c = length l' \\<and> n \\<le> c \\<and> l = take n l'))", "apply(rule preciseI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       (case p of\n        (aa, n) \\<Rightarrow>\n          \\<exists>\\<^sub>Al'.\n             aa \\<mapsto>\\<^sub>a l' *\n             \\<up> (c = length l' \\<and> n \\<le> c \\<and> a = take n l')) *\n       F \\<and>\\<^sub>A\n       (case p of\n        (a, n) \\<Rightarrow>\n          \\<exists>\\<^sub>Al'.\n             a \\<mapsto>\\<^sub>a l' *\n             \\<up> (c = length l' \\<and> n \\<le> c \\<and> a' = take n l')) *\n       F' \\<Longrightarrow>\n       a = a'", "apply(simp split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F' x1 x2.\n       \\<lbrakk>p = (x1, x2);\n        \\<exists>l' l'a.\n           h \\<Turnstile>\n           x1 \\<mapsto>\\<^sub>a l'a * F \\<and>\\<^sub>A\n           x1 \\<mapsto>\\<^sub>a l' * F' \\<and>\n           c = length l'a \\<and>\n           x2 \\<le> c \\<and>\n           a = take x2 l'a \\<and>\n           c = length l' \\<and> x2 \\<le> c \\<and> a' = take x2 l'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "using preciseD snga_prec"], ["proof (prove)\nusing this:\n  \\<lbrakk>precise ?R;\n   ?h \\<Turnstile> ?R ?a ?p * ?F \\<and>\\<^sub>A ?R ?a' ?p * ?F'\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n  precise (\\<lambda>x p. p \\<mapsto>\\<^sub>a x)\n\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F' x1 x2.\n       \\<lbrakk>p = (x1, x2);\n        \\<exists>l' l'a.\n           h \\<Turnstile>\n           x1 \\<mapsto>\\<^sub>a l'a * F \\<and>\\<^sub>A\n           x1 \\<mapsto>\\<^sub>a l' * F' \\<and>\n           c = length l'a \\<and>\n           x2 \\<le> c \\<and>\n           a = take x2 l'a \\<and>\n           c = length l' \\<and> x2 \\<le> c \\<and> a' = take x2 l'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "by fastforce"], ["", "definition pfa_init where\n  \"pfa_init cap v n \\<equiv> do {\n  a \\<leftarrow> Array.new cap v;\n  return (a,n)\n}\""], ["", "lemma pfa_init_rule[sep_heap_rules]: \"n \\<le> N \\<Longrightarrow> < emp > pfa_init N x n <is_pfa N (replicate n x)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> N \\<Longrightarrow>\n    <emp> pfa_init N x n <is_pfa N (replicate n x)>", "by (sep_auto simp: pfa_init_def is_pfa_def)"], ["", "definition pfa_empty where\n  \"pfa_empty cap \\<equiv> pfa_init cap default 0\""], ["", "lemma pfa_empty_rule[sep_heap_rules]: \"< emp > pfa_empty N <is_pfa N []>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> pfa_empty N <is_pfa N []>", "by (sep_auto simp: pfa_empty_def is_pfa_def)"], ["", "definition \"pfa_length \\<equiv> arl_length\""], ["", "lemma pfa_length_rule[sep_heap_rules]: \"\n  <is_pfa c l a> \n    pfa_length a\n  <\\<lambda>r. is_pfa c l a * \\<up>(r=length l)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l a> pfa_length a\n    <\\<lambda>r. is_pfa c l a * \\<up> (r = length l)>", "by (sep_auto simp: pfa_length_def arl_length_def is_pfa_def)"], ["", "definition \"pfa_capacity \\<equiv> \\<lambda>(a,n). Array.len a\n\""], ["", "lemma pfa_capacity_rule[sep_heap_rules]: \"\n  <is_pfa c l a> \n    pfa_capacity a\n  <\\<lambda>r. is_pfa c l a * \\<up>(c=r)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l a> pfa_capacity a <\\<lambda>r. is_pfa c l a * \\<up> (c = r)>", "by (sep_auto simp: pfa_capacity_def arl_length_def is_pfa_def)"], ["", "definition \"pfa_is_empty \\<equiv> arl_is_empty\""], ["", "lemma pfa_is_empty_rule[sep_heap_rules]: \"\n  <is_pfa c l a> \n    pfa_is_empty a\n  <\\<lambda>r. is_pfa c l a * \\<up>(r\\<longleftrightarrow>(l=[]))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l a> pfa_is_empty a\n    <\\<lambda>r. is_pfa c l a * \\<up> (r = (l = []))>", "by (sep_auto simp: pfa_is_empty_def arl_is_empty_def is_pfa_def)"], ["", "definition \"pfa_append \\<equiv> \\<lambda>(a,n) x. do {\n  Array.upd n x a;\n  return (a,n+1)\n}\""], ["", "lemma pfa_append_rule[sep_heap_rules]: \"\n   n < c  \\<Longrightarrow>\n    < is_pfa c l (a,n) > \n      pfa_append (a,n) x \n    <\\<lambda>(a',n'). is_pfa c (l@[x]) (a',n') * \\<up>(a' = a \\<and> n' = n+1) >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < c \\<Longrightarrow>\n    <is_pfa c l (a, n)> pfa_append (a, n) x\n    <\\<lambda>(a', n').\n        is_pfa c (l @ [x]) (a', n') * \\<up> (a' = a \\<and> n' = n + 1)>", "by (sep_auto \n      simp: pfa_append_def arl_append_def is_pfa_def take_update_last neq_Nil_conv\n      split: prod.splits nat.split)"], ["", "definition \"pfa_last \\<equiv> arl_last\""], ["", "lemma pfa_last_rule[sep_heap_rules]: \"\n  l\\<noteq>[] \\<Longrightarrow>\n  <is_pfa c l a> \n    pfa_last a\n  <\\<lambda>r. is_pfa c l a * \\<up>(r=last l)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <is_pfa c l a> pfa_last a\n    <\\<lambda>r. is_pfa c l a * \\<up> (r = last l)>", "by (sep_auto simp: pfa_last_def arl_last_def is_pfa_def last_take_nth_conv)"], ["", "definition pfa_butlast :: \"'a::heap pfarray \\<Rightarrow> 'a pfarray Heap\" where\n  \"pfa_butlast \\<equiv> \\<lambda>(a,n).\n    return (a,n-1)\n  \""], ["", "lemma pfa_butlast_rule[sep_heap_rules]: \"\n  <is_pfa c l (a,n)> \n    pfa_butlast (a,n)\n  <\\<lambda>(a',n'). is_pfa c (butlast l) (a',n') * \\<up>(a' = a)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l (a, n)> pfa_butlast (a, n)\n    <\\<lambda>(a', n'). is_pfa c (butlast l) (a', n') * \\<up> (a' = a)>", "by (sep_auto \n      split: prod.splits\n      simp: pfa_butlast_def is_pfa_def butlast_take)"], ["", "definition \"pfa_get \\<equiv> arl_get\""], ["", "lemma pfa_get_rule[sep_heap_rules]: \"\n  i < length l \\<Longrightarrow>\n  < is_pfa c l a> \n    pfa_get a i\n  <\\<lambda>r. is_pfa c l a * \\<up>((l!i) = r)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow>\n    <is_pfa c l a> pfa_get a i\n    <\\<lambda>r. is_pfa c l a * \\<up> (l ! i = r)>", "by (sep_auto simp: is_pfa_def pfa_get_def arl_get_def  split: prod.split)"], ["", "definition \"pfa_set \\<equiv> arl_set\""], ["", "lemma pfa_set_rule[sep_heap_rules]: \"\n    i<length l \\<Longrightarrow>\n    <is_pfa c l a> \n      pfa_set a i x\n    <\\<lambda>a'. is_pfa c (l[i:=x]) a' * \\<up>(a' = a)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow>\n    <is_pfa c l a> pfa_set a i x\n    <\\<lambda>a'. is_pfa c (l[i := x]) a' * \\<up> (a' = a)>", "by (sep_auto simp: pfa_set_def arl_set_def is_pfa_def split: prod.split)"], ["", "definition pfa_shrink :: \"nat \\<Rightarrow> 'a::heap pfarray \\<Rightarrow> 'a pfarray Heap\" where\n  \"pfa_shrink k \\<equiv> \\<lambda>(a,n).\n  return (a,k)\n\""], ["", "lemma pfa_shrink_rule[sep_heap_rules]: \"\n   k \\<le> length l \\<Longrightarrow>\n    < is_pfa c l (a,n) > \n      pfa_shrink k (a,n)\n    <\\<lambda>(a',n'). is_pfa c (take k l) (a',n') * \\<up>(n' = k \\<and> a'=a) >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> length l \\<Longrightarrow>\n    <is_pfa c l (a, n)> pfa_shrink k (a, n)\n    <\\<lambda>(a', n').\n        is_pfa c (take k l) (a', n') * \\<up> (n' = k \\<and> a' = a)>", "by (sep_auto \n      simp: pfa_shrink_def is_pfa_def min.absorb1\n      split: prod.splits nat.split)"], ["", "definition pfa_shrink_cap :: \"nat \\<Rightarrow> 'a::heap pfarray \\<Rightarrow> 'a pfarray Heap\" where\n  \"pfa_shrink_cap k \\<equiv> \\<lambda>(a,n). do {\n  a' \\<leftarrow> array_shrink a k;\n  return (a',min k n)\n}\n\""], ["", "lemma pfa_shrink_cap_rule_preserve[sep_heap_rules]: \"\n   \\<lbrakk>n \\<le> k; k \\<le> c\\<rbrakk> \\<Longrightarrow>\n    < is_pfa c l (a,n) > \n      pfa_shrink_cap k (a,n)\n    <\\<lambda>a'. is_pfa k l a' >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> k; k \\<le> c\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c l\n                        (a, n)> pfa_shrink_cap k (a, n) <is_pfa k l>\\<^sub>t", "by (sep_auto \n      simp: pfa_shrink_cap_def is_pfa_def min.absorb1 min.absorb2\n      split: prod.splits nat.split)"], ["", "lemma pfa_shrink_cap_rule: \"\n   \\<lbrakk>k \\<le> c\\<rbrakk> \\<Longrightarrow>\n    < is_pfa c l a > \n      pfa_shrink_cap k a\n    <\\<lambda>a'. is_pfa k (take k l) a' >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> c \\<Longrightarrow>\n    <is_pfa c l a> pfa_shrink_cap k a <is_pfa k (take k l)>\\<^sub>t", "by (sep_auto \n      simp: pfa_shrink_cap_def is_pfa_def min.absorb1 min.absorb2\n      split: prod.splits nat.split dest: mod_starD)"], ["", "definition \"array_ensure a s x \\<equiv> do {\n    l\\<leftarrow>Array.len a;\n    if l\\<ge>s then \n      return a\n    else do {\n      a'\\<leftarrow>Array.new s x;\n      blit a 0 a' 0 l;\n      return a'\n    }\n  }\""], ["", "lemma array_ensure_rule[sep_heap_rules]:\n  shows \"\n      < a\\<mapsto>\\<^sub>ala > \n        array_ensure a s x \n      <\\<lambda>a'. a'\\<mapsto>\\<^sub>a (la @ replicate (s-length la) x)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a\n     la> array_ensure a s\n          x <\\<lambda>r.\n                r \\<mapsto>\\<^sub>a\n                (la @ replicate (s - length la) x)>\\<^sub>t", "unfolding array_ensure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a\n     la> Array.len a \\<bind>\n         (\\<lambda>l.\n             if s \\<le> l then return a\n             else Array.new s x \\<bind>\n                  (\\<lambda>a'.\n                      blit a 0 a' 0 l \\<bind>\n                      (\\<lambda>_.\n                          return\n                           a'))) <\\<lambda>r.\n                                     r \\<mapsto>\\<^sub>a\n                                     (la @\nreplicate (s - length la) x)>\\<^sub>t", "by sep_auto"], ["", "(* Ensure a certain capacity *)"], ["", "definition pfa_ensure :: \"'a::{heap,default} pfarray \\<Rightarrow> nat \\<Rightarrow> 'a pfarray Heap\" where\n  \"pfa_ensure \\<equiv> \\<lambda>(a,n) k. do {\n  a' \\<leftarrow> array_ensure a k default;\n  return (a',n)\n}\n\""], ["", "lemma pfa_ensure_rule[sep_heap_rules]: \"\n    < is_pfa c l (a,n) > \n      pfa_ensure (a,n) k\n    <\\<lambda>(a',n'). is_pfa (max c k) l (a',n') * \\<up>(n' = n \\<and> c \\<ge> n)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l\n      (a, n)> pfa_ensure (a, n)\n               k <\\<lambda>r.\n                     case r of\n                     (a', n') \\<Rightarrow>\n                       is_pfa (max c k) l (a', n') *\n                       \\<up> (n' = n \\<and> n \\<le> c)>\\<^sub>t", "by (sep_auto \n      simp: pfa_ensure_def is_pfa_def)"], ["", "definition \"pfa_copy \\<equiv> arl_copy\""], ["", "lemma pfa_copy_rule[sep_heap_rules]:\n  \"< is_pfa c l a >\n   pfa_copy a\n   <\\<lambda>r. is_pfa c l a * is_pfa c l r>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l\n      a> pfa_copy a <\\<lambda>r. is_pfa c l a * is_pfa c l r>\\<^sub>t", "by (sep_auto simp: pfa_copy_def arl_copy_def is_pfa_def)"], ["", "definition pfa_blit :: \"'a::heap pfarray \\<Rightarrow> nat \\<Rightarrow> 'a::heap pfarray \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> unit Heap\" where\n  \"pfa_blit \\<equiv> \\<lambda>(src,sn) si (dst,dn) di l. blit src si dst di l\""], ["", "lemma min_nat: \"min a (a+b) = (a::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min a (a + b) = a", "by auto"], ["", "lemma pfa_blit_rule[sep_heap_rules]:\n  assumes LEN: \"si+len \\<le> sn\" \"di \\<le> dn\" \"di+len \\<le> dc\"\n  shows\n    \"< is_pfa sc src (srci,sn)\n      * is_pfa dc dst (dsti,dn) >\n    pfa_blit (srci,sn) si (dsti,dn) di len\n    <\\<lambda>_. is_pfa sc src (srci,sn)\n      * is_pfa dc (take di dst @ take len (drop si src) @ drop (di+len) dst) (dsti,max (di+len) dn)\n    >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa sc src (srci, sn) * is_pfa dc dst (dsti, dn)>\n    pfa_blit (srci, sn) si (dsti, dn) di len\n    <\\<lambda>_.\n        is_pfa sc src (srci, sn) *\n        is_pfa dc\n         (take di dst @ take len (drop si src) @ drop (di + len) dst)\n         (dsti, max (di + len) dn)>", "using LEN"], ["proof (prove)\nusing this:\n  si + len \\<le> sn\n  di \\<le> dn\n  di + len \\<le> dc\n\ngoal (1 subgoal):\n 1. <is_pfa sc src (srci, sn) * is_pfa dc dst (dsti, dn)>\n    pfa_blit (srci, sn) si (dsti, dn) di len\n    <\\<lambda>_.\n        is_pfa sc src (srci, sn) *\n        is_pfa dc\n         (take di dst @ take len (drop si src) @ drop (di + len) dst)\n         (dsti, max (di + len) dn)>", "apply(sep_auto simp add: min_nat is_pfa_def pfa_blit_def min.commute min.absorb1 heap: blit_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l' l'a a b.\n       \\<lbrakk>si + len \\<le> sn; di \\<le> dn; di + len \\<le> length l';\n        sc = length l'a; sn \\<le> length l'a; src = take sn l'a;\n        dc = length l'; dn \\<le> length l'; dst = take dn l';\n        (a, b) \\<Turnstile>\n        srci \\<mapsto>\\<^sub>a l'a *\n        dsti \\<mapsto>\\<^sub>a\n        (take di l' @ take len (drop si l'a) @ drop (di + len) l')\\<rbrakk>\n       \\<Longrightarrow> take len (drop si (take sn l'a)) =\n                         take len (drop si l'a)\n 2. \\<And>l' l'a a b.\n       \\<lbrakk>si + len \\<le> sn; di \\<le> dn; di + len \\<le> length l';\n        sc = length l'a; sn \\<le> length l'a; src = take sn l'a;\n        dc = length l'; dn \\<le> length l'; dst = take dn l';\n        (a, b) \\<Turnstile>\n        srci \\<mapsto>\\<^sub>a l'a *\n        dsti \\<mapsto>\\<^sub>a\n        (take di l' @ take len (drop si l'a) @ drop (di + len) l')\\<rbrakk>\n       \\<Longrightarrow> drop (di + len) (take dn l') =\n                         take (max (di + len) dn - (di + len))\n                          (drop (di + len) l')", "apply (simp add: min.absorb1 take_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l' l'a a b.\n       \\<lbrakk>si + len \\<le> sn; di \\<le> dn; di + len \\<le> length l';\n        sc = length l'a; sn \\<le> length l'a; src = take sn l'a;\n        dc = length l'; dn \\<le> length l'; dst = take dn l';\n        (a, b) \\<Turnstile>\n        srci \\<mapsto>\\<^sub>a l'a *\n        dsti \\<mapsto>\\<^sub>a\n        (take di l' @ take len (drop si l'a) @ drop (di + len) l')\\<rbrakk>\n       \\<Longrightarrow> drop (di + len) (take dn l') =\n                         take (max (di + len) dn - (di + len))\n                          (drop (di + len) l')", "apply (simp add: drop_take max_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition pfa_drop :: \"('a::heap) pfarray \\<Rightarrow> nat \\<Rightarrow> 'a pfarray \\<Rightarrow> 'a pfarray Heap\" where\n  \"pfa_drop \\<equiv> \\<lambda>(src,sn) si (dst,dn). do {\n   blit src si dst 0 (sn-si);\n   return (dst,(sn-si))\n}\n\""], ["", "lemma pfa_drop_rule[sep_heap_rules]:\n  assumes LEN: \"k \\<le> sn\" \"(sn-k) \\<le> dc\"\n  shows\n    \"< is_pfa sc src (srci,sn)\n      * is_pfa dc dst (dsti,dn) >\n    pfa_drop (srci,sn) k (dsti,dn)\n    <\\<lambda>(dsti',dn'). is_pfa sc src (srci,sn)\n      * is_pfa dc (drop k src) (dsti',dn')\n      * \\<up>(dsti' = dsti)\n    >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa sc src (srci, sn) * is_pfa dc dst (dsti, dn)>\n    pfa_drop (srci, sn) k (dsti, dn)\n    <\\<lambda>(dsti', dn').\n        is_pfa sc src (srci, sn) * is_pfa dc (drop k src) (dsti', dn') *\n        \\<up> (dsti' = dsti)>", "using LEN"], ["proof (prove)\nusing this:\n  k \\<le> sn\n  sn - k \\<le> dc\n\ngoal (1 subgoal):\n 1. <is_pfa sc src (srci, sn) * is_pfa dc dst (dsti, dn)>\n    pfa_drop (srci, sn) k (dsti, dn)\n    <\\<lambda>(dsti', dn').\n        is_pfa sc src (srci, sn) * is_pfa dc (drop k src) (dsti', dn') *\n        \\<up> (dsti' = dsti)>", "apply (sep_auto simp add: drop_take is_pfa_def pfa_drop_def dest!: mod_starD heap: pfa_blit_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"pfa_append_grow \\<equiv> \\<lambda>(a,n) x. do {\n  l \\<leftarrow> pfa_capacity (a,n);\n  a' \\<leftarrow> if l = n \n  then array_grow a (l+1) x\n  else Array.upd n x a;\n  return (a',n+1)\n}\""], ["", "lemma pfa_append_grow_full_rule[sep_heap_rules]: \"n = c \\<Longrightarrow>\n     <is_pfa c l (a,n)>\n  array_grow a (c+1) x\n      <\\<lambda>a'. is_pfa (c+1) (l@[x]) (a',n+1)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = c \\<Longrightarrow>\n    <is_pfa c l\n      (a, n)> array_grow a (c + 1)\n               x <\\<lambda>r. is_pfa (c + 1) (l @ [x]) (r, n + 1)>\\<^sub>t", "apply(sep_auto simp add: is_pfa_def \n      heap del: array_grow_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = length l; c = length l\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l>\n                      array_grow a (Suc (length l)) x\n                      <\\<lambda>r.\n                          \\<exists>\\<^sub>Al'.\n                             r \\<mapsto>\\<^sub>a l' * true *\n                             \\<up>\n                              (Suc (length l) = length l' \\<and>\n                               l @ [x] = take (Suc (length l)) l')>", "apply(vcg heap del: array_grow_rule heap add: array_grow_rule[of l \"(Suc (length l))\" a x])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = length l; c = length l\\<rbrakk>\n    \\<Longrightarrow> length l \\<le> Suc (length l)\n 2. \\<And>xa.\n       \\<lbrakk>n = length l; c = length l\\<rbrakk>\n       \\<Longrightarrow> xa \\<mapsto>\\<^sub>a\n                         (l @ replicate (Suc (length l) - length l) x) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Al'.\n                            xa \\<mapsto>\\<^sub>a l' * true *\n                            \\<up>\n                             (Suc (length l) = length l' \\<and>\n                              l @ [x] = take (Suc (length l)) l')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>n = length l; c = length l\\<rbrakk>\n       \\<Longrightarrow> xa \\<mapsto>\\<^sub>a\n                         (l @ replicate (Suc (length l) - length l) x) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Al'.\n                            xa \\<mapsto>\\<^sub>a l' * true *\n                            \\<up>\n                             (Suc (length l) = length l' \\<and>\n                              l @ [x] = take (Suc (length l)) l')", "apply(rule ent_ex_postI[where ?x=\"l@[x]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>n = length l; c = length l\\<rbrakk>\n       \\<Longrightarrow> xa \\<mapsto>\\<^sub>a\n                         (l @ replicate (Suc (length l) - length l) x) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         xa \\<mapsto>\\<^sub>a (l @ [x]) * true *\n                         \\<up>\n                          (Suc (length l) = length (l @ [x]) \\<and>\n                           l @ [x] = take (Suc (length l)) (l @ [x]))", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pfa_append_grow_less_rule: \"n < c \\<Longrightarrow>\n <is_pfa c l (a,n)>\n    Array.upd n x a\n<\\<lambda>a'. is_pfa c (l@[x]) (a',n+1)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < c \\<Longrightarrow>\n    <is_pfa c l\n      (a, n)> Array.upd n x\n               a <\\<lambda>r. is_pfa c (l @ [x]) (r, n + 1)>\\<^sub>t", "apply(sep_auto simp add: is_pfa_def take_update_last)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pfa_append_grow_rule[sep_heap_rules]: \"\n  <is_pfa c l (a,n)>\n  pfa_append_grow (a,n) x \n  <\\<lambda>(a',n'). is_pfa (if c = n then c+1 else c) (l@[x]) (a',n') * \\<up>(n'=n+1 \\<and> c \\<ge> n)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l\n      (a, n)> pfa_append_grow (a, n)\n               x <\\<lambda>r.\n                     case r of\n                     (a', n') \\<Rightarrow>\n                       is_pfa (if c = n then c + 1 else c) (l @ [x])\n                        (a', n') *\n                       \\<up> (n' = n + 1 \\<and> n \\<le> c)>\\<^sub>t", "apply(subst pfa_append_grow_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l\n      (a, n)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>x.\n                    pfa_capacity (a, n) \\<bind>\n                    (\\<lambda>l.\n                        (if l = n then array_grow a (l + 1) x\n                         else Array.upd n x a) \\<bind>\n                        (\\<lambda>a'. return (a', n + 1))))\n               x <\\<lambda>r.\n                     case r of\n                     (a', n') \\<Rightarrow>\n                       is_pfa (if c = n then c + 1 else c) (l @ [x])\n                        (a', n') *\n                       \\<up> (n' = n + 1 \\<and> n \\<le> c)>\\<^sub>t", "apply(rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> is_pfa c l (a, n) \\<Longrightarrow>\n       <is_pfa c l\n         (a, n)> (case (a, n) of\n                  (a, n) \\<Rightarrow>\n                    \\<lambda>x.\n                       pfa_capacity (a, n) \\<bind>\n                       (\\<lambda>l.\n                           (if l = n then array_grow a (l + 1) x\n                            else Array.upd n x a) \\<bind>\n                           (\\<lambda>a'. return (a', n + 1))))\n                  x <\\<lambda>r.\n                        case r of\n                        (a', n') \\<Rightarrow>\n                          is_pfa (if c = n then c + 1 else c) (l @ [x])\n                           (a', n') *\n                          \\<up> (n' = n + 1 \\<and> n \\<le> c)>\\<^sub>t", "apply (sep_auto\n      heap add: pfa_append_grow_full_rule pfa_append_grow_less_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b) \\<Turnstile> is_pfa c l (a, n);\n        c \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> n < c\n 2. \\<And>aa b xa xaa.\n       \\<lbrakk>(aa, b) \\<Turnstile> is_pfa xa l (a, n); xa \\<noteq> n;\n        c = xa\\<rbrakk>\n       \\<Longrightarrow> <is_pfa xa (l @ [x]) (xaa, n + 1) *\n                          true> return\n                                 (xaa,\n                                  Suc n) <\\<lambda>r.\n       case r of\n       (a', n') \\<Rightarrow>\n         is_pfa xa (l @ [x]) (a', n') *\n         \\<up> (n' = Suc n \\<and> n \\<le> xa)>\\<^sub>t", "apply(sep_auto simp add: is_pfa_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b xa xaa.\n       \\<lbrakk>(aa, b) \\<Turnstile> is_pfa xa l (a, n); xa \\<noteq> n;\n        c = xa\\<rbrakk>\n       \\<Longrightarrow> <is_pfa xa (l @ [x]) (xaa, n + 1) *\n                          true> return\n                                 (xaa,\n                                  Suc n) <\\<lambda>r.\n       case r of\n       (a', n') \\<Rightarrow>\n         is_pfa xa (l @ [x]) (a', n') *\n         \\<up> (n' = Suc n \\<and> n \\<le> xa)>\\<^sub>t", "apply(sep_auto simp add: is_pfa_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* This definition has only one access to the array length *)"], ["", "definition \"pfa_append_grow' \\<equiv> \\<lambda>(a,n) x. do {\n  a' \\<leftarrow> pfa_ensure (a,n) (n+1);\n  a'' \\<leftarrow> pfa_append a' x;\n  return a''\n}\""], ["", "lemma pfa_append_grow'_rule[sep_heap_rules]: \"\n  <is_pfa c l (a,n)>\n  pfa_append_grow' (a,n) x \n  <\\<lambda>(a',n'). is_pfa (max (n+1) c) (l@[x]) (a',n') * \\<up>(n'=n+1 \\<and> c \\<ge> n)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l\n      (a, n)> pfa_append_grow' (a, n)\n               x <\\<lambda>r.\n                     case r of\n                     (a', n') \\<Rightarrow>\n                       is_pfa (max (n + 1) c) (l @ [x]) (a', n') *\n                       \\<up> (n' = n + 1 \\<and> n \\<le> c)>\\<^sub>t", "unfolding pfa_append_grow'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l\n      (a, n)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>x.\n                    pfa_ensure (a, n) (n + 1) \\<bind>\n                    (\\<lambda>a'. pfa_append a' x \\<bind> return))\n               x <\\<lambda>r.\n                     case r of\n                     (a', n') \\<Rightarrow>\n                       is_pfa (max (n + 1) c) (l @ [x]) (a', n') *\n                       \\<up> (n' = n + 1 \\<and> n \\<le> c)>\\<^sub>t", "by (sep_auto simp add: max_def)"], ["", "definition \"pfa_insert \\<equiv> \\<lambda>(a,n) i x. do {\n  a' \\<leftarrow> array_shr a i 1;\n  a'' \\<leftarrow> Array.upd i x a;\n  return (a'',n+1)\n}\""], ["", "lemma list_update_last: \"length ls = Suc i \\<Longrightarrow> ls[i:=x] = (take i ls)@[x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ls = Suc i \\<Longrightarrow> ls[i := x] = take i ls @ [x]", "by (metis append_eq_conv_conj length_Suc_rev_conv list_update_length)"], ["", "lemma pfa_insert_rule[sep_heap_rules]:\n  \"\\<lbrakk>i \\<le> n; n < c\\<rbrakk> \\<Longrightarrow>\n  <is_pfa c l (a,n)>\n  pfa_insert (a,n) i x \n  <\\<lambda>(a',n'). is_pfa c (take i l@x#drop i l) (a',n') * \\<up>(n' = n+1 \\<and> a=a')>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> n; n < c\\<rbrakk>\n    \\<Longrightarrow> <is_pfa c l (a, n)> pfa_insert (a, n) i x\n                      <\\<lambda>(a', n').\n                          is_pfa c (take i l @ x # drop i l) (a', n') *\n                          \\<up> (n' = n + 1 \\<and> a = a')>", "unfolding pfa_insert_def is_pfa_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> n; n < c\\<rbrakk>\n    \\<Longrightarrow> <case (a, n) of\n                       (a, n) \\<Rightarrow>\n                         \\<exists>\\<^sub>Al'.\n                            a \\<mapsto>\\<^sub>a l' *\n                            \\<up>\n                             (c = length l' \\<and>\n                              n \\<le> c \\<and> l = take n l')>\n                      (case (a, n) of\n                       (a, n) \\<Rightarrow>\n                         \\<lambda>i x.\n                            array_shr a i 1 \\<bind>\n                            (\\<lambda>a'.\n                                Array.upd i x a \\<bind>\n                                (\\<lambda>a''. return (a'', n + 1))))\n                       i x\n                      <\\<lambda>(a', n').\n                          (case (a', n') of\n                           (a, n) \\<Rightarrow>\n                             \\<exists>\\<^sub>Al'.\n                                a \\<mapsto>\\<^sub>a l' *\n                                \\<up>\n                                 (c = length l' \\<and>\n                                  n \\<le> c \\<and>\n                                  take i l @ x # drop i l = take n l')) *\n                          \\<up> (n' = n + 1 \\<and> a = a')>", "by (sep_auto simp add: list_update_append1 list_update_last\n      Suc_diff_le drop_take min_def)"], ["", "definition pfa_insert_grow ::  \"'a::{heap,default} pfarray \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a pfarray Heap\" \n  where \"pfa_insert_grow \\<equiv> \\<lambda>(a,n) i x. do {\n  a' \\<leftarrow> pfa_ensure (a,n) (n+1);\n  a'' \\<leftarrow> pfa_insert a' i x;\n  return a''\n}\""], ["", "lemma pfa_insert_grow_rule: \n  \"i \\<le> n \\<Longrightarrow>\n  <is_pfa c l (a,n)>\n  pfa_insert_grow (a,n) i x \n  <\\<lambda>(a',n'). is_pfa (max c (n+1)) (take i l@x#drop i l) (a',n') * \\<up>(n'=n+1 \\<and> c \\<ge> n)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> n \\<Longrightarrow>\n    <is_pfa c l\n      (a, n)> pfa_insert_grow (a, n) i\n               x <\\<lambda>r.\n                     case r of\n                     (a', n') \\<Rightarrow>\n                       is_pfa (max c (n + 1)) (take i l @ x # drop i l)\n                        (a', n') *\n                       \\<up> (n' = n + 1 \\<and> n \\<le> c)>\\<^sub>t", "unfolding pfa_insert_grow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> n \\<Longrightarrow>\n    <is_pfa c l\n      (a, n)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>i x.\n                    pfa_ensure (a, n) (n + 1) \\<bind>\n                    (\\<lambda>a'. pfa_insert a' i x \\<bind> return))\n               i x <\\<lambda>r.\n                       case r of\n                       (a', n') \\<Rightarrow>\n                         is_pfa (max c (n + 1)) (take i l @ x # drop i l)\n                          (a', n') *\n                         \\<up> (n' = n + 1 \\<and> n \\<le> c)>\\<^sub>t", "by (sep_auto heap add: pfa_insert_rule[of i n \"max c (Suc n)\"])"], ["", "definition pfa_extend where\n  \"pfa_extend \\<equiv> \\<lambda> (a,n) (b,m). do{\n  blit b 0 a n m;\n  return (a,n+m)\n}\""], ["", "lemma pfa_extend_rule: \n  \"n+m \\<le> c \\<Longrightarrow>\n  <is_pfa c l1 (a,n) * is_pfa d l2 (b,m)>\n  pfa_extend (a,n) (b,m) \n  <\\<lambda>(a',n'). is_pfa c (l1@l2) (a',n') * \\<up>(a' = a \\<and> n'=n+m) * is_pfa d l2 (b,m)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + m \\<le> c \\<Longrightarrow>\n    <is_pfa c l1 (a, n) *\n     is_pfa d l2\n      (b, m)> pfa_extend (a, n)\n               (b, m) <\\<lambda>r.\n                          case r of\n                          (a', n') \\<Rightarrow>\n                            is_pfa c (l1 @ l2) (a', n') *\n                            \\<up> (a' = a \\<and> n' = n + m) *\n                            is_pfa d l2 (b, m)>\\<^sub>t", "unfolding pfa_extend_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n + m \\<le> c \\<Longrightarrow>\n    <is_pfa c l1 (a, n) *\n     is_pfa d l2\n      (b, m)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>(b, m).\n                    blit b 0 a n m \\<bind> (\\<lambda>_. return (a, n + m)))\n               (b, m) <\\<lambda>r.\n                          case r of\n                          (a', n') \\<Rightarrow>\n                            is_pfa c (l1 @ l2) (a', n') *\n                            \\<up> (a' = a \\<and> n' = n + m) *\n                            is_pfa d l2 (b, m)>\\<^sub>t", "by (sep_auto simp add: is_pfa_def min.absorb1 min.absorb2 heap add: blit_rule)"], ["", "definition pfa_extend_grow where\n  \"pfa_extend_grow \\<equiv> \\<lambda> (a,n) (b,m). do{\n  a' \\<leftarrow> array_ensure a (n+m) default;\n  blit b 0 a' n m;\n  return (a',n+m)\n}\""], ["", "lemma pfa_extend_grow_rule: \n  \"<is_pfa c l1 (a,n) * is_pfa d l2 (b,m)>\n  pfa_extend_grow (a,n) (b,m) \n  <\\<lambda>(a',n'). is_pfa (max c (n+m)) (l1@l2) (a',n') * \\<up>(n'=n+m \\<and> c \\<ge> n) * is_pfa d l2 (b,m)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l1 (a, n) *\n     is_pfa d l2\n      (b, m)> pfa_extend_grow (a, n)\n               (b, m) <\\<lambda>r.\n                          case r of\n                          (a', n') \\<Rightarrow>\n                            is_pfa (max c (n + m)) (l1 @ l2) (a', n') *\n                            \\<up> (n' = n + m \\<and> n \\<le> c) *\n                            is_pfa d l2 (b, m)>\\<^sub>t", "unfolding pfa_extend_grow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l1 (a, n) *\n     is_pfa d l2\n      (b, m)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>(b, m).\n                    array_ensure a (n + m) default \\<bind>\n                    (\\<lambda>a'.\n                        blit b 0 a' n m \\<bind>\n                        (\\<lambda>_. return (a', n + m))))\n               (b, m) <\\<lambda>r.\n                          case r of\n                          (a', n') \\<Rightarrow>\n                            is_pfa (max c (n + m)) (l1 @ l2) (a', n') *\n                            \\<up> (n' = n + m \\<and> n \\<le> c) *\n                            is_pfa d l2 (b, m)>\\<^sub>t", "by (sep_auto simp add: is_pfa_def min.absorb1 min.absorb2 heap add: blit_rule)"], ["", "definition pfa_append_extend_grow where\n  \"pfa_append_extend_grow \\<equiv> \\<lambda> (a,n) x (b,m). do{\n  a' \\<leftarrow> array_ensure a (n+m+1) default;\n  a'' \\<leftarrow> Array.upd n x a';\n  blit b 0 a'' (n+1) m;\n  return (a'',n+m+1)\n}\""], ["", "lemma pfa_append_extend_grow_rule: \n  \"<is_pfa c l1 (a,n) * is_pfa d l2 (b,m)>\n  pfa_append_extend_grow (a,n) x (b,m) \n  <\\<lambda>(a',n'). is_pfa (max c (n+m+1)) (l1@x#l2) (a',n') * \\<up>(n'=n+m+1 \\<and> c \\<ge> n) * is_pfa d l2 (b,m)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l1 (a, n) *\n     is_pfa d l2\n      (b, m)> pfa_append_extend_grow (a, n) x\n               (b, m) <\\<lambda>r.\n                          case r of\n                          (a', n') \\<Rightarrow>\n                            is_pfa (max c (n + m + 1)) (l1 @ x # l2)\n                             (a', n') *\n                            \\<up> (n' = n + m + 1 \\<and> n \\<le> c) *\n                            is_pfa d l2 (b, m)>\\<^sub>t", "unfolding pfa_append_extend_grow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pfa c l1 (a, n) *\n     is_pfa d l2\n      (b, m)> (case (a, n) of\n               (a, n) \\<Rightarrow>\n                 \\<lambda>x (b, m).\n                    array_ensure a (n + m + 1) default \\<bind>\n                    (\\<lambda>a'.\n                        Array.upd n x a' \\<bind>\n                        (\\<lambda>a''.\n                            blit b 0 a'' (n + 1) m \\<bind>\n                            (\\<lambda>_. return (a'', n + m + 1)))))\n               x (b, m) <\\<lambda>r.\n                            case r of\n                            (a', n') \\<Rightarrow>\n                              is_pfa (max c (n + m + 1)) (l1 @ x # l2)\n                               (a', n') *\n                              \\<up> (n' = n + m + 1 \\<and> n \\<le> c) *\n                              is_pfa d l2 (b, m)>\\<^sub>t", "by (sep_auto simp add: list_update_last is_pfa_def min.absorb1 min.absorb2 heap add: blit_rule)"], ["", "definition \"pfa_delete \\<equiv> \\<lambda>(a,n) i. do {\n  array_shl a (i+1) 1;\n  return (a,n-1)\n}\""], ["", "lemma pfa_delete_rule[sep_heap_rules]:\n  \"i < n \\<Longrightarrow>\n  <is_pfa c l (a,n)>\n  pfa_delete (a,n) i\n  <\\<lambda>(a',n'). is_pfa c (take i l@drop (i+1) l) (a',n') * \\<up>(n' = n-1 \\<and> a=a')>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow>\n    <is_pfa c l (a, n)> pfa_delete (a, n) i\n    <\\<lambda>(a', n').\n        is_pfa c (take i l @ drop (i + 1) l) (a', n') *\n        \\<up> (n' = n - 1 \\<and> a = a')>", "unfolding pfa_delete_def is_pfa_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow>\n    <case (a, n) of\n     (a, n) \\<Rightarrow>\n       \\<exists>\\<^sub>Al'.\n          a \\<mapsto>\\<^sub>a l' *\n          \\<up> (c = length l' \\<and> n \\<le> c \\<and> l = take n l')>\n    (case (a, n) of\n     (a, n) \\<Rightarrow>\n       \\<lambda>i.\n          array_shl a (i + 1) 1 \\<bind> (\\<lambda>_. return (a, n - 1)))\n     i\n    <\\<lambda>(a', n').\n        (case (a', n') of\n         (a, n) \\<Rightarrow>\n           \\<exists>\\<^sub>Al'.\n              a \\<mapsto>\\<^sub>a l' *\n              \\<up>\n               (c = length l' \\<and>\n                n \\<le> c \\<and> take i l @ drop (i + 1) l = take n l')) *\n        \\<up> (n' = n - 1 \\<and> a = a')>", "apply (sep_auto simp add: drop_take min_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l' aa b.\n       \\<lbrakk>i < n; c = length l'; n \\<le> length l'; l = take n l';\n        (aa, b) \\<Turnstile>\n        a \\<mapsto>\\<^sub>a\n        (take i l' @ drop (Suc i) l' @ drop (length l' - Suc 0) l');\n        n - Suc 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> take i l' = take (n - Suc 0) l'", "by (metis Suc_diff_Suc diff_zero dual_order.strict_trans2 le_less_Suc_eq zero_le)"], ["", "end"]]}