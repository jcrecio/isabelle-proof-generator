{"file_name": "/home/qj213/afp-2021-10-22/thys/Dict_Construction/Documentation/Introduction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dict_Construction", "problem_names": ["lemma \"cert_plus dict \\<Longrightarrow> double' dict = double\""], "translations": [["", "lemma \"cert_plus dict \\<Longrightarrow> double' dict = double\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cert_plus dict \\<Longrightarrow> double' dict = double", "unfolding cert_plus_def double'_def double_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. param_plus dict = Introduction.plus_class.plus \\<Longrightarrow>\n    (\\<lambda>x. param_plus dict x x) =\n    (\\<lambda>x. Introduction.plus_class.plus x x)", "by auto"], ["", "text \\<open>\n  An unconditional equation can be obtained by specializing the theorem to a ground type and\n  supplying a valid dictionary.\n\\<close>"], ["", "subsection \\<open>Implementation\\<close>"], ["", "text \\<open>\n  When translating a constant \\<open>f\\<close>, we use existing mechanisms in Isabelle to obtain its\n  \\<^emph>\\<open>code graph\\<close>. The graph contains the code equations of all transitive dependencies (i.e.,\n  other constants) of \\<open>f\\<close>. In general, we have to re-define each of these dependencies. For that,\n  we use the internal interface of the @{command function} package and feed it the code equations\n  after performing the dictionary construction. In the standard case, where the user has not\n  performed a custom code setup, the resulting function looks similar to its original definition.\n  But the user may have also changed the implementation of a function significantly afterwards.\n  This imposes some restrictions:\n\n  \\<^item> The new constant needs to be proven terminating. We apply some heuristics to transfer the\n    original termination proof to the new definition. This only works when the termination condition\n    does not rely on class axioms. (See \\<open>\\<section>\\<close>\\ref{sec:termination} for details.)\n  \\<^item> Pattern matching must be performed on datatypes, instead of the more general\n    @{command code_datatype}s.\n  \\<^item> The set of code equations must be exhaustive and non-overlapping.\n\\<close>"], ["", "end"]]}