{"file_name": "/home/qj213/afp-2021-10-22/thys/Dict_Construction/Test_Side_Conditions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dict_Construction", "problem_names": ["lemma head_side_eq: \"head_side xs \\<longleftrightarrow> xs \\<noteq> []\"", "lemma tail_side_eq: \"tail_side xs \\<longleftrightarrow> xs \\<noteq> []\"", "lemma map_cong:\n  assumes \"xs = ys\" \"\\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\"\n  shows \"map f xs = map g ys\"", "lemma \"map_head_side xs \\<longleftrightarrow> (\\<forall>x \\<in> set xs. x \\<noteq> [])\"", "lemma \"map_head'_side xss \\<longleftrightarrow> (\\<forall>xs \\<in> set xss. \\<forall>x \\<in> set xs. x \\<noteq> [])\"", "lemma \"\\<not> map_head_side xs\""], "translations": [["", "lemma head_side_eq: \"head_side xs \\<longleftrightarrow> xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_side xs = (xs \\<noteq> [])", "by (cases xs) (auto intro: head_side.intros elim: head_side.cases)"], ["", "declaration \\<open>K (Side_Conditions.set_alt @{term head} @{thm head_side_eq})\\<close>"], ["", "fun map where\n\"map f [] = []\" |\n\"map f (x # xs) = f x # map f xs\""], ["", "local_setup \\<open>snd o Side_Conditions.mk_side @{thms map.simps} (SOME @{thms map.induct})\\<close>"], ["", "thm map_side.intros"], ["", "ML \\<open>assert_alt_total @{context} @{term map}\\<close>"], ["", "experiment begin"], ["", "text \\<open>Functions that use partial functions always in their domain are processed correctly.\\<close>"], ["", "fun tail where\n  \"tail (_ # xs) = xs\""], ["", "local_setup \\<open>snd o Side_Conditions.mk_side @{thms tail.simps} NONE\\<close>"], ["", "lemma tail_side_eq: \"tail_side xs \\<longleftrightarrow> xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tail_side xs = (xs \\<noteq> [])", "by (cases xs) (auto intro: tail_side.intros elim: tail_side.cases)"], ["", "declaration \\<open>K (Side_Conditions.set_alt @{term tail} @{thm tail_side_eq})\\<close>"], ["", "function map' where\n  \"map' f xs = (if xs = [] then [] else f (head xs) # map' f (tail xs))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>f xs. x = (f, xs) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>f xs fa xsa.\n       (f, xs) = (fa, xsa) \\<Longrightarrow>\n       (if xs = [] then [] else f (head xs) # map'_sumC (f, tail xs)) =\n       (if xsa = [] then [] else fa (head xsa) # map'_sumC (fa, tail xsa))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Wellfounded.accp map'_rel x", "apply (relation \"measure (size \\<circ> snd)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measure (length \\<circ> snd))\n 2. \\<And>f xs.\n       xs \\<noteq> [] \\<Longrightarrow>\n       ((f, tail xs), f, xs) \\<in> measure (length \\<circ> snd)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f xs.\n       xs \\<noteq> [] \\<Longrightarrow>\n       ((f, tail xs), f, xs) \\<in> measure (length \\<circ> snd)", "subgoal for f xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    ((f, tail xs), f, xs) \\<in> measure (length \\<circ> snd)", "by (cases xs) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "local_setup \\<open>snd o Side_Conditions.mk_side @{thms map'.simps} (SOME @{thms map'.induct})\\<close>"], ["", "thm map'_side.intros"], ["", "ML \\<open>assert_alt_total @{context} @{term map'}\\<close>"], ["", "end"], ["", "lemma map_cong:\n  assumes \"xs = ys\" \"\\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\"\n  shows \"map f xs = map g ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Test_Side_Conditions.map f xs = Test_Side_Conditions.map g ys", "unfolding assms(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Test_Side_Conditions.map f ys = Test_Side_Conditions.map g ys", "using assms(2)"], ["proof (prove)\nusing this:\n  ?x \\<in> set ys \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. Test_Side_Conditions.map f ys = Test_Side_Conditions.map g ys", "by (induction ys) auto"], ["", "definition map_head where\n\"map_head xs = map head xs\""], ["", "experiment begin"], ["", "declare map_cong[fundef_cong]"], ["", "local_setup \\<open>snd o Side_Conditions.mk_side @{thms map_head_def} NONE\\<close>"], ["", "thm map_head_side.intros"], ["", "lemma \"map_head_side xs \\<longleftrightarrow> (\\<forall>x \\<in> set xs. x \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_head_side xs = (\\<forall>x\\<in>set xs. x \\<noteq> [])", "by (auto intro: map_head_side.intros elim: map_head_side.cases)"], ["", "definition map_head' where\n  \"map_head' xss = map (map head) xss\""], ["", "local_setup \\<open>snd o Side_Conditions.mk_side @{thms map_head'_def} NONE\\<close>"], ["", "thm map_head'_side.intros"], ["", "lemma \"map_head'_side xss \\<longleftrightarrow> (\\<forall>xs \\<in> set xss. \\<forall>x \\<in> set xs. x \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_head'_side xss =\n    (\\<forall>xs\\<in>set xss. \\<forall>x\\<in>set xs. x \\<noteq> [])", "by (auto intro: map_head'_side.intros elim: map_head'_side.cases)"], ["", "end"], ["", "experiment begin"], ["", "local_setup \\<open>snd o Side_Conditions.mk_side @{thms map_head_def} NONE\\<close>"], ["", "term map_head_side"], ["", "thm map_head_side.intros"], ["", "lemma \"\\<not> map_head_side xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> map_head_side xs", "by (auto elim: map_head_side.cases)"], ["", "end"], ["", "definition head_known where\n\"head_known xs = head (3 # xs)\""], ["", "local_setup \\<open>snd o Side_Conditions.mk_side @{thms head_known_def} NONE\\<close>"], ["", "thm head_known_side.intros"], ["", "ML\\<open>assert_alt_total @{context} @{term head_known}\\<close>"], ["", "fun odd :: \"nat \\<Rightarrow> bool\" and even where\n\"odd 0 \\<longleftrightarrow> False\" |\n\"even 0 \\<longleftrightarrow> True\" |\n\"odd (Suc n) \\<longleftrightarrow> even n\" |\n\"even (Suc n) \\<longleftrightarrow> odd n\""], ["", "local_setup \\<open>snd o Side_Conditions.mk_side @{thms odd.simps even.simps} (SOME @{thms odd_even.induct})\\<close>"], ["", "thm odd_side_even_side.intros"], ["", "ML\\<open>assert_alt_total @{context} @{term odd}\\<close>"], ["", "ML\\<open>assert_alt_total @{context} @{term even}\\<close>"], ["", "definition odd_known where\n\"odd_known = odd (Suc 0)\""], ["", "local_setup \\<open>snd o Side_Conditions.mk_side @{thms odd_known_def} NONE\\<close>"], ["", "thm odd_known_side.intros"], ["", "ML\\<open>assert_alt_total @{context} @{term odd_known}\\<close>"], ["", "end"]]}