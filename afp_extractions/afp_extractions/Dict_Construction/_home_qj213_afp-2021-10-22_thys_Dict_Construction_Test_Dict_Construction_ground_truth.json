{"file_name": "/home/qj213/afp-2021-10-22/thys/Dict_Construction/Test_Dict_Construction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dict_Construction", "problem_names": ["lemma [code]: \"fold f [] = id\" \"fold f (x # xs) s = fold f xs (f x s)\" \"fold f [x, y] u \\<equiv> f y (f x u)\"", "lemma \"List_fold = fold\"", "lemma \"Test__Dict__Construction_h = h\"", "lemma contrived[code]: \"c = d 0\"", "lemma \"Test__Dict__Construction_c = c\"", "lemma [code]: \"j 0 = 0\" \"j (Suc n) = j n\"", "lemma f_code[code]: \"k n = 0\"", "lemma\n  \"Test__Dict__Construction_j = j\"\n  \"Test__Dict__Construction_k = k\""], "translations": [["", "lemma [code]: \"fold f [] = id\" \"fold f (x # xs) s = fold f xs (f x s)\" \"fold f [x, y] u \\<equiv> f y (f x u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold f [] = id &&&\n    fold f (x # xs) s = fold f xs (f x s) &&&\n    fold f [x, y] u \\<equiv> f y (f x u)", "by auto"], ["", "experiment begin"], ["", "declassify valid: fold"], ["", "thm valid"], ["", "lemma \"List_fold = fold\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List_fold = fold", "by (rule valid)"], ["", "end"], ["", "subsection \\<open>Complex class hierarchies\\<close>"], ["", "local_setup \\<open>Class_Graph.ensure_class @{class zero} #> snd\\<close>"], ["", "local_setup \\<open>Class_Graph.ensure_class @{class plus} #> snd\\<close>"], ["", "experiment begin"], ["", "local_setup \\<open>Class_Graph.ensure_class @{class comm_monoid_add} #> snd\\<close>"], ["", "local_setup \\<open>Class_Graph.ensure_class @{class ring} #> snd\\<close>"], ["", "typ \"nat Rings_ring__dict\""], ["", "end"], ["", "text \\<open>Check that \\<open>Class_Graph\\<close> does not leak out of locales\\<close>"], ["", "ML\\<open>@{assert} (is_none (Class_Graph.node @{context} @{class ring}))\\<close>"], ["", "subsection \\<open>Instances with non-trivial arity\\<close>"], ["", "fun f :: \"'a::plus \\<Rightarrow> 'a\" where\n\"f x = x + x\""], ["", "definition g :: \"'a::{plus,zero} list \\<Rightarrow> 'a list\" where\n\"g x = f x\""], ["", "datatype natt = Z | S natt"], ["", "instantiation natt :: \"{zero,plus}\" begin"], ["", "definition zero_natt where\n  \"zero_natt = Z\""], ["", "fun plus_natt where\n  \"plus_natt Z x = x\" |\n  \"plus_natt (S m) n = S (plus_natt m n)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(natt, plus_class) &&& OFCLASS(natt, zero_class)", ".."], ["", "end"], ["", "definition h :: \"natt list\" where\n\"h = g [Z,S Z]\""], ["", "experiment begin"], ["", "(* FIXME problem with smart_tac *)"], ["", "declassify valid: h"], ["", "thm valid"], ["", "lemma \"Test__Dict__Construction_h = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Test__Dict__Construction_h = h", "by (fact valid)"], ["", "ML\\<open>Dict_Construction.the_info @{context} @{const_name plus_natt_inst.plus_natt}\\<close>"], ["", "end"], ["", "text \\<open>Check that @{command declassify} does not leak out of locales\\<close>"], ["", "ML\\<open>\n  can (Dict_Construction.the_info @{context}) @{const_name plus_natt_inst.plus_natt}\n  |> not |> @{assert}\n\\<close>"], ["", "subsection \\<open>[@{attribute fundef_cong}] rules\\<close>"], ["", "datatype 'a seq = Cons 'a \"'a seq\" | Nil"], ["", "experiment begin"], ["", "declassify map_seq"], ["", "text \\<open>Check presence of derived [@{attribute fundef_cong}] rule\\<close>"], ["", "ML\\<open>\n  Dict_Construction.the_info @{context} @{const_name map_seq}\n  |> #fun_info\n  |> the\n  |> #fs\n  |> the_single\n  |> dest_Const\n  |> fst\n  |> Dict_Construction.cong_of_const @{context}\n  |> the\n\\<close>"], ["", "end"], ["", "subsection \\<open>Mutual recursion\\<close>"], ["", "fun odd :: \"nat \\<Rightarrow> bool\" and even where\n\"odd 0 \\<longleftrightarrow> False\" |\n\"even 0 \\<longleftrightarrow> True\" |\n\"odd (Suc n) \\<longleftrightarrow> even n\" |\n\"even (Suc n) \\<longleftrightarrow> odd n\""], ["", "experiment begin"], ["", "declassify valid: odd even"], ["", "thm valid"], ["", "end"], ["", "datatype 'a bin_tree = Leaf | Node 'a \"'a bin_tree\" \"'a bin_tree\""], ["", "experiment begin"], ["", "declassify valid: map_bin_tree rel_bin_tree"], ["", "thm valid"], ["", "end"], ["", "datatype 'v env = Env \"'v list\""], ["", "datatype v = Closure \"v env\""], ["", "context\n  notes is_measure_trivial[where f = \"size_env size\", measure_function]\nbegin"], ["", "(* FIXME order is important! *)"], ["", "fun test_v :: \"v \\<Rightarrow> bool\" and test_w :: \"v env \\<Rightarrow> bool\" where\n\"test_v (Closure env) \\<longleftrightarrow> test_w env\" |\n\"test_w (Env vs) \\<longleftrightarrow> list_all test_v vs\""], ["", "fun test_v1 :: \"v \\<Rightarrow> 'a::{one,monoid_add}\" and test_w1 :: \"v env \\<Rightarrow> 'a\" where\n\"test_v1 (Closure env) = 1 + test_w1 env\" |\n\"test_w1 (Env vs) = sum_list (map test_v1 vs)\""], ["", "end"], ["", "experiment begin"], ["", "declassify valid: test_w test_v"], ["", "thm valid"], ["", "end"], ["", "experiment begin"], ["", "(* FIXME derive fundef_cong rule for sum_list *)"], ["", "declassify valid: test_w1 test_v1"], ["", "thm valid"], ["", "end"], ["", "subsection \\<open>Non-trivial code dependencies; code equations where the head is not fully general\\<close>"], ["", "definition \"c \\<equiv> 0 :: nat\""], ["", "definition \"d x \\<equiv> if x = 0 then 0 else x\""], ["", "lemma contrived[code]: \"c = d 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = d 0", "unfolding c_def d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = (if 0 = 0 then 0 else 0)", "by simp"], ["", "experiment begin"], ["", "declassify valid: c"], ["", "thm valid"], ["", "lemma \"Test__Dict__Construction_c = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Test__Dict__Construction_c = c", "by (fact valid)"], ["", "end"], ["", "subsection \\<open>Pattern matching on @{term \"0::nat\"}\\<close>"], ["", "definition j where \"j (n::nat) = (0::nat)\""], ["", "lemma [code]: \"j 0 = 0\" \"j (Suc n) = j n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j 0 = 0 &&& j (Suc n) = j n", "unfolding j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0 &&& 0 = 0", "by auto"], ["", "fun k where\n\"k 0 = (0::nat)\" |\n\"k (Suc n) = k n\""], ["", "lemma f_code[code]: \"k n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k n = 0", "by (induct n) simp+"], ["", "experiment begin"], ["", "declassify valid: j k"], ["", "thm valid"], ["", "lemma\n  \"Test__Dict__Construction_j = j\"\n  \"Test__Dict__Construction_k = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Test__Dict__Construction_j = j &&& Test__Dict__Construction_k = k", "by (fact valid)+"], ["", "end"], ["", "subsection \\<open>Complex termination arguments\\<close>"], ["", "fun fac :: \"nat \\<Rightarrow> nat\" where\n\"fac n = (if n \\<le> 1 then 1 else n * fac (n - 1))\""], ["", "experiment begin"], ["", "declassify valid: fac"], ["", "end"], ["", "subsection \\<open>Combination of various things\\<close>"], ["", "experiment begin"], ["", "declassify valid: sum_list"], ["", "end"], ["", "subsection \\<open>Interaction with the code generator\\<close>"], ["", "declassify h"], ["", "export_code Test__Dict__Construction_h in SML"], ["", "end"]]}