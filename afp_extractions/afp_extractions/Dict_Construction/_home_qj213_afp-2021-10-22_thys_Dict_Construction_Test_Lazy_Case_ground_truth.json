{"file_name": "/home/qj213/afp-2021-10-22/thys/Dict_Construction/Test_Lazy_Case.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dict_Construction", "problem_names": ["lemma map_tree[code]:\n  \"map_tree f t = (case t of Node \\<Rightarrow> Node | Fork x ts \\<Rightarrow> Fork (f x) (map (map_tree f) ts))\"", "lemma \"Test__Lazy__Case_tree_map__tree = map_tree\"", "lemma \"Test__Lazy__Case_i = i\""], "translations": [["", "lemma map_tree[code]:\n  \"map_tree f t = (case t of Node \\<Rightarrow> Node | Fork x ts \\<Rightarrow> Fork (f x) (map (map_tree f) ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree f t =\n    (case t of Node \\<Rightarrow> Node\n     | Fork x ts \\<Rightarrow> Fork (f x) (map (map_tree f) ts))", "by (induction t) auto"], ["", "experiment begin"], ["", "(* FIXME proper qualified path *)"], ["", "text \\<open>\n  Dictionary construction of @{const map_tree} requires the [@{attribute fundef_cong}] rule of\n  @{const Test_Lazy_Case.tree.case_lazy}.\n\\<close>"], ["", "declassify valid: map_tree"], ["", "thm valid"], ["", "lemma \"Test__Lazy__Case_tree_map__tree = map_tree\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Test__Lazy__Case_tree_map__tree = map_tree", "by (fact valid)"], ["", "end"], ["", "definition i :: \"(unit \\<times> (bool list \\<times> string \\<times> nat option) list) option \\<Rightarrow> string\" where\n\"i = show\""], ["", "experiment begin"], ["", "text \\<open>This currently requires @{theory Lazy_Case.Lazy_Case} because of @{const divmod_nat}.\\<close>"], ["", "(* FIXME get rid of Lazy_Case dependency *)"], ["", "declassify valid: i"], ["", "thm valid"], ["", "lemma \"Test__Lazy__Case_i = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Test__Lazy__Case_i = i", "by (fact valid)"], ["", "end"], ["", "end"]]}