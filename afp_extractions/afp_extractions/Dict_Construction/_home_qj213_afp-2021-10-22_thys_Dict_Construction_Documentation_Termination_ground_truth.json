{"file_name": "/home/qj213/afp-2021-10-22/thys/Dict_Construction/Documentation/Termination.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dict_Construction", "problem_names": ["lemma [code]: \"f x = f x\"", "lemma f_total: \"wfP f_rel\""], "translations": [["", "lemma [code]: \"f x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = f x", ".."], ["", "text \\<open>\n  The invocation of @{theory_text \\<open>declassify f\\<close>} would fail, because @{const f}'s code equations\n  are not terminating.\n\n  Hence, in the general case where users have modified the code equations, we need to fall back\n  to an (automated) attempt to prove termination.\n\n  In the remainder of this section, we will illustrate the special case where the user has not\n  modified the code equations, i.e., the original termination proof should ``morally'' be still\n  applicable. For this, we will perform the dictionary construction manually.\n\\<close>\n\n\\<comment> \\<open>Some ML incantations to ensure that the dictionary types are present\\<close>"], ["", "local_setup \\<open>Class_Graph.ensure_class @{class plus} #> snd\\<close>"], ["", "local_setup \\<open>Class_Graph.ensure_class @{class zero} #> snd\\<close>"], ["", "fun sum_list :: \"'a::{plus,zero} list \\<Rightarrow> 'a\" where\n\"sum_list [] = 0\" |\n\"sum_list (x # xs) = x + sum_list xs\""], ["", "text \\<open>\n  The above function carries two distinct class constraints, which are translated into two\n  dictionary parameters:\n\\<close>"], ["", "function sum_list' where\n\"sum_list' d_plus d_zero [] = Groups_zero__class_zero__field d_zero\" |\n\"sum_list' d_plus d_zero (x # xs) = Groups_plus__class_plus__field d_plus x (sum_list' d_plus d_zero xs)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>d_plus d_zero.\n                   x = (d_plus, d_zero, []) \\<Longrightarrow> P;\n        \\<And>d_plus d_zero xa xs.\n           x = (d_plus, d_zero, xa # xs) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>d_plus d_zero d_plusa d_zeroa.\n       (d_plus, d_zero, []) = (d_plusa, d_zeroa, []) \\<Longrightarrow>\n       Groups_zero__class_zero__field d_zero =\n       Groups_zero__class_zero__field d_zeroa\n 3. \\<And>d_plus d_zero d_plusa d_zeroa x xs.\n       (d_plus, d_zero, []) = (d_plusa, d_zeroa, x # xs) \\<Longrightarrow>\n       Groups_zero__class_zero__field d_zero =\n       Groups_plus__class_plus__field d_plusa x\n        (sum_list'_sumC (d_plusa, d_zeroa, xs))\n 4. \\<And>d_plus d_zero x xs d_plusa d_zeroa xa xsa.\n       (d_plus, d_zero, x # xs) =\n       (d_plusa, d_zeroa, xa # xsa) \\<Longrightarrow>\n       Groups_plus__class_plus__field d_plus x\n        (sum_list'_sumC (d_plus, d_zero, xs)) =\n       Groups_plus__class_plus__field d_plusa xa\n        (sum_list'_sumC (d_plusa, d_zeroa, xsa))", "by pat_completeness auto"], ["", "text \\<open>\n  Now, we need to carry out the termination proof of @{const sum_list'}. The @{theory_text function}\n  package analyzes the function definition and discovers one recursive call. In pseudo-notation:\n\n  @{text [display] \\<open>(d_plus, d_zero, x # xs) \\<leadsto> (d_plus, d_zero, xs)\\<close>}\n\n  The result of this analysis is captured in the inductive predicate @{const sum_list'_rel}. Its\n  introduction rules look as follows:\n\\<close>"], ["", "thm sum_list'_rel.intros\n\\<comment> \\<open>@{thm sum_list'_rel.intros}\\<close>"], ["", "text \\<open>Compare this to the relation for @{const sum_list}:\\<close>"], ["", "thm sum_list_rel.intros\n\\<comment> \\<open>@{thm sum_list_rel.intros}\\<close>"], ["", "text \\<open>\n  Except for the additional (unchanging) dictionary arguments, these relations are more or less\n  equivalent to each other. There is an important difference, though: @{const sum_list_rel} has\n  sort constraints, @{const sum_list'_rel} does not. (This will become important later on.)\n\\<close>"], ["", "context\n  notes [[show_sorts]]\nbegin"], ["", "term sum_list_rel\n\\<comment> \\<open>@{typ \\<open>'a::{plus,zero} list \\<Rightarrow> 'a::{plus,zero} list \\<Rightarrow> bool\\<close>}\\<close>"], ["", "term sum_list'_rel\n\\<comment> \\<open>@{typ \\<open>'a::type Groups_plus__dict \\<times> 'a::type Groups_zero__dict \\<times> 'a::type list \\<Rightarrow> 'a::type Groups_plus__dict \\<times> 'a::type Groups_zero__dict \\<times> 'a::type list \\<Rightarrow> bool\\<close>}\\<close>"], ["", "end"], ["", "text \\<open>\n  Let us know discuss the rough concept of the termination proof for @{const sum_list'}. The goal is\n  to show that @{const sum_list'_rel} is well-founded. Usually, this is proved by specifying a\n  \\<^emph>\\<open>measure function\\<close> that\n  \\<^enum> maps the arguments to natural numbers\n  \\<^enum> decreases for each recursive call.\n\\<close>"], ["", "text \\<open>\n  Here, however, we want to instead show that each recursive call in @{const sum_list'} has a\n  corresponding recursive call in @{const sum_list}. In other words, we want to show that the\n  existing proof of well-foundedness of @{const sum_list_rel} can be lifted to a proof of\n  well-foundedness of @{const sum_list'_rel}. This is what the theorem\n  @{thm [source=true] wfP_simulate_simple} states:\n\n  @{thm [display=true] wfP_simulate_simple}\n\n  Given any well-founded relation \\<open>r\\<close> and a function \\<open>g\\<close> that maps function arguments from \\<open>r'\\<close> to\n  \\<open>r\\<close>, we can deduce that \\<open>r'\\<close> is also well-founded.\n\n  For our example, we need to provide a function \\<open>g\\<close> of type\n  @{typ \\<open>'b Groups_plus__dict \\<times> 'b Groups_zero__dict \\<times> 'b list \\<Rightarrow> 'a list\\<close>}.\n  Because the dictionary parameters are not changing, they can safely be dropped by \\<open>g\\<close>.\n  However, because of the sort constraint in @{const sum_list_rel}, the term @{term \"snd \\<circ> snd\"}\n  is not a well-typed instantiation for \\<open>g\\<close>.\n\n  Instead (this is where the heuristic comes in), we assume that the original function\n  @{const sum_list} is parametric, i.e., termination does not depend on the elements of the list\n  passed to it, but only on the structure of the list. Additionally, we assume that all involved\n  type classes have at least one instantiation.\n\n  With this in mind, we can use @{term \"map (\\<lambda>_. undefined) \\<circ> snd \\<circ> snd\"} as \\<open>g\\<close>:\n\\<close>"], ["", "thm wfP_simulate_simple[where\n  r = sum_list_rel and\n  r' = sum_list'_rel and\n  g = \"map (\\<lambda>_. undefined) \\<circ> snd \\<circ> snd\"]"], ["", "text \\<open>\n  Finally, we can prove the termination of @{const sum_list'}.\n\\<close>"], ["", "termination sum_list'"], ["proof (prove)\ngoal (1 subgoal):\n 1. All sum_list'_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All sum_list'_dom", "have \"wfP sum_list'_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP sum_list'_rel", "proof (rule wfP_simulate_simple)\n    \\<comment> \\<open>We first need to obtain the well-foundedness theorem for @{const sum_list_rel} from the ML\n        guts of the @{theory_text function} package.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. wfP ?r\n 2. \\<And>x y. sum_list'_rel x y \\<Longrightarrow> ?r (?g x) (?g y)", "show \"wfP sum_list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP sum_list_rel", "apply (rule accp_wfPI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. All sum_list_dom", "apply (tactic \\<open>resolve_tac @{context} [Function.get_info @{context} @{term sum_list} |> #totality |> the] 1\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wfP sum_list_rel\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       sum_list'_rel x y \\<Longrightarrow> sum_list_rel (?g x) (?g y)", "define g :: \"'b Groups_plus__dict \\<times> 'b Groups_zero__dict \\<times> 'b list \\<Rightarrow> 'c::{plus,zero} list\" where\n      \"g = map (\\<lambda>_. undefined) \\<circ> snd \\<circ> snd\"\n\n    \\<comment> \\<open>Prove the simulation of @{const sum_list'_rel} by @{const sum_list_rel} by rule induction.\\<close>"], ["proof (state)\nthis:\n  g = map (\\<lambda>_. undefined) \\<circ> snd \\<circ> snd\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       sum_list'_rel x y \\<Longrightarrow> sum_list_rel (?g x) (?g y)", "show \"sum_list_rel (g x) (g y)\" if \"sum_list'_rel x y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list_rel (g x) (g y)", "using that"], ["proof (prove)\nusing this:\n  sum_list'_rel x y\n\ngoal (1 subgoal):\n 1. sum_list_rel (g x) (g y)", "proof (induction x y rule: sum_list'_rel.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d_plus d_zero x xs.\n       sum_list_rel (g (d_plus, d_zero, xs)) (g (d_plus, d_zero, x # xs))", "case (1 d_plus d_zero x xs)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>d_plus d_zero x xs.\n       sum_list_rel (g (d_plus, d_zero, xs)) (g (d_plus, d_zero, x # xs))", "show ?case\n          \\<comment> \\<open>Unfold the constituent parts of @{term g}:\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list_rel (g (d_plus, d_zero, xs)) (g (d_plus, d_zero, x # xs))", "apply (simp only: g_def comp_apply snd_conv list.map)\n          \\<comment> \\<open>Use the corresponding introduction rule of @{const sum_list_rel} and hope for the best:\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list_rel (map (\\<lambda>_. undefined) xs)\n     (undefined # map (\\<lambda>_. undefined) xs)", "apply (rule sum_list_rel.intros(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sum_list_rel (g (d_plus, d_zero, xs)) (g (d_plus, d_zero, x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list'_rel ?x1 ?y1 \\<Longrightarrow> sum_list_rel (g ?x1) (g ?y1)\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>This is the goal that the @{theory_text function} package expects.\\<close>"], ["proof (state)\nthis:\n  wfP sum_list'_rel\n\ngoal (1 subgoal):\n 1. All sum_list'_dom", "then"], ["proof (chain)\npicking this:\n  wfP sum_list'_rel", "show \"\\<forall>x. sum_list'_dom x\""], ["proof (prove)\nusing this:\n  wfP sum_list'_rel\n\ngoal (1 subgoal):\n 1. All sum_list'_dom", "by (rule wfP_implies_dom)"], ["proof (state)\nthis:\n  All sum_list'_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This can be automated with a special tactic:\\<close>"], ["", "experiment\nbegin"], ["", "termination sum_list'"], ["proof (prove)\ngoal (1 subgoal):\n 1. All sum_list'_dom", "apply (tactic \\<open>\n    Transfer_Termination.termination_tac\n      (Function.get_info @{context} @{term sum_list'})\n      (Function.get_info @{context} @{term sum_list})\n      @{context}\n      1\\<close>; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>\n  A similar technique can be used for making functions defined in locales executable when, for some\n  reason, the definition of a ``defs'' locale is not feasible.\n\\<close>"], ["", "locale foo =\n  fixes A :: \"nat\"\n  assumes \"A > 0\"\nbegin"], ["", "fun f where\n\"f 0 = A\" |\n\"f (Suc n) = Suc (f n)\"\n\n\\<comment> \\<open>We carry out this proof in the locale for simplicity; a real implementation would probably\n    have to set up a local theory properly.\\<close>"], ["", "lemma f_total: \"wfP f_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP local.f_rel", "apply (rule accp_wfPI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Wellfounded.accp local.f_rel x", "apply (tactic \\<open>resolve_tac @{context} [Function.get_info @{context} @{term f} |> #totality |> the] 1\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end\n\n\\<comment> \\<open>The dummy interpretation serves the same purpose as the assumption that class constraints have\n    at least one instantiation.\\<close>"], ["", "interpretation dummy: foo 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. foo 1", "by standard simp"], ["", "function f' where\n\"f' A 0 = A\" |\n\"f' A (Suc n) = Suc (f' A n)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>A. x = (A, 0) \\<Longrightarrow> P;\n        \\<And>A n. x = (A, Suc n) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>A Aa. (A, 0) = (Aa, 0) \\<Longrightarrow> A = Aa\n 3. \\<And>A Aa n.\n       (A, 0) = (Aa, Suc n) \\<Longrightarrow> A = Suc (f'_sumC (Aa, n))\n 4. \\<And>A n Aa na.\n       (A, Suc n) = (Aa, Suc na) \\<Longrightarrow>\n       Suc (f'_sumC (A, n)) = Suc (f'_sumC (Aa, na))", "by pat_completeness auto"], ["", "termination f'"], ["proof (prove)\ngoal (1 subgoal):\n 1. All f'_dom", "apply (rule wfP_implies_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP f'_rel", "apply (rule wfP_simulate_simple[where g = \"snd\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. wfP ?r2\n 2. \\<And>x y. f'_rel x y \\<Longrightarrow> ?r2 (snd x) (snd y)", "apply (rule dummy.f_total)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. f'_rel x y \\<Longrightarrow> dummy.f_rel (snd x) (snd y)", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f'_rel x y \\<Longrightarrow> dummy.f_rel (snd x) (snd y)", "apply (induction x y rule: f'_rel.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A n. dummy.f_rel (snd (A, n)) (snd (A, Suc n))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. dummy.f_rel (snd (A_, n_)) (snd (A_, Suc n_))", "apply (simp only: snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dummy.f_rel n_ (Suc n_)", "apply (rule dummy.f_rel.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Automatic:\\<close>"], ["", "experiment\nbegin"], ["", "termination f'"], ["proof (prove)\ngoal (1 subgoal):\n 1. All f'_dom", "apply (tactic \\<open>\n    Transfer_Termination.termination_tac\n      (Function.get_info @{context} @{term f'})\n      (Function.get_info @{context} @{term dummy.f})\n      @{context}\n      1\\<close>; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}