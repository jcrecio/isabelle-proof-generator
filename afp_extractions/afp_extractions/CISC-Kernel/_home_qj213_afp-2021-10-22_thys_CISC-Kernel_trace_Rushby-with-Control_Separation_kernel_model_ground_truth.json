{"file_name": "/home/qj213/afp-2021-10-22/thys/CISC-Kernel/trace/Rushby-with-Control/Separation_kernel_model.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CISC-Kernel", "problem_names": ["lemma initial_invariant:\n  shows \"atomic_step_invariant s0\"", "lemma rstate_invariant:\n  shows \"atomic_step_invariant (\\<down>s)\"", "lemma rstate_down_up[simp]:\n  shows \"(\\<up>\\<down>s) = s\"", "lemma rstate_up_down[simp]:\n  assumes \"atomic_step_invariant s\"\n  shows \"(\\<down>\\<up>s) = s\"", "lemma inst_vpeq_rel:\n  shows rvpeq_refl: \"rvpeq u s s\"\n    and rvpeq_sym: \"rvpeq u s1 s2 \\<Longrightarrow> rvpeq u s2 s1\"\n    and rvpeq_trans: \"\\<lbrakk> rvpeq u s1 s2; rvpeq u s2 s3 \\<rbrakk> \\<Longrightarrow> rvpeq u s1 s3\"", "lemma inst_ifp_refl:\n  shows \"\\<forall> u . rifp u u\"", "lemma inst_step_atomicity [simp]:\n  shows \"\\<forall> s a . rcurrent (rstep s a) = rcurrent s\"", "lemma inst_weakly_step_consistent:\n  assumes \"rvpeq u s t\"\n      and \"rvpeq (rcurrent s) s t\"\n      and \"rcurrent s = rcurrent t\"\n      and \"rprecondition s (rcurrent s) a\"\n      and \"rprecondition t (rcurrent t) a\"\n    shows \"rvpeq u (rstep s a) (rstep t a)\"", "lemma inst_local_respect:\n  assumes not_ifp: \"\\<not>rifp (rcurrent s) u\"\n      and prec: \"rprecondition s (rcurrent s) a\"\n    shows \"rvpeq u s (rstep s a)\"", "lemma inst_output_consistency:\n  assumes rvpeq: \"rvpeq (rcurrent s) s t\"\n  and     current_eq: \"rcurrent s = rcurrent t\"\n  shows   \"routput_f s a = routput_f t a\"", "lemma inst_cswitch_independent_of_state:\n  assumes \"rcurrent s = rcurrent t\"\n  shows \"rcurrent (rcswitch n s) = rcurrent (rcswitch n t)\"", "lemma inst_cswitch_consistency:\n  assumes \"rvpeq u s t\"\n  shows \"rvpeq u (rcswitch n s) (rcswitch n t)\"", "lemma prec_first_IPC_action:\nassumes \"is_SK_IPC aseq\"\n  shows \"rprecondition s d (hd aseq)\"", "lemma prec_first_EV_WAIT_action:\nassumes \"is_SK_EV_WAIT aseq\"\n  shows \"rprecondition s d (hd aseq)\"", "lemma prec_first_EV_SIGNAL_action:\nassumes \"is_SK_EV_SIGNAL aseq\"\n  shows \"rprecondition s d (hd aseq)\"", "lemma prec_after_IPC_step:\nassumes prec: \"rprecondition s (rcurrent s) (aseq ! n)\" \n    and n_bound: \"Suc n < length aseq\"\n    and IPC: \"is_SK_IPC aseq\"\n    and not_aborting: \"\\<not>raborting s (rcurrent s) (aseq ! n)\"\n    and not_waiting: \"\\<not>rwaiting s (rcurrent s) (aseq ! n)\"\nshows \"rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\"", "lemma prec_after_EV_WAIT_step:\nassumes prec: \"rprecondition s (rcurrent s) (aseq ! n)\" \n    and n_bound: \"Suc n < length aseq\"\n    and IPC: \"is_SK_EV_WAIT aseq\"\n    and not_aborting: \"\\<not>raborting s (rcurrent s) (aseq ! n)\"\n    and not_waiting: \"\\<not>rwaiting s (rcurrent s) (aseq ! n)\"\nshows \"rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\"", "lemma prec_after_EV_SIGNAL_step:\nassumes prec: \"rprecondition s (rcurrent s) (aseq ! n)\" \n    and n_bound: \"Suc n < length aseq\"\n    and SIGNAL: \"is_SK_EV_SIGNAL aseq\"\n    and not_aborting: \"\\<not>raborting s (rcurrent s) (aseq ! n)\"\n    and not_waiting: \"\\<not>rwaiting s (rcurrent s) (aseq ! n)\"\nshows \"rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\"", "lemma on_set_object_value:\n  shows \"sp_impl_subj_subj (set_object_value ob val s) = sp_impl_subj_subj s\"\n    and \"sp_impl_subj_obj (set_object_value ob val s) = sp_impl_subj_obj s\"", "lemma prec_IPC_dom_independent:\nassumes \"current s \\<noteq> d\"\n    and \"atomic_step_invariant s\"\n    and \"atomic_step_precondition s d a\"\nshows \"atomic_step_precondition (atomic_step_ipc (current s) dir stage partner page s) d a\"", "lemma prec_ev_signal_dom_independent:\nassumes \"current s \\<noteq> d\"\n    and \"atomic_step_invariant s\"\n    and \"atomic_step_precondition s d a\"\nshows \"atomic_step_precondition (atomic_step_ev_signal (current s) partner s) d a\"", "lemma prec_ev_wait_one_dom_independent:\nassumes \"current s \\<noteq> d\"\n    and \"atomic_step_invariant s\"\n    and \"atomic_step_precondition s d a\"\nshows \"atomic_step_precondition (atomic_step_ev_wait_one (current s) s) d a\"", "lemma prec_ev_wait_all_dom_independent:\nassumes \"current s \\<noteq> d\"\n    and \"atomic_step_invariant s\"\n    and \"atomic_step_precondition s d a\"\nshows \"atomic_step_precondition (atomic_step_ev_wait_all (current s) s) d a\"", "lemma prec_dom_independent:\nshows \"\\<forall> s d a a' . rcurrent s \\<noteq> d \\<and> rprecondition s d a \\<longrightarrow> rprecondition (rstep s a') d a\"", "lemma ipc_precondition_after_cswitch[simp]:\nshows \"ipc_precondition d dir partner page ((\\<down> s)\\<lparr>current := new_current\\<rparr>) \n          = ipc_precondition d dir partner page (\\<down> s)\"", "lemma precondition_after_cswitch:\nshows \"\\<forall>s d n a. rprecondition s d a \\<longrightarrow> rprecondition (rcswitch n s) d a\"", "lemma aborting_switch_independent:\nshows \"\\<forall>n s. raborting (rcswitch n s) = raborting s\"", "lemma waiting_switch_independent:\nshows \"\\<forall>n s. rwaiting (rcswitch n s) = rwaiting s\"", "lemma aborting_after_IPC_step:\nassumes \"d1 \\<noteq> d2\"\nshows \"aborting (atomic_step_ipc d1 dir stage partner page s) d2 a = aborting s d2 a\"", "lemma waiting_after_IPC_step:\nassumes \"d1 \\<noteq> d2\"\nshows \"waiting (atomic_step_ipc d1 dir stage partner page s) d2 a = waiting s d2 a\"", "lemma raborting_consistent:\nshows \"\\<forall>s t u. rvpeq u s t \\<longrightarrow> raborting s u = raborting t u\"", "lemma aborting_dom_independent:\n  assumes \"rcurrent s \\<noteq> d\"\n    shows \"raborting (rstep s a) d a' = raborting s d a'\"", "lemma ipc_precondition_of_partner_consistent:\nassumes vpeq: \"\\<forall> d \\<in> rkinvolved (SK_IPC dir WAIT partner page) . rvpeq d s t\"\nshows \"ipc_precondition partner dir' u page' (\\<down> s) =  ipc_precondition partner dir' u page' \\<down> t\"", "lemma ev_signal_precondition_of_partner_consistent:\nassumes vpeq: \"\\<forall> d \\<in> rkinvolved (SK_EV_SIGNAL EV_SIGNAL_FINISH partner) . rvpeq d s t\"\nshows \"ev_signal_precondition partner u (\\<down> s) =  ev_signal_precondition partner u (\\<down> t)\"", "lemma waiting_consistent:\nshows \"\\<forall>s t u a . rvpeq (rcurrent s) s t \\<and> (\\<forall> d \\<in> rkinvolved a . rvpeq d s t) \n        \\<and> rvpeq u s t\n        \\<longrightarrow> rwaiting s u a = rwaiting t u a\"", "lemma ipc_precondition_ensures_ifp:\nassumes \"ipc_precondition (current s) dir partner page s\"\n    and \"atomic_step_invariant s\"\nshows \"rifp partner (current s)\"", "lemma ev_signal_precondition_ensures_ifp:\nassumes \"ev_signal_precondition (current s) partner s\"\n    and \"atomic_step_invariant s\"\nshows \"rifp partner (current s)\"", "lemma involved_ifp:\nshows \"\\<forall> s a . \\<forall> d \\<in> rkinvolved a . rprecondition s (rcurrent s) a \\<longrightarrow> rifp d (rcurrent s)\"", "lemma spec_of_waiting_ev:\nshows \"\\<forall>s a. rwaiting s (rcurrent s) (SK_EV_WAIT EV_FINISH EV_CONSUME_ALL) \n               \\<longrightarrow> rstep s a = s\"", "lemma spec_of_waiting_ev_w:\nshows \"\\<forall>s a. rwaiting s (rcurrent s) (SK_EV_WAIT EV_WAIT EV_CONSUME_ALL) \n               \\<longrightarrow> rstep s (SK_EV_WAIT EV_WAIT EV_CONSUME_ALL) = s\"", "lemma spec_of_waiting:\nshows \"\\<forall>s a. rwaiting s (rcurrent s) a \\<longrightarrow> rstep s a = s\""], "translations": [["", "lemma initial_invariant:\n  shows \"atomic_step_invariant s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant s0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. atomic_step_invariant s0", "have \"sp_subset s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_subset s0", "unfolding sp_subset_def s0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p1 p2.\n        sp_impl_subj_subj\n         \\<lparr>sp_impl_subj_subj = Policy.sp_spec_subj_subj,\n            sp_impl_subj_obj = Policy.sp_spec_subj_obj,\n            current = initial_current, obj = initial_obj,\n            thread = \\<lambda>_. \\<lparr>ev_counter = 0\\<rparr>\\<rparr>\n         p1 p2 \\<longrightarrow>\n        Policy.sp_spec_subj_subj p1 p2) \\<and>\n    (\\<forall>p1 p2 m.\n        sp_impl_subj_obj\n         \\<lparr>sp_impl_subj_subj = Policy.sp_spec_subj_subj,\n            sp_impl_subj_obj = Policy.sp_spec_subj_obj,\n            current = initial_current, obj = initial_obj,\n            thread = \\<lambda>_. \\<lparr>ev_counter = 0\\<rparr>\\<rparr>\n         p1 p2 m \\<longrightarrow>\n        Policy.sp_spec_subj_obj p1 p2 m)", "by auto"], ["proof (state)\nthis:\n  sp_subset s0\n\ngoal (1 subgoal):\n 1. atomic_step_invariant s0", "thus ?thesis"], ["proof (prove)\nusing this:\n  sp_subset s0\n\ngoal (1 subgoal):\n 1. atomic_step_invariant s0", "unfolding atomic_step_invariant_def"], ["proof (prove)\nusing this:\n  sp_subset s0\n\ngoal (1 subgoal):\n 1. sp_subset s0", "by auto"], ["proof (state)\nthis:\n  atomic_step_invariant s0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Types for instantiation of the generic model\\<close>"], ["", "text \\<open>To simplify formulations, we include the state invariant\n @{term \"atomic_step_invariant\"} in the state data type. The \n initial state @{term s0} serves at witness that @{term rstate_t} \n is non-empty.\\<close>"], ["", "typedef (overloaded) rstate_t = \"{ s . atomic_step_invariant s }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {s. atomic_step_invariant s}", "using initial_invariant"], ["proof (prove)\nusing this:\n  atomic_step_invariant s0\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {s. atomic_step_invariant s}", "by auto"], ["", "definition abs :: \"state_t \\<Rightarrow> rstate_t\" (\"\\<up> _\") where \"abs = Abs_rstate_t\""], ["", "definition rep :: \"rstate_t \\<Rightarrow> state_t\" (\"\\<down> _\") where \"rep = Rep_rstate_t\""], ["", "lemma rstate_invariant:\n  shows \"atomic_step_invariant (\\<down>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant \\<down> s", "unfolding rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant (Rep_rstate_t s)", "by (metis Rep_rstate_t mem_Collect_eq)"], ["", "lemma rstate_down_up[simp]:\n  shows \"(\\<up>\\<down>s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> \\<down> s = s", "unfolding rep_def abs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_rstate_t (Rep_rstate_t s) = s", "using Rep_rstate_t_inverse"], ["proof (prove)\nusing this:\n  Abs_rstate_t (Rep_rstate_t ?x) = ?x\n\ngoal (1 subgoal):\n 1. Abs_rstate_t (Rep_rstate_t s) = s", "by auto"], ["", "lemma rstate_up_down[simp]:\n  assumes \"atomic_step_invariant s\"\n  shows \"(\\<down>\\<up>s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<down> \\<up> s = s", "using assms Abs_rstate_t_inverse"], ["proof (prove)\nusing this:\n  atomic_step_invariant s\n  ?y \\<in> {s. atomic_step_invariant s} \\<Longrightarrow>\n  Rep_rstate_t (Abs_rstate_t ?y) = ?y\n\ngoal (1 subgoal):\n 1. \\<down> \\<up> s = s", "unfolding rep_def abs_def"], ["proof (prove)\nusing this:\n  atomic_step_invariant s\n  ?y \\<in> {s. atomic_step_invariant s} \\<Longrightarrow>\n  Rep_rstate_t (Abs_rstate_t ?y) = ?y\n\ngoal (1 subgoal):\n 1. Rep_rstate_t (Abs_rstate_t s) = s", "by auto"], ["", "text \\<open>A CISK action is identified with an interrupt point.\\<close>"], ["", "type_synonym raction_t = int_point_t"], ["", "definition rcurrent :: \"rstate_t \\<Rightarrow> thread_id_t\" where\n  \"rcurrent s = current \\<down>s\""], ["", "definition rstep :: \"rstate_t \\<Rightarrow> raction_t \\<Rightarrow> rstate_t\" where\n  \"rstep s a \\<equiv> \\<up>(atomic_step (\\<down>s) a)\""], ["", "text \\<open>Each CISK domain is identified with a thread id.\\<close>"], ["", "type_synonym rdom_t = \"thread_id_t\""], ["", "text \\<open>The output function returns the contents of all memory accessible\n  to the subject. The action argument of the output function is ignored.\\<close>"], ["", "datatype visible_obj_t = VALUE obj_t | EXCEPTION"], ["", "type_synonym routput_t = \"page_t \\<Rightarrow> visible_obj_t\""], ["", "definition routput_f :: \"rstate_t \\<Rightarrow> raction_t \\<Rightarrow> routput_t\" where\n  \"routput_f s a p \\<equiv>\n    if sp_impl_subj_obj (\\<down>s) (partition (rcurrent s)) (PAGE p) READ then\n      VALUE (obj (\\<down>s) (PAGE p))\n    else\n      EXCEPTION\""], ["", "text \\<open>The precondition for the generic model. Note that @{term atomic_step_invariant}\n  is already part of the state.\\<close>"], ["", "definition rprecondition :: \"rstate_t \\<Rightarrow> rdom_t \\<Rightarrow> raction_t \\<Rightarrow> bool\" where\n  \"rprecondition s d a \\<equiv> atomic_step_precondition (\\<down>s) d a\""], ["", "abbreviation rinvariant\nwhere \"rinvariant s \\<equiv> True\" \\<comment> \\<open>The invariant is already in the state type.\\<close>"], ["", "text \\<open>Translate view-partitioning and interaction-allowed relations.\\<close>"], ["", "definition rvpeq :: \"rdom_t \\<Rightarrow> rstate_t \\<Rightarrow> rstate_t \\<Rightarrow> bool\" where\n  \"rvpeq u s1 s2 \\<equiv> vpeq (partition u) (\\<down>s1) (\\<down>s2)\""], ["", "definition rifp :: \"rdom_t \\<Rightarrow> rdom_t \\<Rightarrow> bool\" where\n  \"rifp u v = Policy.ifp (partition u) (partition v)\""], ["", "text \\<open>Context Switches\\<close>"], ["", "definition rcswitch :: \"nat \\<Rightarrow> rstate_t \\<Rightarrow> rstate_t\" where\n  \"rcswitch n s \\<equiv> \\<up>((\\<down>s) \\<lparr> current := (SOME t . True) \\<rparr>)\""], ["", "subsubsection  \\<open>Possible action sequences\\<close>"], ["", "text \\<open>\nAn @{term SK_IPC} consists of three atomic actions @{term PREP}, @{term WAIT} and @{term BUF} with the same parameters. \n\\<close>"], ["", "definition is_SK_IPC :: \"raction_t list \\<Rightarrow> bool\"\nwhere \"is_SK_IPC aseq \\<equiv> \\<exists> dir partner page .\n                    aseq = [SK_IPC dir PREP partner page,SK_IPC dir WAIT partner page,SK_IPC dir (BUF (SOME page' . True)) partner page]\""], ["", "text \\<open>\nAn @{term SK_EV_WAIT} consists of three atomic actions, one for each of the stages @{term EV_PREP}, @{term EV_WAIT} and @{term EV_FINISH} \nwith the same parameters. \n\\<close>"], ["", "definition is_SK_EV_WAIT :: \"raction_t list \\<Rightarrow> bool\"\nwhere \"is_SK_EV_WAIT aseq \\<equiv> \\<exists> consume .\n                     aseq = [SK_EV_WAIT EV_PREP consume , \n                             SK_EV_WAIT EV_WAIT consume , \n                             SK_EV_WAIT EV_FINISH consume ]\""], ["", "text \\<open>\nAn @{term SK_EV_SIGNAL} consists of two atomic actions, one for each of the stages @{term EV_SIGNAL_PREP} and \n@{term EV_SIGNAL_FINISH} with the same parameters. \n\\<close>"], ["", "definition is_SK_EV_SIGNAL :: \"raction_t list \\<Rightarrow> bool\"\nwhere \"is_SK_EV_SIGNAL aseq \\<equiv> \\<exists> partner .\n                     aseq = [SK_EV_SIGNAL EV_SIGNAL_PREP partner, \n                             SK_EV_SIGNAL EV_SIGNAL_FINISH partner]\""], ["", "text \\<open>\n  The complete attack surface consists of IPC calls, events, and noops.\n\\<close>"], ["", "definition rAS_set :: \"raction_t list set\"\n  where \"rAS_set \\<equiv> { aseq . is_SK_IPC aseq \\<or> is_SK_EV_WAIT aseq \\<or> is_SK_EV_SIGNAL aseq } \\<union> {[]}\""], ["", "subsubsection \\<open>Control\\<close>"], ["", "text \\<open>\n  When are actions aborting, and when are actions waiting.\n  We do not currently use the @{term set_error_code} function yet.\n\\<close>"], ["", "abbreviation raborting\n  where \"raborting s \\<equiv> aborting (\\<down>s)\""], ["", "abbreviation rwaiting\n  where \"rwaiting s \\<equiv> waiting (\\<down>s)\""], ["", "definition rset_error_code :: \"rstate_t \\<Rightarrow> raction_t \\<Rightarrow> rstate_t\"\n  where \"rset_error_code s a \\<equiv> s\""], ["", "text \\<open>\n  Returns the set of threads that are involved in a certain action.\n  For example, for an IPC call, the @{term WAIT} stage synchronizes with the partner.\n  This partner is involved in that action.\n\\<close>"], ["", "definition rkinvolved :: \"int_point_t \\<Rightarrow> rdom_t set\"\n  where \"rkinvolved a \\<equiv> \n  case a of SK_IPC dir WAIT partner page \\<Rightarrow> {partner}\n   | SK_EV_SIGNAL EV_SIGNAL_FINISH partner => {partner}\n   | _ \\<Rightarrow> {}\""], ["", "abbreviation rinvolved :: \"int_point_t option \\<Rightarrow> rdom_t set\"\n  where \"rinvolved \\<equiv> Kernel.involved rkinvolved\""], ["", "subsubsection \\<open>Discharging the proof obligations\\label{sect:discharging}\\<close>"], ["", "lemma inst_vpeq_rel:\n  shows rvpeq_refl: \"rvpeq u s s\"\n    and rvpeq_sym: \"rvpeq u s1 s2 \\<Longrightarrow> rvpeq u s2 s1\"\n    and rvpeq_trans: \"\\<lbrakk> rvpeq u s1 s2; rvpeq u s2 s3 \\<rbrakk> \\<Longrightarrow> rvpeq u s1 s3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rvpeq u s s &&&\n    (rvpeq u s1 s2 \\<Longrightarrow> rvpeq u s2 s1) &&&\n    (\\<lbrakk>rvpeq u s1 s2; rvpeq u s2 s3\\<rbrakk>\n     \\<Longrightarrow> rvpeq u s1 s3)", "unfolding rvpeq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq (Step.partition u) \\<down> s \\<down> s &&&\n    (vpeq (Step.partition u) \\<down> s1 \\<down> s2 \\<Longrightarrow>\n     vpeq (Step.partition u) \\<down> s2 \\<down> s1) &&&\n    (\\<lbrakk>vpeq (Step.partition u) \\<down> s1 \\<down> s2;\n      vpeq (Step.partition u) \\<down> s2 \\<down> s3\\<rbrakk>\n     \\<Longrightarrow> vpeq (Step.partition u) \\<down> s1 \\<down> s3)", "using vpeq_rel"], ["proof (prove)\nusing this:\n  vpeq ?u ?s ?s\n  vpeq ?u ?s ?t \\<Longrightarrow> vpeq ?u ?t ?s\n  \\<lbrakk>vpeq ?u ?s1.0 ?s2.0; vpeq ?u ?s2.0 ?s3.0\\<rbrakk>\n  \\<Longrightarrow> vpeq ?u ?s1.0 ?s3.0\n\ngoal (1 subgoal):\n 1. vpeq (Step.partition u) \\<down> s \\<down> s &&&\n    (vpeq (Step.partition u) \\<down> s1 \\<down> s2 \\<Longrightarrow>\n     vpeq (Step.partition u) \\<down> s2 \\<down> s1) &&&\n    (\\<lbrakk>vpeq (Step.partition u) \\<down> s1 \\<down> s2;\n      vpeq (Step.partition u) \\<down> s2 \\<down> s3\\<rbrakk>\n     \\<Longrightarrow> vpeq (Step.partition u) \\<down> s1 \\<down> s3)", "by metis+"], ["", "lemma inst_ifp_refl:\n  shows \"\\<forall> u . rifp u u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u. rifp u u", "unfolding rifp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u. Policy.ifp (Step.partition u) (Step.partition u)", "using Policy_properties.ifp_reflexive"], ["proof (prove)\nusing this:\n  \\<forall>p. Policy.ifp p p\n\ngoal (1 subgoal):\n 1. \\<forall>u. Policy.ifp (Step.partition u) (Step.partition u)", "by fast"], ["", "(* Original definition \n  definition step_atomicity::bool where \"step_atomicity \n  \\<equiv> \\<forall> s a . current (step s a) = current s\"    \n*)"], ["", "lemma inst_step_atomicity [simp]:\n  shows \"\\<forall> s a . rcurrent (rstep s a) = rcurrent s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s a. rcurrent (rstep s a) = rcurrent s", "unfolding rstep_def rcurrent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       current \\<down> \\<up> atomic_step \\<down> s a = current \\<down> s", "using atomic_step_does_not_change_current_thread rstate_up_down rstate_invariant atomic_step_preserves_invariants"], ["proof (prove)\nusing this:\n  current (atomic_step ?s ?ipt) = current ?s\n  atomic_step_invariant ?s \\<Longrightarrow> \\<down> \\<up> ?s = ?s\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (atomic_step ?s ?a)\n\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       current \\<down> \\<up> atomic_step \\<down> s a = current \\<down> s", "by auto"], ["", "(* Original definition \ndefinition weakly_step_consistent::bool where \"weakly_step_consistent \n  \\<equiv> \\<forall> s t u a. \n    vpeq u s t \\<and> vpeq (current s) s t \n  \\<and> current s = current t \n  \\<and> precondition s a \\<and> precondition t a \n  \\<longrightarrow> \n  vpeq u (step s a) (step t a)\"\n*)"], ["", "lemma inst_weakly_step_consistent:\n  assumes \"rvpeq u s t\"\n      and \"rvpeq (rcurrent s) s t\"\n      and \"rcurrent s = rcurrent t\"\n      and \"rprecondition s (rcurrent s) a\"\n      and \"rprecondition t (rcurrent t) a\"\n    shows \"rvpeq u (rstep s a) (rstep t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rvpeq u (rstep s a) (rstep t a)", "using assms atomic_step_weakly_step_consistent rstate_invariant atomic_step_preserves_invariants"], ["proof (prove)\nusing this:\n  rvpeq u s t\n  rvpeq (rcurrent s) s t\n  rcurrent s = rcurrent t\n  rprecondition s (rcurrent s) a\n  rprecondition t (rcurrent t) a\n  \\<lbrakk>vpeq ?u ?s1.0 ?s2.0;\n   vpeq (Step.partition (current ?s1.0)) ?s1.0 ?s2.0;\n   atomic_step_invariant ?s1.0; atomic_step_invariant ?s2.0;\n   atomic_step_precondition ?s1.0 (current ?s1.0) ?ipt;\n   atomic_step_precondition ?s2.0 (current ?s2.0) ?ipt;\n   current ?s1.0 = current ?s2.0\\<rbrakk>\n  \\<Longrightarrow> vpeq ?u (atomic_step ?s1.0 ?ipt)\n                     (atomic_step ?s2.0 ?ipt)\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (atomic_step ?s ?a)\n\ngoal (1 subgoal):\n 1. rvpeq u (rstep s a) (rstep t a)", "unfolding rcurrent_def rstep_def rvpeq_def rprecondition_def"], ["proof (prove)\nusing this:\n  vpeq (Step.partition u) \\<down> s \\<down> t\n  vpeq (Step.partition (current \\<down> s)) \\<down> s \\<down> t\n  current \\<down> s = current \\<down> t\n  atomic_step_precondition \\<down> s (current \\<down> s) a\n  atomic_step_precondition \\<down> t (current \\<down> t) a\n  \\<lbrakk>vpeq ?u ?s1.0 ?s2.0;\n   vpeq (Step.partition (current ?s1.0)) ?s1.0 ?s2.0;\n   atomic_step_invariant ?s1.0; atomic_step_invariant ?s2.0;\n   atomic_step_precondition ?s1.0 (current ?s1.0) ?ipt;\n   atomic_step_precondition ?s2.0 (current ?s2.0) ?ipt;\n   current ?s1.0 = current ?s2.0\\<rbrakk>\n  \\<Longrightarrow> vpeq ?u (atomic_step ?s1.0 ?ipt)\n                     (atomic_step ?s2.0 ?ipt)\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (atomic_step ?s ?a)\n\ngoal (1 subgoal):\n 1. vpeq (Step.partition u) \\<down> \\<up> atomic_step \\<down> s a\n     \\<down> \\<up> atomic_step \\<down> t a", "by auto"], ["", "(* Original definition \n\ndefinition locally_respects::bool where \"locally_respects \n  \\<equiv> \\<forall> a s u. \n    \\<not>ifp (current s) u  \n  \\<and> precondition s a \n  \\<longrightarrow> \n  vpeq u s (step s a)\"\n*)"], ["", "lemma inst_local_respect:\n  assumes not_ifp: \"\\<not>rifp (rcurrent s) u\"\n      and prec: \"rprecondition s (rcurrent s) a\"\n    shows \"rvpeq u s (rstep s a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rvpeq u s (rstep s a)", "using assms atomic_step_respects_policy rstate_invariant atomic_step_preserves_invariants"], ["proof (prove)\nusing this:\n  \\<not> rifp (rcurrent s) u\n  rprecondition s (rcurrent s) a\n  \\<lbrakk>\\<not> Policy.ifp (Step.partition (current ?s)) ?u;\n   atomic_step_invariant ?s;\n   atomic_step_precondition ?s (current ?s) ?ipt\\<rbrakk>\n  \\<Longrightarrow> vpeq ?u ?s (atomic_step ?s ?ipt)\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (atomic_step ?s ?a)\n\ngoal (1 subgoal):\n 1. rvpeq u s (rstep s a)", "unfolding rifp_def rprecondition_def rvpeq_def rstep_def rcurrent_def"], ["proof (prove)\nusing this:\n  \\<not> Policy.ifp (Step.partition (current \\<down> s)) (Step.partition u)\n  atomic_step_precondition \\<down> s (current \\<down> s) a\n  \\<lbrakk>\\<not> Policy.ifp (Step.partition (current ?s)) ?u;\n   atomic_step_invariant ?s;\n   atomic_step_precondition ?s (current ?s) ?ipt\\<rbrakk>\n  \\<Longrightarrow> vpeq ?u ?s (atomic_step ?s ?ipt)\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (atomic_step ?s ?a)\n\ngoal (1 subgoal):\n 1. vpeq (Step.partition u) \\<down> s \\<down> \\<up> atomic_step \\<down> s a", "by auto"], ["", "(*\n\ndefinition output_consistent::bool where \"output_consistent \n  \\<equiv> \\<forall> a s t. \n   vpeq (current s) s t \n \\<and> current s = current t \n \\<longrightarrow> \n (output_f s a) = (output_f t a)\"\n*)"], ["", "lemma inst_output_consistency:\n  assumes rvpeq: \"rvpeq (rcurrent s) s t\"\n  and     current_eq: \"rcurrent s = rcurrent t\"\n  shows   \"routput_f s a = routput_f t a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. routput_f s a = routput_f t a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. routput_f s a = routput_f t a", "have \"\\<forall> a s t. rvpeq (rcurrent s) s t \\<and> rcurrent s = rcurrent t \\<longrightarrow> routput_f s a = routput_f t a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a s t.\n       rvpeq (rcurrent s) s t \\<and>\n       rcurrent s = rcurrent t \\<longrightarrow>\n       routput_f s a = routput_f t a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a s t.\n       rvpeq (rcurrent s) s t \\<and>\n       rcurrent s = rcurrent t \\<longrightarrow>\n       routput_f s a = routput_f t a", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a s t.\n       rvpeq (rcurrent s) s t \\<and>\n       rcurrent s = rcurrent t \\<longrightarrow>\n       routput_f s a = routput_f t a", "fix a :: raction_t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a s t.\n       rvpeq (rcurrent s) s t \\<and>\n       rcurrent s = rcurrent t \\<longrightarrow>\n       routput_f s a = routput_f t a", "fix s t :: rstate_t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a s t.\n       rvpeq (rcurrent s) s t \\<and>\n       rcurrent s = rcurrent t \\<longrightarrow>\n       routput_f s a = routput_f t a", "fix p :: page_t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a s t.\n       rvpeq (rcurrent s) s t \\<and>\n       rcurrent s = rcurrent t \\<longrightarrow>\n       routput_f s a = routput_f t a", "assume 1: \"rvpeq (rcurrent s) s t\"\n           and 2: \"rcurrent s = rcurrent t\""], ["proof (state)\nthis:\n  rvpeq (rcurrent s) s t\n  rcurrent s = rcurrent t\n\ngoal (1 subgoal):\n 1. \\<forall>a s t.\n       rvpeq (rcurrent s) s t \\<and>\n       rcurrent s = rcurrent t \\<longrightarrow>\n       routput_f s a = routput_f t a", "let ?part = \"partition (rcurrent s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a s t.\n       rvpeq (rcurrent s) s t \\<and>\n       rcurrent s = rcurrent t \\<longrightarrow>\n       routput_f s a = routput_f t a", "have \"routput_f s a p = routput_f t a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. routput_f s a p = routput_f t a p", "proof (cases \"Policy.sp_spec_subj_obj ?part (PAGE p) READ\"\n                 rule: case_split [case_names Allowed Denied])"], ["proof (state)\ngoal (2 subgoals):\n 1. Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p)\n     READ \\<Longrightarrow>\n    routput_f s a p = routput_f t a p\n 2. \\<not> Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p)\n            READ \\<Longrightarrow>\n    routput_f s a p = routput_f t a p", "case Allowed"], ["proof (state)\nthis:\n  Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p) READ\n\ngoal (2 subgoals):\n 1. Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p)\n     READ \\<Longrightarrow>\n    routput_f s a p = routput_f t a p\n 2. \\<not> Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p)\n            READ \\<Longrightarrow>\n    routput_f s a p = routput_f t a p", "have 5: \"obj (\\<down>s) (PAGE p) = obj (\\<down>t) (PAGE p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obj \\<down> s (PAGE p) = obj \\<down> t (PAGE p)", "using 1 Allowed"], ["proof (prove)\nusing this:\n  rvpeq (rcurrent s) s t\n  Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p) READ\n\ngoal (1 subgoal):\n 1. obj \\<down> s (PAGE p) = obj \\<down> t (PAGE p)", "unfolding rvpeq_def vpeq_def vpeq_obj_def"], ["proof (prove)\nusing this:\n  (\\<forall>obj_id.\n      Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) obj_id\n       READ \\<longrightarrow>\n      obj \\<down> s obj_id = obj \\<down> t obj_id) \\<and>\n  vpeq_subj_subj (Step.partition (rcurrent s)) \\<down> s \\<down> t \\<and>\n  vpeq_subj_obj (Step.partition (rcurrent s)) \\<down> s \\<down> t \\<and>\n  vpeq_local (Step.partition (rcurrent s)) \\<down> s \\<down> t\n  Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p) READ\n\ngoal (1 subgoal):\n 1. obj \\<down> s (PAGE p) = obj \\<down> t (PAGE p)", "by auto"], ["proof (state)\nthis:\n  obj \\<down> s (PAGE p) = obj \\<down> t (PAGE p)\n\ngoal (2 subgoals):\n 1. Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p)\n     READ \\<Longrightarrow>\n    routput_f s a p = routput_f t a p\n 2. \\<not> Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p)\n            READ \\<Longrightarrow>\n    routput_f s a p = routput_f t a p", "have 6: \"sp_impl_subj_obj (\\<down>s) ?part (PAGE p) READ = sp_impl_subj_obj (\\<down>t) ?part (PAGE p) READ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p) READ =\n    sp_impl_subj_obj \\<down> t (Step.partition (rcurrent s)) (PAGE p) READ", "using 1 2 Allowed"], ["proof (prove)\nusing this:\n  rvpeq (rcurrent s) s t\n  rcurrent s = rcurrent t\n  Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p) READ\n\ngoal (1 subgoal):\n 1. sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p) READ =\n    sp_impl_subj_obj \\<down> t (Step.partition (rcurrent s)) (PAGE p) READ", "unfolding rvpeq_def vpeq_def vpeq_subj_obj_def"], ["proof (prove)\nusing this:\n  vpeq_obj (Step.partition (rcurrent s)) \\<down> s \\<down> t \\<and>\n  vpeq_subj_subj (Step.partition (rcurrent s)) \\<down> s \\<down> t \\<and>\n  (\\<forall>ob m p1.\n      (Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) ob\n        m \\<longrightarrow>\n       sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) ob m =\n       sp_impl_subj_obj \\<down> t (Step.partition (rcurrent s)) ob m) \\<and>\n      (Policy.sp_spec_subj_obj p1 ob PROVIDE \\<and>\n       (Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) ob READ \\<or>\n        Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) ob\n         WRITE) \\<longrightarrow>\n       sp_impl_subj_obj \\<down> s p1 ob PROVIDE =\n       sp_impl_subj_obj \\<down> t p1 ob PROVIDE)) \\<and>\n  vpeq_local (Step.partition (rcurrent s)) \\<down> s \\<down> t\n  rcurrent s = rcurrent t\n  Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p) READ\n\ngoal (1 subgoal):\n 1. sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p) READ =\n    sp_impl_subj_obj \\<down> t (Step.partition (rcurrent s)) (PAGE p) READ", "by auto"], ["proof (state)\nthis:\n  sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p) READ =\n  sp_impl_subj_obj \\<down> t (Step.partition (rcurrent s)) (PAGE p) READ\n\ngoal (2 subgoals):\n 1. Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p)\n     READ \\<Longrightarrow>\n    routput_f s a p = routput_f t a p\n 2. \\<not> Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p)\n            READ \\<Longrightarrow>\n    routput_f s a p = routput_f t a p", "show \"routput_f s a p = routput_f t a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. routput_f s a p = routput_f t a p", "unfolding routput_f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p)\n         READ\n     then VALUE (obj \\<down> s (PAGE p)) else EXCEPTION) =\n    (if sp_impl_subj_obj \\<down> t (Step.partition (rcurrent t)) (PAGE p)\n         READ\n     then VALUE (obj \\<down> t (PAGE p)) else EXCEPTION)", "using 2 5 6"], ["proof (prove)\nusing this:\n  rcurrent s = rcurrent t\n  obj \\<down> s (PAGE p) = obj \\<down> t (PAGE p)\n  sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p) READ =\n  sp_impl_subj_obj \\<down> t (Step.partition (rcurrent s)) (PAGE p) READ\n\ngoal (1 subgoal):\n 1. (if sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p)\n         READ\n     then VALUE (obj \\<down> s (PAGE p)) else EXCEPTION) =\n    (if sp_impl_subj_obj \\<down> t (Step.partition (rcurrent t)) (PAGE p)\n         READ\n     then VALUE (obj \\<down> t (PAGE p)) else EXCEPTION)", "by auto"], ["proof (state)\nthis:\n  routput_f s a p = routput_f t a p\n\ngoal (1 subgoal):\n 1. \\<not> Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p)\n            READ \\<Longrightarrow>\n    routput_f s a p = routput_f t a p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p)\n            READ \\<Longrightarrow>\n    routput_f s a p = routput_f t a p", "case Denied"], ["proof (state)\nthis:\n  \\<not> Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p) READ\n\ngoal (1 subgoal):\n 1. \\<not> Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p)\n            READ \\<Longrightarrow>\n    routput_f s a p = routput_f t a p", "hence \"sp_impl_subj_obj (\\<down>s) ?part (PAGE p) READ = False\"\n                and \"sp_impl_subj_obj (\\<down>t) ?part (PAGE p) READ = False\""], ["proof (prove)\nusing this:\n  \\<not> Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p) READ\n\ngoal (1 subgoal):\n 1. sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p) READ =\n    False &&&\n    sp_impl_subj_obj \\<down> t (Step.partition (rcurrent s)) (PAGE p) READ =\n    False", "using rstate_invariant"], ["proof (prove)\nusing this:\n  \\<not> Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p) READ\n  atomic_step_invariant \\<down> ?s\n\ngoal (1 subgoal):\n 1. sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p) READ =\n    False &&&\n    sp_impl_subj_obj \\<down> t (Step.partition (rcurrent s)) (PAGE p) READ =\n    False", "unfolding atomic_step_invariant_def sp_subset_def"], ["proof (prove)\nusing this:\n  \\<not> Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p) READ\n  (\\<forall>p1 p2.\n      sp_impl_subj_subj \\<down> ?s p1 p2 \\<longrightarrow>\n      Policy.sp_spec_subj_subj p1 p2) \\<and>\n  (\\<forall>p1 p2 m.\n      sp_impl_subj_obj \\<down> ?s p1 p2 m \\<longrightarrow>\n      Policy.sp_spec_subj_obj p1 p2 m)\n\ngoal (1 subgoal):\n 1. sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p) READ =\n    False &&&\n    sp_impl_subj_obj \\<down> t (Step.partition (rcurrent s)) (PAGE p) READ =\n    False", "by auto"], ["proof (state)\nthis:\n  sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p) READ =\n  False\n  sp_impl_subj_obj \\<down> t (Step.partition (rcurrent s)) (PAGE p) READ =\n  False\n\ngoal (1 subgoal):\n 1. \\<not> Policy.sp_spec_subj_obj (Step.partition (rcurrent s)) (PAGE p)\n            READ \\<Longrightarrow>\n    routput_f s a p = routput_f t a p", "thus \"routput_f s a p = routput_f t a p\""], ["proof (prove)\nusing this:\n  sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p) READ =\n  False\n  sp_impl_subj_obj \\<down> t (Step.partition (rcurrent s)) (PAGE p) READ =\n  False\n\ngoal (1 subgoal):\n 1. routput_f s a p = routput_f t a p", "using 2"], ["proof (prove)\nusing this:\n  sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p) READ =\n  False\n  sp_impl_subj_obj \\<down> t (Step.partition (rcurrent s)) (PAGE p) READ =\n  False\n  rcurrent s = rcurrent t\n\ngoal (1 subgoal):\n 1. routput_f s a p = routput_f t a p", "unfolding routput_f_def"], ["proof (prove)\nusing this:\n  sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p) READ =\n  False\n  sp_impl_subj_obj \\<down> t (Step.partition (rcurrent s)) (PAGE p) READ =\n  False\n  rcurrent s = rcurrent t\n\ngoal (1 subgoal):\n 1. (if sp_impl_subj_obj \\<down> s (Step.partition (rcurrent s)) (PAGE p)\n         READ\n     then VALUE (obj \\<down> s (PAGE p)) else EXCEPTION) =\n    (if sp_impl_subj_obj \\<down> t (Step.partition (rcurrent t)) (PAGE p)\n         READ\n     then VALUE (obj \\<down> t (PAGE p)) else EXCEPTION)", "by simp"], ["proof (state)\nthis:\n  routput_f s a p = routput_f t a p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  routput_f s a p = routput_f t a p\n\ngoal (1 subgoal):\n 1. \\<forall>a s t.\n       rvpeq (rcurrent s) s t \\<and>\n       rcurrent s = rcurrent t \\<longrightarrow>\n       routput_f s a = routput_f t a", "}"], ["proof (state)\nthis:\n  \\<lbrakk>rvpeq (rcurrent ?sa2) ?sa2 ?ta2;\n   rcurrent ?sa2 = rcurrent ?ta2\\<rbrakk>\n  \\<Longrightarrow> routput_f ?sa2 ?aa2 ?p2 = routput_f ?ta2 ?aa2 ?p2\n\ngoal (1 subgoal):\n 1. \\<forall>a s t.\n       rvpeq (rcurrent s) s t \\<and>\n       rcurrent s = rcurrent t \\<longrightarrow>\n       routput_f s a = routput_f t a", "thus \"\\<forall> a s t. rvpeq (rcurrent s) s t \\<and> rcurrent s = rcurrent t \\<longrightarrow> routput_f s a = routput_f t a\""], ["proof (prove)\nusing this:\n  \\<lbrakk>rvpeq (rcurrent ?sa2) ?sa2 ?ta2;\n   rcurrent ?sa2 = rcurrent ?ta2\\<rbrakk>\n  \\<Longrightarrow> routput_f ?sa2 ?aa2 ?p2 = routput_f ?ta2 ?aa2 ?p2\n\ngoal (1 subgoal):\n 1. \\<forall>a s t.\n       rvpeq (rcurrent s) s t \\<and>\n       rcurrent s = rcurrent t \\<longrightarrow>\n       routput_f s a = routput_f t a", "by auto"], ["proof (state)\nthis:\n  \\<forall>a s t.\n     rvpeq (rcurrent s) s t \\<and> rcurrent s = rcurrent t \\<longrightarrow>\n     routput_f s a = routput_f t a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a s t.\n     rvpeq (rcurrent s) s t \\<and> rcurrent s = rcurrent t \\<longrightarrow>\n     routput_f s a = routput_f t a\n\ngoal (1 subgoal):\n 1. routput_f s a = routput_f t a", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>a s t.\n     rvpeq (rcurrent s) s t \\<and> rcurrent s = rcurrent t \\<longrightarrow>\n     routput_f s a = routput_f t a\n\ngoal (1 subgoal):\n 1. routput_f s a = routput_f t a", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>a s t.\n     rvpeq (rcurrent s) s t \\<and> rcurrent s = rcurrent t \\<longrightarrow>\n     routput_f s a = routput_f t a\n  rvpeq (rcurrent s) s t\n  rcurrent s = rcurrent t\n\ngoal (1 subgoal):\n 1. routput_f s a = routput_f t a", "by auto"], ["proof (state)\nthis:\n  routput_f s a = routput_f t a\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\ndefinition cswitch_independent_of_state::bool where \"cswitch_independent_of_state\n  \\<equiv> \\<forall> n s t . current s = current t \\<longrightarrow> current (cswitch n s) = current (cswitch n t)\"\n*)"], ["", "lemma inst_cswitch_independent_of_state:\n  assumes \"rcurrent s = rcurrent t\"\n  shows \"rcurrent (rcswitch n s) = rcurrent (rcswitch n t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rcurrent (rcswitch n s) = rcurrent (rcswitch n t)", "using rstate_invariant cswitch_preserves_invariants"], ["proof (prove)\nusing this:\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (?s\\<lparr>current := ?new_current\\<rparr>)\n\ngoal (1 subgoal):\n 1. rcurrent (rcswitch n s) = rcurrent (rcswitch n t)", "unfolding rcurrent_def rcswitch_def"], ["proof (prove)\nusing this:\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (?s\\<lparr>current := ?new_current\\<rparr>)\n\ngoal (1 subgoal):\n 1. current \\<down> \\<up> \\<down> s\n     \\<lparr>current := Eps rinvariant\\<rparr> =\n    current \\<down> \\<up> \\<down> t\\<lparr>current := Eps rinvariant\\<rparr>", "by simp"], ["", "(*\ndefinition cswitch_consistency::bool where \"cswitch_consistency\n  \\<equiv> \\<forall> u s t n . vpeq u s t \\<longrightarrow> vpeq u (cswitch n s) (cswitch n t)\"\n  *)"], ["", "lemma inst_cswitch_consistency:\n  assumes \"rvpeq u s t\"\n  shows \"rvpeq u (rcswitch n s) (rcswitch n t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rvpeq u (rcswitch n s) (rcswitch n t)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. rvpeq u (rcswitch n s) (rcswitch n t)", "have 1: \"vpeq (partition u) (\\<down>s) \\<down>(rcswitch n s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq (Step.partition u) \\<down> s \\<down> rcswitch n s", "using rstate_invariant cswitch_consistency_and_respect cswitch_preserves_invariants"], ["proof (prove)\nusing this:\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  vpeq ?u ?s (?s\\<lparr>current := ?new_current\\<rparr>)\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (?s\\<lparr>current := ?new_current\\<rparr>)\n\ngoal (1 subgoal):\n 1. vpeq (Step.partition u) \\<down> s \\<down> rcswitch n s", "unfolding rcswitch_def"], ["proof (prove)\nusing this:\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  vpeq ?u ?s (?s\\<lparr>current := ?new_current\\<rparr>)\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (?s\\<lparr>current := ?new_current\\<rparr>)\n\ngoal (1 subgoal):\n 1. vpeq (Step.partition u) \\<down> s \\<down> \\<up> \\<down> s\n     \\<lparr>current := Eps rinvariant\\<rparr>", "by auto"], ["proof (state)\nthis:\n  vpeq (Step.partition u) \\<down> s \\<down> rcswitch n s\n\ngoal (1 subgoal):\n 1. rvpeq u (rcswitch n s) (rcswitch n t)", "have 2: \"vpeq (partition u) (\\<down>t) \\<down>(rcswitch n t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq (Step.partition u) \\<down> t \\<down> rcswitch n t", "using rstate_invariant cswitch_consistency_and_respect cswitch_preserves_invariants"], ["proof (prove)\nusing this:\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  vpeq ?u ?s (?s\\<lparr>current := ?new_current\\<rparr>)\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (?s\\<lparr>current := ?new_current\\<rparr>)\n\ngoal (1 subgoal):\n 1. vpeq (Step.partition u) \\<down> t \\<down> rcswitch n t", "unfolding rcswitch_def"], ["proof (prove)\nusing this:\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  vpeq ?u ?s (?s\\<lparr>current := ?new_current\\<rparr>)\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (?s\\<lparr>current := ?new_current\\<rparr>)\n\ngoal (1 subgoal):\n 1. vpeq (Step.partition u) \\<down> t \\<down> \\<up> \\<down> t\n     \\<lparr>current := Eps rinvariant\\<rparr>", "by auto"], ["proof (state)\nthis:\n  vpeq (Step.partition u) \\<down> t \\<down> rcswitch n t\n\ngoal (1 subgoal):\n 1. rvpeq u (rcswitch n s) (rcswitch n t)", "from 1 2 assms"], ["proof (chain)\npicking this:\n  vpeq (Step.partition u) \\<down> s \\<down> rcswitch n s\n  vpeq (Step.partition u) \\<down> t \\<down> rcswitch n t\n  rvpeq u s t", "show ?thesis"], ["proof (prove)\nusing this:\n  vpeq (Step.partition u) \\<down> s \\<down> rcswitch n s\n  vpeq (Step.partition u) \\<down> t \\<down> rcswitch n t\n  rvpeq u s t\n\ngoal (1 subgoal):\n 1. rvpeq u (rcswitch n s) (rcswitch n t)", "unfolding rvpeq_def"], ["proof (prove)\nusing this:\n  vpeq (Step.partition u) \\<down> s \\<down> rcswitch n s\n  vpeq (Step.partition u) \\<down> t \\<down> rcswitch n t\n  vpeq (Step.partition u) \\<down> s \\<down> t\n\ngoal (1 subgoal):\n 1. vpeq (Step.partition u) \\<down> rcswitch n s \\<down> rcswitch n t", "using vpeq_rel"], ["proof (prove)\nusing this:\n  vpeq (Step.partition u) \\<down> s \\<down> rcswitch n s\n  vpeq (Step.partition u) \\<down> t \\<down> rcswitch n t\n  vpeq (Step.partition u) \\<down> s \\<down> t\n  vpeq ?u ?s ?s\n  vpeq ?u ?s ?t \\<Longrightarrow> vpeq ?u ?t ?s\n  \\<lbrakk>vpeq ?u ?s1.0 ?s2.0; vpeq ?u ?s2.0 ?s3.0\\<rbrakk>\n  \\<Longrightarrow> vpeq ?u ?s1.0 ?s3.0\n\ngoal (1 subgoal):\n 1. vpeq (Step.partition u) \\<down> rcswitch n s \\<down> rcswitch n t", "by metis"], ["proof (state)\nthis:\n  rvpeq u (rcswitch n s) (rcswitch n t)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nFor the @{term PREP} stage (the first stage of the IPC action sequence) the precondition is True.\n\\<close>"], ["", "lemma prec_first_IPC_action:\nassumes \"is_SK_IPC aseq\"\n  shows \"rprecondition s d (hd aseq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rprecondition s d (hd aseq)", "using assms"], ["proof (prove)\nusing this:\n  is_SK_IPC aseq\n\ngoal (1 subgoal):\n 1. rprecondition s d (hd aseq)", "unfolding is_SK_IPC_def rprecondition_def atomic_step_precondition_def"], ["proof (prove)\nusing this:\n  \\<exists>dir partner page.\n     aseq =\n     [SK_IPC dir PREP partner page, SK_IPC dir WAIT partner page,\n      SK_IPC dir (BUF (Eps rinvariant)) partner page]\n\ngoal (1 subgoal):\n 1. case hd aseq of SK_IPC dir PREP partner page \\<Rightarrow> True\n    | SK_IPC dir WAIT partner page \\<Rightarrow>\n        ipc_precondition d dir partner page \\<down> s\n    | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n        ipc_precondition d dir partner page \\<down> s \\<and>\n        ipc_precondition partner (opposite_ipc_direction dir) d page'\n         \\<down> s\n    | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n    | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n    | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n        ev_signal_precondition d partner \\<down> s\n    | NONE \\<Rightarrow> True", "by auto"], ["", "text \\<open>\nFor the the first stage of the @{term EV_WAIT} action sequence the precondition is True.\n\\<close>"], ["", "lemma prec_first_EV_WAIT_action:\nassumes \"is_SK_EV_WAIT aseq\"\n  shows \"rprecondition s d (hd aseq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rprecondition s d (hd aseq)", "using assms"], ["proof (prove)\nusing this:\n  is_SK_EV_WAIT aseq\n\ngoal (1 subgoal):\n 1. rprecondition s d (hd aseq)", "unfolding is_SK_EV_WAIT_def rprecondition_def atomic_step_precondition_def"], ["proof (prove)\nusing this:\n  \\<exists>consume.\n     aseq =\n     [SK_EV_WAIT EV_PREP consume, SK_EV_WAIT EV_WAIT consume,\n      SK_EV_WAIT EV_FINISH consume]\n\ngoal (1 subgoal):\n 1. case hd aseq of SK_IPC dir PREP partner page \\<Rightarrow> True\n    | SK_IPC dir WAIT partner page \\<Rightarrow>\n        ipc_precondition d dir partner page \\<down> s\n    | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n        ipc_precondition d dir partner page \\<down> s \\<and>\n        ipc_precondition partner (opposite_ipc_direction dir) d page'\n         \\<down> s\n    | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n    | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n    | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n        ev_signal_precondition d partner \\<down> s\n    | NONE \\<Rightarrow> True", "by auto"], ["", "text \\<open>\nFor the first stage of the @{term EV_SIGNAL} action sequence the precondition is True.\n\\<close>"], ["", "lemma prec_first_EV_SIGNAL_action:\nassumes \"is_SK_EV_SIGNAL aseq\"\n  shows \"rprecondition s d (hd aseq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rprecondition s d (hd aseq)", "using assms"], ["proof (prove)\nusing this:\n  is_SK_EV_SIGNAL aseq\n\ngoal (1 subgoal):\n 1. rprecondition s d (hd aseq)", "unfolding is_SK_EV_SIGNAL_def rprecondition_def atomic_step_precondition_def\n          ev_signal_precondition_def"], ["proof (prove)\nusing this:\n  \\<exists>partner.\n     aseq =\n     [SK_EV_SIGNAL EV_SIGNAL_PREP partner,\n      SK_EV_SIGNAL EV_SIGNAL_FINISH partner]\n\ngoal (1 subgoal):\n 1. case hd aseq of SK_IPC dir PREP partner page \\<Rightarrow> True\n    | SK_IPC dir WAIT partner page \\<Rightarrow>\n        ipc_precondition d dir partner page \\<down> s\n    | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n        ipc_precondition d dir partner page \\<down> s \\<and>\n        ipc_precondition partner (opposite_ipc_direction dir) d page'\n         \\<down> s\n    | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n    | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n    | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n        sp_impl_subj_subj \\<down> s (Step.partition d)\n         (Step.partition partner)\n    | NONE \\<Rightarrow> True", "by auto"], ["", "text \\<open>\nWhen not waiting or aborting, the precondition is ``1-step inductive'', that is at all times\nthe precondition holds initially (for the first step of an action sequence) and after doing \none step.\n\\<close>"], ["", "lemma prec_after_IPC_step:\nassumes prec: \"rprecondition s (rcurrent s) (aseq ! n)\" \n    and n_bound: \"Suc n < length aseq\"\n    and IPC: \"is_SK_IPC aseq\"\n    and not_aborting: \"\\<not>raborting s (rcurrent s) (aseq ! n)\"\n    and not_waiting: \"\\<not>rwaiting s (rcurrent s) (aseq ! n)\"\nshows \"rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "fix dir partner page"], ["proof (state)\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "let ?page' = \"(SOME page' . True)\""], ["proof (state)\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "assume IPC: \"aseq = [SK_IPC dir PREP partner page,SK_IPC dir WAIT partner page,SK_IPC dir (BUF ?page') partner page]\""], ["proof (state)\nthis:\n  aseq =\n  [SK_IPC dir PREP partner page, SK_IPC dir WAIT partner page,\n   SK_IPC dir (BUF (Eps rinvariant)) partner page]\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "{"], ["proof (state)\nthis:\n  aseq =\n  [SK_IPC dir PREP partner page, SK_IPC dir WAIT partner page,\n   SK_IPC dir (BUF (Eps rinvariant)) partner page]\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "assume 0: \"n=0\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "from 0 IPC prec not_aborting"], ["proof (chain)\npicking this:\n  n = 0\n  aseq =\n  [SK_IPC dir PREP partner page, SK_IPC dir WAIT partner page,\n   SK_IPC dir (BUF (Eps rinvariant)) partner page]\n  rprecondition s (rcurrent s) (aseq ! n)\n  \\<not> raborting s (rcurrent s) (aseq ! n)", "have ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n  aseq =\n  [SK_IPC dir PREP partner page, SK_IPC dir WAIT partner page,\n   SK_IPC dir (BUF (Eps rinvariant)) partner page]\n  rprecondition s (rcurrent s) (aseq ! n)\n  \\<not> raborting s (rcurrent s) (aseq ! n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "unfolding rprecondition_def atomic_step_precondition_def rstep_def rcurrent_def atomic_step_def atomic_step_ipc_def aborting_def"], ["proof (prove)\nusing this:\n  n = 0\n  aseq =\n  [SK_IPC dir PREP partner page, SK_IPC dir WAIT partner page,\n   SK_IPC dir (BUF (Eps rinvariant)) partner page]\n  case aseq ! n of SK_IPC dir PREP partner page \\<Rightarrow> True\n  | SK_IPC dir WAIT partner page \\<Rightarrow>\n      ipc_precondition (current \\<down> s) dir partner page \\<down> s\n  | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n      ipc_precondition (current \\<down> s) dir partner page \\<down> s \\<and>\n      ipc_precondition partner (opposite_ipc_direction dir)\n       (current \\<down> s) page' \\<down> s\n  | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n  | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n  | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n      ev_signal_precondition (current \\<down> s) partner \\<down> s\n  | NONE \\<Rightarrow> True\n  \\<not> (case aseq ! n of\n          SK_IPC dir PREP partner page \\<Rightarrow>\n            \\<not> ipc_precondition (current \\<down> s) dir partner page\n                    \\<down> s\n          | SK_IPC dir _ partner page \\<Rightarrow> False\n          | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n              \\<not> ev_signal_precondition (current \\<down> s) partner\n                      \\<down> s\n          | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> False\n          | _ \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. case aseq ! Suc n of SK_IPC dir PREP partner page \\<Rightarrow> True\n    | SK_IPC dir WAIT partner page \\<Rightarrow>\n        ipc_precondition (current \\<down> s) dir partner page\n         \\<down> \\<up> case aseq ! n of\n                       SK_IPC SEND (BUF page') partner page \\<Rightarrow>\n                         set_object_value (PAGE page')\n                          (obj \\<down> s (PAGE page)) \\<down> s\n                       | SK_IPC RECV (BUF page') partner page \\<Rightarrow>\n                           \\<down> s\n                       | SK_IPC dir _ partner page \\<Rightarrow> \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                           atomic_step_ev_wait_all (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                           atomic_step_ev_wait_one (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n                           \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                           atomic_step_ev_signal (current \\<down> s) partner\n                            \\<down> s\n                       | NONE \\<Rightarrow> \\<down> s\n    | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n        ipc_precondition (current \\<down> s) dir partner page\n         \\<down> \\<up> case aseq ! n of\n                       SK_IPC SEND (BUF page') partner page \\<Rightarrow>\n                         set_object_value (PAGE page')\n                          (obj \\<down> s (PAGE page)) \\<down> s\n                       | SK_IPC RECV (BUF page') partner page \\<Rightarrow>\n                           \\<down> s\n                       | SK_IPC dir _ partner page \\<Rightarrow> \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                           atomic_step_ev_wait_all (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                           atomic_step_ev_wait_one (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n                           \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                           atomic_step_ev_signal (current \\<down> s) partner\n                            \\<down> s\n                       | NONE \\<Rightarrow> \\<down> s \\<and>\n        ipc_precondition partner (opposite_ipc_direction dir)\n         (current \\<down> s) page'\n         \\<down> \\<up> case aseq ! n of\n                       SK_IPC SEND (BUF page') partner page \\<Rightarrow>\n                         set_object_value (PAGE page')\n                          (obj \\<down> s (PAGE page)) \\<down> s\n                       | SK_IPC RECV (BUF page') partner page \\<Rightarrow>\n                           \\<down> s\n                       | SK_IPC dir _ partner page \\<Rightarrow> \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                           atomic_step_ev_wait_all (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                           atomic_step_ev_wait_one (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n                           \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                           atomic_step_ev_signal (current \\<down> s) partner\n                            \\<down> s\n                       | NONE \\<Rightarrow> \\<down> s\n    | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n    | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n    | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n        ev_signal_precondition (current \\<down> s) partner\n         \\<down> \\<up> case aseq ! n of\n                       SK_IPC SEND (BUF page') partner page \\<Rightarrow>\n                         set_object_value (PAGE page')\n                          (obj \\<down> s (PAGE page)) \\<down> s\n                       | SK_IPC RECV (BUF page') partner page \\<Rightarrow>\n                           \\<down> s\n                       | SK_IPC dir _ partner page \\<Rightarrow> \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                           atomic_step_ev_wait_all (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                           atomic_step_ev_wait_one (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n                           \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                           atomic_step_ev_signal (current \\<down> s) partner\n                            \\<down> s\n                       | NONE \\<Rightarrow> \\<down> s\n    | NONE \\<Rightarrow> True", "by(auto)"], ["proof (state)\nthis:\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "}"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "moreover"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "{"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "assume 1: \"n=1\""], ["proof (state)\nthis:\n  n = 1\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "from 1 IPC prec not_waiting"], ["proof (chain)\npicking this:\n  n = 1\n  aseq =\n  [SK_IPC dir PREP partner page, SK_IPC dir WAIT partner page,\n   SK_IPC dir (BUF (Eps rinvariant)) partner page]\n  rprecondition s (rcurrent s) (aseq ! n)\n  \\<not> rwaiting s (rcurrent s) (aseq ! n)", "have ?thesis"], ["proof (prove)\nusing this:\n  n = 1\n  aseq =\n  [SK_IPC dir PREP partner page, SK_IPC dir WAIT partner page,\n   SK_IPC dir (BUF (Eps rinvariant)) partner page]\n  rprecondition s (rcurrent s) (aseq ! n)\n  \\<not> rwaiting s (rcurrent s) (aseq ! n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "unfolding rprecondition_def atomic_step_precondition_def rstep_def rcurrent_def atomic_step_def atomic_step_ipc_def waiting_def"], ["proof (prove)\nusing this:\n  n = 1\n  aseq =\n  [SK_IPC dir PREP partner page, SK_IPC dir WAIT partner page,\n   SK_IPC dir (BUF (Eps rinvariant)) partner page]\n  case aseq ! n of SK_IPC dir PREP partner page \\<Rightarrow> True\n  | SK_IPC dir WAIT partner page \\<Rightarrow>\n      ipc_precondition (current \\<down> s) dir partner page \\<down> s\n  | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n      ipc_precondition (current \\<down> s) dir partner page \\<down> s \\<and>\n      ipc_precondition partner (opposite_ipc_direction dir)\n       (current \\<down> s) page' \\<down> s\n  | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n  | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n  | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n      ev_signal_precondition (current \\<down> s) partner \\<down> s\n  | NONE \\<Rightarrow> True\n  \\<not> (case aseq ! n of\n          SK_IPC dir WAIT partner page \\<Rightarrow>\n            \\<not> ipc_precondition partner (opposite_ipc_direction dir)\n                    (current \\<down> s) (Eps rinvariant) \\<down> s\n          | SK_IPC dir _ partner page \\<Rightarrow> False\n          | SK_EV_WAIT EV_WAIT x \\<Rightarrow>\n              ev_counter (thread \\<down> s (current \\<down> s)) = 0\n          | SK_EV_WAIT _ x \\<Rightarrow> False | _ \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. case aseq ! Suc n of SK_IPC dir PREP partner page \\<Rightarrow> True\n    | SK_IPC dir WAIT partner page \\<Rightarrow>\n        ipc_precondition (current \\<down> s) dir partner page\n         \\<down> \\<up> case aseq ! n of\n                       SK_IPC SEND (BUF page') partner page \\<Rightarrow>\n                         set_object_value (PAGE page')\n                          (obj \\<down> s (PAGE page)) \\<down> s\n                       | SK_IPC RECV (BUF page') partner page \\<Rightarrow>\n                           \\<down> s\n                       | SK_IPC dir _ partner page \\<Rightarrow> \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                           atomic_step_ev_wait_all (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                           atomic_step_ev_wait_one (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n                           \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                           atomic_step_ev_signal (current \\<down> s) partner\n                            \\<down> s\n                       | NONE \\<Rightarrow> \\<down> s\n    | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n        ipc_precondition (current \\<down> s) dir partner page\n         \\<down> \\<up> case aseq ! n of\n                       SK_IPC SEND (BUF page') partner page \\<Rightarrow>\n                         set_object_value (PAGE page')\n                          (obj \\<down> s (PAGE page)) \\<down> s\n                       | SK_IPC RECV (BUF page') partner page \\<Rightarrow>\n                           \\<down> s\n                       | SK_IPC dir _ partner page \\<Rightarrow> \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                           atomic_step_ev_wait_all (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                           atomic_step_ev_wait_one (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n                           \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                           atomic_step_ev_signal (current \\<down> s) partner\n                            \\<down> s\n                       | NONE \\<Rightarrow> \\<down> s \\<and>\n        ipc_precondition partner (opposite_ipc_direction dir)\n         (current \\<down> s) page'\n         \\<down> \\<up> case aseq ! n of\n                       SK_IPC SEND (BUF page') partner page \\<Rightarrow>\n                         set_object_value (PAGE page')\n                          (obj \\<down> s (PAGE page)) \\<down> s\n                       | SK_IPC RECV (BUF page') partner page \\<Rightarrow>\n                           \\<down> s\n                       | SK_IPC dir _ partner page \\<Rightarrow> \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                           atomic_step_ev_wait_all (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                           atomic_step_ev_wait_one (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n                           \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                           atomic_step_ev_signal (current \\<down> s) partner\n                            \\<down> s\n                       | NONE \\<Rightarrow> \\<down> s\n    | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n    | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n    | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n        ev_signal_precondition (current \\<down> s) partner\n         \\<down> \\<up> case aseq ! n of\n                       SK_IPC SEND (BUF page') partner page \\<Rightarrow>\n                         set_object_value (PAGE page')\n                          (obj \\<down> s (PAGE page)) \\<down> s\n                       | SK_IPC RECV (BUF page') partner page \\<Rightarrow>\n                           \\<down> s\n                       | SK_IPC dir _ partner page \\<Rightarrow> \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                           atomic_step_ev_wait_all (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                           atomic_step_ev_wait_one (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n                           \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                           atomic_step_ev_signal (current \\<down> s) partner\n                            \\<down> s\n                       | NONE \\<Rightarrow> \\<down> s\n    | NONE \\<Rightarrow> True", "by(auto)"], ["proof (state)\nthis:\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "}"], ["proof (state)\nthis:\n  n = 1 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "moreover"], ["proof (state)\nthis:\n  n = 1 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "from IPC"], ["proof (chain)\npicking this:\n  aseq =\n  [SK_IPC dir PREP partner page, SK_IPC dir WAIT partner page,\n   SK_IPC dir (BUF (Eps rinvariant)) partner page]", "have \"length aseq = 3\""], ["proof (prove)\nusing this:\n  aseq =\n  [SK_IPC dir PREP partner page, SK_IPC dir WAIT partner page,\n   SK_IPC dir (BUF (Eps rinvariant)) partner page]\n\ngoal (1 subgoal):\n 1. length aseq = 3", "by auto"], ["proof (state)\nthis:\n  length aseq = 3\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "ultimately"], ["proof (chain)\npicking this:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  n = 1 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  length aseq = 3", "have ?thesis"], ["proof (prove)\nusing this:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  n = 1 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  length aseq = 3\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "using n_bound"], ["proof (prove)\nusing this:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  n = 1 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  length aseq = 3\n  Suc n < length aseq\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "by arith"], ["proof (state)\nthis:\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "}"], ["proof (state)\nthis:\n  aseq =\n  [SK_IPC ?dir2 PREP ?partner2 ?page2, SK_IPC ?dir2 WAIT ?partner2 ?page2,\n   SK_IPC ?dir2 (BUF (Eps rinvariant)) ?partner2 ?page2] \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  aseq =\n  [SK_IPC ?dir2 PREP ?partner2 ?page2, SK_IPC ?dir2 WAIT ?partner2 ?page2,\n   SK_IPC ?dir2 (BUF (Eps rinvariant)) ?partner2 ?page2] \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "using IPC"], ["proof (prove)\nusing this:\n  aseq =\n  [SK_IPC ?dir2 PREP ?partner2 ?page2, SK_IPC ?dir2 WAIT ?partner2 ?page2,\n   SK_IPC ?dir2 (BUF (Eps rinvariant)) ?partner2 ?page2] \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  is_SK_IPC aseq\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "unfolding is_SK_IPC_def"], ["proof (prove)\nusing this:\n  aseq =\n  [SK_IPC ?dir2 PREP ?partner2 ?page2, SK_IPC ?dir2 WAIT ?partner2 ?page2,\n   SK_IPC ?dir2 (BUF (Eps rinvariant)) ?partner2 ?page2] \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  \\<exists>dir partner page.\n     aseq =\n     [SK_IPC dir PREP partner page, SK_IPC dir WAIT partner page,\n      SK_IPC dir (BUF (Eps rinvariant)) partner page]\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "by(auto)"], ["proof (state)\nthis:\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nWhen not waiting or aborting, the precondition is 1-step inductive.\n\\<close>"], ["", "lemma prec_after_EV_WAIT_step:\nassumes prec: \"rprecondition s (rcurrent s) (aseq ! n)\" \n    and n_bound: \"Suc n < length aseq\"\n    and IPC: \"is_SK_EV_WAIT aseq\"\n    and not_aborting: \"\\<not>raborting s (rcurrent s) (aseq ! n)\"\n    and not_waiting: \"\\<not>rwaiting s (rcurrent s) (aseq ! n)\"\nshows \"rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "fix consume"], ["proof (state)\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "assume WAIT: \"aseq = [SK_EV_WAIT EV_PREP consume,\n                        SK_EV_WAIT EV_WAIT consume,\n                        SK_EV_WAIT EV_FINISH consume]\""], ["proof (state)\nthis:\n  aseq =\n  [SK_EV_WAIT EV_PREP consume, SK_EV_WAIT EV_WAIT consume,\n   SK_EV_WAIT EV_FINISH consume]\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "{"], ["proof (state)\nthis:\n  aseq =\n  [SK_EV_WAIT EV_PREP consume, SK_EV_WAIT EV_WAIT consume,\n   SK_EV_WAIT EV_FINISH consume]\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "assume 0: \"n=0\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "from 0 WAIT prec not_aborting"], ["proof (chain)\npicking this:\n  n = 0\n  aseq =\n  [SK_EV_WAIT EV_PREP consume, SK_EV_WAIT EV_WAIT consume,\n   SK_EV_WAIT EV_FINISH consume]\n  rprecondition s (rcurrent s) (aseq ! n)\n  \\<not> raborting s (rcurrent s) (aseq ! n)", "have ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n  aseq =\n  [SK_EV_WAIT EV_PREP consume, SK_EV_WAIT EV_WAIT consume,\n   SK_EV_WAIT EV_FINISH consume]\n  rprecondition s (rcurrent s) (aseq ! n)\n  \\<not> raborting s (rcurrent s) (aseq ! n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "unfolding rprecondition_def atomic_step_precondition_def"], ["proof (prove)\nusing this:\n  n = 0\n  aseq =\n  [SK_EV_WAIT EV_PREP consume, SK_EV_WAIT EV_WAIT consume,\n   SK_EV_WAIT EV_FINISH consume]\n  case aseq ! n of SK_IPC dir PREP partner page \\<Rightarrow> True\n  | SK_IPC dir WAIT partner page \\<Rightarrow>\n      ipc_precondition (rcurrent s) dir partner page \\<down> s\n  | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n      ipc_precondition (rcurrent s) dir partner page \\<down> s \\<and>\n      ipc_precondition partner (opposite_ipc_direction dir) (rcurrent s)\n       page' \\<down> s\n  | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n  | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n  | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n      ev_signal_precondition (rcurrent s) partner \\<down> s\n  | NONE \\<Rightarrow> True\n  \\<not> raborting s (rcurrent s) (aseq ! n)\n\ngoal (1 subgoal):\n 1. case aseq ! Suc n of SK_IPC dir PREP partner page \\<Rightarrow> True\n    | SK_IPC dir WAIT partner page \\<Rightarrow>\n        ipc_precondition (rcurrent s) dir partner page\n         \\<down> rstep s (aseq ! n)\n    | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n        ipc_precondition (rcurrent s) dir partner page\n         \\<down> rstep s (aseq ! n) \\<and>\n        ipc_precondition partner (opposite_ipc_direction dir) (rcurrent s)\n         page' \\<down> rstep s (aseq ! n)\n    | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n    | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n    | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n        ev_signal_precondition (rcurrent s) partner\n         \\<down> rstep s (aseq ! n)\n    | NONE \\<Rightarrow> True", "by(auto)"], ["proof (state)\nthis:\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "}"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "moreover"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "{"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "assume 1: \"n=1\""], ["proof (state)\nthis:\n  n = 1\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "from 1 WAIT prec not_waiting"], ["proof (chain)\npicking this:\n  n = 1\n  aseq =\n  [SK_EV_WAIT EV_PREP consume, SK_EV_WAIT EV_WAIT consume,\n   SK_EV_WAIT EV_FINISH consume]\n  rprecondition s (rcurrent s) (aseq ! n)\n  \\<not> rwaiting s (rcurrent s) (aseq ! n)", "have ?thesis"], ["proof (prove)\nusing this:\n  n = 1\n  aseq =\n  [SK_EV_WAIT EV_PREP consume, SK_EV_WAIT EV_WAIT consume,\n   SK_EV_WAIT EV_FINISH consume]\n  rprecondition s (rcurrent s) (aseq ! n)\n  \\<not> rwaiting s (rcurrent s) (aseq ! n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "unfolding rprecondition_def atomic_step_precondition_def"], ["proof (prove)\nusing this:\n  n = 1\n  aseq =\n  [SK_EV_WAIT EV_PREP consume, SK_EV_WAIT EV_WAIT consume,\n   SK_EV_WAIT EV_FINISH consume]\n  case aseq ! n of SK_IPC dir PREP partner page \\<Rightarrow> True\n  | SK_IPC dir WAIT partner page \\<Rightarrow>\n      ipc_precondition (rcurrent s) dir partner page \\<down> s\n  | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n      ipc_precondition (rcurrent s) dir partner page \\<down> s \\<and>\n      ipc_precondition partner (opposite_ipc_direction dir) (rcurrent s)\n       page' \\<down> s\n  | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n  | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n  | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n      ev_signal_precondition (rcurrent s) partner \\<down> s\n  | NONE \\<Rightarrow> True\n  \\<not> rwaiting s (rcurrent s) (aseq ! n)\n\ngoal (1 subgoal):\n 1. case aseq ! Suc n of SK_IPC dir PREP partner page \\<Rightarrow> True\n    | SK_IPC dir WAIT partner page \\<Rightarrow>\n        ipc_precondition (rcurrent s) dir partner page\n         \\<down> rstep s (aseq ! n)\n    | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n        ipc_precondition (rcurrent s) dir partner page\n         \\<down> rstep s (aseq ! n) \\<and>\n        ipc_precondition partner (opposite_ipc_direction dir) (rcurrent s)\n         page' \\<down> rstep s (aseq ! n)\n    | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n    | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n    | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n        ev_signal_precondition (rcurrent s) partner\n         \\<down> rstep s (aseq ! n)\n    | NONE \\<Rightarrow> True", "by(auto)"], ["proof (state)\nthis:\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "}"], ["proof (state)\nthis:\n  n = 1 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "moreover"], ["proof (state)\nthis:\n  n = 1 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "from WAIT"], ["proof (chain)\npicking this:\n  aseq =\n  [SK_EV_WAIT EV_PREP consume, SK_EV_WAIT EV_WAIT consume,\n   SK_EV_WAIT EV_FINISH consume]", "have \"length aseq = 3\""], ["proof (prove)\nusing this:\n  aseq =\n  [SK_EV_WAIT EV_PREP consume, SK_EV_WAIT EV_WAIT consume,\n   SK_EV_WAIT EV_FINISH consume]\n\ngoal (1 subgoal):\n 1. length aseq = 3", "by auto"], ["proof (state)\nthis:\n  length aseq = 3\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "ultimately"], ["proof (chain)\npicking this:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  n = 1 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  length aseq = 3", "have ?thesis"], ["proof (prove)\nusing this:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  n = 1 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  length aseq = 3\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "using n_bound"], ["proof (prove)\nusing this:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  n = 1 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  length aseq = 3\n  Suc n < length aseq\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "by arith"], ["proof (state)\nthis:\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "}"], ["proof (state)\nthis:\n  aseq =\n  [SK_EV_WAIT EV_PREP ?consume2, SK_EV_WAIT EV_WAIT ?consume2,\n   SK_EV_WAIT EV_FINISH ?consume2] \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  aseq =\n  [SK_EV_WAIT EV_PREP ?consume2, SK_EV_WAIT EV_WAIT ?consume2,\n   SK_EV_WAIT EV_FINISH ?consume2] \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "using assms"], ["proof (prove)\nusing this:\n  aseq =\n  [SK_EV_WAIT EV_PREP ?consume2, SK_EV_WAIT EV_WAIT ?consume2,\n   SK_EV_WAIT EV_FINISH ?consume2] \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  rprecondition s (rcurrent s) (aseq ! n)\n  Suc n < length aseq\n  is_SK_EV_WAIT aseq\n  \\<not> raborting s (rcurrent s) (aseq ! n)\n  \\<not> rwaiting s (rcurrent s) (aseq ! n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "unfolding is_SK_EV_WAIT_def"], ["proof (prove)\nusing this:\n  aseq =\n  [SK_EV_WAIT EV_PREP ?consume2, SK_EV_WAIT EV_WAIT ?consume2,\n   SK_EV_WAIT EV_FINISH ?consume2] \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  rprecondition s (rcurrent s) (aseq ! n)\n  Suc n < length aseq\n  \\<exists>consume.\n     aseq =\n     [SK_EV_WAIT EV_PREP consume, SK_EV_WAIT EV_WAIT consume,\n      SK_EV_WAIT EV_FINISH consume]\n  \\<not> raborting s (rcurrent s) (aseq ! n)\n  \\<not> rwaiting s (rcurrent s) (aseq ! n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "by auto"], ["proof (state)\nthis:\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nWhen not waiting or aborting, the precondition is 1-step inductive.\n\\<close>"], ["", "lemma prec_after_EV_SIGNAL_step:\nassumes prec: \"rprecondition s (rcurrent s) (aseq ! n)\" \n    and n_bound: \"Suc n < length aseq\"\n    and SIGNAL: \"is_SK_EV_SIGNAL aseq\"\n    and not_aborting: \"\\<not>raborting s (rcurrent s) (aseq ! n)\"\n    and not_waiting: \"\\<not>rwaiting s (rcurrent s) (aseq ! n)\"\nshows \"rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "fix partner"], ["proof (state)\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "assume SIGNAL1: \"aseq = [SK_EV_SIGNAL EV_SIGNAL_PREP partner,\n                            SK_EV_SIGNAL EV_SIGNAL_FINISH partner]\""], ["proof (state)\nthis:\n  aseq =\n  [SK_EV_SIGNAL EV_SIGNAL_PREP partner,\n   SK_EV_SIGNAL EV_SIGNAL_FINISH partner]\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "{"], ["proof (state)\nthis:\n  aseq =\n  [SK_EV_SIGNAL EV_SIGNAL_PREP partner,\n   SK_EV_SIGNAL EV_SIGNAL_FINISH partner]\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "assume 0: \"n=0\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "from 0 SIGNAL1 prec not_aborting"], ["proof (chain)\npicking this:\n  n = 0\n  aseq =\n  [SK_EV_SIGNAL EV_SIGNAL_PREP partner,\n   SK_EV_SIGNAL EV_SIGNAL_FINISH partner]\n  rprecondition s (rcurrent s) (aseq ! n)\n  \\<not> raborting s (rcurrent s) (aseq ! n)", "have ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n  aseq =\n  [SK_EV_SIGNAL EV_SIGNAL_PREP partner,\n   SK_EV_SIGNAL EV_SIGNAL_FINISH partner]\n  rprecondition s (rcurrent s) (aseq ! n)\n  \\<not> raborting s (rcurrent s) (aseq ! n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "unfolding rprecondition_def atomic_step_precondition_def ev_signal_precondition_def\n                aborting_def rstep_def atomic_step_def"], ["proof (prove)\nusing this:\n  n = 0\n  aseq =\n  [SK_EV_SIGNAL EV_SIGNAL_PREP partner,\n   SK_EV_SIGNAL EV_SIGNAL_FINISH partner]\n  case aseq ! n of SK_IPC dir PREP partner page \\<Rightarrow> True\n  | SK_IPC dir WAIT partner page \\<Rightarrow>\n      ipc_precondition (rcurrent s) dir partner page \\<down> s\n  | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n      ipc_precondition (rcurrent s) dir partner page \\<down> s \\<and>\n      ipc_precondition partner (opposite_ipc_direction dir) (rcurrent s)\n       page' \\<down> s\n  | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n  | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n  | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n      sp_impl_subj_subj \\<down> s (Step.partition (rcurrent s))\n       (Step.partition partner)\n  | NONE \\<Rightarrow> True\n  \\<not> (case aseq ! n of\n          SK_IPC dir PREP partner page \\<Rightarrow>\n            \\<not> ipc_precondition (rcurrent s) dir partner page \\<down> s\n          | SK_IPC dir _ partner page \\<Rightarrow> False\n          | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n              \\<not> sp_impl_subj_subj \\<down> s\n                      (Step.partition (rcurrent s)) (Step.partition partner)\n          | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> False\n          | _ \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. case aseq ! Suc n of SK_IPC dir PREP partner page \\<Rightarrow> True\n    | SK_IPC dir WAIT partner page \\<Rightarrow>\n        ipc_precondition (rcurrent s) dir partner page\n         \\<down> \\<up> case aseq ! n of\n                       SK_IPC dir stage partner page \\<Rightarrow>\n                         atomic_step_ipc (current \\<down> s) dir stage\n                          partner page \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                           atomic_step_ev_wait_all (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                           atomic_step_ev_wait_one (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n                           \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                           atomic_step_ev_signal (current \\<down> s) partner\n                            \\<down> s\n                       | NONE \\<Rightarrow> \\<down> s\n    | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n        ipc_precondition (rcurrent s) dir partner page\n         \\<down> \\<up> case aseq ! n of\n                       SK_IPC dir stage partner page \\<Rightarrow>\n                         atomic_step_ipc (current \\<down> s) dir stage\n                          partner page \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                           atomic_step_ev_wait_all (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                           atomic_step_ev_wait_one (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n                           \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                           atomic_step_ev_signal (current \\<down> s) partner\n                            \\<down> s\n                       | NONE \\<Rightarrow> \\<down> s \\<and>\n        ipc_precondition partner (opposite_ipc_direction dir) (rcurrent s)\n         page'\n         \\<down> \\<up> case aseq ! n of\n                       SK_IPC dir stage partner page \\<Rightarrow>\n                         atomic_step_ipc (current \\<down> s) dir stage\n                          partner page \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                           atomic_step_ev_wait_all (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                           atomic_step_ev_wait_one (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n                           \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                           atomic_step_ev_signal (current \\<down> s) partner\n                            \\<down> s\n                       | NONE \\<Rightarrow> \\<down> s\n    | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n    | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n    | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n        sp_impl_subj_subj\n         \\<down> \\<up> case aseq ! n of\n                       SK_IPC dir stage partner page \\<Rightarrow>\n                         atomic_step_ipc (current \\<down> s) dir stage\n                          partner page \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                           atomic_step_ev_wait_all (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                           atomic_step_ev_wait_one (current \\<down> s)\n                            \\<down> s\n                       | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n                           \\<down> s\n                       | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                           atomic_step_ev_signal (current \\<down> s) partner\n                            \\<down> s\n                       | NONE \\<Rightarrow> \\<down> s\n         (Step.partition (rcurrent s)) (Step.partition partner)\n    | NONE \\<Rightarrow> True", "by auto"], ["proof (state)\nthis:\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "}"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "moreover"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "from SIGNAL1"], ["proof (chain)\npicking this:\n  aseq =\n  [SK_EV_SIGNAL EV_SIGNAL_PREP partner,\n   SK_EV_SIGNAL EV_SIGNAL_FINISH partner]", "have \"length aseq = 2\""], ["proof (prove)\nusing this:\n  aseq =\n  [SK_EV_SIGNAL EV_SIGNAL_PREP partner,\n   SK_EV_SIGNAL EV_SIGNAL_FINISH partner]\n\ngoal (1 subgoal):\n 1. length aseq = 2", "by auto"], ["proof (state)\nthis:\n  length aseq = 2\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "ultimately"], ["proof (chain)\npicking this:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  length aseq = 2", "have ?thesis"], ["proof (prove)\nusing this:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  length aseq = 2\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "using n_bound"], ["proof (prove)\nusing this:\n  n = 0 \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  length aseq = 2\n  Suc n < length aseq\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "by arith"], ["proof (state)\nthis:\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "}"], ["proof (state)\nthis:\n  aseq =\n  [SK_EV_SIGNAL EV_SIGNAL_PREP ?partner2,\n   SK_EV_SIGNAL EV_SIGNAL_FINISH ?partner2] \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  aseq =\n  [SK_EV_SIGNAL EV_SIGNAL_PREP ?partner2,\n   SK_EV_SIGNAL EV_SIGNAL_FINISH ?partner2] \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "using assms"], ["proof (prove)\nusing this:\n  aseq =\n  [SK_EV_SIGNAL EV_SIGNAL_PREP ?partner2,\n   SK_EV_SIGNAL EV_SIGNAL_FINISH ?partner2] \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  rprecondition s (rcurrent s) (aseq ! n)\n  Suc n < length aseq\n  is_SK_EV_SIGNAL aseq\n  \\<not> raborting s (rcurrent s) (aseq ! n)\n  \\<not> rwaiting s (rcurrent s) (aseq ! n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "unfolding is_SK_EV_SIGNAL_def"], ["proof (prove)\nusing this:\n  aseq =\n  [SK_EV_SIGNAL EV_SIGNAL_PREP ?partner2,\n   SK_EV_SIGNAL EV_SIGNAL_FINISH ?partner2] \\<Longrightarrow>\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n  rprecondition s (rcurrent s) (aseq ! n)\n  Suc n < length aseq\n  \\<exists>partner.\n     aseq =\n     [SK_EV_SIGNAL EV_SIGNAL_PREP partner,\n      SK_EV_SIGNAL EV_SIGNAL_FINISH partner]\n  \\<not> raborting s (rcurrent s) (aseq ! n)\n  \\<not> rwaiting s (rcurrent s) (aseq ! n)\n\ngoal (1 subgoal):\n 1. rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)", "by auto"], ["proof (state)\nthis:\n  rprecondition (rstep s (aseq ! n)) (rcurrent s) (aseq ! Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma on_set_object_value:\n  shows \"sp_impl_subj_subj (set_object_value ob val s) = sp_impl_subj_subj s\"\n    and \"sp_impl_subj_obj (set_object_value ob val s) = sp_impl_subj_obj s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_impl_subj_subj (set_object_value ob val s) = sp_impl_subj_subj s &&&\n    sp_impl_subj_obj (set_object_value ob val s) = sp_impl_subj_obj s", "unfolding set_object_value_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_impl_subj_subj (s\\<lparr>obj := (obj s)(ob := val)\\<rparr>) =\n    sp_impl_subj_subj s &&&\n    sp_impl_subj_obj (s\\<lparr>obj := (obj s)(ob := val)\\<rparr>) =\n    sp_impl_subj_obj s", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prec_IPC_dom_independent:\nassumes \"current s \\<noteq> d\"\n    and \"atomic_step_invariant s\"\n    and \"atomic_step_precondition s d a\"\nshows \"atomic_step_precondition (atomic_step_ipc (current s) dir stage partner page s) d a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_precondition\n     (atomic_step_ipc (current s) dir stage partner page s) d a", "using assms on_set_object_value"], ["proof (prove)\nusing this:\n  current s \\<noteq> d\n  atomic_step_invariant s\n  atomic_step_precondition s d a\n  sp_impl_subj_subj (set_object_value ?ob ?val ?s) = sp_impl_subj_subj ?s\n  sp_impl_subj_obj (set_object_value ?ob ?val ?s) = sp_impl_subj_obj ?s\n\ngoal (1 subgoal):\n 1. atomic_step_precondition\n     (atomic_step_ipc (current s) dir stage partner page s) d a", "unfolding atomic_step_precondition_def atomic_step_ipc_def ipc_precondition_def\n          ev_signal_precondition_def set_object_value_def"], ["proof (prove)\nusing this:\n  current s \\<noteq> d\n  atomic_step_invariant s\n  case a of SK_IPC dir PREP partner page \\<Rightarrow> True\n  | SK_IPC dir WAIT partner page \\<Rightarrow>\n      let sender =\n            case dir of SEND \\<Rightarrow> d | RECV \\<Rightarrow> partner;\n          receiver =\n            case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d;\n          local_access_mode =\n            case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n      in sp_impl_subj_subj s (Step.partition sender)\n          (Step.partition receiver) \\<and>\n         sp_impl_subj_obj s (Step.partition d) (PAGE page) local_access_mode\n  | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n      (let sender =\n             case dir of SEND \\<Rightarrow> d | RECV \\<Rightarrow> partner;\n           receiver =\n             case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d;\n           local_access_mode =\n             case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n       in sp_impl_subj_subj s (Step.partition sender)\n           (Step.partition receiver) \\<and>\n          sp_impl_subj_obj s (Step.partition d) (PAGE page)\n           local_access_mode) \\<and>\n      (let sender =\n             case opposite_ipc_direction dir of SEND \\<Rightarrow> partner\n             | RECV \\<Rightarrow> d;\n           receiver =\n             case opposite_ipc_direction dir of SEND \\<Rightarrow> d\n             | RECV \\<Rightarrow> partner;\n           local_access_mode =\n             case opposite_ipc_direction dir of SEND \\<Rightarrow> READ\n             | RECV \\<Rightarrow> WRITE\n       in sp_impl_subj_subj s (Step.partition sender)\n           (Step.partition receiver) \\<and>\n          sp_impl_subj_obj s (Step.partition partner) (PAGE page')\n           local_access_mode)\n  | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n  | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n  | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n      sp_impl_subj_subj s (Step.partition d) (Step.partition partner)\n  | NONE \\<Rightarrow> True\n  sp_impl_subj_subj (?s\\<lparr>obj := (obj ?s)(?ob := ?val)\\<rparr>) =\n  sp_impl_subj_subj ?s\n  sp_impl_subj_obj (?s\\<lparr>obj := (obj ?s)(?ob := ?val)\\<rparr>) =\n  sp_impl_subj_obj ?s\n\ngoal (1 subgoal):\n 1. case a of SK_IPC dira PREP partner pagea \\<Rightarrow> True\n    | SK_IPC dira WAIT partner pagea \\<Rightarrow>\n        let sender =\n              case dira of SEND \\<Rightarrow> d\n              | RECV \\<Rightarrow> partner;\n            receiver =\n              case dira of SEND \\<Rightarrow> partner\n              | RECV \\<Rightarrow> d;\n            local_access_mode =\n              case dira of SEND \\<Rightarrow> READ\n              | RECV \\<Rightarrow> WRITE\n        in sp_impl_subj_subj\n            (case stage of\n             BUF page' \\<Rightarrow>\n               case dir of\n               SEND \\<Rightarrow> s\n                 \\<lparr>obj := (obj s)\n                           (PAGE page' := obj s (PAGE page))\\<rparr>\n               | RECV \\<Rightarrow> s\n             | _ \\<Rightarrow> s)\n            (Step.partition sender) (Step.partition receiver) \\<and>\n           sp_impl_subj_obj\n            (case stage of\n             BUF page' \\<Rightarrow>\n               case dir of\n               SEND \\<Rightarrow> s\n                 \\<lparr>obj := (obj s)\n                           (PAGE page' := obj s (PAGE page))\\<rparr>\n               | RECV \\<Rightarrow> s\n             | _ \\<Rightarrow> s)\n            (Step.partition d) (PAGE pagea) local_access_mode\n    | SK_IPC dira (BUF page') partner pagea \\<Rightarrow>\n        (let sender =\n               case dira of SEND \\<Rightarrow> d\n               | RECV \\<Rightarrow> partner;\n             receiver =\n               case dira of SEND \\<Rightarrow> partner\n               | RECV \\<Rightarrow> d;\n             local_access_mode =\n               case dira of SEND \\<Rightarrow> READ\n               | RECV \\<Rightarrow> WRITE\n         in sp_impl_subj_subj\n             (case stage of\n              BUF page' \\<Rightarrow>\n                case dir of\n                SEND \\<Rightarrow> s\n                  \\<lparr>obj := (obj s)\n                            (PAGE page' := obj s (PAGE page))\\<rparr>\n                | RECV \\<Rightarrow> s\n              | _ \\<Rightarrow> s)\n             (Step.partition sender) (Step.partition receiver) \\<and>\n            sp_impl_subj_obj\n             (case stage of\n              BUF page' \\<Rightarrow>\n                case dir of\n                SEND \\<Rightarrow> s\n                  \\<lparr>obj := (obj s)\n                            (PAGE page' := obj s (PAGE page))\\<rparr>\n                | RECV \\<Rightarrow> s\n              | _ \\<Rightarrow> s)\n             (Step.partition d) (PAGE pagea) local_access_mode) \\<and>\n        (let sender =\n               case opposite_ipc_direction dira of\n               SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d;\n             receiver =\n               case opposite_ipc_direction dira of SEND \\<Rightarrow> d\n               | RECV \\<Rightarrow> partner;\n             local_access_mode =\n               case opposite_ipc_direction dira of SEND \\<Rightarrow> READ\n               | RECV \\<Rightarrow> WRITE\n         in sp_impl_subj_subj\n             (case stage of\n              BUF page' \\<Rightarrow>\n                case dir of\n                SEND \\<Rightarrow> s\n                  \\<lparr>obj := (obj s)\n                            (PAGE page' := obj s (PAGE page))\\<rparr>\n                | RECV \\<Rightarrow> s\n              | _ \\<Rightarrow> s)\n             (Step.partition sender) (Step.partition receiver) \\<and>\n            sp_impl_subj_obj\n             (case stage of\n              BUF page' \\<Rightarrow>\n                case dir of\n                SEND \\<Rightarrow> s\n                  \\<lparr>obj := (obj s)\n                            (PAGE page' := obj s (PAGE page))\\<rparr>\n                | RECV \\<Rightarrow> s\n              | _ \\<Rightarrow> s)\n             (Step.partition partner) (PAGE page') local_access_mode)\n    | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n    | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n    | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n        sp_impl_subj_subj\n         (case stage of\n          BUF page' \\<Rightarrow>\n            case dir of\n            SEND \\<Rightarrow> s\n              \\<lparr>obj := (obj s)\n                        (PAGE page' := obj s (PAGE page))\\<rparr>\n            | RECV \\<Rightarrow> s\n          | _ \\<Rightarrow> s)\n         (Step.partition d) (Step.partition partner)\n    | NONE \\<Rightarrow> True", "by (auto split: int_point_t.splits ipc_stage_t.splits ipc_direction_t.splits\n                   ev_consume_t.splits ev_wait_stage_t.splits ev_signal_stage_t.splits)"], ["", "lemma prec_ev_signal_dom_independent:\nassumes \"current s \\<noteq> d\"\n    and \"atomic_step_invariant s\"\n    and \"atomic_step_precondition s d a\"\nshows \"atomic_step_precondition (atomic_step_ev_signal (current s) partner s) d a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_precondition (atomic_step_ev_signal (current s) partner s) d\n     a", "using assms on_set_object_value"], ["proof (prove)\nusing this:\n  current s \\<noteq> d\n  atomic_step_invariant s\n  atomic_step_precondition s d a\n  sp_impl_subj_subj (set_object_value ?ob ?val ?s) = sp_impl_subj_subj ?s\n  sp_impl_subj_obj (set_object_value ?ob ?val ?s) = sp_impl_subj_obj ?s\n\ngoal (1 subgoal):\n 1. atomic_step_precondition (atomic_step_ev_signal (current s) partner s) d\n     a", "unfolding atomic_step_precondition_def atomic_step_ev_signal_def ipc_precondition_def\n          ev_signal_precondition_def set_object_value_def"], ["proof (prove)\nusing this:\n  current s \\<noteq> d\n  atomic_step_invariant s\n  case a of SK_IPC dir PREP partner page \\<Rightarrow> True\n  | SK_IPC dir WAIT partner page \\<Rightarrow>\n      let sender =\n            case dir of SEND \\<Rightarrow> d | RECV \\<Rightarrow> partner;\n          receiver =\n            case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d;\n          local_access_mode =\n            case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n      in sp_impl_subj_subj s (Step.partition sender)\n          (Step.partition receiver) \\<and>\n         sp_impl_subj_obj s (Step.partition d) (PAGE page) local_access_mode\n  | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n      (let sender =\n             case dir of SEND \\<Rightarrow> d | RECV \\<Rightarrow> partner;\n           receiver =\n             case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d;\n           local_access_mode =\n             case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n       in sp_impl_subj_subj s (Step.partition sender)\n           (Step.partition receiver) \\<and>\n          sp_impl_subj_obj s (Step.partition d) (PAGE page)\n           local_access_mode) \\<and>\n      (let sender =\n             case opposite_ipc_direction dir of SEND \\<Rightarrow> partner\n             | RECV \\<Rightarrow> d;\n           receiver =\n             case opposite_ipc_direction dir of SEND \\<Rightarrow> d\n             | RECV \\<Rightarrow> partner;\n           local_access_mode =\n             case opposite_ipc_direction dir of SEND \\<Rightarrow> READ\n             | RECV \\<Rightarrow> WRITE\n       in sp_impl_subj_subj s (Step.partition sender)\n           (Step.partition receiver) \\<and>\n          sp_impl_subj_obj s (Step.partition partner) (PAGE page')\n           local_access_mode)\n  | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n  | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n  | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n      sp_impl_subj_subj s (Step.partition d) (Step.partition partner)\n  | NONE \\<Rightarrow> True\n  sp_impl_subj_subj (?s\\<lparr>obj := (obj ?s)(?ob := ?val)\\<rparr>) =\n  sp_impl_subj_subj ?s\n  sp_impl_subj_obj (?s\\<lparr>obj := (obj ?s)(?ob := ?val)\\<rparr>) =\n  sp_impl_subj_obj ?s\n\ngoal (1 subgoal):\n 1. case a of SK_IPC dir PREP partnera page \\<Rightarrow> True\n    | SK_IPC dir WAIT partnera page \\<Rightarrow>\n        let sender =\n              case dir of SEND \\<Rightarrow> d\n              | RECV \\<Rightarrow> partnera;\n            receiver =\n              case dir of SEND \\<Rightarrow> partnera\n              | RECV \\<Rightarrow> d;\n            local_access_mode =\n              case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n        in sp_impl_subj_subj\n            (s\\<lparr>thread := (thread s)\n                        (partner := thread s partner\n                           \\<lparr>ev_counter :=\n                                     Suc\n(ev_counter (thread s partner))\\<rparr>)\\<rparr>)\n            (Step.partition sender) (Step.partition receiver) \\<and>\n           sp_impl_subj_obj\n            (s\\<lparr>thread := (thread s)\n                        (partner := thread s partner\n                           \\<lparr>ev_counter :=\n                                     Suc\n(ev_counter (thread s partner))\\<rparr>)\\<rparr>)\n            (Step.partition d) (PAGE page) local_access_mode\n    | SK_IPC dir (BUF page') partnera page \\<Rightarrow>\n        (let sender =\n               case dir of SEND \\<Rightarrow> d\n               | RECV \\<Rightarrow> partnera;\n             receiver =\n               case dir of SEND \\<Rightarrow> partnera\n               | RECV \\<Rightarrow> d;\n             local_access_mode =\n               case dir of SEND \\<Rightarrow> READ\n               | RECV \\<Rightarrow> WRITE\n         in sp_impl_subj_subj\n             (s\\<lparr>thread := (thread s)\n                         (partner := thread s partner\n                            \\<lparr>ev_counter :=\nSuc (ev_counter (thread s partner))\\<rparr>)\\<rparr>)\n             (Step.partition sender) (Step.partition receiver) \\<and>\n            sp_impl_subj_obj\n             (s\\<lparr>thread := (thread s)\n                         (partner := thread s partner\n                            \\<lparr>ev_counter :=\nSuc (ev_counter (thread s partner))\\<rparr>)\\<rparr>)\n             (Step.partition d) (PAGE page) local_access_mode) \\<and>\n        (let sender =\n               case opposite_ipc_direction dir of\n               SEND \\<Rightarrow> partnera | RECV \\<Rightarrow> d;\n             receiver =\n               case opposite_ipc_direction dir of SEND \\<Rightarrow> d\n               | RECV \\<Rightarrow> partnera;\n             local_access_mode =\n               case opposite_ipc_direction dir of SEND \\<Rightarrow> READ\n               | RECV \\<Rightarrow> WRITE\n         in sp_impl_subj_subj\n             (s\\<lparr>thread := (thread s)\n                         (partner := thread s partner\n                            \\<lparr>ev_counter :=\nSuc (ev_counter (thread s partner))\\<rparr>)\\<rparr>)\n             (Step.partition sender) (Step.partition receiver) \\<and>\n            sp_impl_subj_obj\n             (s\\<lparr>thread := (thread s)\n                         (partner := thread s partner\n                            \\<lparr>ev_counter :=\nSuc (ev_counter (thread s partner))\\<rparr>)\\<rparr>)\n             (Step.partition partnera) (PAGE page') local_access_mode)\n    | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n    | SK_EV_SIGNAL EV_SIGNAL_PREP partnera \\<Rightarrow> True\n    | SK_EV_SIGNAL EV_SIGNAL_FINISH partnera \\<Rightarrow>\n        sp_impl_subj_subj\n         (s\\<lparr>thread := (thread s)\n                     (partner := thread s partner\n                        \\<lparr>ev_counter :=\n                                  Suc (ev_counter\n  (thread s partner))\\<rparr>)\\<rparr>)\n         (Step.partition d) (Step.partition partnera)\n    | NONE \\<Rightarrow> True", "by (auto split: int_point_t.splits ipc_stage_t.splits ipc_direction_t.splits\n                   ev_consume_t.splits ev_wait_stage_t.splits ev_signal_stage_t.splits)"], ["", "lemma prec_ev_wait_one_dom_independent:\nassumes \"current s \\<noteq> d\"\n    and \"atomic_step_invariant s\"\n    and \"atomic_step_precondition s d a\"\nshows \"atomic_step_precondition (atomic_step_ev_wait_one (current s) s) d a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_precondition (atomic_step_ev_wait_one (current s) s) d a", "using assms on_set_object_value"], ["proof (prove)\nusing this:\n  current s \\<noteq> d\n  atomic_step_invariant s\n  atomic_step_precondition s d a\n  sp_impl_subj_subj (set_object_value ?ob ?val ?s) = sp_impl_subj_subj ?s\n  sp_impl_subj_obj (set_object_value ?ob ?val ?s) = sp_impl_subj_obj ?s\n\ngoal (1 subgoal):\n 1. atomic_step_precondition (atomic_step_ev_wait_one (current s) s) d a", "unfolding atomic_step_precondition_def atomic_step_ev_wait_one_def ipc_precondition_def\n          ev_signal_precondition_def set_object_value_def"], ["proof (prove)\nusing this:\n  current s \\<noteq> d\n  atomic_step_invariant s\n  case a of SK_IPC dir PREP partner page \\<Rightarrow> True\n  | SK_IPC dir WAIT partner page \\<Rightarrow>\n      let sender =\n            case dir of SEND \\<Rightarrow> d | RECV \\<Rightarrow> partner;\n          receiver =\n            case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d;\n          local_access_mode =\n            case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n      in sp_impl_subj_subj s (Step.partition sender)\n          (Step.partition receiver) \\<and>\n         sp_impl_subj_obj s (Step.partition d) (PAGE page) local_access_mode\n  | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n      (let sender =\n             case dir of SEND \\<Rightarrow> d | RECV \\<Rightarrow> partner;\n           receiver =\n             case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d;\n           local_access_mode =\n             case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n       in sp_impl_subj_subj s (Step.partition sender)\n           (Step.partition receiver) \\<and>\n          sp_impl_subj_obj s (Step.partition d) (PAGE page)\n           local_access_mode) \\<and>\n      (let sender =\n             case opposite_ipc_direction dir of SEND \\<Rightarrow> partner\n             | RECV \\<Rightarrow> d;\n           receiver =\n             case opposite_ipc_direction dir of SEND \\<Rightarrow> d\n             | RECV \\<Rightarrow> partner;\n           local_access_mode =\n             case opposite_ipc_direction dir of SEND \\<Rightarrow> READ\n             | RECV \\<Rightarrow> WRITE\n       in sp_impl_subj_subj s (Step.partition sender)\n           (Step.partition receiver) \\<and>\n          sp_impl_subj_obj s (Step.partition partner) (PAGE page')\n           local_access_mode)\n  | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n  | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n  | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n      sp_impl_subj_subj s (Step.partition d) (Step.partition partner)\n  | NONE \\<Rightarrow> True\n  sp_impl_subj_subj (?s\\<lparr>obj := (obj ?s)(?ob := ?val)\\<rparr>) =\n  sp_impl_subj_subj ?s\n  sp_impl_subj_obj (?s\\<lparr>obj := (obj ?s)(?ob := ?val)\\<rparr>) =\n  sp_impl_subj_obj ?s\n\ngoal (1 subgoal):\n 1. case a of SK_IPC dir PREP partner page \\<Rightarrow> True\n    | SK_IPC dir WAIT partner page \\<Rightarrow>\n        let sender =\n              case dir of SEND \\<Rightarrow> d | RECV \\<Rightarrow> partner;\n            receiver =\n              case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d;\n            local_access_mode =\n              case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n        in sp_impl_subj_subj\n            (s\\<lparr>thread := (thread s)\n                        (current s := thread s (current s)\n                           \\<lparr>ev_counter :=\n                                     ev_counter (thread s (current s)) -\n                                     1\\<rparr>)\\<rparr>)\n            (Step.partition sender) (Step.partition receiver) \\<and>\n           sp_impl_subj_obj\n            (s\\<lparr>thread := (thread s)\n                        (current s := thread s (current s)\n                           \\<lparr>ev_counter :=\n                                     ev_counter (thread s (current s)) -\n                                     1\\<rparr>)\\<rparr>)\n            (Step.partition d) (PAGE page) local_access_mode\n    | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n        (let sender =\n               case dir of SEND \\<Rightarrow> d\n               | RECV \\<Rightarrow> partner;\n             receiver =\n               case dir of SEND \\<Rightarrow> partner\n               | RECV \\<Rightarrow> d;\n             local_access_mode =\n               case dir of SEND \\<Rightarrow> READ\n               | RECV \\<Rightarrow> WRITE\n         in sp_impl_subj_subj\n             (s\\<lparr>thread := (thread s)\n                         (current s := thread s (current s)\n                            \\<lparr>ev_counter :=\nev_counter (thread s (current s)) - 1\\<rparr>)\\<rparr>)\n             (Step.partition sender) (Step.partition receiver) \\<and>\n            sp_impl_subj_obj\n             (s\\<lparr>thread := (thread s)\n                         (current s := thread s (current s)\n                            \\<lparr>ev_counter :=\nev_counter (thread s (current s)) - 1\\<rparr>)\\<rparr>)\n             (Step.partition d) (PAGE page) local_access_mode) \\<and>\n        (let sender =\n               case opposite_ipc_direction dir of SEND \\<Rightarrow> partner\n               | RECV \\<Rightarrow> d;\n             receiver =\n               case opposite_ipc_direction dir of SEND \\<Rightarrow> d\n               | RECV \\<Rightarrow> partner;\n             local_access_mode =\n               case opposite_ipc_direction dir of SEND \\<Rightarrow> READ\n               | RECV \\<Rightarrow> WRITE\n         in sp_impl_subj_subj\n             (s\\<lparr>thread := (thread s)\n                         (current s := thread s (current s)\n                            \\<lparr>ev_counter :=\nev_counter (thread s (current s)) - 1\\<rparr>)\\<rparr>)\n             (Step.partition sender) (Step.partition receiver) \\<and>\n            sp_impl_subj_obj\n             (s\\<lparr>thread := (thread s)\n                         (current s := thread s (current s)\n                            \\<lparr>ev_counter :=\nev_counter (thread s (current s)) - 1\\<rparr>)\\<rparr>)\n             (Step.partition partner) (PAGE page') local_access_mode)\n    | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n    | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n    | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n        sp_impl_subj_subj\n         (s\\<lparr>thread := (thread s)\n                     (current s := thread s (current s)\n                        \\<lparr>ev_counter :=\n                                  ev_counter (thread s (current s)) -\n                                  1\\<rparr>)\\<rparr>)\n         (Step.partition d) (Step.partition partner)\n    | NONE \\<Rightarrow> True", "by (auto split: int_point_t.splits ipc_stage_t.splits ipc_direction_t.splits\n                   ev_consume_t.splits ev_wait_stage_t.splits ev_signal_stage_t.splits)"], ["", "lemma prec_ev_wait_all_dom_independent:\nassumes \"current s \\<noteq> d\"\n    and \"atomic_step_invariant s\"\n    and \"atomic_step_precondition s d a\"\nshows \"atomic_step_precondition (atomic_step_ev_wait_all (current s) s) d a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_precondition (atomic_step_ev_wait_all (current s) s) d a", "using assms on_set_object_value"], ["proof (prove)\nusing this:\n  current s \\<noteq> d\n  atomic_step_invariant s\n  atomic_step_precondition s d a\n  sp_impl_subj_subj (set_object_value ?ob ?val ?s) = sp_impl_subj_subj ?s\n  sp_impl_subj_obj (set_object_value ?ob ?val ?s) = sp_impl_subj_obj ?s\n\ngoal (1 subgoal):\n 1. atomic_step_precondition (atomic_step_ev_wait_all (current s) s) d a", "unfolding atomic_step_precondition_def atomic_step_ev_wait_all_def ipc_precondition_def\n          ev_signal_precondition_def set_object_value_def"], ["proof (prove)\nusing this:\n  current s \\<noteq> d\n  atomic_step_invariant s\n  case a of SK_IPC dir PREP partner page \\<Rightarrow> True\n  | SK_IPC dir WAIT partner page \\<Rightarrow>\n      let sender =\n            case dir of SEND \\<Rightarrow> d | RECV \\<Rightarrow> partner;\n          receiver =\n            case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d;\n          local_access_mode =\n            case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n      in sp_impl_subj_subj s (Step.partition sender)\n          (Step.partition receiver) \\<and>\n         sp_impl_subj_obj s (Step.partition d) (PAGE page) local_access_mode\n  | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n      (let sender =\n             case dir of SEND \\<Rightarrow> d | RECV \\<Rightarrow> partner;\n           receiver =\n             case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d;\n           local_access_mode =\n             case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n       in sp_impl_subj_subj s (Step.partition sender)\n           (Step.partition receiver) \\<and>\n          sp_impl_subj_obj s (Step.partition d) (PAGE page)\n           local_access_mode) \\<and>\n      (let sender =\n             case opposite_ipc_direction dir of SEND \\<Rightarrow> partner\n             | RECV \\<Rightarrow> d;\n           receiver =\n             case opposite_ipc_direction dir of SEND \\<Rightarrow> d\n             | RECV \\<Rightarrow> partner;\n           local_access_mode =\n             case opposite_ipc_direction dir of SEND \\<Rightarrow> READ\n             | RECV \\<Rightarrow> WRITE\n       in sp_impl_subj_subj s (Step.partition sender)\n           (Step.partition receiver) \\<and>\n          sp_impl_subj_obj s (Step.partition partner) (PAGE page')\n           local_access_mode)\n  | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n  | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n  | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n      sp_impl_subj_subj s (Step.partition d) (Step.partition partner)\n  | NONE \\<Rightarrow> True\n  sp_impl_subj_subj (?s\\<lparr>obj := (obj ?s)(?ob := ?val)\\<rparr>) =\n  sp_impl_subj_subj ?s\n  sp_impl_subj_obj (?s\\<lparr>obj := (obj ?s)(?ob := ?val)\\<rparr>) =\n  sp_impl_subj_obj ?s\n\ngoal (1 subgoal):\n 1. case a of SK_IPC dir PREP partner page \\<Rightarrow> True\n    | SK_IPC dir WAIT partner page \\<Rightarrow>\n        let sender =\n              case dir of SEND \\<Rightarrow> d | RECV \\<Rightarrow> partner;\n            receiver =\n              case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d;\n            local_access_mode =\n              case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n        in sp_impl_subj_subj\n            (s\\<lparr>thread := (thread s)\n                        (current s := thread s (current s)\n                           \\<lparr>ev_counter := 0\\<rparr>)\\<rparr>)\n            (Step.partition sender) (Step.partition receiver) \\<and>\n           sp_impl_subj_obj\n            (s\\<lparr>thread := (thread s)\n                        (current s := thread s (current s)\n                           \\<lparr>ev_counter := 0\\<rparr>)\\<rparr>)\n            (Step.partition d) (PAGE page) local_access_mode\n    | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n        (let sender =\n               case dir of SEND \\<Rightarrow> d\n               | RECV \\<Rightarrow> partner;\n             receiver =\n               case dir of SEND \\<Rightarrow> partner\n               | RECV \\<Rightarrow> d;\n             local_access_mode =\n               case dir of SEND \\<Rightarrow> READ\n               | RECV \\<Rightarrow> WRITE\n         in sp_impl_subj_subj\n             (s\\<lparr>thread := (thread s)\n                         (current s := thread s (current s)\n                            \\<lparr>ev_counter := 0\\<rparr>)\\<rparr>)\n             (Step.partition sender) (Step.partition receiver) \\<and>\n            sp_impl_subj_obj\n             (s\\<lparr>thread := (thread s)\n                         (current s := thread s (current s)\n                            \\<lparr>ev_counter := 0\\<rparr>)\\<rparr>)\n             (Step.partition d) (PAGE page) local_access_mode) \\<and>\n        (let sender =\n               case opposite_ipc_direction dir of SEND \\<Rightarrow> partner\n               | RECV \\<Rightarrow> d;\n             receiver =\n               case opposite_ipc_direction dir of SEND \\<Rightarrow> d\n               | RECV \\<Rightarrow> partner;\n             local_access_mode =\n               case opposite_ipc_direction dir of SEND \\<Rightarrow> READ\n               | RECV \\<Rightarrow> WRITE\n         in sp_impl_subj_subj\n             (s\\<lparr>thread := (thread s)\n                         (current s := thread s (current s)\n                            \\<lparr>ev_counter := 0\\<rparr>)\\<rparr>)\n             (Step.partition sender) (Step.partition receiver) \\<and>\n            sp_impl_subj_obj\n             (s\\<lparr>thread := (thread s)\n                         (current s := thread s (current s)\n                            \\<lparr>ev_counter := 0\\<rparr>)\\<rparr>)\n             (Step.partition partner) (PAGE page') local_access_mode)\n    | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n    | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n    | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n        sp_impl_subj_subj\n         (s\\<lparr>thread := (thread s)\n                     (current s := thread s (current s)\n                        \\<lparr>ev_counter := 0\\<rparr>)\\<rparr>)\n         (Step.partition d) (Step.partition partner)\n    | NONE \\<Rightarrow> True", "by (auto split: int_point_t.splits ipc_stage_t.splits ipc_direction_t.splits\n                   ev_consume_t.splits ev_wait_stage_t.splits ev_signal_stage_t.splits)"], ["", "lemma prec_dom_independent:\nshows \"\\<forall> s d a a' . rcurrent s \\<noteq> d \\<and> rprecondition s d a \\<longrightarrow> rprecondition (rstep s a') d a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s d a a'.\n       rcurrent s \\<noteq> d \\<and> rprecondition s d a \\<longrightarrow>\n       rprecondition (rstep s a') d a", "using atomic_step_preserves_invariants \nrstate_invariant prec_IPC_dom_independent prec_ev_signal_dom_independent\nprec_ev_wait_all_dom_independent prec_ev_wait_one_dom_independent"], ["proof (prove)\nusing this:\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (atomic_step ?s ?a)\n  atomic_step_invariant \\<down> ?s\n  \\<lbrakk>current ?s \\<noteq> ?d; atomic_step_invariant ?s;\n   atomic_step_precondition ?s ?d ?a\\<rbrakk>\n  \\<Longrightarrow> atomic_step_precondition\n                     (atomic_step_ipc (current ?s) ?dir ?stage ?partner\n                       ?page ?s)\n                     ?d ?a\n  \\<lbrakk>current ?s \\<noteq> ?d; atomic_step_invariant ?s;\n   atomic_step_precondition ?s ?d ?a\\<rbrakk>\n  \\<Longrightarrow> atomic_step_precondition\n                     (atomic_step_ev_signal (current ?s) ?partner ?s) ?d ?a\n  \\<lbrakk>current ?s \\<noteq> ?d; atomic_step_invariant ?s;\n   atomic_step_precondition ?s ?d ?a\\<rbrakk>\n  \\<Longrightarrow> atomic_step_precondition\n                     (atomic_step_ev_wait_all (current ?s) ?s) ?d ?a\n  \\<lbrakk>current ?s \\<noteq> ?d; atomic_step_invariant ?s;\n   atomic_step_precondition ?s ?d ?a\\<rbrakk>\n  \\<Longrightarrow> atomic_step_precondition\n                     (atomic_step_ev_wait_one (current ?s) ?s) ?d ?a\n\ngoal (1 subgoal):\n 1. \\<forall>s d a a'.\n       rcurrent s \\<noteq> d \\<and> rprecondition s d a \\<longrightarrow>\n       rprecondition (rstep s a') d a", "unfolding rcurrent_def rprecondition_def rstep_def atomic_step_def"], ["proof (prove)\nusing this:\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant\n   (case ?a of\n    SK_IPC dir stage partner page \\<Rightarrow>\n      atomic_step_ipc (current ?s) dir stage partner page ?s\n    | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n        atomic_step_ev_wait_all (current ?s) ?s\n    | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n        atomic_step_ev_wait_one (current ?s) ?s\n    | SK_EV_WAIT _ consume \\<Rightarrow> ?s\n    | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> ?s\n    | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n        atomic_step_ev_signal (current ?s) partner ?s\n    | NONE \\<Rightarrow> ?s)\n  atomic_step_invariant \\<down> ?s\n  \\<lbrakk>current ?s \\<noteq> ?d; atomic_step_invariant ?s;\n   atomic_step_precondition ?s ?d ?a\\<rbrakk>\n  \\<Longrightarrow> atomic_step_precondition\n                     (atomic_step_ipc (current ?s) ?dir ?stage ?partner\n                       ?page ?s)\n                     ?d ?a\n  \\<lbrakk>current ?s \\<noteq> ?d; atomic_step_invariant ?s;\n   atomic_step_precondition ?s ?d ?a\\<rbrakk>\n  \\<Longrightarrow> atomic_step_precondition\n                     (atomic_step_ev_signal (current ?s) ?partner ?s) ?d ?a\n  \\<lbrakk>current ?s \\<noteq> ?d; atomic_step_invariant ?s;\n   atomic_step_precondition ?s ?d ?a\\<rbrakk>\n  \\<Longrightarrow> atomic_step_precondition\n                     (atomic_step_ev_wait_all (current ?s) ?s) ?d ?a\n  \\<lbrakk>current ?s \\<noteq> ?d; atomic_step_invariant ?s;\n   atomic_step_precondition ?s ?d ?a\\<rbrakk>\n  \\<Longrightarrow> atomic_step_precondition\n                     (atomic_step_ev_wait_one (current ?s) ?s) ?d ?a\n\ngoal (1 subgoal):\n 1. \\<forall>s d a a'.\n       current \\<down> s \\<noteq> d \\<and>\n       atomic_step_precondition \\<down> s d a \\<longrightarrow>\n       atomic_step_precondition\n        \\<down> \\<up> case a' of\n                      SK_IPC dir stage partner page \\<Rightarrow>\n                        atomic_step_ipc (current \\<down> s) dir stage\n                         partner page \\<down> s\n                      | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                          atomic_step_ev_wait_all (current \\<down> s)\n                           \\<down> s\n                      | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                          atomic_step_ev_wait_one (current \\<down> s)\n                           \\<down> s\n                      | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n                      | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n                          \\<down> s\n                      | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                          atomic_step_ev_signal (current \\<down> s) partner\n                           \\<down> s\n                      | NONE \\<Rightarrow> \\<down> s\n        d a", "by(auto split: int_point_t.splits  ev_consume_t.splits ev_wait_stage_t.splits ev_signal_stage_t.splits)"], ["", "lemma ipc_precondition_after_cswitch[simp]:\nshows \"ipc_precondition d dir partner page ((\\<down> s)\\<lparr>current := new_current\\<rparr>) \n          = ipc_precondition d dir partner page (\\<down> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipc_precondition d dir partner page\n     (\\<down> s\\<lparr>current := new_current\\<rparr>) =\n    ipc_precondition d dir partner page \\<down> s", "unfolding ipc_precondition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let sender =\n           case dir of SEND \\<Rightarrow> d | RECV \\<Rightarrow> partner;\n         receiver =\n           case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d;\n         local_access_mode =\n           case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n     in sp_impl_subj_subj (\\<down> s\\<lparr>current := new_current\\<rparr>)\n         (Step.partition sender) (Step.partition receiver) \\<and>\n        sp_impl_subj_obj (\\<down> s\\<lparr>current := new_current\\<rparr>)\n         (Step.partition d) (PAGE page) local_access_mode) =\n    (let sender =\n           case dir of SEND \\<Rightarrow> d | RECV \\<Rightarrow> partner;\n         receiver =\n           case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d;\n         local_access_mode =\n           case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n     in sp_impl_subj_subj \\<down> s (Step.partition sender)\n         (Step.partition receiver) \\<and>\n        sp_impl_subj_obj \\<down> s (Step.partition d) (PAGE page)\n         local_access_mode)", "by(auto split: ipc_direction_t.splits)"], ["", "lemma precondition_after_cswitch:\nshows \"\\<forall>s d n a. rprecondition s d a \\<longrightarrow> rprecondition (rcswitch n s) d a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s d n a.\n       rprecondition s d a \\<longrightarrow>\n       rprecondition (rcswitch n s) d a", "using cswitch_preserves_invariants rstate_invariant"], ["proof (prove)\nusing this:\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (?s\\<lparr>current := ?new_current\\<rparr>)\n  atomic_step_invariant \\<down> ?s\n\ngoal (1 subgoal):\n 1. \\<forall>s d n a.\n       rprecondition s d a \\<longrightarrow>\n       rprecondition (rcswitch n s) d a", "unfolding rprecondition_def rcswitch_def atomic_step_precondition_def\n          ev_signal_precondition_def"], ["proof (prove)\nusing this:\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (?s\\<lparr>current := ?new_current\\<rparr>)\n  atomic_step_invariant \\<down> ?s\n\ngoal (1 subgoal):\n 1. \\<forall>s d n a.\n       (case a of SK_IPC dir PREP partner page \\<Rightarrow> True\n        | SK_IPC dir WAIT partner page \\<Rightarrow>\n            ipc_precondition d dir partner page \\<down> s\n        | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n            ipc_precondition d dir partner page \\<down> s \\<and>\n            ipc_precondition partner (opposite_ipc_direction dir) d page'\n             \\<down> s\n        | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n        | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n        | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n            sp_impl_subj_subj \\<down> s (Step.partition d)\n             (Step.partition partner)\n        | NONE \\<Rightarrow> True) \\<longrightarrow>\n       (case a of SK_IPC dir PREP partner page \\<Rightarrow> True\n        | SK_IPC dir WAIT partner page \\<Rightarrow>\n            ipc_precondition d dir partner page \\<down> \\<up> \\<down> s\n             \\<lparr>current := Eps rinvariant\\<rparr>\n        | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n            ipc_precondition d dir partner page \\<down> \\<up> \\<down> s\n             \\<lparr>current := Eps rinvariant\\<rparr> \\<and>\n            ipc_precondition partner (opposite_ipc_direction dir) d page'\n             \\<down> \\<up> \\<down> s\n             \\<lparr>current := Eps rinvariant\\<rparr>\n        | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n        | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n        | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n            sp_impl_subj_subj \\<down> \\<up> \\<down> s\n             \\<lparr>current := Eps rinvariant\\<rparr> (Step.partition d)\n             (Step.partition partner)\n        | NONE \\<Rightarrow> True)", "by (auto split: int_point_t.splits ipc_stage_t.splits  ev_signal_stage_t.splits)"], ["", "lemma aborting_switch_independent:\nshows \"\\<forall>n s. raborting (rcswitch n s) = raborting s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n s. raborting (rcswitch n s) = raborting s", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n s. raborting (rcswitch n s) = raborting s", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n s. raborting (rcswitch n s) = raborting s", "fix n s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n s. raborting (rcswitch n s) = raborting s", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n s. raborting (rcswitch n s) = raborting s", "fix tid a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n s. raborting (rcswitch n s) = raborting s", "have \"raborting (rcswitch n s) tid a = raborting s tid a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. raborting (rcswitch n s) tid a = raborting s tid a", "using rstate_invariant cswitch_preserves_invariants ev_signal_precondition_weakly_step_consistent\n            cswitch_consistency_and_respect"], ["proof (prove)\nusing this:\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (?s\\<lparr>current := ?new_current\\<rparr>)\n  \\<lbrakk>vpeq (Step.partition ?tid) ?s1.0 ?s2.0;\n   atomic_step_invariant ?s1.0; atomic_step_invariant ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ev_signal_precondition ?tid ?partner ?s1.0 =\n                    ev_signal_precondition ?tid ?partner ?s2.0\n  atomic_step_invariant ?s \\<Longrightarrow>\n  vpeq ?u ?s (?s\\<lparr>current := ?new_current\\<rparr>)\n\ngoal (1 subgoal):\n 1. raborting (rcswitch n s) tid a = raborting s tid a", "unfolding aborting_def rcswitch_def"], ["proof (prove)\nusing this:\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (?s\\<lparr>current := ?new_current\\<rparr>)\n  \\<lbrakk>vpeq (Step.partition ?tid) ?s1.0 ?s2.0;\n   atomic_step_invariant ?s1.0; atomic_step_invariant ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ev_signal_precondition ?tid ?partner ?s1.0 =\n                    ev_signal_precondition ?tid ?partner ?s2.0\n  atomic_step_invariant ?s \\<Longrightarrow>\n  vpeq ?u ?s (?s\\<lparr>current := ?new_current\\<rparr>)\n\ngoal (1 subgoal):\n 1. (case a of\n     SK_IPC dir PREP partner page \\<Rightarrow>\n       \\<not> ipc_precondition tid dir partner page \\<down> \\<up> \\<down> s\n               \\<lparr>current := Eps rinvariant\\<rparr>\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n         \\<not> ev_signal_precondition tid partner \\<down> \\<up> \\<down> s\n                 \\<lparr>current := Eps rinvariant\\<rparr>\n     | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> False\n     | _ \\<Rightarrow> False) =\n    (case a of\n     SK_IPC dir PREP partner page \\<Rightarrow>\n       \\<not> ipc_precondition tid dir partner page \\<down> s\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n         \\<not> ev_signal_precondition tid partner \\<down> s\n     | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> False\n     | _ \\<Rightarrow> False)", "apply (auto split: int_point_t.splits ipc_stage_t.splits\n                         ev_wait_stage_t.splits ev_signal_stage_t.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x32.\n       \\<lbrakk>\\<And>s. atomic_step_invariant \\<down> s;\n        \\<And>s new_current.\n           atomic_step_invariant s \\<Longrightarrow>\n           atomic_step_invariant (s\\<lparr>current := new_current\\<rparr>);\n        \\<And>tid s1 s2 partner.\n           \\<lbrakk>vpeq (Step.partition tid) s1 s2;\n            atomic_step_invariant s1; atomic_step_invariant s2\\<rbrakk>\n           \\<Longrightarrow> ev_signal_precondition tid partner s1 =\n                             ev_signal_precondition tid partner s2;\n        \\<And>s u new_current.\n           atomic_step_invariant s \\<Longrightarrow>\n           vpeq u s (s\\<lparr>current := new_current\\<rparr>);\n        a = SK_EV_SIGNAL EV_SIGNAL_PREP x32;\n        ev_signal_precondition tid x32\n         (\\<down> s\\<lparr>current := Eps rinvariant\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ev_signal_precondition tid x32 \\<down> s\n 2. \\<And>x32.\n       \\<lbrakk>\\<And>s. atomic_step_invariant \\<down> s;\n        \\<And>s new_current.\n           atomic_step_invariant s \\<Longrightarrow>\n           atomic_step_invariant (s\\<lparr>current := new_current\\<rparr>);\n        \\<And>tid s1 s2 partner.\n           \\<lbrakk>vpeq (Step.partition tid) s1 s2;\n            atomic_step_invariant s1; atomic_step_invariant s2\\<rbrakk>\n           \\<Longrightarrow> ev_signal_precondition tid partner s1 =\n                             ev_signal_precondition tid partner s2;\n        \\<And>s u new_current.\n           atomic_step_invariant s \\<Longrightarrow>\n           vpeq u s (s\\<lparr>current := new_current\\<rparr>);\n        a = SK_EV_SIGNAL EV_SIGNAL_PREP x32;\n        ev_signal_precondition tid x32 \\<down> s\\<rbrakk>\n       \\<Longrightarrow> ev_signal_precondition tid x32\n                          (\\<down> s\n                           \\<lparr>current := Eps rinvariant\\<rparr>)", "apply (metis (full_types))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x32.\n       \\<lbrakk>\\<And>s. atomic_step_invariant \\<down> s;\n        \\<And>s new_current.\n           atomic_step_invariant s \\<Longrightarrow>\n           atomic_step_invariant (s\\<lparr>current := new_current\\<rparr>);\n        \\<And>tid s1 s2 partner.\n           \\<lbrakk>vpeq (Step.partition tid) s1 s2;\n            atomic_step_invariant s1; atomic_step_invariant s2\\<rbrakk>\n           \\<Longrightarrow> ev_signal_precondition tid partner s1 =\n                             ev_signal_precondition tid partner s2;\n        \\<And>s u new_current.\n           atomic_step_invariant s \\<Longrightarrow>\n           vpeq u s (s\\<lparr>current := new_current\\<rparr>);\n        a = SK_EV_SIGNAL EV_SIGNAL_PREP x32;\n        ev_signal_precondition tid x32 \\<down> s\\<rbrakk>\n       \\<Longrightarrow> ev_signal_precondition tid x32\n                          (\\<down> s\n                           \\<lparr>current := Eps rinvariant\\<rparr>)", "by blast"], ["proof (state)\nthis:\n  raborting (rcswitch n s) tid a = raborting s tid a\n\ngoal (1 subgoal):\n 1. \\<forall>n s. raborting (rcswitch n s) = raborting s", "}"], ["proof (state)\nthis:\n  raborting (rcswitch n s) ?tid2 ?a2 = raborting s ?tid2 ?a2\n\ngoal (1 subgoal):\n 1. \\<forall>n s. raborting (rcswitch n s) = raborting s", "hence \"raborting (rcswitch n s) = raborting s\""], ["proof (prove)\nusing this:\n  raborting (rcswitch n s) ?tid2 ?a2 = raborting s ?tid2 ?a2\n\ngoal (1 subgoal):\n 1. raborting (rcswitch n s) = raborting s", "by auto"], ["proof (state)\nthis:\n  raborting (rcswitch n s) = raborting s\n\ngoal (1 subgoal):\n 1. \\<forall>n s. raborting (rcswitch n s) = raborting s", "}"], ["proof (state)\nthis:\n  raborting (rcswitch ?n2 ?s2) = raborting ?s2\n\ngoal (1 subgoal):\n 1. \\<forall>n s. raborting (rcswitch n s) = raborting s", "thus ?thesis"], ["proof (prove)\nusing this:\n  raborting (rcswitch ?n2 ?s2) = raborting ?s2\n\ngoal (1 subgoal):\n 1. \\<forall>n s. raborting (rcswitch n s) = raborting s", "by auto"], ["proof (state)\nthis:\n  \\<forall>n s. raborting (rcswitch n s) = raborting s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma waiting_switch_independent:\nshows \"\\<forall>n s. rwaiting (rcswitch n s) = rwaiting s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n s. rwaiting (rcswitch n s) = rwaiting s", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n s. rwaiting (rcswitch n s) = rwaiting s", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n s. rwaiting (rcswitch n s) = rwaiting s", "fix n s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n s. rwaiting (rcswitch n s) = rwaiting s", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n s. rwaiting (rcswitch n s) = rwaiting s", "fix tid a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n s. rwaiting (rcswitch n s) = rwaiting s", "have \"rwaiting (rcswitch n s) tid a = rwaiting s tid a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwaiting (rcswitch n s) tid a = rwaiting s tid a", "using rstate_invariant cswitch_preserves_invariants"], ["proof (prove)\nusing this:\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (?s\\<lparr>current := ?new_current\\<rparr>)\n\ngoal (1 subgoal):\n 1. rwaiting (rcswitch n s) tid a = rwaiting s tid a", "unfolding waiting_def rcswitch_def"], ["proof (prove)\nusing this:\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (?s\\<lparr>current := ?new_current\\<rparr>)\n\ngoal (1 subgoal):\n 1. (case a of\n     SK_IPC dir WAIT partner page \\<Rightarrow>\n       \\<not> ipc_precondition partner (opposite_ipc_direction dir) tid\n               (Eps rinvariant) \\<down> \\<up> \\<down> s\n               \\<lparr>current := Eps rinvariant\\<rparr>\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_WAIT EV_WAIT x \\<Rightarrow>\n         ev_counter\n          (thread \\<down> \\<up> \\<down> s\n            \\<lparr>current := Eps rinvariant\\<rparr> tid) =\n         0\n     | SK_EV_WAIT _ x \\<Rightarrow> False | _ \\<Rightarrow> False) =\n    (case a of\n     SK_IPC dir WAIT partner page \\<Rightarrow>\n       \\<not> ipc_precondition partner (opposite_ipc_direction dir) tid\n               (Eps rinvariant) \\<down> s\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_WAIT EV_WAIT x \\<Rightarrow>\n         ev_counter (thread \\<down> s tid) = 0\n     | SK_EV_WAIT _ x \\<Rightarrow> False | _ \\<Rightarrow> False)", "by(auto split: int_point_t.splits ipc_stage_t.splits ev_wait_stage_t.splits)"], ["proof (state)\nthis:\n  rwaiting (rcswitch n s) tid a = rwaiting s tid a\n\ngoal (1 subgoal):\n 1. \\<forall>n s. rwaiting (rcswitch n s) = rwaiting s", "}"], ["proof (state)\nthis:\n  rwaiting (rcswitch n s) ?tid2 ?a2 = rwaiting s ?tid2 ?a2\n\ngoal (1 subgoal):\n 1. \\<forall>n s. rwaiting (rcswitch n s) = rwaiting s", "hence \"rwaiting (rcswitch n s) = rwaiting s\""], ["proof (prove)\nusing this:\n  rwaiting (rcswitch n s) ?tid2 ?a2 = rwaiting s ?tid2 ?a2\n\ngoal (1 subgoal):\n 1. rwaiting (rcswitch n s) = rwaiting s", "by auto"], ["proof (state)\nthis:\n  rwaiting (rcswitch n s) = rwaiting s\n\ngoal (1 subgoal):\n 1. \\<forall>n s. rwaiting (rcswitch n s) = rwaiting s", "}"], ["proof (state)\nthis:\n  rwaiting (rcswitch ?n2 ?s2) = rwaiting ?s2\n\ngoal (1 subgoal):\n 1. \\<forall>n s. rwaiting (rcswitch n s) = rwaiting s", "thus ?thesis"], ["proof (prove)\nusing this:\n  rwaiting (rcswitch ?n2 ?s2) = rwaiting ?s2\n\ngoal (1 subgoal):\n 1. \\<forall>n s. rwaiting (rcswitch n s) = rwaiting s", "by auto"], ["proof (state)\nthis:\n  \\<forall>n s. rwaiting (rcswitch n s) = rwaiting s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aborting_after_IPC_step:\nassumes \"d1 \\<noteq> d2\"\nshows \"aborting (atomic_step_ipc d1 dir stage partner page s) d2 a = aborting s d2 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aborting (atomic_step_ipc d1 dir stage partner page s) d2 a =\n    aborting s d2 a", "unfolding atomic_step_ipc_def aborting_def set_object_value_def ipc_precondition_def\n          ev_signal_precondition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case a of\n     SK_IPC dira PREP partner pagea \\<Rightarrow>\n       \\<not> (let sender =\n                     case dira of SEND \\<Rightarrow> d2\n                     | RECV \\<Rightarrow> partner;\n                   receiver =\n                     case dira of SEND \\<Rightarrow> partner\n                     | RECV \\<Rightarrow> d2;\n                   local_access_mode =\n                     case dira of SEND \\<Rightarrow> READ\n                     | RECV \\<Rightarrow> WRITE\n               in sp_impl_subj_subj\n                   (case stage of\n                    BUF page' \\<Rightarrow>\n                      case dir of\n                      SEND \\<Rightarrow> s\n                        \\<lparr>obj := (obj s)\n                                  (PAGE page' := obj s (PAGE page))\\<rparr>\n                      | RECV \\<Rightarrow> s\n                    | _ \\<Rightarrow> s)\n                   (Step.partition sender) (Step.partition receiver) \\<and>\n                  sp_impl_subj_obj\n                   (case stage of\n                    BUF page' \\<Rightarrow>\n                      case dir of\n                      SEND \\<Rightarrow> s\n                        \\<lparr>obj := (obj s)\n                                  (PAGE page' := obj s (PAGE page))\\<rparr>\n                      | RECV \\<Rightarrow> s\n                    | _ \\<Rightarrow> s)\n                   (Step.partition d2) (PAGE pagea) local_access_mode)\n     | SK_IPC dira _ partner pagea \\<Rightarrow> False\n     | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n         \\<not> sp_impl_subj_subj\n                 (case stage of\n                  BUF page' \\<Rightarrow>\n                    case dir of\n                    SEND \\<Rightarrow> s\n                      \\<lparr>obj := (obj s)\n                                (PAGE page' := obj s (PAGE page))\\<rparr>\n                    | RECV \\<Rightarrow> s\n                  | _ \\<Rightarrow> s)\n                 (Step.partition d2) (Step.partition partner)\n     | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> False\n     | _ \\<Rightarrow> False) =\n    (case a of\n     SK_IPC dir PREP partner page \\<Rightarrow>\n       \\<not> (let sender =\n                     case dir of SEND \\<Rightarrow> d2\n                     | RECV \\<Rightarrow> partner;\n                   receiver =\n                     case dir of SEND \\<Rightarrow> partner\n                     | RECV \\<Rightarrow> d2;\n                   local_access_mode =\n                     case dir of SEND \\<Rightarrow> READ\n                     | RECV \\<Rightarrow> WRITE\n               in sp_impl_subj_subj s (Step.partition sender)\n                   (Step.partition receiver) \\<and>\n                  sp_impl_subj_obj s (Step.partition d2) (PAGE page)\n                   local_access_mode)\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n         \\<not> sp_impl_subj_subj s (Step.partition d2)\n                 (Step.partition partner)\n     | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> False\n     | _ \\<Rightarrow> False)", "by(auto split: int_point_t.splits ipc_stage_t.splits ipc_direction_t.splits\n                   ev_signal_stage_t.splits)"], ["", "lemma waiting_after_IPC_step:\nassumes \"d1 \\<noteq> d2\"\nshows \"waiting (atomic_step_ipc d1 dir stage partner page s) d2 a = waiting s d2 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. waiting (atomic_step_ipc d1 dir stage partner page s) d2 a =\n    waiting s d2 a", "unfolding atomic_step_ipc_def waiting_def set_object_value_def ipc_precondition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case a of\n     SK_IPC dira WAIT partner pagea \\<Rightarrow>\n       \\<not> (let sender =\n                     case opposite_ipc_direction dira of\n                     SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d2;\n                   receiver =\n                     case opposite_ipc_direction dira of\n                     SEND \\<Rightarrow> d2 | RECV \\<Rightarrow> partner;\n                   local_access_mode =\n                     case opposite_ipc_direction dira of\n                     SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n               in sp_impl_subj_subj\n                   (case stage of\n                    BUF page' \\<Rightarrow>\n                      case dir of\n                      SEND \\<Rightarrow> s\n                        \\<lparr>obj := (obj s)\n                                  (PAGE page' := obj s (PAGE page))\\<rparr>\n                      | RECV \\<Rightarrow> s\n                    | _ \\<Rightarrow> s)\n                   (Step.partition sender) (Step.partition receiver) \\<and>\n                  sp_impl_subj_obj\n                   (case stage of\n                    BUF page' \\<Rightarrow>\n                      case dir of\n                      SEND \\<Rightarrow> s\n                        \\<lparr>obj := (obj s)\n                                  (PAGE page' := obj s (PAGE page))\\<rparr>\n                      | RECV \\<Rightarrow> s\n                    | _ \\<Rightarrow> s)\n                   (Step.partition partner) (PAGE (Eps rinvariant))\n                   local_access_mode)\n     | SK_IPC dira _ partner pagea \\<Rightarrow> False\n     | SK_EV_WAIT EV_WAIT x \\<Rightarrow>\n         ev_counter\n          (thread\n            (case stage of\n             BUF page' \\<Rightarrow>\n               case dir of\n               SEND \\<Rightarrow> s\n                 \\<lparr>obj := (obj s)\n                           (PAGE page' := obj s (PAGE page))\\<rparr>\n               | RECV \\<Rightarrow> s\n             | _ \\<Rightarrow> s)\n            d2) =\n         0\n     | SK_EV_WAIT _ x \\<Rightarrow> False | _ \\<Rightarrow> False) =\n    (case a of\n     SK_IPC dir WAIT partner page \\<Rightarrow>\n       \\<not> (let sender =\n                     case opposite_ipc_direction dir of\n                     SEND \\<Rightarrow> partner | RECV \\<Rightarrow> d2;\n                   receiver =\n                     case opposite_ipc_direction dir of\n                     SEND \\<Rightarrow> d2 | RECV \\<Rightarrow> partner;\n                   local_access_mode =\n                     case opposite_ipc_direction dir of\n                     SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n               in sp_impl_subj_subj s (Step.partition sender)\n                   (Step.partition receiver) \\<and>\n                  sp_impl_subj_obj s (Step.partition partner)\n                   (PAGE (Eps rinvariant)) local_access_mode)\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_WAIT EV_WAIT x \\<Rightarrow> ev_counter (thread s d2) = 0\n     | SK_EV_WAIT _ x \\<Rightarrow> False | _ \\<Rightarrow> False)", "by(auto split: int_point_t.splits ipc_stage_t.splits ipc_direction_t.splits\n                   ev_wait_stage_t.splits)"], ["", "(*\nlemma raborting_after_step:\nshows \"\\<forall>s a d. rcurrent s \\<noteq> d \\<longrightarrow> raborting (rstep s a) d = raborting s d\"\nproof-\n{\n  fix s a d\n  assume not_curr: \"rcurrent s \\<noteq> d\"\n  {\n    fix a\n    have \"raborting (rstep s a) d = raborting s d\"\n      using not_curr aborting_after_IPC_step\n            rstate_invariant atomic_ipc_preserves_invariants\n      unfolding rcurrent_def  rstep_def atomic_step_def\n      by(auto split: int_point_t.splits)\n  }\n  hence \"raborting (rstep s a) d = raborting s d\" by auto\n}\nthus ?thesis by auto\nqed\n*)\n(*\nlemma rwaiting_after_step:\nshows \"\\<forall>s a d. rcurrent s \\<noteq> d \\<longrightarrow> rwaiting (rstep s a) d = rwaiting s d\"\nproof-\n{\n  fix s a d\n  assume not_curr: \"rcurrent s \\<noteq> d\"\n  {\n    fix a\n    have \"rwaiting (rstep s a) d = rwaiting s d\"\n      using not_curr waiting_after_IPC_step\n            rstate_invariant atomic_ipc_preserves_invariants\n      unfolding rcurrent_def  rstep_def atomic_step_def\n      by(auto split: int_point_t.splits)\n  }\n  hence \"rwaiting (rstep s a) d = rwaiting s d\" by auto\n}\nthus ?thesis by auto\nqed\n*)"], ["", "lemma raborting_consistent:\nshows \"\\<forall>s t u. rvpeq u s t \\<longrightarrow> raborting s u = raborting t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t u.\n       rvpeq u s t \\<longrightarrow> raborting s u = raborting t u", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s t u.\n       rvpeq u s t \\<longrightarrow> raborting s u = raborting t u", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s t u.\n       rvpeq u s t \\<longrightarrow> raborting s u = raborting t u", "fix s t u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s t u.\n       rvpeq u s t \\<longrightarrow> raborting s u = raborting t u", "assume vpeq: \"rvpeq u s t\""], ["proof (state)\nthis:\n  rvpeq u s t\n\ngoal (1 subgoal):\n 1. \\<forall>s t u.\n       rvpeq u s t \\<longrightarrow> raborting s u = raborting t u", "{"], ["proof (state)\nthis:\n  rvpeq u s t\n\ngoal (1 subgoal):\n 1. \\<forall>s t u.\n       rvpeq u s t \\<longrightarrow> raborting s u = raborting t u", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s t u.\n       rvpeq u s t \\<longrightarrow> raborting s u = raborting t u", "from vpeq ipc_precondition_weakly_step_consistent rstate_invariant"], ["proof (chain)\npicking this:\n  rvpeq u s t\n  \\<lbrakk>vpeq (Step.partition ?tid) ?s1.0 ?s2.0;\n   atomic_step_invariant ?s1.0; atomic_step_invariant ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ipc_precondition ?tid ?dir ?partner ?page ?s1.0 =\n                    ipc_precondition ?tid ?dir ?partner ?page ?s2.0\n  atomic_step_invariant \\<down> ?s", "have \"\\<And> tid dir partner page . ipc_precondition u dir partner page (\\<down>s) \n                                    = ipc_precondition u dir partner page (\\<down>t)\""], ["proof (prove)\nusing this:\n  rvpeq u s t\n  \\<lbrakk>vpeq (Step.partition ?tid) ?s1.0 ?s2.0;\n   atomic_step_invariant ?s1.0; atomic_step_invariant ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ipc_precondition ?tid ?dir ?partner ?page ?s1.0 =\n                    ipc_precondition ?tid ?dir ?partner ?page ?s2.0\n  atomic_step_invariant \\<down> ?s\n\ngoal (1 subgoal):\n 1. \\<And>tid dir partner page.\n       ipc_precondition u dir partner page \\<down> s =\n       ipc_precondition u dir partner page \\<down> t", "unfolding rvpeq_def"], ["proof (prove)\nusing this:\n  vpeq (Step.partition u) \\<down> s \\<down> t\n  \\<lbrakk>vpeq (Step.partition ?tid) ?s1.0 ?s2.0;\n   atomic_step_invariant ?s1.0; atomic_step_invariant ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ipc_precondition ?tid ?dir ?partner ?page ?s1.0 =\n                    ipc_precondition ?tid ?dir ?partner ?page ?s2.0\n  atomic_step_invariant \\<down> ?s\n\ngoal (1 subgoal):\n 1. \\<And>tid dir partner page.\n       ipc_precondition u dir partner page \\<down> s =\n       ipc_precondition u dir partner page \\<down> t", "by auto"], ["proof (state)\nthis:\n  ipc_precondition u ?dir ?partner ?page \\<down> s =\n  ipc_precondition u ?dir ?partner ?page \\<down> t\n\ngoal (1 subgoal):\n 1. \\<forall>s t u.\n       rvpeq u s t \\<longrightarrow> raborting s u = raborting t u", "with vpeq rstate_invariant"], ["proof (chain)\npicking this:\n  rvpeq u s t\n  atomic_step_invariant \\<down> ?s\n  ipc_precondition u ?dir ?partner ?page \\<down> s =\n  ipc_precondition u ?dir ?partner ?page \\<down> t", "have \"raborting s u a = raborting t u a\""], ["proof (prove)\nusing this:\n  rvpeq u s t\n  atomic_step_invariant \\<down> ?s\n  ipc_precondition u ?dir ?partner ?page \\<down> s =\n  ipc_precondition u ?dir ?partner ?page \\<down> t\n\ngoal (1 subgoal):\n 1. raborting s u a = raborting t u a", "unfolding aborting_def rvpeq_def vpeq_def vpeq_local_def ev_signal_precondition_def\n               vpeq_subj_subj_def atomic_step_invariant_def sp_subset_def rep_def"], ["proof (prove)\nusing this:\n  vpeq_obj (Step.partition u) (Rep_rstate_t s) (Rep_rstate_t t) \\<and>\n  (\\<forall>v.\n      (Policy.sp_spec_subj_subj (Step.partition u) v \\<longrightarrow>\n       sp_impl_subj_subj (Rep_rstate_t s) (Step.partition u) v =\n       sp_impl_subj_subj (Rep_rstate_t t) (Step.partition u) v) \\<and>\n      (Policy.sp_spec_subj_subj v (Step.partition u) \\<longrightarrow>\n       sp_impl_subj_subj (Rep_rstate_t s) v (Step.partition u) =\n       sp_impl_subj_subj (Rep_rstate_t t) v (Step.partition u))) \\<and>\n  vpeq_subj_obj (Step.partition u) (Rep_rstate_t s) (Rep_rstate_t t) \\<and>\n  (\\<forall>tid.\n      Step.partition tid = Step.partition u \\<longrightarrow>\n      thread (Rep_rstate_t s) tid = thread (Rep_rstate_t t) tid)\n  (\\<forall>p1 p2.\n      sp_impl_subj_subj (Rep_rstate_t ?s) p1 p2 \\<longrightarrow>\n      Policy.sp_spec_subj_subj p1 p2) \\<and>\n  (\\<forall>p1 p2 m.\n      sp_impl_subj_obj (Rep_rstate_t ?s) p1 p2 m \\<longrightarrow>\n      Policy.sp_spec_subj_obj p1 p2 m)\n  ipc_precondition u ?dir ?partner ?page (Rep_rstate_t s) =\n  ipc_precondition u ?dir ?partner ?page (Rep_rstate_t t)\n\ngoal (1 subgoal):\n 1. (case a of\n     SK_IPC dir PREP partner page \\<Rightarrow>\n       \\<not> ipc_precondition u dir partner page (Rep_rstate_t s)\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n         \\<not> sp_impl_subj_subj (Rep_rstate_t s) (Step.partition u)\n                 (Step.partition partner)\n     | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> False\n     | _ \\<Rightarrow> False) =\n    (case a of\n     SK_IPC dir PREP partner page \\<Rightarrow>\n       \\<not> ipc_precondition u dir partner page (Rep_rstate_t t)\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n         \\<not> sp_impl_subj_subj (Rep_rstate_t t) (Step.partition u)\n                 (Step.partition partner)\n     | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> False\n     | _ \\<Rightarrow> False)", "apply (auto split: int_point_t.splits ipc_stage_t.splits ev_signal_stage_t.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x32.\n       \\<lbrakk>\\<And>s.\n                   (\\<forall>p1 p2.\n                       sp_impl_subj_subj (Rep_rstate_t s) p1\n                        p2 \\<longrightarrow>\n                       Policy.sp_spec_subj_subj p1 p2) \\<and>\n                   (\\<forall>p1 p2 m.\n                       sp_impl_subj_obj (Rep_rstate_t s) p1 p2\n                        m \\<longrightarrow>\n                       Policy.sp_spec_subj_obj p1 p2 m);\n        \\<And>dir partner page.\n           ipc_precondition u dir partner page (Rep_rstate_t s) =\n           ipc_precondition u dir partner page (Rep_rstate_t t);\n        vpeq_obj (Step.partition u) (Rep_rstate_t s) (Rep_rstate_t t);\n        \\<forall>v.\n           (Policy.sp_spec_subj_subj (Step.partition u) v \\<longrightarrow>\n            sp_impl_subj_subj (Rep_rstate_t s) (Step.partition u) v =\n            sp_impl_subj_subj (Rep_rstate_t t) (Step.partition u) v) \\<and>\n           (Policy.sp_spec_subj_subj v (Step.partition u) \\<longrightarrow>\n            sp_impl_subj_subj (Rep_rstate_t s) v (Step.partition u) =\n            sp_impl_subj_subj (Rep_rstate_t t) v (Step.partition u));\n        vpeq_subj_obj (Step.partition u) (Rep_rstate_t s) (Rep_rstate_t t);\n        \\<forall>tid.\n           Step.partition tid = Step.partition u \\<longrightarrow>\n           thread (Rep_rstate_t s) tid = thread (Rep_rstate_t t) tid;\n        a = SK_EV_SIGNAL EV_SIGNAL_PREP x32;\n        sp_impl_subj_subj (Rep_rstate_t s) (Step.partition u)\n         (Step.partition x32)\\<rbrakk>\n       \\<Longrightarrow> sp_impl_subj_subj (Rep_rstate_t t)\n                          (Step.partition u) (Step.partition x32)", "by blast"], ["proof (state)\nthis:\n  raborting s u a = raborting t u a\n\ngoal (1 subgoal):\n 1. \\<forall>s t u.\n       rvpeq u s t \\<longrightarrow> raborting s u = raborting t u", "}"], ["proof (state)\nthis:\n  raborting s u ?a2 = raborting t u ?a2\n\ngoal (1 subgoal):\n 1. \\<forall>s t u.\n       rvpeq u s t \\<longrightarrow> raborting s u = raborting t u", "hence \"raborting s u = raborting t u\""], ["proof (prove)\nusing this:\n  raborting s u ?a2 = raborting t u ?a2\n\ngoal (1 subgoal):\n 1. raborting s u = raborting t u", "by auto"], ["proof (state)\nthis:\n  raborting s u = raborting t u\n\ngoal (1 subgoal):\n 1. \\<forall>s t u.\n       rvpeq u s t \\<longrightarrow> raborting s u = raborting t u", "}"], ["proof (state)\nthis:\n  rvpeq ?u2 ?s2 ?t2 \\<Longrightarrow> raborting ?s2 ?u2 = raborting ?t2 ?u2\n\ngoal (1 subgoal):\n 1. \\<forall>s t u.\n       rvpeq u s t \\<longrightarrow> raborting s u = raborting t u", "thus ?thesis"], ["proof (prove)\nusing this:\n  rvpeq ?u2 ?s2 ?t2 \\<Longrightarrow> raborting ?s2 ?u2 = raborting ?t2 ?u2\n\ngoal (1 subgoal):\n 1. \\<forall>s t u.\n       rvpeq u s t \\<longrightarrow> raborting s u = raborting t u", "by auto"], ["proof (state)\nthis:\n  \\<forall>s t u.\n     rvpeq u s t \\<longrightarrow> raborting s u = raborting t u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aborting_dom_independent:\n  assumes \"rcurrent s \\<noteq> d\"\n    shows \"raborting (rstep s a) d a' = raborting s d a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. raborting (rstep s a) d a' = raborting s d a'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. raborting (rstep s a) d a' = raborting s d a'", "have \"\\<And> tid dir partner page s . ipc_precondition tid dir partner page s = ipc_precondition tid dir partner page (atomic_step s a)\n                                   \\<and> ev_signal_precondition tid partner  s = ev_signal_precondition tid partner (atomic_step s a)\n       \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tid dir partner page s.\n       ipc_precondition tid dir partner page s =\n       ipc_precondition tid dir partner page (atomic_step s a) \\<and>\n       ev_signal_precondition tid partner s =\n       ev_signal_precondition tid partner (atomic_step s a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tid dir partner page s.\n       ipc_precondition tid dir partner page s =\n       ipc_precondition tid dir partner page (atomic_step s a) \\<and>\n       ev_signal_precondition tid partner s =\n       ev_signal_precondition tid partner (atomic_step s a)", "fix tid dir partner page s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tid dir partner page s.\n       ipc_precondition tid dir partner page s =\n       ipc_precondition tid dir partner page (atomic_step s a) \\<and>\n       ev_signal_precondition tid partner s =\n       ev_signal_precondition tid partner (atomic_step s a)", "let ?s = \"atomic_step s a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tid dir partner page s.\n       ipc_precondition tid dir partner page s =\n       ipc_precondition tid dir partner page (atomic_step s a) \\<and>\n       ev_signal_precondition tid partner s =\n       ev_signal_precondition tid partner (atomic_step s a)", "have \"(\\<forall> p q . sp_impl_subj_subj s p q = sp_impl_subj_subj ?s p q)\n       \\<and> (\\<forall> p x m . sp_impl_subj_obj s p x m = sp_impl_subj_obj ?s p x m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p q.\n        sp_impl_subj_subj s p q =\n        sp_impl_subj_subj (atomic_step s a) p q) \\<and>\n    (\\<forall>p x m.\n        sp_impl_subj_obj s p x m = sp_impl_subj_obj (atomic_step s a) p x m)", "unfolding atomic_step_def atomic_step_ipc_def\n               atomic_step_ev_wait_all_def atomic_step_ev_wait_one_def\n               atomic_step_ev_signal_def set_object_value_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p q.\n        sp_impl_subj_subj s p q =\n        sp_impl_subj_subj\n         (case a of\n          SK_IPC SEND (BUF page') partner page \\<Rightarrow> s\n            \\<lparr>obj := (obj s)(PAGE page' := obj s (PAGE page))\\<rparr>\n          | SK_IPC RECV (BUF page') partner page \\<Rightarrow> s\n          | SK_IPC dir _ partner page \\<Rightarrow> s\n          | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow> s\n              \\<lparr>thread := (thread s)\n                        (current s := thread s (current s)\n                           \\<lparr>ev_counter := 0\\<rparr>)\\<rparr>\n          | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow> s\n              \\<lparr>thread := (thread s)\n                        (current s := thread s (current s)\n                           \\<lparr>ev_counter :=\n                                     ev_counter (thread s (current s)) -\n                                     1\\<rparr>)\\<rparr>\n          | SK_EV_WAIT _ consume \\<Rightarrow> s\n          | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> s\n          | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> s\n              \\<lparr>thread := (thread s)\n                        (partner := thread s partner\n                           \\<lparr>ev_counter :=\n                                     Suc\n(ev_counter (thread s partner))\\<rparr>)\\<rparr>\n          | NONE \\<Rightarrow> s)\n         p q) \\<and>\n    (\\<forall>p x m.\n        sp_impl_subj_obj s p x m =\n        sp_impl_subj_obj\n         (case a of\n          SK_IPC SEND (BUF page') partner page \\<Rightarrow> s\n            \\<lparr>obj := (obj s)(PAGE page' := obj s (PAGE page))\\<rparr>\n          | SK_IPC RECV (BUF page') partner page \\<Rightarrow> s\n          | SK_IPC dir _ partner page \\<Rightarrow> s\n          | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow> s\n              \\<lparr>thread := (thread s)\n                        (current s := thread s (current s)\n                           \\<lparr>ev_counter := 0\\<rparr>)\\<rparr>\n          | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow> s\n              \\<lparr>thread := (thread s)\n                        (current s := thread s (current s)\n                           \\<lparr>ev_counter :=\n                                     ev_counter (thread s (current s)) -\n                                     1\\<rparr>)\\<rparr>\n          | SK_EV_WAIT _ consume \\<Rightarrow> s\n          | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> s\n          | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> s\n              \\<lparr>thread := (thread s)\n                        (partner := thread s partner\n                           \\<lparr>ev_counter :=\n                                     Suc\n(ev_counter (thread s partner))\\<rparr>)\\<rparr>\n          | NONE \\<Rightarrow> s)\n         p x m)", "by (auto split: int_point_t.splits ipc_stage_t.splits ipc_direction_t.splits\n          ev_wait_stage_t.splits ev_consume_t.splits  ev_signal_stage_t.splits)"], ["proof (state)\nthis:\n  (\\<forall>p q.\n      sp_impl_subj_subj s p q =\n      sp_impl_subj_subj (atomic_step s a) p q) \\<and>\n  (\\<forall>p x m.\n      sp_impl_subj_obj s p x m = sp_impl_subj_obj (atomic_step s a) p x m)\n\ngoal (1 subgoal):\n 1. \\<And>tid dir partner page s.\n       ipc_precondition tid dir partner page s =\n       ipc_precondition tid dir partner page (atomic_step s a) \\<and>\n       ev_signal_precondition tid partner s =\n       ev_signal_precondition tid partner (atomic_step s a)", "thus \"ipc_precondition tid dir partner page s = ipc_precondition tid dir partner page (atomic_step s a)\n         \\<and> ev_signal_precondition tid partner  s = ev_signal_precondition tid partner (atomic_step s a)\""], ["proof (prove)\nusing this:\n  (\\<forall>p q.\n      sp_impl_subj_subj s p q =\n      sp_impl_subj_subj (atomic_step s a) p q) \\<and>\n  (\\<forall>p x m.\n      sp_impl_subj_obj s p x m = sp_impl_subj_obj (atomic_step s a) p x m)\n\ngoal (1 subgoal):\n 1. ipc_precondition tid dir partner page s =\n    ipc_precondition tid dir partner page (atomic_step s a) \\<and>\n    ev_signal_precondition tid partner s =\n    ev_signal_precondition tid partner (atomic_step s a)", "unfolding ipc_precondition_def ev_signal_precondition_def"], ["proof (prove)\nusing this:\n  (\\<forall>p q.\n      sp_impl_subj_subj s p q =\n      sp_impl_subj_subj (atomic_step s a) p q) \\<and>\n  (\\<forall>p x m.\n      sp_impl_subj_obj s p x m = sp_impl_subj_obj (atomic_step s a) p x m)\n\ngoal (1 subgoal):\n 1. (let sender =\n           case dir of SEND \\<Rightarrow> tid | RECV \\<Rightarrow> partner;\n         receiver =\n           case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> tid;\n         local_access_mode =\n           case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n     in sp_impl_subj_subj s (Step.partition sender)\n         (Step.partition receiver) \\<and>\n        sp_impl_subj_obj s (Step.partition tid) (PAGE page)\n         local_access_mode) =\n    (let sender =\n           case dir of SEND \\<Rightarrow> tid | RECV \\<Rightarrow> partner;\n         receiver =\n           case dir of SEND \\<Rightarrow> partner | RECV \\<Rightarrow> tid;\n         local_access_mode =\n           case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n     in sp_impl_subj_subj (atomic_step s a) (Step.partition sender)\n         (Step.partition receiver) \\<and>\n        sp_impl_subj_obj (atomic_step s a) (Step.partition tid) (PAGE page)\n         local_access_mode) \\<and>\n    sp_impl_subj_subj s (Step.partition tid) (Step.partition partner) =\n    sp_impl_subj_subj (atomic_step s a) (Step.partition tid)\n     (Step.partition partner)", "by simp"], ["proof (state)\nthis:\n  ipc_precondition tid dir partner page s =\n  ipc_precondition tid dir partner page (atomic_step s a) \\<and>\n  ev_signal_precondition tid partner s =\n  ev_signal_precondition tid partner (atomic_step s a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipc_precondition ?tid ?dir ?partner ?page ?s =\n  ipc_precondition ?tid ?dir ?partner ?page (atomic_step ?s a) \\<and>\n  ev_signal_precondition ?tid ?partner ?s =\n  ev_signal_precondition ?tid ?partner (atomic_step ?s a)\n\ngoal (1 subgoal):\n 1. raborting (rstep s a) d a' = raborting s d a'", "moreover"], ["proof (state)\nthis:\n  ipc_precondition ?tid ?dir ?partner ?page ?s =\n  ipc_precondition ?tid ?dir ?partner ?page (atomic_step ?s a) \\<and>\n  ev_signal_precondition ?tid ?partner ?s =\n  ev_signal_precondition ?tid ?partner (atomic_step ?s a)\n\ngoal (1 subgoal):\n 1. raborting (rstep s a) d a' = raborting s d a'", "have \"\\<And> b . (\\<down>(\\<up>(atomic_step (\\<down>s) b))) = atomic_step (\\<down>s) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. \\<down> \\<up> atomic_step \\<down> s b = atomic_step \\<down> s b", "using rstate_invariant atomic_step_preserves_invariants rstate_up_down"], ["proof (prove)\nusing this:\n  atomic_step_invariant \\<down> ?s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (atomic_step ?s ?a)\n  atomic_step_invariant ?s \\<Longrightarrow> \\<down> \\<up> ?s = ?s\n\ngoal (1 subgoal):\n 1. \\<And>b. \\<down> \\<up> atomic_step \\<down> s b = atomic_step \\<down> s b", "by auto"], ["proof (state)\nthis:\n  \\<down> \\<up> atomic_step \\<down> s ?b = atomic_step \\<down> s ?b\n\ngoal (1 subgoal):\n 1. raborting (rstep s a) d a' = raborting s d a'", "ultimately"], ["proof (chain)\npicking this:\n  ipc_precondition ?tid ?dir ?partner ?page ?s =\n  ipc_precondition ?tid ?dir ?partner ?page (atomic_step ?s a) \\<and>\n  ev_signal_precondition ?tid ?partner ?s =\n  ev_signal_precondition ?tid ?partner (atomic_step ?s a)\n  \\<down> \\<up> atomic_step \\<down> s ?b = atomic_step \\<down> s ?b", "show ?thesis"], ["proof (prove)\nusing this:\n  ipc_precondition ?tid ?dir ?partner ?page ?s =\n  ipc_precondition ?tid ?dir ?partner ?page (atomic_step ?s a) \\<and>\n  ev_signal_precondition ?tid ?partner ?s =\n  ev_signal_precondition ?tid ?partner (atomic_step ?s a)\n  \\<down> \\<up> atomic_step \\<down> s ?b = atomic_step \\<down> s ?b\n\ngoal (1 subgoal):\n 1. raborting (rstep s a) d a' = raborting s d a'", "unfolding aborting_def rstep_def ev_signal_precondition_def"], ["proof (prove)\nusing this:\n  ipc_precondition ?tid ?dir ?partner ?page ?s =\n  ipc_precondition ?tid ?dir ?partner ?page (atomic_step ?s a) \\<and>\n  sp_impl_subj_subj ?s (Step.partition ?tid) (Step.partition ?partner) =\n  sp_impl_subj_subj (atomic_step ?s a) (Step.partition ?tid)\n   (Step.partition ?partner)\n  \\<down> \\<up> atomic_step \\<down> s ?b = atomic_step \\<down> s ?b\n\ngoal (1 subgoal):\n 1. (case a' of\n     SK_IPC dir PREP partner page \\<Rightarrow>\n       \\<not> ipc_precondition d dir partner page\n               \\<down> \\<up> atomic_step \\<down> s a\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n         \\<not> sp_impl_subj_subj \\<down> \\<up> atomic_step \\<down> s a\n                 (Step.partition d) (Step.partition partner)\n     | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> False\n     | _ \\<Rightarrow> False) =\n    (case a' of\n     SK_IPC dir PREP partner page \\<Rightarrow>\n       \\<not> ipc_precondition d dir partner page \\<down> s\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow>\n         \\<not> sp_impl_subj_subj \\<down> s (Step.partition d)\n                 (Step.partition partner)\n     | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> False\n     | _ \\<Rightarrow> False)", "by (simp split: int_point_t.splits ipc_stage_t.splits ev_wait_stage_t.splits\n                        ev_signal_stage_t.splits)"], ["proof (state)\nthis:\n  raborting (rstep s a) d a' = raborting s d a'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipc_precondition_of_partner_consistent:\nassumes vpeq: \"\\<forall> d \\<in> rkinvolved (SK_IPC dir WAIT partner page) . rvpeq d s t\"\nshows \"ipc_precondition partner dir' u page' (\\<down> s) =  ipc_precondition partner dir' u page' \\<down> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipc_precondition partner dir' u page' \\<down> s =\n    ipc_precondition partner dir' u page' \\<down> t", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ipc_precondition partner dir' u page' \\<down> s =\n    ipc_precondition partner dir' u page' \\<down> t", "from assms ipc_precondition_weakly_step_consistent rstate_invariant"], ["proof (chain)\npicking this:\n  \\<forall>d\\<in>rkinvolved (SK_IPC dir WAIT partner page). rvpeq d s t\n  \\<lbrakk>vpeq (Step.partition ?tid) ?s1.0 ?s2.0;\n   atomic_step_invariant ?s1.0; atomic_step_invariant ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ipc_precondition ?tid ?dir ?partner ?page ?s1.0 =\n                    ipc_precondition ?tid ?dir ?partner ?page ?s2.0\n  atomic_step_invariant \\<down> ?s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>d\\<in>rkinvolved (SK_IPC dir WAIT partner page). rvpeq d s t\n  \\<lbrakk>vpeq (Step.partition ?tid) ?s1.0 ?s2.0;\n   atomic_step_invariant ?s1.0; atomic_step_invariant ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ipc_precondition ?tid ?dir ?partner ?page ?s1.0 =\n                    ipc_precondition ?tid ?dir ?partner ?page ?s2.0\n  atomic_step_invariant \\<down> ?s\n\ngoal (1 subgoal):\n 1. ipc_precondition partner dir' u page' \\<down> s =\n    ipc_precondition partner dir' u page' \\<down> t", "unfolding rvpeq_def rkinvolved_def"], ["proof (prove)\nusing this:\n  \\<forall>d\\<in>case SK_IPC dir WAIT partner page of\n                 SK_IPC dir WAIT partner page \\<Rightarrow> {partner}\n                 | SK_IPC dir _ partner page \\<Rightarrow> {}\n                 | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> {}\n                 | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                     {partner}\n                 | _ \\<Rightarrow> {}.\n     vpeq (Step.partition d) \\<down> s \\<down> t\n  \\<lbrakk>vpeq (Step.partition ?tid) ?s1.0 ?s2.0;\n   atomic_step_invariant ?s1.0; atomic_step_invariant ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ipc_precondition ?tid ?dir ?partner ?page ?s1.0 =\n                    ipc_precondition ?tid ?dir ?partner ?page ?s2.0\n  atomic_step_invariant \\<down> ?s\n\ngoal (1 subgoal):\n 1. ipc_precondition partner dir' u page' \\<down> s =\n    ipc_precondition partner dir' u page' \\<down> t", "by auto"], ["proof (state)\nthis:\n  ipc_precondition partner dir' u page' \\<down> s =\n  ipc_precondition partner dir' u page' \\<down> t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ev_signal_precondition_of_partner_consistent:\nassumes vpeq: \"\\<forall> d \\<in> rkinvolved (SK_EV_SIGNAL EV_SIGNAL_FINISH partner) . rvpeq d s t\"\nshows \"ev_signal_precondition partner u (\\<down> s) =  ev_signal_precondition partner u (\\<down> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev_signal_precondition partner u \\<down> s =\n    ev_signal_precondition partner u \\<down> t", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ev_signal_precondition partner u \\<down> s =\n    ev_signal_precondition partner u \\<down> t", "from assms ev_signal_precondition_weakly_step_consistent rstate_invariant"], ["proof (chain)\npicking this:\n  \\<forall>d\\<in>rkinvolved (SK_EV_SIGNAL EV_SIGNAL_FINISH partner).\n     rvpeq d s t\n  \\<lbrakk>vpeq (Step.partition ?tid) ?s1.0 ?s2.0;\n   atomic_step_invariant ?s1.0; atomic_step_invariant ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ev_signal_precondition ?tid ?partner ?s1.0 =\n                    ev_signal_precondition ?tid ?partner ?s2.0\n  atomic_step_invariant \\<down> ?s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>d\\<in>rkinvolved (SK_EV_SIGNAL EV_SIGNAL_FINISH partner).\n     rvpeq d s t\n  \\<lbrakk>vpeq (Step.partition ?tid) ?s1.0 ?s2.0;\n   atomic_step_invariant ?s1.0; atomic_step_invariant ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ev_signal_precondition ?tid ?partner ?s1.0 =\n                    ev_signal_precondition ?tid ?partner ?s2.0\n  atomic_step_invariant \\<down> ?s\n\ngoal (1 subgoal):\n 1. ev_signal_precondition partner u \\<down> s =\n    ev_signal_precondition partner u \\<down> t", "unfolding rvpeq_def rkinvolved_def"], ["proof (prove)\nusing this:\n  \\<forall>d\\<in>case SK_EV_SIGNAL EV_SIGNAL_FINISH partner of\n                 SK_IPC dir WAIT partner page \\<Rightarrow> {partner}\n                 | SK_IPC dir _ partner page \\<Rightarrow> {}\n                 | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> {}\n                 | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                     {partner}\n                 | _ \\<Rightarrow> {}.\n     vpeq (Step.partition d) \\<down> s \\<down> t\n  \\<lbrakk>vpeq (Step.partition ?tid) ?s1.0 ?s2.0;\n   atomic_step_invariant ?s1.0; atomic_step_invariant ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ev_signal_precondition ?tid ?partner ?s1.0 =\n                    ev_signal_precondition ?tid ?partner ?s2.0\n  atomic_step_invariant \\<down> ?s\n\ngoal (1 subgoal):\n 1. ev_signal_precondition partner u \\<down> s =\n    ev_signal_precondition partner u \\<down> t", "by auto"], ["proof (state)\nthis:\n  ev_signal_precondition partner u \\<down> s =\n  ev_signal_precondition partner u \\<down> t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma waiting_consistent:\nshows \"\\<forall>s t u a . rvpeq (rcurrent s) s t \\<and> (\\<forall> d \\<in> rkinvolved a . rvpeq d s t) \n        \\<and> rvpeq u s t\n        \\<longrightarrow> rwaiting s u a = rwaiting t u a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t u a.\n       rvpeq (rcurrent s) s t \\<and>\n       (\\<forall>d\\<in>rkinvolved a. rvpeq d s t) \\<and>\n       rvpeq u s t \\<longrightarrow>\n       rwaiting s u a = rwaiting t u a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s t u a.\n       rvpeq (rcurrent s) s t \\<and>\n       (\\<forall>d\\<in>rkinvolved a. rvpeq d s t) \\<and>\n       rvpeq u s t \\<longrightarrow>\n       rwaiting s u a = rwaiting t u a", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s t u a.\n       rvpeq (rcurrent s) s t \\<and>\n       (\\<forall>d\\<in>rkinvolved a. rvpeq d s t) \\<and>\n       rvpeq u s t \\<longrightarrow>\n       rwaiting s u a = rwaiting t u a", "fix s t u a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s t u a.\n       rvpeq (rcurrent s) s t \\<and>\n       (\\<forall>d\\<in>rkinvolved a. rvpeq d s t) \\<and>\n       rvpeq u s t \\<longrightarrow>\n       rwaiting s u a = rwaiting t u a", "assume vpeq: \"rvpeq (rcurrent s) s t\""], ["proof (state)\nthis:\n  rvpeq (rcurrent s) s t\n\ngoal (1 subgoal):\n 1. \\<forall>s t u a.\n       rvpeq (rcurrent s) s t \\<and>\n       (\\<forall>d\\<in>rkinvolved a. rvpeq d s t) \\<and>\n       rvpeq u s t \\<longrightarrow>\n       rwaiting s u a = rwaiting t u a", "assume vpeq_involved: \"\\<forall> d \\<in> rkinvolved a . rvpeq d s t\""], ["proof (state)\nthis:\n  \\<forall>d\\<in>rkinvolved a. rvpeq d s t\n\ngoal (1 subgoal):\n 1. \\<forall>s t u a.\n       rvpeq (rcurrent s) s t \\<and>\n       (\\<forall>d\\<in>rkinvolved a. rvpeq d s t) \\<and>\n       rvpeq u s t \\<longrightarrow>\n       rwaiting s u a = rwaiting t u a", "assume vpeq_u: \"rvpeq u s t\""], ["proof (state)\nthis:\n  rvpeq u s t\n\ngoal (1 subgoal):\n 1. \\<forall>s t u a.\n       rvpeq (rcurrent s) s t \\<and>\n       (\\<forall>d\\<in>rkinvolved a. rvpeq d s t) \\<and>\n       rvpeq u s t \\<longrightarrow>\n       rwaiting s u a = rwaiting t u a", "have \"rwaiting s u a = rwaiting t u a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwaiting s u a = rwaiting t u a", "proof (cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       a = SK_IPC x11 x12 x13 x14 \\<Longrightarrow>\n       rwaiting s u a = rwaiting t u a\n 2. \\<And>x21 x22.\n       a = SK_EV_WAIT x21 x22 \\<Longrightarrow>\n       rwaiting s u a = rwaiting t u a\n 3. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       rwaiting s u a = rwaiting t u a\n 4. a = NONE \\<Longrightarrow> rwaiting s u a = rwaiting t u a", "case SK_IPC"], ["proof (state)\nthis:\n  a = SK_IPC x11_ x12_ x13_ x14_\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       a = SK_IPC x11 x12 x13 x14 \\<Longrightarrow>\n       rwaiting s u a = rwaiting t u a\n 2. \\<And>x21 x22.\n       a = SK_EV_WAIT x21 x22 \\<Longrightarrow>\n       rwaiting s u a = rwaiting t u a\n 3. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       rwaiting s u a = rwaiting t u a\n 4. a = NONE \\<Longrightarrow> rwaiting s u a = rwaiting t u a", "thus \"rwaiting s u a = rwaiting t u a\""], ["proof (prove)\nusing this:\n  a = SK_IPC x11_ x12_ x13_ x14_\n\ngoal (1 subgoal):\n 1. rwaiting s u a = rwaiting t u a", "using ipc_precondition_of_partner_consistent vpeq_involved"], ["proof (prove)\nusing this:\n  a = SK_IPC x11_ x12_ x13_ x14_\n  \\<forall>d\\<in>rkinvolved (SK_IPC ?dir WAIT ?partner ?page).\n     rvpeq d ?s ?t \\<Longrightarrow>\n  ipc_precondition ?partner ?dir' ?u ?page' \\<down> ?s =\n  ipc_precondition ?partner ?dir' ?u ?page' \\<down> ?t\n  \\<forall>d\\<in>rkinvolved a. rvpeq d s t\n\ngoal (1 subgoal):\n 1. rwaiting s u a = rwaiting t u a", "unfolding waiting_def"], ["proof (prove)\nusing this:\n  a = SK_IPC x11_ x12_ x13_ x14_\n  \\<forall>d\\<in>rkinvolved (SK_IPC ?dir WAIT ?partner ?page).\n     rvpeq d ?s ?t \\<Longrightarrow>\n  ipc_precondition ?partner ?dir' ?u ?page' \\<down> ?s =\n  ipc_precondition ?partner ?dir' ?u ?page' \\<down> ?t\n  \\<forall>d\\<in>rkinvolved a. rvpeq d s t\n\ngoal (1 subgoal):\n 1. (case a of\n     SK_IPC dir WAIT partner page \\<Rightarrow>\n       \\<not> ipc_precondition partner (opposite_ipc_direction dir) u\n               (Eps rinvariant) \\<down> s\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_WAIT EV_WAIT x \\<Rightarrow>\n         ev_counter (thread \\<down> s u) = 0\n     | SK_EV_WAIT _ x \\<Rightarrow> False | _ \\<Rightarrow> False) =\n    (case a of\n     SK_IPC dir WAIT partner page \\<Rightarrow>\n       \\<not> ipc_precondition partner (opposite_ipc_direction dir) u\n               (Eps rinvariant) \\<down> t\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_WAIT EV_WAIT x \\<Rightarrow>\n         ev_counter (thread \\<down> t u) = 0\n     | SK_EV_WAIT _ x \\<Rightarrow> False | _ \\<Rightarrow> False)", "by (auto split: ipc_stage_t.splits)"], ["proof (state)\nthis:\n  rwaiting s u a = rwaiting t u a\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       a = SK_EV_WAIT x21 x22 \\<Longrightarrow>\n       rwaiting s u a = rwaiting t u a\n 2. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       rwaiting s u a = rwaiting t u a\n 3. a = NONE \\<Longrightarrow> rwaiting s u a = rwaiting t u a", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       a = SK_EV_WAIT x21 x22 \\<Longrightarrow>\n       rwaiting s u a = rwaiting t u a\n 2. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       rwaiting s u a = rwaiting t u a\n 3. a = NONE \\<Longrightarrow> rwaiting s u a = rwaiting t u a", "case SK_EV_WAIT"], ["proof (state)\nthis:\n  a = SK_EV_WAIT x21_ x22_\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       a = SK_EV_WAIT x21 x22 \\<Longrightarrow>\n       rwaiting s u a = rwaiting t u a\n 2. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       rwaiting s u a = rwaiting t u a\n 3. a = NONE \\<Longrightarrow> rwaiting s u a = rwaiting t u a", "thus \"rwaiting s u a = rwaiting t u a\""], ["proof (prove)\nusing this:\n  a = SK_EV_WAIT x21_ x22_\n\ngoal (1 subgoal):\n 1. rwaiting s u a = rwaiting t u a", "using ev_signal_precondition_of_partner_consistent\n        vpeq_involved vpeq vpeq_u"], ["proof (prove)\nusing this:\n  a = SK_EV_WAIT x21_ x22_\n  \\<forall>d\\<in>rkinvolved (SK_EV_SIGNAL EV_SIGNAL_FINISH ?partner).\n     rvpeq d ?s ?t \\<Longrightarrow>\n  ev_signal_precondition ?partner ?u \\<down> ?s =\n  ev_signal_precondition ?partner ?u \\<down> ?t\n  \\<forall>d\\<in>rkinvolved a. rvpeq d s t\n  rvpeq (rcurrent s) s t\n  rvpeq u s t\n\ngoal (1 subgoal):\n 1. rwaiting s u a = rwaiting t u a", "unfolding waiting_def rkinvolved_def ev_signal_precondition_def\n                  rvpeq_def vpeq_def vpeq_local_def"], ["proof (prove)\nusing this:\n  a = SK_EV_WAIT x21_ x22_\n  \\<forall>d\\<in>case SK_EV_SIGNAL EV_SIGNAL_FINISH ?partner of\n                 SK_IPC dir WAIT partner page \\<Rightarrow> {partner}\n                 | SK_IPC dir _ partner page \\<Rightarrow> {}\n                 | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> {}\n                 | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                     {partner}\n                 | _ \\<Rightarrow> {}.\n     vpeq_obj (Step.partition d) \\<down> ?s \\<down> ?t \\<and>\n     vpeq_subj_subj (Step.partition d) \\<down> ?s \\<down> ?t \\<and>\n     vpeq_subj_obj (Step.partition d) \\<down> ?s \\<down> ?t \\<and>\n     (\\<forall>tid.\n         Step.partition tid = Step.partition d \\<longrightarrow>\n         thread \\<down> ?s tid = thread \\<down> ?t tid) \\<Longrightarrow>\n  sp_impl_subj_subj \\<down> ?s (Step.partition ?partner)\n   (Step.partition ?u) =\n  sp_impl_subj_subj \\<down> ?t (Step.partition ?partner) (Step.partition ?u)\n  \\<forall>d\\<in>case a of\n                 SK_IPC dir WAIT partner page \\<Rightarrow> {partner}\n                 | SK_IPC dir _ partner page \\<Rightarrow> {}\n                 | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> {}\n                 | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                     {partner}\n                 | _ \\<Rightarrow> {}.\n     vpeq_obj (Step.partition d) \\<down> s \\<down> t \\<and>\n     vpeq_subj_subj (Step.partition d) \\<down> s \\<down> t \\<and>\n     vpeq_subj_obj (Step.partition d) \\<down> s \\<down> t \\<and>\n     (\\<forall>tid.\n         Step.partition tid = Step.partition d \\<longrightarrow>\n         thread \\<down> s tid = thread \\<down> t tid)\n  vpeq_obj (Step.partition (rcurrent s)) \\<down> s \\<down> t \\<and>\n  vpeq_subj_subj (Step.partition (rcurrent s)) \\<down> s \\<down> t \\<and>\n  vpeq_subj_obj (Step.partition (rcurrent s)) \\<down> s \\<down> t \\<and>\n  (\\<forall>tid.\n      Step.partition tid = Step.partition (rcurrent s) \\<longrightarrow>\n      thread \\<down> s tid = thread \\<down> t tid)\n  vpeq_obj (Step.partition u) \\<down> s \\<down> t \\<and>\n  vpeq_subj_subj (Step.partition u) \\<down> s \\<down> t \\<and>\n  vpeq_subj_obj (Step.partition u) \\<down> s \\<down> t \\<and>\n  (\\<forall>tid.\n      Step.partition tid = Step.partition u \\<longrightarrow>\n      thread \\<down> s tid = thread \\<down> t tid)\n\ngoal (1 subgoal):\n 1. (case a of\n     SK_IPC dir WAIT partner page \\<Rightarrow>\n       \\<not> ipc_precondition partner (opposite_ipc_direction dir) u\n               (Eps rinvariant) \\<down> s\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_WAIT EV_WAIT x \\<Rightarrow>\n         ev_counter (thread \\<down> s u) = 0\n     | SK_EV_WAIT _ x \\<Rightarrow> False | _ \\<Rightarrow> False) =\n    (case a of\n     SK_IPC dir WAIT partner page \\<Rightarrow>\n       \\<not> ipc_precondition partner (opposite_ipc_direction dir) u\n               (Eps rinvariant) \\<down> t\n     | SK_IPC dir _ partner page \\<Rightarrow> False\n     | SK_EV_WAIT EV_WAIT x \\<Rightarrow>\n         ev_counter (thread \\<down> t u) = 0\n     | SK_EV_WAIT _ x \\<Rightarrow> False | _ \\<Rightarrow> False)", "by (auto split: ipc_stage_t.splits ev_wait_stage_t.splits ev_consume_t.splits)"], ["proof (state)\nthis:\n  rwaiting s u a = rwaiting t u a\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       rwaiting s u a = rwaiting t u a\n 2. a = NONE \\<Longrightarrow> rwaiting s u a = rwaiting t u a", "qed (simp add: waiting_def, simp add: waiting_def)"], ["proof (state)\nthis:\n  rwaiting s u a = rwaiting t u a\n\ngoal (1 subgoal):\n 1. \\<forall>s t u a.\n       rvpeq (rcurrent s) s t \\<and>\n       (\\<forall>d\\<in>rkinvolved a. rvpeq d s t) \\<and>\n       rvpeq u s t \\<longrightarrow>\n       rwaiting s u a = rwaiting t u a", "}"], ["proof (state)\nthis:\n  \\<lbrakk>rvpeq (rcurrent ?s2) ?s2 ?t2;\n   \\<forall>d\\<in>rkinvolved ?a2. rvpeq d ?s2 ?t2;\n   rvpeq ?u2 ?s2 ?t2\\<rbrakk>\n  \\<Longrightarrow> rwaiting ?s2 ?u2 ?a2 = rwaiting ?t2 ?u2 ?a2\n\ngoal (1 subgoal):\n 1. \\<forall>s t u a.\n       rvpeq (rcurrent s) s t \\<and>\n       (\\<forall>d\\<in>rkinvolved a. rvpeq d s t) \\<and>\n       rvpeq u s t \\<longrightarrow>\n       rwaiting s u a = rwaiting t u a", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>rvpeq (rcurrent ?s2) ?s2 ?t2;\n   \\<forall>d\\<in>rkinvolved ?a2. rvpeq d ?s2 ?t2;\n   rvpeq ?u2 ?s2 ?t2\\<rbrakk>\n  \\<Longrightarrow> rwaiting ?s2 ?u2 ?a2 = rwaiting ?t2 ?u2 ?a2\n\ngoal (1 subgoal):\n 1. \\<forall>s t u a.\n       rvpeq (rcurrent s) s t \\<and>\n       (\\<forall>d\\<in>rkinvolved a. rvpeq d s t) \\<and>\n       rvpeq u s t \\<longrightarrow>\n       rwaiting s u a = rwaiting t u a", "by auto"], ["proof (state)\nthis:\n  \\<forall>s t u a.\n     rvpeq (rcurrent s) s t \\<and>\n     (\\<forall>d\\<in>rkinvolved a. rvpeq d s t) \\<and>\n     rvpeq u s t \\<longrightarrow>\n     rwaiting s u a = rwaiting t u a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipc_precondition_ensures_ifp:\nassumes \"ipc_precondition (current s) dir partner page s\"\n    and \"atomic_step_invariant s\"\nshows \"rifp partner (current s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rifp partner (current s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rifp partner (current s)", "let ?sp = \"\\<lambda> t1 t2 . Policy.sp_spec_subj_subj (partition t1) (partition t2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. rifp partner (current s)", "have \"?sp (current s) partner \\<or> ?sp partner (current s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Policy.sp_spec_subj_subj (Step.partition (current s))\n     (Step.partition partner) \\<or>\n    Policy.sp_spec_subj_subj (Step.partition partner)\n     (Step.partition (current s))", "using assms"], ["proof (prove)\nusing this:\n  ipc_precondition (current s) dir partner page s\n  atomic_step_invariant s\n\ngoal (1 subgoal):\n 1. Policy.sp_spec_subj_subj (Step.partition (current s))\n     (Step.partition partner) \\<or>\n    Policy.sp_spec_subj_subj (Step.partition partner)\n     (Step.partition (current s))", "unfolding ipc_precondition_def atomic_step_invariant_def sp_subset_def"], ["proof (prove)\nusing this:\n  let sender =\n        case dir of SEND \\<Rightarrow> current s\n        | RECV \\<Rightarrow> partner;\n      receiver =\n        case dir of SEND \\<Rightarrow> partner\n        | RECV \\<Rightarrow> current s;\n      local_access_mode =\n        case dir of SEND \\<Rightarrow> READ | RECV \\<Rightarrow> WRITE\n  in sp_impl_subj_subj s (Step.partition sender)\n      (Step.partition receiver) \\<and>\n     sp_impl_subj_obj s (Step.partition (current s)) (PAGE page)\n      local_access_mode\n  (\\<forall>p1 p2.\n      sp_impl_subj_subj s p1 p2 \\<longrightarrow>\n      Policy.sp_spec_subj_subj p1 p2) \\<and>\n  (\\<forall>p1 p2 m.\n      sp_impl_subj_obj s p1 p2 m \\<longrightarrow>\n      Policy.sp_spec_subj_obj p1 p2 m)\n\ngoal (1 subgoal):\n 1. Policy.sp_spec_subj_subj (Step.partition (current s))\n     (Step.partition partner) \\<or>\n    Policy.sp_spec_subj_subj (Step.partition partner)\n     (Step.partition (current s))", "by (cases dir, auto)"], ["proof (state)\nthis:\n  Policy.sp_spec_subj_subj (Step.partition (current s))\n   (Step.partition partner) \\<or>\n  Policy.sp_spec_subj_subj (Step.partition partner)\n   (Step.partition (current s))\n\ngoal (1 subgoal):\n 1. rifp partner (current s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Policy.sp_spec_subj_subj (Step.partition (current s))\n   (Step.partition partner) \\<or>\n  Policy.sp_spec_subj_subj (Step.partition partner)\n   (Step.partition (current s))\n\ngoal (1 subgoal):\n 1. rifp partner (current s)", "unfolding rifp_def"], ["proof (prove)\nusing this:\n  Policy.sp_spec_subj_subj (Step.partition (current s))\n   (Step.partition partner) \\<or>\n  Policy.sp_spec_subj_subj (Step.partition partner)\n   (Step.partition (current s))\n\ngoal (1 subgoal):\n 1. Policy.ifp (Step.partition partner) (Step.partition (current s))", "using Policy_properties.ifp_compatible_with_sp_spec"], ["proof (prove)\nusing this:\n  Policy.sp_spec_subj_subj (Step.partition (current s))\n   (Step.partition partner) \\<or>\n  Policy.sp_spec_subj_subj (Step.partition partner)\n   (Step.partition (current s))\n  \\<forall>a b.\n     Policy.sp_spec_subj_subj a b \\<longrightarrow>\n     Policy.ifp a b \\<and> Policy.ifp b a\n\ngoal (1 subgoal):\n 1. Policy.ifp (Step.partition partner) (Step.partition (current s))", "by auto"], ["proof (state)\nthis:\n  rifp partner (current s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ev_signal_precondition_ensures_ifp:\nassumes \"ev_signal_precondition (current s) partner s\"\n    and \"atomic_step_invariant s\"\nshows \"rifp partner (current s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rifp partner (current s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rifp partner (current s)", "let ?sp = \"\\<lambda> t1 t2 . Policy.sp_spec_subj_subj (partition t1) (partition t2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. rifp partner (current s)", "have \"?sp (current s) partner \\<or> ?sp partner (current s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Policy.sp_spec_subj_subj (Step.partition (current s))\n     (Step.partition partner) \\<or>\n    Policy.sp_spec_subj_subj (Step.partition partner)\n     (Step.partition (current s))", "using assms"], ["proof (prove)\nusing this:\n  ev_signal_precondition (current s) partner s\n  atomic_step_invariant s\n\ngoal (1 subgoal):\n 1. Policy.sp_spec_subj_subj (Step.partition (current s))\n     (Step.partition partner) \\<or>\n    Policy.sp_spec_subj_subj (Step.partition partner)\n     (Step.partition (current s))", "unfolding ev_signal_precondition_def atomic_step_invariant_def sp_subset_def"], ["proof (prove)\nusing this:\n  sp_impl_subj_subj s (Step.partition (current s)) (Step.partition partner)\n  (\\<forall>p1 p2.\n      sp_impl_subj_subj s p1 p2 \\<longrightarrow>\n      Policy.sp_spec_subj_subj p1 p2) \\<and>\n  (\\<forall>p1 p2 m.\n      sp_impl_subj_obj s p1 p2 m \\<longrightarrow>\n      Policy.sp_spec_subj_obj p1 p2 m)\n\ngoal (1 subgoal):\n 1. Policy.sp_spec_subj_subj (Step.partition (current s))\n     (Step.partition partner) \\<or>\n    Policy.sp_spec_subj_subj (Step.partition partner)\n     (Step.partition (current s))", "by (auto)"], ["proof (state)\nthis:\n  Policy.sp_spec_subj_subj (Step.partition (current s))\n   (Step.partition partner) \\<or>\n  Policy.sp_spec_subj_subj (Step.partition partner)\n   (Step.partition (current s))\n\ngoal (1 subgoal):\n 1. rifp partner (current s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Policy.sp_spec_subj_subj (Step.partition (current s))\n   (Step.partition partner) \\<or>\n  Policy.sp_spec_subj_subj (Step.partition partner)\n   (Step.partition (current s))\n\ngoal (1 subgoal):\n 1. rifp partner (current s)", "unfolding rifp_def"], ["proof (prove)\nusing this:\n  Policy.sp_spec_subj_subj (Step.partition (current s))\n   (Step.partition partner) \\<or>\n  Policy.sp_spec_subj_subj (Step.partition partner)\n   (Step.partition (current s))\n\ngoal (1 subgoal):\n 1. Policy.ifp (Step.partition partner) (Step.partition (current s))", "using Policy_properties.ifp_compatible_with_sp_spec"], ["proof (prove)\nusing this:\n  Policy.sp_spec_subj_subj (Step.partition (current s))\n   (Step.partition partner) \\<or>\n  Policy.sp_spec_subj_subj (Step.partition partner)\n   (Step.partition (current s))\n  \\<forall>a b.\n     Policy.sp_spec_subj_subj a b \\<longrightarrow>\n     Policy.ifp a b \\<and> Policy.ifp b a\n\ngoal (1 subgoal):\n 1. Policy.ifp (Step.partition partner) (Step.partition (current s))", "by auto"], ["proof (state)\nthis:\n  rifp partner (current s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma involved_ifp:\nshows \"\\<forall> s a . \\<forall> d \\<in> rkinvolved a . rprecondition s (rcurrent s) a \\<longrightarrow> rifp d (rcurrent s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       \\<forall>d\\<in>rkinvolved a.\n          rprecondition s (rcurrent s) a \\<longrightarrow>\n          rifp d (rcurrent s)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       \\<forall>d\\<in>rkinvolved a.\n          rprecondition s (rcurrent s) a \\<longrightarrow>\n          rifp d (rcurrent s)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       \\<forall>d\\<in>rkinvolved a.\n          rprecondition s (rcurrent s) a \\<longrightarrow>\n          rifp d (rcurrent s)", "fix s a d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       \\<forall>d\\<in>rkinvolved a.\n          rprecondition s (rcurrent s) a \\<longrightarrow>\n          rifp d (rcurrent s)", "assume d_involved: \"d \\<in> rkinvolved a\""], ["proof (state)\nthis:\n  d \\<in> rkinvolved a\n\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       \\<forall>d\\<in>rkinvolved a.\n          rprecondition s (rcurrent s) a \\<longrightarrow>\n          rifp d (rcurrent s)", "assume prec: \"rprecondition s (rcurrent s) a\""], ["proof (state)\nthis:\n  rprecondition s (rcurrent s) a\n\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       \\<forall>d\\<in>rkinvolved a.\n          rprecondition s (rcurrent s) a \\<longrightarrow>\n          rifp d (rcurrent s)", "from d_involved prec"], ["proof (chain)\npicking this:\n  d \\<in> rkinvolved a\n  rprecondition s (rcurrent s) a", "have \"rifp d (rcurrent s)\""], ["proof (prove)\nusing this:\n  d \\<in> rkinvolved a\n  rprecondition s (rcurrent s) a\n\ngoal (1 subgoal):\n 1. rifp d (rcurrent s)", "using ipc_precondition_ensures_ifp ev_signal_precondition_ensures_ifp rstate_invariant"], ["proof (prove)\nusing this:\n  d \\<in> rkinvolved a\n  rprecondition s (rcurrent s) a\n  \\<lbrakk>ipc_precondition (current ?s) ?dir ?partner ?page ?s;\n   atomic_step_invariant ?s\\<rbrakk>\n  \\<Longrightarrow> rifp ?partner (current ?s)\n  \\<lbrakk>ev_signal_precondition (current ?s) ?partner ?s;\n   atomic_step_invariant ?s\\<rbrakk>\n  \\<Longrightarrow> rifp ?partner (current ?s)\n  atomic_step_invariant \\<down> ?s\n\ngoal (1 subgoal):\n 1. rifp d (rcurrent s)", "unfolding rkinvolved_def rprecondition_def atomic_step_precondition_def rcurrent_def Kernel.involved_def"], ["proof (prove)\nusing this:\n  d \\<in> (case a of SK_IPC dir WAIT partner page \\<Rightarrow> {partner}\n           | SK_IPC dir _ partner page \\<Rightarrow> {}\n           | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> {}\n           | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> {partner}\n           | _ \\<Rightarrow> {})\n  case a of SK_IPC dir PREP partner page \\<Rightarrow> True\n  | SK_IPC dir WAIT partner page \\<Rightarrow>\n      ipc_precondition (current \\<down> s) dir partner page \\<down> s\n  | SK_IPC dir (BUF page') partner page \\<Rightarrow>\n      ipc_precondition (current \\<down> s) dir partner page \\<down> s \\<and>\n      ipc_precondition partner (opposite_ipc_direction dir)\n       (current \\<down> s) page' \\<down> s\n  | SK_EV_WAIT ev_wait_stage_t x \\<Rightarrow> rinvariant x\n  | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> True\n  | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n      ev_signal_precondition (current \\<down> s) partner \\<down> s\n  | NONE \\<Rightarrow> True\n  \\<lbrakk>ipc_precondition (current ?s) ?dir ?partner ?page ?s;\n   atomic_step_invariant ?s\\<rbrakk>\n  \\<Longrightarrow> rifp ?partner (current ?s)\n  \\<lbrakk>ev_signal_precondition (current ?s) ?partner ?s;\n   atomic_step_invariant ?s\\<rbrakk>\n  \\<Longrightarrow> rifp ?partner (current ?s)\n  atomic_step_invariant \\<down> ?s\n\ngoal (1 subgoal):\n 1. rifp d (current \\<down> s)", "by(cases a,simp,auto split: int_point_t.splits ipc_stage_t.splits ev_signal_stage_t.splits)"], ["proof (state)\nthis:\n  rifp d (rcurrent s)\n\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       \\<forall>d\\<in>rkinvolved a.\n          rprecondition s (rcurrent s) a \\<longrightarrow>\n          rifp d (rcurrent s)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?d2 \\<in> rkinvolved ?a2;\n   rprecondition ?s2 (rcurrent ?s2) ?a2\\<rbrakk>\n  \\<Longrightarrow> rifp ?d2 (rcurrent ?s2)\n\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       \\<forall>d\\<in>rkinvolved a.\n          rprecondition s (rcurrent s) a \\<longrightarrow>\n          rifp d (rcurrent s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?d2 \\<in> rkinvolved ?a2;\n   rprecondition ?s2 (rcurrent ?s2) ?a2\\<rbrakk>\n  \\<Longrightarrow> rifp ?d2 (rcurrent ?s2)\n\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       \\<forall>d\\<in>rkinvolved a.\n          rprecondition s (rcurrent s) a \\<longrightarrow>\n          rifp d (rcurrent s)", "by auto"], ["proof (state)\nthis:\n  \\<forall>s a.\n     \\<forall>d\\<in>rkinvolved a.\n        rprecondition s (rcurrent s) a \\<longrightarrow> rifp d (rcurrent s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spec_of_waiting_ev:\nshows \"\\<forall>s a. rwaiting s (rcurrent s) (SK_EV_WAIT EV_FINISH EV_CONSUME_ALL) \n               \\<longrightarrow> rstep s a = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       rwaiting s (rcurrent s)\n        (SK_EV_WAIT EV_FINISH EV_CONSUME_ALL) \\<longrightarrow>\n       rstep s a = s", "unfolding waiting_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       (case SK_EV_WAIT EV_FINISH EV_CONSUME_ALL of\n        SK_IPC dir WAIT partner page \\<Rightarrow>\n          \\<not> ipc_precondition partner (opposite_ipc_direction dir)\n                  (rcurrent s) (Eps rinvariant) \\<down> s\n        | SK_IPC dir _ partner page \\<Rightarrow> False\n        | SK_EV_WAIT EV_WAIT x \\<Rightarrow>\n            ev_counter (thread \\<down> s (rcurrent s)) = 0\n        | SK_EV_WAIT _ x \\<Rightarrow> False\n        | _ \\<Rightarrow> False) \\<longrightarrow>\n       rstep s a = s", "by auto"], ["", "lemma spec_of_waiting_ev_w:\nshows \"\\<forall>s a. rwaiting s (rcurrent s) (SK_EV_WAIT EV_WAIT EV_CONSUME_ALL) \n               \\<longrightarrow> rstep s (SK_EV_WAIT EV_WAIT EV_CONSUME_ALL) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       rwaiting s (rcurrent s)\n        (SK_EV_WAIT EV_WAIT EV_CONSUME_ALL) \\<longrightarrow>\n       rstep s (SK_EV_WAIT EV_WAIT EV_CONSUME_ALL) = s", "unfolding rstep_def atomic_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       rwaiting s (rcurrent s)\n        (SK_EV_WAIT EV_WAIT EV_CONSUME_ALL) \\<longrightarrow>\n       \\<up> case SK_EV_WAIT EV_WAIT EV_CONSUME_ALL of\n             SK_IPC dir stage partner page \\<Rightarrow>\n               atomic_step_ipc (current \\<down> s) dir stage partner page\n                \\<down> s\n             | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n                 atomic_step_ev_wait_all (current \\<down> s) \\<down> s\n             | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n                 atomic_step_ev_wait_one (current \\<down> s) \\<down> s\n             | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n             | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> \\<down> s\n             | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n                 atomic_step_ev_signal (current \\<down> s) partner \\<down> s\n             | NONE \\<Rightarrow> \\<down> s =\n       s", "by (auto split: int_point_t.splits ipc_stage_t.splits ev_wait_stage_t.splits)"], ["", "lemma spec_of_waiting:\nshows \"\\<forall>s a. rwaiting s (rcurrent s) a \\<longrightarrow> rstep s a = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s a. rwaiting s (rcurrent s) a \\<longrightarrow> rstep s a = s", "unfolding waiting_def rstep_def atomic_step_def atomic_step_ipc_def\n          atomic_step_ev_signal_def atomic_step_ev_wait_all_def\n          atomic_step_ev_wait_one_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s a.\n       (case a of\n        SK_IPC dir WAIT partner page \\<Rightarrow>\n          \\<not> ipc_precondition partner (opposite_ipc_direction dir)\n                  (rcurrent s) (Eps rinvariant) \\<down> s\n        | SK_IPC dir _ partner page \\<Rightarrow> False\n        | SK_EV_WAIT EV_WAIT x \\<Rightarrow>\n            ev_counter (thread \\<down> s (rcurrent s)) = 0\n        | SK_EV_WAIT _ x \\<Rightarrow> False\n        | _ \\<Rightarrow> False) \\<longrightarrow>\n       \\<up> case a of\n             SK_IPC SEND (BUF page') partner page \\<Rightarrow>\n               set_object_value (PAGE page') (obj \\<down> s (PAGE page))\n                \\<down> s\n             | SK_IPC RECV (BUF page') partner page \\<Rightarrow> \\<down> s\n             | SK_IPC dir _ partner page \\<Rightarrow> \\<down> s\n             | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow> \\<down> s\n                 \\<lparr>thread := (thread \\<down> s)\n                           (current \\<down> s :=\n                              thread \\<down> s (current \\<down> s)\n                              \\<lparr>ev_counter := 0\\<rparr>)\\<rparr>\n             | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow> \\<down> s\n                 \\<lparr>thread := (thread \\<down> s)\n                           (current \\<down> s :=\n                              thread \\<down> s (current \\<down> s)\n                              \\<lparr>ev_counter :=\n  ev_counter (thread \\<down> s (current \\<down> s)) - 1\\<rparr>)\\<rparr>\n             | SK_EV_WAIT _ consume \\<Rightarrow> \\<down> s\n             | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> \\<down> s\n             | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> \\<down> s\n                 \\<lparr>thread := (thread \\<down> s)\n                           (partner := thread \\<down> s partner\n                              \\<lparr>ev_counter :=\n  Suc (ev_counter (thread \\<down> s partner))\\<rparr>)\\<rparr>\n             | NONE \\<Rightarrow> \\<down> s =\n       s", "by(auto split: int_point_t.splits ipc_stage_t.splits ev_wait_stage_t.splits)"], ["", "end"]]}