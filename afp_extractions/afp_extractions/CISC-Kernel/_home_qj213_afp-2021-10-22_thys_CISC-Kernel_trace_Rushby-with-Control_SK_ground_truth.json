{"file_name": "/home/qj213/afp-2021-10-22/thys/CISC-Kernel/trace/Rushby-with-Control/SK.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CISC-Kernel", "problem_names": ["lemma vpeq_s_nt:\n  assumes prec_t: \"precondition (next_state t execs2) (next_action t execs2)\"\n  assumes not_ifp_curr_u: \"\\<not> ifp^** (current t) u\"\n  assumes vpeq_s_t: \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s t\"\n  shows \"(\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s (step (next_state t execs2) (next_action t execs2)))\"", "lemma vpeq_ns_t:\n  assumes prec_s: \"precondition (next_state s execs) (next_action s execs)\"\n  assumes not_ifp_curr_u: \"\\<not> ifp^** (current s) u\"\n  assumes vpeq_s_t: \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s t\"\n  shows \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v (step (next_state s execs) (next_action s execs)) t\"", "lemma vpeq_ns_nt_ifp_u:\nassumes vpeq_s_t: \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s t'\"\n    and current_s_t: \"current s = current t'\"\nshows \"precondition (next_state s execs) a \\<and> precondition (next_state t' execs) a \\<Longrightarrow> (ifp^** (current s) u \\<Longrightarrow>  (\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v (step (next_state s execs) a) (step (next_state t' execs) a)))\"", "lemma vpeq_ns_nt_not_ifp_u:\nassumes purged_a_a2: \"purged_relation u execs execs2\"\n    and prec_s: \"precondition (next_state s execs) (next_action s execs)\"\n    and current_s_t: \"current s = current t'\"\n    and vpeq_s_t: \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s t'\"\nshows \"\\<not>ifp^** (current s) u \\<and> precondition (next_state t' execs2) (next_action t' execs2) \\<longrightarrow> (\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v (step (next_state s execs) (next_action s execs)) (step (next_state t' execs2) (next_action t' execs2)))\"", "lemma unwinding_implies_view_partitioned_ind: \nshows view_partitioned_ind", "lemma unwinding_implies_view_partitioned: \nshows view_partitioned", "theorem unwinding_implies_NI_unrelated: \nshows NI_unrelated", "lemma vpeq_involved_domains:\nassumes ifp_curr: \"ifp (current s) u\"\n    and not_intermediary_curr: \"\\<not>intermediary (current s) u\"\n    and no_gateway_comm: \"does_not_communicate_with_gateway u execs\"\n    and vpeq_s_t: \"\\<forall> v . ifp v u \\<and> \\<not>intermediary v u \\<longrightarrow> vpeq v s t'\"\n    and prec_s: \"precondition (next_state s execs) (next_action s execs)\"\n  shows \"\\<forall> d \\<in> involved (next_action s execs) . vpeq d s t'\"", "lemma ipurge_l_removes_gateway_communications:\nshows \"does_not_communicate_with_gateway u (ipurge_l execs u)\"", "lemma iunwinding_implies_view_partitioned1:\nshows iview_partitioned", "lemma current_independent_of_domain_actions:\nassumes current_s_t: \"mcurrents s t\"\n  shows \"mcurrents (run n s execs) (run n t execs2)\"", "theorem unwinding_implies_NI_indirect_sources: \nshows NI_indirect_sources", "theorem unwinding_implies_isecure: \nshows isecure"], "translations": [["", "lemma vpeq_s_nt:\n  assumes prec_t: \"precondition (next_state t execs2) (next_action t execs2)\"\n  assumes not_ifp_curr_u: \"\\<not> ifp^** (current t) u\"\n  assumes vpeq_s_t: \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s t\"\n  shows \"(\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s (step (next_state t execs2) (next_action t execs2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v s (step (next_state t execs2) (next_action t execs2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v s (step (next_state t execs2) (next_action t execs2))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v s (step (next_state t execs2) (next_action t execs2))", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v s (step (next_state t execs2) (next_action t execs2))", "assume ifp_v_u: \"ifp^** v u\""], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* v u\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v s (step (next_state t execs2) (next_action t execs2))", "from ifp_v_u not_ifp_curr_u"], ["proof (chain)\npicking this:\n  ifp\\<^sup>*\\<^sup>* v u\n  unrelated (current t) u", "have unrelated: \"\\<not>ifp^** (current t) v\""], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  unrelated (current t) u\n\ngoal (1 subgoal):\n 1. unrelated (current t) v", "using rtranclp_trans"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  unrelated (current t) u\n  \\<lbrakk>?r\\<^sup>*\\<^sup>* ?x ?y; ?r\\<^sup>*\\<^sup>* ?y ?z\\<rbrakk>\n  \\<Longrightarrow> ?r\\<^sup>*\\<^sup>* ?x ?z\n\ngoal (1 subgoal):\n 1. unrelated (current t) v", "by metis"], ["proof (state)\nthis:\n  unrelated (current t) v\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v s (step (next_state t execs2) (next_action t execs2))", "from this current_next_state[THEN spec,THEN spec,where x1=t]\n         locally_respects[THEN spec,THEN spec,THEN spec,where x1=\"next_state t execs2\"] vpeq_reflexive\n         prec_t"], ["proof (chain)\npicking this:\n  unrelated (current t) v\n  current (next_state t ?x) = current t\n  \\<not> ifp (current (next_state t execs2)) ?x \\<and>\n  kprecondition (next_state t execs2) ?x2 \\<longrightarrow>\n  vpeq ?x (next_state t execs2) (kstep (next_state t execs2) ?x2)\n  \\<forall>a u. vpeq u a a\n  precondition (next_state t execs2) (next_action t execs2)", "have \"vpeq v (next_state t execs2) (step (next_state t execs2) (next_action t execs2))\""], ["proof (prove)\nusing this:\n  unrelated (current t) v\n  current (next_state t ?x) = current t\n  \\<not> ifp (current (next_state t execs2)) ?x \\<and>\n  kprecondition (next_state t execs2) ?x2 \\<longrightarrow>\n  vpeq ?x (next_state t execs2) (kstep (next_state t execs2) ?x2)\n  \\<forall>a u. vpeq u a a\n  precondition (next_state t execs2) (next_action t execs2)\n\ngoal (1 subgoal):\n 1. vpeq v (next_state t execs2)\n     (step (next_state t execs2) (next_action t execs2))", "unfolding step_def precondition_def B_def"], ["proof (prove)\nusing this:\n  unrelated (current t) v\n  current (next_state t ?x) = current t\n  \\<not> ifp (current (next_state t execs2)) ?x \\<and>\n  kprecondition (next_state t execs2) ?x2 \\<longrightarrow>\n  vpeq ?x (next_state t execs2) (kstep (next_state t execs2) ?x2)\n  \\<forall>a u. vpeq u a a\n  case next_action t execs2 of None \\<Rightarrow> True\n  | Some a \\<Rightarrow> kprecondition (next_state t execs2) a\n\ngoal (1 subgoal):\n 1. vpeq v (next_state t execs2)\n     (case next_action t execs2 of None \\<Rightarrow> next_state t execs2\n      | Some a \\<Rightarrow> kstep (next_state t execs2) a)", "by (cases \"next_action t execs2\",auto)"], ["proof (state)\nthis:\n  vpeq v (next_state t execs2)\n   (step (next_state t execs2) (next_action t execs2))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v s (step (next_state t execs2) (next_action t execs2))", "from unrelated this locally_respects_next_state vpeq_transitive"], ["proof (chain)\npicking this:\n  unrelated (current t) v\n  vpeq v (next_state t execs2)\n   (step (next_state t execs2) (next_action t execs2))\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c", "have \"vpeq v t (step (next_state t execs2) (next_action t execs2))\""], ["proof (prove)\nusing this:\n  unrelated (current t) v\n  vpeq v (next_state t execs2)\n   (step (next_state t execs2) (next_action t execs2))\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n\ngoal (1 subgoal):\n 1. vpeq v t (step (next_state t execs2) (next_action t execs2))", "by blast"], ["proof (state)\nthis:\n  vpeq v t (step (next_state t execs2) (next_action t execs2))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v s (step (next_state t execs2) (next_action t execs2))", "from this and ifp_v_u and vpeq_s_t and vpeq_symmetric and vpeq_transitive"], ["proof (chain)\npicking this:\n  vpeq v t (step (next_state t execs2) (next_action t execs2))\n  ifp\\<^sup>*\\<^sup>* v u\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t\n  \\<forall>a b u. vpeq u a b \\<longrightarrow> vpeq u b a\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c", "have \"vpeq v s (step (next_state t execs2) (next_action t execs2))\""], ["proof (prove)\nusing this:\n  vpeq v t (step (next_state t execs2) (next_action t execs2))\n  ifp\\<^sup>*\\<^sup>* v u\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t\n  \\<forall>a b u. vpeq u a b \\<longrightarrow> vpeq u b a\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n\ngoal (1 subgoal):\n 1. vpeq v s (step (next_state t execs2) (next_action t execs2))", "by metis"], ["proof (state)\nthis:\n  vpeq v s (step (next_state t execs2) (next_action t execs2))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v s (step (next_state t execs2) (next_action t execs2))", "}"], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* ?v2 u \\<Longrightarrow>\n  vpeq ?v2 s (step (next_state t execs2) (next_action t execs2))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v s (step (next_state t execs2) (next_action t execs2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* ?v2 u \\<Longrightarrow>\n  vpeq ?v2 s (step (next_state t execs2) (next_action t execs2))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v s (step (next_state t execs2) (next_action t execs2))", "by auto"], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t execs2) (next_action t execs2))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A proof that when state $s$ performs a step but state $t$ not, the states remain equivalent for any domain $v$ that may interfere with $u$.\n\\<close>"], ["", "lemma vpeq_ns_t:\n  assumes prec_s: \"precondition (next_state s execs) (next_action s execs)\"\n  assumes not_ifp_curr_u: \"\\<not> ifp^** (current s) u\"\n  assumes vpeq_s_t: \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s t\"\n  shows \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v (step (next_state s execs) (next_action s execs)) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs)) t", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs)) t", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs)) t", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs)) t", "assume ifp_v_u: \"ifp^** v u\""], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* v u\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs)) t", "from ifp_v_u and not_ifp_curr_u"], ["proof (chain)\npicking this:\n  ifp\\<^sup>*\\<^sup>* v u\n  unrelated (current s) u", "have unrelated: \"\\<not>ifp^** (current s) v\""], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  unrelated (current s) u\n\ngoal (1 subgoal):\n 1. unrelated (current s) v", "using rtranclp_trans"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  unrelated (current s) u\n  \\<lbrakk>?r\\<^sup>*\\<^sup>* ?x ?y; ?r\\<^sup>*\\<^sup>* ?y ?z\\<rbrakk>\n  \\<Longrightarrow> ?r\\<^sup>*\\<^sup>* ?x ?z\n\ngoal (1 subgoal):\n 1. unrelated (current s) v", "by metis"], ["proof (state)\nthis:\n  unrelated (current s) v\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs)) t", "from this current_next_state[THEN spec,THEN spec,where x1=s] vpeq_reflexive\n         unrelated locally_respects[THEN spec,THEN spec,THEN spec,where x1=\"next_state s execs\" and x=v and x2=\"the (next_action s execs)\"] prec_s"], ["proof (chain)\npicking this:\n  unrelated (current s) v\n  current (next_state s ?x) = current s\n  \\<forall>a u. vpeq u a a\n  unrelated (current s) v\n  \\<not> ifp (current (next_state s execs)) v \\<and>\n  kprecondition (next_state s execs)\n   (the (next_action s execs)) \\<longrightarrow>\n  vpeq v (next_state s execs)\n   (kstep (next_state s execs) (the (next_action s execs)))\n  precondition (next_state s execs) (next_action s execs)", "have \"vpeq v (next_state s execs) (step (next_state s execs) (next_action s execs))\""], ["proof (prove)\nusing this:\n  unrelated (current s) v\n  current (next_state s ?x) = current s\n  \\<forall>a u. vpeq u a a\n  unrelated (current s) v\n  \\<not> ifp (current (next_state s execs)) v \\<and>\n  kprecondition (next_state s execs)\n   (the (next_action s execs)) \\<longrightarrow>\n  vpeq v (next_state s execs)\n   (kstep (next_state s execs) (the (next_action s execs)))\n  precondition (next_state s execs) (next_action s execs)\n\ngoal (1 subgoal):\n 1. vpeq v (next_state s execs)\n     (step (next_state s execs) (next_action s execs))", "unfolding step_def precondition_def B_def"], ["proof (prove)\nusing this:\n  unrelated (current s) v\n  current (next_state s ?x) = current s\n  \\<forall>a u. vpeq u a a\n  unrelated (current s) v\n  \\<not> ifp (current (next_state s execs)) v \\<and>\n  kprecondition (next_state s execs)\n   (the (next_action s execs)) \\<longrightarrow>\n  vpeq v (next_state s execs)\n   (kstep (next_state s execs) (the (next_action s execs)))\n  case next_action s execs of None \\<Rightarrow> True\n  | Some a \\<Rightarrow> kprecondition (next_state s execs) a\n\ngoal (1 subgoal):\n 1. vpeq v (next_state s execs)\n     (case next_action s execs of None \\<Rightarrow> next_state s execs\n      | Some a \\<Rightarrow> kstep (next_state s execs) a)", "by (cases \"next_action s execs\",auto)"], ["proof (state)\nthis:\n  vpeq v (next_state s execs)\n   (step (next_state s execs) (next_action s execs))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs)) t", "from unrelated this locally_respects_next_state vpeq_transitive"], ["proof (chain)\npicking this:\n  unrelated (current s) v\n  vpeq v (next_state s execs)\n   (step (next_state s execs) (next_action s execs))\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c", "have \"vpeq v s (step (next_state s execs) (next_action s execs))\""], ["proof (prove)\nusing this:\n  unrelated (current s) v\n  vpeq v (next_state s execs)\n   (step (next_state s execs) (next_action s execs))\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n\ngoal (1 subgoal):\n 1. vpeq v s (step (next_state s execs) (next_action s execs))", "by blast"], ["proof (state)\nthis:\n  vpeq v s (step (next_state s execs) (next_action s execs))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs)) t", "from this and ifp_v_u and vpeq_s_t and vpeq_symmetric and vpeq_transitive"], ["proof (chain)\npicking this:\n  vpeq v s (step (next_state s execs) (next_action s execs))\n  ifp\\<^sup>*\\<^sup>* v u\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t\n  \\<forall>a b u. vpeq u a b \\<longrightarrow> vpeq u b a\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c", "have \"vpeq v (step (next_state s execs) (next_action s execs)) t\""], ["proof (prove)\nusing this:\n  vpeq v s (step (next_state s execs) (next_action s execs))\n  ifp\\<^sup>*\\<^sup>* v u\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t\n  \\<forall>a b u. vpeq u a b \\<longrightarrow> vpeq u b a\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n\ngoal (1 subgoal):\n 1. vpeq v (step (next_state s execs) (next_action s execs)) t", "by metis"], ["proof (state)\nthis:\n  vpeq v (step (next_state s execs) (next_action s execs)) t\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs)) t", "}"], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* ?v2 u \\<Longrightarrow>\n  vpeq ?v2 (step (next_state s execs) (next_action s execs)) t\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs)) t", "thus ?thesis"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* ?v2 u \\<Longrightarrow>\n  vpeq ?v2 (step (next_state s execs) (next_action s execs)) t\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs)) t", "by auto"], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs)) t\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A proof that when both states $s$ and $t$ perform a step, the states remain equivalent for any domain $v$ that may interfere with $u$.\n  It assumes that the current domain \\emph{can} interact with $u$ (the domain for which is purged).\n\\<close>"], ["", "lemma vpeq_ns_nt_ifp_u:\nassumes vpeq_s_t: \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s t'\"\n    and current_s_t: \"current s = current t'\"\nshows \"precondition (next_state s execs) a \\<and> precondition (next_state t' execs) a \\<Longrightarrow> (ifp^** (current s) u \\<Longrightarrow>  (\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v (step (next_state s execs) a) (step (next_state t' execs) a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>precondition (next_state s execs) a \\<and>\n             precondition (next_state t' execs) a;\n     ifp\\<^sup>*\\<^sup>* (current s) u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n                         vpeq v (step (next_state s execs) a)\n                          (step (next_state t' execs) a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>precondition (next_state s execs) a \\<and>\n             precondition (next_state t' execs) a;\n     ifp\\<^sup>*\\<^sup>* (current s) u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n                         vpeq v (step (next_state s execs) a)\n                          (step (next_state t' execs) a)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>precondition (next_state s execs) a \\<and>\n             precondition (next_state t' execs) a;\n     ifp\\<^sup>*\\<^sup>* (current s) u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n                         vpeq v (step (next_state s execs) a)\n                          (step (next_state t' execs) a)", "assume precs: \"precondition (next_state s execs) a \\<and> precondition (next_state t' execs) a\""], ["proof (state)\nthis:\n  precondition (next_state s execs) a \\<and>\n  precondition (next_state t' execs) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>precondition (next_state s execs) a \\<and>\n             precondition (next_state t' execs) a;\n     ifp\\<^sup>*\\<^sup>* (current s) u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n                         vpeq v (step (next_state s execs) a)\n                          (step (next_state t' execs) a)", "assume ifp_curr: \"ifp^** (current s) u\""], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* (current s) u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>precondition (next_state s execs) a \\<and>\n             precondition (next_state t' execs) a;\n     ifp\\<^sup>*\\<^sup>* (current s) u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n                         vpeq v (step (next_state s execs) a)\n                          (step (next_state t' execs) a)", "from vpeq_s_t"], ["proof (chain)\npicking this:\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'", "have vpeq_curr_s_t: \"ifp^** (current s) u \\<longrightarrow> vpeq (current s) s t'\""], ["proof (prove)\nusing this:\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n    vpeq (current s) s t'", "by auto"], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow> vpeq (current s) s t'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>precondition (next_state s execs) a \\<and>\n             precondition (next_state t' execs) a;\n     ifp\\<^sup>*\\<^sup>* (current s) u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n                         vpeq v (step (next_state s execs) a)\n                          (step (next_state t' execs) a)", "from ifp_curr precs\n    next_state_consistent[THEN spec,THEN spec,where x1=s and x=t'] vpeq_curr_s_t vpeq_s_t\n    current_next_state current_s_t weakly_step_consistent[THEN spec,THEN spec,THEN spec,THEN spec,where x3=\"next_state s execs\" and x2=\"next_state t' execs\" and x=\"the a\"]"], ["proof (chain)\npicking this:\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  precondition (next_state s execs) a \\<and>\n  precondition (next_state t' execs) a\n  \\<forall>u execs.\n     vpeq (current s) s t' \\<and>\n     vpeq u s t' \\<and> current s = current t' \\<longrightarrow>\n     vpeq u (next_state s execs) (next_state t' execs)\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow> vpeq (current s) s t'\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'\n  vpeq ?x1 (next_state s execs) (next_state t' execs) \\<and>\n  vpeq (current (next_state s execs)) (next_state s execs)\n   (next_state t' execs) \\<and>\n  kprecondition (next_state s execs) (the a) \\<and>\n  kprecondition (next_state t' execs) (the a) \\<and>\n  current (next_state s execs) =\n  current (next_state t' execs) \\<longrightarrow>\n  vpeq ?x1 (kstep (next_state s execs) (the a))\n   (kstep (next_state t' execs) (the a))", "show \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v (step (next_state s execs) a) (step (next_state t' execs) a)\""], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  precondition (next_state s execs) a \\<and>\n  precondition (next_state t' execs) a\n  \\<forall>u execs.\n     vpeq (current s) s t' \\<and>\n     vpeq u s t' \\<and> current s = current t' \\<longrightarrow>\n     vpeq u (next_state s execs) (next_state t' execs)\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow> vpeq (current s) s t'\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'\n  vpeq ?x1 (next_state s execs) (next_state t' execs) \\<and>\n  vpeq (current (next_state s execs)) (next_state s execs)\n   (next_state t' execs) \\<and>\n  kprecondition (next_state s execs) (the a) \\<and>\n  kprecondition (next_state t' execs) (the a) \\<and>\n  current (next_state s execs) =\n  current (next_state t' execs) \\<longrightarrow>\n  vpeq ?x1 (kstep (next_state s execs) (the a))\n   (kstep (next_state t' execs) (the a))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) a) (step (next_state t' execs) a)", "unfolding step_def precondition_def B_def"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  (case a of None \\<Rightarrow> True\n   | Some a \\<Rightarrow> kprecondition (next_state s execs) a) \\<and>\n  (case a of None \\<Rightarrow> True\n   | Some a \\<Rightarrow> kprecondition (next_state t' execs) a)\n  \\<forall>u execs.\n     vpeq (current s) s t' \\<and>\n     vpeq u s t' \\<and> current s = current t' \\<longrightarrow>\n     vpeq u (next_state s execs) (next_state t' execs)\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow> vpeq (current s) s t'\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'\n  vpeq ?x1 (next_state s execs) (next_state t' execs) \\<and>\n  vpeq (current (next_state s execs)) (next_state s execs)\n   (next_state t' execs) \\<and>\n  kprecondition (next_state s execs) (the a) \\<and>\n  kprecondition (next_state t' execs) (the a) \\<and>\n  current (next_state s execs) =\n  current (next_state t' execs) \\<longrightarrow>\n  vpeq ?x1 (kstep (next_state s execs) (the a))\n   (kstep (next_state t' execs) (the a))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v\n        (case a of None \\<Rightarrow> next_state s execs\n         | Some a \\<Rightarrow> kstep (next_state s execs) a)\n        (case a of None \\<Rightarrow> next_state t' execs\n         | Some a \\<Rightarrow> kstep (next_state t' execs) a)", "by (cases a,auto)"], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) a) (step (next_state t' execs) a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A proof that when both states $s$ and $t$ perform a step, the states remain equivalent for any domain $v$ that may interfere with $u$.\n  It assumes that the current domain \\emph{cannot} interact with $u$ (the domain for which is purged).\n\\<close>"], ["", "lemma vpeq_ns_nt_not_ifp_u:\nassumes purged_a_a2: \"purged_relation u execs execs2\"\n    and prec_s: \"precondition (next_state s execs) (next_action s execs)\"\n    and current_s_t: \"current s = current t'\"\n    and vpeq_s_t: \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s t'\"\nshows \"\\<not>ifp^** (current s) u \\<and> precondition (next_state t' execs2) (next_action t' execs2) \\<longrightarrow> (\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v (step (next_state s execs) (next_action s execs)) (step (next_state t' execs2) (next_action t' execs2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "assume not_ifp: \"\\<not>ifp^** (current s) u\""], ["proof (state)\nthis:\n  unrelated (current s) u\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "assume prec_t: \"precondition (next_state t' execs2) (next_action t' execs2)\""], ["proof (state)\nthis:\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "fix a a' v"], ["proof (state)\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "assume ifp_v_u: \"ifp^** v u\""], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* v u\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "from not_ifp and purged_a_a2"], ["proof (chain)\npicking this:\n  unrelated (current s) u\n  purged_relation u execs execs2", "have \"\\<not>ifp^** (current s) u\""], ["proof (prove)\nusing this:\n  unrelated (current s) u\n  purged_relation u execs execs2\n\ngoal (1 subgoal):\n 1. unrelated (current s) u", "unfolding purged_relation_def"], ["proof (prove)\nusing this:\n  unrelated (current s) u\n  \\<forall>d. ifp\\<^sup>*\\<^sup>* d u \\<longrightarrow> execs d = execs2 d\n\ngoal (1 subgoal):\n 1. unrelated (current s) u", "by auto"], ["proof (state)\nthis:\n  unrelated (current s) u\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "from this and ifp_v_u"], ["proof (chain)\npicking this:\n  unrelated (current s) u\n  ifp\\<^sup>*\\<^sup>* v u", "have not_ifp_curr_v: \"\\<not>ifp^** (current s) v\""], ["proof (prove)\nusing this:\n  unrelated (current s) u\n  ifp\\<^sup>*\\<^sup>* v u\n\ngoal (1 subgoal):\n 1. unrelated (current s) v", "using rtranclp_trans"], ["proof (prove)\nusing this:\n  unrelated (current s) u\n  ifp\\<^sup>*\\<^sup>* v u\n  \\<lbrakk>?r\\<^sup>*\\<^sup>* ?x ?y; ?r\\<^sup>*\\<^sup>* ?y ?z\\<rbrakk>\n  \\<Longrightarrow> ?r\\<^sup>*\\<^sup>* ?x ?z\n\ngoal (1 subgoal):\n 1. unrelated (current s) v", "by metis"], ["proof (state)\nthis:\n  unrelated (current s) v\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "from this current_next_state[THEN spec,THEN spec,where x1=s and x=execs] prec_s vpeq_reflexive\n       locally_respects[THEN spec,THEN spec,THEN spec,where x1=\"next_state s execs\" and x2=\"the (next_action s execs)\" and x=v]"], ["proof (chain)\npicking this:\n  unrelated (current s) v\n  current (next_state s execs) = current s\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>a u. vpeq u a a\n  \\<not> ifp (current (next_state s execs)) v \\<and>\n  kprecondition (next_state s execs)\n   (the (next_action s execs)) \\<longrightarrow>\n  vpeq v (next_state s execs)\n   (kstep (next_state s execs) (the (next_action s execs)))", "have \"vpeq v (next_state s execs) (step (next_state s execs) (next_action s execs))\""], ["proof (prove)\nusing this:\n  unrelated (current s) v\n  current (next_state s execs) = current s\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>a u. vpeq u a a\n  \\<not> ifp (current (next_state s execs)) v \\<and>\n  kprecondition (next_state s execs)\n   (the (next_action s execs)) \\<longrightarrow>\n  vpeq v (next_state s execs)\n   (kstep (next_state s execs) (the (next_action s execs)))\n\ngoal (1 subgoal):\n 1. vpeq v (next_state s execs)\n     (step (next_state s execs) (next_action s execs))", "unfolding step_def precondition_def B_def"], ["proof (prove)\nusing this:\n  unrelated (current s) v\n  current (next_state s execs) = current s\n  case next_action s execs of None \\<Rightarrow> True\n  | Some a \\<Rightarrow> kprecondition (next_state s execs) a\n  \\<forall>a u. vpeq u a a\n  \\<not> ifp (current (next_state s execs)) v \\<and>\n  kprecondition (next_state s execs)\n   (the (next_action s execs)) \\<longrightarrow>\n  vpeq v (next_state s execs)\n   (kstep (next_state s execs) (the (next_action s execs)))\n\ngoal (1 subgoal):\n 1. vpeq v (next_state s execs)\n     (case next_action s execs of None \\<Rightarrow> next_state s execs\n      | Some a \\<Rightarrow> kstep (next_state s execs) a)", "by (cases \"next_action s execs\",auto)"], ["proof (state)\nthis:\n  vpeq v (next_state s execs)\n   (step (next_state s execs) (next_action s execs))\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "from not_ifp_curr_v this locally_respects_next_state vpeq_transitive"], ["proof (chain)\npicking this:\n  unrelated (current s) v\n  vpeq v (next_state s execs)\n   (step (next_state s execs) (next_action s execs))\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c", "have vpeq_s_ns: \"vpeq v s (step (next_state s execs) (next_action s execs))\""], ["proof (prove)\nusing this:\n  unrelated (current s) v\n  vpeq v (next_state s execs)\n   (step (next_state s execs) (next_action s execs))\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n\ngoal (1 subgoal):\n 1. vpeq v s (step (next_state s execs) (next_action s execs))", "by blast"], ["proof (state)\nthis:\n  vpeq v s (step (next_state s execs) (next_action s execs))\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "from not_ifp_curr_v current_s_t current_next_state[THEN spec,THEN spec,where x1=t' and x=execs2] prec_t\n       locally_respects[THEN spec,THEN spec,where x=\"next_state t' execs2\"] vpeq_reflexive"], ["proof (chain)\npicking this:\n  unrelated (current s) v\n  current s = current t'\n  current (next_state t' execs2) = current t'\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<forall>u.\n     \\<not> ifp (current (next_state t' execs2)) u \\<and>\n     kprecondition (next_state t' execs2) ?x1 \\<longrightarrow>\n     vpeq u (next_state t' execs2) (kstep (next_state t' execs2) ?x1)\n  \\<forall>a u. vpeq u a a", "have 0: \"vpeq v (next_state t' execs2) (step (next_state t' execs2) (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  unrelated (current s) v\n  current s = current t'\n  current (next_state t' execs2) = current t'\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<forall>u.\n     \\<not> ifp (current (next_state t' execs2)) u \\<and>\n     kprecondition (next_state t' execs2) ?x1 \\<longrightarrow>\n     vpeq u (next_state t' execs2) (kstep (next_state t' execs2) ?x1)\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. vpeq v (next_state t' execs2)\n     (step (next_state t' execs2) (next_action t' execs2))", "unfolding step_def precondition_def B_def"], ["proof (prove)\nusing this:\n  unrelated (current s) v\n  current s = current t'\n  current (next_state t' execs2) = current t'\n  case next_action t' execs2 of None \\<Rightarrow> True\n  | Some a \\<Rightarrow> kprecondition (next_state t' execs2) a\n  \\<forall>u.\n     \\<not> ifp (current (next_state t' execs2)) u \\<and>\n     kprecondition (next_state t' execs2) ?x1 \\<longrightarrow>\n     vpeq u (next_state t' execs2) (kstep (next_state t' execs2) ?x1)\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. vpeq v (next_state t' execs2)\n     (case next_action t' execs2 of None \\<Rightarrow> next_state t' execs2\n      | Some a \\<Rightarrow> kstep (next_state t' execs2) a)", "by (cases \"next_action t' execs2\",auto)"], ["proof (state)\nthis:\n  vpeq v (next_state t' execs2)\n   (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "from not_ifp_curr_v current_s_t current_next_state"], ["proof (chain)\npicking this:\n  unrelated (current s) v\n  current s = current t'\n  \\<forall>s execs. current (next_state s execs) = current s", "have 1: \"\\<not>ifp^** (current t') v\""], ["proof (prove)\nusing this:\n  unrelated (current s) v\n  current s = current t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. unrelated (current t') v", "using rtranclp_trans"], ["proof (prove)\nusing this:\n  unrelated (current s) v\n  current s = current t'\n  \\<forall>s execs. current (next_state s execs) = current s\n  \\<lbrakk>?r\\<^sup>*\\<^sup>* ?x ?y; ?r\\<^sup>*\\<^sup>* ?y ?z\\<rbrakk>\n  \\<Longrightarrow> ?r\\<^sup>*\\<^sup>* ?x ?z\n\ngoal (1 subgoal):\n 1. unrelated (current t') v", "by auto"], ["proof (state)\nthis:\n  unrelated (current t') v\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "from 0 1 locally_respects_next_state vpeq_transitive"], ["proof (chain)\npicking this:\n  vpeq v (next_state t' execs2)\n   (step (next_state t' execs2) (next_action t' execs2))\n  unrelated (current t') v\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c", "have vpeq_t_nt: \"vpeq v t' (step (next_state t' execs2) (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  vpeq v (next_state t' execs2)\n   (step (next_state t' execs2) (next_action t' execs2))\n  unrelated (current t') v\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n\ngoal (1 subgoal):\n 1. vpeq v t' (step (next_state t' execs2) (next_action t' execs2))", "by blast"], ["proof (state)\nthis:\n  vpeq v t' (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "from vpeq_s_ns and vpeq_t_nt and vpeq_s_t and ifp_v_u and vpeq_symmetric and vpeq_transitive"], ["proof (chain)\npicking this:\n  vpeq v s (step (next_state s execs) (next_action s execs))\n  vpeq v t' (step (next_state t' execs2) (next_action t' execs2))\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  ifp\\<^sup>*\\<^sup>* v u\n  \\<forall>a b u. vpeq u a b \\<longrightarrow> vpeq u b a\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c", "have vpeq_ns_nt: \"vpeq v (step (next_state s execs) (next_action s execs)) (step (next_state t' execs2) (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  vpeq v s (step (next_state s execs) (next_action s execs))\n  vpeq v t' (step (next_state t' execs2) (next_action t' execs2))\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  ifp\\<^sup>*\\<^sup>* v u\n  \\<forall>a b u. vpeq u a b \\<longrightarrow> vpeq u b a\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n\ngoal (1 subgoal):\n 1. vpeq v (step (next_state s execs) (next_action s execs))\n     (step (next_state t' execs2) (next_action t' execs2))", "by blast"], ["proof (state)\nthis:\n  vpeq v (step (next_state s execs) (next_action s execs))\n   (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>unrelated (current s) u;\n   precondition (next_state t' execs2) (next_action t' execs2);\n   ifp\\<^sup>*\\<^sup>* ?v2 u\\<rbrakk>\n  \\<Longrightarrow> vpeq ?v2\n                     (step (next_state s execs) (next_action s execs))\n                     (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>unrelated (current s) u;\n   precondition (next_state t' execs2) (next_action t' execs2);\n   ifp\\<^sup>*\\<^sup>* ?v2 u\\<rbrakk>\n  \\<Longrightarrow> vpeq ?v2\n                     (step (next_state s execs) (next_action s execs))\n                     (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<and>\n    precondition (next_state t' execs2)\n     (next_action t' execs2) \\<longrightarrow>\n    (\\<forall>v.\n        ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n        vpeq v (step (next_state s execs) (next_action s execs))\n         (step (next_state t' execs2) (next_action t' execs2)))", "by auto"], ["proof (state)\nthis:\n  unrelated (current s) u \\<and>\n  precondition (next_state t' execs2)\n   (next_action t' execs2) \\<longrightarrow>\n  (\\<forall>v.\n      ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n      vpeq v (step (next_state s execs) (next_action s execs))\n       (step (next_state t' execs2) (next_action t' execs2)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A run with a purged list of actions appears identical to a run without purging, when starting from two states that appear identical.\n\\<close>"], ["", "lemma unwinding_implies_view_partitioned_ind: \nshows view_partitioned_ind"], ["proof (prove)\ngoal (1 subgoal):\n 1. view_partitioned_ind", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. view_partitioned_ind", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. view_partitioned_ind", "fix execs execs2 s t n u"], ["proof (state)\ngoal (1 subgoal):\n 1. view_partitioned_ind", "have \"equivalent_states s t u \\<and> purged_relation u execs execs2 \\<longrightarrow> equivalent_states (run n s execs) (run n t execs2) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalent_states s t u \\<and>\n    purged_relation u execs execs2 \\<longrightarrow>\n    equivalent_states (run n s execs) (run n t execs2) u", "proof (induct n s execs arbitrary: t u execs2 rule: run.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s execs t u execs2.\n       equivalent_states s t u \\<and>\n       purged_relation u execs execs2 \\<longrightarrow>\n       equivalent_states (run 0 s execs) (run 0 t execs2) u\n 2. \\<And>n execs t u execs2.\n       equivalent_states None t u \\<and>\n       purged_relation u execs execs2 \\<longrightarrow>\n       equivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u\n 3. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 5. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 6. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "case (1 s execs t u execs2)"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>s execs t u execs2.\n       equivalent_states s t u \\<and>\n       purged_relation u execs execs2 \\<longrightarrow>\n       equivalent_states (run 0 s execs) (run 0 t execs2) u\n 2. \\<And>n execs t u execs2.\n       equivalent_states None t u \\<and>\n       purged_relation u execs execs2 \\<longrightarrow>\n       equivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u\n 3. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 5. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 6. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalent_states s t u \\<and>\n    purged_relation u execs execs2 \\<longrightarrow>\n    equivalent_states (run 0 s execs) (run 0 t execs2) u", "by auto"], ["proof (state)\nthis:\n  equivalent_states s t u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run 0 s execs) (run 0 t execs2) u\n\ngoal (5 subgoals):\n 1. \\<And>n execs t u execs2.\n       equivalent_states None t u \\<and>\n       purged_relation u execs execs2 \\<longrightarrow>\n       equivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u\n 2. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 5. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n execs t u execs2.\n       equivalent_states None t u \\<and>\n       purged_relation u execs execs2 \\<longrightarrow>\n       equivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u\n 2. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 5. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "case (2 n execs t u execs2)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>n execs t u execs2.\n       equivalent_states None t u \\<and>\n       purged_relation u execs execs2 \\<longrightarrow>\n       equivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u\n 2. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 5. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalent_states None t u \\<and>\n    purged_relation u execs execs2 \\<longrightarrow>\n    equivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u", "by simp"], ["proof (state)\nthis:\n  equivalent_states None t u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "case (3 n s execs t u execs2)"], ["proof (state)\nthis:\n  interrupt (Suc n)\n  equivalent_states (Some (cswitch (Suc n) s)) ?t ?u \\<and>\n  purged_relation ?u execs ?execs2.0 \\<longrightarrow>\n  equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n ?t ?execs2.0) ?u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume interrupt_s: \"interrupt (Suc n)\""], ["proof (state)\nthis:\n  interrupt (Suc n)\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume IH: \"(\\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and> purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs) (run n t execs2) u)\""], ["proof (state)\nthis:\n  equivalent_states (Some (cswitch (Suc n) s)) ?t ?u \\<and>\n  purged_relation ?u execs ?execs2.0 \\<longrightarrow>\n  equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n ?t ?execs2.0) ?u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "{"], ["proof (state)\nthis:\n  equivalent_states (Some (cswitch (Suc n) s)) ?t ?u \\<and>\n  purged_relation ?u execs ?execs2.0 \\<longrightarrow>\n  equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n ?t ?execs2.0) ?u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix t'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume \"t = Some t'\""], ["proof (state)\nthis:\n  t = Some t'\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix rs"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume rs: \"run (Suc n) (Some s) execs = Some rs\""], ["proof (state)\nthis:\n  run (Suc n) (Some s) execs = Some rs\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix rt"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume rt: \"run (Suc n) (Some t') execs2 = Some rt\""], ["proof (state)\nthis:\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume vpeq_s_t: \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s t'\""], ["proof (state)\nthis:\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume current_s_t: \"current s = current t'\""], ["proof (state)\nthis:\n  current s = current t'\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume purged_a_a2: \"purged_relation u execs execs2\"\n\n      \\<comment> \\<open>The following terminology is used: states rs and rt (for: run-s and run-t) are the states after a run.\n         States ns and nt (for: next-s and next-t) are the states after one step.\\<close>\n      \\<comment> \\<open>We prove two properties: the states rs and rt have equal active domains (current-rs-rt) and are vpeq for all domains v that may influence u (vpeq-rs-rt).\n          Both are proven using the IH.\n          To use the IH, we have to prove that the properties hold for the next step (in this case, a context switch).\n          Statement current-ns-nt states that after one step states ns and nt have the same active domain.\n          Statement vpeq-ns-nt states that after one step states ns and nt are vpeq for all domains v that may influence u (vpeq-rs-rt).\\<close>"], ["proof (state)\nthis:\n  purged_relation u execs execs2\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from current_s_t cswitch_independent_of_state"], ["proof (chain)\npicking this:\n  current s = current t'\n  \\<forall>n s t.\n     current s = current t \\<longrightarrow>\n     current (cswitch n s) = current (cswitch n t)", "have current_ns_nt: \"current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\""], ["proof (prove)\nusing this:\n  current s = current t'\n  \\<forall>n s t.\n     current s = current t \\<longrightarrow>\n     current (cswitch n s) = current (cswitch n t)\n\ngoal (1 subgoal):\n 1. current (cswitch (Suc n) s) = current (cswitch (Suc n) t')", "by blast"], ["proof (state)\nthis:\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from cswitch_consistency vpeq_s_t"], ["proof (chain)\npicking this:\n  \\<forall>u s t n.\n     vpeq u s t \\<longrightarrow> vpeq u (cswitch n s) (cswitch n t)\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'", "have vpeq_ns_nt: \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\""], ["proof (prove)\nusing this:\n  \\<forall>u s t n.\n     vpeq u s t \\<longrightarrow> vpeq u (cswitch n s) (cswitch n t)\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')", "by auto"], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from current_ns_nt vpeq_ns_nt interrupt_s vpeq_reflexive purged_a_a2 current_s_t IH[where u=u and t=\"Some (cswitch (Suc n) t')\" and ?execs2.0=execs2]"], ["proof (chain)\npicking this:\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n  interrupt (Suc n)\n  \\<forall>a u. vpeq u a a\n  purged_relation u execs execs2\n  current s = current t'\n  equivalent_states (Some (cswitch (Suc n) s)) (Some (cswitch (Suc n) t'))\n   u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2) u", "have current_rs_rt: \"current rs = current rt\""], ["proof (prove)\nusing this:\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n  interrupt (Suc n)\n  \\<forall>a u. vpeq u a a\n  purged_relation u execs execs2\n  current s = current t'\n  equivalent_states (Some (cswitch (Suc n) s)) (Some (cswitch (Suc n) t'))\n   u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2) u\n\ngoal (1 subgoal):\n 1. current rs = current rt", "using rs rt"], ["proof (prove)\nusing this:\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n  interrupt (Suc n)\n  \\<forall>a u. vpeq u a a\n  purged_relation u execs execs2\n  current s = current t'\n  equivalent_states (Some (cswitch (Suc n) s)) (Some (cswitch (Suc n) t'))\n   u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2) u\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. current rs = current rt", "by(auto)"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "{"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix v"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume ia: \"ifp^** v u\""], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* v u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from current_ns_nt vpeq_ns_nt ia interrupt_s vpeq_reflexive purged_a_a2 IH[where u=u and t=\"Some (cswitch (Suc n) t')\" and ?execs2.0=execs2]"], ["proof (chain)\npicking this:\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n  ifp\\<^sup>*\\<^sup>* v u\n  interrupt (Suc n)\n  \\<forall>a u. vpeq u a a\n  purged_relation u execs execs2\n  equivalent_states (Some (cswitch (Suc n) s)) (Some (cswitch (Suc n) t'))\n   u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2) u", "have vpeq_rs_rt: \"vpeq v rs rt\""], ["proof (prove)\nusing this:\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n  ifp\\<^sup>*\\<^sup>* v u\n  interrupt (Suc n)\n  \\<forall>a u. vpeq u a a\n  purged_relation u execs execs2\n  equivalent_states (Some (cswitch (Suc n) s)) (Some (cswitch (Suc n) t'))\n   u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2) u\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "using rs rt"], ["proof (prove)\nusing this:\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n  ifp\\<^sup>*\\<^sup>* v u\n  interrupt (Suc n)\n  \\<forall>a u. vpeq u a a\n  purged_relation u execs execs2\n  equivalent_states (Some (cswitch (Suc n) s)) (Some (cswitch (Suc n) t'))\n   u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2) u\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "by(auto)"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "}"], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* ?v2 u \\<Longrightarrow> vpeq ?v2 rs rt\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from current_rs_rt and this"], ["proof (chain)\npicking this:\n  current rs = current rt\n  ifp\\<^sup>*\\<^sup>* ?v2 u \\<Longrightarrow> vpeq ?v2 rs rt", "have \"equivalent_states (Some rs) (Some rt) u\""], ["proof (prove)\nusing this:\n  current rs = current rt\n  ifp\\<^sup>*\\<^sup>* ?v2 u \\<Longrightarrow> vpeq ?v2 rs rt\n\ngoal (1 subgoal):\n 1. equivalent_states (Some rs) (Some rt) u", "by auto"], ["proof (state)\nthis:\n  equivalent_states (Some rs) (Some rt) u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "}"], ["proof (state)\nthis:\n  \\<lbrakk>t = Some ?t'2; run (Suc n) (Some s) execs = Some ?rs2;\n   run (Suc n) (Some ?t'2) execs2 = Some ?rt2;\n   \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s ?t'2;\n   current s = current ?t'2; purged_relation u execs execs2\\<rbrakk>\n  \\<Longrightarrow> equivalent_states (Some ?rs2) (Some ?rt2) u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           equivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Some ?t'2; run (Suc n) (Some s) execs = Some ?rs2;\n   run (Suc n) (Some ?t'2) execs2 = Some ?rt2;\n   \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s ?t'2;\n   current s = current ?t'2; purged_relation u execs execs2\\<rbrakk>\n  \\<Longrightarrow> equivalent_states (Some ?rs2) (Some ?rt2) u\n\ngoal (1 subgoal):\n 1. equivalent_states (Some s) t u \\<and>\n    purged_relation u execs execs2 \\<longrightarrow>\n    equivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u", "by(simp add:option.splits,cases t,simp+)"], ["proof (state)\nthis:\n  equivalent_states (Some s) t u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "case (4 n execs s t u execs2)"], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n  thread_empty (execs (current s))\n  equivalent_states (Some s) ?t ?u \\<and>\n  purged_relation ?u execs ?execs2.0 \\<longrightarrow>\n  equivalent_states (run n (Some s) execs) (run n ?t ?execs2.0) ?u\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume not_interrupt: \"\\<not>interrupt (Suc n)\""], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume thread_empty_s: \"thread_empty(execs (current s))\""], ["proof (state)\nthis:\n  thread_empty (execs (current s))\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume IH: \"(\\<And>t u execs2. equivalent_states (Some s) t u \\<and> purged_relation u execs execs2 \\<longrightarrow> equivalent_states (run n (Some s) execs) (run n t execs2) u)\""], ["proof (state)\nthis:\n  equivalent_states (Some s) ?t ?u \\<and>\n  purged_relation ?u execs ?execs2.0 \\<longrightarrow>\n  equivalent_states (run n (Some s) execs) (run n ?t ?execs2.0) ?u\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "{"], ["proof (state)\nthis:\n  equivalent_states (Some s) ?t ?u \\<and>\n  purged_relation ?u execs ?execs2.0 \\<longrightarrow>\n  equivalent_states (run n (Some s) execs) (run n ?t ?execs2.0) ?u\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix t'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume t: \"t = Some t'\""], ["proof (state)\nthis:\n  t = Some t'\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix rs"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume rs: \"run (Suc n) (Some s) execs = Some rs\""], ["proof (state)\nthis:\n  run (Suc n) (Some s) execs = Some rs\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix rt"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume rt: \"run (Suc n) (Some t') execs2 = Some rt\""], ["proof (state)\nthis:\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume vpeq_s_t: \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s t'\""], ["proof (state)\nthis:\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume current_s_t: \"current s = current t'\""], ["proof (state)\nthis:\n  current s = current t'\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume purged_a_a2: \"purged_relation u execs execs2\"\n      \n      \\<comment> \\<open>The following terminology is used: states rs and rt (for: run-s and run-t) are the states after a run.\n         States ns and nt (for: next-s and next-t) are the states after one step.\\<close>\n      \\<comment> \\<open>We prove two properties: the states rs and rt have equal active domains (current-rs-rt) and are vpeq for all domains v that may influence u (vpeq-rs-rt).\n          Both are proven using the IH.\n          To use the IH, we have to prove that the properties hold for the next step (in this case, nothing happens in s as the thread is empty).\n          Statement current-ns-nt states that after one step states ns and nt have the same active domain.\n          Statement $vpeq\\_ns\\_nt$ states that after one step states ns and nt are vpeq for all domains v that may influence u (vpeq-rs-rt).\\<close>"], ["proof (state)\nthis:\n  purged_relation u execs execs2\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from ifp_reflexive and vpeq_s_t"], ["proof (chain)\npicking this:\n  \\<forall>u. ifp u u\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'", "have vpeq_s_t_u: \"vpeq u s t'\""], ["proof (prove)\nusing this:\n  \\<forall>u. ifp u u\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq u s t'", "by auto"], ["proof (state)\nthis:\n  vpeq u s t'\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from thread_empty_s and purged_a_a2 and current_s_t"], ["proof (chain)\npicking this:\n  thread_empty (execs (current s))\n  purged_relation u execs execs2\n  current s = current t'", "have purged_a_na2: \"\\<not>ifp^** (current t') u \\<longrightarrow> purged_relation u execs (next_execs t' execs2)\""], ["proof (prove)\nusing this:\n  thread_empty (execs (current s))\n  purged_relation u execs execs2\n  current s = current t'\n\ngoal (1 subgoal):\n 1. unrelated (current t') u \\<longrightarrow>\n    purged_relation u execs (next_execs t' execs2)", "by(unfold next_execs_def,unfold purged_relation_def,auto)"], ["proof (state)\nthis:\n  unrelated (current t') u \\<longrightarrow>\n  purged_relation u execs (next_execs t' execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from step_atomicity current_next_state current_s_t"], ["proof (chain)\npicking this:\n  \\<forall>s a. current (kstep s a) = current s\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'", "have current_s_nt: \"current s = current (step (next_state t' execs2) (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'\n\ngoal (1 subgoal):\n 1. current s =\n    current (step (next_state t' execs2) (next_action t' execs2))", "unfolding step_def"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'\n\ngoal (1 subgoal):\n 1. current s =\n    current\n     (case next_action t' execs2 of None \\<Rightarrow> next_state t' execs2\n      | Some a \\<Rightarrow> kstep (next_state t' execs2) a)", "by (cases \"next_action t' execs2\",auto)\n\n      \\<comment> \\<open>The proof is by case distinction. If the current thread is empty in state t as well (case t-empty), then nothing happens and the proof is trivial.\n          Otherwise (case t-not-empty), since the current thread has different executions in states s and t, we now show that it cannot influence u (statement not-ifp-curr-t).\n          If in state t the precondition holds (case t-prec), locally respects shows that the states remain vpeq.\n          Otherwise, (case t-not-prec), everything holds vacuously.\\<close>"], ["proof (state)\nthis:\n  current s = current (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "have current_rs_rt: \"current rs = current rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current rs = current rt", "proof (cases \"thread_empty(execs2 (current t'))\" rule :case_split[case_names t_empty t_not_empty])"], ["proof (state)\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "case t_empty"], ["proof (state)\nthis:\n  thread_empty (execs2 (current t'))\n\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "from purged_a_a2 and vpeq_s_t and current_s_t IH[where t=\"Some t'\" and u=u and ?execs2.0=execs2]"], ["proof (chain)\npicking this:\n  purged_relation u execs execs2\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  current s = current t'\n  equivalent_states (Some s) (Some t') u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u", "have \"equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\""], ["proof (prove)\nusing this:\n  purged_relation u execs execs2\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  current s = current t'\n  equivalent_states (Some s) (Some t') u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n\ngoal (1 subgoal):\n 1. equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u", "using rs rt"], ["proof (prove)\nusing this:\n  purged_relation u execs execs2\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  current s = current t'\n  equivalent_states (Some s) (Some t') u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u", "by(auto)"], ["proof (state)\nthis:\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "from this not_interrupt t_empty thread_empty_s"], ["proof (chain)\npicking this:\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  thread_empty (execs2 (current t'))\n  thread_empty (execs (current s))", "show ?thesis"], ["proof (prove)\nusing this:\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  thread_empty (execs2 (current t'))\n  thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. current rs = current rt", "using rs rt"], ["proof (prove)\nusing this:\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  thread_empty (execs2 (current t'))\n  thread_empty (execs (current s))\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. current rs = current rt", "by(auto)"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "case t_not_empty"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t'))\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "from t_not_empty current_next_state and vpeq_s_t_u and thread_empty_s and purged_a_a2 and current_s_t"], ["proof (chain)\npicking this:\n  \\<not> thread_empty (execs2 (current t'))\n  \\<forall>s execs. current (next_state s execs) = current s\n  vpeq u s t'\n  thread_empty (execs (current s))\n  purged_relation u execs execs2\n  current s = current t'", "have not_ifp_curr_t: \"\\<not>ifp^** (current (next_state t' execs2)) u\""], ["proof (prove)\nusing this:\n  \\<not> thread_empty (execs2 (current t'))\n  \\<forall>s execs. current (next_state s execs) = current s\n  vpeq u s t'\n  thread_empty (execs (current s))\n  purged_relation u execs execs2\n  current s = current t'\n\ngoal (1 subgoal):\n 1. unrelated (current (next_state t' execs2)) u", "unfolding purged_relation_def"], ["proof (prove)\nusing this:\n  \\<not> thread_empty (execs2 (current t'))\n  \\<forall>s execs. current (next_state s execs) = current s\n  vpeq u s t'\n  thread_empty (execs (current s))\n  \\<forall>d. ifp\\<^sup>*\\<^sup>* d u \\<longrightarrow> execs d = execs2 d\n  current s = current t'\n\ngoal (1 subgoal):\n 1. unrelated (current (next_state t' execs2)) u", "by auto"], ["proof (state)\nthis:\n  unrelated (current (next_state t' execs2)) u\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. current rs = current rt", "proof (cases \"precondition (next_state t' execs2) (next_action t' execs2)\" rule :case_split[case_names t_prec t_not_prec])"], ["proof (state)\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "case t_prec"], ["proof (state)\nthis:\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "from locally_respects_next_state current_next_state t_prec not_ifp_curr_t vpeq_s_t locally_respects vpeq_s_nt"], ["proof (chain)\npicking this:\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  \\<forall>s execs. current (next_state s execs) = current s\n  precondition (next_state t' execs2) (next_action t' execs2)\n  unrelated (current (next_state t' execs2)) u\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  \\<forall>a s u.\n     \\<not> ifp (current s) u \\<and> kprecondition s a \\<longrightarrow>\n     vpeq u s (kstep s a)\n  \\<lbrakk>precondition (next_state ?t ?execs2.0)\n            (next_action ?t ?execs2.0);\n   unrelated (current ?t) ?u;\n   \\<forall>v.\n      ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v ?s\n                        (step (next_state ?t ?execs2.0)\n                          (next_action ?t ?execs2.0))", "have vpeq_s_nt: \"(\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s (step (next_state t' execs2) (next_action t' execs2)))\""], ["proof (prove)\nusing this:\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  \\<forall>s execs. current (next_state s execs) = current s\n  precondition (next_state t' execs2) (next_action t' execs2)\n  unrelated (current (next_state t' execs2)) u\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  \\<forall>a s u.\n     \\<not> ifp (current s) u \\<and> kprecondition s a \\<longrightarrow>\n     vpeq u s (kstep s a)\n  \\<lbrakk>precondition (next_state ?t ?execs2.0)\n            (next_action ?t ?execs2.0);\n   unrelated (current ?t) ?u;\n   \\<forall>v.\n      ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v ?s\n                        (step (next_state ?t ?execs2.0)\n                          (next_action ?t ?execs2.0))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v s (step (next_state t' execs2) (next_action t' execs2))", "by auto"], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "from vpeq_s_nt purged_a_na2 this current_s_nt not_ifp_curr_t current_next_state\n                IH[where t=\"Some (step (next_state t' execs2) (next_action t' execs2))\" and u=u and ?execs2.0=\"next_execs t' execs2\"]"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  unrelated (current t') u \\<longrightarrow>\n  purged_relation u execs (next_execs t' execs2)\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  current s = current (step (next_state t' execs2) (next_action t' execs2))\n  unrelated (current (next_state t' execs2)) u\n  \\<forall>s execs. current (next_state s execs) = current s\n  equivalent_states (Some s)\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u execs (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u", "have \"equivalent_states (run n (Some s) execs) (run n (Some (step (next_state t' execs2) (next_action t' execs2))) (next_execs t' execs2)) u\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  unrelated (current t') u \\<longrightarrow>\n  purged_relation u execs (next_execs t' execs2)\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  current s = current (step (next_state t' execs2) (next_action t' execs2))\n  unrelated (current (next_state t' execs2)) u\n  \\<forall>s execs. current (next_state s execs) = current s\n  equivalent_states (Some s)\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u execs (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n\ngoal (1 subgoal):\n 1. equivalent_states (run n (Some s) execs)\n     (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n       (next_execs t' execs2))\n     u", "using rs rt"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  unrelated (current t') u \\<longrightarrow>\n  purged_relation u execs (next_execs t' execs2)\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  current s = current (step (next_state t' execs2) (next_action t' execs2))\n  unrelated (current (next_state t' execs2)) u\n  \\<forall>s execs. current (next_state s execs) = current s\n  equivalent_states (Some s)\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u execs (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. equivalent_states (run n (Some s) execs)\n     (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n       (next_execs t' execs2))\n     u", "by auto"], ["proof (state)\nthis:\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "from t_not_empty t_prec vpeq_s_nt this thread_empty_s not_interrupt"], ["proof (chain)\npicking this:\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  thread_empty (execs (current s))\n  \\<not> interrupt (Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  thread_empty (execs (current s))\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. current rs = current rt", "using rs rt"], ["proof (prove)\nusing this:\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  thread_empty (execs (current s))\n  \\<not> interrupt (Suc n)\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. current rs = current rt", "by auto"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "case t_not_prec"], ["proof (state)\nthis:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. current rs = current rt", "using rt t_not_empty not_interrupt"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  run (Suc n) (Some t') execs2 = Some rt\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. current rs = current rt", "by(auto)"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "{"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix v"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume ia: \"ifp^** v u\""], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* v u\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "have \"vpeq v rs rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq v rs rt", "proof (cases \"thread_empty(execs2 (current t'))\" rule :case_split[case_names t_empty t_not_empty])"], ["proof (state)\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt", "case t_empty"], ["proof (state)\nthis:\n  thread_empty (execs2 (current t'))\n\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt", "from purged_a_a2 and vpeq_s_t and current_s_t IH[where t=\"Some t'\" and u=u and ?execs2.0=execs2]"], ["proof (chain)\npicking this:\n  purged_relation u execs execs2\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  current s = current t'\n  equivalent_states (Some s) (Some t') u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u", "have \"equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\""], ["proof (prove)\nusing this:\n  purged_relation u execs execs2\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  current s = current t'\n  equivalent_states (Some s) (Some t') u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n\ngoal (1 subgoal):\n 1. equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u", "using rs rt"], ["proof (prove)\nusing this:\n  purged_relation u execs execs2\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  current s = current t'\n  equivalent_states (Some s) (Some t') u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u", "by(auto)"], ["proof (state)\nthis:\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt", "from ia this not_interrupt t_empty thread_empty_s"], ["proof (chain)\npicking this:\n  ifp\\<^sup>*\\<^sup>* v u\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  thread_empty (execs2 (current t'))\n  thread_empty (execs (current s))", "show ?thesis"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  thread_empty (execs2 (current t'))\n  thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "using rs rt"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  equivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  thread_empty (execs2 (current t'))\n  thread_empty (execs (current s))\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "by(auto)"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt", "case t_not_empty"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t'))\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq v rs rt", "proof (cases \"precondition (next_state t' execs2) (next_action t' execs2)\" rule :case_split[case_names t_prec t_not_prec])"], ["proof (state)\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "case t_prec"], ["proof (state)\nthis:\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "from t_not_empty current_next_state and vpeq_s_t_u and thread_empty_s and purged_a_a2 and current_s_t"], ["proof (chain)\npicking this:\n  \\<not> thread_empty (execs2 (current t'))\n  \\<forall>s execs. current (next_state s execs) = current s\n  vpeq u s t'\n  thread_empty (execs (current s))\n  purged_relation u execs execs2\n  current s = current t'", "have not_ifp_curr_t: \"\\<not>ifp^** (current (next_state t' execs2)) u\""], ["proof (prove)\nusing this:\n  \\<not> thread_empty (execs2 (current t'))\n  \\<forall>s execs. current (next_state s execs) = current s\n  vpeq u s t'\n  thread_empty (execs (current s))\n  purged_relation u execs execs2\n  current s = current t'\n\ngoal (1 subgoal):\n 1. unrelated (current (next_state t' execs2)) u", "unfolding purged_relation_def"], ["proof (prove)\nusing this:\n  \\<not> thread_empty (execs2 (current t'))\n  \\<forall>s execs. current (next_state s execs) = current s\n  vpeq u s t'\n  thread_empty (execs (current s))\n  \\<forall>d. ifp\\<^sup>*\\<^sup>* d u \\<longrightarrow> execs d = execs2 d\n  current s = current t'\n\ngoal (1 subgoal):\n 1. unrelated (current (next_state t' execs2)) u", "by auto"], ["proof (state)\nthis:\n  unrelated (current (next_state t' execs2)) u\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "from t_prec current_next_state locally_respects_next_state this and vpeq_s_t and locally_respects and vpeq_s_nt"], ["proof (chain)\npicking this:\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<forall>s execs. current (next_state s execs) = current s\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  unrelated (current (next_state t' execs2)) u\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  \\<forall>a s u.\n     \\<not> ifp (current s) u \\<and> kprecondition s a \\<longrightarrow>\n     vpeq u s (kstep s a)\n  \\<lbrakk>precondition (next_state ?t ?execs2.0)\n            (next_action ?t ?execs2.0);\n   unrelated (current ?t) ?u;\n   \\<forall>v.\n      ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v ?s\n                        (step (next_state ?t ?execs2.0)\n                          (next_action ?t ?execs2.0))", "have vpeq_s_nt: \"(\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s (step (next_state t' execs2) (next_action t' execs2)))\""], ["proof (prove)\nusing this:\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<forall>s execs. current (next_state s execs) = current s\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  unrelated (current (next_state t' execs2)) u\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  \\<forall>a s u.\n     \\<not> ifp (current s) u \\<and> kprecondition s a \\<longrightarrow>\n     vpeq u s (kstep s a)\n  \\<lbrakk>precondition (next_state ?t ?execs2.0)\n            (next_action ?t ?execs2.0);\n   unrelated (current ?t) ?u;\n   \\<forall>v.\n      ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v ?s\n                        (step (next_state ?t ?execs2.0)\n                          (next_action ?t ?execs2.0))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v s (step (next_state t' execs2) (next_action t' execs2))", "by auto"], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "from purged_a_na2 this current_s_nt not_ifp_curr_t current_next_state\n                   IH[where t=\"Some (step (next_state t' execs2) (next_action t' execs2))\" and u=u and ?execs2.0=\"next_execs t' execs2\"]"], ["proof (chain)\npicking this:\n  unrelated (current t') u \\<longrightarrow>\n  purged_relation u execs (next_execs t' execs2)\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  current s = current (step (next_state t' execs2) (next_action t' execs2))\n  unrelated (current (next_state t' execs2)) u\n  \\<forall>s execs. current (next_state s execs) = current s\n  equivalent_states (Some s)\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u execs (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u", "have \"equivalent_states (run n (Some s) execs) (run n (Some (step (next_state t' execs2) (next_action t' execs2))) (next_execs t' execs2)) u\""], ["proof (prove)\nusing this:\n  unrelated (current t') u \\<longrightarrow>\n  purged_relation u execs (next_execs t' execs2)\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  current s = current (step (next_state t' execs2) (next_action t' execs2))\n  unrelated (current (next_state t' execs2)) u\n  \\<forall>s execs. current (next_state s execs) = current s\n  equivalent_states (Some s)\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u execs (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n\ngoal (1 subgoal):\n 1. equivalent_states (run n (Some s) execs)\n     (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n       (next_execs t' execs2))\n     u", "using rs rt"], ["proof (prove)\nusing this:\n  unrelated (current t') u \\<longrightarrow>\n  purged_relation u execs (next_execs t' execs2)\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  current s = current (step (next_state t' execs2) (next_action t' execs2))\n  unrelated (current (next_state t' execs2)) u\n  \\<forall>s execs. current (next_state s execs) = current s\n  equivalent_states (Some s)\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u execs (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. equivalent_states (run n (Some s) execs)\n     (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n       (next_execs t' execs2))\n     u", "by(auto)"], ["proof (state)\nthis:\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "from ia t_not_empty t_prec vpeq_s_nt this thread_empty_s not_interrupt"], ["proof (chain)\npicking this:\n  ifp\\<^sup>*\\<^sup>* v u\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  thread_empty (execs (current s))\n  \\<not> interrupt (Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  thread_empty (execs (current s))\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "using rs rt"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  equivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  thread_empty (execs (current s))\n  \\<not> interrupt (Suc n)\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "by auto"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "case t_not_prec"], ["proof (state)\nthis:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "using rt t_not_empty not_interrupt"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  run (Suc n) (Some t') execs2 = Some rt\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "by(auto)"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "}"], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* ?v2 u \\<Longrightarrow> vpeq ?v2 rs rt\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from current_rs_rt and this"], ["proof (chain)\npicking this:\n  current rs = current rt\n  ifp\\<^sup>*\\<^sup>* ?v2 u \\<Longrightarrow> vpeq ?v2 rs rt", "have \"equivalent_states (Some rs) (Some rt) u\""], ["proof (prove)\nusing this:\n  current rs = current rt\n  ifp\\<^sup>*\\<^sup>* ?v2 u \\<Longrightarrow> vpeq ?v2 rs rt\n\ngoal (1 subgoal):\n 1. equivalent_states (Some rs) (Some rt) u", "by auto"], ["proof (state)\nthis:\n  equivalent_states (Some rs) (Some rt) u\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "}"], ["proof (state)\nthis:\n  \\<lbrakk>t = Some ?t'2; run (Suc n) (Some s) execs = Some ?rs2;\n   run (Suc n) (Some ?t'2) execs2 = Some ?rt2;\n   \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s ?t'2;\n   current s = current ?t'2; purged_relation u execs execs2\\<rbrakk>\n  \\<Longrightarrow> equivalent_states (Some ?rs2) (Some ?rt2) u\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           equivalent_states (Some s) t u \\<and>\n           purged_relation u execs execs2 \\<longrightarrow>\n           equivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Some ?t'2; run (Suc n) (Some s) execs = Some ?rs2;\n   run (Suc n) (Some ?t'2) execs2 = Some ?rt2;\n   \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s ?t'2;\n   current s = current ?t'2; purged_relation u execs execs2\\<rbrakk>\n  \\<Longrightarrow> equivalent_states (Some ?rs2) (Some ?rt2) u\n\ngoal (1 subgoal):\n 1. equivalent_states (Some s) t u \\<and>\n    purged_relation u execs execs2 \\<longrightarrow>\n    equivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u", "by(simp add:option.splits,cases t,simp+)"], ["proof (state)\nthis:\n  equivalent_states (Some s) t u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "case (5 n execs s t u execs2)"], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  \\<not> precondition (next_state s execs) (next_action s execs)\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume not_interrupt: \"\\<not>interrupt (Suc n)\""], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume thread_not_empty_s: \"\\<not>thread_empty(execs (current s))\""], ["proof (state)\nthis:\n  \\<not> thread_empty (execs (current s))\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume not_prec_s: \"\\<not> precondition (next_state s execs) (next_action s execs)\"\n    \\<comment> \\<open>Whenever the precondition does not hold, the entire theorem flattens to True and everything holds vacuously.\\<close>"], ["proof (state)\nthis:\n  \\<not> precondition (next_state s execs) (next_action s execs)\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "hence \"run (Suc n) (Some s) execs = None\""], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state s execs) (next_action s execs)\n\ngoal (1 subgoal):\n 1. run (Suc n) (Some s) execs = None", "using not_interrupt thread_not_empty_s"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state s execs) (next_action s execs)\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. run (Suc n) (Some s) execs = None", "by simp"], ["proof (state)\nthis:\n  run (Suc n) (Some s) execs = None\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "thus ?case"], ["proof (prove)\nusing this:\n  run (Suc n) (Some s) execs = None\n\ngoal (1 subgoal):\n 1. equivalent_states (Some s) t u \\<and>\n    purged_relation u execs execs2 \\<longrightarrow>\n    equivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u", "by(simp add:option.splits)"], ["proof (state)\nthis:\n  equivalent_states (Some s) t u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "case (6 n execs s t u execs2)"], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   ?t ?u \\<and>\n  purged_relation ?u (next_execs s execs) ?execs2.0 \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n ?t ?execs2.0) ?u\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume not_interrupt: \"\\<not>interrupt (Suc n)\""], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume thread_not_empty_s: \"\\<not>thread_empty(execs (current s))\""], ["proof (state)\nthis:\n  \\<not> thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume prec_s: \"precondition (next_state s execs) (next_action s execs)\""], ["proof (state)\nthis:\n  precondition (next_state s execs) (next_action s execs)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume IH: \"(\\<And>t u execs2.\n           equivalent_states (Some (step (next_state s execs) (next_action s execs))) t u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs))) (next_execs s execs))\n            (run n t execs2) u)\""], ["proof (state)\nthis:\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   ?t ?u \\<and>\n  purged_relation ?u (next_execs s execs) ?execs2.0 \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n ?t ?execs2.0) ?u\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "{"], ["proof (state)\nthis:\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   ?t ?u \\<and>\n  purged_relation ?u (next_execs s execs) ?execs2.0 \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n ?t ?execs2.0) ?u\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume t: \"t = Some t'\""], ["proof (state)\nthis:\n  t = Some t'\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix rs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume rs: \"run (Suc n) (Some s) execs = Some rs\""], ["proof (state)\nthis:\n  run (Suc n) (Some s) execs = Some rs\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix rt"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume rt: \"run (Suc n) (Some t') execs2 = Some rt\""], ["proof (state)\nthis:\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume vpeq_s_t: \"\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v s t'\""], ["proof (state)\nthis:\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume current_s_t: \"current s = current t'\""], ["proof (state)\nthis:\n  current s = current t'\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume purged_a_a2: \"purged_relation u execs execs2\"\n\n      \\<comment> \\<open>The following terminology is used: states rs and rt (for: run-s and run-t) are the states after a run.\n         States ns and nt (for: next-s and next-t) are the states after one step.\\<close>\n      \\<comment> \\<open>We prove two properties: the states rs and rt have equal active domains (current-rs-rt) and are vpeq for all domains v that may influence u (vpeq-rs-rt).\n          Both are proven using the IH.\n          To use the IH, we have to prove that the properties hold for the next step (in this case, state s executes an action).\n          Statement current-ns-nt states that after one step states ns and nt have the same active domain.\n          Statement vpeq-ns-nt states that after one step states ns and nt are vpeq for all domains v that may influence u (vpeq-rs-rt).\\<close>\n          \n      \\<comment> \\<open>Some lemma's used in the remainder of this case.\\<close>"], ["proof (state)\nthis:\n  purged_relation u execs execs2\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from ifp_reflexive and vpeq_s_t"], ["proof (chain)\npicking this:\n  \\<forall>u. ifp u u\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'", "have vpeq_s_t_u: \"vpeq u s t'\""], ["proof (prove)\nusing this:\n  \\<forall>u. ifp u u\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq u s t'", "by auto"], ["proof (state)\nthis:\n  vpeq u s t'\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from step_atomicity and current_s_t current_next_state"], ["proof (chain)\npicking this:\n  \\<forall>s a. current (kstep s a) = current s\n  current s = current t'\n  \\<forall>s execs. current (next_state s execs) = current s", "have current_ns_nt: \"current (step (next_state s execs) (next_action s execs)) = current (step (next_state t' execs2) (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  current s = current t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. current (step (next_state s execs) (next_action s execs)) =\n    current (step (next_state t' execs2) (next_action t' execs2))", "unfolding step_def"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  current s = current t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. current\n     (case next_action s execs of None \\<Rightarrow> next_state s execs\n      | Some a \\<Rightarrow> kstep (next_state s execs) a) =\n    current\n     (case next_action t' execs2 of None \\<Rightarrow> next_state t' execs2\n      | Some a \\<Rightarrow> kstep (next_state t' execs2) a)", "by (cases \"next_action s execs\",cases \"next_action t' execs2\",simp,simp,cases \"next_action t' execs2\",simp,simp)"], ["proof (state)\nthis:\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from vpeq_s_t"], ["proof (chain)\npicking this:\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'", "have vpeq_curr_s_t: \"ifp^** (current s) u \\<longrightarrow> vpeq (current s) s t'\""], ["proof (prove)\nusing this:\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n    vpeq (current s) s t'", "by auto"], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow> vpeq (current s) s t'\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from prec_s involved_ifp[THEN spec,THEN spec,where x1=\"next_state s execs\" and x=\"next_action s execs\"] vpeq_s_t"], ["proof (chain)\npicking this:\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>d\\<in>involved (next_action s execs).\n     kprecondition (next_state s execs)\n      (the (next_action s execs)) \\<longrightarrow>\n     ifp d (current (next_state s execs))\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'", "have vpeq_involved: \"ifp^** (current s) u \\<longrightarrow> (\\<forall> d \\<in> involved (next_action s execs) . vpeq d s t')\""], ["proof (prove)\nusing this:\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>d\\<in>involved (next_action s execs).\n     kprecondition (next_state s execs)\n      (the (next_action s execs)) \\<longrightarrow>\n     ifp d (current (next_state s execs))\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n    (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')", "using current_next_state"], ["proof (prove)\nusing this:\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>d\\<in>involved (next_action s execs).\n     kprecondition (next_state s execs)\n      (the (next_action s execs)) \\<longrightarrow>\n     ifp d (current (next_state s execs))\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n    (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')", "unfolding involved_def precondition_def B_def"], ["proof (prove)\nusing this:\n  case next_action s execs of None \\<Rightarrow> True\n  | Some a \\<Rightarrow> kprecondition (next_state s execs) a\n  \\<forall>d\\<in>case next_action s execs of None \\<Rightarrow> {}\n                 | Some a \\<Rightarrow> kinvolved a.\n     kprecondition (next_state s execs)\n      (the (next_action s execs)) \\<longrightarrow>\n     ifp d (current (next_state s execs))\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n    (\\<forall>d\\<in>case next_action s execs of None \\<Rightarrow> {}\n                    | Some a \\<Rightarrow> kinvolved a.\n        vpeq d s t')", "by(cases \"next_action s execs\",simp,auto,metis converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from current_s_t next_execs_consistent vpeq_curr_s_t vpeq_involved"], ["proof (chain)\npicking this:\n  current s = current t'\n  \\<forall>s t execs.\n     vpeq (current s) s t \\<and>\n     (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t) \\<and>\n     current s = current t \\<longrightarrow>\n     fst (snd (control s (current s) (execs (current s)))) =\n     fst (snd (control t (current s) (execs (current s))))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow> vpeq (current s) s t'\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')", "have next_execs_t: \"ifp^** (current s) u \\<longrightarrow> next_execs t' execs = next_execs s execs\""], ["proof (prove)\nusing this:\n  current s = current t'\n  \\<forall>s t execs.\n     vpeq (current s) s t \\<and>\n     (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t) \\<and>\n     current s = current t \\<longrightarrow>\n     fst (snd (control s (current s) (execs (current s)))) =\n     fst (snd (control t (current s) (execs (current s))))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow> vpeq (current s) s t'\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')\n\ngoal (1 subgoal):\n 1. ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n    next_execs t' execs = next_execs s execs", "unfolding next_execs_def"], ["proof (prove)\nusing this:\n  current s = current t'\n  \\<forall>s t execs.\n     vpeq (current s) s t \\<and>\n     (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t) \\<and>\n     current s = current t \\<longrightarrow>\n     fst (snd (control s (current s) (execs (current s)))) =\n     fst (snd (control t (current s) (execs (current s))))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow> vpeq (current s) s t'\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')\n\ngoal (1 subgoal):\n 1. ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n    execs\n    (current t' :=\n       fst (snd (control t' (current t') (execs (current t'))))) =\n    execs\n    (current s := fst (snd (control s (current s) (execs (current s)))))", "by(auto)"], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from current_s_t purged_a_a2  thread_not_empty_s next_action_consistent[THEN spec,THEN spec,where x1=s and x=t'] vpeq_curr_s_t vpeq_involved"], ["proof (chain)\npicking this:\n  current s = current t'\n  purged_relation u execs execs2\n  \\<not> thread_empty (execs (current s))\n  \\<forall>execs.\n     vpeq (current s) s t' \\<and>\n     (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t') \\<and>\n     current s = current t' \\<longrightarrow>\n     next_action s execs = next_action t' execs\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow> vpeq (current s) s t'\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')", "have next_action_s_t: \"ifp^** (current s) u \\<longrightarrow> next_action t' execs2 = next_action s execs\""], ["proof (prove)\nusing this:\n  current s = current t'\n  purged_relation u execs execs2\n  \\<not> thread_empty (execs (current s))\n  \\<forall>execs.\n     vpeq (current s) s t' \\<and>\n     (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t') \\<and>\n     current s = current t' \\<longrightarrow>\n     next_action s execs = next_action t' execs\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow> vpeq (current s) s t'\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')\n\ngoal (1 subgoal):\n 1. ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n    next_action t' execs2 = next_action s execs", "by(unfold next_action_def,unfold purged_relation_def,auto)"], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from purged_a_a2 current_s_t next_execs_consistent[THEN spec,THEN spec,THEN spec,where x2=s and x1=t' and x=\"execs\"]\n           vpeq_curr_s_t vpeq_involved"], ["proof (chain)\npicking this:\n  purged_relation u execs execs2\n  current s = current t'\n  vpeq (current s) s t' \\<and>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t') \\<and>\n  current s = current t' \\<longrightarrow>\n  fst (snd (control s (current s) (execs (current s)))) =\n  fst (snd (control t' (current s) (execs (current s))))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow> vpeq (current s) s t'\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')", "have purged_na_na2: \"purged_relation u (next_execs s execs) (next_execs t' execs2)\""], ["proof (prove)\nusing this:\n  purged_relation u execs execs2\n  current s = current t'\n  vpeq (current s) s t' \\<and>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t') \\<and>\n  current s = current t' \\<longrightarrow>\n  fst (snd (control s (current s) (execs (current s)))) =\n  fst (snd (control t' (current s) (execs (current s))))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow> vpeq (current s) s t'\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')\n\ngoal (1 subgoal):\n 1. purged_relation u (next_execs s execs) (next_execs t' execs2)", "unfolding next_execs_def purged_relation_def"], ["proof (prove)\nusing this:\n  \\<forall>d. ifp\\<^sup>*\\<^sup>* d u \\<longrightarrow> execs d = execs2 d\n  current s = current t'\n  vpeq (current s) s t' \\<and>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t') \\<and>\n  current s = current t' \\<longrightarrow>\n  fst (snd (control s (current s) (execs (current s)))) =\n  fst (snd (control t' (current s) (execs (current s))))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow> vpeq (current s) s t'\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')\n\ngoal (1 subgoal):\n 1. \\<forall>d.\n       ifp\\<^sup>*\\<^sup>* d u \\<longrightarrow>\n       (execs\n        (current s :=\n           fst (snd (control s (current s) (execs (current s))))))\n        d =\n       (execs2\n        (current t' :=\n           fst (snd (control t' (current t') (execs2 (current t'))))))\n        d", "by(auto)"], ["proof (state)\nthis:\n  purged_relation u (next_execs s execs) (next_execs t' execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from purged_a_a2 and purged_relation_def and thread_not_empty_s and current_s_t"], ["proof (chain)\npicking this:\n  purged_relation u execs execs2\n  purged_relation ?u ?execs1.0 ?execs2.0 \\<equiv>\n  \\<forall>d.\n     ifp\\<^sup>*\\<^sup>* d ?u \\<longrightarrow> ?execs1.0 d = ?execs2.0 d\n  \\<not> thread_empty (execs (current s))\n  current s = current t'", "have thread_not_empty_t: \"ifp^** (current s) u \\<longrightarrow> \\<not>thread_empty(execs2 (current t'))\""], ["proof (prove)\nusing this:\n  purged_relation u execs execs2\n  purged_relation ?u ?execs1.0 ?execs2.0 \\<equiv>\n  \\<forall>d.\n     ifp\\<^sup>*\\<^sup>* d ?u \\<longrightarrow> ?execs1.0 d = ?execs2.0 d\n  \\<not> thread_empty (execs (current s))\n  current s = current t'\n\ngoal (1 subgoal):\n 1. ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n    \\<not> thread_empty (execs2 (current t'))", "by auto"], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  \\<not> thread_empty (execs2 (current t'))\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from step_atomicity current_s_t current_next_state"], ["proof (chain)\npicking this:\n  \\<forall>s a. current (kstep s a) = current s\n  current s = current t'\n  \\<forall>s execs. current (next_state s execs) = current s", "have current_ns_t: \"current (step (next_state s execs) (next_action s execs)) = current t'\""], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  current s = current t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. current (step (next_state s execs) (next_action s execs)) = current t'", "unfolding step_def"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  current s = current t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. current\n     (case next_action s execs of None \\<Rightarrow> next_state s execs\n      | Some a \\<Rightarrow> kstep (next_state s execs) a) =\n    current t'", "by (cases \"next_action s execs\",auto)"], ["proof (state)\nthis:\n  current (step (next_state s execs) (next_action s execs)) = current t'\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from step_atomicity and current_s_t"], ["proof (chain)\npicking this:\n  \\<forall>s a. current (kstep s a) = current s\n  current s = current t'", "have current_s_nt: \"current s = current (step t' (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  current s = current t'\n\ngoal (1 subgoal):\n 1. current s = current (step t' (next_action t' execs2))", "unfolding step_def"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  current s = current t'\n\ngoal (1 subgoal):\n 1. current s =\n    current\n     (case next_action t' execs2 of None \\<Rightarrow> t'\n      | Some a \\<Rightarrow> kstep t' a)", "by (cases \"next_action t' execs2\",auto)"], ["proof (state)\nthis:\n  current s = current (step t' (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from purged_a_a2"], ["proof (chain)\npicking this:\n  purged_relation u execs execs2", "have purged_na_a: \"\\<not>ifp^** (current s) u \\<longrightarrow> purged_relation u (next_execs s execs) execs2\""], ["proof (prove)\nusing this:\n  purged_relation u execs execs2\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<longrightarrow>\n    purged_relation u (next_execs s execs) execs2", "by(unfold next_execs_def,unfold purged_relation_def,auto)\n\n      \\<comment> \\<open>The proof is by case distinction. If the current domain can interact with u (case curr-ifp-u), then either in state t the precondition holds (case t-prec) or not.\n          If it holds, then lemma vpeq-ns-nt-ifp-u applies. Otherwise, the proof is trivial as the theorem holds vacuously.\n          If the domain cannot interact with u, (case curr-not-ifp-u), then lemma vpeq-ns-nt-not-ifp-u applies.\\<close>"], ["proof (state)\nthis:\n  unrelated (current s) u \\<longrightarrow>\n  purged_relation u (next_execs s execs) execs2\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "have current_rs_rt: \"current rs = current rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current rs = current rt", "proof (cases \"ifp^** (current s) u\" rule :case_split[case_names curr_ifp_u curr_not_ifp_u])"], ["proof (state)\ngoal (2 subgoals):\n 1. ifp\\<^sup>*\\<^sup>* (current s) u \\<Longrightarrow>\n    current rs = current rt\n 2. unrelated (current s) u \\<Longrightarrow> current rs = current rt", "case curr_ifp_u"], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* (current s) u\n\ngoal (2 subgoals):\n 1. ifp\\<^sup>*\\<^sup>* (current s) u \\<Longrightarrow>\n    current rs = current rt\n 2. unrelated (current s) u \\<Longrightarrow> current rs = current rt", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. current rs = current rt", "proof (cases \"precondition (next_state t' execs2) (next_action t' execs2)\" rule :case_split[case_names prec_t prec_not_t])"], ["proof (state)\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "case prec_t"], ["proof (state)\nthis:\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "have thread_not_empty_t: \"\\<not>thread_empty(execs2 (current t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t'))", "using thread_not_empty_t curr_ifp_u"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  \\<not> thread_empty (execs2 (current t'))\n  ifp\\<^sup>*\\<^sup>* (current s) u\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t'))", "by auto"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t'))\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "from\n            current_ns_nt next_execs_t next_action_s_t purged_a_a2\n            curr_ifp_u prec_t prec_s vpeq_ns_nt_ifp_u[where a=\"(next_action s execs)\"] vpeq_s_t current_s_t"], ["proof (chain)\npicking this:\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  purged_relation u execs execs2\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  precondition (next_state s execs) (next_action s execs)\n  \\<lbrakk>\\<forall>v.\n              ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t';\n   current ?s = current ?t';\n   precondition (next_state ?s ?execs) (next_action s execs) \\<and>\n   precondition (next_state ?t' ?execs) (next_action s execs);\n   ifp\\<^sup>*\\<^sup>* (current ?s) ?u\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v\n                        (step (next_state ?s ?execs) (next_action s execs))\n                        (step (next_state ?t' ?execs) (next_action s execs))\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  current s = current t'", "have \"equivalent_states (Some (step (next_state s execs) (next_action s execs))) (Some (step (next_state t' execs2) (next_action t' execs2))) u\""], ["proof (prove)\nusing this:\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  purged_relation u execs execs2\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  precondition (next_state s execs) (next_action s execs)\n  \\<lbrakk>\\<forall>v.\n              ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t';\n   current ?s = current ?t';\n   precondition (next_state ?s ?execs) (next_action s execs) \\<and>\n   precondition (next_state ?t' ?execs) (next_action s execs);\n   ifp\\<^sup>*\\<^sup>* (current ?s) ?u\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v\n                        (step (next_state ?s ?execs) (next_action s execs))\n                        (step (next_state ?t' ?execs) (next_action s execs))\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  current s = current t'\n\ngoal (1 subgoal):\n 1. equivalent_states\n     (Some (step (next_state s execs) (next_action s execs)))\n     (Some (step (next_state t' execs2) (next_action t' execs2))) u", "unfolding purged_relation_def next_state_def"], ["proof (prove)\nusing this:\n  current\n   (step (snd (snd (control s (current s) (execs (current s)))))\n     (next_action s execs)) =\n  current\n   (step (snd (snd (control t' (current t') (execs2 (current t')))))\n     (next_action t' execs2))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  \\<forall>d. ifp\\<^sup>*\\<^sup>* d u \\<longrightarrow> execs d = execs2 d\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  precondition (snd (snd (control t' (current t') (execs2 (current t')))))\n   (next_action t' execs2)\n  precondition (snd (snd (control s (current s) (execs (current s)))))\n   (next_action s execs)\n  \\<lbrakk>\\<forall>v.\n              ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t';\n   current ?s = current ?t';\n   precondition (snd (snd (control ?s (current ?s) (?execs (current ?s)))))\n    (next_action s execs) \\<and>\n   precondition\n    (snd (snd (control ?t' (current ?t') (?execs (current ?t')))))\n    (next_action s execs);\n   ifp\\<^sup>*\\<^sup>* (current ?s) ?u\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v\n                        (step\n                          (snd (snd (control ?s (current ?s)\n(?execs (current ?s)))))\n                          (next_action s execs))\n                        (step\n                          (snd (snd (control ?t' (current ?t')\n(?execs (current ?t')))))\n                          (next_action s execs))\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  current s = current t'\n\ngoal (1 subgoal):\n 1. equivalent_states\n     (Some\n       (step (snd (snd (control s (current s) (execs (current s)))))\n         (next_action s execs)))\n     (Some\n       (step (snd (snd (control t' (current t') (execs2 (current t')))))\n         (next_action t' execs2)))\n     u", "by auto"], ["proof (state)\nthis:\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "from this\n            IH[where u=u and ?execs2.0=\"(next_execs t' execs2)\" and t=\"Some (step (next_state t' execs2) (next_action t' execs2))\"] \n            current_ns_nt purged_na_na2"], ["proof (chain)\npicking this:\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u (next_execs s execs)\n   (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  purged_relation u (next_execs s execs) (next_execs t' execs2)", "have \"equivalent_states (run n (Some (step (next_state s execs) (next_action s execs))) (next_execs s execs))\n                                    (run n (Some (step (next_state t' execs2) (next_action t' execs2))) (next_execs t' execs2)) u\""], ["proof (prove)\nusing this:\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u (next_execs s execs)\n   (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  purged_relation u (next_execs s execs) (next_execs t' execs2)\n\ngoal (1 subgoal):\n 1. equivalent_states\n     (run n (Some (step (next_state s execs) (next_action s execs)))\n       (next_execs s execs))\n     (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n       (next_execs t' execs2))\n     u", "by auto"], ["proof (state)\nthis:\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "from prec_t thread_not_empty_t prec_s and this and not_interrupt and thread_not_empty_s and next_action_s_t"], ["proof (chain)\npicking this:\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs", "show ?thesis"], ["proof (prove)\nusing this:\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n\ngoal (1 subgoal):\n 1. current rs = current rt", "using rs rt"], ["proof (prove)\nusing this:\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. current rs = current rt", "by auto"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "case prec_not_t"], ["proof (state)\nthis:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "from curr_ifp_u prec_not_t thread_not_empty_t not_interrupt"], ["proof (chain)\npicking this:\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. current rs = current rt", "using rt"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. current rs = current rt", "by simp"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<Longrightarrow> current rs = current rt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<Longrightarrow> current rs = current rt", "case curr_not_ifp_u"], ["proof (state)\nthis:\n  unrelated (current s) u\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<Longrightarrow> current rs = current rt", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. current rs = current rt", "proof (cases \"thread_empty(execs2 (current t'))\" rule :case_split[case_names t_empty t_not_empty])"], ["proof (state)\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "case t_not_empty"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t'))\n\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. current rs = current rt", "proof (cases \"precondition (next_state t' execs2) (next_action t' execs2)\" rule :case_split[case_names t_prec t_not_prec])"], ["proof (state)\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "case t_prec"], ["proof (state)\nthis:\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "from curr_not_ifp_u t_prec IH[where u=u and ?execs2.0=\"(next_execs t' execs2)\" and t=\"Some (step (next_state t' execs2) (next_action t' execs2))\"]\n                 current_ns_nt next_execs_t purged_na_na2 vpeq_ns_nt_not_ifp_u current_s_t vpeq_s_t prec_s purged_a_a2"], ["proof (chain)\npicking this:\n  unrelated (current s) u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u (next_execs s execs)\n   (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  purged_relation u (next_execs s execs) (next_execs t' execs2)\n  \\<lbrakk>purged_relation ?u ?execs ?execs2.0;\n   precondition (next_state ?s ?execs) (next_action ?s ?execs);\n   current ?s = current ?t';\n   \\<forall>v.\n      ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t'\\<rbrakk>\n  \\<Longrightarrow> unrelated (current ?s) ?u \\<and>\n                    precondition (next_state ?t' ?execs2.0)\n                     (next_action ?t' ?execs2.0) \\<longrightarrow>\n                    (\\<forall>v.\n                        ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                        vpeq v\n                         (step (next_state ?s ?execs)\n                           (next_action ?s ?execs))\n                         (step (next_state ?t' ?execs2.0)\n                           (next_action ?t' ?execs2.0)))\n  current s = current t'\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  precondition (next_state s execs) (next_action s execs)\n  purged_relation u execs execs2", "have \"equivalent_states (run n (Some (step (next_state s execs) (next_action s execs))) (next_execs s execs))\n                                     (run n (Some (step (next_state t' execs2) (next_action t' execs2))) (next_execs t' execs2)) u\""], ["proof (prove)\nusing this:\n  unrelated (current s) u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u (next_execs s execs)\n   (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  purged_relation u (next_execs s execs) (next_execs t' execs2)\n  \\<lbrakk>purged_relation ?u ?execs ?execs2.0;\n   precondition (next_state ?s ?execs) (next_action ?s ?execs);\n   current ?s = current ?t';\n   \\<forall>v.\n      ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t'\\<rbrakk>\n  \\<Longrightarrow> unrelated (current ?s) ?u \\<and>\n                    precondition (next_state ?t' ?execs2.0)\n                     (next_action ?t' ?execs2.0) \\<longrightarrow>\n                    (\\<forall>v.\n                        ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                        vpeq v\n                         (step (next_state ?s ?execs)\n                           (next_action ?s ?execs))\n                         (step (next_state ?t' ?execs2.0)\n                           (next_action ?t' ?execs2.0)))\n  current s = current t'\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  precondition (next_state s execs) (next_action s execs)\n  purged_relation u execs execs2\n\ngoal (1 subgoal):\n 1. equivalent_states\n     (run n (Some (step (next_state s execs) (next_action s execs)))\n       (next_execs s execs))\n     (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n       (next_execs t' execs2))\n     u", "by auto"], ["proof (state)\nthis:\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "from this t_prec curr_not_ifp_u t_not_empty prec_s not_interrupt thread_not_empty_s"], ["proof (chain)\npicking this:\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  unrelated (current s) u\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))", "show ?thesis"], ["proof (prove)\nusing this:\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  unrelated (current s) u\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. current rs = current rt", "using rs rt"], ["proof (prove)\nusing this:\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  unrelated (current s) u\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. current rs = current rt", "by auto"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "case t_not_prec"], ["proof (state)\nthis:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    current rs = current rt", "from t_not_prec t_not_empty not_interrupt"], ["proof (chain)\npicking this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. current rs = current rt", "using rt"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. current rs = current rt", "by simp"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "case t_empty"], ["proof (state)\nthis:\n  thread_empty (execs2 (current t'))\n\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "from curr_not_ifp_u and prec_s and vpeq_s_t and locally_respects and vpeq_ns_t current_next_state locally_respects_next_state"], ["proof (chain)\npicking this:\n  unrelated (current s) u\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  \\<forall>a s u.\n     \\<not> ifp (current s) u \\<and> kprecondition s a \\<longrightarrow>\n     vpeq u s (kstep s a)\n  \\<lbrakk>precondition (next_state ?s ?execs) (next_action ?s ?execs);\n   unrelated (current ?s) ?u;\n   \\<forall>v.\n      ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v\n                        (step (next_state ?s ?execs)\n                          (next_action ?s ?execs))\n                        ?t\n  \\<forall>s execs. current (next_state s execs) = current s\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)", "have vpeq_ns_t: \"(\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v (step (next_state s execs) (next_action s execs)) t')\""], ["proof (prove)\nusing this:\n  unrelated (current s) u\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  \\<forall>a s u.\n     \\<not> ifp (current s) u \\<and> kprecondition s a \\<longrightarrow>\n     vpeq u s (kstep s a)\n  \\<lbrakk>precondition (next_state ?s ?execs) (next_action ?s ?execs);\n   unrelated (current ?s) ?u;\n   \\<forall>v.\n      ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v\n                        (step (next_state ?s ?execs)\n                          (next_action ?s ?execs))\n                        ?t\n  \\<forall>s execs. current (next_state s execs) = current s\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs)) t'", "by blast"], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs)) t'\n\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "from curr_not_ifp_u IH[where t=\"Some t'\" and u=u and ?execs2.0=execs2] and current_ns_t and next_execs_t and purged_na_a and vpeq_ns_t and this"], ["proof (chain)\npicking this:\n  unrelated (current s) u\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some t') u \\<and>\n  purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2) u\n  current (step (next_state s execs) (next_action s execs)) = current t'\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  unrelated (current s) u \\<longrightarrow>\n  purged_relation u (next_execs s execs) execs2\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs)) t'\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs)) t'", "have \"equivalent_states (run n (Some (step (next_state s execs) (next_action s execs))) (next_execs s execs)) \n                                  (run n (Some t')  execs2) u\""], ["proof (prove)\nusing this:\n  unrelated (current s) u\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some t') u \\<and>\n  purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2) u\n  current (step (next_state s execs) (next_action s execs)) = current t'\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  unrelated (current s) u \\<longrightarrow>\n  purged_relation u (next_execs s execs) execs2\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs)) t'\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs)) t'\n\ngoal (1 subgoal):\n 1. equivalent_states\n     (run n (Some (step (next_state s execs) (next_action s execs)))\n       (next_execs s execs))\n     (run n (Some t') execs2) u", "by auto"], ["proof (state)\nthis:\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2) u\n\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    current rs = current rt", "from this not_interrupt thread_not_empty_s t_empty prec_s"], ["proof (chain)\npicking this:\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)", "show ?thesis"], ["proof (prove)\nusing this:\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n\ngoal (1 subgoal):\n 1. current rs = current rt", "using rs rt"], ["proof (prove)\nusing this:\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. current rs = current rt", "by auto"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "{"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume ia: \"ifp^** v u\""], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* v u\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "have \"vpeq v rs rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq v rs rt", "proof (cases \"ifp^** (current s) u\" rule :case_split[case_names curr_ifp_u curr_not_ifp_u])"], ["proof (state)\ngoal (2 subgoals):\n 1. ifp\\<^sup>*\\<^sup>* (current s) u \\<Longrightarrow> vpeq v rs rt\n 2. unrelated (current s) u \\<Longrightarrow> vpeq v rs rt", "case curr_ifp_u"], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* (current s) u\n\ngoal (2 subgoals):\n 1. ifp\\<^sup>*\\<^sup>* (current s) u \\<Longrightarrow> vpeq v rs rt\n 2. unrelated (current s) u \\<Longrightarrow> vpeq v rs rt", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq v rs rt", "proof (cases \"precondition (next_state t' execs2) (next_action t' execs2)\" rule :case_split[case_names t_prec t_not_prec])"], ["proof (state)\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "case t_prec"], ["proof (state)\nthis:\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "have thread_not_empty_t: \"\\<not>thread_empty(execs2 (current t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t'))", "using thread_not_empty_t curr_ifp_u"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  \\<not> thread_empty (execs2 (current t'))\n  ifp\\<^sup>*\\<^sup>* (current s) u\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t'))", "by auto"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t'))\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "from\n              current_ns_nt next_execs_t next_action_s_t purged_a_a2\n              curr_ifp_u t_prec  prec_s vpeq_ns_nt_ifp_u[where a=\"(next_action s execs)\"] vpeq_s_t current_s_t"], ["proof (chain)\npicking this:\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  purged_relation u execs execs2\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  precondition (next_state s execs) (next_action s execs)\n  \\<lbrakk>\\<forall>v.\n              ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t';\n   current ?s = current ?t';\n   precondition (next_state ?s ?execs) (next_action s execs) \\<and>\n   precondition (next_state ?t' ?execs) (next_action s execs);\n   ifp\\<^sup>*\\<^sup>* (current ?s) ?u\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v\n                        (step (next_state ?s ?execs) (next_action s execs))\n                        (step (next_state ?t' ?execs) (next_action s execs))\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  current s = current t'", "have \"equivalent_states (Some (step (next_state s execs) (next_action s execs))) (Some (step (next_state t' execs2) (next_action t' execs2))) u\""], ["proof (prove)\nusing this:\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  purged_relation u execs execs2\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  precondition (next_state s execs) (next_action s execs)\n  \\<lbrakk>\\<forall>v.\n              ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t';\n   current ?s = current ?t';\n   precondition (next_state ?s ?execs) (next_action s execs) \\<and>\n   precondition (next_state ?t' ?execs) (next_action s execs);\n   ifp\\<^sup>*\\<^sup>* (current ?s) ?u\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v\n                        (step (next_state ?s ?execs) (next_action s execs))\n                        (step (next_state ?t' ?execs) (next_action s execs))\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  current s = current t'\n\ngoal (1 subgoal):\n 1. equivalent_states\n     (Some (step (next_state s execs) (next_action s execs)))\n     (Some (step (next_state t' execs2) (next_action t' execs2))) u", "unfolding purged_relation_def next_state_def"], ["proof (prove)\nusing this:\n  current\n   (step (snd (snd (control s (current s) (execs (current s)))))\n     (next_action s execs)) =\n  current\n   (step (snd (snd (control t' (current t') (execs2 (current t')))))\n     (next_action t' execs2))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  \\<forall>d. ifp\\<^sup>*\\<^sup>* d u \\<longrightarrow> execs d = execs2 d\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  precondition (snd (snd (control t' (current t') (execs2 (current t')))))\n   (next_action t' execs2)\n  precondition (snd (snd (control s (current s) (execs (current s)))))\n   (next_action s execs)\n  \\<lbrakk>\\<forall>v.\n              ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t';\n   current ?s = current ?t';\n   precondition (snd (snd (control ?s (current ?s) (?execs (current ?s)))))\n    (next_action s execs) \\<and>\n   precondition\n    (snd (snd (control ?t' (current ?t') (?execs (current ?t')))))\n    (next_action s execs);\n   ifp\\<^sup>*\\<^sup>* (current ?s) ?u\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v\n                        (step\n                          (snd (snd (control ?s (current ?s)\n(?execs (current ?s)))))\n                          (next_action s execs))\n                        (step\n                          (snd (snd (control ?t' (current ?t')\n(?execs (current ?t')))))\n                          (next_action s execs))\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  current s = current t'\n\ngoal (1 subgoal):\n 1. equivalent_states\n     (Some\n       (step (snd (snd (control s (current s) (execs (current s)))))\n         (next_action s execs)))\n     (Some\n       (step (snd (snd (control t' (current t') (execs2 (current t')))))\n         (next_action t' execs2)))\n     u", "by auto"], ["proof (state)\nthis:\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "from this\n              IH[where u=u and ?execs2.0=\"(next_execs t' execs2)\" and t=\"Some (step (next_state t' execs2) (next_action t' execs2))\"] \n              current_ns_nt purged_na_na2"], ["proof (chain)\npicking this:\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u (next_execs s execs)\n   (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  purged_relation u (next_execs s execs) (next_execs t' execs2)", "have \"equivalent_states (run n (Some (step (next_state s execs) (next_action s execs))) (next_execs s execs))\n                                      (run n (Some (step (next_state t' execs2) (next_action t' execs2))) (next_execs t' execs2)) u\""], ["proof (prove)\nusing this:\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u (next_execs s execs)\n   (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  purged_relation u (next_execs s execs) (next_execs t' execs2)\n\ngoal (1 subgoal):\n 1. equivalent_states\n     (run n (Some (step (next_state s execs) (next_action s execs)))\n       (next_execs s execs))\n     (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n       (next_execs t' execs2))\n     u", "by auto"], ["proof (state)\nthis:\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "from ia curr_ifp_u t_prec thread_not_empty_t prec_s and this and not_interrupt and thread_not_empty_s and next_action_s_t"], ["proof (chain)\npicking this:\n  ifp\\<^sup>*\\<^sup>* v u\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs", "show ?thesis"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "using rs rt"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "by auto"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "case t_not_prec"], ["proof (state)\nthis:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "from curr_ifp_u t_not_prec thread_not_empty_t not_interrupt"], ["proof (chain)\npicking this:\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "using rt"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* (current s) u\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "by simp"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<Longrightarrow> vpeq v rs rt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<Longrightarrow> vpeq v rs rt", "case curr_not_ifp_u"], ["proof (state)\nthis:\n  unrelated (current s) u\n\ngoal (1 subgoal):\n 1. unrelated (current s) u \\<Longrightarrow> vpeq v rs rt", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq v rs rt", "proof (cases \"thread_empty(execs2 (current t'))\" rule :case_split[case_names t_empty t_not_empty])"], ["proof (state)\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt", "case t_not_empty"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t'))\n\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq v rs rt", "proof (cases \"precondition (next_state t' execs2) (next_action t' execs2)\" rule :case_split[case_names t_prec t_not_prec])"], ["proof (state)\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "case t_prec"], ["proof (state)\nthis:\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "from curr_not_ifp_u t_prec IH[where u=u and ?execs2.0=\"(next_execs t' execs2)\" and t=\"Some (step (next_state t' execs2) (next_action t' execs2))\"]\n                   current_ns_nt next_execs_t purged_na_na2 vpeq_ns_nt_not_ifp_u current_s_t vpeq_s_t prec_s purged_a_a2"], ["proof (chain)\npicking this:\n  unrelated (current s) u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u (next_execs s execs)\n   (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  purged_relation u (next_execs s execs) (next_execs t' execs2)\n  \\<lbrakk>purged_relation ?u ?execs ?execs2.0;\n   precondition (next_state ?s ?execs) (next_action ?s ?execs);\n   current ?s = current ?t';\n   \\<forall>v.\n      ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t'\\<rbrakk>\n  \\<Longrightarrow> unrelated (current ?s) ?u \\<and>\n                    precondition (next_state ?t' ?execs2.0)\n                     (next_action ?t' ?execs2.0) \\<longrightarrow>\n                    (\\<forall>v.\n                        ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                        vpeq v\n                         (step (next_state ?s ?execs)\n                           (next_action ?s ?execs))\n                         (step (next_state ?t' ?execs2.0)\n                           (next_action ?t' ?execs2.0)))\n  current s = current t'\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  precondition (next_state s execs) (next_action s execs)\n  purged_relation u execs execs2", "have \"equivalent_states (run n (Some (step (next_state s execs) (next_action s execs))) (next_execs s execs))\n                                       (run n (Some (step (next_state t' execs2) (next_action t' execs2))) (next_execs t' execs2)) u\""], ["proof (prove)\nusing this:\n  unrelated (current s) u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  purged_relation u (next_execs s execs)\n   (next_execs t' execs2) \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  purged_relation u (next_execs s execs) (next_execs t' execs2)\n  \\<lbrakk>purged_relation ?u ?execs ?execs2.0;\n   precondition (next_state ?s ?execs) (next_action ?s ?execs);\n   current ?s = current ?t';\n   \\<forall>v.\n      ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t'\\<rbrakk>\n  \\<Longrightarrow> unrelated (current ?s) ?u \\<and>\n                    precondition (next_state ?t' ?execs2.0)\n                     (next_action ?t' ?execs2.0) \\<longrightarrow>\n                    (\\<forall>v.\n                        ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                        vpeq v\n                         (step (next_state ?s ?execs)\n                           (next_action ?s ?execs))\n                         (step (next_state ?t' ?execs2.0)\n                           (next_action ?t' ?execs2.0)))\n  current s = current t'\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  precondition (next_state s execs) (next_action s execs)\n  purged_relation u execs execs2\n\ngoal (1 subgoal):\n 1. equivalent_states\n     (run n (Some (step (next_state s execs) (next_action s execs)))\n       (next_execs s execs))\n     (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n       (next_execs t' execs2))\n     u", "by auto"], ["proof (state)\nthis:\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "from ia this t_prec curr_not_ifp_u t_not_empty prec_s not_interrupt thread_not_empty_s"], ["proof (chain)\npicking this:\n  ifp\\<^sup>*\\<^sup>* v u\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  unrelated (current s) u\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))", "show ?thesis"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  unrelated (current s) u\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "using rs rt"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  unrelated (current s) u\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "by auto"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "case t_not_prec"], ["proof (state)\nthis:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    vpeq v rs rt", "from t_not_prec t_not_empty not_interrupt"], ["proof (chain)\npicking this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "using rt"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "by simp"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt", "case t_empty"], ["proof (state)\nthis:\n  thread_empty (execs2 (current t'))\n\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt", "from curr_not_ifp_u prec_s and vpeq_s_t and locally_respects and vpeq_ns_t current_next_state locally_respects_next_state"], ["proof (chain)\npicking this:\n  unrelated (current s) u\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  \\<forall>a s u.\n     \\<not> ifp (current s) u \\<and> kprecondition s a \\<longrightarrow>\n     vpeq u s (kstep s a)\n  \\<lbrakk>precondition (next_state ?s ?execs) (next_action ?s ?execs);\n   unrelated (current ?s) ?u;\n   \\<forall>v.\n      ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v\n                        (step (next_state ?s ?execs)\n                          (next_action ?s ?execs))\n                        ?t\n  \\<forall>s execs. current (next_state s execs) = current s\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)", "have vpeq_ns_t: \"(\\<forall> v . ifp^** v u \\<longrightarrow> vpeq v (step (next_state s execs) (next_action s execs)) t')\""], ["proof (prove)\nusing this:\n  unrelated (current s) u\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s t'\n  \\<forall>a s u.\n     \\<not> ifp (current s) u \\<and> kprecondition s a \\<longrightarrow>\n     vpeq u s (kstep s a)\n  \\<lbrakk>precondition (next_state ?s ?execs) (next_action ?s ?execs);\n   unrelated (current ?s) ?u;\n   \\<forall>v.\n      ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow> vpeq v ?s ?t\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp\\<^sup>*\\<^sup>* v ?u \\<longrightarrow>\n                       vpeq v\n                        (step (next_state ?s ?execs)\n                          (next_action ?s ?execs))\n                        ?t\n  \\<forall>s execs. current (next_state s execs) = current s\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs)) t'", "by blast"], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs)) t'\n\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt", "from curr_not_ifp_u IH[where t=\"Some t'\" and u=u and ?execs2.0=execs2] and current_ns_t and next_execs_t and purged_na_a and vpeq_ns_t and this"], ["proof (chain)\npicking this:\n  unrelated (current s) u\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some t') u \\<and>\n  purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2) u\n  current (step (next_state s execs) (next_action s execs)) = current t'\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  unrelated (current s) u \\<longrightarrow>\n  purged_relation u (next_execs s execs) execs2\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs)) t'\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs)) t'", "have \"equivalent_states (run n (Some (step (next_state s execs) (next_action s execs))) (next_execs s execs)) \n                                    (run n (Some t')  execs2) u\""], ["proof (prove)\nusing this:\n  unrelated (current s) u\n  equivalent_states (Some (step (next_state s execs) (next_action s execs)))\n   (Some t') u \\<and>\n  purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2) u\n  current (step (next_state s execs) (next_action s execs)) = current t'\n  ifp\\<^sup>*\\<^sup>* (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n  unrelated (current s) u \\<longrightarrow>\n  purged_relation u (next_execs s execs) execs2\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs)) t'\n  \\<forall>v.\n     ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs)) t'\n\ngoal (1 subgoal):\n 1. equivalent_states\n     (run n (Some (step (next_state s execs) (next_action s execs)))\n       (next_execs s execs))\n     (run n (Some t') execs2) u", "by auto"], ["proof (state)\nthis:\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2) u\n\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow> vpeq v rs rt", "from ia this not_interrupt thread_not_empty_s t_empty prec_s"], ["proof (chain)\npicking this:\n  ifp\\<^sup>*\\<^sup>* v u\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "using rs rt"], ["proof (prove)\nusing this:\n  ifp\\<^sup>*\\<^sup>* v u\n  equivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  thread_empty (execs2 (current t'))\n  precondition (next_state s execs) (next_action s execs)\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "by auto"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "}"], ["proof (state)\nthis:\n  ifp\\<^sup>*\\<^sup>* ?v2 u \\<Longrightarrow> vpeq ?v2 rs rt\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from current_rs_rt and this"], ["proof (chain)\npicking this:\n  current rs = current rt\n  ifp\\<^sup>*\\<^sup>* ?v2 u \\<Longrightarrow> vpeq ?v2 rs rt", "have \"equivalent_states (Some rs) (Some rt) u\""], ["proof (prove)\nusing this:\n  current rs = current rt\n  ifp\\<^sup>*\\<^sup>* ?v2 u \\<Longrightarrow> vpeq ?v2 rs rt\n\ngoal (1 subgoal):\n 1. equivalent_states (Some rs) (Some rt) u", "by auto"], ["proof (state)\nthis:\n  equivalent_states (Some rs) (Some rt) u\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "}"], ["proof (state)\nthis:\n  \\<lbrakk>t = Some ?t'2; run (Suc n) (Some s) execs = Some ?rs2;\n   run (Suc n) (Some ?t'2) execs2 = Some ?rt2;\n   \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s ?t'2;\n   current s = current ?t'2; purged_relation u execs execs2\\<rbrakk>\n  \\<Longrightarrow> equivalent_states (Some ?rs2) (Some ?rt2) u\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           equivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           purged_relation u (next_execs s execs) execs2 \\<longrightarrow>\n           equivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> equivalent_states (Some s) t u \\<and>\n                         purged_relation u execs execs2 \\<longrightarrow>\n                         equivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Some ?t'2; run (Suc n) (Some s) execs = Some ?rs2;\n   run (Suc n) (Some ?t'2) execs2 = Some ?rt2;\n   \\<forall>v. ifp\\<^sup>*\\<^sup>* v u \\<longrightarrow> vpeq v s ?t'2;\n   current s = current ?t'2; purged_relation u execs execs2\\<rbrakk>\n  \\<Longrightarrow> equivalent_states (Some ?rs2) (Some ?rt2) u\n\ngoal (1 subgoal):\n 1. equivalent_states (Some s) t u \\<and>\n    purged_relation u execs execs2 \\<longrightarrow>\n    equivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u", "by(simp add:option.splits,cases t,simp+)"], ["proof (state)\nthis:\n  equivalent_states (Some s) t u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  equivalent_states s t u \\<and>\n  purged_relation u execs execs2 \\<longrightarrow>\n  equivalent_states (run n s execs) (run n t execs2) u\n\ngoal (1 subgoal):\n 1. view_partitioned_ind", "}"], ["proof (state)\nthis:\n  equivalent_states ?s2 ?t2 ?u2 \\<and>\n  purged_relation ?u2 ?execs2 ?execs2.2 \\<longrightarrow>\n  equivalent_states (run ?n2 ?s2 ?execs2) (run ?n2 ?t2 ?execs2.2) ?u2\n\ngoal (1 subgoal):\n 1. view_partitioned_ind", "thus ?thesis"], ["proof (prove)\nusing this:\n  equivalent_states ?s2 ?t2 ?u2 \\<and>\n  purged_relation ?u2 ?execs2 ?execs2.2 \\<longrightarrow>\n  equivalent_states (run ?n2 ?s2 ?execs2) (run ?n2 ?t2 ?execs2.2) ?u2\n\ngoal (1 subgoal):\n 1. view_partitioned_ind", "unfolding view_partitioned_ind_def"], ["proof (prove)\nusing this:\n  equivalent_states ?s2 ?t2 ?u2 \\<and>\n  purged_relation ?u2 ?execs2 ?execs2.2 \\<longrightarrow>\n  equivalent_states (run ?n2 ?s2 ?execs2) (run ?n2 ?t2 ?execs2.2) ?u2\n\ngoal (1 subgoal):\n 1. \\<forall>execs1 execs2 s t n u.\n       equivalent_states s t u \\<and>\n       purged_relation u execs1 execs2 \\<longrightarrow>\n       equivalent_states (run n s execs1) (run n t execs2) u", "by auto"], ["proof (state)\nthis:\n  view_partitioned_ind\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  From the previous lemma, we can prove that the system is view partitioned.\n  The previous lemma was inductive, this lemma just instantiates the previous lemma replacing s and t by the initial state.\n\\<close>"], ["", "lemma unwinding_implies_view_partitioned: \nshows view_partitioned"], ["proof (prove)\ngoal (1 subgoal):\n 1. view_partitioned", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. view_partitioned", "from unwinding_implies_view_partitioned_ind"], ["proof (chain)\npicking this:\n  view_partitioned_ind", "have view_partitioned_inductive: \"view_partitioned_ind\""], ["proof (prove)\nusing this:\n  view_partitioned_ind\n\ngoal (1 subgoal):\n 1. view_partitioned_ind", "by blast"], ["proof (state)\nthis:\n  view_partitioned_ind\n\ngoal (1 subgoal):\n 1. view_partitioned", "have purged_relation: \"\\<forall> u execs . purged_relation u execs (purge execs u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u execs. purged_relation u execs (purge execs u)", "by(unfold purged_relation_def, unfold purge_def, auto)"], ["proof (state)\nthis:\n  \\<forall>u execs. purged_relation u execs (purge execs u)\n\ngoal (1 subgoal):\n 1. view_partitioned", "{"], ["proof (state)\nthis:\n  \\<forall>u execs. purged_relation u execs (purge execs u)\n\ngoal (1 subgoal):\n 1. view_partitioned", "fix execs s t n u"], ["proof (state)\ngoal (1 subgoal):\n 1. view_partitioned", "assume 1: \"equivalent_states s t u\""], ["proof (state)\nthis:\n  equivalent_states s t u\n\ngoal (1 subgoal):\n 1. view_partitioned", "from this view_partitioned_inductive purged_relation"], ["proof (chain)\npicking this:\n  equivalent_states s t u\n  view_partitioned_ind\n  \\<forall>u execs. purged_relation u execs (purge execs u)", "have \"equivalent_states (run n s execs) (run n t (purge execs u)) u\""], ["proof (prove)\nusing this:\n  equivalent_states s t u\n  view_partitioned_ind\n  \\<forall>u execs. purged_relation u execs (purge execs u)\n\ngoal (1 subgoal):\n 1. equivalent_states (run n s execs) (run n t (purge execs u)) u", "unfolding view_partitioned_ind_def"], ["proof (prove)\nusing this:\n  equivalent_states s t u\n  \\<forall>execs1 execs2 s t n u.\n     equivalent_states s t u \\<and>\n     purged_relation u execs1 execs2 \\<longrightarrow>\n     equivalent_states (run n s execs1) (run n t execs2) u\n  \\<forall>u execs. purged_relation u execs (purge execs u)\n\ngoal (1 subgoal):\n 1. equivalent_states (run n s execs) (run n t (purge execs u)) u", "by auto"], ["proof (state)\nthis:\n  equivalent_states (run n s execs) (run n t (purge execs u)) u\n\ngoal (1 subgoal):\n 1. view_partitioned", "from this ifp_reflexive"], ["proof (chain)\npicking this:\n  equivalent_states (run n s execs) (run n t (purge execs u)) u\n  \\<forall>u. ifp u u", "have \"run n s execs \\<parallel> run n t (purge execs u) \\<rightharpoonup> (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)\""], ["proof (prove)\nusing this:\n  equivalent_states (run n s execs) (run n t (purge execs u)) u\n  \\<forall>u. ifp u u\n\ngoal (1 subgoal):\n 1. B2 (run n s execs) (run n t (purge execs u))\n     (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)", "using r_into_rtranclp"], ["proof (prove)\nusing this:\n  equivalent_states (run n s execs) (run n t (purge execs u)) u\n  \\<forall>u. ifp u u\n  ?r ?x ?y \\<Longrightarrow> ?r\\<^sup>*\\<^sup>* ?x ?y\n\ngoal (1 subgoal):\n 1. B2 (run n s execs) (run n t (purge execs u))\n     (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)", "unfolding B_def"], ["proof (prove)\nusing this:\n  equivalent_states (run n s execs) (run n t (purge execs u)) u\n  \\<forall>u. ifp u u\n  ?r ?x ?y \\<Longrightarrow> ?r\\<^sup>*\\<^sup>* ?x ?y\n\ngoal (1 subgoal):\n 1. B2 (run n s execs) (run n t (purge execs u))\n     (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)", "by(cases \"run n s execs\",simp,cases \"run n t (purge execs u)\",simp,auto)"], ["proof (state)\nthis:\n  B2 (run n s execs) (run n t (purge execs u))\n   (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)\n\ngoal (1 subgoal):\n 1. view_partitioned", "}"], ["proof (state)\nthis:\n  equivalent_states ?s2 ?t2 ?u2 \\<Longrightarrow>\n  B2 (run ?n2 ?s2 ?execs2) (run ?n2 ?t2 (purge ?execs2 ?u2))\n   (\\<lambda>rs rt. vpeq ?u2 rs rt \\<and> current rs = current rt)\n\ngoal (1 subgoal):\n 1. view_partitioned", "thus ?thesis"], ["proof (prove)\nusing this:\n  equivalent_states ?s2 ?t2 ?u2 \\<Longrightarrow>\n  B2 (run ?n2 ?s2 ?execs2) (run ?n2 ?t2 (purge ?execs2 ?u2))\n   (\\<lambda>rs rt. vpeq ?u2 rs rt \\<and> current rs = current rt)\n\ngoal (1 subgoal):\n 1. view_partitioned", "unfolding view_partitioned_def Let_def"], ["proof (prove)\nusing this:\n  equivalent_states ?s2 ?t2 ?u2 \\<Longrightarrow>\n  B2 (run ?n2 ?s2 ?execs2) (run ?n2 ?t2 (purge ?execs2 ?u2))\n   (\\<lambda>rs rt. vpeq ?u2 rs rt \\<and> current rs = current rt)\n\ngoal (1 subgoal):\n 1. \\<forall>execs ms mt n u.\n       equivalent_states ms mt u \\<longrightarrow>\n       B2 (run n ms execs) (run n mt (purge execs u))\n        (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)", "by auto"], ["proof (state)\nthis:\n  view_partitioned\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Domains that many not interfere with each other, do not interfere with each other.\n\\<close>"], ["", "theorem unwinding_implies_NI_unrelated: \nshows NI_unrelated"], ["proof (prove)\ngoal (1 subgoal):\n 1. NI_unrelated", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. NI_unrelated", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. NI_unrelated", "fix execs a n"], ["proof (state)\ngoal (1 subgoal):\n 1. NI_unrelated", "from unwinding_implies_view_partitioned"], ["proof (chain)\npicking this:\n  view_partitioned", "have vp: view_partitioned"], ["proof (prove)\nusing this:\n  view_partitioned\n\ngoal (1 subgoal):\n 1. view_partitioned", "by blast"], ["proof (state)\nthis:\n  view_partitioned\n\ngoal (1 subgoal):\n 1. NI_unrelated", "from vp and vpeq_reflexive"], ["proof (chain)\npicking this:\n  view_partitioned\n  \\<forall>a u. vpeq u a a", "have 1: \"\\<forall> u . (run n (Some s0) execs \n                      \\<parallel> run n (Some s0) (purge execs u) \n                          \\<rightharpoonup> (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt))\""], ["proof (prove)\nusing this:\n  view_partitioned\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       B2 (run n (Some s0) execs) (run n (Some s0) (purge execs u))\n        (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)", "unfolding view_partitioned_def"], ["proof (prove)\nusing this:\n  \\<forall>execs ms mt n u.\n     equivalent_states ms mt u \\<longrightarrow>\n     B2 (run n ms execs) (run n mt (purge execs u))\n      (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       B2 (run n (Some s0) execs) (run n (Some s0) (purge execs u))\n        (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)", "by auto"], ["proof (state)\nthis:\n  \\<forall>u.\n     B2 (run n (Some s0) execs) (run n (Some s0) (purge execs u))\n      (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)\n\ngoal (1 subgoal):\n 1. NI_unrelated", "have \"run n (Some s0) execs \\<rightharpoonup> (\\<lambda>s_f. run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup> (\\<lambda>s_f2. output_f s_f a = output_f s_f2 a \\<and> current s_f = current s_f2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n        (\\<lambda>s_f2.\n            output_f s_f a = output_f s_f2 a \\<and>\n            current s_f = current s_f2))", "proof(cases \"run n (Some s0) execs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. run n (Some s0) execs = None \\<Longrightarrow>\n    run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n        (\\<lambda>s_f2.\n            output_f s_f a = output_f s_f2 a \\<and>\n            current s_f = current s_f2))\n 2. \\<And>aa.\n       run n (Some s0) execs = Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n           (\\<lambda>s_f2.\n               output_f s_f a = output_f s_f2 a \\<and>\n               current s_f = current s_f2))", "case None"], ["proof (state)\nthis:\n  run n (Some s0) execs = None\n\ngoal (2 subgoals):\n 1. run n (Some s0) execs = None \\<Longrightarrow>\n    run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n        (\\<lambda>s_f2.\n            output_f s_f a = output_f s_f2 a \\<and>\n            current s_f = current s_f2))\n 2. \\<And>aa.\n       run n (Some s0) execs = Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n           (\\<lambda>s_f2.\n               output_f s_f a = output_f s_f2 a \\<and>\n               current s_f = current s_f2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = None\n\ngoal (1 subgoal):\n 1. run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n        (\\<lambda>s_f2.\n            output_f s_f a = output_f s_f2 a \\<and>\n            current s_f = current s_f2))", "unfolding B_def"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = None\n\ngoal (1 subgoal):\n 1. case run n (Some s0) execs of None \\<Rightarrow> True\n    | Some aa \\<Rightarrow>\n        case run n (Some s0) (purge execs (current aa)) of\n        None \\<Rightarrow> True\n        | Some ab \\<Rightarrow>\n            output_f aa a = output_f ab a \\<and> current aa = current ab", "by simp"], ["proof (state)\nthis:\n  run n (Some s0) execs \\<rightharpoonup>\n  (\\<lambda>s_f.\n      run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n      (\\<lambda>s_f2.\n          output_f s_f a = output_f s_f2 a \\<and>\n          current s_f = current s_f2))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       run n (Some s0) execs = Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n           (\\<lambda>s_f2.\n               output_f s_f a = output_f s_f2 a \\<and>\n               current s_f = current s_f2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       run n (Some s0) execs = Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n           (\\<lambda>s_f2.\n               output_f s_f a = output_f s_f2 a \\<and>\n               current s_f = current s_f2))", "case (Some rs)"], ["proof (state)\nthis:\n  run n (Some s0) execs = Some rs\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       run n (Some s0) execs = Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n           (\\<lambda>s_f2.\n               output_f s_f a = output_f s_f2 a \\<and>\n               current s_f = current s_f2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some rs\n\ngoal (1 subgoal):\n 1. run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n        (\\<lambda>s_f2.\n            output_f s_f a = output_f s_f2 a \\<and>\n            current s_f = current s_f2))", "proof(cases \"run n (Some s0) (purge execs (current rs))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>run n (Some s0) execs = Some rs;\n     run n (Some s0) (purge execs (current rs)) = None\\<rbrakk>\n    \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                      (\\<lambda>s_f.\n                          run n (Some s0)\n                           (purge execs (current s_f)) \\<rightharpoonup>\n                          (\\<lambda>s_f2.\n                              output_f s_f a = output_f s_f2 a \\<and>\n                              current s_f = current s_f2))\n 2. \\<And>aa.\n       \\<lbrakk>run n (Some s0) execs = Some rs;\n        run n (Some s0) (purge execs (current rs)) = Some aa\\<rbrakk>\n       \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                         (\\<lambda>s_f.\n                             run n (Some s0)\n                              (purge execs (current s_f)) \\<rightharpoonup>\n                             (\\<lambda>s_f2.\n                                 output_f s_f a = output_f s_f2 a \\<and>\n                                 current s_f = current s_f2))", "case None"], ["proof (state)\nthis:\n  run n (Some s0) (purge execs (current rs)) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>run n (Some s0) execs = Some rs;\n     run n (Some s0) (purge execs (current rs)) = None\\<rbrakk>\n    \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                      (\\<lambda>s_f.\n                          run n (Some s0)\n                           (purge execs (current s_f)) \\<rightharpoonup>\n                          (\\<lambda>s_f2.\n                              output_f s_f a = output_f s_f2 a \\<and>\n                              current s_f = current s_f2))\n 2. \\<And>aa.\n       \\<lbrakk>run n (Some s0) execs = Some rs;\n        run n (Some s0) (purge execs (current rs)) = Some aa\\<rbrakk>\n       \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                         (\\<lambda>s_f.\n                             run n (Some s0)\n                              (purge execs (current s_f)) \\<rightharpoonup>\n                             (\\<lambda>s_f2.\n                                 output_f s_f a = output_f s_f2 a \\<and>\n                                 current s_f = current s_f2))", "from Some this"], ["proof (chain)\npicking this:\n  run n (Some s0) execs = Some rs\n  run n (Some s0) (purge execs (current rs)) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some rs\n  run n (Some s0) (purge execs (current rs)) = None\n\ngoal (1 subgoal):\n 1. run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n        (\\<lambda>s_f2.\n            output_f s_f a = output_f s_f2 a \\<and>\n            current s_f = current s_f2))", "unfolding B_def"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some rs\n  run n (Some s0) (purge execs (current rs)) = None\n\ngoal (1 subgoal):\n 1. case run n (Some s0) execs of None \\<Rightarrow> True\n    | Some aa \\<Rightarrow>\n        case run n (Some s0) (purge execs (current aa)) of\n        None \\<Rightarrow> True\n        | Some ab \\<Rightarrow>\n            output_f aa a = output_f ab a \\<and> current aa = current ab", "by simp"], ["proof (state)\nthis:\n  run n (Some s0) execs \\<rightharpoonup>\n  (\\<lambda>s_f.\n      run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n      (\\<lambda>s_f2.\n          output_f s_f a = output_f s_f2 a \\<and>\n          current s_f = current s_f2))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>run n (Some s0) execs = Some rs;\n        run n (Some s0) (purge execs (current rs)) = Some aa\\<rbrakk>\n       \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                         (\\<lambda>s_f.\n                             run n (Some s0)\n                              (purge execs (current s_f)) \\<rightharpoonup>\n                             (\\<lambda>s_f2.\n                                 output_f s_f a = output_f s_f2 a \\<and>\n                                 current s_f = current s_f2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>run n (Some s0) execs = Some rs;\n        run n (Some s0) (purge execs (current rs)) = Some aa\\<rbrakk>\n       \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                         (\\<lambda>s_f.\n                             run n (Some s0)\n                              (purge execs (current s_f)) \\<rightharpoonup>\n                             (\\<lambda>s_f2.\n                                 output_f s_f a = output_f s_f2 a \\<and>\n                                 current s_f = current s_f2))", "case (Some rt)"], ["proof (state)\nthis:\n  run n (Some s0) (purge execs (current rs)) = Some rt\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>run n (Some s0) execs = Some rs;\n        run n (Some s0) (purge execs (current rs)) = Some aa\\<rbrakk>\n       \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                         (\\<lambda>s_f.\n                             run n (Some s0)\n                              (purge execs (current s_f)) \\<rightharpoonup>\n                             (\\<lambda>s_f2.\n                                 output_f s_f a = output_f s_f2 a \\<and>\n                                 current s_f = current s_f2))", "from \\<open>run n (Some s0) execs = Some rs\\<close> Some 1[THEN spec,where x=\"current rs\"]"], ["proof (chain)\npicking this:\n  run n (Some s0) execs = Some rs\n  run n (Some s0) (purge execs (current rs)) = Some rt\n  B2 (run n (Some s0) execs) (run n (Some s0) (purge execs (current rs)))\n   (\\<lambda>rsa rt.\n       vpeq (current rs) rsa rt \\<and> current rsa = current rt)", "have vpeq: \"vpeq (current rs) rs rt \\<and> current rs = current rt\""], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some rs\n  run n (Some s0) (purge execs (current rs)) = Some rt\n  B2 (run n (Some s0) execs) (run n (Some s0) (purge execs (current rs)))\n   (\\<lambda>rsa rt.\n       vpeq (current rs) rsa rt \\<and> current rsa = current rt)\n\ngoal (1 subgoal):\n 1. vpeq (current rs) rs rt \\<and> current rs = current rt", "unfolding B_def"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some rs\n  run n (Some s0) (purge execs (current rs)) = Some rt\n  B2 (run n (Some s0) execs) (run n (Some s0) (purge execs (current rs)))\n   (\\<lambda>rsa rt.\n       vpeq (current rs) rsa rt \\<and> current rsa = current rt)\n\ngoal (1 subgoal):\n 1. vpeq (current rs) rs rt \\<and> current rs = current rt", "by auto"], ["proof (state)\nthis:\n  vpeq (current rs) rs rt \\<and> current rs = current rt\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>run n (Some s0) execs = Some rs;\n        run n (Some s0) (purge execs (current rs)) = Some aa\\<rbrakk>\n       \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                         (\\<lambda>s_f.\n                             run n (Some s0)\n                              (purge execs (current s_f)) \\<rightharpoonup>\n                             (\\<lambda>s_f2.\n                                 output_f s_f a = output_f s_f2 a \\<and>\n                                 current s_f = current s_f2))", "from this output_consistent"], ["proof (chain)\npicking this:\n  vpeq (current rs) rs rt \\<and> current rs = current rt\n  \\<forall>a s t.\n     vpeq (current s) s t \\<and> current s = current t \\<longrightarrow>\n     output_f s a = output_f t a", "have \"output_f rs a = output_f rt a\""], ["proof (prove)\nusing this:\n  vpeq (current rs) rs rt \\<and> current rs = current rt\n  \\<forall>a s t.\n     vpeq (current s) s t \\<and> current s = current t \\<longrightarrow>\n     output_f s a = output_f t a\n\ngoal (1 subgoal):\n 1. output_f rs a = output_f rt a", "by auto"], ["proof (state)\nthis:\n  output_f rs a = output_f rt a\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>run n (Some s0) execs = Some rs;\n        run n (Some s0) (purge execs (current rs)) = Some aa\\<rbrakk>\n       \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                         (\\<lambda>s_f.\n                             run n (Some s0)\n                              (purge execs (current s_f)) \\<rightharpoonup>\n                             (\\<lambda>s_f2.\n                                 output_f s_f a = output_f s_f2 a \\<and>\n                                 current s_f = current s_f2))", "from this vpeq \\<open>run n (Some s0) execs = Some rs\\<close> Some"], ["proof (chain)\npicking this:\n  output_f rs a = output_f rt a\n  vpeq (current rs) rs rt \\<and> current rs = current rt\n  run n (Some s0) execs = Some rs\n  run n (Some s0) (purge execs (current rs)) = Some rt", "show ?thesis"], ["proof (prove)\nusing this:\n  output_f rs a = output_f rt a\n  vpeq (current rs) rs rt \\<and> current rs = current rt\n  run n (Some s0) execs = Some rs\n  run n (Some s0) (purge execs (current rs)) = Some rt\n\ngoal (1 subgoal):\n 1. run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n        (\\<lambda>s_f2.\n            output_f s_f a = output_f s_f2 a \\<and>\n            current s_f = current s_f2))", "unfolding B_def"], ["proof (prove)\nusing this:\n  output_f rs a = output_f rt a\n  vpeq (current rs) rs rt \\<and> current rs = current rt\n  run n (Some s0) execs = Some rs\n  run n (Some s0) (purge execs (current rs)) = Some rt\n\ngoal (1 subgoal):\n 1. case run n (Some s0) execs of None \\<Rightarrow> True\n    | Some aa \\<Rightarrow>\n        case run n (Some s0) (purge execs (current aa)) of\n        None \\<Rightarrow> True\n        | Some ab \\<Rightarrow>\n            output_f aa a = output_f ab a \\<and> current aa = current ab", "by auto"], ["proof (state)\nthis:\n  run n (Some s0) execs \\<rightharpoonup>\n  (\\<lambda>s_f.\n      run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n      (\\<lambda>s_f2.\n          output_f s_f a = output_f s_f2 a \\<and>\n          current s_f = current s_f2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  run n (Some s0) execs \\<rightharpoonup>\n  (\\<lambda>s_f.\n      run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n      (\\<lambda>s_f2.\n          output_f s_f a = output_f s_f2 a \\<and>\n          current s_f = current s_f2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  run n (Some s0) execs \\<rightharpoonup>\n  (\\<lambda>s_f.\n      run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n      (\\<lambda>s_f2.\n          output_f s_f a = output_f s_f2 a \\<and>\n          current s_f = current s_f2))\n\ngoal (1 subgoal):\n 1. NI_unrelated", "}"], ["proof (state)\nthis:\n  run ?n2 (Some s0) ?execs2 \\<rightharpoonup>\n  (\\<lambda>s_f.\n      run ?n2 (Some s0) (purge ?execs2 (current s_f)) \\<rightharpoonup>\n      (\\<lambda>s_f2.\n          output_f s_f ?a2 = output_f s_f2 ?a2 \\<and>\n          current s_f = current s_f2))\n\ngoal (1 subgoal):\n 1. NI_unrelated", "thus ?thesis"], ["proof (prove)\nusing this:\n  run ?n2 (Some s0) ?execs2 \\<rightharpoonup>\n  (\\<lambda>s_f.\n      run ?n2 (Some s0) (purge ?execs2 (current s_f)) \\<rightharpoonup>\n      (\\<lambda>s_f2.\n          output_f s_f ?a2 = output_f s_f2 ?a2 \\<and>\n          current s_f = current s_f2))\n\ngoal (1 subgoal):\n 1. NI_unrelated", "unfolding NI_unrelated_def"], ["proof (prove)\nusing this:\n  run ?n2 (Some s0) ?execs2 \\<rightharpoonup>\n  (\\<lambda>s_f.\n      run ?n2 (Some s0) (purge ?execs2 (current s_f)) \\<rightharpoonup>\n      (\\<lambda>s_f2.\n          output_f s_f ?a2 = output_f s_f2 ?a2 \\<and>\n          current s_f = current s_f2))\n\ngoal (1 subgoal):\n 1. \\<forall>execs a n.\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           run n (Some s0) (purge execs (current s_f)) \\<rightharpoonup>\n           (\\<lambda>s_f2.\n               output_f s_f a = output_f s_f2 a \\<and>\n               current s_f = current s_f2))", "by auto"], ["proof (state)\nthis:\n  NI_unrelated\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Security for indirectly interfering domains\\<close>"], ["", "text \\<open>\nConsider the following security policy over three domains $A$, $B$ and $C$: $A \\leadsto B \\leadsto C$,\nbut $A \\not\\leadsto C$.\nThe semantics of this policy is that $A$ may communicate with $C$, but \\emph{only} via $B$. No direct communication from $A$ to $C$ is allowed.\nWe formalize these semantics as follows:\nwithout intermediate domain $B$, domain $A$ cannot flow information to $C$.\nIn other words, from the point of view of domain $C$ the run where domain $B$ is inactive must be equivalent to the run where domain $B$ is inactive and domain $A$ is replaced by an attacker.\nDomain $C$ must be independent of domain $A$, when domain $B$ is inactive.\n\nThe aim of this subsection is to formalize the semantics where $A$ can write to $C$ via $B$ \\emph{only}.\nWe define to two ipurge functions. The first purges all domains $d$ that are \\emph{intermediary} for some other domain $v$.\nAn intermediary for $u$ is defined as a domain $d$ for which there exists an information flow from some domain $v$ to $u$ via $d$, but no direct information flow from $v$ to $u$ is allowed.\n\\<close>"], ["", "definition intermediary :: \"'dom_t \\<Rightarrow> 'dom_t \\<Rightarrow> bool\"\nwhere \"intermediary d u \\<equiv> \\<exists> v . ifp^** v d \\<and> ifp d u \\<and> \\<not>ifp v u \\<and> d \\<noteq> u\""], ["", "primrec remove_gateway_communications :: \"'dom_t \\<Rightarrow> 'action_t execution \\<Rightarrow> 'action_t execution\"\nwhere \"remove_gateway_communications u [] = []\"\n    | \"remove_gateway_communications u (aseq#exec) = (if \\<exists> a \\<in> set aseq . \\<exists> v . intermediary v u \\<and> v \\<in> involved (Some a) then [] else aseq)#(remove_gateway_communications u exec)\""], ["", "definition ipurge_l ::\n  \"('dom_t \\<Rightarrow> 'action_t execution) \\<Rightarrow> 'dom_t \\<Rightarrow> ('dom_t \\<Rightarrow> 'action_t execution)\" where\n  \"ipurge_l execs u \\<equiv> \\<lambda> d . if intermediary d u then\n                              []\n                            else if d = u then\n                              remove_gateway_communications u (execs u)\n                            else execs d\""], ["", "text \\<open>\nThe second ipurge removes both the intermediaries and the \\emph{indirect sources}.\nAn indirect source for $u$ is defined as a domain that may indirectly flow information to $u$, but not directly.\n\\<close>"], ["", "abbreviation ind_source :: \"'dom_t \\<Rightarrow> 'dom_t \\<Rightarrow> bool\"\nwhere \"ind_source d u \\<equiv> ifp^** d u \\<and> \\<not>ifp d u\""], ["", "definition ipurge_r ::\n  \"('dom_t \\<Rightarrow> 'action_t execution) \\<Rightarrow> 'dom_t \\<Rightarrow> ('dom_t \\<Rightarrow> 'action_t execution)\" where\n  \"ipurge_r execs u \\<equiv> \\<lambda> d . if intermediary d u then\n                              []\n                            else if ind_source d u then\n                              SOME alpha . realistic_execution alpha\n                            else if d = u then\n                              remove_gateway_communications u (execs u)\n                            else\n                              execs d\""], ["", "text \\<open>\nFor a system with an intransitive policy to be called secure for domain $u$ any indirect source may not flow information towards $u$ when the intermediaries are purged out.\nThis definition of security allows the information flow $A \\leadsto B \\leadsto C$, but prohibits $A \\leadsto C$.\n\\<close>"], ["", "definition NI_indirect_sources ::bool\nwhere \"NI_indirect_sources \n  \\<equiv> \\<forall> execs a n. run n (Some s0) execs \\<rightharpoonup>\n                   (\\<lambda> s_f . (run n (Some s0) (ipurge_l execs (current s_f)) \\<parallel>\n                             run n (Some s0) (ipurge_r execs  (current s_f)) \\<rightharpoonup>\n                                 (\\<lambda> s_l s_r . output_f s_l a = output_f s_r a)))\""], ["", "text \\<open>\nThis definition concerns indirect sources only. It does not enforce that an \\emph{unrelated} domain may not flow information to $u$.\nThis is expressed by ``secure''.\n\\<close>"], ["", "text \\<open>This allows us to define security over intransitive policies.\n\\<close>"], ["", "definition isecure::bool\nwhere \"isecure \\<equiv> NI_indirect_sources  \\<and> NI_unrelated\""], ["", "abbreviation iequivalent_states :: \"'state_t option  \\<Rightarrow> 'state_t option \\<Rightarrow> 'dom_t \\<Rightarrow> bool\"\nwhere \"iequivalent_states s t u \\<equiv> s \\<parallel> t \\<rightharpoonup> (\\<lambda> s t . (\\<forall> v . ifp v u \\<and> \\<not>intermediary v u \\<longrightarrow> vpeq v s t) \\<and> current s = current t)\""], ["", "definition does_not_communicate_with_gateway\nwhere \"does_not_communicate_with_gateway u execs \\<equiv> \\<forall> a . a \\<in> actions_in_execution (execs u) \\<longrightarrow> (\\<forall> v . intermediary v u \\<longrightarrow> v \\<notin> involved (Some a))\""], ["", "definition iview_partitioned::bool where \"iview_partitioned\n  \\<equiv> \\<forall> execs ms mt n u . iequivalent_states ms mt u  \\<longrightarrow>\n        (run n ms (ipurge_l execs u) \\<parallel>\n         run n mt (ipurge_r execs u) \\<rightharpoonup>\n         (\\<lambda> rs rt . vpeq u rs rt \\<and> current rs = current rt))\""], ["", "definition ipurged_relation1 :: \"'dom_t \\<Rightarrow> ('dom_t \\<Rightarrow> 'action_t execution) \\<Rightarrow> ('dom_t \\<Rightarrow> 'action_t execution) \\<Rightarrow> bool\"\nwhere \"ipurged_relation1 u execs1 execs2 \\<equiv> \\<forall> d . (ifp d u \\<longrightarrow> execs1 d = execs2 d) \\<and> (intermediary d u \\<longrightarrow> execs1 d = [])\""], ["", "text \\<open>\n  Proof that if the current is not an intermediary for u, then all domains involved in the next action are vpeq.\n\\<close>"], ["", "lemma vpeq_involved_domains:\nassumes ifp_curr: \"ifp (current s) u\"\n    and not_intermediary_curr: \"\\<not>intermediary (current s) u\"\n    and no_gateway_comm: \"does_not_communicate_with_gateway u execs\"\n    and vpeq_s_t: \"\\<forall> v . ifp v u \\<and> \\<not>intermediary v u \\<longrightarrow> vpeq v s t'\"\n    and prec_s: \"precondition (next_state s execs) (next_action s execs)\"\n  shows \"\\<forall> d \\<in> involved (next_action s execs) . vpeq d s t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>involved (next_action s execs). vpeq d s t'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>involved (next_action s execs). vpeq d s t'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>involved (next_action s execs). vpeq d s t'", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>involved (next_action s execs). vpeq d s t'", "assume involved: \"v \\<in> involved (next_action s execs)\""], ["proof (state)\nthis:\n  v \\<in> involved (next_action s execs)\n\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>involved (next_action s execs). vpeq d s t'", "from this prec_s involved_ifp[THEN spec,THEN spec,where x1=\"next_state s execs\" and x=\"next_action s execs\"]"], ["proof (chain)\npicking this:\n  v \\<in> involved (next_action s execs)\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>d\\<in>involved (next_action s execs).\n     kprecondition (next_state s execs)\n      (the (next_action s execs)) \\<longrightarrow>\n     ifp d (current (next_state s execs))", "have ifp_v_curr: \"ifp v (current s)\""], ["proof (prove)\nusing this:\n  v \\<in> involved (next_action s execs)\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>d\\<in>involved (next_action s execs).\n     kprecondition (next_state s execs)\n      (the (next_action s execs)) \\<longrightarrow>\n     ifp d (current (next_state s execs))\n\ngoal (1 subgoal):\n 1. ifp v (current s)", "using current_next_state"], ["proof (prove)\nusing this:\n  v \\<in> involved (next_action s execs)\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>d\\<in>involved (next_action s execs).\n     kprecondition (next_state s execs)\n      (the (next_action s execs)) \\<longrightarrow>\n     ifp d (current (next_state s execs))\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. ifp v (current s)", "unfolding involved_def precondition_def B_def"], ["proof (prove)\nusing this:\n  v \\<in> (case next_action s execs of None \\<Rightarrow> {}\n           | Some a \\<Rightarrow> kinvolved a)\n  case next_action s execs of None \\<Rightarrow> True\n  | Some a \\<Rightarrow> kprecondition (next_state s execs) a\n  \\<forall>d\\<in>case next_action s execs of None \\<Rightarrow> {}\n                 | Some a \\<Rightarrow> kinvolved a.\n     kprecondition (next_state s execs)\n      (the (next_action s execs)) \\<longrightarrow>\n     ifp d (current (next_state s execs))\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. ifp v (current s)", "by(cases \"next_action s execs\",auto)"], ["proof (state)\nthis:\n  ifp v (current s)\n\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>involved (next_action s execs). vpeq d s t'", "have \"vpeq v s t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq v s t'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. vpeq v s t'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. vpeq v s t'", "assume \"ifp v u \\<and> \\<not>intermediary v u\""], ["proof (state)\nthis:\n  ifp v u \\<and> \\<not> intermediary v u\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "from this vpeq_s_t"], ["proof (chain)\npicking this:\n  ifp v u \\<and> \\<not> intermediary v u\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'", "have \"vpeq v s t'\""], ["proof (prove)\nusing this:\n  ifp v u \\<and> \\<not> intermediary v u\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "by (auto)"], ["proof (state)\nthis:\n  vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "}"], ["proof (state)\nthis:\n  ifp v u \\<and> \\<not> intermediary v u \\<Longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "moreover"], ["proof (state)\nthis:\n  ifp v u \\<and> \\<not> intermediary v u \\<Longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "{"], ["proof (state)\nthis:\n  ifp v u \\<and> \\<not> intermediary v u \\<Longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "assume not_intermediary_v: \"intermediary v u\""], ["proof (state)\nthis:\n  intermediary v u\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "from ifp_curr not_intermediary_curr ifp_v_curr not_intermediary_v"], ["proof (chain)\npicking this:\n  ifp (current s) u\n  \\<not> intermediary (current s) u\n  ifp v (current s)\n  intermediary v u", "have curr_is_u: \"current s = u\""], ["proof (prove)\nusing this:\n  ifp (current s) u\n  \\<not> intermediary (current s) u\n  ifp v (current s)\n  intermediary v u\n\ngoal (1 subgoal):\n 1. current s = u", "using rtranclp_trans r_into_rtranclp"], ["proof (prove)\nusing this:\n  ifp (current s) u\n  \\<not> intermediary (current s) u\n  ifp v (current s)\n  intermediary v u\n  \\<lbrakk>?r\\<^sup>*\\<^sup>* ?x ?y; ?r\\<^sup>*\\<^sup>* ?y ?z\\<rbrakk>\n  \\<Longrightarrow> ?r\\<^sup>*\\<^sup>* ?x ?z\n  ?r ?x ?y \\<Longrightarrow> ?r\\<^sup>*\\<^sup>* ?x ?y\n\ngoal (1 subgoal):\n 1. current s = u", "by (metis intermediary_def)"], ["proof (state)\nthis:\n  current s = u\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "from curr_is_u next_action_from_execs[THEN spec,THEN spec,where x=execs and x1=s] not_intermediary_v involved\n         no_gateway_comm[unfolded does_not_communicate_with_gateway_def,THEN spec,where x=\"the (next_action s execs)\"]"], ["proof (chain)\npicking this:\n  current s = u\n  next_action s execs \\<rightharpoonup>\n  (\\<lambda>a. a \\<in> actions_in_execution (execs (current s)))\n  intermediary v u\n  v \\<in> involved (next_action s execs)\n  the (next_action s execs)\n  \\<in> actions_in_execution (execs u) \\<longrightarrow>\n  (\\<forall>v.\n      intermediary v u \\<longrightarrow>\n      v \\<notin> involved (Some (the (next_action s execs))))", "have False"], ["proof (prove)\nusing this:\n  current s = u\n  next_action s execs \\<rightharpoonup>\n  (\\<lambda>a. a \\<in> actions_in_execution (execs (current s)))\n  intermediary v u\n  v \\<in> involved (next_action s execs)\n  the (next_action s execs)\n  \\<in> actions_in_execution (execs u) \\<longrightarrow>\n  (\\<forall>v.\n      intermediary v u \\<longrightarrow>\n      v \\<notin> involved (Some (the (next_action s execs))))\n\ngoal (1 subgoal):\n 1. False", "unfolding involved_def B_def"], ["proof (prove)\nusing this:\n  current s = u\n  case next_action s execs of None \\<Rightarrow> True\n  | Some a \\<Rightarrow> a \\<in> actions_in_execution (execs (current s))\n  intermediary v u\n  v \\<in> (case next_action s execs of None \\<Rightarrow> {}\n           | Some a \\<Rightarrow> kinvolved a)\n  the (next_action s execs)\n  \\<in> actions_in_execution (execs u) \\<longrightarrow>\n  (\\<forall>v.\n      intermediary v u \\<longrightarrow>\n      v \\<notin> (case Some (the (next_action s execs)) of\n                  None \\<Rightarrow> {} | Some a \\<Rightarrow> kinvolved a))\n\ngoal (1 subgoal):\n 1. False", "by (cases \"next_action s execs\",auto)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "hence \"vpeq v s t'\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "by auto"], ["proof (state)\nthis:\n  vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "}"], ["proof (state)\nthis:\n  intermediary v u \\<Longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "moreover"], ["proof (state)\nthis:\n  intermediary v u \\<Longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "{"], ["proof (state)\nthis:\n  intermediary v u \\<Longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "assume intermediary_v: \"\\<not> ifp v u\""], ["proof (state)\nthis:\n  \\<not> ifp v u\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "from ifp_curr not_intermediary_curr ifp_v_curr intermediary_v"], ["proof (chain)\npicking this:\n  ifp (current s) u\n  \\<not> intermediary (current s) u\n  ifp v (current s)\n  \\<not> ifp v u", "have \"False\""], ["proof (prove)\nusing this:\n  ifp (current s) u\n  \\<not> intermediary (current s) u\n  ifp v (current s)\n  \\<not> ifp v u\n\ngoal (1 subgoal):\n 1. False", "unfolding intermediary_def"], ["proof (prove)\nusing this:\n  ifp (current s) u\n  \\<nexists>v.\n     ifp\\<^sup>*\\<^sup>* v (current s) \\<and>\n     ifp (current s) u \\<and> \\<not> ifp v u \\<and> current s \\<noteq> u\n  ifp v (current s)\n  \\<not> ifp v u\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "hence \"vpeq v s t'\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "by auto"], ["proof (state)\nthis:\n  vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "}"], ["proof (state)\nthis:\n  \\<not> ifp v u \\<Longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "ultimately"], ["proof (chain)\npicking this:\n  ifp v u \\<and> \\<not> intermediary v u \\<Longrightarrow> vpeq v s t'\n  intermediary v u \\<Longrightarrow> vpeq v s t'\n  \\<not> ifp v u \\<Longrightarrow> vpeq v s t'", "show \"vpeq v s t'\""], ["proof (prove)\nusing this:\n  ifp v u \\<and> \\<not> intermediary v u \\<Longrightarrow> vpeq v s t'\n  intermediary v u \\<Longrightarrow> vpeq v s t'\n  \\<not> ifp v u \\<Longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "unfolding intermediary_def"], ["proof (prove)\nusing this:\n  ifp v u \\<and>\n  (\\<nexists>va.\n      ifp\\<^sup>*\\<^sup>* va v \\<and>\n      ifp v u \\<and> \\<not> ifp va u \\<and> v \\<noteq> u) \\<Longrightarrow>\n  vpeq v s t'\n  \\<exists>va.\n     ifp\\<^sup>*\\<^sup>* va v \\<and>\n     ifp v u \\<and> \\<not> ifp va u \\<and> v \\<noteq> u \\<Longrightarrow>\n  vpeq v s t'\n  \\<not> ifp v u \\<Longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "by auto"], ["proof (state)\nthis:\n  vpeq v s t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vpeq v s t'\n\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>involved (next_action s execs). vpeq d s t'", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> involved (next_action s execs) \\<Longrightarrow> vpeq ?v2 s t'\n\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>involved (next_action s execs). vpeq d s t'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?v2 \\<in> involved (next_action s execs) \\<Longrightarrow> vpeq ?v2 s t'\n\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>involved (next_action s execs). vpeq d s t'", "by auto"], ["proof (state)\nthis:\n  \\<forall>d\\<in>involved (next_action s execs). vpeq d s t'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Proof that purging removes communications of the gateway to domain u.\n\\<close>"], ["", "lemma ipurge_l_removes_gateway_communications:\nshows \"does_not_communicate_with_gateway u (ipurge_l execs u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (ipurge_l execs u)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (ipurge_l execs u)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (ipurge_l execs u)", "fix aseq u execs a v"], ["proof (state)\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (ipurge_l execs u)", "assume 1: \"aseq \\<in> set (remove_gateway_communications u (execs u))\""], ["proof (state)\nthis:\n  aseq \\<in> set (remove_gateway_communications u (execs u))\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (ipurge_l execs u)", "assume 2: \"a \\<in> set aseq\""], ["proof (state)\nthis:\n  a \\<in> set aseq\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (ipurge_l execs u)", "assume 3: \"intermediary v u\""], ["proof (state)\nthis:\n  intermediary v u\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (ipurge_l execs u)", "have 4: \"v \\<notin> involved (Some a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> involved (Some a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> involved (Some a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> involved (Some a)", "fix a::'action_t"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> involved (Some a__)", "fix aseq u exec v"], ["proof (state)\ngoal (1 subgoal):\n 1. v__ \\<notin> involved (Some a__)", "have \"aseq \\<in> set (remove_gateway_communications u exec) \\<and> a \\<in> set aseq \\<and> intermediary v u \\<longrightarrow> v \\<notin> involved (Some a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aseq \\<in> set (remove_gateway_communications u exec) \\<and>\n    a \\<in> set aseq \\<and> intermediary v u \\<longrightarrow>\n    v \\<notin> involved (Some a)", "by(induct exec,auto)"], ["proof (state)\nthis:\n  aseq \\<in> set (remove_gateway_communications u exec) \\<and>\n  a \\<in> set aseq \\<and> intermediary v u \\<longrightarrow>\n  v \\<notin> involved (Some a)\n\ngoal (1 subgoal):\n 1. v__ \\<notin> involved (Some a__)", "}"], ["proof (state)\nthis:\n  ?aseqa2 \\<in> set (remove_gateway_communications ?ub2 ?exec2) \\<and>\n  ?aa2 \\<in> set ?aseqa2 \\<and> intermediary ?va2 ?ub2 \\<longrightarrow>\n  ?va2 \\<notin> involved (Some ?aa2)\n\ngoal (1 subgoal):\n 1. v \\<notin> involved (Some a)", "from 1 2 3 this"], ["proof (chain)\npicking this:\n  aseq \\<in> set (remove_gateway_communications u (execs u))\n  a \\<in> set aseq\n  intermediary v u\n  ?aseqa2 \\<in> set (remove_gateway_communications ?ub2 ?exec2) \\<and>\n  ?aa2 \\<in> set ?aseqa2 \\<and> intermediary ?va2 ?ub2 \\<longrightarrow>\n  ?va2 \\<notin> involved (Some ?aa2)", "show ?thesis"], ["proof (prove)\nusing this:\n  aseq \\<in> set (remove_gateway_communications u (execs u))\n  a \\<in> set aseq\n  intermediary v u\n  ?aseqa2 \\<in> set (remove_gateway_communications ?ub2 ?exec2) \\<and>\n  ?aa2 \\<in> set ?aseqa2 \\<and> intermediary ?va2 ?ub2 \\<longrightarrow>\n  ?va2 \\<notin> involved (Some ?aa2)\n\ngoal (1 subgoal):\n 1. v \\<notin> involved (Some a)", "by metis"], ["proof (state)\nthis:\n  v \\<notin> involved (Some a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<notin> involved (Some a)\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (ipurge_l execs u)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?aseq2\n           \\<in> set (remove_gateway_communications ?ua2 (?execsa2 ?ua2));\n   ?a2 \\<in> set ?aseq2; intermediary ?v2 ?ua2\\<rbrakk>\n  \\<Longrightarrow> ?v2 \\<notin> involved (Some ?a2)\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (ipurge_l execs u)", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>?aseq2\n           \\<in> set (remove_gateway_communications ?ua2 (?execsa2 ?ua2));\n   ?a2 \\<in> set ?aseq2; intermediary ?v2 ?ua2\\<rbrakk>\n  \\<Longrightarrow> ?v2 \\<notin> involved (Some ?a2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?aseq2\n           \\<in> set (remove_gateway_communications ?ua2 (?execsa2 ?ua2));\n   ?a2 \\<in> set ?aseq2; intermediary ?v2 ?ua2\\<rbrakk>\n  \\<Longrightarrow> ?v2 \\<notin> involved (Some ?a2)\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (ipurge_l execs u)", "unfolding does_not_communicate_with_gateway_def ipurge_l_def actions_in_execution_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?aseq2\n           \\<in> set (remove_gateway_communications ?ua2 (?execsa2 ?ua2));\n   ?a2 \\<in> set ?aseq2; intermediary ?v2 ?ua2\\<rbrakk>\n  \\<Longrightarrow> ?v2 \\<notin> involved (Some ?a2)\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       a \\<in> {a. \\<exists>aseq\n                            \\<in>set (if intermediary u u then []\nelse if u = u then remove_gateway_communications u (execs u) else execs u).\n                      a \\<in> set aseq} \\<longrightarrow>\n       (\\<forall>v.\n           intermediary v u \\<longrightarrow> v \\<notin> involved (Some a))", "by auto"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u (ipurge_l execs u)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Proof of view partitioning. The lemma is structured exactly as lemma unwinding\\_implies\\_view\\_partitioned\\_ind and uses the same convention for naming.\n\\<close>"], ["", "lemma iunwinding_implies_view_partitioned1:\nshows iview_partitioned"], ["proof (prove)\ngoal (1 subgoal):\n 1. iview_partitioned", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. iview_partitioned", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. iview_partitioned", "fix u execs execs2 s t n"], ["proof (state)\ngoal (1 subgoal):\n 1. iview_partitioned", "have \"does_not_communicate_with_gateway u execs \\<and> iequivalent_states s t u \\<and> ipurged_relation1 u execs execs2 \\<longrightarrow> iequivalent_states (run n s execs) (run n t execs2) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u execs \\<and>\n    iequivalent_states s t u \\<and>\n    ipurged_relation1 u execs execs2 \\<longrightarrow>\n    iequivalent_states (run n s execs) (run n t execs2) u", "proof (induct n s execs arbitrary: t u execs2 rule: run.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s execs t u execs2.\n       does_not_communicate_with_gateway u execs \\<and>\n       iequivalent_states s t u \\<and>\n       ipurged_relation1 u execs execs2 \\<longrightarrow>\n       iequivalent_states (run 0 s execs) (run 0 t execs2) u\n 2. \\<And>n execs t u execs2.\n       does_not_communicate_with_gateway u execs \\<and>\n       iequivalent_states None t u \\<and>\n       ipurged_relation1 u execs execs2 \\<longrightarrow>\n       iequivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u\n 3. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 5. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 6. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "case (1 s execs t u execs2)"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>s execs t u execs2.\n       does_not_communicate_with_gateway u execs \\<and>\n       iequivalent_states s t u \\<and>\n       ipurged_relation1 u execs execs2 \\<longrightarrow>\n       iequivalent_states (run 0 s execs) (run 0 t execs2) u\n 2. \\<And>n execs t u execs2.\n       does_not_communicate_with_gateway u execs \\<and>\n       iequivalent_states None t u \\<and>\n       ipurged_relation1 u execs execs2 \\<longrightarrow>\n       iequivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u\n 3. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 5. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 6. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u execs \\<and>\n    iequivalent_states s t u \\<and>\n    ipurged_relation1 u execs execs2 \\<longrightarrow>\n    iequivalent_states (run 0 s execs) (run 0 t execs2) u", "by auto"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states s t u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run 0 s execs) (run 0 t execs2) u\n\ngoal (5 subgoals):\n 1. \\<And>n execs t u execs2.\n       does_not_communicate_with_gateway u execs \\<and>\n       iequivalent_states None t u \\<and>\n       ipurged_relation1 u execs execs2 \\<longrightarrow>\n       iequivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u\n 2. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 5. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n execs t u execs2.\n       does_not_communicate_with_gateway u execs \\<and>\n       iequivalent_states None t u \\<and>\n       ipurged_relation1 u execs execs2 \\<longrightarrow>\n       iequivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u\n 2. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 5. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "case (2 n execs t u execs2)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>n execs t u execs2.\n       does_not_communicate_with_gateway u execs \\<and>\n       iequivalent_states None t u \\<and>\n       ipurged_relation1 u execs execs2 \\<longrightarrow>\n       iequivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u\n 2. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 5. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u execs \\<and>\n    iequivalent_states None t u \\<and>\n    ipurged_relation1 u execs execs2 \\<longrightarrow>\n    iequivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u", "by simp"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states None t u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run (Suc n) None execs) (run (Suc n) t execs2) u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "case (3 n s execs t u execs2)"], ["proof (state)\nthis:\n  interrupt (Suc n)\n  does_not_communicate_with_gateway ?u execs \\<and>\n  iequivalent_states (Some (cswitch (Suc n) s)) ?t ?u \\<and>\n  ipurged_relation1 ?u execs ?execs2.0 \\<longrightarrow>\n  iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n ?t ?execs2.0) ?u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume interrupt_s: \"interrupt (Suc n)\""], ["proof (state)\nthis:\n  interrupt (Suc n)\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume IH: \"(\\<And>t u execs2. does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and> ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs) (run n t execs2) u)\""], ["proof (state)\nthis:\n  does_not_communicate_with_gateway ?u execs \\<and>\n  iequivalent_states (Some (cswitch (Suc n) s)) ?t ?u \\<and>\n  ipurged_relation1 ?u execs ?execs2.0 \\<longrightarrow>\n  iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n ?t ?execs2.0) ?u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "{"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway ?u execs \\<and>\n  iequivalent_states (Some (cswitch (Suc n) s)) ?t ?u \\<and>\n  ipurged_relation1 ?u execs ?execs2.0 \\<longrightarrow>\n  iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n ?t ?execs2.0) ?u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix t' :: 'state_t"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume \"t = Some t'\""], ["proof (state)\nthis:\n  t = Some t'\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix rs"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume rs: \"run (Suc n) (Some s) execs = Some rs\""], ["proof (state)\nthis:\n  run (Suc n) (Some s) execs = Some rs\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix rt"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume rt: \"run (Suc n) (Some t') execs2 = Some rt\""], ["proof (state)\nthis:\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume no_gateway_comm: \"does_not_communicate_with_gateway u execs\""], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u execs\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume vpeq_s_t: \"\\<forall> v . ifp v u \\<and> \\<not>intermediary v u \\<longrightarrow> vpeq v s t'\""], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume current_s_t: \"current s = current t'\""], ["proof (state)\nthis:\n  current s = current t'\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume purged_a_a2: \"ipurged_relation1 u execs execs2\""], ["proof (state)\nthis:\n  ipurged_relation1 u execs execs2\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from current_s_t cswitch_independent_of_state"], ["proof (chain)\npicking this:\n  current s = current t'\n  \\<forall>n s t.\n     current s = current t \\<longrightarrow>\n     current (cswitch n s) = current (cswitch n t)", "have current_ns_nt: \"current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\""], ["proof (prove)\nusing this:\n  current s = current t'\n  \\<forall>n s t.\n     current s = current t \\<longrightarrow>\n     current (cswitch n s) = current (cswitch n t)\n\ngoal (1 subgoal):\n 1. current (cswitch (Suc n) s) = current (cswitch (Suc n) t')", "by blast"], ["proof (state)\nthis:\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from cswitch_consistency vpeq_s_t"], ["proof (chain)\npicking this:\n  \\<forall>u s t n.\n     vpeq u s t \\<longrightarrow> vpeq u (cswitch n s) (cswitch n t)\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'", "have vpeq_ns_nt: \"\\<forall> v . ifp v u \\<and> \\<not>intermediary v u \\<longrightarrow> vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\""], ["proof (prove)\nusing this:\n  \\<forall>u s t n.\n     vpeq u s t \\<longrightarrow> vpeq u (cswitch n s) (cswitch n t)\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n       vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')", "by auto"], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from no_gateway_comm current_ns_nt vpeq_ns_nt interrupt_s vpeq_reflexive current_s_t purged_a_a2 IH[where u=u and t=\"Some (cswitch (Suc n) t')\" and ?execs2.0=execs2]"], ["proof (chain)\npicking this:\n  does_not_communicate_with_gateway u execs\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n  interrupt (Suc n)\n  \\<forall>a u. vpeq u a a\n  current s = current t'\n  ipurged_relation1 u execs execs2\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some (cswitch (Suc n) s)) (Some (cswitch (Suc n) t'))\n   u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2) u", "have current_rs_rt: \"current rs = current rt\""], ["proof (prove)\nusing this:\n  does_not_communicate_with_gateway u execs\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n  interrupt (Suc n)\n  \\<forall>a u. vpeq u a a\n  current s = current t'\n  ipurged_relation1 u execs execs2\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some (cswitch (Suc n) s)) (Some (cswitch (Suc n) t'))\n   u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2) u\n\ngoal (1 subgoal):\n 1. current rs = current rt", "using rs rt"], ["proof (prove)\nusing this:\n  does_not_communicate_with_gateway u execs\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n  interrupt (Suc n)\n  \\<forall>a u. vpeq u a a\n  current s = current t'\n  ipurged_relation1 u execs execs2\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some (cswitch (Suc n) s)) (Some (cswitch (Suc n) t'))\n   u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2) u\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. current rs = current rt", "by(auto)"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "{"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix v"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume ia: \"ifp v u \\<and> \\<not>intermediary v u\""], ["proof (state)\nthis:\n  ifp v u \\<and> \\<not> intermediary v u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from no_gateway_comm interrupt_s current_ns_nt vpeq_ns_nt vpeq_reflexive ia current_s_t purged_a_a2 IH[where u=u and t=\"Some (cswitch (Suc n) t')\" and ?execs2.0=execs2]"], ["proof (chain)\npicking this:\n  does_not_communicate_with_gateway u execs\n  interrupt (Suc n)\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n  \\<forall>a u. vpeq u a a\n  ifp v u \\<and> \\<not> intermediary v u\n  current s = current t'\n  ipurged_relation1 u execs execs2\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some (cswitch (Suc n) s)) (Some (cswitch (Suc n) t'))\n   u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2) u", "have \"vpeq v rs rt\""], ["proof (prove)\nusing this:\n  does_not_communicate_with_gateway u execs\n  interrupt (Suc n)\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n  \\<forall>a u. vpeq u a a\n  ifp v u \\<and> \\<not> intermediary v u\n  current s = current t'\n  ipurged_relation1 u execs execs2\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some (cswitch (Suc n) s)) (Some (cswitch (Suc n) t'))\n   u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2) u\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "using rs rt"], ["proof (prove)\nusing this:\n  does_not_communicate_with_gateway u execs\n  interrupt (Suc n)\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v (cswitch (Suc n) s) (cswitch (Suc n) t')\n  \\<forall>a u. vpeq u a a\n  ifp v u \\<and> \\<not> intermediary v u\n  current s = current t'\n  ipurged_relation1 u execs execs2\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some (cswitch (Suc n) s)) (Some (cswitch (Suc n) t'))\n   u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2) u\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "by(auto)"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "}"], ["proof (state)\nthis:\n  ifp ?v2 u \\<and> \\<not> intermediary ?v2 u \\<Longrightarrow>\n  vpeq ?v2 rs rt\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from current_rs_rt and this"], ["proof (chain)\npicking this:\n  current rs = current rt\n  ifp ?v2 u \\<and> \\<not> intermediary ?v2 u \\<Longrightarrow>\n  vpeq ?v2 rs rt", "have \"iequivalent_states (Some rs) (Some rt) u\""], ["proof (prove)\nusing this:\n  current rs = current rt\n  ifp ?v2 u \\<and> \\<not> intermediary ?v2 u \\<Longrightarrow>\n  vpeq ?v2 rs rt\n\ngoal (1 subgoal):\n 1. iequivalent_states (Some rs) (Some rt) u", "by auto"], ["proof (state)\nthis:\n  iequivalent_states (Some rs) (Some rt) u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "}"], ["proof (state)\nthis:\n  \\<lbrakk>t = Some ?t'2; run (Suc n) (Some s) execs = Some ?rs2;\n   run (Suc n) (Some ?t'2) execs2 = Some ?rt2;\n   does_not_communicate_with_gateway u execs;\n   \\<forall>v.\n      ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n      vpeq v s ?t'2;\n   current s = current ?t'2; ipurged_relation1 u execs execs2\\<rbrakk>\n  \\<Longrightarrow> iequivalent_states (Some ?rs2) (Some ?rt2) u\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t u execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some (cswitch (Suc n) s)) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 4. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Some ?t'2; run (Suc n) (Some s) execs = Some ?rs2;\n   run (Suc n) (Some ?t'2) execs2 = Some ?rt2;\n   does_not_communicate_with_gateway u execs;\n   \\<forall>v.\n      ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n      vpeq v s ?t'2;\n   current s = current ?t'2; ipurged_relation1 u execs execs2\\<rbrakk>\n  \\<Longrightarrow> iequivalent_states (Some ?rs2) (Some ?rt2) u\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u execs \\<and>\n    iequivalent_states (Some s) t u \\<and>\n    ipurged_relation1 u execs execs2 \\<longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u", "by(simp add:option.splits,cases t,simp+)"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some s) t u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "case (4 n execs s t u execs2)"], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n  thread_empty (execs (current s))\n  does_not_communicate_with_gateway ?u execs \\<and>\n  iequivalent_states (Some s) ?t ?u \\<and>\n  ipurged_relation1 ?u execs ?execs2.0 \\<longrightarrow>\n  iequivalent_states (run n (Some s) execs) (run n ?t ?execs2.0) ?u\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume not_interrupt: \"\\<not>interrupt (Suc n)\""], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume thread_empty_s: \"thread_empty(execs (current s))\""], ["proof (state)\nthis:\n  thread_empty (execs (current s))\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume IH: \"(\\<And>t u execs2. does_not_communicate_with_gateway u execs \\<and> iequivalent_states (Some s) t u \\<and> ipurged_relation1 u execs execs2 \\<longrightarrow> iequivalent_states (run n (Some s) execs) (run n t execs2) u)\""], ["proof (state)\nthis:\n  does_not_communicate_with_gateway ?u execs \\<and>\n  iequivalent_states (Some s) ?t ?u \\<and>\n  ipurged_relation1 ?u execs ?execs2.0 \\<longrightarrow>\n  iequivalent_states (run n (Some s) execs) (run n ?t ?execs2.0) ?u\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "{"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway ?u execs \\<and>\n  iequivalent_states (Some s) ?t ?u \\<and>\n  ipurged_relation1 ?u execs ?execs2.0 \\<longrightarrow>\n  iequivalent_states (run n (Some s) execs) (run n ?t ?execs2.0) ?u\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix t'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume t: \"t = Some t'\""], ["proof (state)\nthis:\n  t = Some t'\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix rs"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume rs: \"run (Suc n) (Some s) execs = Some rs\""], ["proof (state)\nthis:\n  run (Suc n) (Some s) execs = Some rs\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix rt"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume rt: \"run (Suc n) (Some t') execs2 = Some rt\""], ["proof (state)\nthis:\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume no_gateway_comm: \"does_not_communicate_with_gateway u execs\""], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u execs\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume vpeq_s_t: \"\\<forall> v . ifp v u \\<and> \\<not>intermediary v u \\<longrightarrow> vpeq v s t'\""], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume current_s_t: \"current s = current t'\""], ["proof (state)\nthis:\n  current s = current t'\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume purged_a_a2: \"ipurged_relation1 u execs execs2\""], ["proof (state)\nthis:\n  ipurged_relation1 u execs execs2\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from ifp_reflexive vpeq_s_t"], ["proof (chain)\npicking this:\n  \\<forall>u. ifp u u\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'", "have vpeq_u_s_t: \"vpeq u s t'\""], ["proof (prove)\nusing this:\n  \\<forall>u. ifp u u\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq u s t'", "unfolding intermediary_def"], ["proof (prove)\nusing this:\n  \\<forall>u. ifp u u\n  \\<forall>v.\n     ifp v u \\<and>\n     (\\<nexists>va.\n         ifp\\<^sup>*\\<^sup>* va v \\<and>\n         ifp v u \\<and>\n         \\<not> ifp va u \\<and> v \\<noteq> u) \\<longrightarrow>\n     vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq u s t'", "by auto"], ["proof (state)\nthis:\n  vpeq u s t'\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from step_atomicity current_next_state current_s_t"], ["proof (chain)\npicking this:\n  \\<forall>s a. current (kstep s a) = current s\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'", "have current_s_nt: \"current s = current (step (next_state t' execs2) (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'\n\ngoal (1 subgoal):\n 1. current s =\n    current (step (next_state t' execs2) (next_action t' execs2))", "unfolding step_def"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'\n\ngoal (1 subgoal):\n 1. current s =\n    current\n     (case next_action t' execs2 of None \\<Rightarrow> next_state t' execs2\n      | Some a \\<Rightarrow> kstep (next_state t' execs2) a)", "by (cases \"next_action s execs\",cases \"next_action t' execs2\",simp,simp,cases \"next_action t' execs2\",simp,simp)"], ["proof (state)\nthis:\n  current s = current (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from vpeq_s_t"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'", "have vpeq_curr_s_t: \"ifp (current s) u \\<and> \\<not>intermediary (current s) u \\<longrightarrow> vpeq (current s) s t'\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. ifp (current s) u \\<and>\n    \\<not> intermediary (current s) u \\<longrightarrow>\n    vpeq (current s) s t'", "by auto"], ["proof (state)\nthis:\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  vpeq (current s) s t'\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "have \"iequivalent_states (run (Suc n) (Some s) execs) (run (Suc n) (Some t') execs2) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "proof(cases \"thread_empty(execs2 (current t'))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "case True"], ["proof (state)\nthis:\n  thread_empty (execs2 (current t'))\n\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from purged_a_a2 and vpeq_s_t and current_s_t IH[where t=\"Some t'\" and u=u and ?execs2.0=execs2] no_gateway_comm"], ["proof (chain)\npicking this:\n  ipurged_relation1 u execs execs2\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  current s = current t'\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some s) (Some t') u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  does_not_communicate_with_gateway u execs", "have \"iequivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\""], ["proof (prove)\nusing this:\n  ipurged_relation1 u execs execs2\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  current s = current t'\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some s) (Some t') u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  does_not_communicate_with_gateway u execs\n\ngoal (1 subgoal):\n 1. iequivalent_states (run n (Some s) execs) (run n (Some t') execs2) u", "using rs rt"], ["proof (prove)\nusing this:\n  ipurged_relation1 u execs execs2\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  current s = current t'\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some s) (Some t') u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  does_not_communicate_with_gateway u execs\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. iequivalent_states (run n (Some s) execs) (run n (Some t') execs2) u", "by(auto)"], ["proof (state)\nthis:\n  iequivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from this not_interrupt True thread_empty_s"], ["proof (chain)\npicking this:\n  iequivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  thread_empty (execs2 (current t'))\n  thread_empty (execs (current s))", "show ?thesis"], ["proof (prove)\nusing this:\n  iequivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  thread_empty (execs2 (current t'))\n  thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "using rs rt"], ["proof (prove)\nusing this:\n  iequivalent_states (run n (Some s) execs) (run n (Some t') execs2) u\n  \\<not> interrupt (Suc n)\n  thread_empty (execs2 (current t'))\n  thread_empty (execs (current s))\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "by(auto)"], ["proof (state)\nthis:\n  iequivalent_states (run (Suc n) (Some s) execs)\n   (run (Suc n) (Some t') execs2) u\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "case False"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t'))\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "have prec_t: \"precondition (next_state t' execs2) (next_action t' execs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precondition (next_state t' execs2) (next_action t' execs2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. precondition (next_state t' execs2) (next_action t' execs2)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. precondition (next_state t' execs2) (next_action t' execs2)", "assume not_prec_t: \"\\<not>precondition (next_state t' execs2) (next_action t' execs2)\""], ["proof (state)\nthis:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. precondition (next_state t' execs2) (next_action t' execs2)", "hence \"run (Suc n) (Some t') execs2 = None\""], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. run (Suc n) (Some t') execs2 = None", "using not_interrupt False not_prec_t"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. run (Suc n) (Some t') execs2 = None", "by (simp)"], ["proof (state)\nthis:\n  run (Suc n) (Some t') execs2 = None\n\ngoal (1 subgoal):\n 1. precondition (next_state t' execs2) (next_action t' execs2)", "from this"], ["proof (chain)\npicking this:\n  run (Suc n) (Some t') execs2 = None", "have \"False\""], ["proof (prove)\nusing this:\n  run (Suc n) (Some t') execs2 = None\n\ngoal (1 subgoal):\n 1. False", "using rt"], ["proof (prove)\nusing this:\n  run (Suc n) (Some t') execs2 = None\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. False", "by(simp add:option.splits)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. precondition (next_state t' execs2) (next_action t' execs2)", "}"], ["proof (state)\nthis:\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. precondition (next_state t' execs2) (next_action t' execs2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. precondition (next_state t' execs2) (next_action t' execs2)", "by auto"], ["proof (state)\nthis:\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from False purged_a_a2 thread_empty_s current_s_t"], ["proof (chain)\npicking this:\n  \\<not> thread_empty (execs2 (current t'))\n  ipurged_relation1 u execs execs2\n  thread_empty (execs (current s))\n  current s = current t'", "have 1: \"ind_source (current t') u \\<or> unrelated (current t') u\""], ["proof (prove)\nusing this:\n  \\<not> thread_empty (execs2 (current t'))\n  ipurged_relation1 u execs execs2\n  thread_empty (execs (current s))\n  current s = current t'\n\ngoal (1 subgoal):\n 1. ind_source (current t') u \\<or> unrelated (current t') u", "unfolding ipurged_relation1_def intermediary_def"], ["proof (prove)\nusing this:\n  \\<not> thread_empty (execs2 (current t'))\n  \\<forall>d.\n     (ifp d u \\<longrightarrow> execs d = execs2 d) \\<and>\n     ((\\<exists>v.\n          ifp\\<^sup>*\\<^sup>* v d \\<and>\n          ifp d u \\<and>\n          \\<not> ifp v u \\<and> d \\<noteq> u) \\<longrightarrow>\n      execs d = [])\n  thread_empty (execs (current s))\n  current s = current t'\n\ngoal (1 subgoal):\n 1. ind_source (current t') u \\<or> unrelated (current t') u", "by auto"], ["proof (state)\nthis:\n  ind_source (current t') u \\<or> unrelated (current t') u\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "{"], ["proof (state)\nthis:\n  ind_source (current t') u \\<or> unrelated (current t') u\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "assume ifp_v: \"ifp v u\""], ["proof (state)\nthis:\n  ifp v u\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "assume v_not_intermediary: \"\\<not>intermediary v u\""], ["proof (state)\nthis:\n  \\<not> intermediary v u\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from 1 ifp_v v_not_intermediary"], ["proof (chain)\npicking this:\n  ind_source (current t') u \\<or> unrelated (current t') u\n  ifp v u\n  \\<not> intermediary v u", "have not_ifp_curr_v: \"\\<not>ifp (current t') v\""], ["proof (prove)\nusing this:\n  ind_source (current t') u \\<or> unrelated (current t') u\n  ifp v u\n  \\<not> intermediary v u\n\ngoal (1 subgoal):\n 1. \\<not> ifp (current t') v", "unfolding intermediary_def"], ["proof (prove)\nusing this:\n  ind_source (current t') u \\<or> unrelated (current t') u\n  ifp v u\n  \\<nexists>va.\n     ifp\\<^sup>*\\<^sup>* va v \\<and>\n     ifp v u \\<and> \\<not> ifp va u \\<and> v \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<not> ifp (current t') v", "by auto"], ["proof (state)\nthis:\n  \\<not> ifp (current t') v\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from not_ifp_curr_v prec_t locally_respects[THEN spec,THEN spec,THEN spec,where x1=\"next_state t' execs2\" and x=v and x2=\"the (next_action t' execs2)\"]\n               current_next_state  vpeq_reflexive"], ["proof (chain)\npicking this:\n  \\<not> ifp (current t') v\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> ifp (current (next_state t' execs2)) v \\<and>\n  kprecondition (next_state t' execs2)\n   (the (next_action t' execs2)) \\<longrightarrow>\n  vpeq v (next_state t' execs2)\n   (kstep (next_state t' execs2) (the (next_action t' execs2)))\n  \\<forall>s execs. current (next_state s execs) = current s\n  \\<forall>a u. vpeq u a a", "have \"vpeq v (next_state t' execs2) (step (next_state t' execs2) (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  \\<not> ifp (current t') v\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> ifp (current (next_state t' execs2)) v \\<and>\n  kprecondition (next_state t' execs2)\n   (the (next_action t' execs2)) \\<longrightarrow>\n  vpeq v (next_state t' execs2)\n   (kstep (next_state t' execs2) (the (next_action t' execs2)))\n  \\<forall>s execs. current (next_state s execs) = current s\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. vpeq v (next_state t' execs2)\n     (step (next_state t' execs2) (next_action t' execs2))", "unfolding step_def precondition_def B_def"], ["proof (prove)\nusing this:\n  \\<not> ifp (current t') v\n  case next_action t' execs2 of None \\<Rightarrow> True\n  | Some a \\<Rightarrow> kprecondition (next_state t' execs2) a\n  \\<not> ifp (current (next_state t' execs2)) v \\<and>\n  kprecondition (next_state t' execs2)\n   (the (next_action t' execs2)) \\<longrightarrow>\n  vpeq v (next_state t' execs2)\n   (kstep (next_state t' execs2) (the (next_action t' execs2)))\n  \\<forall>s execs. current (next_state s execs) = current s\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. vpeq v (next_state t' execs2)\n     (case next_action t' execs2 of None \\<Rightarrow> next_state t' execs2\n      | Some a \\<Rightarrow> kstep (next_state t' execs2) a)", "by (cases \"next_action t' execs2\",auto)"], ["proof (state)\nthis:\n  vpeq v (next_state t' execs2)\n   (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from this vpeq_transitive not_ifp_curr_v locally_respects_next_state"], ["proof (chain)\npicking this:\n  vpeq v (next_state t' execs2)\n   (step (next_state t' execs2) (next_action t' execs2))\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n  \\<not> ifp (current t') v\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)", "have vpeq_t_nt: \"vpeq v t' (step (next_state t' execs2) (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  vpeq v (next_state t' execs2)\n   (step (next_state t' execs2) (next_action t' execs2))\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n  \\<not> ifp (current t') v\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n\ngoal (1 subgoal):\n 1. vpeq v t' (step (next_state t' execs2) (next_action t' execs2))", "by blast"], ["proof (state)\nthis:\n  vpeq v t' (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from vpeq_s_t ifp_v v_not_intermediary vpeq_t_nt vpeq_transitive vpeq_symmetric vpeq_reflexive"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  ifp v u\n  \\<not> intermediary v u\n  vpeq v t' (step (next_state t' execs2) (next_action t' execs2))\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n  \\<forall>a b u. vpeq u a b \\<longrightarrow> vpeq u b a\n  \\<forall>a u. vpeq u a a", "have \"vpeq v s (step (next_state t' execs2) (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  ifp v u\n  \\<not> intermediary v u\n  vpeq v t' (step (next_state t' execs2) (next_action t' execs2))\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n  \\<forall>a b u. vpeq u a b \\<longrightarrow> vpeq u b a\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. vpeq v s (step (next_state t' execs2) (next_action t' execs2))", "by (metis)"], ["proof (state)\nthis:\n  vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "}"], ["proof (state)\nthis:\n  \\<lbrakk>ifp ?v2 u; \\<not> intermediary ?v2 u\\<rbrakk>\n  \\<Longrightarrow> vpeq ?v2 s\n                     (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "hence vpeq_ns_nt: \"\\<forall> v . ifp v u \\<and> \\<not>intermediary v u \\<longrightarrow> vpeq v s (step (next_state t' execs2) (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ifp ?v2 u; \\<not> intermediary ?v2 u\\<rbrakk>\n  \\<Longrightarrow> vpeq ?v2 s\n                     (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n       vpeq v s (step (next_state t' execs2) (next_action t' execs2))", "by auto"], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from False purged_a_a2 current_s_t thread_empty_s"], ["proof (chain)\npicking this:\n  \\<not> thread_empty (execs2 (current t'))\n  ipurged_relation1 u execs execs2\n  current s = current t'\n  thread_empty (execs (current s))", "have purged_a_na2: \"ipurged_relation1 u execs (next_execs t' execs2)\""], ["proof (prove)\nusing this:\n  \\<not> thread_empty (execs2 (current t'))\n  ipurged_relation1 u execs execs2\n  current s = current t'\n  thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. ipurged_relation1 u execs (next_execs t' execs2)", "unfolding ipurged_relation1_def next_execs_def"], ["proof (prove)\nusing this:\n  \\<not> thread_empty (execs2 (current t'))\n  \\<forall>d.\n     (ifp d u \\<longrightarrow> execs d = execs2 d) \\<and>\n     (intermediary d u \\<longrightarrow> execs d = [])\n  current s = current t'\n  thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. \\<forall>d.\n       (ifp d u \\<longrightarrow>\n        execs d =\n        (execs2\n         (current t' :=\n            fst (snd (control t' (current t') (execs2 (current t'))))))\n         d) \\<and>\n       (intermediary d u \\<longrightarrow> execs d = [])", "by(auto)"], ["proof (state)\nthis:\n  ipurged_relation1 u execs (next_execs t' execs2)\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from vpeq_ns_nt no_gateway_comm\n          and IH[where t=\"Some (step (next_state t' execs2) (next_action t' execs2))\" and ?execs2.0=\"(next_execs t' execs2)\" and u=u]\n          and current_s_nt purged_a_na2"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  does_not_communicate_with_gateway u execs\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some s)\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  ipurged_relation1 u execs (next_execs t' execs2) \\<longrightarrow>\n  iequivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  current s = current (step (next_state t' execs2) (next_action t' execs2))\n  ipurged_relation1 u execs (next_execs t' execs2)", "have eq_ns_nt: \"iequivalent_states (run n (Some s) execs)\n                                             (run n (Some (step (next_state t' execs2) (next_action t' execs2))) (next_execs t' execs2)) u\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v s (step (next_state t' execs2) (next_action t' execs2))\n  does_not_communicate_with_gateway u execs\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some s)\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  ipurged_relation1 u execs (next_execs t' execs2) \\<longrightarrow>\n  iequivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  current s = current (step (next_state t' execs2) (next_action t' execs2))\n  ipurged_relation1 u execs (next_execs t' execs2)\n\ngoal (1 subgoal):\n 1. iequivalent_states (run n (Some s) execs)\n     (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n       (next_execs t' execs2))\n     u", "by auto"], ["proof (state)\nthis:\n  iequivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from prec_t  eq_ns_nt not_interrupt False thread_empty_s"], ["proof (chain)\npicking this:\n  precondition (next_state t' execs2) (next_action t' execs2)\n  iequivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs2 (current t'))\n  thread_empty (execs (current s))", "show ?thesis"], ["proof (prove)\nusing this:\n  precondition (next_state t' execs2) (next_action t' execs2)\n  iequivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs2 (current t'))\n  thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "using t rs rt"], ["proof (prove)\nusing this:\n  precondition (next_state t' execs2) (next_action t' execs2)\n  iequivalent_states (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs2 (current t'))\n  thread_empty (execs (current s))\n  t = Some t'\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "by(auto)"], ["proof (state)\nthis:\n  iequivalent_states (run (Suc n) (Some s) execs)\n   (run (Suc n) (Some t') execs2) u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  iequivalent_states (run (Suc n) (Some s) execs)\n   (run (Suc n) (Some t') execs2) u\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "}"], ["proof (state)\nthis:\n  \\<lbrakk>t = Some ?t'2; run (Suc n) (Some s) execs = Some ?rs2;\n   run (Suc n) (Some ?t'2) execs2 = Some ?rt2;\n   does_not_communicate_with_gateway u execs;\n   \\<forall>v.\n      ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n      vpeq v s ?t'2;\n   current s = current ?t'2; ipurged_relation1 u execs execs2\\<rbrakk>\n  \\<Longrightarrow> iequivalent_states (run (Suc n) (Some s) execs)\n                     (run (Suc n) (Some ?t'2) execs2) u\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u execs \\<and>\n           iequivalent_states (Some s) t u \\<and>\n           ipurged_relation1 u execs execs2 \\<longrightarrow>\n           iequivalent_states (run n (Some s) execs) (run n t execs2)\n            u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 3. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Some ?t'2; run (Suc n) (Some s) execs = Some ?rs2;\n   run (Suc n) (Some ?t'2) execs2 = Some ?rt2;\n   does_not_communicate_with_gateway u execs;\n   \\<forall>v.\n      ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n      vpeq v s ?t'2;\n   current s = current ?t'2; ipurged_relation1 u execs execs2\\<rbrakk>\n  \\<Longrightarrow> iequivalent_states (run (Suc n) (Some s) execs)\n                     (run (Suc n) (Some ?t'2) execs2) u\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u execs \\<and>\n    iequivalent_states (Some s) t u \\<and>\n    ipurged_relation1 u execs execs2 \\<longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u", "by(simp add:option.splits,cases t,simp+)"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some s) t u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "case (5 n execs s t u execs2)"], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  \\<not> precondition (next_state s execs) (next_action s execs)\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume not_interrupt: \"\\<not>interrupt (Suc n)\""], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume thread_not_empty_s: \"\\<not>thread_empty(execs (current s))\""], ["proof (state)\nthis:\n  \\<not> thread_empty (execs (current s))\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume not_prec_s: \"\\<not> precondition (next_state s execs) (next_action s execs)\""], ["proof (state)\nthis:\n  \\<not> precondition (next_state s execs) (next_action s execs)\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "hence \"run (Suc n) (Some s) execs = None\""], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state s execs) (next_action s execs)\n\ngoal (1 subgoal):\n 1. run (Suc n) (Some s) execs = None", "using not_interrupt thread_not_empty_s"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state s execs) (next_action s execs)\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. run (Suc n) (Some s) execs = None", "by simp"], ["proof (state)\nthis:\n  run (Suc n) (Some s) execs = None\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u\n 2. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "thus ?case"], ["proof (prove)\nusing this:\n  run (Suc n) (Some s) execs = None\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u execs \\<and>\n    iequivalent_states (Some s) t u \\<and>\n    ipurged_relation1 u execs execs2 \\<longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u", "by(simp add:option.splits)"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some s) t u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "case (6 n execs s t u execs2)"], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  does_not_communicate_with_gateway ?u (next_execs s execs) \\<and>\n  iequivalent_states\n   (Some (step (next_state s execs) (next_action s execs))) ?t ?u \\<and>\n  ipurged_relation1 ?u (next_execs s execs) ?execs2.0 \\<longrightarrow>\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n ?t ?execs2.0) ?u\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume not_interrupt: \"\\<not>interrupt (Suc n)\""], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume thread_not_empty_s: \"\\<not>thread_empty(execs (current s))\""], ["proof (state)\nthis:\n  \\<not> thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume prec_s: \"precondition (next_state s execs) (next_action s execs)\""], ["proof (state)\nthis:\n  precondition (next_state s execs) (next_action s execs)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume IH: \"(\\<And>t u execs2. does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states (Some (step (next_state s execs) (next_action s execs))) t u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs))) (next_execs s execs))\n            (run n t execs2) u)\""], ["proof (state)\nthis:\n  does_not_communicate_with_gateway ?u (next_execs s execs) \\<and>\n  iequivalent_states\n   (Some (step (next_state s execs) (next_action s execs))) ?t ?u \\<and>\n  ipurged_relation1 ?u (next_execs s execs) ?execs2.0 \\<longrightarrow>\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n ?t ?execs2.0) ?u\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "{"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway ?u (next_execs s execs) \\<and>\n  iequivalent_states\n   (Some (step (next_state s execs) (next_action s execs))) ?t ?u \\<and>\n  ipurged_relation1 ?u (next_execs s execs) ?execs2.0 \\<longrightarrow>\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n ?t ?execs2.0) ?u\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume t: \"t = Some t'\""], ["proof (state)\nthis:\n  t = Some t'\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix rs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume rs: \"run (Suc n) (Some s) execs = Some rs\""], ["proof (state)\nthis:\n  run (Suc n) (Some s) execs = Some rs\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "fix rt"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume rt: \"run (Suc n) (Some t') execs2 = Some rt\""], ["proof (state)\nthis:\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume no_gateway_comm: \"does_not_communicate_with_gateway u execs\""], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u execs\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume vpeq_s_t: \"\\<forall> v . ifp v u \\<and> \\<not>intermediary v u \\<longrightarrow> vpeq v s t'\""], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume current_s_t: \"current s = current t'\""], ["proof (state)\nthis:\n  current s = current t'\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "assume purged_a_a2: \"ipurged_relation1 u execs execs2\""], ["proof (state)\nthis:\n  ipurged_relation1 u execs execs2\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from ifp_reflexive vpeq_s_t"], ["proof (chain)\npicking this:\n  \\<forall>u. ifp u u\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'", "have vpeq_u_s_t: \"vpeq u s t'\""], ["proof (prove)\nusing this:\n  \\<forall>u. ifp u u\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq u s t'", "unfolding intermediary_def"], ["proof (prove)\nusing this:\n  \\<forall>u. ifp u u\n  \\<forall>v.\n     ifp v u \\<and>\n     (\\<nexists>va.\n         ifp\\<^sup>*\\<^sup>* va v \\<and>\n         ifp v u \\<and>\n         \\<not> ifp va u \\<and> v \\<noteq> u) \\<longrightarrow>\n     vpeq v s t'\n\ngoal (1 subgoal):\n 1. vpeq u s t'", "by auto"], ["proof (state)\nthis:\n  vpeq u s t'\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from step_atomicity and current_s_t current_next_state"], ["proof (chain)\npicking this:\n  \\<forall>s a. current (kstep s a) = current s\n  current s = current t'\n  \\<forall>s execs. current (next_state s execs) = current s", "have current_ns_nt: \"current (step (next_state s execs) (next_action s execs)) = current (step (next_state t' execs2) (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  current s = current t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. current (step (next_state s execs) (next_action s execs)) =\n    current (step (next_state t' execs2) (next_action t' execs2))", "unfolding step_def"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  current s = current t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. current\n     (case next_action s execs of None \\<Rightarrow> next_state s execs\n      | Some a \\<Rightarrow> kstep (next_state s execs) a) =\n    current\n     (case next_action t' execs2 of None \\<Rightarrow> next_state t' execs2\n      | Some a \\<Rightarrow> kstep (next_state t' execs2) a)", "by (cases \"next_action s execs\",cases \"next_action t' execs2\",simp,simp,cases \"next_action t' execs2\",simp,simp)"], ["proof (state)\nthis:\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from step_atomicity current_next_state current_s_t"], ["proof (chain)\npicking this:\n  \\<forall>s a. current (kstep s a) = current s\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'", "have current_ns_t: \"current (step (next_state s execs) (next_action s execs)) = current t'\""], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'\n\ngoal (1 subgoal):\n 1. current (step (next_state s execs) (next_action s execs)) = current t'", "unfolding step_def"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'\n\ngoal (1 subgoal):\n 1. current\n     (case next_action s execs of None \\<Rightarrow> next_state s execs\n      | Some a \\<Rightarrow> kstep (next_state s execs) a) =\n    current t'", "by (cases \"next_action s execs\",auto)"], ["proof (state)\nthis:\n  current (step (next_state s execs) (next_action s execs)) = current t'\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from vpeq_s_t"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'", "have vpeq_curr_s_t: \"ifp (current s) u \\<and> \\<not>intermediary (current s) u \\<longrightarrow> vpeq (current s) s t'\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n\ngoal (1 subgoal):\n 1. ifp (current s) u \\<and>\n    \\<not> intermediary (current s) u \\<longrightarrow>\n    vpeq (current s) s t'", "unfolding intermediary_def"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     ifp v u \\<and>\n     (\\<nexists>va.\n         ifp\\<^sup>*\\<^sup>* va v \\<and>\n         ifp v u \\<and>\n         \\<not> ifp va u \\<and> v \\<noteq> u) \\<longrightarrow>\n     vpeq v s t'\n\ngoal (1 subgoal):\n 1. ifp (current s) u \\<and>\n    (\\<nexists>v.\n        ifp\\<^sup>*\\<^sup>* v (current s) \\<and>\n        ifp (current s) u \\<and>\n        \\<not> ifp v u \\<and> current s \\<noteq> u) \\<longrightarrow>\n    vpeq (current s) s t'", "by auto"], ["proof (state)\nthis:\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  vpeq (current s) s t'\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from current_s_t purged_a_a2"], ["proof (chain)\npicking this:\n  current s = current t'\n  ipurged_relation1 u execs execs2", "have eq_execs: \"ifp (current s) u \\<and> \\<not>intermediary (current s) u \\<longrightarrow> execs (current s) = execs2 (current s)\""], ["proof (prove)\nusing this:\n  current s = current t'\n  ipurged_relation1 u execs execs2\n\ngoal (1 subgoal):\n 1. ifp (current s) u \\<and>\n    \\<not> intermediary (current s) u \\<longrightarrow>\n    execs (current s) = execs2 (current s)", "by(auto simp add: ipurged_relation1_def)"], ["proof (state)\nthis:\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  execs (current s) = execs2 (current s)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from vpeq_involved_domains no_gateway_comm vpeq_s_t vpeq_involved_domains prec_s"], ["proof (chain)\npicking this:\n  \\<lbrakk>ifp (current ?s) ?u; \\<not> intermediary (current ?s) ?u;\n   does_not_communicate_with_gateway ?u ?execs;\n   \\<forall>v.\n      ifp v ?u \\<and> \\<not> intermediary v ?u \\<longrightarrow>\n      vpeq v ?s ?t';\n   precondition (next_state ?s ?execs) (next_action ?s ?execs)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>d\\<in>involved (next_action ?s ?execs).\n                       vpeq d ?s ?t'\n  does_not_communicate_with_gateway u execs\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  \\<lbrakk>ifp (current ?s) ?u; \\<not> intermediary (current ?s) ?u;\n   does_not_communicate_with_gateway ?u ?execs;\n   \\<forall>v.\n      ifp v ?u \\<and> \\<not> intermediary v ?u \\<longrightarrow>\n      vpeq v ?s ?t';\n   precondition (next_state ?s ?execs) (next_action ?s ?execs)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>d\\<in>involved (next_action ?s ?execs).\n                       vpeq d ?s ?t'\n  precondition (next_state s execs) (next_action s execs)", "have vpeq_involved: \"ifp (current s) u \\<and> \\<not>intermediary (current s) u \\<longrightarrow> (\\<forall> d \\<in> involved (next_action s execs) . vpeq d s t')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ifp (current ?s) ?u; \\<not> intermediary (current ?s) ?u;\n   does_not_communicate_with_gateway ?u ?execs;\n   \\<forall>v.\n      ifp v ?u \\<and> \\<not> intermediary v ?u \\<longrightarrow>\n      vpeq v ?s ?t';\n   precondition (next_state ?s ?execs) (next_action ?s ?execs)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>d\\<in>involved (next_action ?s ?execs).\n                       vpeq d ?s ?t'\n  does_not_communicate_with_gateway u execs\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  \\<lbrakk>ifp (current ?s) ?u; \\<not> intermediary (current ?s) ?u;\n   does_not_communicate_with_gateway ?u ?execs;\n   \\<forall>v.\n      ifp v ?u \\<and> \\<not> intermediary v ?u \\<longrightarrow>\n      vpeq v ?s ?t';\n   precondition (next_state ?s ?execs) (next_action ?s ?execs)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>d\\<in>involved (next_action ?s ?execs).\n                       vpeq d ?s ?t'\n  precondition (next_state s execs) (next_action s execs)\n\ngoal (1 subgoal):\n 1. ifp (current s) u \\<and>\n    \\<not> intermediary (current s) u \\<longrightarrow>\n    (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')", "by blast"], ["proof (state)\nthis:\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from current_s_t next_execs_consistent[THEN spec,THEN spec,THEN spec,where x2=s and x1=t' and x=execs] vpeq_curr_s_t vpeq_involved"], ["proof (chain)\npicking this:\n  current s = current t'\n  vpeq (current s) s t' \\<and>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t') \\<and>\n  current s = current t' \\<longrightarrow>\n  fst (snd (control s (current s) (execs (current s)))) =\n  fst (snd (control t' (current s) (execs (current s))))\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  vpeq (current s) s t'\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')", "have next_execs_t: \"ifp (current s) u \\<and> \\<not>intermediary (current s) u \\<longrightarrow> next_execs t' execs = next_execs s execs\""], ["proof (prove)\nusing this:\n  current s = current t'\n  vpeq (current s) s t' \\<and>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t') \\<and>\n  current s = current t' \\<longrightarrow>\n  fst (snd (control s (current s) (execs (current s)))) =\n  fst (snd (control t' (current s) (execs (current s))))\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  vpeq (current s) s t'\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')\n\ngoal (1 subgoal):\n 1. ifp (current s) u \\<and>\n    \\<not> intermediary (current s) u \\<longrightarrow>\n    next_execs t' execs = next_execs s execs", "by(auto simp add: next_execs_def)"], ["proof (state)\nthis:\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  next_execs t' execs = next_execs s execs\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from current_s_t and purged_a_a2 and thread_not_empty_s next_action_consistent[THEN spec,THEN spec,where x1=s and x=t'] vpeq_curr_s_t vpeq_involved"], ["proof (chain)\npicking this:\n  current s = current t'\n  ipurged_relation1 u execs execs2\n  \\<not> thread_empty (execs (current s))\n  \\<forall>execs.\n     vpeq (current s) s t' \\<and>\n     (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t') \\<and>\n     current s = current t' \\<longrightarrow>\n     next_action s execs = next_action t' execs\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  vpeq (current s) s t'\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')", "have next_action_s_t: \"ifp (current s) u \\<and> \\<not>intermediary (current s) u \\<longrightarrow> next_action t' execs2 = next_action s execs\""], ["proof (prove)\nusing this:\n  current s = current t'\n  ipurged_relation1 u execs execs2\n  \\<not> thread_empty (execs (current s))\n  \\<forall>execs.\n     vpeq (current s) s t' \\<and>\n     (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t') \\<and>\n     current s = current t' \\<longrightarrow>\n     next_action s execs = next_action t' execs\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  vpeq (current s) s t'\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')\n\ngoal (1 subgoal):\n 1. ifp (current s) u \\<and>\n    \\<not> intermediary (current s) u \\<longrightarrow>\n    next_action t' execs2 = next_action s execs", "by(unfold next_action_def,unfold ipurged_relation1_def,auto)"], ["proof (state)\nthis:\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "from purged_a_a2 and thread_not_empty_s and current_s_t"], ["proof (chain)\npicking this:\n  ipurged_relation1 u execs execs2\n  \\<not> thread_empty (execs (current s))\n  current s = current t'", "have thread_not_empty_t: \"ifp (current s) u \\<and> \\<not>intermediary (current s) u \\<longrightarrow> \\<not>thread_empty(execs2 (current t'))\""], ["proof (prove)\nusing this:\n  ipurged_relation1 u execs execs2\n  \\<not> thread_empty (execs (current s))\n  current s = current t'\n\ngoal (1 subgoal):\n 1. ifp (current s) u \\<and>\n    \\<not> intermediary (current s) u \\<longrightarrow>\n    \\<not> thread_empty (execs2 (current t'))", "unfolding ipurged_relation1_def"], ["proof (prove)\nusing this:\n  \\<forall>d.\n     (ifp d u \\<longrightarrow> execs d = execs2 d) \\<and>\n     (intermediary d u \\<longrightarrow> execs d = [])\n  \\<not> thread_empty (execs (current s))\n  current s = current t'\n\ngoal (1 subgoal):\n 1. ifp (current s) u \\<and>\n    \\<not> intermediary (current s) u \\<longrightarrow>\n    \\<not> thread_empty (execs2 (current t'))", "by auto"], ["proof (state)\nthis:\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  \\<not> thread_empty (execs2 (current t'))\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "have vpeq_ns_nt_1: \"\\<And> a . precondition (next_state s execs) a \\<and> precondition (next_state t' execs) a \\<Longrightarrow> ifp (current s) u \\<and> \\<not>intermediary (current s) u \\<Longrightarrow>  (\\<forall> v . ifp v u \\<and> \\<not>intermediary v u \\<longrightarrow> vpeq v (step (next_state s execs) a) (step (next_state t' execs) a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>precondition (next_state s execs) a \\<and>\n                precondition (next_state t' execs) a;\n        ifp (current s) u \\<and> \\<not> intermediary (current s) u\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            ifp v u \\<and>\n                            \\<not> intermediary v u \\<longrightarrow>\n                            vpeq v (step (next_state s execs) a)\n                             (step (next_state t' execs) a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>precondition (next_state s execs) a \\<and>\n                precondition (next_state t' execs) a;\n        ifp (current s) u \\<and> \\<not> intermediary (current s) u\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            ifp v u \\<and>\n                            \\<not> intermediary v u \\<longrightarrow>\n                            vpeq v (step (next_state s execs) a)\n                             (step (next_state t' execs) a)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>precondition (next_state s execs) a \\<and>\n                precondition (next_state t' execs) a;\n        ifp (current s) u \\<and> \\<not> intermediary (current s) u\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            ifp v u \\<and>\n                            \\<not> intermediary v u \\<longrightarrow>\n                            vpeq v (step (next_state s execs) a)\n                             (step (next_state t' execs) a)", "assume precs: \"precondition (next_state s execs) a \\<and> precondition (next_state t' execs) a\""], ["proof (state)\nthis:\n  precondition (next_state s execs) a \\<and>\n  precondition (next_state t' execs) a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>precondition (next_state s execs) a \\<and>\n                precondition (next_state t' execs) a;\n        ifp (current s) u \\<and> \\<not> intermediary (current s) u\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            ifp v u \\<and>\n                            \\<not> intermediary v u \\<longrightarrow>\n                            vpeq v (step (next_state s execs) a)\n                             (step (next_state t' execs) a)", "assume ifp_curr: \"ifp (current s) u \\<and> \\<not>intermediary (current s) u\""], ["proof (state)\nthis:\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>precondition (next_state s execs) a \\<and>\n                precondition (next_state t' execs) a;\n        ifp (current s) u \\<and> \\<not> intermediary (current s) u\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            ifp v u \\<and>\n                            \\<not> intermediary v u \\<longrightarrow>\n                            vpeq v (step (next_state s execs) a)\n                             (step (next_state t' execs) a)", "from ifp_curr precs\n          next_state_consistent[THEN spec,THEN spec,where x1=s and x=t'] vpeq_curr_s_t vpeq_s_t\n          current_next_state current_s_t weakly_step_consistent[THEN spec,THEN spec,THEN spec,THEN spec,where x3=\"next_state s execs\" and x2=\"next_state t' execs\" and x=\"the a\"]"], ["proof (chain)\npicking this:\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n  precondition (next_state s execs) a \\<and>\n  precondition (next_state t' execs) a\n  \\<forall>u execs.\n     vpeq (current s) s t' \\<and>\n     vpeq u s t' \\<and> current s = current t' \\<longrightarrow>\n     vpeq u (next_state s execs) (next_state t' execs)\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  vpeq (current s) s t'\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'\n  vpeq ?x1 (next_state s execs) (next_state t' execs) \\<and>\n  vpeq (current (next_state s execs)) (next_state s execs)\n   (next_state t' execs) \\<and>\n  kprecondition (next_state s execs) (the a) \\<and>\n  kprecondition (next_state t' execs) (the a) \\<and>\n  current (next_state s execs) =\n  current (next_state t' execs) \\<longrightarrow>\n  vpeq ?x1 (kstep (next_state s execs) (the a))\n   (kstep (next_state t' execs) (the a))", "show \"\\<forall> v . ifp v u \\<and> \\<not>intermediary v u \\<longrightarrow> vpeq v (step (next_state s execs) a) (step (next_state t' execs) a)\""], ["proof (prove)\nusing this:\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n  precondition (next_state s execs) a \\<and>\n  precondition (next_state t' execs) a\n  \\<forall>u execs.\n     vpeq (current s) s t' \\<and>\n     vpeq u s t' \\<and> current s = current t' \\<longrightarrow>\n     vpeq u (next_state s execs) (next_state t' execs)\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  vpeq (current s) s t'\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'\n  vpeq ?x1 (next_state s execs) (next_state t' execs) \\<and>\n  vpeq (current (next_state s execs)) (next_state s execs)\n   (next_state t' execs) \\<and>\n  kprecondition (next_state s execs) (the a) \\<and>\n  kprecondition (next_state t' execs) (the a) \\<and>\n  current (next_state s execs) =\n  current (next_state t' execs) \\<longrightarrow>\n  vpeq ?x1 (kstep (next_state s execs) (the a))\n   (kstep (next_state t' execs) (the a))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) a) (step (next_state t' execs) a)", "unfolding step_def precondition_def B_def"], ["proof (prove)\nusing this:\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n  (case a of None \\<Rightarrow> True\n   | Some a \\<Rightarrow> kprecondition (next_state s execs) a) \\<and>\n  (case a of None \\<Rightarrow> True\n   | Some a \\<Rightarrow> kprecondition (next_state t' execs) a)\n  \\<forall>u execs.\n     vpeq (current s) s t' \\<and>\n     vpeq u s t' \\<and> current s = current t' \\<longrightarrow>\n     vpeq u (next_state s execs) (next_state t' execs)\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  vpeq (current s) s t'\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  \\<forall>s execs. current (next_state s execs) = current s\n  current s = current t'\n  vpeq ?x1 (next_state s execs) (next_state t' execs) \\<and>\n  vpeq (current (next_state s execs)) (next_state s execs)\n   (next_state t' execs) \\<and>\n  kprecondition (next_state s execs) (the a) \\<and>\n  kprecondition (next_state t' execs) (the a) \\<and>\n  current (next_state s execs) =\n  current (next_state t' execs) \\<longrightarrow>\n  vpeq ?x1 (kstep (next_state s execs) (the a))\n   (kstep (next_state t' execs) (the a))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n       vpeq v\n        (case a of None \\<Rightarrow> next_state s execs\n         | Some a \\<Rightarrow> kstep (next_state s execs) a)\n        (case a of None \\<Rightarrow> next_state t' execs\n         | Some a \\<Rightarrow> kstep (next_state t' execs) a)", "by (cases a,auto)"], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) a) (step (next_state t' execs) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>precondition (next_state s execs) ?a \\<and>\n           precondition (next_state t' execs) ?a;\n   ifp (current s) u \\<and> \\<not> intermediary (current s) u\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp v u \\<and>\n                       \\<not> intermediary v u \\<longrightarrow>\n                       vpeq v (step (next_state s execs) ?a)\n                        (step (next_state t' execs) ?a)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "have no_gateway_comm_na: \"does_not_communicate_with_gateway u (next_execs s execs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (next_execs s execs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (next_execs s execs)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (next_execs s execs)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (next_execs s execs)", "assume \"a \\<in> actions_in_execution (next_execs s execs u)\""], ["proof (state)\nthis:\n  a \\<in> actions_in_execution (next_execs s execs u)\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (next_execs s execs)", "from this no_gateway_comm[unfolded does_not_communicate_with_gateway_def,THEN spec,where x=a]\n               next_execs_subset[THEN spec,THEN spec,THEN spec,where x2=s and x1=execs and x0=u]"], ["proof (chain)\npicking this:\n  a \\<in> actions_in_execution (next_execs s execs u)\n  a \\<in> actions_in_execution (execs u) \\<longrightarrow>\n  (\\<forall>v.\n      intermediary v u \\<longrightarrow> v \\<notin> involved (Some a))\n  actions_in_execution (next_execs s execs u)\n  \\<subseteq> actions_in_execution (execs u)", "have \"\\<forall>v. intermediary v u \\<longrightarrow> v \\<notin> involved (Some a)\""], ["proof (prove)\nusing this:\n  a \\<in> actions_in_execution (next_execs s execs u)\n  a \\<in> actions_in_execution (execs u) \\<longrightarrow>\n  (\\<forall>v.\n      intermediary v u \\<longrightarrow> v \\<notin> involved (Some a))\n  actions_in_execution (next_execs s execs u)\n  \\<subseteq> actions_in_execution (execs u)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       intermediary v u \\<longrightarrow> v \\<notin> involved (Some a)", "unfolding  actions_in_execution_def"], ["proof (prove)\nusing this:\n  a \\<in> {a. \\<exists>aseq\\<in>set (next_execs s execs u).\n                 a \\<in> set aseq}\n  a \\<in> {a. \\<exists>aseq\\<in>set (execs u).\n                 a \\<in> set aseq} \\<longrightarrow>\n  (\\<forall>v.\n      intermediary v u \\<longrightarrow> v \\<notin> involved (Some a))\n  {a. \\<exists>aseq\\<in>set (next_execs s execs u). a \\<in> set aseq}\n  \\<subseteq> {a. \\<exists>aseq\\<in>set (execs u). a \\<in> set aseq}\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       intermediary v u \\<longrightarrow> v \\<notin> involved (Some a)", "by(auto)"], ["proof (state)\nthis:\n  \\<forall>v.\n     intermediary v u \\<longrightarrow> v \\<notin> involved (Some a)\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (next_execs s execs)", "}"], ["proof (state)\nthis:\n  ?a2 \\<in> actions_in_execution (next_execs s execs u) \\<Longrightarrow>\n  \\<forall>v.\n     intermediary v u \\<longrightarrow> v \\<notin> involved (Some ?a2)\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (next_execs s execs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?a2 \\<in> actions_in_execution (next_execs s execs u) \\<Longrightarrow>\n  \\<forall>v.\n     intermediary v u \\<longrightarrow> v \\<notin> involved (Some ?a2)\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (next_execs s execs)", "unfolding does_not_communicate_with_gateway_def"], ["proof (prove)\nusing this:\n  ?a2 \\<in> actions_in_execution (next_execs s execs u) \\<Longrightarrow>\n  \\<forall>v.\n     intermediary v u \\<longrightarrow> v \\<notin> involved (Some ?a2)\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       a \\<in> actions_in_execution (next_execs s execs u) \\<longrightarrow>\n       (\\<forall>v.\n           intermediary v u \\<longrightarrow> v \\<notin> involved (Some a))", "by auto"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u (next_execs s execs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u (next_execs s execs)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "have \"iequivalent_states (run (Suc n) (Some s) execs) (run (Suc n) (Some t') execs2) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "proof (cases \"ifp (current s) u \\<and> \\<not>intermediary (current s) u\" rule :case_split[case_names T F])"], ["proof (state)\ngoal (2 subgoals):\n 1. ifp (current s) u \\<and>\n    \\<not> intermediary (current s) u \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> (ifp (current s) u \\<and>\n            \\<not> intermediary (current s) u) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "case T"], ["proof (state)\nthis:\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n\ngoal (2 subgoals):\n 1. ifp (current s) u \\<and>\n    \\<not> intermediary (current s) u \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> (ifp (current s) u \\<and>\n            \\<not> intermediary (current s) u) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "proof (cases \"thread_empty(execs2 (current t'))\" rule :case_split[case_names T2 F2])"], ["proof (state)\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "case F2"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t'))\n\ngoal (2 subgoals):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "proof (cases \"precondition (next_state t' execs2) (next_action t' execs2)\" rule :case_split[case_names T3 F3])"], ["proof (state)\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "case T3"], ["proof (state)\nthis:\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from T purged_a_a2 current_s_t\n              next_execs_consistent[THEN spec,THEN spec,where x1=s and x=t'] vpeq_curr_s_t vpeq_involved"], ["proof (chain)\npicking this:\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n  ipurged_relation1 u execs execs2\n  current s = current t'\n  \\<forall>execs.\n     vpeq (current s) s t' \\<and>\n     (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t') \\<and>\n     current s = current t' \\<longrightarrow>\n     fst (snd (control s (current s) (execs (current s)))) =\n     fst (snd (control t' (current s) (execs (current s))))\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  vpeq (current s) s t'\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')", "have purged_na_na2: \"ipurged_relation1 u (next_execs s execs) (next_execs t' execs2)\""], ["proof (prove)\nusing this:\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n  ipurged_relation1 u execs execs2\n  current s = current t'\n  \\<forall>execs.\n     vpeq (current s) s t' \\<and>\n     (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t') \\<and>\n     current s = current t' \\<longrightarrow>\n     fst (snd (control s (current s) (execs (current s)))) =\n     fst (snd (control t' (current s) (execs (current s))))\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  vpeq (current s) s t'\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')\n\ngoal (1 subgoal):\n 1. ipurged_relation1 u (next_execs s execs) (next_execs t' execs2)", "unfolding ipurged_relation1_def next_execs_def"], ["proof (prove)\nusing this:\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n  \\<forall>d.\n     (ifp d u \\<longrightarrow> execs d = execs2 d) \\<and>\n     (intermediary d u \\<longrightarrow> execs d = [])\n  current s = current t'\n  \\<forall>execs.\n     vpeq (current s) s t' \\<and>\n     (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t') \\<and>\n     current s = current t' \\<longrightarrow>\n     fst (snd (control s (current s) (execs (current s)))) =\n     fst (snd (control t' (current s) (execs (current s))))\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  vpeq (current s) s t'\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  (\\<forall>d\\<in>involved (next_action s execs). vpeq d s t')\n\ngoal (1 subgoal):\n 1. \\<forall>d.\n       (ifp d u \\<longrightarrow>\n        (execs\n         (current s :=\n            fst (snd (control s (current s) (execs (current s))))))\n         d =\n        (execs2\n         (current t' :=\n            fst (snd (control t' (current t') (execs2 (current t'))))))\n         d) \\<and>\n       (intermediary d u \\<longrightarrow>\n        (execs\n         (current s :=\n            fst (snd (control s (current s) (execs (current s))))))\n         d =\n        [])", "by auto"], ["proof (state)\nthis:\n  ipurged_relation1 u (next_execs s execs) (next_execs t' execs2)\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from IH[where t=\"Some (step (next_state t' execs2) (next_action t' execs2))\" and ?execs2.0=\"next_execs t' execs2\" and u=u]\n              purged_na_na2 current_ns_nt vpeq_ns_nt_1[where a=\"(next_action s execs)\"] T T3 prec_s\n              next_action_s_t  eq_execs current_s_t no_gateway_comm_na"], ["proof (chain)\npicking this:\n  does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n  iequivalent_states\n   (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  ipurged_relation1 u (next_execs s execs)\n   (next_execs t' execs2) \\<longrightarrow>\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  ipurged_relation1 u (next_execs s execs) (next_execs t' execs2)\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  \\<lbrakk>precondition (next_state s execs) (next_action s execs) \\<and>\n           precondition (next_state t' execs) (next_action s execs);\n   ifp (current s) u \\<and> \\<not> intermediary (current s) u\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp v u \\<and>\n                       \\<not> intermediary v u \\<longrightarrow>\n                       vpeq v\n                        (step (next_state s execs) (next_action s execs))\n                        (step (next_state t' execs) (next_action s execs))\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  precondition (next_state s execs) (next_action s execs)\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  execs (current s) = execs2 (current s)\n  current s = current t'\n  does_not_communicate_with_gateway u (next_execs s execs)", "have eq_ns_nt: \"iequivalent_states (run n (Some (step (next_state s execs) (next_action s execs))) (next_execs s execs))\n                                                 (run n (Some (step (next_state t' execs2) (next_action t' execs2))) (next_execs t' execs2)) u\""], ["proof (prove)\nusing this:\n  does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n  iequivalent_states\n   (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2))) u \\<and>\n  ipurged_relation1 u (next_execs s execs)\n   (next_execs t' execs2) \\<longrightarrow>\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  ipurged_relation1 u (next_execs s execs) (next_execs t' execs2)\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  \\<lbrakk>precondition (next_state s execs) (next_action s execs) \\<and>\n           precondition (next_state t' execs) (next_action s execs);\n   ifp (current s) u \\<and> \\<not> intermediary (current s) u\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp v u \\<and>\n                       \\<not> intermediary v u \\<longrightarrow>\n                       vpeq v\n                        (step (next_state s execs) (next_action s execs))\n                        (step (next_state t' execs) (next_action s execs))\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n  precondition (next_state t' execs2) (next_action t' execs2)\n  precondition (next_state s execs) (next_action s execs)\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  execs (current s) = execs2 (current s)\n  current s = current t'\n  does_not_communicate_with_gateway u (next_execs s execs)\n\ngoal (1 subgoal):\n 1. iequivalent_states\n     (run n (Some (step (next_state s execs) (next_action s execs)))\n       (next_execs s execs))\n     (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n       (next_execs t' execs2))\n     u", "unfolding next_state_def"], ["proof (prove)\nusing this:\n  does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n  iequivalent_states\n   (Some\n     (step (snd (snd (control s (current s) (execs (current s)))))\n       (next_action s execs)))\n   (Some\n     (step (snd (snd (control t' (current t') (execs2 (current t')))))\n       (next_action t' execs2)))\n   u \\<and>\n  ipurged_relation1 u (next_execs s execs)\n   (next_execs t' execs2) \\<longrightarrow>\n  iequivalent_states\n   (run n\n     (Some\n       (step (snd (snd (control s (current s) (execs (current s)))))\n         (next_action s execs)))\n     (next_execs s execs))\n   (run n\n     (Some\n       (step (snd (snd (control t' (current t') (execs2 (current t')))))\n         (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  ipurged_relation1 u (next_execs s execs) (next_execs t' execs2)\n  current\n   (step (snd (snd (control s (current s) (execs (current s)))))\n     (next_action s execs)) =\n  current\n   (step (snd (snd (control t' (current t') (execs2 (current t')))))\n     (next_action t' execs2))\n  \\<lbrakk>precondition\n            (snd (snd (control s (current s) (execs (current s)))))\n            (next_action s execs) \\<and>\n           precondition\n            (snd (snd (control t' (current t') (execs (current t')))))\n            (next_action s execs);\n   ifp (current s) u \\<and> \\<not> intermediary (current s) u\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v.\n                       ifp v u \\<and>\n                       \\<not> intermediary v u \\<longrightarrow>\n                       vpeq v\n                        (step\n                          (snd (snd (control s (current s)\n(execs (current s)))))\n                          (next_action s execs))\n                        (step\n                          (snd (snd (control t' (current t')\n(execs (current t')))))\n                          (next_action s execs))\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n  precondition (snd (snd (control t' (current t') (execs2 (current t')))))\n   (next_action t' execs2)\n  precondition (snd (snd (control s (current s) (execs (current s)))))\n   (next_action s execs)\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  execs (current s) = execs2 (current s)\n  current s = current t'\n  does_not_communicate_with_gateway u (next_execs s execs)\n\ngoal (1 subgoal):\n 1. iequivalent_states\n     (run n\n       (Some\n         (step (snd (snd (control s (current s) (execs (current s)))))\n           (next_action s execs)))\n       (next_execs s execs))\n     (run n\n       (Some\n         (step (snd (snd (control t' (current t') (execs2 (current t')))))\n           (next_action t' execs2)))\n       (next_execs t' execs2))\n     u", "by (auto,metis)"], ["proof (state)\nthis:\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from this not_interrupt thread_not_empty_s prec_s F2 T3"], ["proof (chain)\npicking this:\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state t' execs2) (next_action t' execs2)", "have current_rs_rt: \"current rs = current rt\""], ["proof (prove)\nusing this:\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. current rs = current rt", "using rs rt"], ["proof (prove)\nusing this:\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state t' execs2) (next_action t' execs2)\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. current rs = current rt", "by auto"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "{"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "assume ia: \"ifp v u \\<and> \\<not>intermediary v u\""], ["proof (state)\nthis:\n  ifp v u \\<and> \\<not> intermediary v u\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from this eq_ns_nt not_interrupt thread_not_empty_s prec_s F2 T3"], ["proof (chain)\npicking this:\n  ifp v u \\<and> \\<not> intermediary v u\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state t' execs2) (next_action t' execs2)", "have \"vpeq v rs rt\""], ["proof (prove)\nusing this:\n  ifp v u \\<and> \\<not> intermediary v u\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "using rs rt"], ["proof (prove)\nusing this:\n  ifp v u \\<and> \\<not> intermediary v u\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> thread_empty (execs2 (current t'))\n  precondition (next_state t' execs2) (next_action t' execs2)\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "by auto"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "}"], ["proof (state)\nthis:\n  ifp ?v2 u \\<and> \\<not> intermediary ?v2 u \\<Longrightarrow>\n  vpeq ?v2 rs rt\n\ngoal (2 subgoals):\n 1. precondition (next_state t' execs2)\n     (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u\n 2. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from this and current_rs_rt"], ["proof (chain)\npicking this:\n  ifp ?v2 u \\<and> \\<not> intermediary ?v2 u \\<Longrightarrow>\n  vpeq ?v2 rs rt\n  current rs = current rt", "show ?thesis"], ["proof (prove)\nusing this:\n  ifp ?v2 u \\<and> \\<not> intermediary ?v2 u \\<Longrightarrow>\n  vpeq ?v2 rs rt\n  current rs = current rt\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "using rs rt"], ["proof (prove)\nusing this:\n  ifp ?v2 u \\<and> \\<not> intermediary ?v2 u \\<Longrightarrow>\n  vpeq ?v2 rs rt\n  current rs = current rt\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "by auto"], ["proof (state)\nthis:\n  iequivalent_states (run (Suc n) (Some s) execs)\n   (run (Suc n) (Some t') execs2) u\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "case F3"], ["proof (state)\nthis:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. \\<not> precondition (next_state t' execs2)\n            (next_action t' execs2) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from F3 F2 not_interrupt"], ["proof (chain)\npicking this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "using rt"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> interrupt (Suc n)\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "by simp"], ["proof (state)\nthis:\n  iequivalent_states (run (Suc n) (Some s) execs)\n   (run (Suc n) (Some t') execs2) u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  iequivalent_states (run (Suc n) (Some s) execs)\n   (run (Suc n) (Some t') execs2) u\n\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "case T2"], ["proof (state)\nthis:\n  thread_empty (execs2 (current t'))\n\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from T2 T purged_a_a2 thread_not_empty_s current_s_t prec_s next_action_s_t vpeq_u_s_t"], ["proof (chain)\npicking this:\n  thread_empty (execs2 (current t'))\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n  ipurged_relation1 u execs execs2\n  \\<not> thread_empty (execs (current s))\n  current s = current t'\n  precondition (next_state s execs) (next_action s execs)\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  vpeq u s t'", "have ind_source: \"False\""], ["proof (prove)\nusing this:\n  thread_empty (execs2 (current t'))\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n  ipurged_relation1 u execs execs2\n  \\<not> thread_empty (execs (current s))\n  current s = current t'\n  precondition (next_state s execs) (next_action s execs)\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  vpeq u s t'\n\ngoal (1 subgoal):\n 1. False", "unfolding  ipurged_relation1_def"], ["proof (prove)\nusing this:\n  thread_empty (execs2 (current t'))\n  ifp (current s) u \\<and> \\<not> intermediary (current s) u\n  \\<forall>d.\n     (ifp d u \\<longrightarrow> execs d = execs2 d) \\<and>\n     (intermediary d u \\<longrightarrow> execs d = [])\n  \\<not> thread_empty (execs (current s))\n  current s = current t'\n  precondition (next_state s execs) (next_action s execs)\n  ifp (current s) u \\<and>\n  \\<not> intermediary (current s) u \\<longrightarrow>\n  next_action t' execs2 = next_action s execs\n  vpeq u s t'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. thread_empty (execs2 (current t')) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "by auto"], ["proof (state)\nthis:\n  iequivalent_states (run (Suc n) (Some s) execs)\n   (run (Suc n) (Some t') execs2) u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  iequivalent_states (run (Suc n) (Some s) execs)\n   (run (Suc n) (Some t') execs2) u\n\ngoal (1 subgoal):\n 1. \\<not> (ifp (current s) u \\<and>\n            \\<not> intermediary (current s) u) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (ifp (current s) u \\<and>\n            \\<not> intermediary (current s) u) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "case F"], ["proof (state)\nthis:\n  \\<not> (ifp (current s) u \\<and> \\<not> intermediary (current s) u)\n\ngoal (1 subgoal):\n 1. \\<not> (ifp (current s) u \\<and>\n            \\<not> intermediary (current s) u) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "hence 1: \"ind_source (current s) u \\<or> unrelated (current s) u \\<or> intermediary (current s) u\""], ["proof (prove)\nusing this:\n  \\<not> (ifp (current s) u \\<and> \\<not> intermediary (current s) u)\n\ngoal (1 subgoal):\n 1. ind_source (current s) u \\<or>\n    unrelated (current s) u \\<or> intermediary (current s) u", "unfolding intermediary_def"], ["proof (prove)\nusing this:\n  \\<not> (ifp (current s) u \\<and>\n          (\\<nexists>v.\n              ifp\\<^sup>*\\<^sup>* v (current s) \\<and>\n              ifp (current s) u \\<and>\n              \\<not> ifp v u \\<and> current s \\<noteq> u))\n\ngoal (1 subgoal):\n 1. ind_source (current s) u \\<or>\n    unrelated (current s) u \\<or>\n    (\\<exists>v.\n        ifp\\<^sup>*\\<^sup>* v (current s) \\<and>\n        ifp (current s) u \\<and> \\<not> ifp v u \\<and> current s \\<noteq> u)", "by auto"], ["proof (state)\nthis:\n  ind_source (current s) u \\<or>\n  unrelated (current s) u \\<or> intermediary (current s) u\n\ngoal (1 subgoal):\n 1. \\<not> (ifp (current s) u \\<and>\n            \\<not> intermediary (current s) u) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from purged_a_a2 and thread_not_empty_s"], ["proof (chain)\npicking this:\n  ipurged_relation1 u execs execs2\n  \\<not> thread_empty (execs (current s))", "have 2: \"\\<not>intermediary (current s) u\""], ["proof (prove)\nusing this:\n  ipurged_relation1 u execs execs2\n  \\<not> thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. \\<not> intermediary (current s) u", "unfolding ipurged_relation1_def"], ["proof (prove)\nusing this:\n  \\<forall>d.\n     (ifp d u \\<longrightarrow> execs d = execs2 d) \\<and>\n     (intermediary d u \\<longrightarrow> execs d = [])\n  \\<not> thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. \\<not> intermediary (current s) u", "by auto"], ["proof (state)\nthis:\n  \\<not> intermediary (current s) u\n\ngoal (1 subgoal):\n 1. \\<not> (ifp (current s) u \\<and>\n            \\<not> intermediary (current s) u) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "let ?nt = \"if thread_empty(execs2 (current t'))  then t' else step (next_state t' execs2) (next_action t' execs2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (ifp (current s) u \\<and>\n            \\<not> intermediary (current s) u) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "let ?na2 = \"if thread_empty(execs2 (current t')) then execs2 else next_execs t' execs2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (ifp (current s) u \\<and>\n            \\<not> intermediary (current s) u) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "have prec_t: \"\\<not>thread_empty(execs2 (current t')) \\<Longrightarrow> precondition (next_state t' execs2) (next_action t' execs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    precondition (next_state t' execs2) (next_action t' execs2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    precondition (next_state t' execs2) (next_action t' execs2)", "assume thread_not_empty_t: \"\\<not>thread_empty(execs2 (current t'))\""], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t'))\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    precondition (next_state t' execs2) (next_action t' execs2)", "{"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t'))\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    precondition (next_state t' execs2) (next_action t' execs2)", "assume not_prec_t: \"\\<not>precondition (next_state t' execs2) (next_action t' execs2)\""], ["proof (state)\nthis:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    precondition (next_state t' execs2) (next_action t' execs2)", "hence \"run (Suc n) (Some t') execs2 = None\""], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. run (Suc n) (Some t') execs2 = None", "using not_interrupt thread_not_empty_t not_prec_t"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs2 (current t'))\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. run (Suc n) (Some t') execs2 = None", "by (simp)"], ["proof (state)\nthis:\n  run (Suc n) (Some t') execs2 = None\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    precondition (next_state t' execs2) (next_action t' execs2)", "from this"], ["proof (chain)\npicking this:\n  run (Suc n) (Some t') execs2 = None", "have \"False\""], ["proof (prove)\nusing this:\n  run (Suc n) (Some t') execs2 = None\n\ngoal (1 subgoal):\n 1. False", "using rt"], ["proof (prove)\nusing this:\n  run (Suc n) (Some t') execs2 = None\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. False", "by(simp add:option.splits)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    precondition (next_state t' execs2) (next_action t' execs2)", "}"], ["proof (state)\nthis:\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n    precondition (next_state t' execs2) (next_action t' execs2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. precondition (next_state t' execs2) (next_action t' execs2)", "by auto"], ["proof (state)\nthis:\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. \\<not> (ifp (current s) u \\<and>\n            \\<not> intermediary (current s) u) \\<Longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "assume ifp_v: \"ifp v u\""], ["proof (state)\nthis:\n  ifp v u\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "assume v_not_intermediary: \"\\<not>intermediary v u\""], ["proof (state)\nthis:\n  \\<not> intermediary v u\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "have not_ifp_curr_v: \"\\<not>ifp (current s) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ifp (current s) v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ifp (current s) v \\<Longrightarrow> False", "assume ifp_curr_v: \"ifp (current s) v\""], ["proof (state)\nthis:\n  ifp (current s) v\n\ngoal (1 subgoal):\n 1. ifp (current s) v \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  ifp (current s) v\n\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ifp (current s) v \\<Longrightarrow> False", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ifp (current s) v \\<Longrightarrow> False", "assume \"ind_source (current s) u\""], ["proof (state)\nthis:\n  ind_source (current s) u\n\ngoal (1 subgoal):\n 1. ifp (current s) v \\<Longrightarrow> False", "from this ifp_curr_v ifp_v"], ["proof (chain)\npicking this:\n  ind_source (current s) u\n  ifp (current s) v\n  ifp v u", "have \"intermediary v u\""], ["proof (prove)\nusing this:\n  ind_source (current s) u\n  ifp (current s) v\n  ifp v u\n\ngoal (1 subgoal):\n 1. intermediary v u", "unfolding intermediary_def"], ["proof (prove)\nusing this:\n  ind_source (current s) u\n  ifp (current s) v\n  ifp v u\n\ngoal (1 subgoal):\n 1. \\<exists>va.\n       ifp\\<^sup>*\\<^sup>* va v \\<and>\n       ifp v u \\<and> \\<not> ifp va u \\<and> v \\<noteq> u", "by auto"], ["proof (state)\nthis:\n  intermediary v u\n\ngoal (1 subgoal):\n 1. ifp (current s) v \\<Longrightarrow> False", "from this v_not_intermediary"], ["proof (chain)\npicking this:\n  intermediary v u\n  \\<not> intermediary v u", "have False"], ["proof (prove)\nusing this:\n  intermediary v u\n  \\<not> intermediary v u\n\ngoal (1 subgoal):\n 1. False", "unfolding intermediary_def"], ["proof (prove)\nusing this:\n  \\<exists>va.\n     ifp\\<^sup>*\\<^sup>* va v \\<and>\n     ifp v u \\<and> \\<not> ifp va u \\<and> v \\<noteq> u\n  \\<nexists>va.\n     ifp\\<^sup>*\\<^sup>* va v \\<and>\n     ifp v u \\<and> \\<not> ifp va u \\<and> v \\<noteq> u\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. ifp (current s) v \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  ind_source (current s) u \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. ifp (current s) v \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ind_source (current s) u \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. ifp (current s) v \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  ind_source (current s) u \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. ifp (current s) v \\<Longrightarrow> False", "assume unrelated: \"unrelated (current s) u\""], ["proof (state)\nthis:\n  unrelated (current s) u\n\ngoal (1 subgoal):\n 1. ifp (current s) v \\<Longrightarrow> False", "from this ifp_v ifp_curr_v"], ["proof (chain)\npicking this:\n  unrelated (current s) u\n  ifp v u\n  ifp (current s) v", "have \"False\""], ["proof (prove)\nusing this:\n  unrelated (current s) u\n  ifp v u\n  ifp (current s) v\n\ngoal (1 subgoal):\n 1. False", "using rtranclp_trans r_into_rtranclp"], ["proof (prove)\nusing this:\n  unrelated (current s) u\n  ifp v u\n  ifp (current s) v\n  \\<lbrakk>?r\\<^sup>*\\<^sup>* ?x ?y; ?r\\<^sup>*\\<^sup>* ?y ?z\\<rbrakk>\n  \\<Longrightarrow> ?r\\<^sup>*\\<^sup>* ?x ?z\n  ?r ?x ?y \\<Longrightarrow> ?r\\<^sup>*\\<^sup>* ?x ?y\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. ifp (current s) v \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  unrelated (current s) u \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. ifp (current s) v \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  ind_source (current s) u \\<Longrightarrow> False\n  unrelated (current s) u \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  ind_source (current s) u \\<Longrightarrow> False\n  unrelated (current s) u \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "using 1 2"], ["proof (prove)\nusing this:\n  ind_source (current s) u \\<Longrightarrow> False\n  unrelated (current s) u \\<Longrightarrow> False\n  ind_source (current s) u \\<or>\n  unrelated (current s) u \\<or> intermediary (current s) u\n  \\<not> intermediary (current s) u\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> ifp (current s) v\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from this current_next_state[THEN spec,THEN spec,where x1=s and x=execs] prec_s\n             locally_respects[THEN spec,THEN spec,where x=\"next_state s execs\"] vpeq_reflexive"], ["proof (chain)\npicking this:\n  \\<not> ifp (current s) v\n  current (next_state s execs) = current s\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>u.\n     \\<not> ifp (current (next_state s execs)) u \\<and>\n     kprecondition (next_state s execs) ?x1 \\<longrightarrow>\n     vpeq u (next_state s execs) (kstep (next_state s execs) ?x1)\n  \\<forall>a u. vpeq u a a", "have \"vpeq v (next_state s execs) (step (next_state s execs) (next_action s execs))\""], ["proof (prove)\nusing this:\n  \\<not> ifp (current s) v\n  current (next_state s execs) = current s\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>u.\n     \\<not> ifp (current (next_state s execs)) u \\<and>\n     kprecondition (next_state s execs) ?x1 \\<longrightarrow>\n     vpeq u (next_state s execs) (kstep (next_state s execs) ?x1)\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. vpeq v (next_state s execs)\n     (step (next_state s execs) (next_action s execs))", "unfolding step_def precondition_def B_def"], ["proof (prove)\nusing this:\n  \\<not> ifp (current s) v\n  current (next_state s execs) = current s\n  case next_action s execs of None \\<Rightarrow> True\n  | Some a \\<Rightarrow> kprecondition (next_state s execs) a\n  \\<forall>u.\n     \\<not> ifp (current (next_state s execs)) u \\<and>\n     kprecondition (next_state s execs) ?x1 \\<longrightarrow>\n     vpeq u (next_state s execs) (kstep (next_state s execs) ?x1)\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. vpeq v (next_state s execs)\n     (case next_action s execs of None \\<Rightarrow> next_state s execs\n      | Some a \\<Rightarrow> kstep (next_state s execs) a)", "by (cases \"next_action s execs\",auto)"], ["proof (state)\nthis:\n  vpeq v (next_state s execs)\n   (step (next_state s execs) (next_action s execs))\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from not_ifp_curr_v this locally_respects_next_state vpeq_transitive"], ["proof (chain)\npicking this:\n  \\<not> ifp (current s) v\n  vpeq v (next_state s execs)\n   (step (next_state s execs) (next_action s execs))\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c", "have vpeq_s_ns: \"vpeq v s (step (next_state s execs) (next_action s execs))\""], ["proof (prove)\nusing this:\n  \\<not> ifp (current s) v\n  vpeq v (next_state s execs)\n   (step (next_state s execs) (next_action s execs))\n  \\<forall>s u execs.\n     \\<not> ifp (current s) u \\<longrightarrow>\n     vpeq u s (next_state s execs)\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n\ngoal (1 subgoal):\n 1. vpeq v s (step (next_state s execs) (next_action s execs))", "by blast"], ["proof (state)\nthis:\n  vpeq v s (step (next_state s execs) (next_action s execs))\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from not_ifp_curr_v current_s_t current_next_state[THEN spec,THEN spec,where x1=t' and x=execs2] prec_t\n             locally_respects[THEN spec,THEN spec,where x=\"next_state t' execs2\"]\n             F vpeq_reflexive"], ["proof (chain)\npicking this:\n  \\<not> ifp (current s) v\n  current s = current t'\n  current (next_state t' execs2) = current t'\n  \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<forall>u.\n     \\<not> ifp (current (next_state t' execs2)) u \\<and>\n     kprecondition (next_state t' execs2) ?x1 \\<longrightarrow>\n     vpeq u (next_state t' execs2) (kstep (next_state t' execs2) ?x1)\n  \\<not> (ifp (current s) u \\<and> \\<not> intermediary (current s) u)\n  \\<forall>a u. vpeq u a a", "have 0: \"\\<not> thread_empty (execs2 (current t')) \\<longrightarrow> vpeq v (next_state t' execs2) (step (next_state t' execs2) (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  \\<not> ifp (current s) v\n  current s = current t'\n  current (next_state t' execs2) = current t'\n  \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n  precondition (next_state t' execs2) (next_action t' execs2)\n  \\<forall>u.\n     \\<not> ifp (current (next_state t' execs2)) u \\<and>\n     kprecondition (next_state t' execs2) ?x1 \\<longrightarrow>\n     vpeq u (next_state t' execs2) (kstep (next_state t' execs2) ?x1)\n  \\<not> (ifp (current s) u \\<and> \\<not> intermediary (current s) u)\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<longrightarrow>\n    vpeq v (next_state t' execs2)\n     (step (next_state t' execs2) (next_action t' execs2))", "unfolding step_def precondition_def B_def"], ["proof (prove)\nusing this:\n  \\<not> ifp (current s) v\n  current s = current t'\n  current (next_state t' execs2) = current t'\n  \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n  case next_action t' execs2 of None \\<Rightarrow> True\n  | Some a \\<Rightarrow> kprecondition (next_state t' execs2) a\n  \\<forall>u.\n     \\<not> ifp (current (next_state t' execs2)) u \\<and>\n     kprecondition (next_state t' execs2) ?x1 \\<longrightarrow>\n     vpeq u (next_state t' execs2) (kstep (next_state t' execs2) ?x1)\n  \\<not> (ifp (current s) u \\<and> \\<not> intermediary (current s) u)\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<longrightarrow>\n    vpeq v (next_state t' execs2)\n     (case next_action t' execs2 of None \\<Rightarrow> next_state t' execs2\n      | Some a \\<Rightarrow> kstep (next_state t' execs2) a)", "by (cases \"next_action t' execs2\",auto)"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<longrightarrow>\n  vpeq v (next_state t' execs2)\n   (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from 0 not_ifp_curr_v current_s_t locally_respects_next_state[THEN spec,THEN spec,THEN spec,where x2=\"t'\" and x1=v and x=\"execs2\"]\n             vpeq_transitive"], ["proof (chain)\npicking this:\n  \\<not> thread_empty (execs2 (current t')) \\<longrightarrow>\n  vpeq v (next_state t' execs2)\n   (step (next_state t' execs2) (next_action t' execs2))\n  \\<not> ifp (current s) v\n  current s = current t'\n  \\<not> ifp (current t') v \\<longrightarrow>\n  vpeq v t' (next_state t' execs2)\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c", "have vpeq_t_nt: \"\\<not> thread_empty (execs2 (current t')) \\<longrightarrow> vpeq v t' (step (next_state t' execs2) (next_action t' execs2))\""], ["proof (prove)\nusing this:\n  \\<not> thread_empty (execs2 (current t')) \\<longrightarrow>\n  vpeq v (next_state t' execs2)\n   (step (next_state t' execs2) (next_action t' execs2))\n  \\<not> ifp (current s) v\n  current s = current t'\n  \\<not> ifp (current t') v \\<longrightarrow>\n  vpeq v t' (next_state t' execs2)\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n\ngoal (1 subgoal):\n 1. \\<not> thread_empty (execs2 (current t')) \\<longrightarrow>\n    vpeq v t' (step (next_state t' execs2) (next_action t' execs2))", "by metis"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<longrightarrow>\n  vpeq v t' (step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from this vpeq_reflexive"], ["proof (chain)\npicking this:\n  \\<not> thread_empty (execs2 (current t')) \\<longrightarrow>\n  vpeq v t' (step (next_state t' execs2) (next_action t' execs2))\n  \\<forall>a u. vpeq u a a", "have vpeq_t_nt: \"vpeq v t' ?nt\""], ["proof (prove)\nusing this:\n  \\<not> thread_empty (execs2 (current t')) \\<longrightarrow>\n  vpeq v t' (step (next_state t' execs2) (next_action t' execs2))\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. vpeq v t'\n     (if thread_empty (execs2 (current t')) then t'\n      else step (next_state t' execs2) (next_action t' execs2))", "by auto"], ["proof (state)\nthis:\n  vpeq v t'\n   (if thread_empty (execs2 (current t')) then t'\n    else step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from vpeq_s_t ifp_v v_not_intermediary"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  ifp v u\n  \\<not> intermediary v u", "have \"vpeq v s t'\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  ifp v u\n  \\<not> intermediary v u\n\ngoal (1 subgoal):\n 1. vpeq v s t'", "by auto"], ["proof (state)\nthis:\n  vpeq v s t'\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from this vpeq_s_ns vpeq_t_nt vpeq_transitive vpeq_symmetric vpeq_reflexive"], ["proof (chain)\npicking this:\n  vpeq v s t'\n  vpeq v s (step (next_state s execs) (next_action s execs))\n  vpeq v t'\n   (if thread_empty (execs2 (current t')) then t'\n    else step (next_state t' execs2) (next_action t' execs2))\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n  \\<forall>a b u. vpeq u a b \\<longrightarrow> vpeq u b a\n  \\<forall>a u. vpeq u a a", "have \"vpeq v (step (next_state s execs) (next_action s execs)) ?nt\""], ["proof (prove)\nusing this:\n  vpeq v s t'\n  vpeq v s (step (next_state s execs) (next_action s execs))\n  vpeq v t'\n   (if thread_empty (execs2 (current t')) then t'\n    else step (next_state t' execs2) (next_action t' execs2))\n  \\<forall>a b c u.\n     vpeq u a b \\<and> vpeq u b c \\<longrightarrow> vpeq u a c\n  \\<forall>a b u. vpeq u a b \\<longrightarrow> vpeq u b a\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. vpeq v (step (next_state s execs) (next_action s execs))\n     (if thread_empty (execs2 (current t')) then t'\n      else step (next_state t' execs2) (next_action t' execs2))", "by (metis (hide_lams, no_types))"], ["proof (state)\nthis:\n  vpeq v (step (next_state s execs) (next_action s execs))\n   (if thread_empty (execs2 (current t')) then t'\n    else step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "}"], ["proof (state)\nthis:\n  \\<lbrakk>ifp ?v2 u; \\<not> intermediary ?v2 u\\<rbrakk>\n  \\<Longrightarrow> vpeq ?v2\n                     (step (next_state s execs) (next_action s execs))\n                     (if thread_empty (execs2 (current t')) then t'\n                      else step (next_state t' execs2)\n                            (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "hence vpeq_ns_nt: \"\\<forall> v . ifp v u \\<and> \\<not>intermediary v u \\<longrightarrow> vpeq v (step (next_state s execs) (next_action s execs)) ?nt\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ifp ?v2 u; \\<not> intermediary ?v2 u\\<rbrakk>\n  \\<Longrightarrow> vpeq ?v2\n                     (step (next_state s execs) (next_action s execs))\n                     (if thread_empty (execs2 (current t')) then t'\n                      else step (next_state t' execs2)\n                            (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n       vpeq v (step (next_state s execs) (next_action s execs))\n        (if thread_empty (execs2 (current t')) then t'\n         else step (next_state t' execs2) (next_action t' execs2))", "by auto"], ["proof (state)\nthis:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs))\n      (if thread_empty (execs2 (current t')) then t'\n       else step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from vpeq_s_t 2 F purged_a_a2 current_s_t thread_not_empty_s"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  \\<not> intermediary (current s) u\n  \\<not> (ifp (current s) u \\<and> \\<not> intermediary (current s) u)\n  ipurged_relation1 u execs execs2\n  current s = current t'\n  \\<not> thread_empty (execs (current s))", "have purged_na_na2: \"ipurged_relation1 u (next_execs s execs) ?na2\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow> vpeq v s t'\n  \\<not> intermediary (current s) u\n  \\<not> (ifp (current s) u \\<and> \\<not> intermediary (current s) u)\n  ipurged_relation1 u execs execs2\n  current s = current t'\n  \\<not> thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. ipurged_relation1 u (next_execs s execs)\n     (if thread_empty (execs2 (current t')) then execs2\n      else next_execs t' execs2)", "unfolding ipurged_relation1_def next_execs_def intermediary_def"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     ifp v u \\<and>\n     (\\<nexists>va.\n         ifp\\<^sup>*\\<^sup>* va v \\<and>\n         ifp v u \\<and>\n         \\<not> ifp va u \\<and> v \\<noteq> u) \\<longrightarrow>\n     vpeq v s t'\n  \\<nexists>v.\n     ifp\\<^sup>*\\<^sup>* v (current s) \\<and>\n     ifp (current s) u \\<and> \\<not> ifp v u \\<and> current s \\<noteq> u\n  \\<not> (ifp (current s) u \\<and>\n          (\\<nexists>v.\n              ifp\\<^sup>*\\<^sup>* v (current s) \\<and>\n              ifp (current s) u \\<and>\n              \\<not> ifp v u \\<and> current s \\<noteq> u))\n  \\<forall>d.\n     (ifp d u \\<longrightarrow> execs d = execs2 d) \\<and>\n     ((\\<exists>v.\n          ifp\\<^sup>*\\<^sup>* v d \\<and>\n          ifp d u \\<and>\n          \\<not> ifp v u \\<and> d \\<noteq> u) \\<longrightarrow>\n      execs d = [])\n  current s = current t'\n  \\<not> thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. \\<forall>d.\n       (ifp d u \\<longrightarrow>\n        (execs\n         (current s :=\n            fst (snd (control s (current s) (execs (current s))))))\n         d =\n        (if thread_empty (execs2 (current t')) then execs2\n         else execs2\n              (current t' :=\n                 fst (snd (control t' (current t') (execs2 (current t'))))))\n         d) \\<and>\n       ((\\<exists>v.\n            ifp\\<^sup>*\\<^sup>* v d \\<and>\n            ifp d u \\<and>\n            \\<not> ifp v u \\<and> d \\<noteq> u) \\<longrightarrow>\n        (execs\n         (current s :=\n            fst (snd (control s (current s) (execs (current s))))))\n         d =\n        [])", "by(auto)"], ["proof (state)\nthis:\n  ipurged_relation1 u (next_execs s execs)\n   (if thread_empty (execs2 (current t')) then execs2\n    else next_execs t' execs2)\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from current_ns_nt current_ns_t current_next_state"], ["proof (chain)\npicking this:\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  current (step (next_state s execs) (next_action s execs)) = current t'\n  \\<forall>s execs. current (next_state s execs) = current s", "have current_ns_nt:\n            \"current (step (next_state s execs) (next_action s execs)) = current ?nt\""], ["proof (prove)\nusing this:\n  current (step (next_state s execs) (next_action s execs)) =\n  current (step (next_state t' execs2) (next_action t' execs2))\n  current (step (next_state s execs) (next_action s execs)) = current t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. current (step (next_state s execs) (next_action s execs)) =\n    current\n     (if thread_empty (execs2 (current t')) then t'\n      else step (next_state t' execs2) (next_action t' execs2))", "by auto"], ["proof (state)\nthis:\n  current (step (next_state s execs) (next_action s execs)) =\n  current\n   (if thread_empty (execs2 (current t')) then t'\n    else step (next_state t' execs2) (next_action t' execs2))\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from prec_s vpeq_ns_nt no_gateway_comm_na\n            and IH[where t=\"Some ?nt\" and ?execs2.0=\"?na2\" and u=u]\n            and current_ns_nt purged_na_na2"], ["proof (chain)\npicking this:\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs))\n      (if thread_empty (execs2 (current t')) then t'\n       else step (next_state t' execs2) (next_action t' execs2))\n  does_not_communicate_with_gateway u (next_execs s execs)\n  does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n  iequivalent_states\n   (Some (step (next_state s execs) (next_action s execs)))\n   (Some\n     (if thread_empty (execs2 (current t')) then t'\n      else step (next_state t' execs2) (next_action t' execs2)))\n   u \\<and>\n  ipurged_relation1 u (next_execs s execs)\n   (if thread_empty (execs2 (current t')) then execs2\n    else next_execs t' execs2) \\<longrightarrow>\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n\n     (Some\n       (if thread_empty (execs2 (current t')) then t'\n        else step (next_state t' execs2) (next_action t' execs2)))\n     (if thread_empty (execs2 (current t')) then execs2\n      else next_execs t' execs2))\n   u\n  current (step (next_state s execs) (next_action s execs)) =\n  current\n   (if thread_empty (execs2 (current t')) then t'\n    else step (next_state t' execs2) (next_action t' execs2))\n  ipurged_relation1 u (next_execs s execs)\n   (if thread_empty (execs2 (current t')) then execs2\n    else next_execs t' execs2)", "have eq_ns_nt: \"iequivalent_states (run n (Some (step (next_state s execs) (next_action s execs))) (next_execs s execs))\n                                               (run n (Some ?nt) ?na2) u\""], ["proof (prove)\nusing this:\n  precondition (next_state s execs) (next_action s execs)\n  \\<forall>v.\n     ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n     vpeq v (step (next_state s execs) (next_action s execs))\n      (if thread_empty (execs2 (current t')) then t'\n       else step (next_state t' execs2) (next_action t' execs2))\n  does_not_communicate_with_gateway u (next_execs s execs)\n  does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n  iequivalent_states\n   (Some (step (next_state s execs) (next_action s execs)))\n   (Some\n     (if thread_empty (execs2 (current t')) then t'\n      else step (next_state t' execs2) (next_action t' execs2)))\n   u \\<and>\n  ipurged_relation1 u (next_execs s execs)\n   (if thread_empty (execs2 (current t')) then execs2\n    else next_execs t' execs2) \\<longrightarrow>\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n\n     (Some\n       (if thread_empty (execs2 (current t')) then t'\n        else step (next_state t' execs2) (next_action t' execs2)))\n     (if thread_empty (execs2 (current t')) then execs2\n      else next_execs t' execs2))\n   u\n  current (step (next_state s execs) (next_action s execs)) =\n  current\n   (if thread_empty (execs2 (current t')) then t'\n    else step (next_state t' execs2) (next_action t' execs2))\n  ipurged_relation1 u (next_execs s execs)\n   (if thread_empty (execs2 (current t')) then execs2\n    else next_execs t' execs2)\n\ngoal (1 subgoal):\n 1. iequivalent_states\n     (run n (Some (step (next_state s execs) (next_action s execs)))\n       (next_execs s execs))\n     (run n\n       (Some\n         (if thread_empty (execs2 (current t')) then t'\n          else step (next_state t' execs2) (next_action t' execs2)))\n       (if thread_empty (execs2 (current t')) then execs2\n        else next_execs t' execs2))\n     u", "by auto"], ["proof (state)\nthis:\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n\n     (Some\n       (if thread_empty (execs2 (current t')) then t'\n        else step (next_state t' execs2) (next_action t' execs2)))\n     (if thread_empty (execs2 (current t')) then execs2\n      else next_execs t' execs2))\n   u\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from this not_interrupt thread_not_empty_s prec_t prec_s"], ["proof (chain)\npicking this:\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n\n     (Some\n       (if thread_empty (execs2 (current t')) then t'\n        else step (next_state t' execs2) (next_action t' execs2)))\n     (if thread_empty (execs2 (current t')) then execs2\n      else next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n  precondition (next_state t' execs2) (next_action t' execs2)\n  precondition (next_state s execs) (next_action s execs)", "have current_rs_rt: \"current rs = current rt\""], ["proof (prove)\nusing this:\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n\n     (Some\n       (if thread_empty (execs2 (current t')) then t'\n        else step (next_state t' execs2) (next_action t' execs2)))\n     (if thread_empty (execs2 (current t')) then execs2\n      else next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n  precondition (next_state t' execs2) (next_action t' execs2)\n  precondition (next_state s execs) (next_action s execs)\n\ngoal (1 subgoal):\n 1. current rs = current rt", "using rs rt"], ["proof (prove)\nusing this:\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n\n     (Some\n       (if thread_empty (execs2 (current t')) then t'\n        else step (next_state t' execs2) (next_action t' execs2)))\n     (if thread_empty (execs2 (current t')) then execs2\n      else next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n  precondition (next_state t' execs2) (next_action t' execs2)\n  precondition (next_state s execs) (next_action s execs)\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. current rs = current rt", "by (cases \"thread_empty (execs2 (current t'))\",simp,simp)"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "{"], ["proof (state)\nthis:\n  current rs = current rt\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "assume ia: \"ifp v u \\<and> \\<not>intermediary v u\""], ["proof (state)\nthis:\n  ifp v u \\<and> \\<not> intermediary v u\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from this eq_ns_nt not_interrupt thread_not_empty_s prec_s prec_t"], ["proof (chain)\npicking this:\n  ifp v u \\<and> \\<not> intermediary v u\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n\n     (Some\n       (if thread_empty (execs2 (current t')) then t'\n        else step (next_state t' execs2) (next_action t' execs2)))\n     (if thread_empty (execs2 (current t')) then execs2\n      else next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n  precondition (next_state t' execs2) (next_action t' execs2)", "have \"vpeq v rs rt\""], ["proof (prove)\nusing this:\n  ifp v u \\<and> \\<not> intermediary v u\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n\n     (Some\n       (if thread_empty (execs2 (current t')) then t'\n        else step (next_state t' execs2) (next_action t' execs2)))\n     (if thread_empty (execs2 (current t')) then execs2\n      else next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "using rs rt"], ["proof (prove)\nusing this:\n  ifp v u \\<and> \\<not> intermediary v u\n  iequivalent_states\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n\n     (Some\n       (if thread_empty (execs2 (current t')) then t'\n        else step (next_state t' execs2) (next_action t' execs2)))\n     (if thread_empty (execs2 (current t')) then execs2\n      else next_execs t' execs2))\n   u\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  \\<not> thread_empty (execs2 (current t')) \\<Longrightarrow>\n  precondition (next_state t' execs2) (next_action t' execs2)\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. vpeq v rs rt", "by (cases \"thread_empty(execs2 (current t'))\",simp,simp)"], ["proof (state)\nthis:\n  vpeq v rs rt\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "}"], ["proof (state)\nthis:\n  ifp ?v2 u \\<and> \\<not> intermediary ?v2 u \\<Longrightarrow>\n  vpeq ?v2 rs rt\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "from current_rs_rt and this"], ["proof (chain)\npicking this:\n  current rs = current rt\n  ifp ?v2 u \\<and> \\<not> intermediary ?v2 u \\<Longrightarrow>\n  vpeq ?v2 rs rt", "show ?thesis"], ["proof (prove)\nusing this:\n  current rs = current rt\n  ifp ?v2 u \\<and> \\<not> intermediary ?v2 u \\<Longrightarrow>\n  vpeq ?v2 rs rt\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "using rs rt"], ["proof (prove)\nusing this:\n  current rs = current rt\n  ifp ?v2 u \\<and> \\<not> intermediary ?v2 u \\<Longrightarrow>\n  vpeq ?v2 rs rt\n  run (Suc n) (Some s) execs = Some rs\n  run (Suc n) (Some t') execs2 = Some rt\n\ngoal (1 subgoal):\n 1. iequivalent_states (run (Suc n) (Some s) execs)\n     (run (Suc n) (Some t') execs2) u", "by auto"], ["proof (state)\nthis:\n  iequivalent_states (run (Suc n) (Some s) execs)\n   (run (Suc n) (Some t') execs2) u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  iequivalent_states (run (Suc n) (Some s) execs)\n   (run (Suc n) (Some t') execs2) u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  iequivalent_states (run (Suc n) (Some s) execs)\n   (run (Suc n) (Some t') execs2) u\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "}"], ["proof (state)\nthis:\n  \\<lbrakk>t = Some ?t'2; run (Suc n) (Some s) execs = Some ?rs2;\n   run (Suc n) (Some ?t'2) execs2 = Some ?rt2;\n   does_not_communicate_with_gateway u execs;\n   \\<forall>v.\n      ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n      vpeq v s ?t'2;\n   current s = current ?t'2; ipurged_relation1 u execs execs2\\<rbrakk>\n  \\<Longrightarrow> iequivalent_states (run (Suc n) (Some s) execs)\n                     (run (Suc n) (Some ?t'2) execs2) u\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t u execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t u execs2.\n           does_not_communicate_with_gateway u (next_execs s execs) \\<and>\n           iequivalent_states\n            (Some (step (next_state s execs) (next_action s execs))) t\n            u \\<and>\n           ipurged_relation1 u (next_execs s execs) execs2 \\<longrightarrow>\n           iequivalent_states\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2) u\\<rbrakk>\n       \\<Longrightarrow> does_not_communicate_with_gateway u execs \\<and>\n                         iequivalent_states (Some s) t u \\<and>\n                         ipurged_relation1 u execs execs2 \\<longrightarrow>\n                         iequivalent_states (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2) u", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Some ?t'2; run (Suc n) (Some s) execs = Some ?rs2;\n   run (Suc n) (Some ?t'2) execs2 = Some ?rt2;\n   does_not_communicate_with_gateway u execs;\n   \\<forall>v.\n      ifp v u \\<and> \\<not> intermediary v u \\<longrightarrow>\n      vpeq v s ?t'2;\n   current s = current ?t'2; ipurged_relation1 u execs execs2\\<rbrakk>\n  \\<Longrightarrow> iequivalent_states (run (Suc n) (Some s) execs)\n                     (run (Suc n) (Some ?t'2) execs2) u\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u execs \\<and>\n    iequivalent_states (Some s) t u \\<and>\n    ipurged_relation1 u execs execs2 \\<longrightarrow>\n    iequivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u", "by(simp add:option.splits,cases t,simp+)"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states (Some s) t u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run (Suc n) (Some s) execs) (run (Suc n) t execs2) u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u execs \\<and>\n  iequivalent_states s t u \\<and>\n  ipurged_relation1 u execs execs2 \\<longrightarrow>\n  iequivalent_states (run n s execs) (run n t execs2) u\n\ngoal (1 subgoal):\n 1. iview_partitioned", "}"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway ?u2 ?execs2 \\<and>\n  iequivalent_states ?s2 ?t2 ?u2 \\<and>\n  ipurged_relation1 ?u2 ?execs2 ?execs2.2 \\<longrightarrow>\n  iequivalent_states (run ?n2 ?s2 ?execs2) (run ?n2 ?t2 ?execs2.2) ?u2\n\ngoal (1 subgoal):\n 1. iview_partitioned", "hence iview_partitioned_inductive: \"\\<forall> u s t execs execs2 n. does_not_communicate_with_gateway u execs \\<and> iequivalent_states s t u \\<and> ipurged_relation1 u execs execs2 \\<longrightarrow> iequivalent_states (run n s execs) (run n t execs2) u\""], ["proof (prove)\nusing this:\n  does_not_communicate_with_gateway ?u2 ?execs2 \\<and>\n  iequivalent_states ?s2 ?t2 ?u2 \\<and>\n  ipurged_relation1 ?u2 ?execs2 ?execs2.2 \\<longrightarrow>\n  iequivalent_states (run ?n2 ?s2 ?execs2) (run ?n2 ?t2 ?execs2.2) ?u2\n\ngoal (1 subgoal):\n 1. \\<forall>u s t execs execs2 n.\n       does_not_communicate_with_gateway u execs \\<and>\n       iequivalent_states s t u \\<and>\n       ipurged_relation1 u execs execs2 \\<longrightarrow>\n       iequivalent_states (run n s execs) (run n t execs2) u", "by blast"], ["proof (state)\nthis:\n  \\<forall>u s t execs execs2 n.\n     does_not_communicate_with_gateway u execs \\<and>\n     iequivalent_states s t u \\<and>\n     ipurged_relation1 u execs execs2 \\<longrightarrow>\n     iequivalent_states (run n s execs) (run n t execs2) u\n\ngoal (1 subgoal):\n 1. iview_partitioned", "have ipurged_relation: \"\\<forall> u execs . ipurged_relation1 u (ipurge_l execs u) (ipurge_r execs u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u execs.\n       ipurged_relation1 u (ipurge_l execs u) (ipurge_r execs u)", "by(unfold ipurged_relation1_def,unfold ipurge_l_def,unfold ipurge_r_def,auto)"], ["proof (state)\nthis:\n  \\<forall>u execs.\n     ipurged_relation1 u (ipurge_l execs u) (ipurge_r execs u)\n\ngoal (1 subgoal):\n 1. iview_partitioned", "{"], ["proof (state)\nthis:\n  \\<forall>u execs.\n     ipurged_relation1 u (ipurge_l execs u) (ipurge_r execs u)\n\ngoal (1 subgoal):\n 1. iview_partitioned", "fix execs s t n u"], ["proof (state)\ngoal (1 subgoal):\n 1. iview_partitioned", "assume 1: \"iequivalent_states s t u\""], ["proof (state)\nthis:\n  iequivalent_states s t u\n\ngoal (1 subgoal):\n 1. iview_partitioned", "from ifp_reflexive"], ["proof (chain)\npicking this:\n  \\<forall>u. ifp u u", "have dir_source: \"\\<forall> u . ifp u u \\<and> \\<not>intermediary u u\""], ["proof (prove)\nusing this:\n  \\<forall>u. ifp u u\n\ngoal (1 subgoal):\n 1. \\<forall>u. ifp u u \\<and> \\<not> intermediary u u", "unfolding intermediary_def"], ["proof (prove)\nusing this:\n  \\<forall>u. ifp u u\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       ifp u u \\<and>\n       (\\<nexists>v.\n           ifp\\<^sup>*\\<^sup>* v u \\<and>\n           ifp u u \\<and> \\<not> ifp v u \\<and> u \\<noteq> u)", "by auto"], ["proof (state)\nthis:\n  \\<forall>u. ifp u u \\<and> \\<not> intermediary u u\n\ngoal (1 subgoal):\n 1. iview_partitioned", "from ipurge_l_removes_gateway_communications"], ["proof (chain)\npicking this:\n  does_not_communicate_with_gateway ?u (ipurge_l ?execs ?u)", "have \"does_not_communicate_with_gateway u (ipurge_l execs u)\""], ["proof (prove)\nusing this:\n  does_not_communicate_with_gateway ?u (ipurge_l ?execs ?u)\n\ngoal (1 subgoal):\n 1. does_not_communicate_with_gateway u (ipurge_l execs u)", "by auto"], ["proof (state)\nthis:\n  does_not_communicate_with_gateway u (ipurge_l execs u)\n\ngoal (1 subgoal):\n 1. iview_partitioned", "from 1 this iview_partitioned_inductive ipurged_relation"], ["proof (chain)\npicking this:\n  iequivalent_states s t u\n  does_not_communicate_with_gateway u (ipurge_l execs u)\n  \\<forall>u s t execs execs2 n.\n     does_not_communicate_with_gateway u execs \\<and>\n     iequivalent_states s t u \\<and>\n     ipurged_relation1 u execs execs2 \\<longrightarrow>\n     iequivalent_states (run n s execs) (run n t execs2) u\n  \\<forall>u execs.\n     ipurged_relation1 u (ipurge_l execs u) (ipurge_r execs u)", "have \"iequivalent_states (run n s (ipurge_l execs u)) (run n t (ipurge_r execs u)) u\""], ["proof (prove)\nusing this:\n  iequivalent_states s t u\n  does_not_communicate_with_gateway u (ipurge_l execs u)\n  \\<forall>u s t execs execs2 n.\n     does_not_communicate_with_gateway u execs \\<and>\n     iequivalent_states s t u \\<and>\n     ipurged_relation1 u execs execs2 \\<longrightarrow>\n     iequivalent_states (run n s execs) (run n t execs2) u\n  \\<forall>u execs.\n     ipurged_relation1 u (ipurge_l execs u) (ipurge_r execs u)\n\ngoal (1 subgoal):\n 1. iequivalent_states (run n s (ipurge_l execs u))\n     (run n t (ipurge_r execs u)) u", "by auto"], ["proof (state)\nthis:\n  iequivalent_states (run n s (ipurge_l execs u))\n   (run n t (ipurge_r execs u)) u\n\ngoal (1 subgoal):\n 1. iview_partitioned", "from this dir_source"], ["proof (chain)\npicking this:\n  iequivalent_states (run n s (ipurge_l execs u))\n   (run n t (ipurge_r execs u)) u\n  \\<forall>u. ifp u u \\<and> \\<not> intermediary u u", "have \"run n s (ipurge_l execs u) \\<parallel> run n t (ipurge_r execs u) \\<rightharpoonup> (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)\""], ["proof (prove)\nusing this:\n  iequivalent_states (run n s (ipurge_l execs u))\n   (run n t (ipurge_r execs u)) u\n  \\<forall>u. ifp u u \\<and> \\<not> intermediary u u\n\ngoal (1 subgoal):\n 1. B2 (run n s (ipurge_l execs u)) (run n t (ipurge_r execs u))\n     (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)", "using r_into_rtranclp"], ["proof (prove)\nusing this:\n  iequivalent_states (run n s (ipurge_l execs u))\n   (run n t (ipurge_r execs u)) u\n  \\<forall>u. ifp u u \\<and> \\<not> intermediary u u\n  ?r ?x ?y \\<Longrightarrow> ?r\\<^sup>*\\<^sup>* ?x ?y\n\ngoal (1 subgoal):\n 1. B2 (run n s (ipurge_l execs u)) (run n t (ipurge_r execs u))\n     (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)", "unfolding B_def"], ["proof (prove)\nusing this:\n  iequivalent_states (run n s (ipurge_l execs u))\n   (run n t (ipurge_r execs u)) u\n  \\<forall>u. ifp u u \\<and> \\<not> intermediary u u\n  ?r ?x ?y \\<Longrightarrow> ?r\\<^sup>*\\<^sup>* ?x ?y\n\ngoal (1 subgoal):\n 1. B2 (run n s (ipurge_l execs u)) (run n t (ipurge_r execs u))\n     (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)", "by(cases \"run n s (ipurge_l execs u)\",simp,cases \"run n t (ipurge_r execs u)\",simp,auto)"], ["proof (state)\nthis:\n  B2 (run n s (ipurge_l execs u)) (run n t (ipurge_r execs u))\n   (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)\n\ngoal (1 subgoal):\n 1. iview_partitioned", "}"], ["proof (state)\nthis:\n  iequivalent_states ?s2 ?t2 ?u2 \\<Longrightarrow>\n  B2 (run ?n2 ?s2 (ipurge_l ?execs2 ?u2))\n   (run ?n2 ?t2 (ipurge_r ?execs2 ?u2))\n   (\\<lambda>rs rt. vpeq ?u2 rs rt \\<and> current rs = current rt)\n\ngoal (1 subgoal):\n 1. iview_partitioned", "thus ?thesis"], ["proof (prove)\nusing this:\n  iequivalent_states ?s2 ?t2 ?u2 \\<Longrightarrow>\n  B2 (run ?n2 ?s2 (ipurge_l ?execs2 ?u2))\n   (run ?n2 ?t2 (ipurge_r ?execs2 ?u2))\n   (\\<lambda>rs rt. vpeq ?u2 rs rt \\<and> current rs = current rt)\n\ngoal (1 subgoal):\n 1. iview_partitioned", "unfolding iview_partitioned_def Let_def"], ["proof (prove)\nusing this:\n  iequivalent_states ?s2 ?t2 ?u2 \\<Longrightarrow>\n  B2 (run ?n2 ?s2 (ipurge_l ?execs2 ?u2))\n   (run ?n2 ?t2 (ipurge_r ?execs2 ?u2))\n   (\\<lambda>rs rt. vpeq ?u2 rs rt \\<and> current rs = current rt)\n\ngoal (1 subgoal):\n 1. \\<forall>execs ms mt n u.\n       iequivalent_states ms mt u \\<longrightarrow>\n       B2 (run n ms (ipurge_l execs u)) (run n mt (ipurge_r execs u))\n        (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)", "by auto"], ["proof (state)\nthis:\n  iview_partitioned\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Returns True iff and only if the two states have the same active domain, \\emph{or} if one of the states is None.\n\\<close>"], ["", "definition mcurrents :: \"'state_t option \\<Rightarrow> 'state_t option \\<Rightarrow> bool\"\n  where \"mcurrents m1 m2 \\<equiv> m1 \\<parallel> m2 \\<rightharpoonup> (\\<lambda> s t . current s = current t)\""], ["", "text \\<open>\n  Proof that switching/interrupts are purely time-based and happen independent of the actions done by the domains.\n  As all theorems in this locale, it holds vacuously whenever one of the states is None, i.e., whenver at some point a precondition does not hold.\n\\<close>"], ["", "lemma current_independent_of_domain_actions:\nassumes current_s_t: \"mcurrents s t\"\n  shows \"mcurrents (run n s execs) (run n t execs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcurrents (run n s execs) (run n t execs2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mcurrents (run n s execs) (run n t execs2)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. mcurrents (run n s execs) (run n t execs2)", "fix n s execs t execs2"], ["proof (state)\ngoal (1 subgoal):\n 1. mcurrents (run n s execs) (run n t execs2)", "have \"mcurrents s t \\<longrightarrow> mcurrents (run n s execs) (run n t execs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcurrents s t \\<longrightarrow>\n    mcurrents (run n s execs) (run n t execs2)", "proof (induct n s execs arbitrary: t execs2 rule: run.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s execs t execs2.\n       mcurrents s t \\<longrightarrow>\n       mcurrents (run 0 s execs) (run 0 t execs2)\n 2. \\<And>n execs t execs2.\n       mcurrents None t \\<longrightarrow>\n       mcurrents (run (Suc n) None execs) (run (Suc n) t execs2)\n 3. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 5. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 6. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "case (1 s execs t execs2)"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>s execs t execs2.\n       mcurrents s t \\<longrightarrow>\n       mcurrents (run 0 s execs) (run 0 t execs2)\n 2. \\<And>n execs t execs2.\n       mcurrents None t \\<longrightarrow>\n       mcurrents (run (Suc n) None execs) (run (Suc n) t execs2)\n 3. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 5. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 6. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "from this"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mcurrents s t \\<longrightarrow>\n    mcurrents (run 0 s execs) (run 0 t execs2)", "using current_s_t"], ["proof (prove)\nusing this:\n  mcurrents s t\n\ngoal (1 subgoal):\n 1. mcurrents s t \\<longrightarrow>\n    mcurrents (run 0 s execs) (run 0 t execs2)", "unfolding B_def"], ["proof (prove)\nusing this:\n  mcurrents s t\n\ngoal (1 subgoal):\n 1. mcurrents s t \\<longrightarrow>\n    mcurrents (run 0 s execs) (run 0 t execs2)", "by auto"], ["proof (state)\nthis:\n  mcurrents s t \\<longrightarrow> mcurrents (run 0 s execs) (run 0 t execs2)\n\ngoal (5 subgoals):\n 1. \\<And>n execs t execs2.\n       mcurrents None t \\<longrightarrow>\n       mcurrents (run (Suc n) None execs) (run (Suc n) t execs2)\n 2. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 5. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n execs t execs2.\n       mcurrents None t \\<longrightarrow>\n       mcurrents (run (Suc n) None execs) (run (Suc n) t execs2)\n 2. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 5. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "case (2 n execs t execs2)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>n execs t execs2.\n       mcurrents None t \\<longrightarrow>\n       mcurrents (run (Suc n) None execs) (run (Suc n) t execs2)\n 2. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 5. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mcurrents None t \\<longrightarrow>\n    mcurrents (run (Suc n) None execs) (run (Suc n) t execs2)", "unfolding mcurrents_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. B2 None t (\\<lambda>s t. current s = current t) \\<longrightarrow>\n    B2 (run (Suc n) None execs) (run (Suc n) t execs2)\n     (\\<lambda>s t. current s = current t)", "by(auto)"], ["proof (state)\nthis:\n  mcurrents None t \\<longrightarrow>\n  mcurrents (run (Suc n) None execs) (run (Suc n) t execs2)\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "case (3 n s execs t execs2)"], ["proof (state)\nthis:\n  interrupt (Suc n)\n  mcurrents (Some (cswitch (Suc n) s)) ?t \\<longrightarrow>\n  mcurrents (run n (Some (cswitch (Suc n) s)) execs) (run n ?t ?execs2.0)\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume interrupt: \"interrupt (Suc n)\""], ["proof (state)\nthis:\n  interrupt (Suc n)\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume IH: \"(\\<And>t execs2. mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow> mcurrents (run n (Some (cswitch (Suc n) s)) execs) (run n t execs2))\""], ["proof (state)\nthis:\n  mcurrents (Some (cswitch (Suc n) s)) ?t \\<longrightarrow>\n  mcurrents (run n (Some (cswitch (Suc n) s)) execs) (run n ?t ?execs2.0)\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "{"], ["proof (state)\nthis:\n  mcurrents (Some (cswitch (Suc n) s)) ?t \\<longrightarrow>\n  mcurrents (run n (Some (cswitch (Suc n) s)) execs) (run n ?t ?execs2.0)\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "fix t'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume t: \"t = (Some t')\""], ["proof (state)\nthis:\n  t = Some t'\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume curr: \"mcurrents (Some s) t\""], ["proof (state)\nthis:\n  mcurrents (Some s) t\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "from t curr cswitch_independent_of_state[THEN spec,THEN spec,THEN spec,where x1=s]"], ["proof (chain)\npicking this:\n  t = Some t'\n  mcurrents (Some s) t\n  current s = current ?x \\<longrightarrow>\n  current (cswitch ?x2 s) = current (cswitch ?x2 ?x)", "have current_ns_nt: \"current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\""], ["proof (prove)\nusing this:\n  t = Some t'\n  mcurrents (Some s) t\n  current s = current ?x \\<longrightarrow>\n  current (cswitch ?x2 s) = current (cswitch ?x2 ?x)\n\ngoal (1 subgoal):\n 1. current (cswitch (Suc n) s) = current (cswitch (Suc n) t')", "unfolding mcurrents_def"], ["proof (prove)\nusing this:\n  t = Some t'\n  B2 (Some s) t (\\<lambda>s t. current s = current t)\n  current s = current ?x \\<longrightarrow>\n  current (cswitch ?x2 s) = current (cswitch ?x2 ?x)\n\ngoal (1 subgoal):\n 1. current (cswitch (Suc n) s) = current (cswitch (Suc n) t')", "by simp"], ["proof (state)\nthis:\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "from current_ns_nt IH[where t=\"Some (cswitch (Suc n) t')\" and ?execs2.0=execs2]"], ["proof (chain)\npicking this:\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  mcurrents (Some (cswitch (Suc n) s))\n   (Some (cswitch (Suc n) t')) \\<longrightarrow>\n  mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2)", "have mcurrents_ns_nt: \"mcurrents (run n (Some (cswitch (Suc n) s)) execs) (run n (Some (cswitch (Suc n) t')) execs2)\""], ["proof (prove)\nusing this:\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  mcurrents (Some (cswitch (Suc n) s))\n   (Some (cswitch (Suc n) t')) \\<longrightarrow>\n  mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2)\n\ngoal (1 subgoal):\n 1. mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n     (run n (Some (cswitch (Suc n) t')) execs2)", "unfolding mcurrents_def"], ["proof (prove)\nusing this:\n  current (cswitch (Suc n) s) = current (cswitch (Suc n) t')\n  B2 (Some (cswitch (Suc n) s)) (Some (cswitch (Suc n) t'))\n   (\\<lambda>s t. current s = current t) \\<longrightarrow>\n  B2 (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2)\n   (\\<lambda>s t. current s = current t)\n\ngoal (1 subgoal):\n 1. B2 (run n (Some (cswitch (Suc n) s)) execs)\n     (run n (Some (cswitch (Suc n) t')) execs2)\n     (\\<lambda>s t. current s = current t)", "by(auto)"], ["proof (state)\nthis:\n  mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2)\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "from mcurrents_ns_nt interrupt t"], ["proof (chain)\npicking this:\n  mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2)\n  interrupt (Suc n)\n  t = Some t'", "have \"mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\""], ["proof (prove)\nusing this:\n  mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n   (run n (Some (cswitch (Suc n) t')) execs2)\n  interrupt (Suc n)\n  t = Some t'\n\ngoal (1 subgoal):\n 1. mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "unfolding mcurrents_def B2_def B_def"], ["proof (prove)\nusing this:\n  case run n (Some (cswitch (Suc n) s)) execs of None \\<Rightarrow> True\n  | Some a \\<Rightarrow>\n      case run n (Some (cswitch (Suc n) t')) execs2 of\n      None \\<Rightarrow> True | Some aa \\<Rightarrow> current a = current aa\n  interrupt (Suc n)\n  t = Some t'\n\ngoal (1 subgoal):\n 1. case run (Suc n) (Some s) execs of None \\<Rightarrow> True\n    | Some a \\<Rightarrow>\n        case run (Suc n) t execs2 of None \\<Rightarrow> True\n        | Some aa \\<Rightarrow> current a = current aa", "by(cases \"run n (Some (cswitch (Suc n) s)) execs\", cases \"run (Suc n) t execs2\",auto)"], ["proof (state)\nthis:\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>t = Some ?t'2; mcurrents (Some s) t\\<rbrakk>\n  \\<Longrightarrow> mcurrents (run (Suc n) (Some s) execs)\n                     (run (Suc n) t execs2)\n\ngoal (4 subgoals):\n 1. \\<And>n s execs t execs2.\n       \\<lbrakk>interrupt (Suc n);\n        \\<And>t execs2.\n           mcurrents (Some (cswitch (Suc n) s)) t \\<longrightarrow>\n           mcurrents (run n (Some (cswitch (Suc n) s)) execs)\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 4. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Some ?t'2; mcurrents (Some s) t\\<rbrakk>\n  \\<Longrightarrow> mcurrents (run (Suc n) (Some s) execs)\n                     (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. mcurrents (Some s) t \\<longrightarrow>\n    mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "unfolding mcurrents_def B2_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Some ?t'2;\n   Some s \\<rightharpoonup>\n   (\\<lambda>a.\n       t \\<rightharpoonup> (\\<lambda>b. current a = current b))\\<rbrakk>\n  \\<Longrightarrow> run (Suc n) (Some s) execs \\<rightharpoonup>\n                    (\\<lambda>a.\n                        run (Suc n) t execs2 \\<rightharpoonup>\n                        (\\<lambda>b. current a = current b))\n\ngoal (1 subgoal):\n 1. Some s \\<rightharpoonup>\n    (\\<lambda>a.\n        t \\<rightharpoonup>\n        (\\<lambda>b. current a = current b)) \\<longrightarrow>\n    run (Suc n) (Some s) execs \\<rightharpoonup>\n    (\\<lambda>a.\n        run (Suc n) t execs2 \\<rightharpoonup>\n        (\\<lambda>b. current a = current b))", "by(cases t,auto)"], ["proof (state)\nthis:\n  mcurrents (Some s) t \\<longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "case (4 n execs s t execs2)"], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n  thread_empty (execs (current s))\n  mcurrents (Some s) ?t \\<longrightarrow>\n  mcurrents (run n (Some s) execs) (run n ?t ?execs2.0)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume not_interrupt: \"\\<not>interrupt (Suc n)\""], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume thread_empty_s: \"thread_empty(execs (current s))\""], ["proof (state)\nthis:\n  thread_empty (execs (current s))\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume IH: \"(\\<And>t execs2. mcurrents (Some s) t \\<longrightarrow> mcurrents (run n (Some s) execs) (run n t execs2))\""], ["proof (state)\nthis:\n  mcurrents (Some s) ?t \\<longrightarrow>\n  mcurrents (run n (Some s) execs) (run n ?t ?execs2.0)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "{"], ["proof (state)\nthis:\n  mcurrents (Some s) ?t \\<longrightarrow>\n  mcurrents (run n (Some s) execs) (run n ?t ?execs2.0)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "fix t'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume t: \"t = (Some t')\""], ["proof (state)\nthis:\n  t = Some t'\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume curr: \"mcurrents (Some s) t\""], ["proof (state)\nthis:\n  mcurrents (Some s) t\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "{"], ["proof (state)\nthis:\n  mcurrents (Some s) t\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume thread_empty_t: \"thread_empty(execs2 (current t'))\""], ["proof (state)\nthis:\n  thread_empty (execs2 (current t'))\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "from t curr not_interrupt thread_empty_s this IH[where ?execs2.0=execs2 and t=\"Some t'\"]"], ["proof (chain)\npicking this:\n  t = Some t'\n  mcurrents (Some s) t\n  \\<not> interrupt (Suc n)\n  thread_empty (execs (current s))\n  thread_empty (execs2 (current t'))\n  mcurrents (Some s) (Some t') \\<longrightarrow>\n  mcurrents (run n (Some s) execs) (run n (Some t') execs2)", "have \"mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\""], ["proof (prove)\nusing this:\n  t = Some t'\n  mcurrents (Some s) t\n  \\<not> interrupt (Suc n)\n  thread_empty (execs (current s))\n  thread_empty (execs2 (current t'))\n  mcurrents (Some s) (Some t') \\<longrightarrow>\n  mcurrents (run n (Some s) execs) (run n (Some t') execs2)\n\ngoal (1 subgoal):\n 1. mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "by auto"], ["proof (state)\nthis:\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "}"], ["proof (state)\nthis:\n  thread_empty (execs2 (current t')) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "moreover"], ["proof (state)\nthis:\n  thread_empty (execs2 (current t')) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "{"], ["proof (state)\nthis:\n  thread_empty (execs2 (current t')) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume not_prec_t: \"\\<not>thread_empty(execs2 (current t')) \\<and> \\<not>precondition (next_state t' execs2) (next_action t' execs2)\""], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "from t this not_interrupt"], ["proof (chain)\npicking this:\n  t = Some t'\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> interrupt (Suc n)", "have \"mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\""], ["proof (prove)\nusing this:\n  t = Some t'\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "unfolding mcurrents_def"], ["proof (prove)\nusing this:\n  t = Some t'\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. B2 (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n     (\\<lambda>s t. current s = current t)", "by (simp add: rewrite_B2_cases)"], ["proof (state)\nthis:\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "}"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "moreover"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "{"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume step_t: \"\\<not>thread_empty(execs2 (current t')) \\<and> precondition (next_state t' execs2) (next_action t' execs2)\""], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "have \"mcurrents (Some s) (Some (step (next_state t' execs2) (next_action t' execs2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcurrents (Some s)\n     (Some (step (next_state t' execs2) (next_action t' execs2)))", "using step_atomicity curr t current_next_state"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  mcurrents (Some s) t\n  t = Some t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. mcurrents (Some s)\n     (Some (step (next_state t' execs2) (next_action t' execs2)))", "unfolding mcurrents_def"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  B2 (Some s) t (\\<lambda>s t. current s = current t)\n  t = Some t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. B2 (Some s) (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (\\<lambda>s t. current s = current t)", "unfolding step_def"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  B2 (Some s) t (\\<lambda>s t. current s = current t)\n  t = Some t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. B2 (Some s)\n     (Some\n       (case next_action t' execs2 of\n        None \\<Rightarrow> next_state t' execs2\n        | Some a \\<Rightarrow> kstep (next_state t' execs2) a))\n     (\\<lambda>s t. current s = current t)", "by (cases \"next_action t' execs2\",auto)"], ["proof (state)\nthis:\n  mcurrents (Some s)\n   (Some (step (next_state t' execs2) (next_action t' execs2)))\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "from t step_t curr not_interrupt thread_empty_s this IH[where ?execs2.0=\"next_execs t' execs2\" and t=\"Some (step (next_state t' execs2) (next_action t' execs2))\"]"], ["proof (chain)\npicking this:\n  t = Some t'\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  precondition (next_state t' execs2) (next_action t' execs2)\n  mcurrents (Some s) t\n  \\<not> interrupt (Suc n)\n  thread_empty (execs (current s))\n  mcurrents (Some s)\n   (Some (step (next_state t' execs2) (next_action t' execs2)))\n  mcurrents (Some s)\n   (Some\n     (step (next_state t' execs2)\n       (next_action t' execs2))) \\<longrightarrow>\n  mcurrents (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))", "have \"mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\""], ["proof (prove)\nusing this:\n  t = Some t'\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  precondition (next_state t' execs2) (next_action t' execs2)\n  mcurrents (Some s) t\n  \\<not> interrupt (Suc n)\n  thread_empty (execs (current s))\n  mcurrents (Some s)\n   (Some (step (next_state t' execs2) (next_action t' execs2)))\n  mcurrents (Some s)\n   (Some\n     (step (next_state t' execs2)\n       (next_action t' execs2))) \\<longrightarrow>\n  mcurrents (run n (Some s) execs)\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n\ngoal (1 subgoal):\n 1. mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "by auto"], ["proof (state)\nthis:\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "}"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  precondition (next_state t' execs2)\n   (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "ultimately"], ["proof (chain)\npicking this:\n  thread_empty (execs2 (current t')) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  precondition (next_state t' execs2)\n   (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "have \"mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\""], ["proof (prove)\nusing this:\n  thread_empty (execs2 (current t')) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  precondition (next_state t' execs2)\n   (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "by blast"], ["proof (state)\nthis:\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>t = Some ?t'2; mcurrents (Some s) t\\<rbrakk>\n  \\<Longrightarrow> mcurrents (run (Suc n) (Some s) execs)\n                     (run (Suc n) t execs2)\n\ngoal (3 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n); thread_empty (execs (current s));\n        \\<And>t execs2.\n           mcurrents (Some s) t \\<longrightarrow>\n           mcurrents (run n (Some s) execs) (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 3. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Some ?t'2; mcurrents (Some s) t\\<rbrakk>\n  \\<Longrightarrow> mcurrents (run (Suc n) (Some s) execs)\n                     (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. mcurrents (Some s) t \\<longrightarrow>\n    mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "unfolding mcurrents_def B2_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Some ?t'2;\n   Some s \\<rightharpoonup>\n   (\\<lambda>a.\n       t \\<rightharpoonup> (\\<lambda>b. current a = current b))\\<rbrakk>\n  \\<Longrightarrow> run (Suc n) (Some s) execs \\<rightharpoonup>\n                    (\\<lambda>a.\n                        run (Suc n) t execs2 \\<rightharpoonup>\n                        (\\<lambda>b. current a = current b))\n\ngoal (1 subgoal):\n 1. Some s \\<rightharpoonup>\n    (\\<lambda>a.\n        t \\<rightharpoonup>\n        (\\<lambda>b. current a = current b)) \\<longrightarrow>\n    run (Suc n) (Some s) execs \\<rightharpoonup>\n    (\\<lambda>a.\n        run (Suc n) t execs2 \\<rightharpoonup>\n        (\\<lambda>b. current a = current b))", "by(cases t,auto)"], ["proof (state)\nthis:\n  mcurrents (Some s) t \\<longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "case (5 n execs s t execs2)"], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  \\<not> precondition (next_state s execs) (next_action s execs)\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume not_interrupt_s: \"\\<not>interrupt (Suc n)\""], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume thread_not_empty_s: \"\\<not>thread_empty(execs (current s))\""], ["proof (state)\nthis:\n  \\<not> thread_empty (execs (current s))\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume not_prec_s: \"\\<not> precondition (next_state s execs) (next_action s execs)\""], ["proof (state)\nthis:\n  \\<not> precondition (next_state s execs) (next_action s execs)\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "hence \"run (Suc n) (Some s) execs = None\""], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state s execs) (next_action s execs)\n\ngoal (1 subgoal):\n 1. run (Suc n) (Some s) execs = None", "using not_interrupt_s thread_not_empty_s"], ["proof (prove)\nusing this:\n  \\<not> precondition (next_state s execs) (next_action s execs)\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. run (Suc n) (Some s) execs = None", "by simp"], ["proof (state)\nthis:\n  run (Suc n) (Some s) execs = None\n\ngoal (2 subgoals):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        \\<not> precondition (next_state s execs)\n                (next_action s execs)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)\n 2. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "thus ?case"], ["proof (prove)\nusing this:\n  run (Suc n) (Some s) execs = None\n\ngoal (1 subgoal):\n 1. mcurrents (Some s) t \\<longrightarrow>\n    mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "unfolding mcurrents_def"], ["proof (prove)\nusing this:\n  run (Suc n) (Some s) execs = None\n\ngoal (1 subgoal):\n 1. B2 (Some s) t (\\<lambda>s t. current s = current t) \\<longrightarrow>\n    B2 (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n     (\\<lambda>s t. current s = current t)", "by(simp add:option.splits)"], ["proof (state)\nthis:\n  mcurrents (Some s) t \\<longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "case (6 n execs s t execs2)"], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  mcurrents (Some (step (next_state s execs) (next_action s execs)))\n   ?t \\<longrightarrow>\n  mcurrents\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n ?t ?execs2.0)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume not_interrupt: \"\\<not>interrupt (Suc n)\""], ["proof (state)\nthis:\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume thread_not_empty_s: \"\\<not>thread_empty(execs (current s))\""], ["proof (state)\nthis:\n  \\<not> thread_empty (execs (current s))\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume prec_s: \"precondition (next_state s execs) (next_action s execs)\""], ["proof (state)\nthis:\n  precondition (next_state s execs) (next_action s execs)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume IH: \"(\\<And>t execs2.\n           mcurrents (Some (step (next_state s execs) (next_action s execs))) t \\<longrightarrow>\n           mcurrents (run n (Some (step (next_state s execs) (next_action s execs))) (next_execs s execs)) (run n t execs2))\""], ["proof (state)\nthis:\n  mcurrents (Some (step (next_state s execs) (next_action s execs)))\n   ?t \\<longrightarrow>\n  mcurrents\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n ?t ?execs2.0)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "{"], ["proof (state)\nthis:\n  mcurrents (Some (step (next_state s execs) (next_action s execs)))\n   ?t \\<longrightarrow>\n  mcurrents\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n ?t ?execs2.0)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "fix t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume t: \"t = (Some t')\""], ["proof (state)\nthis:\n  t = Some t'\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume curr: \"mcurrents (Some s) t\""], ["proof (state)\nthis:\n  mcurrents (Some s) t\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "{"], ["proof (state)\nthis:\n  mcurrents (Some s) t\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume thread_empty_t: \"thread_empty(execs2 (current t'))\""], ["proof (state)\nthis:\n  thread_empty (execs2 (current t'))\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "have \"mcurrents (Some (step (next_state s execs) (next_action s execs))) (Some t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcurrents (Some (step (next_state s execs) (next_action s execs)))\n     (Some t')", "using step_atomicity curr t current_next_state"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  mcurrents (Some s) t\n  t = Some t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. mcurrents (Some (step (next_state s execs) (next_action s execs)))\n     (Some t')", "unfolding mcurrents_def"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  B2 (Some s) t (\\<lambda>s t. current s = current t)\n  t = Some t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. B2 (Some (step (next_state s execs) (next_action s execs))) (Some t')\n     (\\<lambda>s t. current s = current t)", "unfolding step_def"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  B2 (Some s) t (\\<lambda>s t. current s = current t)\n  t = Some t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. B2 (Some\n         (case next_action s execs of None \\<Rightarrow> next_state s execs\n          | Some a \\<Rightarrow> kstep (next_state s execs) a))\n     (Some t') (\\<lambda>s t. current s = current t)", "by (cases \"next_action s execs\",auto)"], ["proof (state)\nthis:\n  mcurrents (Some (step (next_state s execs) (next_action s execs)))\n   (Some t')\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "from t curr not_interrupt thread_not_empty_s prec_s thread_empty_t this IH[where ?execs2.0=execs2 and t=\"Some t'\"]"], ["proof (chain)\npicking this:\n  t = Some t'\n  mcurrents (Some s) t\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  thread_empty (execs2 (current t'))\n  mcurrents (Some (step (next_state s execs) (next_action s execs)))\n   (Some t')\n  mcurrents (Some (step (next_state s execs) (next_action s execs)))\n   (Some t') \\<longrightarrow>\n  mcurrents\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2)", "have \"mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\""], ["proof (prove)\nusing this:\n  t = Some t'\n  mcurrents (Some s) t\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  thread_empty (execs2 (current t'))\n  mcurrents (Some (step (next_state s execs) (next_action s execs)))\n   (Some t')\n  mcurrents (Some (step (next_state s execs) (next_action s execs)))\n   (Some t') \\<longrightarrow>\n  mcurrents\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some t') execs2)\n\ngoal (1 subgoal):\n 1. mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "by auto"], ["proof (state)\nthis:\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "}"], ["proof (state)\nthis:\n  thread_empty (execs2 (current t')) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "moreover"], ["proof (state)\nthis:\n  thread_empty (execs2 (current t')) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "{"], ["proof (state)\nthis:\n  thread_empty (execs2 (current t')) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume not_prec_t: \"\\<not>thread_empty(execs2 (current t')) \\<and> \\<not>precondition (next_state t' execs2) (next_action t' execs2)\""], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "from t this not_interrupt"], ["proof (chain)\npicking this:\n  t = Some t'\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> interrupt (Suc n)", "have \"mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\""], ["proof (prove)\nusing this:\n  t = Some t'\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "unfolding mcurrents_def B2_def"], ["proof (prove)\nusing this:\n  t = Some t'\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2) (next_action t' execs2)\n  \\<not> interrupt (Suc n)\n\ngoal (1 subgoal):\n 1. run (Suc n) (Some s) execs \\<rightharpoonup>\n    (\\<lambda>a.\n        run (Suc n) t execs2 \\<rightharpoonup>\n        (\\<lambda>b. current a = current b))", "by (auto)"], ["proof (state)\nthis:\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "}"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "moreover"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "{"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "assume step_t: \"\\<not>thread_empty(execs2 (current t')) \\<and> precondition (next_state t' execs2) (next_action t' execs2)\""], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  precondition (next_state t' execs2) (next_action t' execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "have \"mcurrents (Some (step (next_state s execs) (next_action s execs))) (Some (step (next_state t' execs2) (next_action t' execs2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcurrents (Some (step (next_state s execs) (next_action s execs)))\n     (Some (step (next_state t' execs2) (next_action t' execs2)))", "using step_atomicity curr t current_next_state"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  mcurrents (Some s) t\n  t = Some t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. mcurrents (Some (step (next_state s execs) (next_action s execs)))\n     (Some (step (next_state t' execs2) (next_action t' execs2)))", "unfolding mcurrents_def"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  B2 (Some s) t (\\<lambda>s t. current s = current t)\n  t = Some t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. B2 (Some (step (next_state s execs) (next_action s execs)))\n     (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (\\<lambda>s t. current s = current t)", "unfolding step_def"], ["proof (prove)\nusing this:\n  \\<forall>s a. current (kstep s a) = current s\n  B2 (Some s) t (\\<lambda>s t. current s = current t)\n  t = Some t'\n  \\<forall>s execs. current (next_state s execs) = current s\n\ngoal (1 subgoal):\n 1. B2 (Some\n         (case next_action s execs of None \\<Rightarrow> next_state s execs\n          | Some a \\<Rightarrow> kstep (next_state s execs) a))\n     (Some\n       (case next_action t' execs2 of\n        None \\<Rightarrow> next_state t' execs2\n        | Some a \\<Rightarrow> kstep (next_state t' execs2) a))\n     (\\<lambda>s t. current s = current t)", "by (cases \"next_action s execs\",simp,cases \"next_action t' execs2\",simp,simp,cases \"next_action t' execs2\",simp,simp)"], ["proof (state)\nthis:\n  mcurrents (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2)))\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "from current_next_state t step_t curr not_interrupt thread_not_empty_s prec_s this IH[where ?execs2.0=\"next_execs t' execs2\" and t=\"Some (step (next_state t' execs2) (next_action t' execs2))\"]"], ["proof (chain)\npicking this:\n  \\<forall>s execs. current (next_state s execs) = current s\n  t = Some t'\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  precondition (next_state t' execs2) (next_action t' execs2)\n  mcurrents (Some s) t\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  mcurrents (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2)))\n  mcurrents (Some (step (next_state s execs) (next_action s execs)))\n   (Some\n     (step (next_state t' execs2)\n       (next_action t' execs2))) \\<longrightarrow>\n  mcurrents\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))", "have \"mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\""], ["proof (prove)\nusing this:\n  \\<forall>s execs. current (next_state s execs) = current s\n  t = Some t'\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  precondition (next_state t' execs2) (next_action t' execs2)\n  mcurrents (Some s) t\n  \\<not> interrupt (Suc n)\n  \\<not> thread_empty (execs (current s))\n  precondition (next_state s execs) (next_action s execs)\n  mcurrents (Some (step (next_state s execs) (next_action s execs)))\n   (Some (step (next_state t' execs2) (next_action t' execs2)))\n  mcurrents (Some (step (next_state s execs) (next_action s execs)))\n   (Some\n     (step (next_state t' execs2)\n       (next_action t' execs2))) \\<longrightarrow>\n  mcurrents\n   (run n (Some (step (next_state s execs) (next_action s execs)))\n     (next_execs s execs))\n   (run n (Some (step (next_state t' execs2) (next_action t' execs2)))\n     (next_execs t' execs2))\n\ngoal (1 subgoal):\n 1. mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "by auto"], ["proof (state)\nthis:\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "}"], ["proof (state)\nthis:\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  precondition (next_state t' execs2)\n   (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "ultimately"], ["proof (chain)\npicking this:\n  thread_empty (execs2 (current t')) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  precondition (next_state t' execs2)\n   (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "have \"mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\""], ["proof (prove)\nusing this:\n  thread_empty (execs2 (current t')) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  \\<not> precondition (next_state t' execs2)\n          (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n  \\<not> thread_empty (execs2 (current t')) \\<and>\n  precondition (next_state t' execs2)\n   (next_action t' execs2) \\<Longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "by blast"], ["proof (state)\nthis:\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>t = Some ?t'2; mcurrents (Some s) t\\<rbrakk>\n  \\<Longrightarrow> mcurrents (run (Suc n) (Some s) execs)\n                     (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. \\<And>n execs s t execs2.\n       \\<lbrakk>\\<not> interrupt (Suc n);\n        \\<not> thread_empty (execs (current s));\n        precondition (next_state s execs) (next_action s execs);\n        \\<And>t execs2.\n           mcurrents\n            (Some (step (next_state s execs) (next_action s execs)))\n            t \\<longrightarrow>\n           mcurrents\n            (run n (Some (step (next_state s execs) (next_action s execs)))\n              (next_execs s execs))\n            (run n t execs2)\\<rbrakk>\n       \\<Longrightarrow> mcurrents (Some s) t \\<longrightarrow>\n                         mcurrents (run (Suc n) (Some s) execs)\n                          (run (Suc n) t execs2)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Some ?t'2; mcurrents (Some s) t\\<rbrakk>\n  \\<Longrightarrow> mcurrents (run (Suc n) (Some s) execs)\n                     (run (Suc n) t execs2)\n\ngoal (1 subgoal):\n 1. mcurrents (Some s) t \\<longrightarrow>\n    mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)", "unfolding mcurrents_def B2_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Some ?t'2;\n   Some s \\<rightharpoonup>\n   (\\<lambda>a.\n       t \\<rightharpoonup> (\\<lambda>b. current a = current b))\\<rbrakk>\n  \\<Longrightarrow> run (Suc n) (Some s) execs \\<rightharpoonup>\n                    (\\<lambda>a.\n                        run (Suc n) t execs2 \\<rightharpoonup>\n                        (\\<lambda>b. current a = current b))\n\ngoal (1 subgoal):\n 1. Some s \\<rightharpoonup>\n    (\\<lambda>a.\n        t \\<rightharpoonup>\n        (\\<lambda>b. current a = current b)) \\<longrightarrow>\n    run (Suc n) (Some s) execs \\<rightharpoonup>\n    (\\<lambda>a.\n        run (Suc n) t execs2 \\<rightharpoonup>\n        (\\<lambda>b. current a = current b))", "by(cases t,auto)"], ["proof (state)\nthis:\n  mcurrents (Some s) t \\<longrightarrow>\n  mcurrents (run (Suc n) (Some s) execs) (run (Suc n) t execs2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mcurrents s t \\<longrightarrow> mcurrents (run n s execs) (run n t execs2)\n\ngoal (1 subgoal):\n 1. mcurrents (run n s execs) (run n t execs2)", "}"], ["proof (state)\nthis:\n  mcurrents ?sa2 ?ta2 \\<longrightarrow>\n  mcurrents (run ?na2 ?sa2 ?execsa2) (run ?na2 ?ta2 ?execs2a2)\n\ngoal (1 subgoal):\n 1. mcurrents (run n s execs) (run n t execs2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mcurrents ?sa2 ?ta2 \\<longrightarrow>\n  mcurrents (run ?na2 ?sa2 ?execsa2) (run ?na2 ?ta2 ?execs2a2)\n\ngoal (1 subgoal):\n 1. mcurrents (run n s execs) (run n t execs2)", "using current_s_t"], ["proof (prove)\nusing this:\n  mcurrents ?sa2 ?ta2 \\<longrightarrow>\n  mcurrents (run ?na2 ?sa2 ?execsa2) (run ?na2 ?ta2 ?execs2a2)\n  mcurrents s t\n\ngoal (1 subgoal):\n 1. mcurrents (run n s execs) (run n t execs2)", "by auto"], ["proof (state)\nthis:\n  mcurrents (run n s execs) (run n t execs2)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem unwinding_implies_NI_indirect_sources: \nshows NI_indirect_sources"], ["proof (prove)\ngoal (1 subgoal):\n 1. NI_indirect_sources", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. NI_indirect_sources", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. NI_indirect_sources", "fix execs a n"], ["proof (state)\ngoal (1 subgoal):\n 1. NI_indirect_sources", "from iunwinding_implies_view_partitioned1"], ["proof (chain)\npicking this:\n  iview_partitioned", "have vp: iview_partitioned"], ["proof (prove)\nusing this:\n  iview_partitioned\n\ngoal (1 subgoal):\n 1. iview_partitioned", "by blast"], ["proof (state)\nthis:\n  iview_partitioned\n\ngoal (1 subgoal):\n 1. NI_indirect_sources", "from vp and vpeq_reflexive"], ["proof (chain)\npicking this:\n  iview_partitioned\n  \\<forall>a u. vpeq u a a", "have 1: \"\\<forall> u . run n (Some s0) (ipurge_l execs u) \\<parallel> run n (Some s0) (ipurge_r execs u)  \\<rightharpoonup> (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)\""], ["proof (prove)\nusing this:\n  iview_partitioned\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       B2 (run n (Some s0) (ipurge_l execs u))\n        (run n (Some s0) (ipurge_r execs u))\n        (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)", "unfolding iview_partitioned_def"], ["proof (prove)\nusing this:\n  \\<forall>execs ms mt n u.\n     iequivalent_states ms mt u \\<longrightarrow>\n     B2 (run n ms (ipurge_l execs u)) (run n mt (ipurge_r execs u))\n      (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)\n  \\<forall>a u. vpeq u a a\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       B2 (run n (Some s0) (ipurge_l execs u))\n        (run n (Some s0) (ipurge_r execs u))\n        (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)", "by auto"], ["proof (state)\nthis:\n  \\<forall>u.\n     B2 (run n (Some s0) (ipurge_l execs u))\n      (run n (Some s0) (ipurge_r execs u))\n      (\\<lambda>rs rt. vpeq u rs rt \\<and> current rs = current rt)\n\ngoal (1 subgoal):\n 1. NI_indirect_sources", "have \"run n (Some s0) execs \\<rightharpoonup> (\\<lambda>s_f. run n (Some s0) (ipurge_l execs (current s_f))  \\<parallel>\n                                           run n (Some s0) (ipurge_r execs (current s_f)) \\<rightharpoonup>\n                                           (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n         (run n (Some s0) (ipurge_r execs (current s_f)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "proof(cases \"run n (Some s0) execs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. run n (Some s0) execs = None \\<Longrightarrow>\n    run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n         (run n (Some s0) (ipurge_r execs (current s_f)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))\n 2. \\<And>aa.\n       run n (Some s0) execs = Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "case None"], ["proof (state)\nthis:\n  run n (Some s0) execs = None\n\ngoal (2 subgoals):\n 1. run n (Some s0) execs = None \\<Longrightarrow>\n    run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n         (run n (Some s0) (ipurge_r execs (current s_f)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))\n 2. \\<And>aa.\n       run n (Some s0) execs = Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = None\n\ngoal (1 subgoal):\n 1. run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n         (run n (Some s0) (ipurge_r execs (current s_f)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "unfolding B_def"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = None\n\ngoal (1 subgoal):\n 1. case run n (Some s0) execs of None \\<Rightarrow> True\n    | Some aa \\<Rightarrow>\n        B2 (run n (Some s0) (ipurge_l execs (current aa)))\n         (run n (Some s0) (ipurge_r execs (current aa)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a)", "by simp"], ["proof (state)\nthis:\n  run n (Some s0) execs \\<rightharpoonup>\n  (\\<lambda>s_f.\n      B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n       (run n (Some s0) (ipurge_r execs (current s_f)))\n       (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       run n (Some s0) execs = Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       run n (Some s0) execs = Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "case (Some s_f)"], ["proof (state)\nthis:\n  run n (Some s0) execs = Some s_f\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       run n (Some s0) execs = Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some s_f\n\ngoal (1 subgoal):\n 1. run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n         (run n (Some s0) (ipurge_r execs (current s_f)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "proof(cases \"run n (Some s0) (ipurge_l execs (current s_f))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>run n (Some s0) execs = Some s_f;\n     run n (Some s0) (ipurge_l execs (current s_f)) = None\\<rbrakk>\n    \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                      (\\<lambda>s_f.\n                          B2 (run n (Some s0)\n                               (ipurge_l execs (current s_f)))\n                           (run n (Some s0) (ipurge_r execs (current s_f)))\n                           (\\<lambda>s_l s_r.\n                               output_f s_l a = output_f s_r a))\n 2. \\<And>aa.\n       \\<lbrakk>run n (Some s0) execs = Some s_f;\n        run n (Some s0) (ipurge_l execs (current s_f)) = Some aa\\<rbrakk>\n       \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                         (\\<lambda>s_f.\n                             B2 (run n (Some s0)\n                                  (ipurge_l execs (current s_f)))\n                              (run n (Some s0)\n                                (ipurge_r execs (current s_f)))\n                              (\\<lambda>s_l s_r.\n                                  output_f s_l a = output_f s_r a))", "case None"], ["proof (state)\nthis:\n  run n (Some s0) (ipurge_l execs (current s_f)) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>run n (Some s0) execs = Some s_f;\n     run n (Some s0) (ipurge_l execs (current s_f)) = None\\<rbrakk>\n    \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                      (\\<lambda>s_f.\n                          B2 (run n (Some s0)\n                               (ipurge_l execs (current s_f)))\n                           (run n (Some s0) (ipurge_r execs (current s_f)))\n                           (\\<lambda>s_l s_r.\n                               output_f s_l a = output_f s_r a))\n 2. \\<And>aa.\n       \\<lbrakk>run n (Some s0) execs = Some s_f;\n        run n (Some s0) (ipurge_l execs (current s_f)) = Some aa\\<rbrakk>\n       \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                         (\\<lambda>s_f.\n                             B2 (run n (Some s0)\n                                  (ipurge_l execs (current s_f)))\n                              (run n (Some s0)\n                                (ipurge_r execs (current s_f)))\n                              (\\<lambda>s_l s_r.\n                                  output_f s_l a = output_f s_r a))", "from Some this"], ["proof (chain)\npicking this:\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = None\n\ngoal (1 subgoal):\n 1. run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n         (run n (Some s0) (ipurge_r execs (current s_f)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "unfolding B_def"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = None\n\ngoal (1 subgoal):\n 1. case run n (Some s0) execs of None \\<Rightarrow> True\n    | Some aa \\<Rightarrow>\n        B2 (run n (Some s0) (ipurge_l execs (current aa)))\n         (run n (Some s0) (ipurge_r execs (current aa)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a)", "by simp"], ["proof (state)\nthis:\n  run n (Some s0) execs \\<rightharpoonup>\n  (\\<lambda>s_f.\n      B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n       (run n (Some s0) (ipurge_r execs (current s_f)))\n       (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>run n (Some s0) execs = Some s_f;\n        run n (Some s0) (ipurge_l execs (current s_f)) = Some aa\\<rbrakk>\n       \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                         (\\<lambda>s_f.\n                             B2 (run n (Some s0)\n                                  (ipurge_l execs (current s_f)))\n                              (run n (Some s0)\n                                (ipurge_r execs (current s_f)))\n                              (\\<lambda>s_l s_r.\n                                  output_f s_l a = output_f s_r a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>run n (Some s0) execs = Some s_f;\n        run n (Some s0) (ipurge_l execs (current s_f)) = Some aa\\<rbrakk>\n       \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                         (\\<lambda>s_f.\n                             B2 (run n (Some s0)\n                                  (ipurge_l execs (current s_f)))\n                              (run n (Some s0)\n                                (ipurge_r execs (current s_f)))\n                              (\\<lambda>s_l s_r.\n                                  output_f s_l a = output_f s_r a))", "case (Some s_ipurge_l)"], ["proof (state)\nthis:\n  run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>run n (Some s0) execs = Some s_f;\n        run n (Some s0) (ipurge_l execs (current s_f)) = Some aa\\<rbrakk>\n       \\<Longrightarrow> run n (Some s0) execs \\<rightharpoonup>\n                         (\\<lambda>s_f.\n                             B2 (run n (Some s0)\n                                  (ipurge_l execs (current s_f)))\n                              (run n (Some s0)\n                                (ipurge_r execs (current s_f)))\n                              (\\<lambda>s_l s_r.\n                                  output_f s_l a = output_f s_r a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n         (run n (Some s0) (ipurge_r execs (current s_f)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "proof(cases \"run n (Some s0) (ipurge_r execs (current s_f))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. run n (Some s0) (ipurge_r execs (current s_f)) = None \\<Longrightarrow>\n    run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n         (run n (Some s0) (ipurge_r execs (current s_f)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))\n 2. \\<And>aa.\n       run n (Some s0) (ipurge_r execs (current s_f)) =\n       Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "case None"], ["proof (state)\nthis:\n  run n (Some s0) (ipurge_r execs (current s_f)) = None\n\ngoal (2 subgoals):\n 1. run n (Some s0) (ipurge_r execs (current s_f)) = None \\<Longrightarrow>\n    run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n         (run n (Some s0) (ipurge_r execs (current s_f)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))\n 2. \\<And>aa.\n       run n (Some s0) (ipurge_r execs (current s_f)) =\n       Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "from \\<open>run n (Some s0) execs = Some s_f\\<close> Some this"], ["proof (chain)\npicking this:\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\n  run n (Some s0) (ipurge_r execs (current s_f)) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\n  run n (Some s0) (ipurge_r execs (current s_f)) = None\n\ngoal (1 subgoal):\n 1. run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n         (run n (Some s0) (ipurge_r execs (current s_f)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "unfolding B_def"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\n  run n (Some s0) (ipurge_r execs (current s_f)) = None\n\ngoal (1 subgoal):\n 1. case run n (Some s0) execs of None \\<Rightarrow> True\n    | Some aa \\<Rightarrow>\n        B2 (run n (Some s0) (ipurge_l execs (current aa)))\n         (run n (Some s0) (ipurge_r execs (current aa)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a)", "by simp"], ["proof (state)\nthis:\n  run n (Some s0) execs \\<rightharpoonup>\n  (\\<lambda>s_f.\n      B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n       (run n (Some s0) (ipurge_r execs (current s_f)))\n       (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       run n (Some s0) (ipurge_r execs (current s_f)) =\n       Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       run n (Some s0) (ipurge_r execs (current s_f)) =\n       Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "case (Some s_ipurge_r)"], ["proof (state)\nthis:\n  run n (Some s0) (ipurge_r execs (current s_f)) = Some s_ipurge_r\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       run n (Some s0) (ipurge_r execs (current s_f)) =\n       Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "from cswitch_independent_of_state\n                \\<open>run n (Some s0) execs = Some s_f\\<close> \\<open>run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\\<close>\n                current_independent_of_domain_actions[where n=n and s=\"Some s0\" and t=\"Some s0\" and execs=execs and ?execs2.0=\"(ipurge_l execs (current s_f))\"]"], ["proof (chain)\npicking this:\n  \\<forall>n s t.\n     current s = current t \\<longrightarrow>\n     current (cswitch n s) = current (cswitch n t)\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\n  mcurrents (Some s0) (Some s0) \\<Longrightarrow>\n  mcurrents (run n (Some s0) execs)\n   (run n (Some s0) (ipurge_l execs (current s_f)))", "have 2: \"current s_ipurge_l = current s_f\""], ["proof (prove)\nusing this:\n  \\<forall>n s t.\n     current s = current t \\<longrightarrow>\n     current (cswitch n s) = current (cswitch n t)\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\n  mcurrents (Some s0) (Some s0) \\<Longrightarrow>\n  mcurrents (run n (Some s0) execs)\n   (run n (Some s0) (ipurge_l execs (current s_f)))\n\ngoal (1 subgoal):\n 1. current s_ipurge_l = current s_f", "unfolding mcurrents_def B_def"], ["proof (prove)\nusing this:\n  \\<forall>n s t.\n     current s = current t \\<longrightarrow>\n     current (cswitch n s) = current (cswitch n t)\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\n  B2 (Some s0) (Some s0)\n   (\\<lambda>s t. current s = current t) \\<Longrightarrow>\n  B2 (run n (Some s0) execs)\n   (run n (Some s0) (ipurge_l execs (current s_f)))\n   (\\<lambda>s t. current s = current t)\n\ngoal (1 subgoal):\n 1. current s_ipurge_l = current s_f", "by auto"], ["proof (state)\nthis:\n  current s_ipurge_l = current s_f\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       run n (Some s0) (ipurge_r execs (current s_f)) =\n       Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "from \\<open>run n (Some s0) execs = Some s_f\\<close>  \\<open>run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\\<close>\n                Some 1[THEN spec,where x=\"current s_f\"]"], ["proof (chain)\npicking this:\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\n  run n (Some s0) (ipurge_r execs (current s_f)) = Some s_ipurge_r\n  B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n   (run n (Some s0) (ipurge_r execs (current s_f)))\n   (\\<lambda>rs rt. vpeq (current s_f) rs rt \\<and> current rs = current rt)", "have \"vpeq (current s_f) s_ipurge_l s_ipurge_r \\<and> current s_ipurge_l = current s_ipurge_r\""], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\n  run n (Some s0) (ipurge_r execs (current s_f)) = Some s_ipurge_r\n  B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n   (run n (Some s0) (ipurge_r execs (current s_f)))\n   (\\<lambda>rs rt. vpeq (current s_f) rs rt \\<and> current rs = current rt)\n\ngoal (1 subgoal):\n 1. vpeq (current s_f) s_ipurge_l s_ipurge_r \\<and>\n    current s_ipurge_l = current s_ipurge_r", "unfolding B_def"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\n  run n (Some s0) (ipurge_r execs (current s_f)) = Some s_ipurge_r\n  B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n   (run n (Some s0) (ipurge_r execs (current s_f)))\n   (\\<lambda>rs rt. vpeq (current s_f) rs rt \\<and> current rs = current rt)\n\ngoal (1 subgoal):\n 1. vpeq (current s_f) s_ipurge_l s_ipurge_r \\<and>\n    current s_ipurge_l = current s_ipurge_r", "by auto"], ["proof (state)\nthis:\n  vpeq (current s_f) s_ipurge_l s_ipurge_r \\<and>\n  current s_ipurge_l = current s_ipurge_r\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       run n (Some s0) (ipurge_r execs (current s_f)) =\n       Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "from this 2"], ["proof (chain)\npicking this:\n  vpeq (current s_f) s_ipurge_l s_ipurge_r \\<and>\n  current s_ipurge_l = current s_ipurge_r\n  current s_ipurge_l = current s_f", "have \"output_f s_ipurge_l a = output_f s_ipurge_r a\""], ["proof (prove)\nusing this:\n  vpeq (current s_f) s_ipurge_l s_ipurge_r \\<and>\n  current s_ipurge_l = current s_ipurge_r\n  current s_ipurge_l = current s_f\n\ngoal (1 subgoal):\n 1. output_f s_ipurge_l a = output_f s_ipurge_r a", "using output_consistent"], ["proof (prove)\nusing this:\n  vpeq (current s_f) s_ipurge_l s_ipurge_r \\<and>\n  current s_ipurge_l = current s_ipurge_r\n  current s_ipurge_l = current s_f\n  \\<forall>a s t.\n     vpeq (current s) s t \\<and> current s = current t \\<longrightarrow>\n     output_f s a = output_f t a\n\ngoal (1 subgoal):\n 1. output_f s_ipurge_l a = output_f s_ipurge_r a", "by auto"], ["proof (state)\nthis:\n  output_f s_ipurge_l a = output_f s_ipurge_r a\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       run n (Some s0) (ipurge_r execs (current s_f)) =\n       Some aa \\<Longrightarrow>\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "from \\<open>run n (Some s0) execs = Some s_f\\<close>  \\<open>run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\\<close>\n                this Some"], ["proof (chain)\npicking this:\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\n  output_f s_ipurge_l a = output_f s_ipurge_r a\n  run n (Some s0) (ipurge_r execs (current s_f)) = Some s_ipurge_r", "show ?thesis"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\n  output_f s_ipurge_l a = output_f s_ipurge_r a\n  run n (Some s0) (ipurge_r execs (current s_f)) = Some s_ipurge_r\n\ngoal (1 subgoal):\n 1. run n (Some s0) execs \\<rightharpoonup>\n    (\\<lambda>s_f.\n        B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n         (run n (Some s0) (ipurge_r execs (current s_f)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "unfolding B_def"], ["proof (prove)\nusing this:\n  run n (Some s0) execs = Some s_f\n  run n (Some s0) (ipurge_l execs (current s_f)) = Some s_ipurge_l\n  output_f s_ipurge_l a = output_f s_ipurge_r a\n  run n (Some s0) (ipurge_r execs (current s_f)) = Some s_ipurge_r\n\ngoal (1 subgoal):\n 1. case run n (Some s0) execs of None \\<Rightarrow> True\n    | Some aa \\<Rightarrow>\n        B2 (run n (Some s0) (ipurge_l execs (current aa)))\n         (run n (Some s0) (ipurge_r execs (current aa)))\n         (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a)", "by auto"], ["proof (state)\nthis:\n  run n (Some s0) execs \\<rightharpoonup>\n  (\\<lambda>s_f.\n      B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n       (run n (Some s0) (ipurge_r execs (current s_f)))\n       (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  run n (Some s0) execs \\<rightharpoonup>\n  (\\<lambda>s_f.\n      B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n       (run n (Some s0) (ipurge_r execs (current s_f)))\n       (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  run n (Some s0) execs \\<rightharpoonup>\n  (\\<lambda>s_f.\n      B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n       (run n (Some s0) (ipurge_r execs (current s_f)))\n       (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  run n (Some s0) execs \\<rightharpoonup>\n  (\\<lambda>s_f.\n      B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n       (run n (Some s0) (ipurge_r execs (current s_f)))\n       (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))\n\ngoal (1 subgoal):\n 1. NI_indirect_sources", "}"], ["proof (state)\nthis:\n  run ?n2 (Some s0) ?execs2 \\<rightharpoonup>\n  (\\<lambda>s_f.\n      B2 (run ?n2 (Some s0) (ipurge_l ?execs2 (current s_f)))\n       (run ?n2 (Some s0) (ipurge_r ?execs2 (current s_f)))\n       (\\<lambda>s_l s_r. output_f s_l ?a2 = output_f s_r ?a2))\n\ngoal (1 subgoal):\n 1. NI_indirect_sources", "thus ?thesis"], ["proof (prove)\nusing this:\n  run ?n2 (Some s0) ?execs2 \\<rightharpoonup>\n  (\\<lambda>s_f.\n      B2 (run ?n2 (Some s0) (ipurge_l ?execs2 (current s_f)))\n       (run ?n2 (Some s0) (ipurge_r ?execs2 (current s_f)))\n       (\\<lambda>s_l s_r. output_f s_l ?a2 = output_f s_r ?a2))\n\ngoal (1 subgoal):\n 1. NI_indirect_sources", "unfolding NI_indirect_sources_def"], ["proof (prove)\nusing this:\n  run ?n2 (Some s0) ?execs2 \\<rightharpoonup>\n  (\\<lambda>s_f.\n      B2 (run ?n2 (Some s0) (ipurge_l ?execs2 (current s_f)))\n       (run ?n2 (Some s0) (ipurge_r ?execs2 (current s_f)))\n       (\\<lambda>s_l s_r. output_f s_l ?a2 = output_f s_r ?a2))\n\ngoal (1 subgoal):\n 1. \\<forall>execs a n.\n       run n (Some s0) execs \\<rightharpoonup>\n       (\\<lambda>s_f.\n           B2 (run n (Some s0) (ipurge_l execs (current s_f)))\n            (run n (Some s0) (ipurge_r execs (current s_f)))\n            (\\<lambda>s_l s_r. output_f s_l a = output_f s_r a))", "by auto"], ["proof (state)\nthis:\n  NI_indirect_sources\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem unwinding_implies_isecure: \nshows isecure"], ["proof (prove)\ngoal (1 subgoal):\n 1. isecure", "using unwinding_implies_NI_indirect_sources  unwinding_implies_NI_unrelated"], ["proof (prove)\nusing this:\n  NI_indirect_sources\n  NI_unrelated\n\ngoal (1 subgoal):\n 1. isecure", "unfolding isecure_def"], ["proof (prove)\nusing this:\n  NI_indirect_sources\n  NI_unrelated\n\ngoal (1 subgoal):\n 1. NI_indirect_sources \\<and> NI_unrelated", "by(auto)"], ["", "end"], ["", "end"]]}