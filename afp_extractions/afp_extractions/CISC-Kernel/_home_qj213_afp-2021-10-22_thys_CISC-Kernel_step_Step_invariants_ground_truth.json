{"file_name": "/home/qj213/afp-2021-10-22/thys/CISC-Kernel/step/Step_invariants.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CISC-Kernel", "problem_names": ["lemma set_object_value_invariant:\n  shows \"atomic_step_invariant s = atomic_step_invariant (set_object_value ob va s)\"", "lemma set_thread_value_invariant:\n  shows \"atomic_step_invariant s = atomic_step_invariant (s \\<lparr> thread := thrst \\<rparr>)\"", "lemma atomic_ipc_preserves_invariants:\n  fixes s :: state_t\n    and tid :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)\"", "lemma atomic_ev_wait_one_preserves_invariants:\n  fixes s :: state_t\n    and tid :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"atomic_step_invariant (atomic_step_ev_wait_one tid s)\"", "lemma atomic_ev_wait_all_preserves_invariants:\n  fixes s :: state_t\n    and tid :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"atomic_step_invariant (atomic_step_ev_wait_all tid s)\"", "lemma atomic_ev_signal_preserves_invariants:\n  fixes s :: state_t\n    and tid :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"atomic_step_invariant (atomic_step_ev_signal tid  partner s)\"", "theorem atomic_step_preserves_invariants:\n  fixes s :: state_t\n    and tid :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"atomic_step_invariant (atomic_step s a)\"", "theorem cswitch_preserves_invariants:\n  fixes s :: state_t\n    and new_current :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"atomic_step_invariant (s \\<lparr> current := new_current \\<rparr>)\"", "theorem atomic_step_does_not_change_current_thread:\n  shows \"current (atomic_step s ipt) = current s\""], "translations": [["", "lemma set_object_value_invariant:\n  shows \"atomic_step_invariant s = atomic_step_invariant (set_object_value ob va s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant s =\n    atomic_step_invariant (set_object_value ob va s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. atomic_step_invariant s =\n    atomic_step_invariant (set_object_value ob va s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant s =\n    atomic_step_invariant (set_object_value ob va s)", "unfolding atomic_step_invariant_def atomic_step_precondition_def ipc_precondition_def\n      sp_subset_def set_object_value_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>p1 p2.\n         sp_impl_subj_subj s p1 p2 \\<longrightarrow>\n         Policy.sp_spec_subj_subj p1 p2) \\<and>\n     (\\<forall>p1 p2 m.\n         sp_impl_subj_obj s p1 p2 m \\<longrightarrow>\n         Policy.sp_spec_subj_obj p1 p2 m)) =\n    ((\\<forall>p1 p2.\n         sp_impl_subj_subj (s\\<lparr>obj := (obj s)(ob := va)\\<rparr>) p1\n          p2 \\<longrightarrow>\n         Policy.sp_spec_subj_subj p1 p2) \\<and>\n     (\\<forall>p1 p2 m.\n         sp_impl_subj_obj (s\\<lparr>obj := (obj s)(ob := va)\\<rparr>) p1 p2\n          m \\<longrightarrow>\n         Policy.sp_spec_subj_obj p1 p2 m))", "by (simp split: int_point_t.splits ipc_stage_t.splits ipc_direction_t.splits)"], ["proof (state)\nthis:\n  atomic_step_invariant s = atomic_step_invariant (set_object_value ob va s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_thread_value_invariant:\n  shows \"atomic_step_invariant s = atomic_step_invariant (s \\<lparr> thread := thrst \\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant s =\n    atomic_step_invariant (s\\<lparr>thread := thrst\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. atomic_step_invariant s =\n    atomic_step_invariant (s\\<lparr>thread := thrst\\<rparr>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant s =\n    atomic_step_invariant (s\\<lparr>thread := thrst\\<rparr>)", "unfolding atomic_step_invariant_def atomic_step_precondition_def ipc_precondition_def\n      sp_subset_def set_object_value_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>p1 p2.\n         sp_impl_subj_subj s p1 p2 \\<longrightarrow>\n         Policy.sp_spec_subj_subj p1 p2) \\<and>\n     (\\<forall>p1 p2 m.\n         sp_impl_subj_obj s p1 p2 m \\<longrightarrow>\n         Policy.sp_spec_subj_obj p1 p2 m)) =\n    ((\\<forall>p1 p2.\n         sp_impl_subj_subj (s\\<lparr>thread := thrst\\<rparr>) p1\n          p2 \\<longrightarrow>\n         Policy.sp_spec_subj_subj p1 p2) \\<and>\n     (\\<forall>p1 p2 m.\n         sp_impl_subj_obj (s\\<lparr>thread := thrst\\<rparr>) p1 p2\n          m \\<longrightarrow>\n         Policy.sp_spec_subj_obj p1 p2 m))", "by (simp split: int_point_t.splits ipc_stage_t.splits ipc_direction_t.splits)"], ["proof (state)\nthis:\n  atomic_step_invariant s =\n  atomic_step_invariant (s\\<lparr>thread := thrst\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atomic_ipc_preserves_invariants:\n  fixes s :: state_t\n    and tid :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "proof (cases stage)"], ["proof (state)\ngoal (3 subgoals):\n 1. stage = PREP \\<Longrightarrow>\n    atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)\n 2. stage = WAIT \\<Longrightarrow>\n    atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)\n 3. \\<And>x3.\n       stage = BUF x3 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "case PREP"], ["proof (state)\nthis:\n  stage = PREP\n\ngoal (3 subgoals):\n 1. stage = PREP \\<Longrightarrow>\n    atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)\n 2. stage = WAIT \\<Longrightarrow>\n    atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)\n 3. \\<And>x3.\n       stage = BUF x3 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "from this assms"], ["proof (chain)\npicking this:\n  stage = PREP\n  atomic_step_invariant s", "show ?thesis"], ["proof (prove)\nusing this:\n  stage = PREP\n  atomic_step_invariant s\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "unfolding atomic_step_ipc_def atomic_step_invariant_def"], ["proof (prove)\nusing this:\n  stage = PREP\n  sp_subset s\n\ngoal (1 subgoal):\n 1. sp_subset\n     (case stage of\n      BUF page' \\<Rightarrow>\n        case dir of\n        SEND \\<Rightarrow>\n          set_object_value (PAGE page') (obj s (PAGE page)) s\n        | RECV \\<Rightarrow> s\n      | _ \\<Rightarrow> s)", "by auto"], ["proof (state)\nthis:\n  atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)\n\ngoal (2 subgoals):\n 1. stage = WAIT \\<Longrightarrow>\n    atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)\n 2. \\<And>x3.\n       stage = BUF x3 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. stage = WAIT \\<Longrightarrow>\n    atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)\n 2. \\<And>x3.\n       stage = BUF x3 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "case WAIT"], ["proof (state)\nthis:\n  stage = WAIT\n\ngoal (2 subgoals):\n 1. stage = WAIT \\<Longrightarrow>\n    atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)\n 2. \\<And>x3.\n       stage = BUF x3 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "from this assms"], ["proof (chain)\npicking this:\n  stage = WAIT\n  atomic_step_invariant s", "show ?thesis"], ["proof (prove)\nusing this:\n  stage = WAIT\n  atomic_step_invariant s\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "unfolding atomic_step_ipc_def atomic_step_invariant_def"], ["proof (prove)\nusing this:\n  stage = WAIT\n  sp_subset s\n\ngoal (1 subgoal):\n 1. sp_subset\n     (case stage of\n      BUF page' \\<Rightarrow>\n        case dir of\n        SEND \\<Rightarrow>\n          set_object_value (PAGE page') (obj s (PAGE page)) s\n        | RECV \\<Rightarrow> s\n      | _ \\<Rightarrow> s)", "by auto"], ["proof (state)\nthis:\n  atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       stage = BUF x3 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       stage = BUF x3 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "case BUF"], ["proof (state)\nthis:\n  stage = BUF x3_\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       stage = BUF x3 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "using assms BUF set_object_value_invariant"], ["proof (prove)\nusing this:\n  atomic_step_invariant s\n  stage = BUF x3_\n  atomic_step_invariant ?s =\n  atomic_step_invariant (set_object_value ?ob ?va ?s)\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)", "unfolding atomic_step_ipc_def"], ["proof (prove)\nusing this:\n  atomic_step_invariant s\n  stage = BUF x3_\n  atomic_step_invariant ?s =\n  atomic_step_invariant (set_object_value ?ob ?va ?s)\n\ngoal (1 subgoal):\n 1. atomic_step_invariant\n     (case stage of\n      BUF page' \\<Rightarrow>\n        case dir of\n        SEND \\<Rightarrow>\n          set_object_value (PAGE page') (obj s (PAGE page)) s\n        | RECV \\<Rightarrow> s\n      | _ \\<Rightarrow> s)", "by (simp split: ipc_direction_t.splits)"], ["proof (state)\nthis:\n  atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  atomic_step_invariant (atomic_step_ipc tid dir stage partner page s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atomic_ev_wait_one_preserves_invariants:\n  fixes s :: state_t\n    and tid :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"atomic_step_invariant (atomic_step_ev_wait_one tid s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ev_wait_one tid s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ev_wait_one tid s)", "from assms"], ["proof (chain)\npicking this:\n  atomic_step_invariant s", "show ?thesis"], ["proof (prove)\nusing this:\n  atomic_step_invariant s\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ev_wait_one tid s)", "unfolding atomic_step_ev_wait_one_def atomic_step_invariant_def sp_subset_def"], ["proof (prove)\nusing this:\n  (\\<forall>p1 p2.\n      sp_impl_subj_subj s p1 p2 \\<longrightarrow>\n      Policy.sp_spec_subj_subj p1 p2) \\<and>\n  (\\<forall>p1 p2 m.\n      sp_impl_subj_obj s p1 p2 m \\<longrightarrow>\n      Policy.sp_spec_subj_obj p1 p2 m)\n\ngoal (1 subgoal):\n 1. (\\<forall>p1 p2.\n        sp_impl_subj_subj\n         (s\\<lparr>thread := (thread s)\n                     (tid := thread s tid\n                        \\<lparr>ev_counter :=\n                                  ev_counter (thread s tid) -\n                                  1\\<rparr>)\\<rparr>)\n         p1 p2 \\<longrightarrow>\n        Policy.sp_spec_subj_subj p1 p2) \\<and>\n    (\\<forall>p1 p2 m.\n        sp_impl_subj_obj\n         (s\\<lparr>thread := (thread s)\n                     (tid := thread s tid\n                        \\<lparr>ev_counter :=\n                                  ev_counter (thread s tid) -\n                                  1\\<rparr>)\\<rparr>)\n         p1 p2 m \\<longrightarrow>\n        Policy.sp_spec_subj_obj p1 p2 m)", "by auto"], ["proof (state)\nthis:\n  atomic_step_invariant (atomic_step_ev_wait_one tid s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atomic_ev_wait_all_preserves_invariants:\n  fixes s :: state_t\n    and tid :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"atomic_step_invariant (atomic_step_ev_wait_all tid s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ev_wait_all tid s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ev_wait_all tid s)", "from assms"], ["proof (chain)\npicking this:\n  atomic_step_invariant s", "show ?thesis"], ["proof (prove)\nusing this:\n  atomic_step_invariant s\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ev_wait_all tid s)", "unfolding atomic_step_ev_wait_all_def atomic_step_invariant_def sp_subset_def"], ["proof (prove)\nusing this:\n  (\\<forall>p1 p2.\n      sp_impl_subj_subj s p1 p2 \\<longrightarrow>\n      Policy.sp_spec_subj_subj p1 p2) \\<and>\n  (\\<forall>p1 p2 m.\n      sp_impl_subj_obj s p1 p2 m \\<longrightarrow>\n      Policy.sp_spec_subj_obj p1 p2 m)\n\ngoal (1 subgoal):\n 1. (\\<forall>p1 p2.\n        sp_impl_subj_subj\n         (s\\<lparr>thread := (thread s)\n                     (tid := thread s tid\n                        \\<lparr>ev_counter := 0\\<rparr>)\\<rparr>)\n         p1 p2 \\<longrightarrow>\n        Policy.sp_spec_subj_subj p1 p2) \\<and>\n    (\\<forall>p1 p2 m.\n        sp_impl_subj_obj\n         (s\\<lparr>thread := (thread s)\n                     (tid := thread s tid\n                        \\<lparr>ev_counter := 0\\<rparr>)\\<rparr>)\n         p1 p2 m \\<longrightarrow>\n        Policy.sp_spec_subj_obj p1 p2 m)", "by auto"], ["proof (state)\nthis:\n  atomic_step_invariant (atomic_step_ev_wait_all tid s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atomic_ev_signal_preserves_invariants:\n  fixes s :: state_t\n    and tid :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"atomic_step_invariant (atomic_step_ev_signal tid  partner s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ev_signal tid partner s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ev_signal tid partner s)", "from assms"], ["proof (chain)\npicking this:\n  atomic_step_invariant s", "show ?thesis"], ["proof (prove)\nusing this:\n  atomic_step_invariant s\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step_ev_signal tid partner s)", "unfolding atomic_step_ev_signal_def atomic_step_invariant_def sp_subset_def"], ["proof (prove)\nusing this:\n  (\\<forall>p1 p2.\n      sp_impl_subj_subj s p1 p2 \\<longrightarrow>\n      Policy.sp_spec_subj_subj p1 p2) \\<and>\n  (\\<forall>p1 p2 m.\n      sp_impl_subj_obj s p1 p2 m \\<longrightarrow>\n      Policy.sp_spec_subj_obj p1 p2 m)\n\ngoal (1 subgoal):\n 1. (\\<forall>p1 p2.\n        sp_impl_subj_subj\n         (s\\<lparr>thread := (thread s)\n                     (partner := thread s partner\n                        \\<lparr>ev_counter :=\n                                  Suc (ev_counter\n  (thread s partner))\\<rparr>)\\<rparr>)\n         p1 p2 \\<longrightarrow>\n        Policy.sp_spec_subj_subj p1 p2) \\<and>\n    (\\<forall>p1 p2 m.\n        sp_impl_subj_obj\n         (s\\<lparr>thread := (thread s)\n                     (partner := thread s partner\n                        \\<lparr>ev_counter :=\n                                  Suc (ev_counter\n  (thread s partner))\\<rparr>)\\<rparr>)\n         p1 p2 m \\<longrightarrow>\n        Policy.sp_spec_subj_obj p1 p2 m)", "by auto"], ["proof (state)\nthis:\n  atomic_step_invariant (atomic_step_ev_signal tid partner s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Summary theorems on atomic step invariants\\<close>"], ["", "text \\<open>Now we are ready to show that an atomic step from the current interrupt point\n        in any thread preserves invariants.\\<close>"], ["", "theorem atomic_step_preserves_invariants:\n  fixes s :: state_t\n    and tid :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"atomic_step_invariant (atomic_step s a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step s a)", "proof (cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       a = SK_IPC x11 x12 x13 x14 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 2. \\<And>x21 x22.\n       a = SK_EV_WAIT x21 x22 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 3. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 4. a = NONE \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "case SK_IPC"], ["proof (state)\nthis:\n  a = SK_IPC x11_ x12_ x13_ x14_\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       a = SK_IPC x11 x12 x13 x14 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 2. \\<And>x21 x22.\n       a = SK_EV_WAIT x21 x22 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 3. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 4. a = NONE \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "then"], ["proof (chain)\npicking this:\n  a = SK_IPC x11_ x12_ x13_ x14_", "show ?thesis"], ["proof (prove)\nusing this:\n  a = SK_IPC x11_ x12_ x13_ x14_\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step s a)", "unfolding atomic_step_def"], ["proof (prove)\nusing this:\n  a = SK_IPC x11_ x12_ x13_ x14_\n\ngoal (1 subgoal):\n 1. atomic_step_invariant\n     (case a of\n      SK_IPC dir stage partner page \\<Rightarrow>\n        atomic_step_ipc (current s) dir stage partner page s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n          atomic_step_ev_wait_all (current s) s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n          atomic_step_ev_wait_one (current s) s\n      | SK_EV_WAIT _ consume \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n          atomic_step_ev_signal (current s) partner s\n      | NONE \\<Rightarrow> s)", "using assms atomic_ipc_preserves_invariants"], ["proof (prove)\nusing this:\n  a = SK_IPC x11_ x12_ x13_ x14_\n  atomic_step_invariant s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (atomic_step_ipc ?tid ?dir ?stage ?partner ?page ?s)\n\ngoal (1 subgoal):\n 1. atomic_step_invariant\n     (case a of\n      SK_IPC dir stage partner page \\<Rightarrow>\n        atomic_step_ipc (current s) dir stage partner page s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n          atomic_step_ev_wait_all (current s) s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n          atomic_step_ev_wait_one (current s) s\n      | SK_EV_WAIT _ consume \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n          atomic_step_ev_signal (current s) partner s\n      | NONE \\<Rightarrow> s)", "by simp"], ["proof (state)\nthis:\n  atomic_step_invariant (atomic_step s a)\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       a = SK_EV_WAIT x21 x22 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 2. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 3. a = NONE \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       a = SK_EV_WAIT x21 x22 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 2. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 3. a = NONE \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "case (SK_EV_WAIT ev_wait_stage consume)"], ["proof (state)\nthis:\n  a = SK_EV_WAIT ev_wait_stage consume\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       a = SK_EV_WAIT x21 x22 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 2. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 3. a = NONE \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "then"], ["proof (chain)\npicking this:\n  a = SK_EV_WAIT ev_wait_stage consume", "show ?thesis"], ["proof (prove)\nusing this:\n  a = SK_EV_WAIT ev_wait_stage consume\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step s a)", "proof (cases consume)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = SK_EV_WAIT ev_wait_stage consume;\n     consume = EV_CONSUME_ALL\\<rbrakk>\n    \\<Longrightarrow> atomic_step_invariant (atomic_step s a)\n 2. \\<lbrakk>a = SK_EV_WAIT ev_wait_stage consume;\n     consume = EV_CONSUME_ONE\\<rbrakk>\n    \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "case EV_CONSUME_ALL"], ["proof (state)\nthis:\n  consume = EV_CONSUME_ALL\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = SK_EV_WAIT ev_wait_stage consume;\n     consume = EV_CONSUME_ALL\\<rbrakk>\n    \\<Longrightarrow> atomic_step_invariant (atomic_step s a)\n 2. \\<lbrakk>a = SK_EV_WAIT ev_wait_stage consume;\n     consume = EV_CONSUME_ONE\\<rbrakk>\n    \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "then"], ["proof (chain)\npicking this:\n  consume = EV_CONSUME_ALL", "show ?thesis"], ["proof (prove)\nusing this:\n  consume = EV_CONSUME_ALL\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step s a)", "unfolding atomic_step_def"], ["proof (prove)\nusing this:\n  consume = EV_CONSUME_ALL\n\ngoal (1 subgoal):\n 1. atomic_step_invariant\n     (case a of\n      SK_IPC dir stage partner page \\<Rightarrow>\n        atomic_step_ipc (current s) dir stage partner page s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n          atomic_step_ev_wait_all (current s) s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n          atomic_step_ev_wait_one (current s) s\n      | SK_EV_WAIT _ consume \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n          atomic_step_ev_signal (current s) partner s\n      | NONE \\<Rightarrow> s)", "using SK_EV_WAIT assms atomic_ev_wait_all_preserves_invariants"], ["proof (prove)\nusing this:\n  consume = EV_CONSUME_ALL\n  a = SK_EV_WAIT ev_wait_stage consume\n  atomic_step_invariant s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (atomic_step_ev_wait_all ?tid ?s)\n\ngoal (1 subgoal):\n 1. atomic_step_invariant\n     (case a of\n      SK_IPC dir stage partner page \\<Rightarrow>\n        atomic_step_ipc (current s) dir stage partner page s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n          atomic_step_ev_wait_all (current s) s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n          atomic_step_ev_wait_one (current s) s\n      | SK_EV_WAIT _ consume \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n          atomic_step_ev_signal (current s) partner s\n      | NONE \\<Rightarrow> s)", "by (simp split: ev_wait_stage_t.splits)"], ["proof (state)\nthis:\n  atomic_step_invariant (atomic_step s a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = SK_EV_WAIT ev_wait_stage consume;\n     consume = EV_CONSUME_ONE\\<rbrakk>\n    \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = SK_EV_WAIT ev_wait_stage consume;\n     consume = EV_CONSUME_ONE\\<rbrakk>\n    \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "case EV_CONSUME_ONE"], ["proof (state)\nthis:\n  consume = EV_CONSUME_ONE\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = SK_EV_WAIT ev_wait_stage consume;\n     consume = EV_CONSUME_ONE\\<rbrakk>\n    \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "then"], ["proof (chain)\npicking this:\n  consume = EV_CONSUME_ONE", "show ?thesis"], ["proof (prove)\nusing this:\n  consume = EV_CONSUME_ONE\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step s a)", "unfolding atomic_step_def"], ["proof (prove)\nusing this:\n  consume = EV_CONSUME_ONE\n\ngoal (1 subgoal):\n 1. atomic_step_invariant\n     (case a of\n      SK_IPC dir stage partner page \\<Rightarrow>\n        atomic_step_ipc (current s) dir stage partner page s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n          atomic_step_ev_wait_all (current s) s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n          atomic_step_ev_wait_one (current s) s\n      | SK_EV_WAIT _ consume \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n          atomic_step_ev_signal (current s) partner s\n      | NONE \\<Rightarrow> s)", "using SK_EV_WAIT assms atomic_ev_wait_one_preserves_invariants"], ["proof (prove)\nusing this:\n  consume = EV_CONSUME_ONE\n  a = SK_EV_WAIT ev_wait_stage consume\n  atomic_step_invariant s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (atomic_step_ev_wait_one ?tid ?s)\n\ngoal (1 subgoal):\n 1. atomic_step_invariant\n     (case a of\n      SK_IPC dir stage partner page \\<Rightarrow>\n        atomic_step_ipc (current s) dir stage partner page s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n          atomic_step_ev_wait_all (current s) s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n          atomic_step_ev_wait_one (current s) s\n      | SK_EV_WAIT _ consume \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n          atomic_step_ev_signal (current s) partner s\n      | NONE \\<Rightarrow> s)", "by (simp split: ev_wait_stage_t.splits)"], ["proof (state)\nthis:\n  atomic_step_invariant (atomic_step s a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  atomic_step_invariant (atomic_step s a)\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 2. a = NONE \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 2. a = NONE \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "case SK_EV_SIGNAL"], ["proof (state)\nthis:\n  a = SK_EV_SIGNAL x31_ x32_\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32.\n       a = SK_EV_SIGNAL x31 x32 \\<Longrightarrow>\n       atomic_step_invariant (atomic_step s a)\n 2. a = NONE \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "then"], ["proof (chain)\npicking this:\n  a = SK_EV_SIGNAL x31_ x32_", "show ?thesis"], ["proof (prove)\nusing this:\n  a = SK_EV_SIGNAL x31_ x32_\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step s a)", "unfolding atomic_step_def"], ["proof (prove)\nusing this:\n  a = SK_EV_SIGNAL x31_ x32_\n\ngoal (1 subgoal):\n 1. atomic_step_invariant\n     (case a of\n      SK_IPC dir stage partner page \\<Rightarrow>\n        atomic_step_ipc (current s) dir stage partner page s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n          atomic_step_ev_wait_all (current s) s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n          atomic_step_ev_wait_one (current s) s\n      | SK_EV_WAIT _ consume \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n          atomic_step_ev_signal (current s) partner s\n      | NONE \\<Rightarrow> s)", "using assms atomic_ev_signal_preserves_invariants"], ["proof (prove)\nusing this:\n  a = SK_EV_SIGNAL x31_ x32_\n  atomic_step_invariant s\n  atomic_step_invariant ?s \\<Longrightarrow>\n  atomic_step_invariant (atomic_step_ev_signal ?tid ?partner ?s)\n\ngoal (1 subgoal):\n 1. atomic_step_invariant\n     (case a of\n      SK_IPC dir stage partner page \\<Rightarrow>\n        atomic_step_ipc (current s) dir stage partner page s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n          atomic_step_ev_wait_all (current s) s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n          atomic_step_ev_wait_one (current s) s\n      | SK_EV_WAIT _ consume \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n          atomic_step_ev_signal (current s) partner s\n      | NONE \\<Rightarrow> s)", "by (simp add: ev_signal_stage_t.splits)"], ["proof (state)\nthis:\n  atomic_step_invariant (atomic_step s a)\n\ngoal (1 subgoal):\n 1. a = NONE \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = NONE \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "case NONE"], ["proof (state)\nthis:\n  a = NONE\n\ngoal (1 subgoal):\n 1. a = NONE \\<Longrightarrow> atomic_step_invariant (atomic_step s a)", "then"], ["proof (chain)\npicking this:\n  a = NONE", "show ?thesis"], ["proof (prove)\nusing this:\n  a = NONE\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (atomic_step s a)", "unfolding atomic_step_def"], ["proof (prove)\nusing this:\n  a = NONE\n\ngoal (1 subgoal):\n 1. atomic_step_invariant\n     (case a of\n      SK_IPC dir stage partner page \\<Rightarrow>\n        atomic_step_ipc (current s) dir stage partner page s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n          atomic_step_ev_wait_all (current s) s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n          atomic_step_ev_wait_one (current s) s\n      | SK_EV_WAIT _ consume \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n          atomic_step_ev_signal (current s) partner s\n      | NONE \\<Rightarrow> s)", "using assms"], ["proof (prove)\nusing this:\n  a = NONE\n  atomic_step_invariant s\n\ngoal (1 subgoal):\n 1. atomic_step_invariant\n     (case a of\n      SK_IPC dir stage partner page \\<Rightarrow>\n        atomic_step_ipc (current s) dir stage partner page s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow>\n          atomic_step_ev_wait_all (current s) s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow>\n          atomic_step_ev_wait_one (current s) s\n      | SK_EV_WAIT _ consume \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow>\n          atomic_step_ev_signal (current s) partner s\n      | NONE \\<Rightarrow> s)", "by auto"], ["proof (state)\nthis:\n  atomic_step_invariant (atomic_step s a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally, the invariants do not depend on the current thread. That is, \nthe context switch preserves the invariants, and an atomic step that is \nnot a context switch does not change the current thread.\\<close>"], ["", "theorem cswitch_preserves_invariants:\n  fixes s :: state_t\n    and new_current :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"atomic_step_invariant (s \\<lparr> current := new_current \\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_step_invariant (s\\<lparr>current := new_current\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. atomic_step_invariant (s\\<lparr>current := new_current\\<rparr>)", "let ?s1 = \"s \\<lparr> current := new_current \\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. atomic_step_invariant (s\\<lparr>current := new_current\\<rparr>)", "have \"sp_subset s = sp_subset ?s1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_subset s = sp_subset (s\\<lparr>current := new_current\\<rparr>)", "unfolding sp_subset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>p1 p2.\n         sp_impl_subj_subj s p1 p2 \\<longrightarrow>\n         Policy.sp_spec_subj_subj p1 p2) \\<and>\n     (\\<forall>p1 p2 m.\n         sp_impl_subj_obj s p1 p2 m \\<longrightarrow>\n         Policy.sp_spec_subj_obj p1 p2 m)) =\n    ((\\<forall>p1 p2.\n         sp_impl_subj_subj (s\\<lparr>current := new_current\\<rparr>) p1\n          p2 \\<longrightarrow>\n         Policy.sp_spec_subj_subj p1 p2) \\<and>\n     (\\<forall>p1 p2 m.\n         sp_impl_subj_obj (s\\<lparr>current := new_current\\<rparr>) p1 p2\n          m \\<longrightarrow>\n         Policy.sp_spec_subj_obj p1 p2 m))", "by auto"], ["proof (state)\nthis:\n  sp_subset s = sp_subset (s\\<lparr>current := new_current\\<rparr>)\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (s\\<lparr>current := new_current\\<rparr>)", "from assms this"], ["proof (chain)\npicking this:\n  atomic_step_invariant s\n  sp_subset s = sp_subset (s\\<lparr>current := new_current\\<rparr>)", "show ?thesis"], ["proof (prove)\nusing this:\n  atomic_step_invariant s\n  sp_subset s = sp_subset (s\\<lparr>current := new_current\\<rparr>)\n\ngoal (1 subgoal):\n 1. atomic_step_invariant (s\\<lparr>current := new_current\\<rparr>)", "unfolding atomic_step_invariant_def"], ["proof (prove)\nusing this:\n  sp_subset s\n  sp_subset s = sp_subset (s\\<lparr>current := new_current\\<rparr>)\n\ngoal (1 subgoal):\n 1. sp_subset (s\\<lparr>current := new_current\\<rparr>)", "by metis"], ["proof (state)\nthis:\n  atomic_step_invariant (s\\<lparr>current := new_current\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem atomic_step_does_not_change_current_thread:\n  shows \"current (atomic_step s ipt) = current s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. current (atomic_step s ipt) = current s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. current (atomic_step s ipt) = current s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. current (atomic_step s ipt) = current s", "unfolding atomic_step_def\n          and atomic_step_ipc_def\n          and set_object_value_def Let_def\n          and atomic_step_ev_wait_one_def atomic_step_ev_wait_all_def\n          and atomic_step_ev_signal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. current\n     (case ipt of\n      SK_IPC SEND (BUF page') partner page \\<Rightarrow> s\n        \\<lparr>obj := (obj s)(PAGE page' := obj s (PAGE page))\\<rparr>\n      | SK_IPC RECV (BUF page') partner page \\<Rightarrow> s\n      | SK_IPC dir _ partner page \\<Rightarrow> s\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ALL \\<Rightarrow> s\n          \\<lparr>thread := (thread s)\n                    (current s := thread s (current s)\n                       \\<lparr>ev_counter := 0\\<rparr>)\\<rparr>\n      | SK_EV_WAIT EV_FINISH EV_CONSUME_ONE \\<Rightarrow> s\n          \\<lparr>thread := (thread s)\n                    (current s := thread s (current s)\n                       \\<lparr>ev_counter :=\n                                 ev_counter (thread s (current s)) -\n                                 1\\<rparr>)\\<rparr>\n      | SK_EV_WAIT _ consume \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_PREP partner \\<Rightarrow> s\n      | SK_EV_SIGNAL EV_SIGNAL_FINISH partner \\<Rightarrow> s\n          \\<lparr>thread := (thread s)\n                    (partner := thread s partner\n                       \\<lparr>ev_counter :=\n                                 Suc (ev_counter\n (thread s partner))\\<rparr>)\\<rparr>\n      | NONE \\<Rightarrow> s) =\n    current s", "by (simp split: int_point_t.splits ipc_stage_t.splits ipc_direction_t.splits \n                        ev_consume_t.splits ev_wait_stage_t.splits ev_signal_stage_t.splits)"], ["proof (state)\nthis:\n  current (atomic_step s ipt) = current s\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}