{"file_name": "/home/qj213/afp-2021-10-22/thys/CISC-Kernel/step/Step_vpeq.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CISC-Kernel", "problem_names": ["lemma vpeq_rel:\n  shows vpeq_refl: \"vpeq u s s\"\n    and vpeq_sym [sym]: \"vpeq u s t \\<Longrightarrow> vpeq u t s\"\n    and vpeq_trans [trans]: \"\\<lbrakk> vpeq u s1 s2 ; vpeq u s2 s3 \\<rbrakk> \\<Longrightarrow> vpeq u s1 s3\"", "lemma set_object_value_ign:\n  assumes eq_obs: \"~ Policy.sp_spec_subj_obj u x READ\"\n    shows \"vpeq u s (set_object_value x y s)\"", "theorem cswitch_consistency_and_respect:\n  fixes u :: partition_id_t \n    and s :: state_t\n    and new_current :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"vpeq u s (s \\<lparr> current := new_current \\<rparr>)\""], "translations": [["", "lemma vpeq_rel:\n  shows vpeq_refl: \"vpeq u s s\"\n    and vpeq_sym [sym]: \"vpeq u s t \\<Longrightarrow> vpeq u t s\"\n    and vpeq_trans [trans]: \"\\<lbrakk> vpeq u s1 s2 ; vpeq u s2 s3 \\<rbrakk> \\<Longrightarrow> vpeq u s1 s3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq u s s &&&\n    (vpeq u s t \\<Longrightarrow> vpeq u t s) &&&\n    (\\<lbrakk>vpeq u s1 s2; vpeq u s2 s3\\<rbrakk>\n     \\<Longrightarrow> vpeq u s1 s3)", "unfolding vpeq_def vpeq_obj_def vpeq_subj_subj_def vpeq_subj_obj_def vpeq_local_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>obj_id.\n        Policy.sp_spec_subj_obj u obj_id READ \\<longrightarrow>\n        obj s obj_id = obj s obj_id) \\<and>\n    (\\<forall>v.\n        (Policy.sp_spec_subj_subj u v \\<longrightarrow>\n         sp_impl_subj_subj s u v = sp_impl_subj_subj s u v) \\<and>\n        (Policy.sp_spec_subj_subj v u \\<longrightarrow>\n         sp_impl_subj_subj s v u = sp_impl_subj_subj s v u)) \\<and>\n    (\\<forall>ob m p1.\n        (Policy.sp_spec_subj_obj u ob m \\<longrightarrow>\n         sp_impl_subj_obj s u ob m = sp_impl_subj_obj s u ob m) \\<and>\n        (Policy.sp_spec_subj_obj p1 ob PROVIDE \\<and>\n         (Policy.sp_spec_subj_obj u ob READ \\<or>\n          Policy.sp_spec_subj_obj u ob WRITE) \\<longrightarrow>\n         sp_impl_subj_obj s p1 ob PROVIDE =\n         sp_impl_subj_obj s p1 ob PROVIDE)) \\<and>\n    (\\<forall>tid.\n        Step.partition tid = u \\<longrightarrow>\n        thread s tid = thread s tid) &&&\n    ((\\<forall>obj_id.\n         Policy.sp_spec_subj_obj u obj_id READ \\<longrightarrow>\n         obj s obj_id = obj t obj_id) \\<and>\n     (\\<forall>v.\n         (Policy.sp_spec_subj_subj u v \\<longrightarrow>\n          sp_impl_subj_subj s u v = sp_impl_subj_subj t u v) \\<and>\n         (Policy.sp_spec_subj_subj v u \\<longrightarrow>\n          sp_impl_subj_subj s v u = sp_impl_subj_subj t v u)) \\<and>\n     (\\<forall>ob m p1.\n         (Policy.sp_spec_subj_obj u ob m \\<longrightarrow>\n          sp_impl_subj_obj s u ob m = sp_impl_subj_obj t u ob m) \\<and>\n         (Policy.sp_spec_subj_obj p1 ob PROVIDE \\<and>\n          (Policy.sp_spec_subj_obj u ob READ \\<or>\n           Policy.sp_spec_subj_obj u ob WRITE) \\<longrightarrow>\n          sp_impl_subj_obj s p1 ob PROVIDE =\n          sp_impl_subj_obj t p1 ob PROVIDE)) \\<and>\n     (\\<forall>tid.\n         Step.partition tid = u \\<longrightarrow>\n         thread s tid = thread t tid) \\<Longrightarrow>\n     (\\<forall>obj_id.\n         Policy.sp_spec_subj_obj u obj_id READ \\<longrightarrow>\n         obj t obj_id = obj s obj_id) \\<and>\n     (\\<forall>v.\n         (Policy.sp_spec_subj_subj u v \\<longrightarrow>\n          sp_impl_subj_subj t u v = sp_impl_subj_subj s u v) \\<and>\n         (Policy.sp_spec_subj_subj v u \\<longrightarrow>\n          sp_impl_subj_subj t v u = sp_impl_subj_subj s v u)) \\<and>\n     (\\<forall>ob m p1.\n         (Policy.sp_spec_subj_obj u ob m \\<longrightarrow>\n          sp_impl_subj_obj t u ob m = sp_impl_subj_obj s u ob m) \\<and>\n         (Policy.sp_spec_subj_obj p1 ob PROVIDE \\<and>\n          (Policy.sp_spec_subj_obj u ob READ \\<or>\n           Policy.sp_spec_subj_obj u ob WRITE) \\<longrightarrow>\n          sp_impl_subj_obj t p1 ob PROVIDE =\n          sp_impl_subj_obj s p1 ob PROVIDE)) \\<and>\n     (\\<forall>tid.\n         Step.partition tid = u \\<longrightarrow>\n         thread t tid = thread s tid)) &&&\n    (\\<lbrakk>(\\<forall>obj_id.\n                  Policy.sp_spec_subj_obj u obj_id READ \\<longrightarrow>\n                  obj s1 obj_id = obj s2 obj_id) \\<and>\n              (\\<forall>v.\n                  (Policy.sp_spec_subj_subj u v \\<longrightarrow>\n                   sp_impl_subj_subj s1 u v =\n                   sp_impl_subj_subj s2 u v) \\<and>\n                  (Policy.sp_spec_subj_subj v u \\<longrightarrow>\n                   sp_impl_subj_subj s1 v u =\n                   sp_impl_subj_subj s2 v u)) \\<and>\n              (\\<forall>ob m p1.\n                  (Policy.sp_spec_subj_obj u ob m \\<longrightarrow>\n                   sp_impl_subj_obj s1 u ob m =\n                   sp_impl_subj_obj s2 u ob m) \\<and>\n                  (Policy.sp_spec_subj_obj p1 ob PROVIDE \\<and>\n                   (Policy.sp_spec_subj_obj u ob READ \\<or>\n                    Policy.sp_spec_subj_obj u ob WRITE) \\<longrightarrow>\n                   sp_impl_subj_obj s1 p1 ob PROVIDE =\n                   sp_impl_subj_obj s2 p1 ob PROVIDE)) \\<and>\n              (\\<forall>tid.\n                  Step.partition tid = u \\<longrightarrow>\n                  thread s1 tid = thread s2 tid);\n      (\\<forall>obj_id.\n          Policy.sp_spec_subj_obj u obj_id READ \\<longrightarrow>\n          obj s2 obj_id = obj s3 obj_id) \\<and>\n      (\\<forall>v.\n          (Policy.sp_spec_subj_subj u v \\<longrightarrow>\n           sp_impl_subj_subj s2 u v = sp_impl_subj_subj s3 u v) \\<and>\n          (Policy.sp_spec_subj_subj v u \\<longrightarrow>\n           sp_impl_subj_subj s2 v u = sp_impl_subj_subj s3 v u)) \\<and>\n      (\\<forall>ob m p1.\n          (Policy.sp_spec_subj_obj u ob m \\<longrightarrow>\n           sp_impl_subj_obj s2 u ob m = sp_impl_subj_obj s3 u ob m) \\<and>\n          (Policy.sp_spec_subj_obj p1 ob PROVIDE \\<and>\n           (Policy.sp_spec_subj_obj u ob READ \\<or>\n            Policy.sp_spec_subj_obj u ob WRITE) \\<longrightarrow>\n           sp_impl_subj_obj s2 p1 ob PROVIDE =\n           sp_impl_subj_obj s3 p1 ob PROVIDE)) \\<and>\n      (\\<forall>tid.\n          Step.partition tid = u \\<longrightarrow>\n          thread s2 tid = thread s3 tid)\\<rbrakk>\n     \\<Longrightarrow> (\\<forall>obj_id.\n                           Policy.sp_spec_subj_obj u obj_id\n                            READ \\<longrightarrow>\n                           obj s1 obj_id = obj s3 obj_id) \\<and>\n                       (\\<forall>v.\n                           (Policy.sp_spec_subj_subj u v \\<longrightarrow>\n                            sp_impl_subj_subj s1 u v =\n                            sp_impl_subj_subj s3 u v) \\<and>\n                           (Policy.sp_spec_subj_subj v u \\<longrightarrow>\n                            sp_impl_subj_subj s1 v u =\n                            sp_impl_subj_subj s3 v u)) \\<and>\n                       (\\<forall>ob m p1.\n                           (Policy.sp_spec_subj_obj u ob m \\<longrightarrow>\n                            sp_impl_subj_obj s1 u ob m =\n                            sp_impl_subj_obj s3 u ob m) \\<and>\n                           (Policy.sp_spec_subj_obj p1 ob PROVIDE \\<and>\n                            (Policy.sp_spec_subj_obj u ob READ \\<or>\n                             Policy.sp_spec_subj_obj u ob\n                              WRITE) \\<longrightarrow>\n                            sp_impl_subj_obj s1 p1 ob PROVIDE =\n                            sp_impl_subj_obj s3 p1 ob PROVIDE)) \\<and>\n                       (\\<forall>tid.\n                           Step.partition tid = u \\<longrightarrow>\n                           thread s1 tid = thread s3 tid))", "by auto"], ["", "text \\<open>Auxiliary equivalence relation.\\<close>"], ["", "lemma set_object_value_ign:\n  assumes eq_obs: \"~ Policy.sp_spec_subj_obj u x READ\"\n    shows \"vpeq u s (set_object_value x y s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq u s (set_object_value x y s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vpeq u s (set_object_value x y s)", "from assms"], ["proof (chain)\npicking this:\n  \\<not> Policy.sp_spec_subj_obj u x READ", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> Policy.sp_spec_subj_obj u x READ\n\ngoal (1 subgoal):\n 1. vpeq u s (set_object_value x y s)", "unfolding vpeq_def vpeq_obj_def vpeq_subj_subj_def vpeq_subj_obj_def set_object_value_def \n              vpeq_local_def"], ["proof (prove)\nusing this:\n  \\<not> Policy.sp_spec_subj_obj u x READ\n\ngoal (1 subgoal):\n 1. (\\<forall>obj_id.\n        Policy.sp_spec_subj_obj u obj_id READ \\<longrightarrow>\n        obj s obj_id =\n        obj (s\\<lparr>obj := (obj s)(x := y)\\<rparr>) obj_id) \\<and>\n    (\\<forall>v.\n        (Policy.sp_spec_subj_subj u v \\<longrightarrow>\n         sp_impl_subj_subj s u v =\n         sp_impl_subj_subj (s\\<lparr>obj := (obj s)(x := y)\\<rparr>) u\n          v) \\<and>\n        (Policy.sp_spec_subj_subj v u \\<longrightarrow>\n         sp_impl_subj_subj s v u =\n         sp_impl_subj_subj (s\\<lparr>obj := (obj s)(x := y)\\<rparr>) v\n          u)) \\<and>\n    (\\<forall>ob m p1.\n        (Policy.sp_spec_subj_obj u ob m \\<longrightarrow>\n         sp_impl_subj_obj s u ob m =\n         sp_impl_subj_obj (s\\<lparr>obj := (obj s)(x := y)\\<rparr>) u ob\n          m) \\<and>\n        (Policy.sp_spec_subj_obj p1 ob PROVIDE \\<and>\n         (Policy.sp_spec_subj_obj u ob READ \\<or>\n          Policy.sp_spec_subj_obj u ob WRITE) \\<longrightarrow>\n         sp_impl_subj_obj s p1 ob PROVIDE =\n         sp_impl_subj_obj (s\\<lparr>obj := (obj s)(x := y)\\<rparr>) p1 ob\n          PROVIDE)) \\<and>\n    (\\<forall>tid.\n        Step.partition tid = u \\<longrightarrow>\n        thread s tid = thread (s\\<lparr>obj := (obj s)(x := y)\\<rparr>) tid)", "by auto"], ["proof (state)\nthis:\n  vpeq u s (set_object_value x y s)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Context-switch and fetch operations are also consistent with vpeq\n        and locally respect everything.\\<close>"], ["", "theorem cswitch_consistency_and_respect:\n  fixes u :: partition_id_t \n    and s :: state_t\n    and new_current :: thread_id_t\n  assumes \"atomic_step_invariant s\"\n  shows \"vpeq u s (s \\<lparr> current := new_current \\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq u s (s\\<lparr>current := new_current\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vpeq u s (s\\<lparr>current := new_current\\<rparr>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vpeq u s (s\\<lparr>current := new_current\\<rparr>)", "unfolding vpeq_def vpeq_obj_def vpeq_subj_subj_def vpeq_subj_obj_def vpeq_local_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>obj_id.\n        Policy.sp_spec_subj_obj u obj_id READ \\<longrightarrow>\n        obj s obj_id =\n        obj (s\\<lparr>current := new_current\\<rparr>) obj_id) \\<and>\n    (\\<forall>v.\n        (Policy.sp_spec_subj_subj u v \\<longrightarrow>\n         sp_impl_subj_subj s u v =\n         sp_impl_subj_subj (s\\<lparr>current := new_current\\<rparr>) u\n          v) \\<and>\n        (Policy.sp_spec_subj_subj v u \\<longrightarrow>\n         sp_impl_subj_subj s v u =\n         sp_impl_subj_subj (s\\<lparr>current := new_current\\<rparr>) v\n          u)) \\<and>\n    (\\<forall>ob m p1.\n        (Policy.sp_spec_subj_obj u ob m \\<longrightarrow>\n         sp_impl_subj_obj s u ob m =\n         sp_impl_subj_obj (s\\<lparr>current := new_current\\<rparr>) u ob\n          m) \\<and>\n        (Policy.sp_spec_subj_obj p1 ob PROVIDE \\<and>\n         (Policy.sp_spec_subj_obj u ob READ \\<or>\n          Policy.sp_spec_subj_obj u ob WRITE) \\<longrightarrow>\n         sp_impl_subj_obj s p1 ob PROVIDE =\n         sp_impl_subj_obj (s\\<lparr>current := new_current\\<rparr>) p1 ob\n          PROVIDE)) \\<and>\n    (\\<forall>tid.\n        Step.partition tid = u \\<longrightarrow>\n        thread s tid = thread (s\\<lparr>current := new_current\\<rparr>) tid)", "by auto"], ["proof (state)\nthis:\n  vpeq u s (s\\<lparr>current := new_current\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}