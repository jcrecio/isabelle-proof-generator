{"file_name": "/home/qj213/afp-2021-10-22/thys/Progress_Tracking/Graph.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Progress_Tracking", "problem_names": ["lemma le_plus: \"(s::'lbl) \\<le> s + s'\" \"(s'::'lbl) \\<le> s + s'\"", "lemma path_trans: \"path l1 l2 xs \\<Longrightarrow> path l2 l3 ys \\<Longrightarrow> path l1 l3 (xs @ ys)\"", "lemma path_take_from: \"path l1 l2 xs \\<Longrightarrow> m < length xs \\<Longrightarrow> FROM (xs ! m) = l2' \\<Longrightarrow> path l1 l2' (take m xs)\"", "lemma path_take_to: \"path l1 l2 xs \\<Longrightarrow> m < length xs \\<Longrightarrow> TO (xs ! m) = l2' \\<Longrightarrow> path l1 l2' (take (m+1) xs)\"", "lemma path_determines_loc: \"path l1 l2 xs \\<Longrightarrow> path l1 l3 xs \\<Longrightarrow> l2 = l3\"", "lemma path_first_loc: \"path loc loc' xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> FROM (xs ! 0) = loc\"", "lemma path_to_eq_from: \"path loc1 loc2 xs \\<Longrightarrow> i + 1 < length xs \\<Longrightarrow> FROM (xs ! (i+1)) = TO (xs ! i)\"", "lemma path_singleton[intro, simp]: \"s \\<in>\\<^sub>A weights l1 l2 \\<Longrightarrow> path l1 l2 [(l1,s,l2)]\"", "lemma path_appendE: \"path l1 l3 (xs @ ys) \\<Longrightarrow> \\<exists>l2. path l2 l3 ys \\<and> path l1 l2 xs\"", "lemma path_replace_prefix:\n  \"path l1 l3 (xs @ zs) \\<Longrightarrow> path l1 l2 ys \\<Longrightarrow> path l1 l2 xs \\<Longrightarrow> path l1 l3 (ys @ zs)\"", "lemma drop_subseq: \"n \\<le> length xs \\<Longrightarrow> drop n xs \\<preceq> xs\"", "lemma take_subseq[simp, intro]: \"take n xs \\<preceq> xs\"", "lemma map_take_subseq[simp, intro]: \"map f (take n xs) \\<preceq> map f xs\"", "lemma path_distinct:\n  \"path l1 l2 xs \\<Longrightarrow> \\<exists>xs'. distinct xs' \\<and> path l1 l2 xs' \\<and> map LBL xs' \\<preceq> map LBL xs\"", "lemma path_edge: \"(l1', lbl, l2') \\<in> set xs \\<Longrightarrow> path l1 l2 xs \\<Longrightarrow> lbl \\<in>\\<^sub>A weights l1' l2'\"", "lemma sum_not_less_zero[simp, dest]: \"(s::'lbl) < 0 \\<Longrightarrow> False\"", "lemma sum_le_zero[simp]: \"(s::'lbl) \\<le> 0 \\<longleftrightarrow> s = 0\"", "lemma sum_le_zeroD[dest]: \"(x::'lbl) \\<le> 0 \\<Longrightarrow> x = 0\"", "lemma foldr_plus_mono: \"(n::'lbl) \\<le> m \\<Longrightarrow> foldr (+) xs n \\<le> foldr (+) xs m\"", "lemma sum_weights_append:\n  \"sum_weights (ys @ xs) = sum_weights ys + sum_weights xs\"", "lemma sum_summary_prepend_le: \"sum_path_weights ys \\<le> sum_path_weights xs \\<Longrightarrow> sum_path_weights (zs @ ys) \\<le> sum_path_weights (zs @ xs)\"", "lemma sum_summary_append_le: \"sum_path_weights ys \\<le> sum_path_weights xs \\<Longrightarrow> sum_path_weights (ys @ zs) \\<le> sum_path_weights (xs @ zs)\"", "lemma foldr_plus_zero_le: \"foldr (+) xs (0::'lbl) \\<le> foldr (+) xs a\"", "lemma subseq_sum_weights_le:\n  assumes \"xs \\<preceq> ys\"\n  shows \"sum_weights xs \\<le> sum_weights ys\"", "lemma subseq_sum_path_weights_le:\n  \"map LBL xs \\<preceq> map LBL ys \\<Longrightarrow> sum_path_weights xs \\<le> sum_path_weights ys\"", "lemma sum_path_weights_take_le[simp, intro]: \"sum_path_weights (take i xs) \\<le> sum_path_weights xs\"", "lemma sum_weights_append_singleton:\n  \"sum_weights (xs @ [x]) = sum_weights xs + x\"", "lemma sum_path_weights_append_singleton:\n  \"sum_path_weights (xs @ [(l,x,l')]) = sum_path_weights xs + x\"", "lemma path_weightp_ex_path:\n  \"path_weightp l1 l2 s \\<Longrightarrow> \\<exists>xs.\n  (let s' = sum_path_weights xs in s' \\<le> s \\<and> path_weightp l1 l2 s' \\<and> distinct xs \\<and>\n  (\\<forall>(l1,s,l2) \\<in> set xs. s \\<in>\\<^sub>A weights l1 l2))\"", "lemma finite_set_summaries:\n  \"finite ((\\<lambda>((l1,l2),s). (l1,s,l2)) ` (Sigma UNIV (\\<lambda>(l1,l2). set_antichain (weights l1 l2))))\"", "lemma finite_summaries: \"finite {xs. distinct xs \\<and> (\\<forall>(l1, s, l2) \\<in> set xs. s \\<in>\\<^sub>A weights l1 l2)}\"", "lemma finite_minimal_antichain_path_weightp:\n  \"finite (minimal_antichain {x. path_weightp l1 l2 x})\"", "lemma in_path_weight: \"s \\<in>\\<^sub>A path_weight loc1 loc2 \\<longleftrightarrow> s \\<in> minimal_antichain {s. path_weightp loc1 loc2 s}\"", "lemma path_weight_refl[simp]: \"0 \\<in>\\<^sub>A path_weight loc loc\"", "lemma zero_in_minimal_antichain[simp]: \"(0::'lbl) \\<in> S \\<Longrightarrow> 0 \\<in> minimal_antichain S\"", "lemma minimal_antichain_path_weightp_distinct:\n  \"minimal_antichain {xs. path_weightp l1 l2 xs} = minimal_antichain {xs. path_weightp_distinct l1 l2 xs}\"", "lemma finite_path_weightp_distinct[simp, intro]: \"finite {xs. path_weightp_distinct l1 l2 xs}\"", "lemma path_weightp_distinct_nonempty:\n  \"{xs. path_weightp l1 l2 xs} \\<noteq> {} \\<longleftrightarrow> {xs. path_weightp_distinct l1 l2 xs} \\<noteq> {}\"", "lemma path_weightp_distinct_member:\n  \"s \\<in> {s. path_weightp l1 l2 s} \\<Longrightarrow> \\<exists>u. u \\<in> {s. path_weightp_distinct l1 l2 s} \\<and> u \\<le> s\"", "lemma minimal_antichain_path_weightp_member:\n  \"s \\<in> {xs. path_weightp l1 l2 xs} \\<Longrightarrow> \\<exists>u. u \\<in> minimal_antichain {xs. path_weightp l1 l2 xs} \\<and> u \\<le> s\"", "lemma path_path_weight: \"path l1 l2 xs \\<Longrightarrow> \\<exists>s. s \\<in>\\<^sub>A path_weight l1 l2 \\<and> s \\<le> sum_path_weights xs\"", "lemma path_weight_conv_path:\n  \"s \\<in>\\<^sub>A path_weight l1 l2 \\<Longrightarrow> \\<exists>xs. path l1 l2 xs \\<and> s = sum_path_weights xs \\<and> (\\<forall>ys. path l1 l2 ys \\<longrightarrow> \\<not> sum_path_weights ys < sum_path_weights xs)\"", "lemma path_weight_path: \"s \\<in>\\<^sub>A path_weight loc1 loc2 \\<Longrightarrow>\n  (\\<And>xs. optimal_path loc1 loc2 xs \\<Longrightarrow> distinct xs \\<Longrightarrow> sum_path_weights xs = s \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma path_weight_elem_trans:\n  \"s \\<in>\\<^sub>A path_weight l1 l2 \\<Longrightarrow> s' \\<in>\\<^sub>A path_weight l2 l3 \\<Longrightarrow> \\<exists>u. u \\<in>\\<^sub>A path_weight l1 l3 \\<and> u \\<le> s + s'\""], "translations": [["", "lemma le_plus: \"(s::'lbl) \\<le> s + s'\" \"(s'::'lbl) \\<le> s + s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<le> s + s' &&& s' \\<le> s + s'", "by (intro plus_mono[of s s 0 s', simplified] plus_mono[of 0 s s' s', simplified])+"], ["", "subsection\\<open>Paths\\<close>"], ["", "inductive path :: \"'vtx \\<Rightarrow> 'vtx \\<Rightarrow> ('vtx \\<times> 'lbl \\<times> 'vtx) list \\<Rightarrow> bool\" where\n  path0: \"l1 = l2 \\<Longrightarrow> path l1 l2 []\"\n| path: \"path l1 l2 xs \\<Longrightarrow> lbl \\<in>\\<^sub>A weights l2 l3 \\<Longrightarrow> path l1 l3 (xs @ [(l2, lbl, l3)])\""], ["", "inductive_cases path0E: \"path l1 l2 []\""], ["", "inductive_cases path_AppendE: \"path l1 l3 (xs @ [(l2,s,l2')])\""], ["", "lemma path_trans: \"path l1 l2 xs \\<Longrightarrow> path l2 l3 ys \\<Longrightarrow> path l1 l3 (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs; path l2 l3 ys\\<rbrakk>\n    \\<Longrightarrow> path l1 l3 (xs @ ys)", "by (rotate_tac, induct l2 l3 ys rule: path.induct)\n    (auto intro: path.path simp flip: append_assoc)"], ["", "lemma path_take_from: \"path l1 l2 xs \\<Longrightarrow> m < length xs \\<Longrightarrow> FROM (xs ! m) = l2' \\<Longrightarrow> path l1 l2' (take m xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs; m < length xs;\n     (case xs ! m of (s, l, t) \\<Rightarrow> s) = l2'\\<rbrakk>\n    \\<Longrightarrow> path l1 l2' (take m xs)", "proof (induct l1 l2 xs rule: path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; m < length [];\n        (case [] ! m of (s, l, t) \\<Rightarrow> s) = l2'\\<rbrakk>\n       \\<Longrightarrow> path l1 l2' (take m [])\n 2. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        \\<lbrakk>m < length xs;\n         (case xs ! m of (s, l, t) \\<Rightarrow> s) = l2'\\<rbrakk>\n        \\<Longrightarrow> path l1 l2' (take m xs);\n        lbl \\<in>\\<^sub>A weights l2 l3; m < length (xs @ [(l2, lbl, l3)]);\n        (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> s) =\n        l2'\\<rbrakk>\n       \\<Longrightarrow> path l1 l2' (take m (xs @ [(l2, lbl, l3)]))", "case (path l1 l2 xs lbl l3)"], ["proof (state)\nthis:\n  path l1 l2 xs\n  \\<lbrakk>m < length xs;\n   (case xs ! m of (s, l, t) \\<Rightarrow> s) = l2'\\<rbrakk>\n  \\<Longrightarrow> path l1 l2' (take m xs)\n  lbl \\<in>\\<^sub>A weights l2 l3\n  m < length (xs @ [(l2, lbl, l3)])\n  (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> s) = l2'\n\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; m < length [];\n        (case [] ! m of (s, l, t) \\<Rightarrow> s) = l2'\\<rbrakk>\n       \\<Longrightarrow> path l1 l2' (take m [])\n 2. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        \\<lbrakk>m < length xs;\n         (case xs ! m of (s, l, t) \\<Rightarrow> s) = l2'\\<rbrakk>\n        \\<Longrightarrow> path l1 l2' (take m xs);\n        lbl \\<in>\\<^sub>A weights l2 l3; m < length (xs @ [(l2, lbl, l3)]);\n        (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> s) =\n        l2'\\<rbrakk>\n       \\<Longrightarrow> path l1 l2' (take m (xs @ [(l2, lbl, l3)]))", "then"], ["proof (chain)\npicking this:\n  path l1 l2 xs\n  \\<lbrakk>m < length xs;\n   (case xs ! m of (s, l, t) \\<Rightarrow> s) = l2'\\<rbrakk>\n  \\<Longrightarrow> path l1 l2' (take m xs)\n  lbl \\<in>\\<^sub>A weights l2 l3\n  m < length (xs @ [(l2, lbl, l3)])\n  (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> s) = l2'", "show ?case"], ["proof (prove)\nusing this:\n  path l1 l2 xs\n  \\<lbrakk>m < length xs;\n   (case xs ! m of (s, l, t) \\<Rightarrow> s) = l2'\\<rbrakk>\n  \\<Longrightarrow> path l1 l2' (take m xs)\n  lbl \\<in>\\<^sub>A weights l2 l3\n  m < length (xs @ [(l2, lbl, l3)])\n  (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> s) = l2'\n\ngoal (1 subgoal):\n 1. path l1 l2' (take m (xs @ [(l2, lbl, l3)]))", "apply (unfold take_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs;\n     \\<lbrakk>m < length xs;\n      (case xs ! m of (s, l, t) \\<Rightarrow> s) = l2'\\<rbrakk>\n     \\<Longrightarrow> path l1 l2' (take m xs);\n     lbl \\<in>\\<^sub>A weights l2 l3; m < length (xs @ [(l2, lbl, l3)]);\n     (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> s) =\n     l2'\\<rbrakk>\n    \\<Longrightarrow> path l1 l2'\n                       (take m xs @ take (m - length xs) [(l2, lbl, l3)])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs;\n     \\<lbrakk>m < length xs;\n      (case xs ! m of (s, a) \\<Rightarrow> s) = l2'\\<rbrakk>\n     \\<Longrightarrow> path l1 l2' (take m xs);\n     lbl \\<in>\\<^sub>A weights l2 l3; m < Suc (length xs);\n     (case (xs @ [(l2, lbl, l3)]) ! m of (s, a) \\<Rightarrow> s) =\n     l2'\\<rbrakk>\n    \\<Longrightarrow> path l1 l2' (take m xs)", "apply (cases \"l2=l2'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>path l1 l2 xs;\n     \\<lbrakk>m < length xs;\n      (case xs ! m of (s, a) \\<Rightarrow> s) = l2'\\<rbrakk>\n     \\<Longrightarrow> path l1 l2' (take m xs);\n     lbl \\<in>\\<^sub>A weights l2 l3; m < Suc (length xs);\n     (case (xs @ [(l2, lbl, l3)]) ! m of (s, a) \\<Rightarrow> s) = l2';\n     l2 = l2'\\<rbrakk>\n    \\<Longrightarrow> path l1 l2' (take m xs)\n 2. \\<lbrakk>path l1 l2 xs;\n     \\<lbrakk>m < length xs;\n      (case xs ! m of (s, a) \\<Rightarrow> s) = l2'\\<rbrakk>\n     \\<Longrightarrow> path l1 l2' (take m xs);\n     lbl \\<in>\\<^sub>A weights l2 l3; m < Suc (length xs);\n     (case (xs @ [(l2, lbl, l3)]) ! m of (s, a) \\<Rightarrow> s) = l2';\n     l2 \\<noteq> l2'\\<rbrakk>\n    \\<Longrightarrow> path l1 l2' (take m xs)", "apply (metis linorder_not_less nth_append take_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs;\n     \\<lbrakk>m < length xs;\n      (case xs ! m of (s, a) \\<Rightarrow> s) = l2'\\<rbrakk>\n     \\<Longrightarrow> path l1 l2' (take m xs);\n     lbl \\<in>\\<^sub>A weights l2 l3; m < Suc (length xs);\n     (case (xs @ [(l2, lbl, l3)]) ! m of (s, a) \\<Rightarrow> s) = l2';\n     l2 \\<noteq> l2'\\<rbrakk>\n    \\<Longrightarrow> path l1 l2' (take m xs)", "apply (metis case_prod_conv less_Suc_eq nth_append nth_append_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  path l1 l2' (take m (xs @ [(l2, lbl, l3)]))\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; m < length [];\n        (case [] ! m of (s, l, t) \\<Rightarrow> s) = l2'\\<rbrakk>\n       \\<Longrightarrow> path l1 l2' (take m [])", "qed simp"], ["", "lemma path_take_to: \"path l1 l2 xs \\<Longrightarrow> m < length xs \\<Longrightarrow> TO (xs ! m) = l2' \\<Longrightarrow> path l1 l2' (take (m+1) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs; m < length xs;\n     (case xs ! m of (s, l, t) \\<Rightarrow> t) = l2'\\<rbrakk>\n    \\<Longrightarrow> path l1 l2' (take (m + 1) xs)", "proof (induct l1 l2 xs rule: path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; m < length [];\n        (case [] ! m of (s, l, t) \\<Rightarrow> t) = l2'\\<rbrakk>\n       \\<Longrightarrow> path l1 l2' (take (m + 1) [])\n 2. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        \\<lbrakk>m < length xs;\n         (case xs ! m of (s, l, t) \\<Rightarrow> t) = l2'\\<rbrakk>\n        \\<Longrightarrow> path l1 l2' (take (m + 1) xs);\n        lbl \\<in>\\<^sub>A weights l2 l3; m < length (xs @ [(l2, lbl, l3)]);\n        (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> t) =\n        l2'\\<rbrakk>\n       \\<Longrightarrow> path l1 l2' (take (m + 1) (xs @ [(l2, lbl, l3)]))", "case (path l1 l2 xs lbl l3)"], ["proof (state)\nthis:\n  path l1 l2 xs\n  \\<lbrakk>m < length xs;\n   (case xs ! m of (s, l, t) \\<Rightarrow> t) = l2'\\<rbrakk>\n  \\<Longrightarrow> path l1 l2' (take (m + 1) xs)\n  lbl \\<in>\\<^sub>A weights l2 l3\n  m < length (xs @ [(l2, lbl, l3)])\n  (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> t) = l2'\n\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; m < length [];\n        (case [] ! m of (s, l, t) \\<Rightarrow> t) = l2'\\<rbrakk>\n       \\<Longrightarrow> path l1 l2' (take (m + 1) [])\n 2. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        \\<lbrakk>m < length xs;\n         (case xs ! m of (s, l, t) \\<Rightarrow> t) = l2'\\<rbrakk>\n        \\<Longrightarrow> path l1 l2' (take (m + 1) xs);\n        lbl \\<in>\\<^sub>A weights l2 l3; m < length (xs @ [(l2, lbl, l3)]);\n        (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> t) =\n        l2'\\<rbrakk>\n       \\<Longrightarrow> path l1 l2' (take (m + 1) (xs @ [(l2, lbl, l3)]))", "then"], ["proof (chain)\npicking this:\n  path l1 l2 xs\n  \\<lbrakk>m < length xs;\n   (case xs ! m of (s, l, t) \\<Rightarrow> t) = l2'\\<rbrakk>\n  \\<Longrightarrow> path l1 l2' (take (m + 1) xs)\n  lbl \\<in>\\<^sub>A weights l2 l3\n  m < length (xs @ [(l2, lbl, l3)])\n  (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> t) = l2'", "show ?case"], ["proof (prove)\nusing this:\n  path l1 l2 xs\n  \\<lbrakk>m < length xs;\n   (case xs ! m of (s, l, t) \\<Rightarrow> t) = l2'\\<rbrakk>\n  \\<Longrightarrow> path l1 l2' (take (m + 1) xs)\n  lbl \\<in>\\<^sub>A weights l2 l3\n  m < length (xs @ [(l2, lbl, l3)])\n  (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> t) = l2'\n\ngoal (1 subgoal):\n 1. path l1 l2' (take (m + 1) (xs @ [(l2, lbl, l3)]))", "apply (cases \"m < length xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>path l1 l2 xs;\n     \\<lbrakk>m < length xs;\n      (case xs ! m of (s, l, t) \\<Rightarrow> t) = l2'\\<rbrakk>\n     \\<Longrightarrow> path l1 l2' (take (m + 1) xs);\n     lbl \\<in>\\<^sub>A weights l2 l3; m < length (xs @ [(l2, lbl, l3)]);\n     (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> t) = l2';\n     m < length xs\\<rbrakk>\n    \\<Longrightarrow> path l1 l2' (take (m + 1) (xs @ [(l2, lbl, l3)]))\n 2. \\<lbrakk>path l1 l2 xs;\n     \\<lbrakk>m < length xs;\n      (case xs ! m of (s, l, t) \\<Rightarrow> t) = l2'\\<rbrakk>\n     \\<Longrightarrow> path l1 l2' (take (m + 1) xs);\n     lbl \\<in>\\<^sub>A weights l2 l3; m < length (xs @ [(l2, lbl, l3)]);\n     (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> t) = l2';\n     \\<not> m < length xs\\<rbrakk>\n    \\<Longrightarrow> path l1 l2' (take (m + 1) (xs @ [(l2, lbl, l3)]))", "apply (simp add: nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs;\n     \\<lbrakk>m < length xs;\n      (case xs ! m of (s, l, t) \\<Rightarrow> t) = l2'\\<rbrakk>\n     \\<Longrightarrow> path l1 l2' (take (m + 1) xs);\n     lbl \\<in>\\<^sub>A weights l2 l3; m < length (xs @ [(l2, lbl, l3)]);\n     (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> t) = l2';\n     \\<not> m < length xs\\<rbrakk>\n    \\<Longrightarrow> path l1 l2' (take (m + 1) (xs @ [(l2, lbl, l3)]))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs; lbl \\<in>\\<^sub>A weights l2 l3;\n     m < Suc (length xs); \\<not> m < length xs;\n     l2' =\n     (case (xs @ [(l2, lbl, l3)]) ! m of (s, l, t) \\<Rightarrow> t)\\<rbrakk>\n    \\<Longrightarrow> path l1\n                       (case (xs @ [(l2, lbl, l3)]) ! m of\n                        (s, l, t) \\<Rightarrow> t)\n                       (xs @ [(l2, lbl, l3)])", "apply (metis case_prod_conv less_antisym nth_append_length path.path)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  path l1 l2' (take (m + 1) (xs @ [(l2, lbl, l3)]))\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; m < length [];\n        (case [] ! m of (s, l, t) \\<Rightarrow> t) = l2'\\<rbrakk>\n       \\<Longrightarrow> path l1 l2' (take (m + 1) [])", "qed simp"], ["", "lemma path_determines_loc: \"path l1 l2 xs \\<Longrightarrow> path l1 l3 xs \\<Longrightarrow> l2 = l3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs; path l1 l3 xs\\<rbrakk> \\<Longrightarrow> l2 = l3", "by (induct l1 l2 xs rule: path.induct) (auto elim: path.cases)"], ["", "lemma path_first_loc: \"path loc loc' xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> FROM (xs ! 0) = loc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path loc loc' xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (case xs ! 0 of (s, l, t) \\<Rightarrow> s) = loc", "proof (induct rule: path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (case [] ! 0 of (s, l, t) \\<Rightarrow> s) = l1\n 2. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        xs \\<noteq> [] \\<Longrightarrow>\n        (case xs ! 0 of (s, l, t) \\<Rightarrow> s) = l1;\n        lbl \\<in>\\<^sub>A weights l2 l3;\n        xs @ [(l2, lbl, l3)] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (case (xs @ [(l2, lbl, l3)]) ! 0 of\n                          (s, l, t) \\<Rightarrow> s) =\n                         l1", "case (path l1 l2 xs lbl l3)"], ["proof (state)\nthis:\n  path l1 l2 xs\n  xs \\<noteq> [] \\<Longrightarrow>\n  (case xs ! 0 of (s, l, t) \\<Rightarrow> s) = l1\n  lbl \\<in>\\<^sub>A weights l2 l3\n  xs @ [(l2, lbl, l3)] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (case [] ! 0 of (s, l, t) \\<Rightarrow> s) = l1\n 2. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        xs \\<noteq> [] \\<Longrightarrow>\n        (case xs ! 0 of (s, l, t) \\<Rightarrow> s) = l1;\n        lbl \\<in>\\<^sub>A weights l2 l3;\n        xs @ [(l2, lbl, l3)] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (case (xs @ [(l2, lbl, l3)]) ! 0 of\n                          (s, l, t) \\<Rightarrow> s) =\n                         l1", "then"], ["proof (chain)\npicking this:\n  path l1 l2 xs\n  xs \\<noteq> [] \\<Longrightarrow>\n  (case xs ! 0 of (s, l, t) \\<Rightarrow> s) = l1\n  lbl \\<in>\\<^sub>A weights l2 l3\n  xs @ [(l2, lbl, l3)] \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  path l1 l2 xs\n  xs \\<noteq> [] \\<Longrightarrow>\n  (case xs ! 0 of (s, l, t) \\<Rightarrow> s) = l1\n  lbl \\<in>\\<^sub>A weights l2 l3\n  xs @ [(l2, lbl, l3)] \\<noteq> []\n\ngoal (1 subgoal):\n 1. (case (xs @ [(l2, lbl, l3)]) ! 0 of (s, l, t) \\<Rightarrow> s) = l1", "by (auto elim: path0E simp: nth_append)"], ["proof (state)\nthis:\n  (case (xs @ [(l2, lbl, l3)]) ! 0 of (s, l, t) \\<Rightarrow> s) = l1\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (case [] ! 0 of (s, l, t) \\<Rightarrow> s) = l1", "qed simp"], ["", "lemma path_to_eq_from: \"path loc1 loc2 xs \\<Longrightarrow> i + 1 < length xs \\<Longrightarrow> FROM (xs ! (i+1)) = TO (xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path loc1 loc2 xs; i + 1 < length xs\\<rbrakk>\n    \\<Longrightarrow> (case xs ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n                      (case xs ! i of (s, l, t) \\<Rightarrow> t)", "proof (induct rule: path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; i + 1 < length []\\<rbrakk>\n       \\<Longrightarrow> (case [] ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n                         (case [] ! i of (s, l, t) \\<Rightarrow> t)\n 2. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        i + 1 < length xs \\<Longrightarrow>\n        (case xs ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n        (case xs ! i of (s, l, t) \\<Rightarrow> t);\n        lbl \\<in>\\<^sub>A weights l2 l3;\n        i + 1 < length (xs @ [(l2, lbl, l3)])\\<rbrakk>\n       \\<Longrightarrow> (case (xs @ [(l2, lbl, l3)]) ! (i + 1) of\n                          (s, l, t) \\<Rightarrow> s) =\n                         (case (xs @ [(l2, lbl, l3)]) ! i of\n                          (s, l, t) \\<Rightarrow> t)", "case (path l1 l2 xs lbl l3)"], ["proof (state)\nthis:\n  path l1 l2 xs\n  i + 1 < length xs \\<Longrightarrow>\n  (case xs ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n  (case xs ! i of (s, l, t) \\<Rightarrow> t)\n  lbl \\<in>\\<^sub>A weights l2 l3\n  i + 1 < length (xs @ [(l2, lbl, l3)])\n\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; i + 1 < length []\\<rbrakk>\n       \\<Longrightarrow> (case [] ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n                         (case [] ! i of (s, l, t) \\<Rightarrow> t)\n 2. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        i + 1 < length xs \\<Longrightarrow>\n        (case xs ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n        (case xs ! i of (s, l, t) \\<Rightarrow> t);\n        lbl \\<in>\\<^sub>A weights l2 l3;\n        i + 1 < length (xs @ [(l2, lbl, l3)])\\<rbrakk>\n       \\<Longrightarrow> (case (xs @ [(l2, lbl, l3)]) ! (i + 1) of\n                          (s, l, t) \\<Rightarrow> s) =\n                         (case (xs @ [(l2, lbl, l3)]) ! i of\n                          (s, l, t) \\<Rightarrow> t)", "then"], ["proof (chain)\npicking this:\n  path l1 l2 xs\n  i + 1 < length xs \\<Longrightarrow>\n  (case xs ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n  (case xs ! i of (s, l, t) \\<Rightarrow> t)\n  lbl \\<in>\\<^sub>A weights l2 l3\n  i + 1 < length (xs @ [(l2, lbl, l3)])", "show ?case"], ["proof (prove)\nusing this:\n  path l1 l2 xs\n  i + 1 < length xs \\<Longrightarrow>\n  (case xs ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n  (case xs ! i of (s, l, t) \\<Rightarrow> t)\n  lbl \\<in>\\<^sub>A weights l2 l3\n  i + 1 < length (xs @ [(l2, lbl, l3)])\n\ngoal (1 subgoal):\n 1. (case (xs @ [(l2, lbl, l3)]) ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n    (case (xs @ [(l2, lbl, l3)]) ! i of (s, l, t) \\<Rightarrow> t)", "apply (cases \"i + 1 < length xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>path l1 l2 xs;\n     i + 1 < length xs \\<Longrightarrow>\n     (case xs ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n     (case xs ! i of (s, l, t) \\<Rightarrow> t);\n     lbl \\<in>\\<^sub>A weights l2 l3; i + 1 < length (xs @ [(l2, lbl, l3)]);\n     i + 1 < length xs\\<rbrakk>\n    \\<Longrightarrow> (case (xs @ [(l2, lbl, l3)]) ! (i + 1) of\n                       (s, l, t) \\<Rightarrow> s) =\n                      (case (xs @ [(l2, lbl, l3)]) ! i of\n                       (s, l, t) \\<Rightarrow> t)\n 2. \\<lbrakk>path l1 l2 xs;\n     i + 1 < length xs \\<Longrightarrow>\n     (case xs ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n     (case xs ! i of (s, l, t) \\<Rightarrow> t);\n     lbl \\<in>\\<^sub>A weights l2 l3; i + 1 < length (xs @ [(l2, lbl, l3)]);\n     \\<not> i + 1 < length xs\\<rbrakk>\n    \\<Longrightarrow> (case (xs @ [(l2, lbl, l3)]) ! (i + 1) of\n                       (s, l, t) \\<Rightarrow> s) =\n                      (case (xs @ [(l2, lbl, l3)]) ! i of\n                       (s, l, t) \\<Rightarrow> t)", "apply (simp add: nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs;\n     i + 1 < length xs \\<Longrightarrow>\n     (case xs ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n     (case xs ! i of (s, l, t) \\<Rightarrow> t);\n     lbl \\<in>\\<^sub>A weights l2 l3; i + 1 < length (xs @ [(l2, lbl, l3)]);\n     \\<not> i + 1 < length xs\\<rbrakk>\n    \\<Longrightarrow> (case (xs @ [(l2, lbl, l3)]) ! (i + 1) of\n                       (s, l, t) \\<Rightarrow> s) =\n                      (case (xs @ [(l2, lbl, l3)]) ! i of\n                       (s, l, t) \\<Rightarrow> t)", "apply (simp add: nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs; lbl \\<in>\\<^sub>A weights l2 l3; i < length xs;\n     \\<not> Suc i < length xs\\<rbrakk>\n    \\<Longrightarrow> l2 = (case xs ! i of (s, l, t) \\<Rightarrow> t)", "apply (metis add.commute drop_eq_Nil hd_drop_conv_nth id_take_nth_drop linorder_not_less path_determines_loc path_take_to plus_1_eq_Suc take_hd_drop)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (case (xs @ [(l2, lbl, l3)]) ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n  (case (xs @ [(l2, lbl, l3)]) ! i of (s, l, t) \\<Rightarrow> t)\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; i + 1 < length []\\<rbrakk>\n       \\<Longrightarrow> (case [] ! (i + 1) of (s, l, t) \\<Rightarrow> s) =\n                         (case [] ! i of (s, l, t) \\<Rightarrow> t)", "qed simp"], ["", "lemma path_singleton[intro, simp]: \"s \\<in>\\<^sub>A weights l1 l2 \\<Longrightarrow> path l1 l2 [(l1,s,l2)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A weights l1 l2 \\<Longrightarrow> path l1 l2 [(l1, s, l2)]", "by (subst path.simps) (auto simp: path.intros)"], ["", "lemma path_appendE: \"path l1 l3 (xs @ ys) \\<Longrightarrow> \\<exists>l2. path l2 l3 ys \\<and> path l1 l2 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path l1 l3 (xs @ ys) \\<Longrightarrow>\n    \\<exists>l2. path l2 l3 ys \\<and> path l1 l2 xs", "proof (induct l1 l3 \"xs@ys\" arbitrary: xs ys rule: path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l1 l2 xs ys.\n       \\<lbrakk>l1 = l2; [] = xs @ ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l2a. path l2a l2 ys \\<and> path l1 l2a xs\n 2. \\<And>l1 l2 xs lbl l3 xsa ys.\n       \\<lbrakk>path l1 l2 xs;\n        \\<And>xsa ys.\n           xs = xsa @ ys \\<Longrightarrow>\n           \\<exists>l2a. path l2a l2 ys \\<and> path l1 l2a xsa;\n        lbl \\<in>\\<^sub>A weights l2 l3;\n        xs @ [(l2, lbl, l3)] = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l2. path l2 l3 ys \\<and> path l1 l2 xsa", "case (path0 l1 l2)"], ["proof (state)\nthis:\n  l1 = l2\n  [] = xs @ ys\n\ngoal (2 subgoals):\n 1. \\<And>l1 l2 xs ys.\n       \\<lbrakk>l1 = l2; [] = xs @ ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l2a. path l2a l2 ys \\<and> path l1 l2a xs\n 2. \\<And>l1 l2 xs lbl l3 xsa ys.\n       \\<lbrakk>path l1 l2 xs;\n        \\<And>xsa ys.\n           xs = xsa @ ys \\<Longrightarrow>\n           \\<exists>l2a. path l2a l2 ys \\<and> path l1 l2a xsa;\n        lbl \\<in>\\<^sub>A weights l2 l3;\n        xs @ [(l2, lbl, l3)] = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l2. path l2 l3 ys \\<and> path l1 l2 xsa", "then"], ["proof (chain)\npicking this:\n  l1 = l2\n  [] = xs @ ys", "show ?case"], ["proof (prove)\nusing this:\n  l1 = l2\n  [] = xs @ ys\n\ngoal (1 subgoal):\n 1. \\<exists>l2a. path l2a l2 ys \\<and> path l1 l2a xs", "by (auto intro: path.intros)"], ["proof (state)\nthis:\n  \\<exists>l2a. path l2a l2 ys \\<and> path l1 l2a xs\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3 xsa ys.\n       \\<lbrakk>path l1 l2 xs;\n        \\<And>xsa ys.\n           xs = xsa @ ys \\<Longrightarrow>\n           \\<exists>l2a. path l2a l2 ys \\<and> path l1 l2a xsa;\n        lbl \\<in>\\<^sub>A weights l2 l3;\n        xs @ [(l2, lbl, l3)] = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l2. path l2 l3 ys \\<and> path l1 l2 xsa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3 xsa ys.\n       \\<lbrakk>path l1 l2 xs;\n        \\<And>xsa ys.\n           xs = xsa @ ys \\<Longrightarrow>\n           \\<exists>l2a. path l2a l2 ys \\<and> path l1 l2a xsa;\n        lbl \\<in>\\<^sub>A weights l2 l3;\n        xs @ [(l2, lbl, l3)] = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l2. path l2 l3 ys \\<and> path l1 l2 xsa", "case (path l1 l2 xs lbl l3 xs' ys')"], ["proof (state)\nthis:\n  path l1 l2 xs\n  xs = ?xs @ ?ys \\<Longrightarrow>\n  \\<exists>l2a. path l2a l2 ?ys \\<and> path l1 l2a ?xs\n  lbl \\<in>\\<^sub>A weights l2 l3\n  xs @ [(l2, lbl, l3)] = xs' @ ys'\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3 xsa ys.\n       \\<lbrakk>path l1 l2 xs;\n        \\<And>xsa ys.\n           xs = xsa @ ys \\<Longrightarrow>\n           \\<exists>l2a. path l2a l2 ys \\<and> path l1 l2a xsa;\n        lbl \\<in>\\<^sub>A weights l2 l3;\n        xs @ [(l2, lbl, l3)] = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l2. path l2 l3 ys \\<and> path l1 l2 xsa", "from path(1,3-)"], ["proof (chain)\npicking this:\n  path l1 l2 xs\n  lbl \\<in>\\<^sub>A weights l2 l3\n  xs @ [(l2, lbl, l3)] = xs' @ ys'", "show ?case"], ["proof (prove)\nusing this:\n  path l1 l2 xs\n  lbl \\<in>\\<^sub>A weights l2 l3\n  xs @ [(l2, lbl, l3)] = xs' @ ys'\n\ngoal (1 subgoal):\n 1. \\<exists>l2. path l2 l3 ys' \\<and> path l1 l2 xs'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs; lbl \\<in>\\<^sub>A weights l2 l3;\n     xs @ [(l2, lbl, l3)] = xs' @ ys'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l2. path l2 l3 ys' \\<and> path l1 l2 xs'", "apply (subst (asm) append_eq_append_conv2[of xs \"[(l2,lbl,l3)]\" xs' ys'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs; lbl \\<in>\\<^sub>A weights l2 l3;\n     \\<exists>us.\n        xs = xs' @ us \\<and> us @ [(l2, lbl, l3)] = ys' \\<or>\n        xs @ us = xs' \\<and> [(l2, lbl, l3)] = us @ ys'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l2. path l2 l3 ys' \\<and> path l1 l2 xs'", "apply (elim exE conjE disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>us.\n       \\<lbrakk>path l1 l2 xs; lbl \\<in>\\<^sub>A weights l2 l3;\n        xs = xs' @ us; us @ [(l2, lbl, l3)] = ys'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l2. path l2 l3 ys' \\<and> path l1 l2 xs'\n 2. \\<And>us.\n       \\<lbrakk>path l1 l2 xs; lbl \\<in>\\<^sub>A weights l2 l3;\n        xs @ us = xs'; [(l2, lbl, l3)] = us @ ys'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l2. path l2 l3 ys' \\<and> path l1 l2 xs'", "subgoal for us"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs; lbl \\<in>\\<^sub>A weights l2 l3; xs = xs' @ us;\n     us @ [(l2, lbl, l3)] = ys'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l2. path l2 l3 ys' \\<and> path l1 l2 xs'", "using path(2)[of xs' us]"], ["proof (prove)\nusing this:\n  xs = xs' @ us \\<Longrightarrow>\n  \\<exists>l2a. path l2a l2 us \\<and> path l1 l2a xs'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs; lbl \\<in>\\<^sub>A weights l2 l3; xs = xs' @ us;\n     us @ [(l2, lbl, l3)] = ys'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l2. path l2 l3 ys' \\<and> path l1 l2 xs'", "by (auto intro: path.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>us.\n       \\<lbrakk>path l1 l2 xs; lbl \\<in>\\<^sub>A weights l2 l3;\n        xs @ us = xs'; [(l2, lbl, l3)] = us @ ys'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l2. path l2 l3 ys' \\<and> path l1 l2 xs'", "subgoal for us"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs; lbl \\<in>\\<^sub>A weights l2 l3; xs @ us = xs';\n     [(l2, lbl, l3)] = us @ ys'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l2. path l2 l3 ys' \\<and> path l1 l2 xs'", "by (cases \"us=[]\") (auto intro: path.intros simp: Cons_eq_append_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>l2. path l2 l3 ys' \\<and> path l1 l2 xs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_replace_prefix:\n  \"path l1 l3 (xs @ zs) \\<Longrightarrow> path l1 l2 ys \\<Longrightarrow> path l1 l2 xs \\<Longrightarrow> path l1 l3 (ys @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l3 (xs @ zs); path l1 l2 ys; path l1 l2 xs\\<rbrakk>\n    \\<Longrightarrow> path l1 l3 (ys @ zs)", "by (drule path_appendE) (auto elim!: path_trans dest: path_determines_loc)"], ["", "lemma drop_subseq: \"n \\<le> length xs \\<Longrightarrow> drop n xs \\<preceq> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow> drop n xs \\<preceq> xs", "by (auto simp: suffix_def intro!: exI[of _ \"take n xs\"])"], ["", "lemma take_subseq[simp, intro]: \"take n xs \\<preceq> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n xs \\<preceq> xs", "by (induct xs) auto"], ["", "lemma map_take_subseq[simp, intro]: \"map f (take n xs) \\<preceq> map f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (take n xs) \\<preceq> map f xs", "by (rule subseq_map, induct xs) auto"], ["", "lemma path_distinct:\n  \"path l1 l2 xs \\<Longrightarrow> \\<exists>xs'. distinct xs' \\<and> path l1 l2 xs' \\<and> map LBL xs' \\<preceq> map LBL xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path l1 l2 xs \\<Longrightarrow>\n    \\<exists>xs'.\n       distinct xs' \\<and>\n       path l1 l2 xs' \\<and>\n       map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n       map (\\<lambda>(s, l, t). l) xs", "proof (induct rule: path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       l1 = l2 \\<Longrightarrow>\n       \\<exists>xs'.\n          distinct xs' \\<and>\n          path l1 l2 xs' \\<and>\n          map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n           xs' \\<preceq>\n          map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) []\n 2. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        \\<exists>xs'.\n           distinct xs' \\<and>\n           path l1 l2 xs' \\<and>\n           map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n            xs' \\<preceq>\n           map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n        lbl \\<in>\\<^sub>A weights l2 l3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            distinct xs' \\<and>\n                            path l1 l3 xs' \\<and>\n                            map (\\<lambda>a.\n                                    case a of (s, l, t) \\<Rightarrow> l)\n                             xs' \\<preceq>\n                            map (\\<lambda>a.\n                                    case a of (s, l, t) \\<Rightarrow> l)\n                             (xs @ [(l2, lbl, l3)])", "case (path0 l1 l2)"], ["proof (state)\nthis:\n  l1 = l2\n\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       l1 = l2 \\<Longrightarrow>\n       \\<exists>xs'.\n          distinct xs' \\<and>\n          path l1 l2 xs' \\<and>\n          map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n           xs' \\<preceq>\n          map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) []\n 2. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        \\<exists>xs'.\n           distinct xs' \\<and>\n           path l1 l2 xs' \\<and>\n           map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n            xs' \\<preceq>\n           map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n        lbl \\<in>\\<^sub>A weights l2 l3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            distinct xs' \\<and>\n                            path l1 l3 xs' \\<and>\n                            map (\\<lambda>a.\n                                    case a of (s, l, t) \\<Rightarrow> l)\n                             xs' \\<preceq>\n                            map (\\<lambda>a.\n                                    case a of (s, l, t) \\<Rightarrow> l)\n                             (xs @ [(l2, lbl, l3)])", "then"], ["proof (chain)\npicking this:\n  l1 = l2", "show ?case"], ["proof (prove)\nusing this:\n  l1 = l2\n\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       distinct xs' \\<and>\n       path l1 l2 xs' \\<and>\n       map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n       map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) []", "by (intro exI[of _ \"[]\"]) (auto intro: path.intros)"], ["proof (state)\nthis:\n  \\<exists>xs'.\n     distinct xs' \\<and>\n     path l1 l2 xs' \\<and>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) []\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        \\<exists>xs'.\n           distinct xs' \\<and>\n           path l1 l2 xs' \\<and>\n           map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n            xs' \\<preceq>\n           map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n        lbl \\<in>\\<^sub>A weights l2 l3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            distinct xs' \\<and>\n                            path l1 l3 xs' \\<and>\n                            map (\\<lambda>a.\n                                    case a of (s, l, t) \\<Rightarrow> l)\n                             xs' \\<preceq>\n                            map (\\<lambda>a.\n                                    case a of (s, l, t) \\<Rightarrow> l)\n                             (xs @ [(l2, lbl, l3)])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        \\<exists>xs'.\n           distinct xs' \\<and>\n           path l1 l2 xs' \\<and>\n           map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n            xs' \\<preceq>\n           map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n        lbl \\<in>\\<^sub>A weights l2 l3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            distinct xs' \\<and>\n                            path l1 l3 xs' \\<and>\n                            map (\\<lambda>a.\n                                    case a of (s, l, t) \\<Rightarrow> l)\n                             xs' \\<preceq>\n                            map (\\<lambda>a.\n                                    case a of (s, l, t) \\<Rightarrow> l)\n                             (xs @ [(l2, lbl, l3)])", "case (path l1 l2 xs lbl l3)"], ["proof (state)\nthis:\n  path l1 l2 xs\n  \\<exists>xs'.\n     distinct xs' \\<and>\n     path l1 l2 xs' \\<and>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs\n  lbl \\<in>\\<^sub>A weights l2 l3\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        \\<exists>xs'.\n           distinct xs' \\<and>\n           path l1 l2 xs' \\<and>\n           map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n            xs' \\<preceq>\n           map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n        lbl \\<in>\\<^sub>A weights l2 l3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            distinct xs' \\<and>\n                            path l1 l3 xs' \\<and>\n                            map (\\<lambda>a.\n                                    case a of (s, l, t) \\<Rightarrow> l)\n                             xs' \\<preceq>\n                            map (\\<lambda>a.\n                                    case a of (s, l, t) \\<Rightarrow> l)\n                             (xs @ [(l2, lbl, l3)])", "then"], ["proof (chain)\npicking this:\n  path l1 l2 xs\n  \\<exists>xs'.\n     distinct xs' \\<and>\n     path l1 l2 xs' \\<and>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs\n  lbl \\<in>\\<^sub>A weights l2 l3", "obtain xs' where ih: \"path l1 l2 xs'\" \"distinct xs'\" \"map LBL xs' \\<preceq> map LBL xs\""], ["proof (prove)\nusing this:\n  path l1 l2 xs\n  \\<exists>xs'.\n     distinct xs' \\<and>\n     path l1 l2 xs' \\<and>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs\n  lbl \\<in>\\<^sub>A weights l2 l3\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        \\<lbrakk>path l1 l2 xs'; distinct xs';\n         map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n         map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path l1 l2 xs'\n  distinct xs'\n  map (\\<lambda>(s, l, t). l) xs' \\<preceq> map (\\<lambda>(s, l, t). l) xs\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        \\<exists>xs'.\n           distinct xs' \\<and>\n           path l1 l2 xs' \\<and>\n           map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n            xs' \\<preceq>\n           map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n        lbl \\<in>\\<^sub>A weights l2 l3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            distinct xs' \\<and>\n                            path l1 l3 xs' \\<and>\n                            map (\\<lambda>a.\n                                    case a of (s, l, t) \\<Rightarrow> l)\n                             xs' \\<preceq>\n                            map (\\<lambda>a.\n                                    case a of (s, l, t) \\<Rightarrow> l)\n                             (xs @ [(l2, lbl, l3)])", "then"], ["proof (chain)\npicking this:\n  path l1 l2 xs'\n  distinct xs'\n  map (\\<lambda>(s, l, t). l) xs' \\<preceq> map (\\<lambda>(s, l, t). l) xs", "show ?case"], ["proof (prove)\nusing this:\n  path l1 l2 xs'\n  distinct xs'\n  map (\\<lambda>(s, l, t). l) xs' \\<preceq> map (\\<lambda>(s, l, t). l) xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       distinct xs' \\<and>\n       path l1 l3 xs' \\<and>\n       map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n       map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n        (xs @ [(l2, lbl, l3)])", "proof (cases \"(l2, lbl, l3) \\<in> set xs'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>path l1 l2 xs'; distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     (l2, lbl, l3) \\<in> set xs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         distinct xs' \\<and>\n                         path l1 l3 xs' \\<and>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          xs' \\<preceq>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          (xs @ [(l2, lbl, l3)])\n 2. \\<lbrakk>path l1 l2 xs'; distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     (l2, lbl, l3) \\<notin> set xs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         distinct xs' \\<and>\n                         path l1 l3 xs' \\<and>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          xs' \\<preceq>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          (xs @ [(l2, lbl, l3)])", "case True"], ["proof (state)\nthis:\n  (l2, lbl, l3) \\<in> set xs'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path l1 l2 xs'; distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     (l2, lbl, l3) \\<in> set xs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         distinct xs' \\<and>\n                         path l1 l3 xs' \\<and>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          xs' \\<preceq>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          (xs @ [(l2, lbl, l3)])\n 2. \\<lbrakk>path l1 l2 xs'; distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     (l2, lbl, l3) \\<notin> set xs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         distinct xs' \\<and>\n                         path l1 l3 xs' \\<and>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          xs' \\<preceq>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          (xs @ [(l2, lbl, l3)])", "then"], ["proof (chain)\npicking this:\n  (l2, lbl, l3) \\<in> set xs'", "obtain m where m: \"m < length xs'\" \"xs' ! m = (l2, lbl, l3)\""], ["proof (prove)\nusing this:\n  (l2, lbl, l3) \\<in> set xs'\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding in_set_conv_nth"], ["proof (prove)\nusing this:\n  \\<exists>i<length xs'. xs' ! i = (l2, lbl, l3)\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m < length xs'\n  xs' ! m = (l2, lbl, l3)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path l1 l2 xs'; distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     (l2, lbl, l3) \\<in> set xs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         distinct xs' \\<and>\n                         path l1 l3 xs' \\<and>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          xs' \\<preceq>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          (xs @ [(l2, lbl, l3)])\n 2. \\<lbrakk>path l1 l2 xs'; distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     (l2, lbl, l3) \\<notin> set xs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         distinct xs' \\<and>\n                         path l1 l3 xs' \\<and>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          xs' \\<preceq>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          (xs @ [(l2, lbl, l3)])", "from m ih"], ["proof (chain)\npicking this:\n  m < length xs'\n  xs' ! m = (l2, lbl, l3)\n  path l1 l2 xs'\n  distinct xs'\n  map (\\<lambda>(s, l, t). l) xs' \\<preceq> map (\\<lambda>(s, l, t). l) xs", "have \"path l1 l2 (take m xs')\""], ["proof (prove)\nusing this:\n  m < length xs'\n  xs' ! m = (l2, lbl, l3)\n  path l1 l2 xs'\n  distinct xs'\n  map (\\<lambda>(s, l, t). l) xs' \\<preceq> map (\\<lambda>(s, l, t). l) xs\n\ngoal (1 subgoal):\n 1. path l1 l2 (take m xs')", "by (auto intro: path_take_from)"], ["proof (state)\nthis:\n  path l1 l2 (take m xs')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path l1 l2 xs'; distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     (l2, lbl, l3) \\<in> set xs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         distinct xs' \\<and>\n                         path l1 l3 xs' \\<and>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          xs' \\<preceq>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          (xs @ [(l2, lbl, l3)])\n 2. \\<lbrakk>path l1 l2 xs'; distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     (l2, lbl, l3) \\<notin> set xs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         distinct xs' \\<and>\n                         path l1 l3 xs' \\<and>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          xs' \\<preceq>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          (xs @ [(l2, lbl, l3)])", "with m ih path"], ["proof (chain)\npicking this:\n  m < length xs'\n  xs' ! m = (l2, lbl, l3)\n  path l1 l2 xs'\n  distinct xs'\n  map (\\<lambda>(s, l, t). l) xs' \\<preceq> map (\\<lambda>(s, l, t). l) xs\n  path l1 l2 xs\n  \\<exists>xs'.\n     distinct xs' \\<and>\n     path l1 l2 xs' \\<and>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs\n  lbl \\<in>\\<^sub>A weights l2 l3\n  path l1 l2 (take m xs')", "show ?thesis"], ["proof (prove)\nusing this:\n  m < length xs'\n  xs' ! m = (l2, lbl, l3)\n  path l1 l2 xs'\n  distinct xs'\n  map (\\<lambda>(s, l, t). l) xs' \\<preceq> map (\\<lambda>(s, l, t). l) xs\n  path l1 l2 xs\n  \\<exists>xs'.\n     distinct xs' \\<and>\n     path l1 l2 xs' \\<and>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs\n  lbl \\<in>\\<^sub>A weights l2 l3\n  path l1 l2 (take m xs')\n\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       distinct xs' \\<and>\n       path l1 l3 xs' \\<and>\n       map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n       map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n        (xs @ [(l2, lbl, l3)])", "apply (intro exI[of _ \"take m xs' @ [(l2, lbl, l3)]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3); path l1 l2 xs';\n     distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     path l1 l2 xs;\n     \\<exists>xs'.\n        distinct xs' \\<and>\n        path l1 l2 xs' \\<and>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n     lbl \\<in>\\<^sub>A weights l2 l3; path l1 l2 (take m xs')\\<rbrakk>\n    \\<Longrightarrow> distinct (take m xs' @ [(l2, lbl, l3)]) \\<and>\n                      path l1 l3 (take m xs' @ [(l2, lbl, l3)]) \\<and>\n                      map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (take m xs' @ [(l2, lbl, l3)]) \\<preceq>\n                      map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (xs @ [(l2, lbl, l3)])", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3); path l1 l2 xs';\n     distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     path l1 l2 xs;\n     \\<exists>xs'.\n        distinct xs' \\<and>\n        path l1 l2 xs' \\<and>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n     lbl \\<in>\\<^sub>A weights l2 l3; path l1 l2 (take m xs')\\<rbrakk>\n    \\<Longrightarrow> distinct (take m xs' @ [(l2, lbl, l3)])\n 2. \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3); path l1 l2 xs';\n     distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     path l1 l2 xs;\n     \\<exists>xs'.\n        distinct xs' \\<and>\n        path l1 l2 xs' \\<and>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n     lbl \\<in>\\<^sub>A weights l2 l3; path l1 l2 (take m xs')\\<rbrakk>\n    \\<Longrightarrow> path l1 l3 (take m xs' @ [(l2, lbl, l3)]) \\<and>\n                      map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (take m xs' @ [(l2, lbl, l3)]) \\<preceq>\n                      map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (xs @ [(l2, lbl, l3)])", "apply (metis distinct_take take_Suc_conv_app_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3); path l1 l2 xs';\n     distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     path l1 l2 xs;\n     \\<exists>xs'.\n        distinct xs' \\<and>\n        path l1 l2 xs' \\<and>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n     lbl \\<in>\\<^sub>A weights l2 l3; path l1 l2 (take m xs')\\<rbrakk>\n    \\<Longrightarrow> path l1 l3 (take m xs' @ [(l2, lbl, l3)]) \\<and>\n                      map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (take m xs' @ [(l2, lbl, l3)]) \\<preceq>\n                      map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (xs @ [(l2, lbl, l3)])", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3); path l1 l2 xs';\n     distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     path l1 l2 xs;\n     \\<exists>xs'.\n        distinct xs' \\<and>\n        path l1 l2 xs' \\<and>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n     lbl \\<in>\\<^sub>A weights l2 l3; path l1 l2 (take m xs')\\<rbrakk>\n    \\<Longrightarrow> path l1 l3 (take m xs' @ [(l2, lbl, l3)])\n 2. \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3); path l1 l2 xs';\n     distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     path l1 l2 xs;\n     \\<exists>xs'.\n        distinct xs' \\<and>\n        path l1 l2 xs' \\<and>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n     lbl \\<in>\\<^sub>A weights l2 l3; path l1 l2 (take m xs')\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (take m xs' @ [(l2, lbl, l3)]) \\<preceq>\n                      map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (xs @ [(l2, lbl, l3)])", "apply (rule path.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3); path l1 l2 xs';\n     distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     path l1 l2 xs;\n     \\<exists>xs'.\n        distinct xs' \\<and>\n        path l1 l2 xs' \\<and>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n     lbl \\<in>\\<^sub>A weights l2 l3; path l1 l2 (take m xs')\\<rbrakk>\n    \\<Longrightarrow> path l1 l2 (take m xs')\n 2. \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3); path l1 l2 xs';\n     distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     path l1 l2 xs;\n     \\<exists>xs'.\n        distinct xs' \\<and>\n        path l1 l2 xs' \\<and>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n     lbl \\<in>\\<^sub>A weights l2 l3; path l1 l2 (take m xs')\\<rbrakk>\n    \\<Longrightarrow> lbl \\<in>\\<^sub>A weights l2 l3\n 3. \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3); path l1 l2 xs';\n     distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     path l1 l2 xs;\n     \\<exists>xs'.\n        distinct xs' \\<and>\n        path l1 l2 xs' \\<and>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n     lbl \\<in>\\<^sub>A weights l2 l3; path l1 l2 (take m xs')\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (take m xs' @ [(l2, lbl, l3)]) \\<preceq>\n                      map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (xs @ [(l2, lbl, l3)])", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3); path l1 l2 xs';\n     distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     path l1 l2 xs;\n     \\<exists>xs'.\n        distinct xs' \\<and>\n        path l1 l2 xs' \\<and>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n     lbl \\<in>\\<^sub>A weights l2 l3; path l1 l2 (take m xs')\\<rbrakk>\n    \\<Longrightarrow> lbl \\<in>\\<^sub>A weights l2 l3\n 2. \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3); path l1 l2 xs';\n     distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     path l1 l2 xs;\n     \\<exists>xs'.\n        distinct xs' \\<and>\n        path l1 l2 xs' \\<and>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n     lbl \\<in>\\<^sub>A weights l2 l3; path l1 l2 (take m xs')\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (take m xs' @ [(l2, lbl, l3)]) \\<preceq>\n                      map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (xs @ [(l2, lbl, l3)])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3); path l1 l2 xs';\n     distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     path l1 l2 xs;\n     \\<exists>xs'.\n        distinct xs' \\<and>\n        path l1 l2 xs' \\<and>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n     lbl \\<in>\\<^sub>A weights l2 l3; path l1 l2 (take m xs')\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (take m xs' @ [(l2, lbl, l3)]) \\<preceq>\n                      map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                       (xs @ [(l2, lbl, l3)])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < length xs'; xs' ! m = (l2, lbl, l3); path l1 l2 xs';\n     distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     path l1 l2 xs;\n     \\<exists>xs'.\n        distinct xs' \\<and>\n        path l1 l2 xs' \\<and>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n        map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs;\n     lbl \\<in>\\<^sub>A weights l2 l3; path l1 l2 (take m xs')\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>(s, l, t). l) (take m xs') \\<preceq>\n                      map (\\<lambda>(s, l, t). l) xs", "apply (metis ih(3) subseq_order.order.trans take_map take_subseq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>xs'.\n     distinct xs' \\<and>\n     path l1 l3 xs' \\<and>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n      (xs @ [(l2, lbl, l3)])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs'; distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     (l2, lbl, l3) \\<notin> set xs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         distinct xs' \\<and>\n                         path l1 l3 xs' \\<and>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          xs' \\<preceq>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          (xs @ [(l2, lbl, l3)])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs'; distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     (l2, lbl, l3) \\<notin> set xs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         distinct xs' \\<and>\n                         path l1 l3 xs' \\<and>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          xs' \\<preceq>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          (xs @ [(l2, lbl, l3)])", "case False"], ["proof (state)\nthis:\n  (l2, lbl, l3) \\<notin> set xs'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs'; distinct xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs;\n     (l2, lbl, l3) \\<notin> set xs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         distinct xs' \\<and>\n                         path l1 l3 xs' \\<and>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          xs' \\<preceq>\n                         map (\\<lambda>a.\n                                 case a of (s, l, t) \\<Rightarrow> l)\n                          (xs @ [(l2, lbl, l3)])", "with ih path(3)"], ["proof (chain)\npicking this:\n  path l1 l2 xs'\n  distinct xs'\n  map (\\<lambda>(s, l, t). l) xs' \\<preceq> map (\\<lambda>(s, l, t). l) xs\n  lbl \\<in>\\<^sub>A weights l2 l3\n  (l2, lbl, l3) \\<notin> set xs'", "show ?thesis"], ["proof (prove)\nusing this:\n  path l1 l2 xs'\n  distinct xs'\n  map (\\<lambda>(s, l, t). l) xs' \\<preceq> map (\\<lambda>(s, l, t). l) xs\n  lbl \\<in>\\<^sub>A weights l2 l3\n  (l2, lbl, l3) \\<notin> set xs'\n\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       distinct xs' \\<and>\n       path l1 l3 xs' \\<and>\n       map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n       map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n        (xs @ [(l2, lbl, l3)])", "by (auto intro!: exI[of _ \"xs' @ [(l2, lbl, l3)]\"] intro: path.intros)"], ["proof (state)\nthis:\n  \\<exists>xs'.\n     distinct xs' \\<and>\n     path l1 l3 xs' \\<and>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n      (xs @ [(l2, lbl, l3)])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs'.\n     distinct xs' \\<and>\n     path l1 l3 xs' \\<and>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs' \\<preceq>\n     map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n      (xs @ [(l2, lbl, l3)])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_edge: \"(l1', lbl, l2') \\<in> set xs \\<Longrightarrow> path l1 l2 xs \\<Longrightarrow> lbl \\<in>\\<^sub>A weights l1' l2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(l1', lbl, l2') \\<in> set xs; path l1 l2 xs\\<rbrakk>\n    \\<Longrightarrow> lbl \\<in>\\<^sub>A weights l1' l2'", "by (rotate_tac, induct rule: path.induct) auto"], ["", "subsection\\<open>Path Weights\\<close>"], ["", "abbreviation sum_weights :: \"'lbl list \\<Rightarrow> 'lbl\" where\n  \"sum_weights xs \\<equiv> foldr (+) xs 0\""], ["", "abbreviation \"sum_path_weights xs \\<equiv> sum_weights (map LBL xs)\""], ["", "definition \"path_weightp l1 l2 s \\<equiv> (\\<exists>xs. path l1 l2 xs \\<and> s = sum_path_weights xs)\""], ["", "lemma sum_not_less_zero[simp, dest]: \"(s::'lbl) < 0 \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s < (0::'lbl) \\<Longrightarrow> False", "by (simp add: less_le_not_le)"], ["", "lemma sum_le_zero[simp]: \"(s::'lbl) \\<le> 0 \\<longleftrightarrow> s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<le> (0::'lbl)) = (s = (0::'lbl))", "by (simp add: eq_iff)"], ["", "lemma sum_le_zeroD[dest]: \"(x::'lbl) \\<le> 0 \\<Longrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> (0::'lbl) \\<Longrightarrow> x = (0::'lbl)", "by simp"], ["", "lemma foldr_plus_mono: \"(n::'lbl) \\<le> m \\<Longrightarrow> foldr (+) xs n \\<le> foldr (+) xs m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow> foldr (+) xs n \\<le> foldr (+) xs m", "by (induct xs) (auto simp: plus_mono)"], ["", "lemma sum_weights_append:\n  \"sum_weights (ys @ xs) = sum_weights ys + sum_weights xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_weights (ys @ xs) = sum_weights ys + sum_weights xs", "by (induct ys) (auto simp: add.assoc)"], ["", "lemma sum_summary_prepend_le: \"sum_path_weights ys \\<le> sum_path_weights xs \\<Longrightarrow> sum_path_weights (zs @ ys) \\<le> sum_path_weights (zs @ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_weights (map (\\<lambda>(s, l, t). l) ys)\n    \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<Longrightarrow>\n    sum_weights (map (\\<lambda>(s, l, t). l) (zs @ ys))\n    \\<le> sum_weights (map (\\<lambda>(s, l, t). l) (zs @ xs))", "by (induct zs arbitrary: xs ys) (auto intro: plus_mono)"], ["", "lemma sum_summary_append_le: \"sum_path_weights ys \\<le> sum_path_weights xs \\<Longrightarrow> sum_path_weights (ys @ zs) \\<le> sum_path_weights (xs @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_weights (map (\\<lambda>(s, l, t). l) ys)\n    \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<Longrightarrow>\n    sum_weights (map (\\<lambda>(s, l, t). l) (ys @ zs))\n    \\<le> sum_weights (map (\\<lambda>(s, l, t). l) (xs @ zs))", "proof (induct zs arbitrary: xs ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       sum_weights (map (\\<lambda>(s, l, t). l) ys)\n       \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<Longrightarrow>\n       sum_weights (map (\\<lambda>(s, l, t). l) (ys @ []))\n       \\<le> sum_weights (map (\\<lambda>(s, l, t). l) (xs @ []))\n 2. \\<And>a zs xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   sum_weights (map (\\<lambda>(s, l, t). l) ys)\n                   \\<le> sum_weights\n                          (map (\\<lambda>(s, l, t). l) xs) \\<Longrightarrow>\n                   sum_weights (map (\\<lambda>(s, l, t). l) (ys @ zs))\n                   \\<le> sum_weights\n                          (map (\\<lambda>(s, l, t). l) (xs @ zs));\n        sum_weights (map (\\<lambda>(s, l, t). l) ys)\n        \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)\\<rbrakk>\n       \\<Longrightarrow> sum_weights\n                          (map (\\<lambda>(s, l, t). l) (ys @ a # zs))\n                         \\<le> sum_weights\n                                (map (\\<lambda>(s, l, t). l) (xs @ a # zs))", "case (Cons a zs)"], ["proof (state)\nthis:\n  sum_weights (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) ?ys1)\n  \\<le> sum_weights\n         (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n           ?xs1) \\<Longrightarrow>\n  sum_weights\n   (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) (?ys1 @ zs))\n  \\<le> sum_weights\n         (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) (?xs1 @ zs))\n  sum_weights (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) ys)\n  \\<le> sum_weights\n         (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       sum_weights (map (\\<lambda>(s, l, t). l) ys)\n       \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<Longrightarrow>\n       sum_weights (map (\\<lambda>(s, l, t). l) (ys @ []))\n       \\<le> sum_weights (map (\\<lambda>(s, l, t). l) (xs @ []))\n 2. \\<And>a zs xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   sum_weights (map (\\<lambda>(s, l, t). l) ys)\n                   \\<le> sum_weights\n                          (map (\\<lambda>(s, l, t). l) xs) \\<Longrightarrow>\n                   sum_weights (map (\\<lambda>(s, l, t). l) (ys @ zs))\n                   \\<le> sum_weights\n                          (map (\\<lambda>(s, l, t). l) (xs @ zs));\n        sum_weights (map (\\<lambda>(s, l, t). l) ys)\n        \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)\\<rbrakk>\n       \\<Longrightarrow> sum_weights\n                          (map (\\<lambda>(s, l, t). l) (ys @ a # zs))\n                         \\<le> sum_weights\n                                (map (\\<lambda>(s, l, t). l) (xs @ a # zs))", "then"], ["proof (chain)\npicking this:\n  sum_weights (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) ?ys1)\n  \\<le> sum_weights\n         (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n           ?xs1) \\<Longrightarrow>\n  sum_weights\n   (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) (?ys1 @ zs))\n  \\<le> sum_weights\n         (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) (?xs1 @ zs))\n  sum_weights (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) ys)\n  \\<le> sum_weights\n         (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs)", "show ?case"], ["proof (prove)\nusing this:\n  sum_weights (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) ?ys1)\n  \\<le> sum_weights\n         (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n           ?xs1) \\<Longrightarrow>\n  sum_weights\n   (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) (?ys1 @ zs))\n  \\<le> sum_weights\n         (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) (?xs1 @ zs))\n  sum_weights (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) ys)\n  \\<le> sum_weights\n         (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs)\n\ngoal (1 subgoal):\n 1. sum_weights\n     (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) (ys @ a # zs))\n    \\<le> sum_weights\n           (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n             (xs @ a # zs))", "by (metis plus_mono map_append order_refl sum_weights_append)"], ["proof (state)\nthis:\n  sum_weights\n   (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) (ys @ a # zs))\n  \\<le> sum_weights\n         (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n           (xs @ a # zs))\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       sum_weights (map (\\<lambda>(s, l, t). l) ys)\n       \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<Longrightarrow>\n       sum_weights (map (\\<lambda>(s, l, t). l) (ys @ []))\n       \\<le> sum_weights (map (\\<lambda>(s, l, t). l) (xs @ []))", "qed simp"], ["", "lemma foldr_plus_zero_le: \"foldr (+) xs (0::'lbl) \\<le> foldr (+) xs a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_weights xs \\<le> foldr (+) xs a", "by (induct xs) (simp_all add: plus_mono)"], ["", "lemma subseq_sum_weights_le:\n  assumes \"xs \\<preceq> ys\"\n  shows \"sum_weights xs \\<le> sum_weights ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_weights xs \\<le> sum_weights ys", "using assms"], ["proof (prove)\nusing this:\n  xs \\<preceq> ys\n\ngoal (1 subgoal):\n 1. sum_weights xs \\<le> sum_weights ys", "proof (induct rule: list_emb.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys. sum_weights [] \\<le> sum_weights ys\n 2. \\<And>xs ys y.\n       \\<lbrakk>xs \\<preceq> ys;\n        sum_weights xs \\<le> sum_weights ys\\<rbrakk>\n       \\<Longrightarrow> sum_weights xs \\<le> sum_weights (y # ys)\n 3. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        sum_weights xs \\<le> sum_weights ys\\<rbrakk>\n       \\<Longrightarrow> sum_weights (x # xs) \\<le> sum_weights (y # ys)", "case (list_emb_Nil ys)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>ys. sum_weights [] \\<le> sum_weights ys\n 2. \\<And>xs ys y.\n       \\<lbrakk>xs \\<preceq> ys;\n        sum_weights xs \\<le> sum_weights ys\\<rbrakk>\n       \\<Longrightarrow> sum_weights xs \\<le> sum_weights (y # ys)\n 3. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        sum_weights xs \\<le> sum_weights ys\\<rbrakk>\n       \\<Longrightarrow> sum_weights (x # xs) \\<le> sum_weights (y # ys)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_weights [] \\<le> sum_weights ys", "by auto"], ["proof (state)\nthis:\n  sum_weights [] \\<le> sum_weights ys\n\ngoal (2 subgoals):\n 1. \\<And>xs ys y.\n       \\<lbrakk>xs \\<preceq> ys;\n        sum_weights xs \\<le> sum_weights ys\\<rbrakk>\n       \\<Longrightarrow> sum_weights xs \\<le> sum_weights (y # ys)\n 2. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        sum_weights xs \\<le> sum_weights ys\\<rbrakk>\n       \\<Longrightarrow> sum_weights (x # xs) \\<le> sum_weights (y # ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys y.\n       \\<lbrakk>xs \\<preceq> ys;\n        sum_weights xs \\<le> sum_weights ys\\<rbrakk>\n       \\<Longrightarrow> sum_weights xs \\<le> sum_weights (y # ys)\n 2. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        sum_weights xs \\<le> sum_weights ys\\<rbrakk>\n       \\<Longrightarrow> sum_weights (x # xs) \\<le> sum_weights (y # ys)", "case (list_emb_Cons xs ys y)"], ["proof (state)\nthis:\n  xs \\<preceq> ys\n  sum_weights xs \\<le> sum_weights ys\n\ngoal (2 subgoals):\n 1. \\<And>xs ys y.\n       \\<lbrakk>xs \\<preceq> ys;\n        sum_weights xs \\<le> sum_weights ys\\<rbrakk>\n       \\<Longrightarrow> sum_weights xs \\<le> sum_weights (y # ys)\n 2. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        sum_weights xs \\<le> sum_weights ys\\<rbrakk>\n       \\<Longrightarrow> sum_weights (x # xs) \\<le> sum_weights (y # ys)", "then"], ["proof (chain)\npicking this:\n  xs \\<preceq> ys\n  sum_weights xs \\<le> sum_weights ys", "show ?case"], ["proof (prove)\nusing this:\n  xs \\<preceq> ys\n  sum_weights xs \\<le> sum_weights ys\n\ngoal (1 subgoal):\n 1. sum_weights xs \\<le> sum_weights (y # ys)", "by (auto elim!: order_trans simp: le_plus)"], ["proof (state)\nthis:\n  sum_weights xs \\<le> sum_weights (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        sum_weights xs \\<le> sum_weights ys\\<rbrakk>\n       \\<Longrightarrow> sum_weights (x # xs) \\<le> sum_weights (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        sum_weights xs \\<le> sum_weights ys\\<rbrakk>\n       \\<Longrightarrow> sum_weights (x # xs) \\<le> sum_weights (y # ys)", "case (list_emb_Cons2 x y xs ys)"], ["proof (state)\nthis:\n  x = y\n  xs \\<preceq> ys\n  sum_weights xs \\<le> sum_weights ys\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys.\n       \\<lbrakk>x = y; xs \\<preceq> ys;\n        sum_weights xs \\<le> sum_weights ys\\<rbrakk>\n       \\<Longrightarrow> sum_weights (x # xs) \\<le> sum_weights (y # ys)", "then"], ["proof (chain)\npicking this:\n  x = y\n  xs \\<preceq> ys\n  sum_weights xs \\<le> sum_weights ys", "show ?case"], ["proof (prove)\nusing this:\n  x = y\n  xs \\<preceq> ys\n  sum_weights xs \\<le> sum_weights ys\n\ngoal (1 subgoal):\n 1. sum_weights (x # xs) \\<le> sum_weights (y # ys)", "by (auto elim!: order_trans simp: plus_mono)"], ["proof (state)\nthis:\n  sum_weights (x # xs) \\<le> sum_weights (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subseq_sum_path_weights_le:\n  \"map LBL xs \\<preceq> map LBL ys \\<Longrightarrow> sum_path_weights xs \\<le> sum_path_weights ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(s, l, t). l) xs \\<preceq>\n    map (\\<lambda>(s, l, t). l) ys \\<Longrightarrow>\n    sum_weights (map (\\<lambda>(s, l, t). l) xs)\n    \\<le> sum_weights (map (\\<lambda>(s, l, t). l) ys)", "by (rule subseq_sum_weights_le)"], ["", "lemma sum_path_weights_take_le[simp, intro]: \"sum_path_weights (take i xs) \\<le> sum_path_weights xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_weights (map (\\<lambda>(s, l, t). l) (take i xs))\n    \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)", "by (auto intro!: subseq_sum_path_weights_le)"], ["", "lemma sum_weights_append_singleton:\n  \"sum_weights (xs @ [x]) = sum_weights xs + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_weights (xs @ [x]) = sum_weights xs + x", "by (induct xs) (simp_all add: add.assoc)"], ["", "lemma sum_path_weights_append_singleton:\n  \"sum_path_weights (xs @ [(l,x,l')]) = sum_path_weights xs + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_weights (map (\\<lambda>(s, l, t). l) (xs @ [(l, x, l')])) =\n    sum_weights (map (\\<lambda>(s, l, t). l) xs) + x", "by (induct xs) (simp_all add: add.assoc)"], ["", "lemma path_weightp_ex_path:\n  \"path_weightp l1 l2 s \\<Longrightarrow> \\<exists>xs.\n  (let s' = sum_path_weights xs in s' \\<le> s \\<and> path_weightp l1 l2 s' \\<and> distinct xs \\<and>\n  (\\<forall>(l1,s,l2) \\<in> set xs. s \\<in>\\<^sub>A weights l1 l2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_weightp l1 l2 s \\<Longrightarrow>\n    \\<exists>xs.\n       let s' = sum_weights (map (\\<lambda>(s, l, t). l) xs)\n       in s' \\<le> s \\<and>\n          path_weightp l1 l2 s' \\<and>\n          distinct xs \\<and>\n          (\\<forall>(l1, s, l2)\\<in>set xs. s \\<in>\\<^sub>A weights l1 l2)", "unfolding path_weightp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       path l1 l2 xs \\<and>\n       s = sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<Longrightarrow>\n    \\<exists>xs.\n       let s' = sum_weights (map (\\<lambda>(s, l, t). l) xs)\n       in s' \\<le> s \\<and>\n          (\\<exists>xs.\n              path l1 l2 xs \\<and>\n              s' = sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n          distinct xs \\<and>\n          (\\<forall>(l1, s, l2)\\<in>set xs. s \\<in>\\<^sub>A weights l1 l2)", "apply (erule exE conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>path l1 l2 xs;\n        s = sum_weights (map (\\<lambda>(s, l, t). l) xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            let s' = sum_weights\n(map (\\<lambda>(s, l, t). l) xs)\n                            in s' \\<le> s \\<and>\n                               (\\<exists>xs.\n                                   path l1 l2 xs \\<and>\n                                   s' =\n                                   sum_weights\n                                    (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                               distinct xs \\<and>\n                               (\\<forall>(l1, s, l2)\\<in>set xs.\n                                   s \\<in>\\<^sub>A weights l1 l2)", "apply (drule path_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>s = sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        \\<exists>xs'.\n           distinct xs' \\<and>\n           path l1 l2 xs' \\<and>\n           map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n           map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            let s' = sum_weights\n(map (\\<lambda>(s, l, t). l) xs)\n                            in s' \\<le> s \\<and>\n                               (\\<exists>xs.\n                                   path l1 l2 xs \\<and>\n                                   s' =\n                                   sum_weights\n                                    (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                               distinct xs \\<and>\n                               (\\<forall>(l1, s, l2)\\<in>set xs.\n                                   s \\<in>\\<^sub>A weights l1 l2)", "apply (erule exE conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xs'.\n       \\<lbrakk>s = sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        distinct xs'; path l1 l2 xs';\n        map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n        map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            let s' = sum_weights\n(map (\\<lambda>(s, l, t). l) xs)\n                            in s' \\<le> s \\<and>\n                               (\\<exists>xs.\n                                   path l1 l2 xs \\<and>\n                                   s' =\n                                   sum_weights\n                                    (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                               distinct xs \\<and>\n                               (\\<forall>(l1, s, l2)\\<in>set xs.\n                                   s \\<in>\\<^sub>A weights l1 l2)", "subgoal for xs xs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = sum_weights (map (\\<lambda>(s, l, t). l) xs); distinct xs';\n     path l1 l2 xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         let s' = sum_weights\n                                   (map (\\<lambda>(s, l, t). l) xs)\n                         in s' \\<le> s \\<and>\n                            (\\<exists>xs.\n                                path l1 l2 xs \\<and>\n                                s' =\n                                sum_weights\n                                 (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                            distinct xs \\<and>\n                            (\\<forall>(l1, s, l2)\\<in>set xs.\n                                s \\<in>\\<^sub>A weights l1 l2)", "apply (rule exI[of _ xs'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = sum_weights (map (\\<lambda>(s, l, t). l) xs); distinct xs';\n     path l1 l2 xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n    \\<Longrightarrow> let s' = sum_weights (map (\\<lambda>(s, l, t). l) xs')\n                      in s' \\<le> s \\<and>\n                         (\\<exists>xs.\n                             path l1 l2 xs \\<and>\n                             s' =\n                             sum_weights\n                              (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         distinct xs' \\<and>\n                         (\\<forall>(l1, s, l2)\\<in>set xs'.\n                             s \\<in>\\<^sub>A weights l1 l2)", "apply (auto simp: Let_def dest!: path_edge intro: subseq_sum_path_weights_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_set_summaries:\n  \"finite ((\\<lambda>((l1,l2),s). (l1,s,l2)) ` (Sigma UNIV (\\<lambda>(l1,l2). set_antichain (weights l1 l2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>((l1, l2), s). (l1, s, l2)) `\n      (SIGMA (l1, l2):UNIV. set_antichain (weights l1 l2)))", "by force"], ["", "lemma finite_summaries: \"finite {xs. distinct xs \\<and> (\\<forall>(l1, s, l2) \\<in> set xs. s \\<in>\\<^sub>A weights l1 l2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {xs.\n      distinct xs \\<and>\n      (\\<forall>(l1, s, l2)\\<in>set xs. s \\<in>\\<^sub>A weights l1 l2)}", "apply (rule finite_subset[OF _ finite_distinct_bounded[of \"((\\<lambda>((l1,l2),s). (l1,s,l2)) ` (Sigma UNIV (\\<lambda>(l1,l2). set_antichain (weights l1 l2))))\"]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {xs.\n     distinct xs \\<and>\n     (\\<forall>(l1, s, l2)\\<in>set xs. s \\<in>\\<^sub>A weights l1 l2)}\n    \\<subseteq> {xs.\n                 distinct xs \\<and>\n                 set xs\n                 \\<subseteq> (\\<lambda>((l1, l2), s). (l1, s, l2)) `\n                             (SIGMA (l1, l2):UNIV.\n                                 set_antichain (weights l1 l2))}\n 2. finite\n     ((\\<lambda>((l1, l2), s). (l1, s, l2)) `\n      (SIGMA (l1, l2):UNIV. set_antichain (weights l1 l2)))", "apply (force simp: finite_set_summaries)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_minimal_antichain_path_weightp:\n  \"finite (minimal_antichain {x. path_weightp l1 l2 x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (minimal_antichain {x. path_weightp l1 l2 x})", "apply (rule finite_surj[OF finite_summaries, where f = sum_path_weights])"], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_antichain {x. path_weightp l1 l2 x}\n    \\<subseteq> (\\<lambda>xs.\n                    sum_weights (map (\\<lambda>(s, l, t). l) xs)) `\n                {xs.\n                 distinct xs \\<and>\n                 (\\<forall>(l1, s, l2)\\<in>set xs.\n                     s \\<in>\\<^sub>A weights l1 l2)}", "apply (clarsimp simp: minimal_antichain_def image_iff dest!: path_weightp_ex_path)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<forall>y.\n                   path_weightp l1 l2 y \\<longrightarrow> \\<not> y < x;\n        let s' = sum_weights (map (\\<lambda>(s, l, t). l) xs)\n        in s' \\<le> x \\<and>\n           path_weightp l1 l2 s' \\<and>\n           distinct xs \\<and>\n           (\\<forall>x\\<in>set xs.\n               case x of\n               (l1, s, l2) \\<Rightarrow>\n                 s \\<in>\\<^sub>A weights l1 l2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            distinct xa \\<and>\n                            (\\<forall>x\\<in>set xa.\n                                case x of\n                                (l1, s, l2) \\<Rightarrow>\n                                  s \\<in>\\<^sub>A weights l1 l2) \\<and>\n                            x = sum_weights (map (\\<lambda>(s, l, t). l) xa)", "apply (fastforce simp: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* antichain of summaries along cycles-less paths (cycle-less = no edge repeated) *)"], ["", "lift_definition path_weight :: \"'vtx \\<Rightarrow> 'vtx \\<Rightarrow> 'lbl antichain\"\n  is \"\\<lambda>l1 l2. minimal_antichain {x. path_weightp l1 l2 x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vtx1 vtx2.\n       finite (minimal_antichain (Collect (path_weightp vtx1 vtx2))) \\<and>\n       incomparable (minimal_antichain (Collect (path_weightp vtx1 vtx2)))", "using finite_minimal_antichain_path_weightp"], ["proof (prove)\nusing this:\n  finite (minimal_antichain {x. path_weightp ?l1.0 ?l2.0 x})\n\ngoal (1 subgoal):\n 1. \\<And>vtx1 vtx2.\n       finite (minimal_antichain (Collect (path_weightp vtx1 vtx2))) \\<and>\n       incomparable (minimal_antichain (Collect (path_weightp vtx1 vtx2)))", "by auto"], ["", "definition \"reachable l1 l2 \\<equiv> path_weight l1 l2 \\<noteq> {}\\<^sub>A\""], ["", "lemma in_path_weight: \"s \\<in>\\<^sub>A path_weight loc1 loc2 \\<longleftrightarrow> s \\<in> minimal_antichain {s. path_weightp loc1 loc2 s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<in>\\<^sub>A path_weight loc1 loc2) =\n    (s \\<in> minimal_antichain {s. path_weightp loc1 loc2 s})", "by transfer simp"], ["", "lemma path_weight_refl[simp]: \"0 \\<in>\\<^sub>A path_weight loc loc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'lbl) \\<in>\\<^sub>A path_weight loc loc", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'lbl) \\<in>\\<^sub>A path_weight loc loc", "have *: \"path loc loc []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path loc loc []", "by (simp add: path0)"], ["proof (state)\nthis:\n  path loc loc []\n\ngoal (1 subgoal):\n 1. (0::'lbl) \\<in>\\<^sub>A path_weight loc loc", "then"], ["proof (chain)\npicking this:\n  path loc loc []", "have \"0 = sum_path_weights []\""], ["proof (prove)\nusing this:\n  path loc loc []\n\ngoal (1 subgoal):\n 1. (0::'lbl) = sum_weights (map (\\<lambda>(s, l, t). l) [])", "by auto"], ["proof (state)\nthis:\n  (0::'lbl) = sum_weights (map (\\<lambda>(s, l, t). l) [])\n\ngoal (1 subgoal):\n 1. (0::'lbl) \\<in>\\<^sub>A path_weight loc loc", "with *"], ["proof (chain)\npicking this:\n  path loc loc []\n  (0::'lbl) = sum_weights (map (\\<lambda>(s, l, t). l) [])", "have \"path_weightp loc loc 0\""], ["proof (prove)\nusing this:\n  path loc loc []\n  (0::'lbl) = sum_weights (map (\\<lambda>(s, l, t). l) [])\n\ngoal (1 subgoal):\n 1. path_weightp loc loc (0::'lbl)", "using path_weightp_def"], ["proof (prove)\nusing this:\n  path loc loc []\n  (0::'lbl) = sum_weights (map (\\<lambda>(s, l, t). l) [])\n  path_weightp ?l1.0 ?l2.0 ?s \\<equiv>\n  \\<exists>xs.\n     path ?l1.0 ?l2.0 xs \\<and>\n     ?s = sum_weights (map (\\<lambda>(s, l, t). l) xs)\n\ngoal (1 subgoal):\n 1. path_weightp loc loc (0::'lbl)", "by blast"], ["proof (state)\nthis:\n  path_weightp loc loc (0::'lbl)\n\ngoal (1 subgoal):\n 1. (0::'lbl) \\<in>\\<^sub>A path_weight loc loc", "then"], ["proof (chain)\npicking this:\n  path_weightp loc loc (0::'lbl)", "show ?thesis"], ["proof (prove)\nusing this:\n  path_weightp loc loc (0::'lbl)\n\ngoal (1 subgoal):\n 1. (0::'lbl) \\<in>\\<^sub>A path_weight loc loc", "by (auto simp: in_path_weight in_minimal_antichain)"], ["proof (state)\nthis:\n  (0::'lbl) \\<in>\\<^sub>A path_weight loc loc\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_in_minimal_antichain[simp]: \"(0::'lbl) \\<in> S \\<Longrightarrow> 0 \\<in> minimal_antichain S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'lbl) \\<in> S \\<Longrightarrow> (0::'lbl) \\<in> minimal_antichain S", "by (auto simp: in_minimal_antichain intro: sum_not_less_zero)"], ["", "definition \"path_weightp_distinct l1 l2 s \\<equiv> (\\<exists>xs. distinct xs \\<and> path l1 l2 xs \\<and> s = sum_path_weights xs)\""], ["", "lemma minimal_antichain_path_weightp_distinct:\n  \"minimal_antichain {xs. path_weightp l1 l2 xs} = minimal_antichain {xs. path_weightp_distinct l1 l2 xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_antichain {xs. path_weightp l1 l2 xs} =\n    minimal_antichain {xs. path_weightp_distinct l1 l2 xs}", "unfolding path_weightp_def path_weightp_distinct_def minimal_antichain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> {xs.\n              \\<exists>xsa.\n                 path l1 l2 xsa \\<and>\n                 xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}.\n     \\<not> (\\<exists>y\\<in>{xs.\n                             \\<exists>xsa.\n                                path l1 l2 xsa \\<and>\n                                xs =\n                                sum_weights\n                                 (map (\\<lambda>(s, l, t). l) xsa)}.\n                y < x)} =\n    {x \\<in> {xs.\n              \\<exists>xsa.\n                 distinct xsa \\<and>\n                 path l1 l2 xsa \\<and>\n                 xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}.\n     \\<not> (\\<exists>y\\<in>{xs.\n                             \\<exists>xsa.\n                                distinct xsa \\<and>\n                                path l1 l2 xsa \\<and>\n                                xs =\n                                sum_weights\n                                 (map (\\<lambda>(s, l, t). l) xsa)}.\n                y < x)}", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<not> (\\<exists>y\\<in>{xs.\n  \\<exists>xsa.\n     path l1 l2 xsa \\<and>\n     xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}.\n                           y < sum_weights\n                                (map (\\<lambda>(s, l, t). l) xs));\n        path l1 l2 xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            distinct xsa \\<and>\n                            path l1 l2 xsa \\<and>\n                            sum_weights (map (\\<lambda>(s, l, t). l) xs) =\n                            sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n 2. \\<And>x xs y xsa.\n       \\<lbrakk>\\<not> (\\<exists>y\\<in>{xs.\n  \\<exists>xsa.\n     path l1 l2 xsa \\<and>\n     xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}.\n                           y < sum_weights\n                                (map (\\<lambda>(s, l, t). l) xs));\n        path l1 l2 xs;\n        sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n        < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        distinct xsa; path l1 l2 xsa\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x xs.\n       \\<lbrakk>\\<not> (\\<exists>y\\<in>{xs.\n  \\<exists>xsa.\n     distinct xsa \\<and>\n     path l1 l2 xsa \\<and>\n     xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}.\n                           y < sum_weights\n                                (map (\\<lambda>(s, l, t). l) xs));\n        distinct xs; path l1 l2 xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            path l1 l2 xsa \\<and>\n                            sum_weights (map (\\<lambda>(s, l, t). l) xs) =\n                            sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n 4. \\<And>x xs y xsa.\n       \\<lbrakk>\\<not> (\\<exists>y\\<in>{xs.\n  \\<exists>xsa.\n     distinct xsa \\<and>\n     path l1 l2 xsa \\<and>\n     xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}.\n                           y < sum_weights\n                                (map (\\<lambda>(s, l, t). l) xs));\n        distinct xs; path l1 l2 xs;\n        sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n        < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        path l1 l2 xsa\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>y.\n                   (\\<forall>xs.\n                       path l1 l2 xs \\<longrightarrow>\n                       y \\<noteq>\n                       sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<or>\n                   \\<not> y < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        path l1 l2 xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            distinct xsa \\<and>\n                            path l1 l2 xsa \\<and>\n                            sum_weights (map (\\<lambda>(s, l, t). l) xs) =\n                            sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n 2. \\<And>x xs y xsa.\n       \\<lbrakk>\\<not> (\\<exists>y\\<in>{xs.\n  \\<exists>xsa.\n     path l1 l2 xsa \\<and>\n     xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}.\n                           y < sum_weights\n                                (map (\\<lambda>(s, l, t). l) xs));\n        path l1 l2 xs;\n        sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n        < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        distinct xsa; path l1 l2 xsa\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x xs.\n       \\<lbrakk>\\<not> (\\<exists>y\\<in>{xs.\n  \\<exists>xsa.\n     distinct xsa \\<and>\n     path l1 l2 xsa \\<and>\n     xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}.\n                           y < sum_weights\n                                (map (\\<lambda>(s, l, t). l) xs));\n        distinct xs; path l1 l2 xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            path l1 l2 xsa \\<and>\n                            sum_weights (map (\\<lambda>(s, l, t). l) xs) =\n                            sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n 4. \\<And>x xs y xsa.\n       \\<lbrakk>\\<not> (\\<exists>y\\<in>{xs.\n  \\<exists>xsa.\n     distinct xsa \\<and>\n     path l1 l2 xsa \\<and>\n     xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}.\n                           y < sum_weights\n                                (map (\\<lambda>(s, l, t). l) xs));\n        distinct xs; path l1 l2 xs;\n        sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n        < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        path l1 l2 xsa\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis path_distinct order.strict_iff_order subseq_sum_path_weights_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs y xsa.\n       \\<lbrakk>\\<not> (\\<exists>y\\<in>{xs.\n  \\<exists>xsa.\n     path l1 l2 xsa \\<and>\n     xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}.\n                           y < sum_weights\n                                (map (\\<lambda>(s, l, t). l) xs));\n        path l1 l2 xs;\n        sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n        < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        distinct xsa; path l1 l2 xsa\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x xs.\n       \\<lbrakk>\\<not> (\\<exists>y\\<in>{xs.\n  \\<exists>xsa.\n     distinct xsa \\<and>\n     path l1 l2 xsa \\<and>\n     xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}.\n                           y < sum_weights\n                                (map (\\<lambda>(s, l, t). l) xs));\n        distinct xs; path l1 l2 xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            path l1 l2 xsa \\<and>\n                            sum_weights (map (\\<lambda>(s, l, t). l) xs) =\n                            sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n 3. \\<And>x xs y xsa.\n       \\<lbrakk>\\<not> (\\<exists>y\\<in>{xs.\n  \\<exists>xsa.\n     distinct xsa \\<and>\n     path l1 l2 xsa \\<and>\n     xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}.\n                           y < sum_weights\n                                (map (\\<lambda>(s, l, t). l) xs));\n        distinct xs; path l1 l2 xs;\n        sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n        < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        path l1 l2 xsa\\<rbrakk>\n       \\<Longrightarrow> False", "apply (blast+) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y xsa.\n       \\<lbrakk>\\<not> (\\<exists>y\\<in>{xs.\n  \\<exists>xsa.\n     distinct xsa \\<and>\n     path l1 l2 xsa \\<and>\n     xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}.\n                           y < sum_weights\n                                (map (\\<lambda>(s, l, t). l) xs));\n        distinct xs; path l1 l2 xs;\n        sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n        < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        path l1 l2 xsa\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xsa.\n       \\<lbrakk>\\<forall>y.\n                   (\\<forall>xs.\n                       path l1 l2 xs \\<longrightarrow>\n                       distinct xs \\<longrightarrow>\n                       y \\<noteq>\n                       sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<or>\n                   \\<not> y < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        distinct xs; path l1 l2 xs;\n        sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n        < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        path l1 l2 xsa\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis (no_types, lifting) le_less_trans path_distinct subseq_sum_weights_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_path_weightp_distinct[simp, intro]: \"finite {xs. path_weightp_distinct l1 l2 xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. path_weightp_distinct l1 l2 xs}", "unfolding path_weightp_distinct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {xs.\n      \\<exists>xsa.\n         distinct xsa \\<and>\n         path l1 l2 xsa \\<and>\n         xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}", "apply (rule finite_subset[where B = \"sum_path_weights ` {xs. distinct xs \\<and> path l1 l2 xs}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {xs.\n     \\<exists>xsa.\n        distinct xsa \\<and>\n        path l1 l2 xsa \\<and>\n        xs = sum_weights (map (\\<lambda>(s, l, t). l) xsa)}\n    \\<subseteq> (\\<lambda>xs.\n                    sum_weights (map (\\<lambda>(s, l, t). l) xs)) `\n                {xs. distinct xs \\<and> path l1 l2 xs}\n 2. finite\n     ((\\<lambda>xs. sum_weights (map (\\<lambda>(s, l, t). l) xs)) `\n      {xs. distinct xs \\<and> path l1 l2 xs})", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>xs. sum_weights (map (\\<lambda>(s, l, t). l) xs)) `\n      {xs. distinct xs \\<and> path l1 l2 xs})", "apply (rule finite_imageI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. distinct xs \\<and> path l1 l2 xs}", "apply (rule finite_subset[OF _ finite_summaries])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. distinct xs \\<and> path l1 l2 xs}\n    \\<subseteq> {xs.\n                 distinct xs \\<and>\n                 (\\<forall>(l1, s, l2)\\<in>set xs.\n                     s \\<in>\\<^sub>A weights l1 l2)}", "apply (clarsimp simp: path_edge)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_weightp_distinct_nonempty:\n  \"{xs. path_weightp l1 l2 xs} \\<noteq> {} \\<longleftrightarrow> {xs. path_weightp_distinct l1 l2 xs} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({xs. path_weightp l1 l2 xs} \\<noteq> {}) =\n    ({xs. path_weightp_distinct l1 l2 xs} \\<noteq> {})", "by (auto dest: path_distinct simp: path_weightp_def path_weightp_distinct_def)"], ["", "lemma path_weightp_distinct_member:\n  \"s \\<in> {s. path_weightp l1 l2 s} \\<Longrightarrow> \\<exists>u. u \\<in> {s. path_weightp_distinct l1 l2 s} \\<and> u \\<le> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {s. path_weightp l1 l2 s} \\<Longrightarrow>\n    \\<exists>u. u \\<in> {s. path_weightp_distinct l1 l2 s} \\<and> u \\<le> s", "apply (clarsimp simp: path_weightp_def path_weightp_distinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>path l1 l2 xs;\n        s = sum_weights (map (\\<lambda>(s, l, t). l) xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u.\n                            (\\<exists>xs.\n                                distinct xs \\<and>\n                                path l1 l2 xs \\<and>\n                                u =\n                                sum_weights\n                                 (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                            u \\<le> sum_weights\n                                     (map (\\<lambda>(s, l, t). l) xs)", "apply (drule path_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>s = sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        \\<exists>xs'.\n           distinct xs' \\<and>\n           path l1 l2 xs' \\<and>\n           map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n           map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u.\n                            (\\<exists>xs.\n                                distinct xs \\<and>\n                                path l1 l2 xs \\<and>\n                                u =\n                                sum_weights\n                                 (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                            u \\<le> sum_weights\n                                     (map (\\<lambda>(s, l, t). l) xs)", "apply (auto dest: subseq_sum_path_weights_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma minimal_antichain_path_weightp_member:\n  \"s \\<in> {xs. path_weightp l1 l2 xs} \\<Longrightarrow> \\<exists>u. u \\<in> minimal_antichain {xs. path_weightp l1 l2 xs} \\<and> u \\<le> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {xs. path_weightp l1 l2 xs} \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in> minimal_antichain {xs. path_weightp l1 l2 xs} \\<and>\n       u \\<le> s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<in> {xs. path_weightp l1 l2 xs} \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in> minimal_antichain {xs. path_weightp l1 l2 xs} \\<and>\n       u \\<le> s", "assume \"s \\<in> {xs. path_weightp l1 l2 xs}\""], ["proof (state)\nthis:\n  s \\<in> {xs. path_weightp l1 l2 xs}\n\ngoal (1 subgoal):\n 1. s \\<in> {xs. path_weightp l1 l2 xs} \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in> minimal_antichain {xs. path_weightp l1 l2 xs} \\<and>\n       u \\<le> s", "then"], ["proof (chain)\npicking this:\n  s \\<in> {xs. path_weightp l1 l2 xs}", "obtain u where u: \"u \\<in> {s. path_weightp_distinct l1 l2 s} \\<and> u \\<le> s\""], ["proof (prove)\nusing this:\n  s \\<in> {xs. path_weightp l1 l2 xs}\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<in> {s. path_weightp_distinct l1 l2 s} \\<and>\n        u \\<le> s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using path_weightp_distinct_member"], ["proof (prove)\nusing this:\n  s \\<in> {xs. path_weightp l1 l2 xs}\n  ?s \\<in> {s. path_weightp ?l1.0 ?l2.0 s} \\<Longrightarrow>\n  \\<exists>u.\n     u \\<in> {s. path_weightp_distinct ?l1.0 ?l2.0 s} \\<and> u \\<le> ?s\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<in> {s. path_weightp_distinct l1 l2 s} \\<and>\n        u \\<le> s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u \\<in> {s. path_weightp_distinct l1 l2 s} \\<and> u \\<le> s\n\ngoal (1 subgoal):\n 1. s \\<in> {xs. path_weightp l1 l2 xs} \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in> minimal_antichain {xs. path_weightp l1 l2 xs} \\<and>\n       u \\<le> s", "have finite: \"finite {xs. path_weightp_distinct l1 l2 xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. path_weightp_distinct l1 l2 xs}", ".."], ["proof (state)\nthis:\n  finite {xs. path_weightp_distinct l1 l2 xs}\n\ngoal (1 subgoal):\n 1. s \\<in> {xs. path_weightp l1 l2 xs} \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in> minimal_antichain {xs. path_weightp l1 l2 xs} \\<and>\n       u \\<le> s", "from u finite"], ["proof (chain)\npicking this:\n  u \\<in> {s. path_weightp_distinct l1 l2 s} \\<and> u \\<le> s\n  finite {xs. path_weightp_distinct l1 l2 xs}", "obtain v where \"v \\<in> minimal_antichain {xs. path_weightp_distinct l1 l2 xs} \\<and> v \\<le> u\""], ["proof (prove)\nusing this:\n  u \\<in> {s. path_weightp_distinct l1 l2 s} \\<and> u \\<le> s\n  finite {xs. path_weightp_distinct l1 l2 xs}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> minimal_antichain\n                 {xs. path_weightp_distinct l1 l2 xs} \\<and>\n        v \\<le> u \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (auto intro: minimal_antichain_member)"], ["proof (state)\nthis:\n  v \\<in> minimal_antichain {xs. path_weightp_distinct l1 l2 xs} \\<and>\n  v \\<le> u\n\ngoal (1 subgoal):\n 1. s \\<in> {xs. path_weightp l1 l2 xs} \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in> minimal_antichain {xs. path_weightp l1 l2 xs} \\<and>\n       u \\<le> s", "with u"], ["proof (chain)\npicking this:\n  u \\<in> {s. path_weightp_distinct l1 l2 s} \\<and> u \\<le> s\n  v \\<in> minimal_antichain {xs. path_weightp_distinct l1 l2 xs} \\<and>\n  v \\<le> u", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> {s. path_weightp_distinct l1 l2 s} \\<and> u \\<le> s\n  v \\<in> minimal_antichain {xs. path_weightp_distinct l1 l2 xs} \\<and>\n  v \\<le> u\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in> minimal_antichain {xs. path_weightp l1 l2 xs} \\<and>\n       u \\<le> s", "by (auto simp: minimal_antichain_path_weightp_distinct)"], ["proof (state)\nthis:\n  \\<exists>u.\n     u \\<in> minimal_antichain {xs. path_weightp l1 l2 xs} \\<and> u \\<le> s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_path_weight: \"path l1 l2 xs \\<Longrightarrow> \\<exists>s. s \\<in>\\<^sub>A path_weight l1 l2 \\<and> s \\<le> sum_path_weights xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path l1 l2 xs \\<Longrightarrow>\n    \\<exists>s.\n       s \\<in>\\<^sub>A path_weight l1 l2 \\<and>\n       s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path l1 l2 xs \\<Longrightarrow>\n    \\<exists>s.\n       s \\<in>\\<^sub>A path_weight l1 l2 \\<and>\n       s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)", "assume \"path l1 l2 xs\""], ["proof (state)\nthis:\n  path l1 l2 xs\n\ngoal (1 subgoal):\n 1. path l1 l2 xs \\<Longrightarrow>\n    \\<exists>s.\n       s \\<in>\\<^sub>A path_weight l1 l2 \\<and>\n       s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)", "then"], ["proof (chain)\npicking this:\n  path l1 l2 xs", "have \"sum_path_weights xs \\<in> {x. path_weightp l1 l2 x}\""], ["proof (prove)\nusing this:\n  path l1 l2 xs\n\ngoal (1 subgoal):\n 1. sum_weights (map (\\<lambda>(s, l, t). l) xs)\n    \\<in> {x. path_weightp l1 l2 x}", "by (auto simp: path_weightp_def)"], ["proof (state)\nthis:\n  sum_weights (map (\\<lambda>(s, l, t). l) xs)\n  \\<in> {x. path_weightp l1 l2 x}\n\ngoal (1 subgoal):\n 1. path l1 l2 xs \\<Longrightarrow>\n    \\<exists>s.\n       s \\<in>\\<^sub>A path_weight l1 l2 \\<and>\n       s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)", "then"], ["proof (chain)\npicking this:\n  sum_weights (map (\\<lambda>(s, l, t). l) xs)\n  \\<in> {x. path_weightp l1 l2 x}", "obtain u where \"u \\<in> minimal_antichain {x. path_weightp l1 l2 x} \\<and> u \\<le> sum_path_weights xs\""], ["proof (prove)\nusing this:\n  sum_weights (map (\\<lambda>(s, l, t). l) xs)\n  \\<in> {x. path_weightp l1 l2 x}\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<in> minimal_antichain {x. path_weightp l1 l2 x} \\<and>\n        u \\<le> sum_weights\n                 (map (\\<lambda>(s, l, t). l) xs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_weights (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs)\n    \\<in> {x. path_weightp l1 l2 x} \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in> minimal_antichain (Collect (path_weightp l1 l2)) \\<and>\n       u \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)", "apply (drule minimal_antichain_path_weightp_member)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in> minimal_antichain {x. path_weightp l1 l2 x} \\<and>\n       u \\<le> sum_weights\n                (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n                  xs) \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in> minimal_antichain (Collect (path_weightp l1 l2)) \\<and>\n       u \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  u \\<in> minimal_antichain {x. path_weightp l1 l2 x} \\<and>\n  u \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)\n\ngoal (1 subgoal):\n 1. path l1 l2 xs \\<Longrightarrow>\n    \\<exists>s.\n       s \\<in>\\<^sub>A path_weight l1 l2 \\<and>\n       s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)", "then"], ["proof (chain)\npicking this:\n  u \\<in> minimal_antichain {x. path_weightp l1 l2 x} \\<and>\n  u \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> minimal_antichain {x. path_weightp l1 l2 x} \\<and>\n  u \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s \\<in>\\<^sub>A path_weight l1 l2 \\<and>\n       s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)", "by transfer auto"], ["proof (state)\nthis:\n  \\<exists>s.\n     s \\<in>\\<^sub>A path_weight l1 l2 \\<and>\n     s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_weight_conv_path:\n  \"s \\<in>\\<^sub>A path_weight l1 l2 \\<Longrightarrow> \\<exists>xs. path l1 l2 xs \\<and> s = sum_path_weights xs \\<and> (\\<forall>ys. path l1 l2 ys \\<longrightarrow> \\<not> sum_path_weights ys < sum_path_weights xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A path_weight l1 l2 \\<Longrightarrow>\n    \\<exists>xs.\n       path l1 l2 xs \\<and>\n       s = sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<and>\n       (\\<forall>ys.\n           path l1 l2 ys \\<longrightarrow>\n           \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ys)\n                  < sum_weights (map (\\<lambda>(s, l, t). l) xs))", "by transfer (auto simp: in_minimal_antichain path_weightp_def)"], ["", "abbreviation \"optimal_path loc1 loc2 xs \\<equiv> path loc1 loc2 xs \\<and>\n   (\\<forall>ys. path loc1 loc2 ys \\<longrightarrow> \\<not> sum_path_weights ys < sum_path_weights xs)\""], ["", "lemma path_weight_path: \"s \\<in>\\<^sub>A path_weight loc1 loc2 \\<Longrightarrow>\n  (\\<And>xs. optimal_path loc1 loc2 xs \\<Longrightarrow> distinct xs \\<Longrightarrow> sum_path_weights xs = s \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in>\\<^sub>A path_weight loc1 loc2;\n     \\<And>xs.\n        \\<lbrakk>path loc1 loc2 xs \\<and>\n                 (\\<forall>ys.\n                     path loc1 loc2 ys \\<longrightarrow>\n                     \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ys)\n                            < sum_weights (map (\\<lambda>(s, l, t). l) xs));\n         distinct xs;\n         sum_weights (map (\\<lambda>(s, l, t). l) xs) = s\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A path_weight loc1 loc2 \\<Longrightarrow>\n    \\<exists>xs.\n       (path loc1 loc2 xs \\<and>\n        (\\<forall>ys.\n            path loc1 loc2 ys \\<longrightarrow>\n            \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ys)\n                   < sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<and>\n       distinct xs \\<and> sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s loc1 loc2.\n       s \\<in> minimal_antichain\n                (Collect (path_weightp loc1 loc2)) \\<Longrightarrow>\n       \\<exists>xs.\n          (path loc1 loc2 xs \\<and>\n           (\\<forall>ys.\n               path loc1 loc2 ys \\<longrightarrow>\n               \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ys)\n                      < sum_weights\n                         (map (\\<lambda>(s, l, t). l) xs))) \\<and>\n          distinct xs \\<and>\n          sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "apply (clarsimp simp: in_minimal_antichain path_weightp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 xs.\n       \\<lbrakk>\\<forall>y.\n                   (\\<forall>xs.\n                       path loc1 loc2 xs \\<longrightarrow>\n                       y \\<noteq>\n                       sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<or>\n                   \\<not> y < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        path loc1 loc2 xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            path loc1 loc2 xsa \\<and>\n                            (\\<forall>ys.\n                                path loc1 loc2 ys \\<longrightarrow>\n                                \\<not> sum_weights\n  (map (\\<lambda>(s, l, t). l) ys)\n < sum_weights (map (\\<lambda>(s, l, t). l) xsa)) \\<and>\n                            distinct xsa \\<and>\n                            sum_weights (map (\\<lambda>(s, l, t). l) xsa) =\n                            sum_weights (map (\\<lambda>(s, l, t). l) xs)", "apply (drule path_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 xs.\n       \\<lbrakk>\\<forall>y.\n                   (\\<forall>xs.\n                       path loc1 loc2 xs \\<longrightarrow>\n                       y \\<noteq>\n                       sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<or>\n                   \\<not> y < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        \\<exists>xs'.\n           distinct xs' \\<and>\n           path loc1 loc2 xs' \\<and>\n           map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n           map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            path loc1 loc2 xsa \\<and>\n                            (\\<forall>ys.\n                                path loc1 loc2 ys \\<longrightarrow>\n                                \\<not> sum_weights\n  (map (\\<lambda>(s, l, t). l) ys)\n < sum_weights (map (\\<lambda>(s, l, t). l) xsa)) \\<and>\n                            distinct xsa \\<and>\n                            sum_weights (map (\\<lambda>(s, l, t). l) xsa) =\n                            sum_weights (map (\\<lambda>(s, l, t). l) xs)", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 xs xs'.\n       \\<lbrakk>\\<forall>y.\n                   (\\<forall>xs.\n                       path loc1 loc2 xs \\<longrightarrow>\n                       y \\<noteq>\n                       sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<or>\n                   \\<not> y < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        distinct xs' \\<and>\n        path loc1 loc2 xs' \\<and>\n        map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n        map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            path loc1 loc2 xsa \\<and>\n                            (\\<forall>ys.\n                                path loc1 loc2 ys \\<longrightarrow>\n                                \\<not> sum_weights\n  (map (\\<lambda>(s, l, t). l) ys)\n < sum_weights (map (\\<lambda>(s, l, t). l) xsa)) \\<and>\n                            distinct xsa \\<and>\n                            sum_weights (map (\\<lambda>(s, l, t). l) xsa) =\n                            sum_weights (map (\\<lambda>(s, l, t). l) xs)", "subgoal for loc1 loc2 xs xs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                (\\<forall>xs.\n                    path loc1 loc2 xs \\<longrightarrow>\n                    y \\<noteq>\n                    sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<or>\n                \\<not> y < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n     distinct xs' \\<and>\n     path loc1 loc2 xs' \\<and>\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xsa.\n                         path loc1 loc2 xsa \\<and>\n                         (\\<forall>ys.\n                             path loc1 loc2 ys \\<longrightarrow>\n                             \\<not> sum_weights\n                                     (map (\\<lambda>(s, l, t). l) ys)\n                                    < sum_weights\n (map (\\<lambda>(s, l, t). l) xsa)) \\<and>\n                         distinct xsa \\<and>\n                         sum_weights (map (\\<lambda>(s, l, t). l) xsa) =\n                         sum_weights (map (\\<lambda>(s, l, t). l) xs)", "apply (rule exI[of _ xs'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                (\\<forall>xs.\n                    path loc1 loc2 xs \\<longrightarrow>\n                    y \\<noteq>\n                    sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<or>\n                \\<not> y < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n     distinct xs' \\<and>\n     path loc1 loc2 xs' \\<and>\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n    \\<Longrightarrow> path loc1 loc2 xs' \\<and>\n                      (\\<forall>ys.\n                          path loc1 loc2 ys \\<longrightarrow>\n                          \\<not> sum_weights\n                                  (map (\\<lambda>(s, l, t). l) ys)\n                                 < sum_weights\n                                    (map (\\<lambda>(s, l, t). l)\nxs')) \\<and>\n                      distinct xs' \\<and>\n                      sum_weights (map (\\<lambda>(s, l, t). l) xs') =\n                      sum_weights (map (\\<lambda>(s, l, t). l) xs)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<forall>y.\n                   (\\<forall>xs.\n                       path loc1 loc2 xs \\<longrightarrow>\n                       y \\<noteq>\n                       sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<or>\n                   \\<not> y < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        distinct xs'; path loc1 loc2 xs';\n        map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n        map (\\<lambda>(s, l, t). l) xs;\n        path loc1 loc2 ys;\n        sum_weights (map (\\<lambda>(s, l, t). l) ys)\n        < sum_weights (map (\\<lambda>(s, l, t). l) xs')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>\\<forall>y.\n                (\\<forall>xs.\n                    path loc1 loc2 xs \\<longrightarrow>\n                    y \\<noteq>\n                    sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<or>\n                \\<not> y < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n     distinct xs'; path loc1 loc2 xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n    \\<Longrightarrow> sum_weights (map (\\<lambda>(s, l, t). l) xs') =\n                      sum_weights (map (\\<lambda>(s, l, t). l) xs)", "using order.strict_iff_order subseq_sum_path_weights_le"], ["proof (prove)\nusing this:\n  (?a < ?b) = (?a \\<le> ?b \\<and> ?a \\<noteq> ?b)\n  map (\\<lambda>(s, l, t). l) ?xs \\<preceq>\n  map (\\<lambda>(s, l, t). l) ?ys \\<Longrightarrow>\n  sum_weights (map (\\<lambda>(s, l, t). l) ?xs)\n  \\<le> sum_weights (map (\\<lambda>(s, l, t). l) ?ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<forall>y.\n                   (\\<forall>xs.\n                       path loc1 loc2 xs \\<longrightarrow>\n                       y \\<noteq>\n                       sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<or>\n                   \\<not> y < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        distinct xs'; path loc1 loc2 xs';\n        map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n        map (\\<lambda>(s, l, t). l) xs;\n        path loc1 loc2 ys;\n        sum_weights (map (\\<lambda>(s, l, t). l) ys)\n        < sum_weights (map (\\<lambda>(s, l, t). l) xs')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>\\<forall>y.\n                (\\<forall>xs.\n                    path loc1 loc2 xs \\<longrightarrow>\n                    y \\<noteq>\n                    sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<or>\n                \\<not> y < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n     distinct xs'; path loc1 loc2 xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n    \\<Longrightarrow> sum_weights (map (\\<lambda>(s, l, t). l) xs') =\n                      sum_weights (map (\\<lambda>(s, l, t). l) xs)", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                (\\<forall>xs.\n                    path loc1 loc2 xs \\<longrightarrow>\n                    y \\<noteq>\n                    sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<or>\n                \\<not> y < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n     distinct xs'; path loc1 loc2 xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n    \\<Longrightarrow> sum_weights (map (\\<lambda>(s, l, t). l) xs') =\n                      sum_weights (map (\\<lambda>(s, l, t). l) xs)", "using less_le subseq_sum_path_weights_le"], ["proof (prove)\nusing this:\n  (?x < ?y) = (?x \\<le> ?y \\<and> ?x \\<noteq> ?y)\n  map (\\<lambda>(s, l, t). l) ?xs \\<preceq>\n  map (\\<lambda>(s, l, t). l) ?ys \\<Longrightarrow>\n  sum_weights (map (\\<lambda>(s, l, t). l) ?xs)\n  \\<le> sum_weights (map (\\<lambda>(s, l, t). l) ?ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                (\\<forall>xs.\n                    path loc1 loc2 xs \\<longrightarrow>\n                    y \\<noteq>\n                    sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<or>\n                \\<not> y < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n     distinct xs'; path loc1 loc2 xs';\n     map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n     map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n    \\<Longrightarrow> sum_weights (map (\\<lambda>(s, l, t). l) xs') =\n                      sum_weights (map (\\<lambda>(s, l, t). l) xs)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_weight_elem_trans:\n  \"s \\<in>\\<^sub>A path_weight l1 l2 \\<Longrightarrow> s' \\<in>\\<^sub>A path_weight l2 l3 \\<Longrightarrow> \\<exists>u. u \\<in>\\<^sub>A path_weight l1 l3 \\<and> u \\<le> s + s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in>\\<^sub>A path_weight l1 l2;\n     s' \\<in>\\<^sub>A path_weight l2 l3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u.\n                         u \\<in>\\<^sub>A path_weight l1 l3 \\<and>\n                         u \\<le> s + s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in>\\<^sub>A path_weight l1 l2;\n     s' \\<in>\\<^sub>A path_weight l2 l3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u.\n                         u \\<in>\\<^sub>A path_weight l1 l3 \\<and>\n                         u \\<le> s + s'", "assume ps1: \"s  \\<in>\\<^sub>A path_weight l1 l2\""], ["proof (state)\nthis:\n  s \\<in>\\<^sub>A path_weight l1 l2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in>\\<^sub>A path_weight l1 l2;\n     s' \\<in>\\<^sub>A path_weight l2 l3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u.\n                         u \\<in>\\<^sub>A path_weight l1 l3 \\<and>\n                         u \\<le> s + s'", "assume ps2: \"s' \\<in>\\<^sub>A path_weight l2 l3\""], ["proof (state)\nthis:\n  s' \\<in>\\<^sub>A path_weight l2 l3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in>\\<^sub>A path_weight l1 l2;\n     s' \\<in>\\<^sub>A path_weight l2 l3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u.\n                         u \\<in>\\<^sub>A path_weight l1 l3 \\<and>\n                         u \\<le> s + s'", "from ps1"], ["proof (chain)\npicking this:\n  s \\<in>\\<^sub>A path_weight l1 l2", "obtain xs where path1: \"path l1 l2 xs\" \"s = sum_path_weights xs\""], ["proof (prove)\nusing this:\n  s \\<in>\\<^sub>A path_weight l1 l2\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>path l1 l2 xs;\n         s = sum_weights (map (\\<lambda>(s, l, t). l) xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: path_weight_path)"], ["proof (state)\nthis:\n  path l1 l2 xs\n  s = sum_weights (map (\\<lambda>(s, l, t). l) xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in>\\<^sub>A path_weight l1 l2;\n     s' \\<in>\\<^sub>A path_weight l2 l3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u.\n                         u \\<in>\\<^sub>A path_weight l1 l3 \\<and>\n                         u \\<le> s + s'", "from ps2"], ["proof (chain)\npicking this:\n  s' \\<in>\\<^sub>A path_weight l2 l3", "obtain ys where path2: \"path l2 l3 ys\" \"s' = sum_path_weights ys\""], ["proof (prove)\nusing this:\n  s' \\<in>\\<^sub>A path_weight l2 l3\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>path l2 l3 ys;\n         s' = sum_weights (map (\\<lambda>(s, l, t). l) ys)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: path_weight_path)"], ["proof (state)\nthis:\n  path l2 l3 ys\n  s' = sum_weights (map (\\<lambda>(s, l, t). l) ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in>\\<^sub>A path_weight l1 l2;\n     s' \\<in>\\<^sub>A path_weight l2 l3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u.\n                         u \\<in>\\<^sub>A path_weight l1 l3 \\<and>\n                         u \\<le> s + s'", "from path1(1) path2(1)"], ["proof (chain)\npicking this:\n  path l1 l2 xs\n  path l2 l3 ys", "have \"path l1 l3 (xs @ ys)\""], ["proof (prove)\nusing this:\n  path l1 l2 xs\n  path l2 l3 ys\n\ngoal (1 subgoal):\n 1. path l1 l3 (xs @ ys)", "by (rule path_trans)"], ["proof (state)\nthis:\n  path l1 l3 (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in>\\<^sub>A path_weight l1 l2;\n     s' \\<in>\\<^sub>A path_weight l2 l3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u.\n                         u \\<in>\\<^sub>A path_weight l1 l3 \\<and>\n                         u \\<le> s + s'", "with path1(2) path2(2)"], ["proof (chain)\npicking this:\n  s = sum_weights (map (\\<lambda>(s, l, t). l) xs)\n  s' = sum_weights (map (\\<lambda>(s, l, t). l) ys)\n  path l1 l3 (xs @ ys)", "have \"s + s' \\<in> {s. path_weightp l1 l3 s}\""], ["proof (prove)\nusing this:\n  s = sum_weights (map (\\<lambda>(s, l, t). l) xs)\n  s' = sum_weights (map (\\<lambda>(s, l, t). l) ys)\n  path l1 l3 (xs @ ys)\n\ngoal (1 subgoal):\n 1. s + s' \\<in> {s. path_weightp l1 l3 s}", "by (auto simp: path_weightp_def sum_weights_append[symmetric])"], ["proof (state)\nthis:\n  s + s' \\<in> {s. path_weightp l1 l3 s}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in>\\<^sub>A path_weight l1 l2;\n     s' \\<in>\\<^sub>A path_weight l2 l3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u.\n                         u \\<in>\\<^sub>A path_weight l1 l3 \\<and>\n                         u \\<le> s + s'", "then"], ["proof (chain)\npicking this:\n  s + s' \\<in> {s. path_weightp l1 l3 s}", "show \"\\<exists>u. u \\<in>\\<^sub>A path_weight l1 l3 \\<and> u \\<le> s + s'\""], ["proof (prove)\nusing this:\n  s + s' \\<in> {s. path_weightp l1 l3 s}\n\ngoal (1 subgoal):\n 1. \\<exists>u. u \\<in>\\<^sub>A path_weight l1 l3 \\<and> u \\<le> s + s'", "by transfer (simp add: minimal_antichain_path_weightp_member)"], ["proof (state)\nthis:\n  \\<exists>u. u \\<in>\\<^sub>A path_weight l1 l3 \\<and> u \\<le> s + s'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}