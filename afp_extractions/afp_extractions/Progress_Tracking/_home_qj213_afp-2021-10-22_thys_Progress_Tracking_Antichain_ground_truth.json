{"file_name": "/home/qj213/afp-2021-10-22/thys/Progress_Tracking/Antichain.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Progress_Tracking", "problem_names": ["lemma incomparable_empty[simp, intro]: \"incomparable {}\"", "lemma mem_antichain_nonempty[simp]: \"s \\<in>\\<^sub>A A \\<Longrightarrow> A \\<noteq> {}\\<^sub>A\"", "lemma in_minimal_antichain: \"x \\<in> minimal_antichain A \\<longleftrightarrow> x \\<in> A \\<and> \\<not>(\\<exists>y \\<in> A. y < x)\"", "lemma in_antichain_minimal_antichain[simp]: \"finite M \\<Longrightarrow> x \\<in>\\<^sub>A antichain (minimal_antichain M) \\<longleftrightarrow> x \\<in> minimal_antichain M\"", "lemma incomparable_minimal_antichain[simp]: \"incomparable (minimal_antichain A)\"", "lemma finite_minimal_antichain[simp]: \"finite A \\<Longrightarrow> finite (minimal_antichain A)\"", "lemma finite_set_antichain[simp, intro]: \"finite (set_antichain A)\"", "lemma minimal_antichain_subset: \"minimal_antichain A \\<subseteq> A\"", "lemma member_frontier_pos_zmset: \"t \\<in>\\<^sub>A frontier M \\<Longrightarrow> 0 < zcount M t\"", "lemma frontier_comparable_False[simp]: \"x \\<in>\\<^sub>A frontier M \\<Longrightarrow> y \\<in>\\<^sub>A frontier M \\<Longrightarrow> x < y \\<Longrightarrow> False\"", "lemma minimal_antichain_idempotent[simp]: \"minimal_antichain (minimal_antichain A) = minimal_antichain A\"", "lemma antichain_add_commute: \"(M :: 'a :: order antichain) + N = N + M\"", "lemma minimal_antichain_empty[simp]: \"minimal_antichain {} = {}\"", "lemma minimal_antichain_singleton[simp]: \"minimal_antichain {x::_ ::order} = {x}\"", "lemma minimal_antichain_nonempty:\n  \"finite A \\<Longrightarrow> (t::_::order) \\<in> A \\<Longrightarrow> minimal_antichain A \\<noteq> {}\"", "lemma minimal_antichain_member:\n  \"finite A \\<Longrightarrow> (t::_::order) \\<in> A \\<Longrightarrow> \\<exists>t'. t' \\<in> minimal_antichain A \\<and> t' \\<le> t\"", "lemma minimal_antichain_union: \"minimal_antichain ((A::(_ :: order) set) \\<union> B) \\<subseteq> minimal_antichain (minimal_antichain A \\<union> minimal_antichain B)\"", "lemma ac_Diff_iff: \"c \\<in>\\<^sub>A A - B \\<longleftrightarrow> c \\<in>\\<^sub>A A \\<and> c \\<notin>\\<^sub>A B\"", "lemma ac_DiffD2: \"c \\<in>\\<^sub>A A - B \\<Longrightarrow> c \\<in>\\<^sub>A B \\<Longrightarrow> P\"", "lemma ac_notin_Diff: \"\\<not> x \\<in>\\<^sub>A A - B \\<Longrightarrow> \\<not> x \\<in>\\<^sub>A A \\<or> x \\<in>\\<^sub>A B\"", "lemma ac_eq_iff: \"A = B \\<longleftrightarrow> (\\<forall>x. x \\<in>\\<^sub>A A \\<longleftrightarrow> x \\<in>\\<^sub>A B)\"", "lemma antichain_obtain_foundation:\n  assumes   \"t \\<in>\\<^sub>A M\"\n  obtains s where \"s \\<in>\\<^sub>A M \\<and> s \\<le> t \\<and> (\\<forall>u. u\\<in>\\<^sub>AM \\<longrightarrow> \\<not> u < s)\"", "lemma set_antichain1[simp]: \"x \\<in> set_antichain X \\<Longrightarrow> x \\<in>\\<^sub>A X\"", "lemma set_antichain2[simp]: \"x \\<in>\\<^sub>A X \\<Longrightarrow> x \\<in> set_antichain X\""], "translations": [["", "lemma incomparable_empty[simp, intro]: \"incomparable {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incomparable {}", "unfolding incomparable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{}.\n       \\<forall>y\\<in>{}.\n          x \\<noteq> y \\<longrightarrow> \\<not> x < y \\<and> \\<not> y < x", "by auto"], ["", "typedef (overloaded) 'a :: order antichain =\n  \"{A :: 'a set. finite A \\<and> incomparable A}\"\n  morphisms set_antichain antichain"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {A. finite A \\<and> incomparable A}", "by auto"], ["", "setup_lifting type_definition_antichain"], ["", "lift_definition member_antichain :: \"'a :: order \\<Rightarrow> 'a antichain \\<Rightarrow> bool\" (\"(_/ \\<in>\\<^sub>A _)\" [51, 51] 50) is \"Set.member\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation not_member_antichain :: \"'a :: order \\<Rightarrow> 'a antichain \\<Rightarrow> bool\" (\"(_/ \\<notin>\\<^sub>A _)\" [51, 51] 50) where\n  \"x \\<notin>\\<^sub>A A \\<equiv> \\<not> x \\<in>\\<^sub>A A\""], ["", "lift_definition empty_antichain :: \"'a :: order antichain\" (\"{}\\<^sub>A\") is \"{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {} \\<and> incomparable {}", "by simp"], ["", "lemma mem_antichain_nonempty[simp]: \"s \\<in>\\<^sub>A A \\<Longrightarrow> A \\<noteq> {}\\<^sub>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A A \\<Longrightarrow> A \\<noteq> {}\\<^sub>A", "by transfer auto"], ["", "definition \"minimal_antichain A = {x \\<in> A. \\<not>(\\<exists>y \\<in> A. y < x)}\""], ["", "lemma in_minimal_antichain: \"x \\<in> minimal_antichain A \\<longleftrightarrow> x \\<in> A \\<and> \\<not>(\\<exists>y \\<in> A. y < x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> minimal_antichain A) =\n    (x \\<in> A \\<and> \\<not> (\\<exists>y\\<in>A. y < x))", "unfolding minimal_antichain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> {x \\<in> A. \\<not> (\\<exists>y\\<in>A. y < x)}) =\n    (x \\<in> A \\<and> \\<not> (\\<exists>y\\<in>A. y < x))", "by auto"], ["", "lemma in_antichain_minimal_antichain[simp]: \"finite M \\<Longrightarrow> x \\<in>\\<^sub>A antichain (minimal_antichain M) \\<longleftrightarrow> x \\<in> minimal_antichain M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite M \\<Longrightarrow>\n    (x \\<in>\\<^sub>A antichain (minimal_antichain M)) =\n    (x \\<in> minimal_antichain M)", "apply (clarsimp simp: minimal_antichain_def member_antichain.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite M \\<Longrightarrow>\n    (x \\<in> set_antichain\n              (antichain {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x})) =\n    (x \\<in> M \\<and> (\\<forall>y\\<in>M. \\<not> y < x))", "apply (intro conjI iffI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite M;\n     x \\<in> set_antichain\n              (antichain\n                {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x})\\<rbrakk>\n    \\<Longrightarrow> x \\<in> M\n 2. \\<lbrakk>finite M;\n     x \\<in> set_antichain\n              (antichain\n                {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x})\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>M. \\<not> y < x\n 3. \\<lbrakk>finite M;\n     x \\<in> M \\<and> (\\<forall>y\\<in>M. \\<not> y < x)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set_antichain\n                               (antichain\n                                 {x \\<in> M.\n                                  \\<forall>y\\<in>M. \\<not> y < x})", "apply (subst (asm) antichain_inverse)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite M \\<Longrightarrow>\n    {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x}\n    \\<in> {A. finite A \\<and> incomparable A}\n 2. \\<lbrakk>finite M;\n     x \\<in> {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x}\\<rbrakk>\n    \\<Longrightarrow> x \\<in> M\n 3. \\<lbrakk>finite M;\n     x \\<in> set_antichain\n              (antichain\n                {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x})\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>M. \\<not> y < x\n 4. \\<lbrakk>finite M;\n     x \\<in> M \\<and> (\\<forall>y\\<in>M. \\<not> y < x)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set_antichain\n                               (antichain\n                                 {x \\<in> M.\n                                  \\<forall>y\\<in>M. \\<not> y < x})", "apply (simp add: incomparable_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite M;\n     x \\<in> {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x}\\<rbrakk>\n    \\<Longrightarrow> x \\<in> M\n 2. \\<lbrakk>finite M;\n     x \\<in> set_antichain\n              (antichain\n                {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x})\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>M. \\<not> y < x\n 3. \\<lbrakk>finite M;\n     x \\<in> M \\<and> (\\<forall>y\\<in>M. \\<not> y < x)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set_antichain\n                               (antichain\n                                 {x \\<in> M.\n                                  \\<forall>y\\<in>M. \\<not> y < x})", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite M;\n     x \\<in> set_antichain\n              (antichain\n                {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x})\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>M. \\<not> y < x\n 2. \\<lbrakk>finite M;\n     x \\<in> M \\<and> (\\<forall>y\\<in>M. \\<not> y < x)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set_antichain\n                               (antichain\n                                 {x \\<in> M.\n                                  \\<forall>y\\<in>M. \\<not> y < x})", "apply (subst (asm) antichain_inverse)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite M \\<Longrightarrow>\n    {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x}\n    \\<in> {A. finite A \\<and> incomparable A}\n 2. \\<lbrakk>finite M;\n     x \\<in> {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>M. \\<not> y < x\n 3. \\<lbrakk>finite M;\n     x \\<in> M \\<and> (\\<forall>y\\<in>M. \\<not> y < x)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set_antichain\n                               (antichain\n                                 {x \\<in> M.\n                                  \\<forall>y\\<in>M. \\<not> y < x})", "apply (simp add: incomparable_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite M;\n     x \\<in> {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>M. \\<not> y < x\n 2. \\<lbrakk>finite M;\n     x \\<in> M \\<and> (\\<forall>y\\<in>M. \\<not> y < x)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set_antichain\n                               (antichain\n                                 {x \\<in> M.\n                                  \\<forall>y\\<in>M. \\<not> y < x})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite M;\n     x \\<in> M \\<and> (\\<forall>y\\<in>M. \\<not> y < x)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set_antichain\n                               (antichain\n                                 {x \\<in> M.\n                                  \\<forall>y\\<in>M. \\<not> y < x})", "apply (subst antichain_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite M;\n     x \\<in> M \\<and> (\\<forall>y\\<in>M. \\<not> y < x)\\<rbrakk>\n    \\<Longrightarrow> {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x}\n                      \\<in> {A. finite A \\<and> incomparable A}\n 2. \\<lbrakk>finite M;\n     x \\<in> M \\<and> (\\<forall>y\\<in>M. \\<not> y < x)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x}", "apply (simp add: incomparable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite M;\n     x \\<in> M \\<and> (\\<forall>y\\<in>M. \\<not> y < x)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {x \\<in> M. \\<forall>y\\<in>M. \\<not> y < x}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma incomparable_minimal_antichain[simp]: \"incomparable (minimal_antichain A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incomparable (minimal_antichain A)", "unfolding incomparable_def minimal_antichain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> A. \\<not> (\\<exists>y\\<in>A. y < x)}.\n       \\<forall>y\\<in>{x \\<in> A. \\<not> (\\<exists>y\\<in>A. y < x)}.\n          x \\<noteq> y \\<longrightarrow> \\<not> x < y \\<and> \\<not> y < x", "by auto"], ["", "lemma finite_minimal_antichain[simp]: \"finite A \\<Longrightarrow> finite (minimal_antichain A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> finite (minimal_antichain A)", "unfolding minimal_antichain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    finite {x \\<in> A. \\<not> (\\<exists>y\\<in>A. y < x)}", "by auto"], ["", "lemma finite_set_antichain[simp, intro]: \"finite (set_antichain A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_antichain A)", "by transfer auto"], ["", "lemma minimal_antichain_subset: \"minimal_antichain A \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_antichain A \\<subseteq> A", "unfolding minimal_antichain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> A. \\<not> (\\<exists>y\\<in>A. y < x)} \\<subseteq> A", "by auto"], ["", "lift_definition frontier :: \"'t :: order zmultiset \\<Rightarrow> 't antichain\" is\n  \"\\<lambda>M. minimal_antichain {t. zcount M t > 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zmultiset.\n       finite (minimal_antichain {t. 0 < zcount zmultiset t}) \\<and>\n       incomparable (minimal_antichain {t. 0 < zcount zmultiset t})", "by (auto simp: finite_subset[OF minimal_antichain_subset finite_zcount_pos])"], ["", "lemma member_frontier_pos_zmset: \"t \\<in>\\<^sub>A frontier M \\<Longrightarrow> 0 < zcount M t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in>\\<^sub>A frontier M \\<Longrightarrow> 0 < zcount M t", "by (simp add: frontier_def in_minimal_antichain)"], ["", "lemma frontier_comparable_False[simp]: \"x \\<in>\\<^sub>A frontier M \\<Longrightarrow> y \\<in>\\<^sub>A frontier M \\<Longrightarrow> x < y \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in>\\<^sub>A frontier M; y \\<in>\\<^sub>A frontier M;\n     x < y\\<rbrakk>\n    \\<Longrightarrow> False", "by transfer (auto simp: minimal_antichain_def)"], ["", "lemma minimal_antichain_idempotent[simp]: \"minimal_antichain (minimal_antichain A) = minimal_antichain A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_antichain (minimal_antichain A) = minimal_antichain A", "by (auto simp: minimal_antichain_def)"], ["", "instantiation antichain :: (order) minus begin"], ["", "lift_definition minus_antichain :: \"'a antichain \\<Rightarrow> 'a antichain \\<Rightarrow> 'a antichain\" is \"(-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       \\<lbrakk>finite set1 \\<and> incomparable set1;\n        finite set2 \\<and> incomparable set2\\<rbrakk>\n       \\<Longrightarrow> finite (set1 - set2) \\<and>\n                         incomparable (set1 - set2)", "by (auto simp: incomparable_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a antichain, minus_class)", ".."], ["", "end"], ["", "instantiation antichain :: (order) plus begin"], ["", "lift_definition plus_antichain :: \"'a antichain \\<Rightarrow> 'a antichain \\<Rightarrow> 'a antichain\" is \"\\<lambda>M N. minimal_antichain (M \\<union> N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       \\<lbrakk>finite set1 \\<and> incomparable set1;\n        finite set2 \\<and> incomparable set2\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (minimal_antichain (set1 \\<union> set2)) \\<and>\n                         incomparable\n                          (minimal_antichain (set1 \\<union> set2))", "by (auto simp: incomparable_def minimal_antichain_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a antichain, plus_class)", ".."], ["", "end"], ["", "lemma antichain_add_commute: \"(M :: 'a :: order antichain) + N = N + M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M + N = N + M", "by transfer (auto simp: incomparable_def sup_commute)"], ["", "lift_definition filter_antichain :: \"('a :: order \\<Rightarrow> bool) \\<Rightarrow> 'a antichain \\<Rightarrow> 'a antichain\" is \"Set.filter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun set.\n       finite set \\<and> incomparable set \\<Longrightarrow>\n       finite (Set.filter fun set) \\<and> incomparable (Set.filter fun set)", "by (auto simp: incomparable_def)"], ["", "syntax (ASCII)\n  \"_ACCollect\" :: \"pttrn \\<Rightarrow> 'a :: order antichain \\<Rightarrow> bool \\<Rightarrow> 'a antichain\" (\"(1{_ :\\<^sub>A _./ _})\")"], ["", "syntax\n  \"_ACCollect\" :: \"pttrn \\<Rightarrow> 'a :: order antichain \\<Rightarrow> bool \\<Rightarrow> 'a antichain\" (\"(1{_ \\<in>\\<^sub>A _./ _})\")"], ["", "translations\n  \"{x \\<in>\\<^sub>A M. P}\" == \"CONST filter_antichain (\\<lambda>x. P) M\""], ["", "declare empty_antichain.rep_eq[simp]"], ["", "lemma minimal_antichain_empty[simp]: \"minimal_antichain {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_antichain {} = {}", "by (simp add: minimal_antichain_def)"], ["", "lemma minimal_antichain_singleton[simp]: \"minimal_antichain {x::_ ::order} = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_antichain {x} = {x}", "by (auto simp: minimal_antichain_def)"], ["", "lemma minimal_antichain_nonempty:\n  \"finite A \\<Longrightarrow> (t::_::order) \\<in> A \\<Longrightarrow> minimal_antichain A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; t \\<in> A\\<rbrakk>\n    \\<Longrightarrow> minimal_antichain A \\<noteq> {}", "by (auto simp: minimal_antichain_def dest: order_finite_set_exists_foundation[of _ t])"], ["", "lemma minimal_antichain_member:\n  \"finite A \\<Longrightarrow> (t::_::order) \\<in> A \\<Longrightarrow> \\<exists>t'. t' \\<in> minimal_antichain A \\<and> t' \\<le> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; t \\<in> A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in> minimal_antichain A \\<and> t' \\<le> t", "by (auto simp: minimal_antichain_def dest: order_finite_set_exists_foundation[of _ t])"], ["", "lemma minimal_antichain_union: \"minimal_antichain ((A::(_ :: order) set) \\<union> B) \\<subseteq> minimal_antichain (minimal_antichain A \\<union> minimal_antichain B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_antichain (A \\<union> B)\n    \\<subseteq> minimal_antichain\n                 (minimal_antichain A \\<union> minimal_antichain B)", "by (auto simp: minimal_antichain_def)"], ["", "lemma ac_Diff_iff: \"c \\<in>\\<^sub>A A - B \\<longleftrightarrow> c \\<in>\\<^sub>A A \\<and> c \\<notin>\\<^sub>A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c \\<in>\\<^sub>A A - B) =\n    (c \\<in>\\<^sub>A A \\<and> c \\<notin>\\<^sub>A B)", "by transfer simp"], ["", "lemma ac_DiffD2: \"c \\<in>\\<^sub>A A - B \\<Longrightarrow> c \\<in>\\<^sub>A B \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<in>\\<^sub>A A - B; c \\<in>\\<^sub>A B\\<rbrakk>\n    \\<Longrightarrow> P", "by transfer simp"], ["", "lemma ac_notin_Diff: \"\\<not> x \\<in>\\<^sub>A A - B \\<Longrightarrow> \\<not> x \\<in>\\<^sub>A A \\<or> x \\<in>\\<^sub>A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin>\\<^sub>A A - B \\<Longrightarrow>\n    x \\<notin>\\<^sub>A A \\<or> x \\<in>\\<^sub>A B", "by transfer simp"], ["", "lemma ac_eq_iff: \"A = B \\<longleftrightarrow> (\\<forall>x. x \\<in>\\<^sub>A A \\<longleftrightarrow> x \\<in>\\<^sub>A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A = B) = (\\<forall>x. (x \\<in>\\<^sub>A A) = (x \\<in>\\<^sub>A B))", "by transfer auto"], ["", "lemma antichain_obtain_foundation:\n  assumes   \"t \\<in>\\<^sub>A M\"\n  obtains s where \"s \\<in>\\<^sub>A M \\<and> s \\<le> t \\<and> (\\<forall>u. u\\<in>\\<^sub>AM \\<longrightarrow> \\<not> u < s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in>\\<^sub>A M \\<and>\n        s \\<le> t \\<and>\n        (\\<forall>u.\n            u \\<in>\\<^sub>A M \\<longrightarrow>\n            \\<not> u < s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  t \\<in>\\<^sub>A M\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in>\\<^sub>A M \\<and>\n        s \\<le> t \\<and>\n        (\\<forall>u.\n            u \\<in>\\<^sub>A M \\<longrightarrow>\n            \\<not> u < s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding member_antichain.rep_eq"], ["proof (prove)\nusing this:\n  t \\<in> set_antichain M\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> set_antichain M \\<and>\n        s \\<le> t \\<and>\n        (\\<forall>u.\n            u \\<in> set_antichain M \\<longrightarrow>\n            \\<not> u < s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by - (rule order_finite_set_obtain_foundation[of \"set_antichain M\" t]; auto)"], ["", "lemma set_antichain1[simp]: \"x \\<in> set_antichain X \\<Longrightarrow> x \\<in>\\<^sub>A X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set_antichain X \\<Longrightarrow> x \\<in>\\<^sub>A X", "by transfer simp"], ["", "lemma set_antichain2[simp]: \"x \\<in>\\<^sub>A X \\<Longrightarrow> x \\<in> set_antichain X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in>\\<^sub>A X \\<Longrightarrow> x \\<in> set_antichain X", "by transfer simp"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}