{"file_name": "/home/qj213/afp-2021-10-22/thys/Progress_Tracking/Exchange_Abadi.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Progress_Tracking", "problem_names": ["lemma upright_alt:  \"upright a \\<longleftrightarrow> (\\<forall>t. zcount a t > 0 \\<longrightarrow> supported_strong a t)\"", "lemma beta_upright_alt:\n  \"beta_upright va vb = (\\<forall>t. zcount va t > 0 \\<longrightarrow> (\\<exists>s. s < t \\<and> (zcount va s < 0 \\<or> zcount vb s < 0) \\<and> nonpos_upto va s))\"", "lemma init_InvTempUpright: \"init_config c \\<Longrightarrow> InvTempUpright c\"", "lemma upright_obtain_support:\n  assumes \"upright a\"\n    and \"zcount a t > 0\"\n  obtains s where \"s < t\" \"zcount a s < 0\" \"nonpos_upto a s\"", "lemma upright_vec_add:\n  assumes \"upright v1\"\n    and   \"upright v2\"\n  shows   \"upright (v1 + v2)\"", "lemma next_InvTempUpright: \"holds InvTempUpright s \\<Longrightarrow> next s \\<Longrightarrow> nxt (holds InvTempUpright) s\"", "lemma alw_InvTempUpright: \"spec s \\<Longrightarrow> alw (holds InvTempUpright) s\"", "lemma upright_0: \"upright 0\"", "lemma init_InvIncomingInfoUpright: \"init_config c \\<Longrightarrow> InvIncomingInfoUpright c\"", "lemma next_InvIncomingInfoUpright: \"holds InvIncomingInfoUpright s \\<Longrightarrow> next s \\<Longrightarrow> nxt (holds InvIncomingInfoUpright) s\"", "lemma alw_InvIncomingInfoUpright: \"spec s \\<Longrightarrow> alw (holds InvIncomingInfoUpright) s\"", "lemma init_InvGlobalRecordCount: \"holds init_config s \\<Longrightarrow> holds InvGlobalRecordCount s\"", "lemma if_eq_same: \"(if a = b then f b else f a) = f a\"", "lemma next_InvGlobalRecordCount: \"holds InvGlobalRecordCount s \\<Longrightarrow> next s \\<Longrightarrow> nxt (holds InvGlobalRecordCount) s\"", "lemma alw_InvGlobalRecordCount: \"spec s \\<Longrightarrow> alw (holds InvGlobalRecordCount) s\"", "lemma upright_sum_upright: \"finite X \\<Longrightarrow> \\<forall>x. upright (A x) \\<Longrightarrow> upright (\\<Sum>x\\<in>X. A x)\"", "lemma InvIncomingInfoUpright_imp_InvGlobalIncomingInfoUpright: \"holds InvIncomingInfoUpright s \\<Longrightarrow> holds InvGlobalIncomingInfoUpright s\"", "lemma alw_InvGlobalIncomingInfoUpright: \"spec s \\<Longrightarrow> alw (holds InvGlobalIncomingInfoUpright) s\"", "lemma init_nrec_pos: \"holds init_config s \\<Longrightarrow> holds nrec_pos s\"", "lemma next_nrec_pos: \"holds nrec_pos s \\<Longrightarrow> next s \\<Longrightarrow> nxt (holds nrec_pos) s\"", "lemma alw_nrec_pos: \"spec s \\<Longrightarrow> alw (holds nrec_pos) s\"", "lemma next_performop_vacant:\n  \"vacant_upto (c_records (shd s)) t \\<Longrightarrow> next_performop s \\<Longrightarrow> vacant_upto (c_records (shd (stl s))) t\"", "lemma next_sendupd_vacant:\n  \"vacant_upto (c_records (shd s)) t \\<Longrightarrow> next_sendupd s \\<Longrightarrow> vacant_upto (c_records (shd (stl s))) t\"", "lemma next_recvupd_vacant:\n  \"vacant_upto (c_records (shd s)) t \\<Longrightarrow> next_recvupd s \\<Longrightarrow> vacant_upto (c_records (shd (stl s))) t\"", "lemma spec_imp_SafeStickyNrecVacantUpto_aux: \"alw next s \\<Longrightarrow> alw SafeStickyNrecVacantUpto s\"", "lemma spec_imp_SafeStickyNrecVacantUpto: \"spec s \\<Longrightarrow> alw SafeStickyNrecVacantUpto s\"", "lemma invs_imp_InvGlobVacantUptoImpliesNrec:\n  assumes \"holds InvGlobalIncomingInfoUpright s\"\n  assumes \"holds InvGlobalRecordCount s\"\n  assumes \"holds nrec_pos s\"\n  shows \"holds InvGlobVacantUptoImpliesNrec s\"", "lemma spec_imp_inv1: \"spec s \\<Longrightarrow> alw (holds InvGlobVacantUptoImpliesNrec) s\"", "lemma safe2_inv1_imp_safe: \"SafeStickyNrecVacantUpto s \\<Longrightarrow> holds InvGlobVacantUptoImpliesNrec s \\<Longrightarrow> SafeGlobVacantUptoImpliesStickyNrec s\"", "lemma spec_imp_safe: \"spec s \\<Longrightarrow> alw SafeGlobVacantUptoImpliesStickyNrec s\"", "lemma beta_upright_0: \"beta_upright 0 vb\"", "lemma betaupright_PositiveImplies: \"upright (va + vb) \\<Longrightarrow> PositiveImplies va (va + vb) \\<Longrightarrow> beta_upright va vb\"", "lemma betaupright_obtain_support:\n  assumes \"beta_upright va vb\"\n    \"zcount va t > 0\"\n  obtains s where \"s < t\" \"zcount va s < 0 \\<or> zcount vb s < 0\" \"nonpos_upto va s\"", "lemma betaupright_upright_vut:\n  assumes \"beta_upright va vb\"\n    and     \"upright vb\"\n    and     \"vacant_upto (va + vb) t\"\n  shows   \"vacant_upto va t\"", "lemma beta_upright_add:\n  assumes \"upright vb\"\n    and     \"upright vc\"\n    and     \"beta_upright va vb\"\n  shows   \"beta_upright va (vb + vc)\"", "lemma init_InvInfoAtBetaUpright: \"init_config c \\<Longrightarrow> InvInfoAtBetaUpright c\"", "lemma next_inv[consumes 1, case_names next_performop next_sendupd next_recvupd stutter]:\n  assumes \"next s\"\n    and     \"next_performop s \\<Longrightarrow> P\"\n    and     \"next_sendupd s \\<Longrightarrow> P\"\n    and     \"next_recvupd s \\<Longrightarrow> P\"\n    and     \"shd (stl s) = shd s \\<Longrightarrow> P\"\n  shows   \"P\"", "lemma next_InvInfoAtBetaUpright:\n  assumes a1: \"next s\"\n    and     a2: \"InvInfoAtBetaUpright (shd s)\"\n    and     a3: \"InvIncomingInfoUpright (shd s)\"\n    and     a4: \"InvTempUpright (shd s)\"\n  shows   \"InvInfoAtBetaUpright (shd (stl s))\"", "lemma alw_InvInfoAtBetaUpright_aux: \"alw (holds InvTempUpright) s \\<Longrightarrow> alw (holds InvIncomingInfoUpright) s \\<Longrightarrow> holds InvInfoAtBetaUpright s \\<Longrightarrow> alw next s \\<Longrightarrow> alw (holds InvInfoAtBetaUpright) s\"", "lemma alw_InvInfoAtBetaUpright: \"spec s \\<Longrightarrow> alw (holds InvInfoAtBetaUpright) s\"", "lemma finite_induct_select [consumes 1, case_names empty select]:\n  assumes \"finite S\"\n    and empty: \"P {}\"\n    and select: \"\\<And>T. finite T \\<Longrightarrow> T \\<subset> S \\<Longrightarrow> P T \\<Longrightarrow> \\<exists>s\\<in>S - T. P (insert s T)\"\n  shows \"P S\"", "lemma predicate_sum_decompose:\n  fixes f :: \"'a \\<Rightarrow> ('b :: ab_group_add)\"\n  assumes \"finite X\"\n    and     \"x\\<in>X\"\n    and     \"A (f x)\"\n    and     \"\\<forall>Z. B (sum f Z)\"\n    and     \"\\<And>x Z. A (f x) \\<Longrightarrow> B (sum f Z) \\<Longrightarrow> A (f x + sum f Z)\"\n    and     \"\\<And>x Z. B (f x) \\<Longrightarrow> A (sum f Z) \\<Longrightarrow> A (f x + sum f Z)\"\n  shows \"A (\\<Sum>x\\<in>X. f x)\"", "lemma invs_imp_InvGlobalInfoAtBetaUpright:\n  assumes \"holds InvInfoAtBetaUpright s\"\n    and     \"holds InvGlobalIncomingInfoUpright s\"\n    and     \"holds InvIncomingInfoUpright s\"\n  shows   \"holds InvGlobalInfoAtBetaUpright s\"", "lemma alw_InvGlobalInfoAtBetaUpright: \"spec s \\<Longrightarrow> alw (holds InvGlobalInfoAtBetaUpright) s\"", "lemma gvut1:\n  \"GlobVacantUpto (shd s) q t \\<Longrightarrow> next_performop s \\<Longrightarrow> GlobVacantUpto (shd (stl s)) q t\"", "lemma gvut2:\n  \"GlobVacantUpto (shd s) q t \\<Longrightarrow> next_sendupd s \\<Longrightarrow> GlobVacantUpto (shd (stl s)) q t\"", "lemma gvut3:\n  assumes\n    gvu: \"GlobVacantUpto (shd s) q t\" and\n    igvuin: \"InvGlobVacantUptoImpliesNrec (shd s)\" and\n    igrc: \"InvGlobalRecordCount (shd s)\" and\n    igiiu: \"InvGlobalIncomingInfoUpright (shd s)\" and\n    igiabu: \"InvGlobalInfoAtBetaUpright (shd s)\" and\n    \"next\": \"next_recvupd s\"\n  shows \"GlobVacantUpto (shd (stl s)) q t\"", "lemma spec_imp_SafeStickyGlobVacantUpto_aux:\n  assumes\n    \"alw (holds (\\<lambda>c. InvGlobVacantUptoImpliesNrec c)) s\" and\n    \"alw (holds (\\<lambda>c. InvGlobalRecordCount c)) s\" and\n    \"alw (holds (\\<lambda>c. InvGlobalIncomingInfoUpright c)) s\" and\n    \"alw (holds (\\<lambda>c. InvGlobalInfoAtBetaUpright c)) s\" and\n    \"alw next s\"\n  shows \"alw SafeStickyGlobVacantUpto s\"", "lemma spec_imp_SafeStickyGlobVacantUpto: \"spec s \\<Longrightarrow> alw SafeStickyGlobVacantUpto s\"", "lemma alw_SafeGlobMono: \"spec s \\<Longrightarrow> alw (relates SafeGlobMono) s\""], "translations": [["", "lemma upright_alt:  \"upright a \\<longleftrightarrow> (\\<forall>t. zcount a t > 0 \\<longrightarrow> supported_strong a t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upright a =\n    (\\<forall>t. 0 < zcount a t \\<longrightarrow> supported_strong a t)", "unfolding upright_def supported_def supported_strong_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>t.\n        0 < zcount a t \\<longrightarrow> (\\<exists>s<t. zcount a s < 0)) =\n    (\\<forall>t.\n        0 < zcount a t \\<longrightarrow>\n        (\\<exists>s<t. zcount a s < 0 \\<and> nonpos_upto a s))", "by (rule iffI) (meson order.strict_trans2 order.strict_trans1 order_zmset_exists_foundation')+"], ["", "definition beta_upright :: \"'t :: order delta_vec \\<Rightarrow> 't :: order delta_vec \\<Rightarrow> bool\" where\n  \"beta_upright va vb = (\\<forall>t. zcount va t > 0 \\<longrightarrow> (\\<exists>s. s < t \\<and> (zcount va s < 0 \\<or> zcount vb s < 0)))\""], ["", "lemma beta_upright_alt:\n  \"beta_upright va vb = (\\<forall>t. zcount va t > 0 \\<longrightarrow> (\\<exists>s. s < t \\<and> (zcount va s < 0 \\<or> zcount vb s < 0) \\<and> nonpos_upto va s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beta_upright va vb =\n    (\\<forall>t.\n        0 < zcount va t \\<longrightarrow>\n        (\\<exists>s<t.\n            (zcount va s < 0 \\<or> zcount vb s < 0) \\<and>\n            nonpos_upto va s))", "unfolding beta_upright_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>t.\n        0 < zcount va t \\<longrightarrow>\n        (\\<exists>s<t. zcount va s < 0 \\<or> zcount vb s < 0)) =\n    (\\<forall>t.\n        0 < zcount va t \\<longrightarrow>\n        (\\<exists>s<t.\n            (zcount va s < 0 \\<or> zcount vb s < 0) \\<and>\n            nonpos_upto va s))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>t.\n       0 < zcount va t \\<longrightarrow>\n       (\\<exists>s<t.\n           zcount va s < 0 \\<or> zcount vb s < 0) \\<Longrightarrow>\n    \\<forall>t.\n       0 < zcount va t \\<longrightarrow>\n       (\\<exists>s<t.\n           (zcount va s < 0 \\<or> zcount vb s < 0) \\<and> nonpos_upto va s)\n 2. \\<forall>t.\n       0 < zcount va t \\<longrightarrow>\n       (\\<exists>s<t.\n           (zcount va s < 0 \\<or> zcount vb s < 0) \\<and>\n           nonpos_upto va s) \\<Longrightarrow>\n    \\<forall>t.\n       0 < zcount va t \\<longrightarrow>\n       (\\<exists>s<t. zcount va s < 0 \\<or> zcount vb s < 0)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>\\<forall>t.\n                   0 < zcount va t \\<longrightarrow>\n                   (\\<exists>s<t. zcount va s < 0 \\<or> zcount vb s < 0);\n        0 < zcount va t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s<t.\n                            (zcount va s < 0 \\<or> zcount vb s < 0) \\<and>\n                            nonpos_upto va s\n 2. \\<forall>t.\n       0 < zcount va t \\<longrightarrow>\n       (\\<exists>s<t.\n           (zcount va s < 0 \\<or> zcount vb s < 0) \\<and>\n           nonpos_upto va s) \\<Longrightarrow>\n    \\<forall>t.\n       0 < zcount va t \\<longrightarrow>\n       (\\<exists>s<t. zcount va s < 0 \\<or> zcount vb s < 0)", "apply (drule order_zmset_exists_foundation)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>\\<forall>t.\n                   0 < zcount va t \\<longrightarrow>\n                   (\\<exists>s<t. zcount va s < 0 \\<or> zcount vb s < 0);\n        \\<exists>s\\<le>t.\n           0 < zcount va s \\<and>\n           (\\<forall>u.\n               0 < zcount va u \\<longrightarrow> \\<not> u < s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s<t.\n                            (zcount va s < 0 \\<or> zcount vb s < 0) \\<and>\n                            nonpos_upto va s\n 2. \\<forall>t.\n       0 < zcount va t \\<longrightarrow>\n       (\\<exists>s<t.\n           (zcount va s < 0 \\<or> zcount vb s < 0) \\<and>\n           nonpos_upto va s) \\<Longrightarrow>\n    \\<forall>t.\n       0 < zcount va t \\<longrightarrow>\n       (\\<exists>s<t. zcount va s < 0 \\<or> zcount vb s < 0)", "apply (metis le_less_linear less_le_trans order.strict_trans1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       0 < zcount va t \\<longrightarrow>\n       (\\<exists>s<t.\n           (zcount va s < 0 \\<or> zcount vb s < 0) \\<and>\n           nonpos_upto va s) \\<Longrightarrow>\n    \\<forall>t.\n       0 < zcount va t \\<longrightarrow>\n       (\\<exists>s<t. zcount va s < 0 \\<or> zcount vb s < 0)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* count_vec: nrec, the occupancy vector\n   ('p \\<Rightarrow> delta_vec): temp, the local change in the occupancy vector due to ops performed at given processor\n   ('p \\<Rightarrow> 'p \\<Rightarrow> delta_vec list): msg, queue of updates from one processor to another\n   ('p \\<Rightarrow> delta_vec): glob, given processors (delayed) view of the occupancy vector *)"], ["", "record ('p, 't) configuration =\n  c_records :: \"'t delta_vec\"\n  c_temp :: \"'p \\<Rightarrow> 't delta_vec\"\n  c_msg :: \"'p \\<Rightarrow> 'p \\<Rightarrow> 't delta_vec list\"\n  c_glob :: \"'p \\<Rightarrow> 't delta_vec\""], ["", "type_synonym ('p, 't) computation = \"('p, 't) configuration stream\""], ["", "definition init_config :: \"('p :: finite, 't :: order) configuration \\<Rightarrow> bool\" where\n  \"init_config c =\n     ((\\<forall>p. c_temp c p = {#}\\<^sub>z) \\<and>\n      (\\<forall>p1 p2. c_msg c p1 p2 = []) \\<and>\n      (\\<forall>p. c_glob c p = c_records c) \\<and>\n      (\\<forall>t. 0 \\<le> zcount (c_records c) t))\""], ["", "definition next_performop' :: \"('p, 't :: order) configuration \\<Rightarrow> ('p, 't) configuration \\<Rightarrow> 'p \\<Rightarrow> 't count_vec \\<Rightarrow> 't count_vec \\<Rightarrow> bool\" where\n  \"next_performop' c0 c1 p c r =\n   (let \\<Delta> = zmset_of r - zmset_of c in\n      (\\<forall>t. int (count c t) \\<le> zcount (c_records c0) t)\n    \\<and> upright \\<Delta>\n    \\<and> c1 = c0\\<lparr>c_records := c_records c0 + \\<Delta>,\n              c_temp := (c_temp c0)(p := c_temp c0 p + \\<Delta>)\\<rparr>)\""], ["", "abbreviation next_performop where\n  \"next_performop s \\<equiv> (\\<exists>p (c :: 't :: order count_vec) (r::'t count_vec). next_performop' (shd s) (shd (stl s)) p c r)\""], ["", "definition next_sendupd' where\n  \"next_sendupd' c0 c1 p tt =\n   (let \\<gamma> = {#t \\<in>#\\<^sub>z c_temp c0 p. t \\<in> tt#} in\n      \\<gamma> \\<noteq> 0\n    \\<and> upright (c_temp c0 p - \\<gamma>)\n    \\<and> c1 = c0\\<lparr>c_msg := (c_msg c0)(p := \\<lambda>q. c_msg c0 p q @ [\\<gamma>]),\n              c_temp := (c_temp c0)(p := c_temp c0 p - \\<gamma>)\\<rparr>)\""], ["", "abbreviation next_sendupd where\n  \"next_sendupd s \\<equiv> (\\<exists>p tt. next_sendupd' (shd s) (shd (stl s)) p tt)\""], ["", "definition next_recvupd' where\n  \"next_recvupd' c0 c1 p q =\n   (c_msg c0 p q \\<noteq> []\n    \\<and> c1 = c0\\<lparr>c_msg := (c_msg c0)(p := (c_msg c0 p)(q := tl (c_msg c0 p q))),\n              c_glob := (c_glob c0)(q := c_glob c0 q + hd (c_msg c0 p q))\\<rparr>)\""], ["", "abbreviation next_recvupd where\n  \"next_recvupd s \\<equiv> (\\<exists>p q. next_recvupd' (shd s) (shd (stl s)) p q)\""], ["", "definition \"next\" where\n  \"next s = (next_performop s \\<or> next_sendupd s \\<or> next_recvupd s \\<or> (shd (stl s) = shd s))\""], ["", "definition spec :: \"('p :: finite, 't :: order) computation \\<Rightarrow> bool\" where\n  \"spec s = (holds init_config s \\<and> alw next s)\""], ["", "abbreviation GlobVacantUpto where\n  \"GlobVacantUpto c q t \\<equiv> vacant_upto (c_glob c q) t\""], ["", "abbreviation NrecVacantUpto where\n  \"NrecVacantUpto c t \\<equiv> vacant_upto (c_records c) t\""], ["", "(* This is the main safety property (safe) *)"], ["", "definition SafeGlobVacantUptoImpliesStickyNrec :: \"('p :: finite, 't :: order) computation \\<Rightarrow> bool\" where\n  \"SafeGlobVacantUptoImpliesStickyNrec s =\n     (let c = shd s in \\<forall>t q. GlobVacantUpto c q t \\<longrightarrow> alw (holds (\\<lambda>c. NrecVacantUpto c t)) s)\""], ["", "(* This is safe2 *)"], ["", "definition SafeStickyNrecVacantUpto :: \"('p :: finite, 't :: order) computation \\<Rightarrow> bool\" where\n  \"SafeStickyNrecVacantUpto s =\n     (let c = shd s in \\<forall>t. NrecVacantUpto c t \\<longrightarrow> alw (holds (\\<lambda>c. NrecVacantUpto c t)) s)\""], ["", "(* This is inv1 *)"], ["", "definition InvGlobVacantUptoImpliesNrec :: \"('p :: finite, 't :: order) configuration \\<Rightarrow> bool\" where\n  \"InvGlobVacantUptoImpliesNrec c =\n     (\\<forall>t q. vacant_upto (c_glob c q) t \\<longrightarrow> vacant_upto (c_records c) t)\""], ["", "definition InvTempUpright where\n  \"InvTempUpright c = (\\<forall>p. upright (c_temp c p))\""], ["", "lemma init_InvTempUpright: \"init_config c \\<Longrightarrow> InvTempUpright c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_config c \\<Longrightarrow> InvTempUpright c", "by (simp add: InvTempUpright_def init_config_def upright_def)"], ["", "lemma upright_obtain_support:\n  assumes \"upright a\"\n    and \"zcount a t > 0\"\n  obtains s where \"s < t\" \"zcount a s < 0\" \"nonpos_upto a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s < t; zcount a s < 0; nonpos_upto a s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  upright a\n  0 < zcount a t\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s < t; zcount a s < 0; nonpos_upto a s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding upright_alt supported_strong_def"], ["proof (prove)\nusing this:\n  \\<forall>t.\n     0 < zcount a t \\<longrightarrow>\n     (\\<exists>s<t. zcount a s < 0 \\<and> nonpos_upto a s)\n  0 < zcount a t\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s < t; zcount a s < 0; nonpos_upto a s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t.\n                0 < zcount a t \\<longrightarrow>\n                (\\<exists>s<t. zcount a s < 0 \\<and> nonpos_upto a s);\n     0 < zcount a t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s<t. zcount a s < 0 \\<and> nonpos_upto a s", "using order.strict_implies_order"], ["proof (prove)\nusing this:\n  ?a < ?b \\<Longrightarrow> ?a \\<le> ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t.\n                0 < zcount a t \\<longrightarrow>\n                (\\<exists>s<t. zcount a s < 0 \\<and> nonpos_upto a s);\n     0 < zcount a t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s<t. zcount a s < 0 \\<and> nonpos_upto a s", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma upright_vec_add:\n  assumes \"upright v1\"\n    and   \"upright v2\"\n  shows   \"upright (v1 + v2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "let ?v0 = \"v1 + v2\""], ["proof (state)\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "assume upr1: \"upright v1\""], ["proof (state)\nthis:\n  upright v1\n\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "assume upr2: \"upright v2\""], ["proof (state)\nthis:\n  upright v2\n\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "assume zcnt: \"0 < zcount ?v0 t\""], ["proof (state)\nthis:\n  0 < zcount (v1 + v2) t\n\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "{"], ["proof (state)\nthis:\n  0 < zcount (v1 + v2) t\n\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "fix va vb :: \"'a zmultiset\""], ["proof (state)\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "assume upra: \"upright va\""], ["proof (state)\nthis:\n  upright va\n\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "assume uprb: \"upright vb\""], ["proof (state)\nthis:\n  upright vb\n\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "assume zcnt: \"0 < zcount va t\""], ["proof (state)\nthis:\n  0 < zcount va t\n\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "from upra zcnt"], ["proof (chain)\npicking this:\n  upright va\n  0 < zcount va t", "obtain x where x: \"x < t\" \"zcount va x < 0\" \"nonpos_upto va x\""], ["proof (prove)\nusing this:\n  upright va\n  0 < zcount va t\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x < t; zcount va x < 0; nonpos_upto va x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using upright_obtain_support"], ["proof (prove)\nusing this:\n  upright va\n  0 < zcount va t\n  \\<lbrakk>upright ?a; 0 < zcount ?a ?t;\n   \\<And>s.\n      \\<lbrakk>s < ?t; zcount ?a s < 0; nonpos_upto ?a s\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x < t; zcount va x < 0; nonpos_upto va x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x < t\n  zcount va x < 0\n  nonpos_upto va x\n\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "with uprb"], ["proof (chain)\npicking this:\n  upright vb\n  x < t\n  zcount va x < 0\n  nonpos_upto va x", "have \"supported_strong (va+vb) t\""], ["proof (prove)\nusing this:\n  upright vb\n  x < t\n  zcount va x < 0\n  nonpos_upto va x\n\ngoal (1 subgoal):\n 1. supported_strong (va + vb) t", "apply (cases \"\\<exists>s. s \\<le> x \\<and> 0 < zcount vb s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>upright vb; x < t; zcount va x < 0; nonpos_upto va x;\n     \\<exists>s\\<le>x. 0 < zcount vb s\\<rbrakk>\n    \\<Longrightarrow> supported_strong (va + vb) t\n 2. \\<lbrakk>upright vb; x < t; zcount va x < 0; nonpos_upto va x;\n     \\<not> (\\<exists>s\\<le>x. 0 < zcount vb s)\\<rbrakk>\n    \\<Longrightarrow> supported_strong (va + vb) t", "apply (clarsimp simp: upright_alt supported_strong_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>t.\n                   0 < zcount vb t \\<longrightarrow>\n                   (\\<exists>s<t. zcount vb s < 0 \\<and> nonpos_upto vb s);\n        x < t; zcount va x < 0; nonpos_upto va x; s \\<le> x;\n        0 < zcount vb s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s<t.\n                            zcount va s + zcount vb s < 0 \\<and>\n                            (\\<forall>sa\\<le>s.\n                                zcount va sa + zcount vb sa \\<le> 0)\n 2. \\<lbrakk>upright vb; x < t; zcount va x < 0; nonpos_upto va x;\n     \\<not> (\\<exists>s\\<le>x. 0 < zcount vb s)\\<rbrakk>\n    \\<Longrightarrow> supported_strong (va + vb) t", "apply (meson add_nonpos_neg less_imp_le order.strict_trans2 order.trans add_nonpos_nonpos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>upright vb; x < t; zcount va x < 0; nonpos_upto va x;\n     \\<not> (\\<exists>s\\<le>x. 0 < zcount vb s)\\<rbrakk>\n    \\<Longrightarrow> supported_strong (va + vb) t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>upright vb; x < t; zcount va x < 0; nonpos_upto va x;\n     \\<forall>s\\<le>x. \\<not> 0 < zcount vb s\\<rbrakk>\n    \\<Longrightarrow> supported_strong (va + vb) t", "apply (force simp: supported_strong_def intro!: exI[of _ x])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  supported_strong (va + vb) t\n\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>upright ?va2; upright ?vb2; 0 < zcount ?va2 ?ta2\\<rbrakk>\n  \\<Longrightarrow> supported_strong (?va2 + ?vb2) ?ta2\n\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "with upr1 upr2 zcnt"], ["proof (chain)\npicking this:\n  upright v1\n  upright v2\n  0 < zcount (v1 + v2) t\n  \\<lbrakk>upright ?va2; upright ?vb2; 0 < zcount ?va2 ?ta2\\<rbrakk>\n  \\<Longrightarrow> supported_strong (?va2 + ?vb2) ?ta2", "have \"supported_strong ?v0 t\""], ["proof (prove)\nusing this:\n  upright v1\n  upright v2\n  0 < zcount (v1 + v2) t\n  \\<lbrakk>upright ?va2; upright ?vb2; 0 < zcount ?va2 ?ta2\\<rbrakk>\n  \\<Longrightarrow> supported_strong (?va2 + ?vb2) ?ta2\n\ngoal (1 subgoal):\n 1. supported_strong (v1 + v2) t", "unfolding supported_strong_def"], ["proof (prove)\nusing this:\n  upright v1\n  upright v2\n  0 < zcount (v1 + v2) t\n  \\<lbrakk>upright ?va2; upright ?vb2; 0 < zcount ?va2 ?ta2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s<?ta2.\n                       zcount (?va2 + ?vb2) s < 0 \\<and>\n                       nonpos_upto (?va2 + ?vb2) s\n\ngoal (1 subgoal):\n 1. \\<exists>s<t. zcount (v1 + v2) s < 0 \\<and> nonpos_upto (v1 + v2) s", "apply (cases \"0 < zcount v1 t\"; cases \"0 < zcount v2 t\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     0 < zcount v1 t; upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     0 < zcount v2 t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s<t.\n                         zcount (v1 + v2) s < 0 \\<and>\n                         nonpos_upto (v1 + v2) s\n 2. \\<lbrakk>upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     0 < zcount v1 t; upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     \\<not> 0 < zcount v2 t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s<t.\n                         zcount (v1 + v2) s < 0 \\<and>\n                         nonpos_upto (v1 + v2) s\n 3. \\<lbrakk>upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     \\<not> 0 < zcount v1 t; upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     0 < zcount v2 t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s<t.\n                         zcount (v1 + v2) s < 0 \\<and>\n                         nonpos_upto (v1 + v2) s\n 4. \\<lbrakk>upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     \\<not> 0 < zcount v1 t; upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     \\<not> 0 < zcount v2 t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s<t.\n                         zcount (v1 + v2) s < 0 \\<and>\n                         nonpos_upto (v1 + v2) s", "apply auto [2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     \\<not> 0 < zcount v1 t; upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     0 < zcount v2 t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s<t.\n                         zcount (v1 + v2) s < 0 \\<and>\n                         nonpos_upto (v1 + v2) s\n 2. \\<lbrakk>upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     \\<not> 0 < zcount v1 t; upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     \\<not> 0 < zcount v2 t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s<t.\n                         zcount (v1 + v2) s < 0 \\<and>\n                         nonpos_upto (v1 + v2) s", "apply (subst (1 2) add.commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     \\<not> 0 < zcount v1 t; upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     0 < zcount v2 t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s<t.\n                         zcount (v2 + v1) s < 0 \\<and>\n                         nonpos_upto (v2 + v1) s\n 2. \\<lbrakk>upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     \\<not> 0 < zcount v1 t; upright v1; upright v2; 0 < zcount (v1 + v2) t;\n     \\<And>va vb ta.\n        \\<lbrakk>upright va; upright vb; 0 < zcount va ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s<ta.\n                             zcount (va + vb) s < 0 \\<and>\n                             nonpos_upto (va + vb) s;\n     \\<not> 0 < zcount v2 t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s<t.\n                         zcount (v1 + v2) s < 0 \\<and>\n                         nonpos_upto (v1 + v2) s", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  supported_strong (v1 + v2) t\n\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>upright v1; upright v2; 0 < zcount (v1 + v2) ?t2\\<rbrakk>\n  \\<Longrightarrow> supported_strong (v1 + v2) ?t2\n\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "with assms"], ["proof (chain)\npicking this:\n  upright v1\n  upright v2\n  \\<lbrakk>upright v1; upright v2; 0 < zcount (v1 + v2) ?t2\\<rbrakk>\n  \\<Longrightarrow> supported_strong (v1 + v2) ?t2", "show ?thesis"], ["proof (prove)\nusing this:\n  upright v1\n  upright v2\n  \\<lbrakk>upright v1; upright v2; 0 < zcount (v1 + v2) ?t2\\<rbrakk>\n  \\<Longrightarrow> supported_strong (v1 + v2) ?t2\n\ngoal (1 subgoal):\n 1. upright (v1 + v2)", "by (simp add: upright_alt)"], ["proof (state)\nthis:\n  upright (v1 + v2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma next_InvTempUpright: \"holds InvTempUpright s \\<Longrightarrow> next s \\<Longrightarrow> nxt (holds InvTempUpright) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds InvTempUpright s; next s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds InvTempUpright) s", "unfolding next_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds InvTempUpright s;\n     next_performop s \\<or>\n     next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds InvTempUpright) s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvTempUpright (shd s);\n     next_performop s \\<or>\n     next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))", "apply (elim disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>InvTempUpright (shd s); next_performop s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))\n 2. \\<lbrakk>InvTempUpright (shd s); next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))\n 3. \\<lbrakk>InvTempUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))\n 4. \\<lbrakk>InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvTempUpright (shd s); next_performop s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))", "unfolding InvTempUpright_def next_performop'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. upright (c_temp (shd s) p);\n     \\<exists>p c r.\n        let \\<Delta> = zmset_of r - zmset_of c\n        in (\\<forall>t.\n               int (count c t) \\<le> zcount (c_records (shd s)) t) \\<and>\n           upright \\<Delta> \\<and>\n           shd (stl s) = shd s\n           \\<lparr>c_records := c_records (shd s) + \\<Delta>,\n              c_temp := (c_temp (shd s))\n                (p := c_temp (shd s) p + \\<Delta>)\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. upright (c_temp (shd (stl s)) p)", "by (auto simp: Let_def upright_vec_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>InvTempUpright (shd s); next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))\n 2. \\<lbrakk>InvTempUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))\n 3. \\<lbrakk>InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvTempUpright (shd s); next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))", "unfolding InvTempUpright_def next_sendupd'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. upright (c_temp (shd s) p);\n     \\<exists>p tt.\n        let \\<gamma> = {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}\n        in \\<gamma> \\<noteq> {#}\\<^sub>z \\<and>\n           upright (c_temp (shd s) p - \\<gamma>) \\<and>\n           shd (stl s) = shd s\n           \\<lparr>c_msg := (c_msg (shd s))\n                     (p := \\<lambda>q. c_msg (shd s) p q @ [\\<gamma>]),\n              c_temp := (c_temp (shd s))\n                (p := c_temp (shd s) p - \\<gamma>)\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. upright (c_temp (shd (stl s)) p)", "by (auto simp: Let_def upright_vec_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>InvTempUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))\n 2. \\<lbrakk>InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvTempUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))", "unfolding InvTempUpright_def next_recvupd'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. upright (c_temp (shd s) p);\n     \\<exists>p q.\n        c_msg (shd s) p q \\<noteq> [] \\<and>\n        shd (stl s) = shd s\n        \\<lparr>c_msg := (c_msg (shd s))\n                  (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n           c_glob := (c_glob (shd s))\n             (q := c_glob (shd s) q +\n                   hd (c_msg (shd s) p q))\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. upright (c_temp (shd (stl s)) p)", "by (auto simp: upright_vec_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvTempUpright (shd (stl s))", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma alw_InvTempUpright: \"spec s \\<Longrightarrow> alw (holds InvTempUpright) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds InvTempUpright) s", "apply (rule alw_invar)"], ["proof (prove)\ngoal (2 subgoals):\n 1. spec s \\<Longrightarrow> holds InvTempUpright s\n 2. spec s \\<Longrightarrow>\n    alw (\\<lambda>xs.\n            holds InvTempUpright xs \\<longrightarrow>\n            nxt (holds InvTempUpright) xs)\n     s", "apply (simp add: spec_def init_InvTempUpright)"], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow>\n    alw (\\<lambda>xs.\n            holds InvTempUpright xs \\<longrightarrow>\n            nxt (holds InvTempUpright) xs)\n     s", "apply (metis (no_types, lifting) alw_iff_sdrop next_InvTempUpright spec_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition IncomingInfo where\n  \"IncomingInfo c k p q = (sum_list (drop k (c_msg c p q)) + c_temp c p)\""], ["", "definition InvIncomingInfoUpright where\n  \"InvIncomingInfoUpright c = (\\<forall>k p q. upright (IncomingInfo c k p q))\""], ["", "lemma upright_0: \"upright 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upright {#}\\<^sub>z", "by (simp add: upright_def)"], ["", "lemma init_InvIncomingInfoUpright: \"init_config c \\<Longrightarrow> InvIncomingInfoUpright c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_config c \\<Longrightarrow> InvIncomingInfoUpright c", "by (simp add: upright_0 upright_vec_add init_config_def InvIncomingInfoUpright_def IncomingInfo_def)"], ["", "lemma next_InvIncomingInfoUpright: \"holds InvIncomingInfoUpright s \\<Longrightarrow> next s \\<Longrightarrow> nxt (holds InvIncomingInfoUpright) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds InvIncomingInfoUpright s; next s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds InvIncomingInfoUpright) s", "unfolding next_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds InvIncomingInfoUpright s;\n     next_performop s \\<or>\n     next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds InvIncomingInfoUpright) s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvIncomingInfoUpright (shd s);\n     next_performop s \\<or>\n     next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))", "apply (elim disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>InvIncomingInfoUpright (shd s); next_performop s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))\n 2. \\<lbrakk>InvIncomingInfoUpright (shd s); next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))\n 3. \\<lbrakk>InvIncomingInfoUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))\n 4. \\<lbrakk>InvIncomingInfoUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvIncomingInfoUpright (shd s); next_performop s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))", "by (auto simp: add.assoc[symmetric] upright_vec_add next_performop'_def Let_def InvIncomingInfoUpright_def IncomingInfo_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>InvIncomingInfoUpright (shd s); next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))\n 2. \\<lbrakk>InvIncomingInfoUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))\n 3. \\<lbrakk>InvIncomingInfoUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvIncomingInfoUpright (shd s); next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))", "unfolding next_sendupd'_def Let_def InvIncomingInfoUpright_def IncomingInfo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k p q.\n                upright\n                 (sum_list (drop k (c_msg (shd s) p q)) + c_temp (shd s) p);\n     \\<exists>p tt.\n        {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n        {#}\\<^sub>z \\<and>\n        upright\n         (c_temp (shd s) p -\n          {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}) \\<and>\n        shd (stl s) = shd s\n        \\<lparr>c_msg := (c_msg (shd s))\n                  (p := \\<lambda>q.\n                           c_msg (shd s) p q @\n                           [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                             t \\<in> tt#}]),\n           c_temp := (c_temp (shd s))\n             (p := c_temp (shd s) p -\n                   {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                    t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k p q.\n                         upright\n                          (sum_list (drop k (c_msg (shd (stl s)) p q)) +\n                           c_temp (shd (stl s)) p)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p tt k q.\n       \\<lbrakk>\\<forall>k p q.\n                   upright\n                    (sum_list (drop k (c_msg (shd s) p q)) +\n                     c_temp (shd s) p);\n        {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n        {#}\\<^sub>z;\n        upright\n         (c_temp (shd s) p -\n          {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n        shd (stl s) = shd s\n        \\<lparr>c_msg := (c_msg (shd s))\n                  (p := \\<lambda>q.\n                           c_msg (shd s) p q @\n                           [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                             t \\<in> tt#}]),\n           c_temp := (c_temp (shd s))\n             (p := c_temp (shd s) p -\n                   {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                    t \\<in> tt#})\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> upright\n                          (sum_list (drop k (c_msg (shd s) p q)) +\n                           sum_list\n                            (drop (k - length (c_msg (shd s) p q))\n                              [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                                t \\<in> tt#}]) +\n                           (c_temp (shd s) p -\n                            {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                             t \\<in> tt#}))", "subgoal for p tt k q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k p q.\n                upright\n                 (sum_list (drop k (c_msg (shd s) p q)) + c_temp (shd s) p);\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> upright\n                       (sum_list (drop k (c_msg (shd s) p q)) +\n                        sum_list\n                         (drop (k - length (c_msg (shd s) p q))\n                           [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                             t \\<in> tt#}]) +\n                        (c_temp (shd s) p -\n                         {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}))", "apply (cases \"k \\<le> length (c_msg (shd s) p q)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>k p q.\n                upright\n                 (sum_list (drop k (c_msg (shd s) p q)) + c_temp (shd s) p);\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     k \\<le> length (c_msg (shd s) p q)\\<rbrakk>\n    \\<Longrightarrow> upright\n                       (sum_list (drop k (c_msg (shd s) p q)) +\n                        sum_list\n                         (drop (k - length (c_msg (shd s) p q))\n                           [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                             t \\<in> tt#}]) +\n                        (c_temp (shd s) p -\n                         {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}))\n 2. \\<lbrakk>\\<forall>k p q.\n                upright\n                 (sum_list (drop k (c_msg (shd s) p q)) + c_temp (shd s) p);\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     \\<not> k \\<le> length (c_msg (shd s) p q)\\<rbrakk>\n    \\<Longrightarrow> upright\n                       (sum_list (drop k (c_msg (shd s) p q)) +\n                        sum_list\n                         (drop (k - length (c_msg (shd s) p q))\n                           [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                             t \\<in> tt#}]) +\n                        (c_temp (shd s) p -\n                         {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>InvIncomingInfoUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))\n 2. \\<lbrakk>InvIncomingInfoUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvIncomingInfoUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))", "unfolding next_recvupd'_def Let_def InvIncomingInfoUpright_def IncomingInfo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k p q.\n                upright\n                 (sum_list (drop k (c_msg (shd s) p q)) + c_temp (shd s) p);\n     \\<exists>p q.\n        c_msg (shd s) p q \\<noteq> [] \\<and>\n        shd (stl s) = shd s\n        \\<lparr>c_msg := (c_msg (shd s))\n                  (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n           c_glob := (c_glob (shd s))\n             (q := c_glob (shd s) q +\n                   hd (c_msg (shd s) p q))\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k p q.\n                         upright\n                          (sum_list (drop k (c_msg (shd (stl s)) p q)) +\n                           c_temp (shd (stl s)) p)", "apply (clarsimp simp: drop_Suc[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvIncomingInfoUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvIncomingInfoUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvIncomingInfoUpright (shd (stl s))", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma alw_InvIncomingInfoUpright: \"spec s \\<Longrightarrow> alw (holds InvIncomingInfoUpright) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds InvIncomingInfoUpright) s", "by (metis (mono_tags, lifting) alw_iff_sdrop alw_invar holds.elims(2) holds.elims(3) init_InvIncomingInfoUpright next_InvIncomingInfoUpright spec_def)"], ["", "definition GlobalIncomingInfo :: \"('p :: finite, 't) configuration \\<Rightarrow> nat \\<Rightarrow> 'p \\<Rightarrow> 'p \\<Rightarrow> 't delta_vec\" where\n  \"GlobalIncomingInfo c k p q = (\\<Sum>p' \\<in> UNIV. IncomingInfo c (if p' = p then k else 0) p' q)\""], ["", "(* (GlobalIncomingInfo c 0 q q) sums up all info incoming at q *)"], ["", "abbreviation GlobalIncomingInfoAt where\n  \"GlobalIncomingInfoAt c q \\<equiv> GlobalIncomingInfo c 0 q q\""], ["", "definition InvGlobalRecordCount where\n  \"InvGlobalRecordCount c = (\\<forall>q. c_records c = GlobalIncomingInfoAt c q + c_glob c q)\""], ["", "lemma init_InvGlobalRecordCount: \"holds init_config s \\<Longrightarrow> holds InvGlobalRecordCount s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. holds init_config s \\<Longrightarrow> holds InvGlobalRecordCount s", "by (simp add: InvGlobalRecordCount_def init_config_def GlobalIncomingInfo_def IncomingInfo_def)"], ["", "lemma if_eq_same: \"(if a = b then f b else f a) = f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a = b then f b else f a) = f a", "by auto"], ["", "lemma next_InvGlobalRecordCount: \"holds InvGlobalRecordCount s \\<Longrightarrow> next s \\<Longrightarrow> nxt (holds InvGlobalRecordCount) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds InvGlobalRecordCount s; next s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds InvGlobalRecordCount) s", "unfolding InvGlobalRecordCount_def init_config_def GlobalIncomingInfo_def IncomingInfo_def next_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     next_performop s \\<or>\n     next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s", "apply (elim disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     next_performop s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s\n 2. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s\n 3. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s\n 4. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     next_performop s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s", "apply (clarsimp simp: next_performop'_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p c x q.\n       \\<lbrakk>\\<forall>q.\n                   c_records (shd s) =\n                   (\\<Sum>p'\\<in>UNIV.\n                      sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                   c_glob (shd s) q;\n        \\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n        upright (zmset_of x - zmset_of c);\n        shd (stl s) = shd s\n        \\<lparr>c_records := c_records (shd s) + (zmset_of x - zmset_of c),\n           c_temp := (c_temp (shd s))\n             (p := c_temp (shd s) p +\n                   (zmset_of x - zmset_of c))\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> c_records (shd s) + (zmset_of x - zmset_of c) =\n                         (\\<Sum>p'\\<in>UNIV.\n                            sum_list (c_msg (shd s) p' q) +\n                            (if p' = p\n                             then c_temp (shd s) p +\n                                  (zmset_of x - zmset_of c)\n                             else c_temp (shd s) p')) +\n                         c_glob (shd s) q", "subgoal for p c q r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     \\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of q - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of q - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p +\n                (zmset_of q - zmset_of c))\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) + (zmset_of q - zmset_of c) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list (c_msg (shd s) p' r) +\n                         (if p' = p\n                          then c_temp (shd s) p + (zmset_of q - zmset_of c)\n                          else c_temp (shd s) p')) +\n                      c_glob (shd s) r", "apply (simp add: sum.distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     \\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of q - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of q - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p +\n                (zmset_of q - zmset_of c))\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) + (zmset_of q - zmset_of c) =\n                      (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' r)) +\n                      (\\<Sum>p'\\<in>UNIV.\n                         if p' = p\n                         then c_temp (shd s) p + (zmset_of q - zmset_of c)\n                         else c_temp (shd s) p') +\n                      c_glob (shd s) r", "apply (subst sum_if_distrib_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     \\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of q - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of q - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p +\n                (zmset_of q - zmset_of c))\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> finite UNIV\n 2. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     \\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of q - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of q - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p +\n                (zmset_of q - zmset_of c))\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> p \\<in> UNIV\n 3. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     \\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of q - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of q - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p +\n                (zmset_of q - zmset_of c))\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) + (zmset_of q - zmset_of c) =\n                      (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' r)) +\n                      (sum (c_temp (shd s)) UNIV +\n                       (zmset_of q - zmset_of c)) +\n                      c_glob (shd s) r", "apply (simp_all add: add.assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s\n 2. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s\n 3. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s", "apply (clarsimp simp: next_sendupd'_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x q.\n       \\<lbrakk>\\<forall>q.\n                   c_records (shd s) =\n                   (\\<Sum>p'\\<in>UNIV.\n                      sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                   c_glob (shd s) q;\n        {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> x#} \\<noteq>\n        {#}\\<^sub>z;\n        upright\n         (c_temp (shd s) p -\n          {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> x#});\n        shd (stl s) = shd s\n        \\<lparr>c_msg := (c_msg (shd s))\n                  (p := \\<lambda>q.\n                           c_msg (shd s) p q @\n                           [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                             t \\<in> x#}]),\n           c_temp := (c_temp (shd s))\n             (p := c_temp (shd s) p -\n                   {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                    t \\<in> x#})\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> c_records (shd s) =\n                         (\\<Sum>p'\\<in>UNIV.\n                            sum_list\n                             ((if p' = p\n                               then \\<lambda>q.\n c_msg (shd s) p q @ [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> x#}]\n                               else c_msg (shd s) p')\n                               q) +\n                            (if p' = p\n                             then c_temp (shd s) p -\n                                  {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                                   t \\<in> x#}\n                             else c_temp (shd s) p')) +\n                         c_glob (shd s) q", "subgoal for p tt q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list\n                          ((if p' = p\n                            then \\<lambda>q.\n                                    c_msg (shd s) p q @\n                                    [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\nt \\<in> tt#}]\n                            else c_msg (shd s) p')\n                            q) +\n                         (if p' = p\n                          then c_temp (shd s) p -\n                               {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                                t \\<in> tt#}\n                          else c_temp (shd s) p')) +\n                      c_glob (shd s) q", "apply (simp add: if_distrib[of \"\\<lambda>f. f _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list\n                          (if p' = p\n                           then c_msg (shd s) p q @\n                                [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                                  t \\<in> tt#}]\n                           else c_msg (shd s) p' q) +\n                         (if p' = p\n                          then c_temp (shd s) p -\n                               {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                                t \\<in> tt#}\n                          else c_temp (shd s) p')) +\n                      c_glob (shd s) q", "apply (simp add: if_distrib[of sum_list])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         (if p' = p\n                          then sum_list\n                                (c_msg (shd s) p q @\n                                 [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                                   t \\<in> tt#}])\n                          else sum_list (c_msg (shd s) p' q)) +\n                         (if p' = p\n                          then c_temp (shd s) p -\n                               {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                                t \\<in> tt#}\n                          else c_temp (shd s) p')) +\n                      c_glob (shd s) q", "apply (subst sum_list_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         (if p' = p\n                          then sum_list (c_msg (shd s) p q) +\n                               sum_list\n                                [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                                  t \\<in> tt#}]\n                          else sum_list (c_msg (shd s) p' q)) +\n                         (if p' = p\n                          then c_temp (shd s) p -\n                               {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                                t \\<in> tt#}\n                          else c_temp (shd s) p')) +\n                      c_glob (shd s) q", "apply (simp add: sum.distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         if p' = p\n                         then sum_list (c_msg (shd s) p q) +\n                              sum_list\n                               [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                                 t \\<in> tt#}]\n                         else sum_list (c_msg (shd s) p' q)) +\n                      (\\<Sum>p'\\<in>UNIV.\n                         if p' = p\n                         then c_temp (shd s) p -\n                              {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                               t \\<in> tt#}\n                         else c_temp (shd s) p') +\n                      c_glob (shd s) q", "apply (subst sum_if_distrib_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> finite UNIV\n 2. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> p \\<in> UNIV\n 3. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>a\\<in>UNIV. sum_list (c_msg (shd s) a q)) +\n                      sum_list\n                       [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}] +\n                      (\\<Sum>p'\\<in>UNIV.\n                         if p' = p\n                         then c_temp (shd s) p -\n                              {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                               t \\<in> tt#}\n                         else c_temp (shd s) p') +\n                      c_glob (shd s) q", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> p \\<in> UNIV\n 2. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>a\\<in>UNIV. sum_list (c_msg (shd s) a q)) +\n                      sum_list\n                       [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}] +\n                      (\\<Sum>p'\\<in>UNIV.\n                         if p' = p\n                         then c_temp (shd s) p -\n                              {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                               t \\<in> tt#}\n                         else c_temp (shd s) p') +\n                      c_glob (shd s) q", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>a\\<in>UNIV. sum_list (c_msg (shd s) a q)) +\n                      sum_list\n                       [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}] +\n                      (\\<Sum>p'\\<in>UNIV.\n                         if p' = p\n                         then c_temp (shd s) p -\n                              {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                               t \\<in> tt#}\n                         else c_temp (shd s) p') +\n                      c_glob (shd s) q", "apply (subst diff_conv_add_uminus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>a\\<in>UNIV. sum_list (c_msg (shd s) a q)) +\n                      sum_list\n                       [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}] +\n                      (\\<Sum>p'\\<in>UNIV.\n                         if p' = p\n                         then c_temp (shd s) p +\n                              - {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                                 t \\<in> tt#}\n                         else c_temp (shd s) p') +\n                      c_glob (shd s) q", "apply (subst sum_if_distrib_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> finite UNIV\n 2. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> p \\<in> UNIV\n 3. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq> {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>a\\<in>UNIV. sum_list (c_msg (shd s) a q)) +\n                      sum_list\n                       [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}] +\n                      (sum (c_temp (shd s)) UNIV +\n                       - {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}) +\n                      c_glob (shd s) q", "apply (auto simp: sum_if_distrib_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s\n 2. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s", "apply (clarsimp simp: next_recvupd'_def Let_def fun_upd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x q.\n       \\<lbrakk>\\<forall>q.\n                   c_records (shd s) =\n                   (\\<Sum>p'\\<in>UNIV.\n                      sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                   c_glob (shd s) q;\n        c_msg (shd s) p x \\<noteq> [];\n        shd (stl s) = shd s\n        \\<lparr>c_msg :=\n                  \\<lambda>xa.\n                     if xa = p\n                     then \\<lambda>xa.\n                             if xa = x then tl (c_msg (shd s) p x)\n                             else c_msg (shd s) p xa\n                     else c_msg (shd s) xa,\n           c_glob :=\n             \\<lambda>xa.\n                if xa = x then c_glob (shd s) x + hd (c_msg (shd s) p x)\n                else c_glob (shd s) xa\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> (q = x \\<longrightarrow>\n                          c_records (shd s) =\n                          (\\<Sum>p'\\<in>UNIV.\n                             sum_list\n                              ((if p' = p\n                                then \\<lambda>xa.\n  if xa = x then tl (c_msg (shd s) p x) else c_msg (shd s) p xa\n                                else c_msg (shd s) p')\n                                x) +\n                             c_temp (shd s) p') +\n                          (c_glob (shd s) x +\n                           hd (c_msg (shd s) p x))) \\<and>\n                         (q \\<noteq> x \\<longrightarrow>\n                          c_records (shd s) =\n                          (\\<Sum>p'\\<in>UNIV.\n                             sum_list\n                              ((if p' = p\n                                then \\<lambda>xa.\n  if xa = x then tl (c_msg (shd s) p x) else c_msg (shd s) p xa\n                                else c_msg (shd s) p')\n                                q) +\n                             c_temp (shd s) p') +\n                          c_glob (shd s) q)", "subgoal for p q q'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> (q' = q \\<longrightarrow>\n                       c_records (shd s) =\n                       (\\<Sum>p'\\<in>UNIV.\n                          sum_list\n                           ((if p' = p\n                             then \\<lambda>x.\n                                     if x = q then tl (c_msg (shd s) p q)\n                                     else c_msg (shd s) p x\n                             else c_msg (shd s) p')\n                             q) +\n                          c_temp (shd s) p') +\n                       (c_glob (shd s) q + hd (c_msg (shd s) p q))) \\<and>\n                      (q' \\<noteq> q \\<longrightarrow>\n                       c_records (shd s) =\n                       (\\<Sum>p'\\<in>UNIV.\n                          sum_list\n                           ((if p' = p\n                             then \\<lambda>x.\n                                     if x = q then tl (c_msg (shd s) p q)\n                                     else c_msg (shd s) p x\n                             else c_msg (shd s) p')\n                             q') +\n                          c_temp (shd s) p') +\n                       c_glob (shd s) q')", "apply (simp add: if_distrib[of \"\\<lambda>f. f _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> (q' = q \\<longrightarrow>\n                       c_records (shd s) =\n                       (\\<Sum>p'\\<in>UNIV.\n                          sum_list\n                           (if p' = p then tl (c_msg (shd s) p q)\n                            else c_msg (shd s) p' q) +\n                          c_temp (shd s) p') +\n                       (c_glob (shd s) q + hd (c_msg (shd s) p q))) \\<and>\n                      (q' \\<noteq> q \\<longrightarrow>\n                       c_records (shd s) =\n                       (\\<Sum>p'\\<in>UNIV.\n                          sum_list\n                           (if p' = p then c_msg (shd s) p q'\n                            else c_msg (shd s) p' q') +\n                          c_temp (shd s) p') +\n                       c_glob (shd s) q')", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' = q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list\n                          (if p' = p then tl (c_msg (shd s) p q)\n                           else c_msg (shd s) p' q) +\n                         c_temp (shd s) p') +\n                      (c_glob (shd s) q + hd (c_msg (shd s) p q))\n 2. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list\n                          (if p' = p then c_msg (shd s) p q'\n                           else c_msg (shd s) p' q') +\n                         c_temp (shd s) p') +\n                      c_glob (shd s) q'", "apply (simp add: if_distrib[of sum_list])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' = q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         (if p' = p then sum_list (tl (c_msg (shd s) p q))\n                          else sum_list (c_msg (shd s) p' q)) +\n                         c_temp (shd s) p') +\n                      (c_glob (shd s) q + hd (c_msg (shd s) p q))\n 2. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list\n                          (if p' = p then c_msg (shd s) p q'\n                           else c_msg (shd s) p' q') +\n                         c_temp (shd s) p') +\n                      c_glob (shd s) q'", "apply (subst sum_list_hd_tl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p'.\n       \\<lbrakk>\\<forall>q.\n                   c_records (shd s) =\n                   (\\<Sum>p'\\<in>UNIV.\n                      sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                   c_glob (shd s) q;\n        c_msg (shd s) p q \\<noteq> [];\n        shd (stl s) = shd s\n        \\<lparr>c_msg :=\n                  \\<lambda>x.\n                     if x = p\n                     then \\<lambda>x.\n                             if x = q then tl (c_msg (shd s) p q)\n                             else c_msg (shd s) p x\n                     else c_msg (shd s) x,\n           c_glob :=\n             \\<lambda>x.\n                if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n                else c_glob (shd s) x\\<rparr>;\n        q' = q\\<rbrakk>\n       \\<Longrightarrow> c_msg (shd s) p q \\<noteq> []\n 2. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' = q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         (if p' = p\n                          then - hd (c_msg (shd s) p q) +\n                               sum_list (c_msg (shd s) p q)\n                          else sum_list (c_msg (shd s) p' q)) +\n                         c_temp (shd s) p') +\n                      (c_glob (shd s) q + hd (c_msg (shd s) p q))\n 3. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list\n                          (if p' = p then c_msg (shd s) p q'\n                           else c_msg (shd s) p' q') +\n                         c_temp (shd s) p') +\n                      c_glob (shd s) q'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' = q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         (if p' = p\n                          then - hd (c_msg (shd s) p q) +\n                               sum_list (c_msg (shd s) p q)\n                          else sum_list (c_msg (shd s) p' q)) +\n                         c_temp (shd s) p') +\n                      (c_glob (shd s) q + hd (c_msg (shd s) p q))\n 2. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list\n                          (if p' = p then c_msg (shd s) p q'\n                           else c_msg (shd s) p' q') +\n                         c_temp (shd s) p') +\n                      c_glob (shd s) q'", "apply (subst add.commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' = q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         (if p' = p\n                          then sum_list (c_msg (shd s) p q) +\n                               - hd (c_msg (shd s) p q)\n                          else sum_list (c_msg (shd s) p' q)) +\n                         c_temp (shd s) p') +\n                      (c_glob (shd s) q + hd (c_msg (shd s) p q))\n 2. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list\n                          (if p' = p then c_msg (shd s) p q'\n                           else c_msg (shd s) p' q') +\n                         c_temp (shd s) p') +\n                      c_glob (shd s) q'", "apply (simp add: sum.distrib)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' = q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         if p' = p\n                         then sum_list (c_msg (shd s) p q) +\n                              - hd (c_msg (shd s) p q)\n                         else sum_list (c_msg (shd s) p' q)) +\n                      sum (c_temp (shd s)) UNIV +\n                      (c_glob (shd s) q + hd (c_msg (shd s) p q))\n 2. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list\n                          (if p' = p then c_msg (shd s) p q'\n                           else c_msg (shd s) p' q') +\n                         c_temp (shd s) p') +\n                      c_glob (shd s) q'", "apply (subst sum_if_distrib_add)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' = q\\<rbrakk>\n    \\<Longrightarrow> finite UNIV\n 2. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' = q\\<rbrakk>\n    \\<Longrightarrow> p \\<in> UNIV\n 3. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' = q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>a\\<in>UNIV. sum_list (c_msg (shd s) a q)) +\n                      - hd (c_msg (shd s) p q) +\n                      sum (c_temp (shd s)) UNIV +\n                      (c_glob (shd s) q + hd (c_msg (shd s) p q))\n 4. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list\n                          (if p' = p then c_msg (shd s) p q'\n                           else c_msg (shd s) p' q') +\n                         c_temp (shd s) p') +\n                      c_glob (shd s) q'", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' = q\\<rbrakk>\n    \\<Longrightarrow> p \\<in> UNIV\n 2. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' = q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>a\\<in>UNIV. sum_list (c_msg (shd s) a q)) +\n                      - hd (c_msg (shd s) p q) +\n                      sum (c_temp (shd s)) UNIV +\n                      (c_glob (shd s) q + hd (c_msg (shd s) p q))\n 3. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list\n                          (if p' = p then c_msg (shd s) p q'\n                           else c_msg (shd s) p' q') +\n                         c_temp (shd s) p') +\n                      c_glob (shd s) q'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV. sum_list (c_msg (shd s) p' q)) +\n                sum (c_temp (shd s)) UNIV +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' = q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>a\\<in>UNIV. sum_list (c_msg (shd s) a q)) +\n                      - hd (c_msg (shd s) p q) +\n                      sum (c_temp (shd s)) UNIV +\n                      (c_glob (shd s) q + hd (c_msg (shd s) p q))\n 2. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list\n                          (if p' = p then c_msg (shd s) p q'\n                           else c_msg (shd s) p' q') +\n                         c_temp (shd s) p') +\n                      c_glob (shd s) q'", "apply (simp add: add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list\n                          (if p' = p then c_msg (shd s) p q'\n                           else c_msg (shd s) p' q') +\n                         c_temp (shd s) p') +\n                      c_glob (shd s) q'", "apply (subst if_eq_same)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                c_records (shd s) =\n                (\\<Sum>p'\\<in>UNIV.\n                   sum_list (c_msg (shd s) p' q) + c_temp (shd s) p') +\n                c_glob (shd s) q;\n     c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg :=\n               \\<lambda>x.\n                  if x = p\n                  then \\<lambda>x.\n                          if x = q then tl (c_msg (shd s) p q)\n                          else c_msg (shd s) p x\n                  else c_msg (shd s) x,\n        c_glob :=\n          \\<lambda>x.\n             if x = q then c_glob (shd s) q + hd (c_msg (shd s) p q)\n             else c_glob (shd s) x\\<rparr>;\n     q' \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> c_records (shd s) =\n                      (\\<Sum>p'\\<in>UNIV.\n                         sum_list (c_msg (shd s) p' q') +\n                         c_temp (shd s) p') +\n                      c_glob (shd s) q'", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds\n              (\\<lambda>c.\n                  \\<forall>q.\n                     c_records c =\n                     (\\<Sum>p'\\<in>UNIV.\n                        sum_list\n                         (drop (if p' = q then 0 else 0) (c_msg c p' q)) +\n                        c_temp c p') +\n                     c_glob c q)\n              s;\n     shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>q.\n                                   c_records c =\n                                   (\\<Sum>p'\\<in>UNIV.\nsum_list (drop (if p' = q then 0 else 0) (c_msg c p' q)) + c_temp c p') +\n                                   c_glob c q))\n                       s", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* This is inv2 in the short paper *)"], ["", "lemma alw_InvGlobalRecordCount: \"spec s \\<Longrightarrow> alw (holds InvGlobalRecordCount) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds InvGlobalRecordCount) s", "by (metis (no_types, lifting) alw_iff_sdrop alw_invar init_InvGlobalRecordCount next_InvGlobalRecordCount spec_def)"], ["", "definition InvGlobalIncomingInfoUpright where\n  \"InvGlobalIncomingInfoUpright c = (\\<forall>k p q. upright (GlobalIncomingInfo c k p q))\""], ["", "lemma upright_sum_upright: \"finite X \\<Longrightarrow> \\<forall>x. upright (A x) \\<Longrightarrow> upright (\\<Sum>x\\<in>X. A x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; \\<forall>x. upright (A x)\\<rbrakk>\n    \\<Longrightarrow> upright (sum A X)", "by (induct X rule: finite_induct) (auto simp: upright_0 upright_vec_add)"], ["", "lemma InvIncomingInfoUpright_imp_InvGlobalIncomingInfoUpright: \"holds InvIncomingInfoUpright s \\<Longrightarrow> holds InvGlobalIncomingInfoUpright s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. holds InvIncomingInfoUpright s \\<Longrightarrow>\n    holds InvGlobalIncomingInfoUpright s", "by (simp add: InvIncomingInfoUpright_def InvGlobalIncomingInfoUpright_def GlobalIncomingInfo_def upright_sum_upright)"], ["", "(* This is inv6 in the short paper *)"], ["", "lemma alw_InvGlobalIncomingInfoUpright: \"spec s \\<Longrightarrow> alw (holds InvGlobalIncomingInfoUpright) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds InvGlobalIncomingInfoUpright) s", "using InvIncomingInfoUpright_imp_InvGlobalIncomingInfoUpright alw_InvIncomingInfoUpright alw_mono"], ["proof (prove)\nusing this:\n  holds InvIncomingInfoUpright ?s \\<Longrightarrow>\n  holds InvGlobalIncomingInfoUpright ?s\n  spec ?s \\<Longrightarrow> alw (holds InvIncomingInfoUpright) ?s\n  \\<lbrakk>alw ?\\<phi> ?xs;\n   \\<And>xs. ?\\<phi> xs \\<Longrightarrow> ?\\<psi> xs\\<rbrakk>\n  \\<Longrightarrow> alw ?\\<psi> ?xs\n\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds InvGlobalIncomingInfoUpright) s", "by blast"], ["", "abbreviation nrec_pos where\n  \"nrec_pos c \\<equiv> \\<forall>t. zcount (c_records c) t \\<ge> 0\""], ["", "lemma init_nrec_pos: \"holds init_config s \\<Longrightarrow> holds nrec_pos s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. holds init_config s \\<Longrightarrow>\n    holds (\\<lambda>c. \\<forall>t. 0 \\<le> zcount (c_records c) t) s", "by (simp add: init_config_def)"], ["", "lemma next_nrec_pos: \"holds nrec_pos s \\<Longrightarrow> next s \\<Longrightarrow> nxt (holds nrec_pos) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds (\\<lambda>c. \\<forall>t. 0 \\<le> zcount (c_records c) t)\n              s;\n     next s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>t. 0 \\<le> zcount (c_records c) t))\n                       s", "unfolding next_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds (\\<lambda>c. \\<forall>t. 0 \\<le> zcount (c_records c) t)\n              s;\n     next_performop s \\<or>\n     next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> nxt (holds\n                            (\\<lambda>c.\n                                \\<forall>t. 0 \\<le> zcount (c_records c) t))\n                       s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     next_performop s \\<or>\n     next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>t. 0 \\<le> zcount (c_records (shd (stl s))) t", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        next_performop s \\<or>\n        next_sendupd s \\<or>\n        next_recvupd s \\<or> shd (stl s) = shd s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t", "apply (elim disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        next_performop s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t\n 2. \\<And>t.\n       \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        next_sendupd s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t\n 3. \\<And>t.\n       \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        next_recvupd s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t\n 4. \\<And>t.\n       \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        shd (stl s) = shd s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t", "subgoal for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     next_performop s\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t", "unfolding next_performop'_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     \\<exists>p c r.\n        (\\<forall>t.\n            int (count c t) \\<le> zcount (c_records (shd s)) t) \\<and>\n        upright (zmset_of r - zmset_of c) \\<and>\n        shd (stl s) = shd s\n        \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n           c_temp := (c_temp (shd s))\n             (p := c_temp (shd s) p +\n                   (zmset_of r - zmset_of c))\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p c r.\n       \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        \\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n        upright (zmset_of r - zmset_of c);\n        shd (stl s) = shd s\n        \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n           c_temp := (c_temp (shd s))\n             (p := c_temp (shd s) p +\n                   (zmset_of r - zmset_of c))\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t", "subgoal for p c r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     \\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p +\n                (zmset_of r - zmset_of c))\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t", "apply (simp add: add_diff_eq add.commute add_increasing)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        next_sendupd s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t\n 2. \\<And>t.\n       \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        next_recvupd s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t\n 3. \\<And>t.\n       \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        shd (stl s) = shd s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t", "subgoal for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t", "by (auto simp: next_sendupd'_def Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        next_recvupd s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t\n 2. \\<And>t.\n       \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        shd (stl s) = shd s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t", "subgoal for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t", "by (auto simp: next_recvupd'_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        shd (stl s) = shd s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> zcount (c_records (shd (stl s))) t_", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma alw_nrec_pos: \"spec s \\<Longrightarrow> alw (holds nrec_pos) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow>\n    alw (holds (\\<lambda>c. \\<forall>t. 0 \\<le> zcount (c_records c) t)) s", "by (metis (mono_tags, lifting) alw_iff_sdrop alw_invar init_nrec_pos next_nrec_pos spec_def)"], ["", "lemma next_performop_vacant:\n  \"vacant_upto (c_records (shd s)) t \\<Longrightarrow> next_performop s \\<Longrightarrow> vacant_upto (c_records (shd (stl s))) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NrecVacantUpto (shd s) t; next_performop s\\<rbrakk>\n    \\<Longrightarrow> NrecVacantUpto (shd (stl s)) t", "unfolding next_performop'_def Let_def vacant_upto_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>sa\\<le>t. zcount (c_records (shd s)) sa = 0;\n     \\<exists>p c r.\n        (\\<forall>t.\n            int (count c t) \\<le> zcount (c_records (shd s)) t) \\<and>\n        upright (zmset_of r - zmset_of c) \\<and>\n        shd (stl s) = shd s\n        \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n           c_temp := (c_temp (shd s))\n             (p := c_temp (shd s) p +\n                   (zmset_of r - zmset_of c))\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>sa\\<le>t.\n                         zcount (c_records (shd (stl s))) sa = 0", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p c sa r.\n       \\<lbrakk>\\<forall>sa\\<le>t. zcount (c_records (shd s)) sa = 0;\n        \\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n        upright (zmset_of r - zmset_of c);\n        shd (stl s) = shd s\n        \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n           c_temp := (c_temp (shd s))\n             (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n        sa \\<le> t\\<rbrakk>\n       \\<Longrightarrow> count r sa = count c sa", "subgoal for p c u r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>sa\\<le>t. zcount (c_records (shd s)) sa = 0;\n     \\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     u \\<le> t\\<rbrakk>\n    \\<Longrightarrow> count r u = count c u", "apply (clarsimp simp: upright_def supported_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>sa\\<le>t. zcount (c_records (shd s)) sa = 0;\n     \\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     \\<forall>t.\n        count c t < count r t \\<longrightarrow>\n        (\\<exists>s<t. count r s < count c s);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     u \\<le> t\\<rbrakk>\n    \\<Longrightarrow> count r u = count c u", "apply (metis (no_types, hide_lams) gr_implies_not_zero of_nat_le_0_iff order.strict_implies_order order_trans zero_less_iff_neq_zero)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma next_sendupd_vacant:\n  \"vacant_upto (c_records (shd s)) t \\<Longrightarrow> next_sendupd s \\<Longrightarrow> vacant_upto (c_records (shd (stl s))) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NrecVacantUpto (shd s) t; next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> NrecVacantUpto (shd (stl s)) t", "by (auto simp add: next_sendupd'_def Let_def)"], ["", "lemma next_recvupd_vacant:\n  \"vacant_upto (c_records (shd s)) t \\<Longrightarrow> next_recvupd s \\<Longrightarrow> vacant_upto (c_records (shd (stl s))) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NrecVacantUpto (shd s) t; next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> NrecVacantUpto (shd (stl s)) t", "by (auto simp add: next_recvupd'_def Let_def)"], ["", "lemma spec_imp_SafeStickyNrecVacantUpto_aux: \"alw next s \\<Longrightarrow> alw SafeStickyNrecVacantUpto s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw next s \\<Longrightarrow> alw SafeStickyNrecVacantUpto s", "apply (coinduction arbitrary: s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       alw next s \\<Longrightarrow>\n       \\<exists>xs.\n          s = xs \\<and>\n          SafeStickyNrecVacantUpto xs \\<and>\n          ((\\<exists>s. stl xs = s \\<and> alw next s) \\<or>\n           alw SafeStickyNrecVacantUpto (stl xs))", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw next s \\<Longrightarrow>\n    \\<exists>xs.\n       s = xs \\<and>\n       SafeStickyNrecVacantUpto xs \\<and>\n       ((\\<exists>s. stl xs = s \\<and> alw next s) \\<or>\n        alw SafeStickyNrecVacantUpto (stl xs))", "unfolding spec_def next_def SafeStickyNrecVacantUpto_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>s.\n            next_performop s \\<or>\n            next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n     s \\<Longrightarrow>\n    \\<exists>xs.\n       s = xs \\<and>\n       (\\<forall>t.\n           NrecVacantUpto (shd xs) t \\<longrightarrow>\n           alw (holds (\\<lambda>c. NrecVacantUpto c t)) xs) \\<and>\n       ((\\<exists>s.\n            stl xs = s \\<and>\n            alw (\\<lambda>s.\n                    next_performop s \\<or>\n                    next_sendupd s \\<or>\n                    next_recvupd s \\<or> shd (stl s) = shd s)\n             s) \\<or>\n        alw (\\<lambda>s.\n                \\<forall>t.\n                   NrecVacantUpto (shd s) t \\<longrightarrow>\n                   alw (holds (\\<lambda>c. NrecVacantUpto c t)) s)\n         (stl xs))", "apply (rule exI[of _ s])"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>s.\n            next_performop s \\<or>\n            next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n     s \\<Longrightarrow>\n    s = s \\<and>\n    (\\<forall>t.\n        NrecVacantUpto (shd s) t \\<longrightarrow>\n        alw (holds (\\<lambda>c. NrecVacantUpto c t)) s) \\<and>\n    ((\\<exists>s.\n         stl s = s \\<and>\n         alw (\\<lambda>s.\n                 next_performop s \\<or>\n                 next_sendupd s \\<or>\n                 next_recvupd s \\<or> shd (stl s) = shd s)\n          s) \\<or>\n     alw (\\<lambda>s.\n             \\<forall>t.\n                NrecVacantUpto (shd s) t \\<longrightarrow>\n                alw (holds (\\<lambda>c. NrecVacantUpto c t)) s)\n      (stl s))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>alw (\\<lambda>s.\n                        next_performop s \\<or>\n                        next_sendupd s \\<or>\n                        next_recvupd s \\<or> shd (stl s) = shd s)\n                 s;\n        NrecVacantUpto (shd s) t\\<rbrakk>\n       \\<Longrightarrow> alw (holds (\\<lambda>c. NrecVacantUpto c t)) s\n 2. \\<lbrakk>alw (\\<lambda>s.\n                     next_performop s \\<or>\n                     next_sendupd s \\<or>\n                     next_recvupd s \\<or> shd (stl s) = shd s)\n              s;\n     \\<not> alw (\\<lambda>s.\n                    \\<forall>t.\n                       NrecVacantUpto (shd s) t \\<longrightarrow>\n                       alw (holds (\\<lambda>c. NrecVacantUpto c t)) s)\n             (stl s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s.\n                         stl s = s \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          s", "subgoal for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (\\<lambda>s.\n                     next_performop s \\<or>\n                     next_sendupd s \\<or>\n                     next_recvupd s \\<or> shd (stl s) = shd s)\n              s;\n     NrecVacantUpto (shd s) t\\<rbrakk>\n    \\<Longrightarrow> alw (holds (\\<lambda>c. NrecVacantUpto c t)) s", "apply (coinduction arbitrary: s rule: alw.coinduct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (\\<lambda>s.\n                        next_performop s \\<or>\n                        next_sendupd s \\<or>\n                        next_recvupd s \\<or> shd (stl s) = shd s)\n                 s;\n        NrecVacantUpto (shd s) t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            s = xs \\<and>\n                            holds (\\<lambda>c. NrecVacantUpto c t) xs \\<and>\n                            ((\\<exists>s.\n                                 stl xs = s \\<and>\n                                 alw (\\<lambda>s.\n   next_performop s \\<or>\n   next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n                                  s \\<and>\n                                 NrecVacantUpto (shd s) t) \\<or>\n                             alw (holds (\\<lambda>c. NrecVacantUpto c t))\n                              (stl xs))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (\\<lambda>s.\n                        next_performop s \\<or>\n                        next_sendupd s \\<or>\n                        next_recvupd s \\<or> shd (stl s) = shd s)\n                 s;\n        NrecVacantUpto (shd s) t;\n        \\<not> alw (holds (\\<lambda>c. NrecVacantUpto c t)) (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         NrecVacantUpto (shd (stl s)) t", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>alw (\\<lambda>s.\n                        next_performop s \\<or>\n                        next_sendupd s \\<or>\n                        next_recvupd s \\<or> shd (stl s) = shd s)\n                 s;\n        NrecVacantUpto (shd s) t;\n        \\<not> alw (holds (\\<lambda>c. NrecVacantUpto c t)) (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s)\n 2. \\<And>s.\n       \\<lbrakk>alw (\\<lambda>s.\n                        next_performop s \\<or>\n                        next_sendupd s \\<or>\n                        next_recvupd s \\<or> shd (stl s) = shd s)\n                 s;\n        NrecVacantUpto (shd s) t;\n        \\<not> alw (holds (\\<lambda>c. NrecVacantUpto c t)) (stl s)\\<rbrakk>\n       \\<Longrightarrow> NrecVacantUpto (shd (stl s)) t", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (\\<lambda>s.\n                        next_performop s \\<or>\n                        next_sendupd s \\<or>\n                        next_recvupd s \\<or> shd (stl s) = shd s)\n                 s;\n        NrecVacantUpto (shd s) t;\n        \\<not> alw (holds (\\<lambda>c. NrecVacantUpto c t)) (stl s)\\<rbrakk>\n       \\<Longrightarrow> NrecVacantUpto (shd (stl s)) t", "apply (erule alw.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s xs.\n       \\<lbrakk>NrecVacantUpto (shd s) t;\n        \\<not> alw (holds (\\<lambda>c. NrecVacantUpto c t)) (stl s); s = xs;\n        next_performop xs \\<or>\n        next_sendupd xs \\<or> next_recvupd xs \\<or> shd (stl xs) = shd xs;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         (stl xs)\\<rbrakk>\n       \\<Longrightarrow> NrecVacantUpto (shd (stl s)) t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>NrecVacantUpto (shd xs) t;\n        \\<not> alw (holds (\\<lambda>c. NrecVacantUpto c t)) (stl xs);\n        next_performop xs \\<or>\n        next_sendupd xs \\<or> next_recvupd xs \\<or> shd (stl xs) = shd xs;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         (stl xs)\\<rbrakk>\n       \\<Longrightarrow> NrecVacantUpto (shd (stl xs)) t", "apply (elim disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>NrecVacantUpto (shd xs) t;\n        \\<not> alw (holds (\\<lambda>c. NrecVacantUpto c t)) (stl xs);\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         (stl xs);\n        next_performop xs\\<rbrakk>\n       \\<Longrightarrow> NrecVacantUpto (shd (stl xs)) t\n 2. \\<And>xs.\n       \\<lbrakk>NrecVacantUpto (shd xs) t;\n        \\<not> alw (holds (\\<lambda>c. NrecVacantUpto c t)) (stl xs);\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         (stl xs);\n        next_sendupd xs\\<rbrakk>\n       \\<Longrightarrow> NrecVacantUpto (shd (stl xs)) t\n 3. \\<And>xs.\n       \\<lbrakk>NrecVacantUpto (shd xs) t;\n        \\<not> alw (holds (\\<lambda>c. NrecVacantUpto c t)) (stl xs);\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         (stl xs);\n        next_recvupd xs\\<rbrakk>\n       \\<Longrightarrow> NrecVacantUpto (shd (stl xs)) t\n 4. \\<And>xs.\n       \\<lbrakk>NrecVacantUpto (shd xs) t;\n        \\<not> alw (holds (\\<lambda>c. NrecVacantUpto c t)) (stl xs);\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         (stl xs);\n        shd (stl xs) = shd xs\\<rbrakk>\n       \\<Longrightarrow> NrecVacantUpto (shd (stl xs)) t", "apply (simp_all add: next_performop_vacant next_sendupd_vacant next_recvupd_vacant)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (\\<lambda>s.\n                     next_performop s \\<or>\n                     next_sendupd s \\<or>\n                     next_recvupd s \\<or> shd (stl s) = shd s)\n              s;\n     \\<not> alw (\\<lambda>s.\n                    \\<forall>t.\n                       NrecVacantUpto (shd s) t \\<longrightarrow>\n                       alw (holds (\\<lambda>c. NrecVacantUpto c t)) s)\n             (stl s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s.\n                         stl s = s \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          s", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma spec_imp_SafeStickyNrecVacantUpto: \"spec s \\<Longrightarrow> alw SafeStickyNrecVacantUpto s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw SafeStickyNrecVacantUpto s", "unfolding spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. holds init_config s \\<and> alw next s \\<Longrightarrow>\n    alw SafeStickyNrecVacantUpto s", "by (blast intro: spec_imp_SafeStickyNrecVacantUpto_aux)"], ["", "lemma invs_imp_InvGlobVacantUptoImpliesNrec:\n  assumes \"holds InvGlobalIncomingInfoUpright s\"\n  assumes \"holds InvGlobalRecordCount s\"\n  assumes \"holds nrec_pos s\"\n  shows \"holds InvGlobVacantUptoImpliesNrec s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. holds InvGlobVacantUptoImpliesNrec s", "using assms"], ["proof (prove)\nusing this:\n  holds InvGlobalIncomingInfoUpright s\n  holds InvGlobalRecordCount s\n  holds (\\<lambda>c. \\<forall>t. 0 \\<le> zcount (c_records c) t) s\n\ngoal (1 subgoal):\n 1. holds InvGlobVacantUptoImpliesNrec s", "unfolding InvGlobVacantUptoImpliesNrec_def"], ["proof (prove)\nusing this:\n  holds InvGlobalIncomingInfoUpright s\n  holds InvGlobalRecordCount s\n  holds (\\<lambda>c. \\<forall>t. 0 \\<le> zcount (c_records c) t) s\n\ngoal (1 subgoal):\n 1. holds\n     (\\<lambda>c.\n         \\<forall>t q.\n            GlobVacantUpto c q t \\<longrightarrow> NrecVacantUpto c t)\n     s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n     InvGlobalRecordCount (shd s);\n     \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t\\<rbrakk>\n    \\<Longrightarrow> \\<forall>t.\n                         (\\<exists>q.\n                             GlobVacantUpto (shd s) q t) \\<longrightarrow>\n                         NrecVacantUpto (shd s) t", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t q.\n       \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n        InvGlobalRecordCount (shd s);\n        \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        GlobVacantUpto (shd s) q t\\<rbrakk>\n       \\<Longrightarrow> NrecVacantUpto (shd s) t", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t q.\n       \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n        InvGlobalRecordCount (shd s);\n        \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        GlobVacantUpto (shd s) q t; \\<not> NrecVacantUpto (shd s) t\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: vacant_upto_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t q.\n       \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n        InvGlobalRecordCount (shd s);\n        \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0;\n        \\<exists>sa\\<le>t. sa \\<in>#\\<^sub>z c_records (shd s)\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t q sa.\n       \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n        InvGlobalRecordCount (shd s);\n        \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n        \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0; sa \\<le> t;\n        sa \\<in>#\\<^sub>z c_records (shd s)\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for t q u"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n     InvGlobalRecordCount (shd s);\n     \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0; u \\<le> t;\n     u \\<in>#\\<^sub>z c_records (shd s)\\<rbrakk>\n    \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n     InvGlobalRecordCount (shd s);\n     \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0; u \\<le> t;\n     u \\<in>#\\<^sub>z c_records (shd s)\\<rbrakk>\n    \\<Longrightarrow> False", "assume globvut: \"\\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0\""], ["proof (state)\nthis:\n  \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n     InvGlobalRecordCount (shd s);\n     \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0; u \\<le> t;\n     u \\<in>#\\<^sub>z c_records (shd s)\\<rbrakk>\n    \\<Longrightarrow> False", "assume uleqt: \"u \\<le> t\""], ["proof (state)\nthis:\n  u \\<le> t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n     InvGlobalRecordCount (shd s);\n     \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0; u \\<le> t;\n     u \\<in>#\\<^sub>z c_records (shd s)\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"u \\<in>#\\<^sub>z c_records (shd s)\""], ["proof (state)\nthis:\n  u \\<in>#\\<^sub>z c_records (shd s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n     InvGlobalRecordCount (shd s);\n     \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0; u \\<le> t;\n     u \\<in>#\\<^sub>z c_records (shd s)\\<rbrakk>\n    \\<Longrightarrow> False", "with assms(3)"], ["proof (chain)\npicking this:\n  holds (\\<lambda>c. \\<forall>t. 0 \\<le> zcount (c_records c) t) s\n  u \\<in>#\\<^sub>z c_records (shd s)", "have \"0 < zcount (c_records (shd s)) u\""], ["proof (prove)\nusing this:\n  holds (\\<lambda>c. \\<forall>t. 0 \\<le> zcount (c_records c) t) s\n  u \\<in>#\\<^sub>z c_records (shd s)\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_records (shd s)) u", "by (simp add: order.not_eq_order_implies_strict)"], ["proof (state)\nthis:\n  0 < zcount (c_records (shd s)) u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n     InvGlobalRecordCount (shd s);\n     \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0; u \\<le> t;\n     u \\<in>#\\<^sub>z c_records (shd s)\\<rbrakk>\n    \\<Longrightarrow> False", "with assms(2) globvut uleqt"], ["proof (chain)\npicking this:\n  holds InvGlobalRecordCount s\n  \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0\n  u \\<le> t\n  0 < zcount (c_records (shd s)) u", "have *: \"0 < zcount (GlobalIncomingInfoAt (shd s) q) u\""], ["proof (prove)\nusing this:\n  holds InvGlobalRecordCount s\n  \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0\n  u \\<le> t\n  0 < zcount (c_records (shd s)) u\n\ngoal (1 subgoal):\n 1. 0 < zcount (GlobalIncomingInfoAt (shd s) q) u", "unfolding InvGlobalRecordCount_def"], ["proof (prove)\nusing this:\n  holds\n   (\\<lambda>c.\n       \\<forall>q. c_records c = GlobalIncomingInfoAt c q + c_glob c q)\n   s\n  \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0\n  u \\<le> t\n  0 < zcount (c_records (shd s)) u\n\ngoal (1 subgoal):\n 1. 0 < zcount (GlobalIncomingInfoAt (shd s) q) u", "by (auto dest: spec[of _ q])"], ["proof (state)\nthis:\n  0 < zcount (GlobalIncomingInfoAt (shd s) q) u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n     InvGlobalRecordCount (shd s);\n     \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0; u \\<le> t;\n     u \\<in>#\\<^sub>z c_records (shd s)\\<rbrakk>\n    \\<Longrightarrow> False", "from assms(1)[unfolded InvGlobalIncomingInfoUpright_def]"], ["proof (chain)\npicking this:\n  holds (\\<lambda>c. \\<forall>k p q. upright (GlobalIncomingInfo c k p q)) s", "have \"upright (GlobalIncomingInfoAt (shd s) q)\""], ["proof (prove)\nusing this:\n  holds (\\<lambda>c. \\<forall>k p q. upright (GlobalIncomingInfo c k p q)) s\n\ngoal (1 subgoal):\n 1. upright (GlobalIncomingInfoAt (shd s) q)", "by simp"], ["proof (state)\nthis:\n  upright (GlobalIncomingInfoAt (shd s) q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n     InvGlobalRecordCount (shd s);\n     \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0; u \\<le> t;\n     u \\<in>#\\<^sub>z c_records (shd s)\\<rbrakk>\n    \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  0 < zcount (GlobalIncomingInfoAt (shd s) q) u\n  upright (GlobalIncomingInfoAt (shd s) q)", "obtain v where **: \"v \\<le> u\" \"zcount (GlobalIncomingInfoAt (shd s) q) v < 0\""], ["proof (prove)\nusing this:\n  0 < zcount (GlobalIncomingInfoAt (shd s) q) u\n  upright (GlobalIncomingInfoAt (shd s) q)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<le> u;\n         zcount (GlobalIncomingInfoAt (shd s) q) v < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson order.strict_iff_order upright_def supported_def)"], ["proof (state)\nthis:\n  v \\<le> u\n  zcount (GlobalIncomingInfoAt (shd s) q) v < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n     InvGlobalRecordCount (shd s);\n     \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0; u \\<le> t;\n     u \\<in>#\\<^sub>z c_records (shd s)\\<rbrakk>\n    \\<Longrightarrow> False", "with assms(2)"], ["proof (chain)\npicking this:\n  holds InvGlobalRecordCount s\n  v \\<le> u\n  zcount (GlobalIncomingInfoAt (shd s) q) v < 0", "have \"zcount (c_records (shd s)) v < 0\""], ["proof (prove)\nusing this:\n  holds InvGlobalRecordCount s\n  v \\<le> u\n  zcount (GlobalIncomingInfoAt (shd s) q) v < 0\n\ngoal (1 subgoal):\n 1. zcount (c_records (shd s)) v < 0", "by (metis (no_types, hide_lams) InvGlobalRecordCount_def add.right_neutral order.trans globvut holds.elims(2) uleqt zcount_union)"], ["proof (state)\nthis:\n  zcount (c_records (shd s)) v < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalIncomingInfoUpright (shd s);\n     InvGlobalRecordCount (shd s);\n     \\<forall>t. 0 \\<le> zcount (c_records (shd s)) t;\n     \\<forall>sa\\<le>t. zcount (c_glob (shd s) q) sa = 0; u \\<le> t;\n     u \\<in>#\\<^sub>z c_records (shd s)\\<rbrakk>\n    \\<Longrightarrow> False", "with assms(3)"], ["proof (chain)\npicking this:\n  holds (\\<lambda>c. \\<forall>t. 0 \\<le> zcount (c_records c) t) s\n  zcount (c_records (shd s)) v < 0", "show \"False\""], ["proof (prove)\nusing this:\n  holds (\\<lambda>c. \\<forall>t. 0 \\<le> zcount (c_records c) t) s\n  zcount (c_records (shd s)) v < 0\n\ngoal (1 subgoal):\n 1. False", "using atLeastatMost_empty"], ["proof (prove)\nusing this:\n  holds (\\<lambda>c. \\<forall>t. 0 \\<le> zcount (c_records c) t) s\n  zcount (c_records (shd s)) v < 0\n  ?b < ?a \\<Longrightarrow> {?a..?b} = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma spec_imp_inv1: \"spec s \\<Longrightarrow> alw (holds InvGlobVacantUptoImpliesNrec) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds InvGlobVacantUptoImpliesNrec) s", "by (metis (mono_tags, lifting) alw_iff_sdrop invs_imp_InvGlobVacantUptoImpliesNrec alw_InvGlobalIncomingInfoUpright alw_InvGlobalRecordCount alw_nrec_pos)"], ["", "lemma safe2_inv1_imp_safe: \"SafeStickyNrecVacantUpto s \\<Longrightarrow> holds InvGlobVacantUptoImpliesNrec s \\<Longrightarrow> SafeGlobVacantUptoImpliesStickyNrec s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SafeStickyNrecVacantUpto s;\n     holds InvGlobVacantUptoImpliesNrec s\\<rbrakk>\n    \\<Longrightarrow> SafeGlobVacantUptoImpliesStickyNrec s", "by (simp add: InvGlobVacantUptoImpliesNrec_def SafeStickyNrecVacantUpto_def SafeGlobVacantUptoImpliesStickyNrec_def)"], ["", "lemma spec_imp_safe: \"spec s \\<Longrightarrow> alw SafeGlobVacantUptoImpliesStickyNrec s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw SafeGlobVacantUptoImpliesStickyNrec s", "by (meson alw_iff_sdrop safe2_inv1_imp_safe spec_imp_SafeStickyNrecVacantUpto spec_imp_inv1)"], ["", "(* Second safety property from here on (glob stays vacant) *)"], ["", "lemma beta_upright_0: \"beta_upright 0 vb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beta_upright {#}\\<^sub>z vb", "unfolding beta_upright_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       0 < zcount {#}\\<^sub>z t \\<longrightarrow>\n       (\\<exists>s<t. zcount {#}\\<^sub>z s < 0 \\<or> zcount vb s < 0)", "by auto"], ["", "definition PositiveImplies where\n  \"PositiveImplies v w = (\\<forall>t. zcount v t > 0 \\<longrightarrow> zcount w t > 0)\""], ["", "lemma betaupright_PositiveImplies: \"upright (va + vb) \\<Longrightarrow> PositiveImplies va (va + vb) \\<Longrightarrow> beta_upright va vb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>upright (va + vb); PositiveImplies va (va + vb)\\<rbrakk>\n    \\<Longrightarrow> beta_upright va vb", "unfolding beta_upright_def PositiveImplies_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>upright (va + vb);\n     \\<forall>t.\n        0 < zcount va t \\<longrightarrow> 0 < zcount (va + vb) t\\<rbrakk>\n    \\<Longrightarrow> \\<forall>t.\n                         0 < zcount va t \\<longrightarrow>\n                         (\\<exists>s<t.\n                             zcount va s < 0 \\<or> zcount vb s < 0)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>upright (va + vb);\n        \\<forall>t.\n           0 < zcount va t \\<longrightarrow> 0 < zcount (va + vb) t;\n        0 < zcount va t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s<t. zcount va s < 0 \\<or> zcount vb s < 0", "subgoal for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>upright (va + vb);\n     \\<forall>t. 0 < zcount va t \\<longrightarrow> 0 < zcount (va + vb) t;\n     0 < zcount va t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s<t. zcount va s < 0 \\<or> zcount vb s < 0", "apply (erule upright_obtain_support[of _ t])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t.\n                0 < zcount va t \\<longrightarrow> 0 < zcount (va + vb) t;\n     0 < zcount va t\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount (va + vb) t\n 2. \\<And>s.\n       \\<lbrakk>\\<forall>t.\n                   0 < zcount va t \\<longrightarrow> 0 < zcount (va + vb) t;\n        0 < zcount va t; s < t; zcount (va + vb) s < 0;\n        nonpos_upto (va + vb) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s<t. zcount va s < 0 \\<or> zcount vb s < 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>t.\n                   0 < zcount va t \\<longrightarrow> 0 < zcount (va + vb) t;\n        0 < zcount va t; s < t; zcount (va + vb) s < 0;\n        nonpos_upto (va + vb) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s<t. zcount va s < 0 \\<or> zcount vb s < 0", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t.\n                0 < zcount va t \\<longrightarrow> 0 < zcount (va + vb) t;\n     0 < zcount va t; s < t; zcount (va + vb) s < 0;\n     nonpos_upto (va + vb) s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s<t. zcount va s < 0 \\<or> zcount vb s < 0", "apply (rule exI[of _ s])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t.\n                0 < zcount va t \\<longrightarrow> 0 < zcount (va + vb) t;\n     0 < zcount va t; s < t; zcount (va + vb) s < 0;\n     nonpos_upto (va + vb) s\\<rbrakk>\n    \\<Longrightarrow> s < t \\<and> (zcount va s < 0 \\<or> zcount vb s < 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t.\n                0 < zcount va t \\<longrightarrow>\n                0 < zcount va t + zcount vb t;\n     0 < zcount va t; s < t; zcount va s + zcount vb s < 0;\n     \\<forall>sa\\<le>s. zcount va sa + zcount vb sa \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> zcount va s < 0 \\<or> zcount vb s < 0", "apply (simp add: add_less_zeroD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma betaupright_obtain_support:\n  assumes \"beta_upright va vb\"\n    \"zcount va t > 0\"\n  obtains s where \"s < t\" \"zcount va s < 0 \\<or> zcount vb s < 0\" \"nonpos_upto va s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s < t; zcount va s < 0 \\<or> zcount vb s < 0;\n         nonpos_upto va s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  beta_upright va vb\n  0 < zcount va t\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s < t; zcount va s < 0 \\<or> zcount vb s < 0;\n         nonpos_upto va s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: beta_upright_alt)"], ["", "lemma betaupright_upright_vut:\n  assumes \"beta_upright va vb\"\n    and     \"upright vb\"\n    and     \"vacant_upto (va + vb) t\"\n  shows   \"vacant_upto va t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vacant_upto va t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vacant_upto va t", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. vacant_upto va t", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. vacant_upto va t", "assume s: \"s \\<le> t\" \"zcount va s > 0\""], ["proof (state)\nthis:\n  s \\<le> t\n  0 < zcount va s\n\ngoal (1 subgoal):\n 1. vacant_upto va t", "with assms"], ["proof (chain)\npicking this:\n  beta_upright va vb\n  upright vb\n  vacant_upto (va + vb) t\n  s \\<le> t\n  0 < zcount va s", "obtain x where x: \"x < s\" \"zcount va x < 0 \\<or> zcount vb x < 0\" \"nonpos_upto va x\""], ["proof (prove)\nusing this:\n  beta_upright va vb\n  upright vb\n  vacant_upto (va + vb) t\n  s \\<le> t\n  0 < zcount va s\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x < s; zcount va x < 0 \\<or> zcount vb x < 0;\n         nonpos_upto va x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using betaupright_obtain_support"], ["proof (prove)\nusing this:\n  beta_upright va vb\n  upright vb\n  vacant_upto (va + vb) t\n  s \\<le> t\n  0 < zcount va s\n  \\<lbrakk>beta_upright ?va ?vb; 0 < zcount ?va ?t;\n   \\<And>s.\n      \\<lbrakk>s < ?t; zcount ?va s < 0 \\<or> zcount ?vb s < 0;\n       nonpos_upto ?va s\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x < s; zcount va x < 0 \\<or> zcount vb x < 0;\n         nonpos_upto va x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x < s\n  zcount va x < 0 \\<or> zcount vb x < 0\n  nonpos_upto va x\n\ngoal (1 subgoal):\n 1. vacant_upto va t", "then"], ["proof (chain)\npicking this:\n  x < s\n  zcount va x < 0 \\<or> zcount vb x < 0\n  nonpos_upto va x", "have False"], ["proof (prove)\nusing this:\n  x < s\n  zcount va x < 0 \\<or> zcount vb x < 0\n  nonpos_upto va x\n\ngoal (1 subgoal):\n 1. False", "proof (cases \"zcount va x < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x < s; zcount va x < 0 \\<or> zcount vb x < 0; nonpos_upto va x;\n     zcount va x < 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>x < s; zcount va x < 0 \\<or> zcount vb x < 0; nonpos_upto va x;\n     \\<not> zcount va x < 0\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  zcount va x < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x < s; zcount va x < 0 \\<or> zcount vb x < 0; nonpos_upto va x;\n     zcount va x < 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>x < s; zcount va x < 0 \\<or> zcount vb x < 0; nonpos_upto va x;\n     \\<not> zcount va x < 0\\<rbrakk>\n    \\<Longrightarrow> False", "with assms(2,3) s x(1,3)"], ["proof (chain)\npicking this:\n  upright vb\n  vacant_upto (va + vb) t\n  s \\<le> t\n  0 < zcount va s\n  x < s\n  nonpos_upto va x\n  zcount va x < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  upright vb\n  vacant_upto (va + vb) t\n  s \\<le> t\n  0 < zcount va s\n  x < s\n  nonpos_upto va x\n  zcount va x < 0\n\ngoal (1 subgoal):\n 1. False", "unfolding vacant_upto_def"], ["proof (prove)\nusing this:\n  upright vb\n  \\<forall>s\\<le>t. zcount (va + vb) s = 0\n  s \\<le> t\n  0 < zcount va s\n  x < s\n  nonpos_upto va x\n  zcount va x < 0\n\ngoal (1 subgoal):\n 1. False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>upright vb; \\<forall>s\\<le>t. zcount va s + zcount vb s = 0;\n     s \\<le> t; 0 < zcount va s; x < s; nonpos_upto va x;\n     zcount va x < 0\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule upright_obtain_support[of vb x])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>s\\<le>t. zcount va s + zcount vb s = 0; s \\<le> t;\n     0 < zcount va s; x < s; nonpos_upto va x; zcount va x < 0\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount vb x\n 2. \\<And>sa.\n       \\<lbrakk>\\<forall>s\\<le>t. zcount va s + zcount vb s = 0; s \\<le> t;\n        0 < zcount va s; x < s; nonpos_upto va x; zcount va x < 0; sa < x;\n        zcount vb sa < 0; nonpos_upto vb sa\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis add_less_same_cancel2 order.trans order.strict_implies_order)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>\\<forall>s\\<le>t. zcount va s + zcount vb s = 0; s \\<le> t;\n        0 < zcount va s; x < s; nonpos_upto va x; zcount va x < 0; sa < x;\n        zcount vb sa < 0; nonpos_upto vb sa\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis add_less_same_cancel1 add_neg_neg order.order_iff_strict order.trans less_irrefl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < s; zcount va x < 0 \\<or> zcount vb x < 0; nonpos_upto va x;\n     \\<not> zcount va x < 0\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < s; zcount va x < 0 \\<or> zcount vb x < 0; nonpos_upto va x;\n     \\<not> zcount va x < 0\\<rbrakk>\n    \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> zcount va x < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < s; zcount va x < 0 \\<or> zcount vb x < 0; nonpos_upto va x;\n     \\<not> zcount va x < 0\\<rbrakk>\n    \\<Longrightarrow> False", "with assms s x"], ["proof (chain)\npicking this:\n  beta_upright va vb\n  upright vb\n  vacant_upto (va + vb) t\n  s \\<le> t\n  0 < zcount va s\n  x < s\n  zcount va x < 0 \\<or> zcount vb x < 0\n  nonpos_upto va x\n  \\<not> zcount va x < 0", "have \"x \\<le> t\" \"zcount va x > 0\""], ["proof (prove)\nusing this:\n  beta_upright va vb\n  upright vb\n  vacant_upto (va + vb) t\n  s \\<le> t\n  0 < zcount va s\n  x < s\n  zcount va x < 0 \\<or> zcount vb x < 0\n  nonpos_upto va x\n  \\<not> zcount va x < 0\n\ngoal (1 subgoal):\n 1. x \\<le> t &&& 0 < zcount va x", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>beta_upright va vb; upright vb; vacant_upto (va + vb) t;\n     s \\<le> t; 0 < zcount va s; x < s;\n     zcount va x < 0 \\<or> zcount vb x < 0; nonpos_upto va x;\n     \\<not> zcount va x < 0\\<rbrakk>\n    \\<Longrightarrow> x \\<le> t\n 2. \\<lbrakk>beta_upright va vb; upright vb; vacant_upto (va + vb) t;\n     s \\<le> t; 0 < zcount va s; x < s;\n     zcount va x < 0 \\<or> zcount vb x < 0; nonpos_upto va x;\n     \\<not> zcount va x < 0\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount va x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>beta_upright va vb; upright vb; vacant_upto (va + vb) t;\n     s \\<le> t; 0 < zcount va s; x < s;\n     zcount va x < 0 \\<or> zcount vb x < 0; nonpos_upto va x;\n     \\<not> zcount va x < 0\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount va x", "apply (metis (no_types, hide_lams) add.left_neutral order.order_iff_strict order.trans vacant_upto_def zcount_union)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<le> t\n  0 < zcount va x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < s; zcount va x < 0 \\<or> zcount vb x < 0; nonpos_upto va x;\n     \\<not> zcount va x < 0\\<rbrakk>\n    \\<Longrightarrow> False", "with assms(2,3) s x"], ["proof (chain)\npicking this:\n  upright vb\n  vacant_upto (va + vb) t\n  s \\<le> t\n  0 < zcount va s\n  x < s\n  zcount va x < 0 \\<or> zcount vb x < 0\n  nonpos_upto va x\n  x \\<le> t\n  0 < zcount va x", "show ?thesis"], ["proof (prove)\nusing this:\n  upright vb\n  vacant_upto (va + vb) t\n  s \\<le> t\n  0 < zcount va s\n  x < s\n  zcount va x < 0 \\<or> zcount vb x < 0\n  nonpos_upto va x\n  x \\<le> t\n  0 < zcount va x\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. vacant_upto va t", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?s2 \\<le> t; 0 < zcount va ?s2\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. vacant_upto va t", "note r = this"], ["proof (state)\nthis:\n  \\<lbrakk>?s2 \\<le> t; 0 < zcount va ?s2\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. vacant_upto va t", "from assms(2,3)"], ["proof (chain)\npicking this:\n  upright vb\n  vacant_upto (va + vb) t", "show ?thesis"], ["proof (prove)\nusing this:\n  upright vb\n  vacant_upto (va + vb) t\n\ngoal (1 subgoal):\n 1. vacant_upto va t", "unfolding vacant_upto_def"], ["proof (prove)\nusing this:\n  upright vb\n  \\<forall>s\\<le>t. zcount (va + vb) s = 0\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<le>t. zcount va s = 0", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>upright vb; \\<forall>s\\<le>t. zcount va s + zcount vb s = 0;\n        s \\<le> t\\<rbrakk>\n       \\<Longrightarrow> zcount va s = 0", "apply (metis (no_types, hide_lams) r add_cancel_right_left order.order_iff_strict order.trans le_less_linear less_add_same_cancel2 upright_obtain_support)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  vacant_upto va t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma beta_upright_add:\n  assumes \"upright vb\"\n    and     \"upright vc\"\n    and     \"beta_upright va vb\"\n  shows   \"beta_upright va (vb + vc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "assume \"0 < zcount va t\""], ["proof (state)\nthis:\n  0 < zcount va t\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "assume assm: \"\\<not>(\\<exists>s<t. (zcount va s < 0 \\<or> zcount vb s + zcount vc s < 0) \\<and> \\<not>(\\<exists>u \\<le> s. zcount va u > 0))\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>s<t.\n             (zcount va s < 0 \\<or> zcount vb s + zcount vc s < 0) \\<and>\n             \\<not> (\\<exists>u\\<le>s. 0 < zcount va u))\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "from \\<open>0 < zcount va t\\<close> assms(3)"], ["proof (chain)\npicking this:\n  0 < zcount va t\n  beta_upright va vb", "obtain x where x: \"x < t \\<and> (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\""], ["proof (prove)\nusing this:\n  0 < zcount va t\n  beta_upright va vb\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x < t \\<and>\n        (zcount va x < 0 \\<or> zcount vb x < 0) \\<and>\n        nonpos_upto va x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using betaupright_obtain_support"], ["proof (prove)\nusing this:\n  0 < zcount va t\n  beta_upright va vb\n  \\<lbrakk>beta_upright ?va ?vb; 0 < zcount ?va ?t;\n   \\<And>s.\n      \\<lbrakk>s < ?t; zcount ?va s < 0 \\<or> zcount ?vb s < 0;\n       nonpos_upto ?va s\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x < t \\<and>\n        (zcount va x < 0 \\<or> zcount vb x < 0) \\<and>\n        nonpos_upto va x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "then"], ["proof (chain)\npicking this:\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x", "have \"\\<not> zcount va x < 0\""], ["proof (prove)\nusing this:\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n\ngoal (1 subgoal):\n 1. \\<not> zcount va x < 0", "using assm"], ["proof (prove)\nusing this:\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n  \\<not> (\\<exists>s<t.\n             (zcount va s < 0 \\<or> zcount vb s + zcount vc s < 0) \\<and>\n             \\<not> (\\<exists>u\\<le>s. 0 < zcount va u))\n\ngoal (1 subgoal):\n 1. \\<not> zcount va x < 0", "by force"], ["proof (state)\nthis:\n  \\<not> zcount va x < 0\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "with x"], ["proof (chain)\npicking this:\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n  \\<not> zcount va x < 0", "have \"zcount vb x < 0\""], ["proof (prove)\nusing this:\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n  \\<not> zcount va x < 0\n\ngoal (1 subgoal):\n 1. zcount vb x < 0", "by blast"], ["proof (state)\nthis:\n  zcount vb x < 0\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "from assm x"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>s<t.\n             (zcount va s < 0 \\<or> zcount vb s + zcount vc s < 0) \\<and>\n             \\<not> (\\<exists>u\\<le>s. 0 < zcount va u))\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x", "have \"\\<not> zcount vb x + zcount vc x < 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>s<t.\n             (zcount va s < 0 \\<or> zcount vb s + zcount vc s < 0) \\<and>\n             \\<not> (\\<exists>u\\<le>s. 0 < zcount va u))\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n\ngoal (1 subgoal):\n 1. \\<not> zcount vb x + zcount vc x < 0", "using not_le"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>s<t.\n             (zcount va s < 0 \\<or> zcount vb s + zcount vc s < 0) \\<and>\n             \\<not> (\\<exists>u\\<le>s. 0 < zcount va u))\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. \\<not> zcount vb x + zcount vc x < 0", "by blast"], ["proof (state)\nthis:\n  \\<not> zcount vb x + zcount vc x < 0\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "with \\<open>zcount vb x < 0\\<close>"], ["proof (chain)\npicking this:\n  zcount vb x < 0\n  \\<not> zcount vb x + zcount vc x < 0", "have \"zcount vc x > 0\""], ["proof (prove)\nusing this:\n  zcount vb x < 0\n  \\<not> zcount vb x + zcount vc x < 0\n\ngoal (1 subgoal):\n 1. 0 < zcount vc x", "by clarsimp"], ["proof (state)\nthis:\n  0 < zcount vc x\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "with assms(2)"], ["proof (chain)\npicking this:\n  upright vc\n  0 < zcount vc x", "obtain y where y: \"y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y\""], ["proof (prove)\nusing this:\n  upright vc\n  0 < zcount vc x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y < x \\<and>\n        zcount vc y < 0 \\<and> nonpos_upto vc y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using upright_obtain_support"], ["proof (prove)\nusing this:\n  upright vc\n  0 < zcount vc x\n  \\<lbrakk>upright ?a; 0 < zcount ?a ?t;\n   \\<And>s.\n      \\<lbrakk>s < ?t; zcount ?a s < 0; nonpos_upto ?a s\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y < x \\<and>\n        zcount vc y < 0 \\<and> nonpos_upto vc y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "with x"], ["proof (chain)\npicking this:\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n  y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y", "have \"y < t\""], ["proof (prove)\nusing this:\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n  y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y\n\ngoal (1 subgoal):\n 1. y < t", "using order.strict_trans"], ["proof (prove)\nusing this:\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n  y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y\n  \\<lbrakk>?a < ?b; ?b < ?c\\<rbrakk> \\<Longrightarrow> ?a < ?c\n\ngoal (1 subgoal):\n 1. y < t", "by blast"], ["proof (state)\nthis:\n  y < t\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "from assm x y"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>s<t.\n             (zcount va s < 0 \\<or> zcount vb s + zcount vc s < 0) \\<and>\n             \\<not> (\\<exists>u\\<le>s. 0 < zcount va u))\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n  y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y", "have \"\\<not> zcount vb y + zcount vc y < 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>s<t.\n             (zcount va s < 0 \\<or> zcount vb s + zcount vc s < 0) \\<and>\n             \\<not> (\\<exists>u\\<le>s. 0 < zcount va u))\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n  y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y\n\ngoal (1 subgoal):\n 1. \\<not> zcount vb y + zcount vc y < 0", "by (metis order.strict_implies_order order.strict_trans1 not_less)"], ["proof (state)\nthis:\n  \\<not> zcount vb y + zcount vc y < 0\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "with y"], ["proof (chain)\npicking this:\n  y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y\n  \\<not> zcount vb y + zcount vc y < 0", "have \"zcount vb y > 0\""], ["proof (prove)\nusing this:\n  y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y\n  \\<not> zcount vb y + zcount vc y < 0\n\ngoal (1 subgoal):\n 1. 0 < zcount vb y", "by linarith"], ["proof (state)\nthis:\n  0 < zcount vb y\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "with assms(1)"], ["proof (chain)\npicking this:\n  upright vb\n  0 < zcount vb y", "obtain z where z: \"z < y \\<and> zcount vb z < 0\""], ["proof (prove)\nusing this:\n  upright vb\n  0 < zcount vb y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        z < y \\<and> zcount vb z < 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: upright_def supported_def)"], ["proof (state)\nthis:\n  z < y \\<and> zcount vb z < 0\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "with \\<open>y < t\\<close>"], ["proof (chain)\npicking this:\n  y < t\n  z < y \\<and> zcount vb z < 0", "have \"z < t\""], ["proof (prove)\nusing this:\n  y < t\n  z < y \\<and> zcount vb z < 0\n\ngoal (1 subgoal):\n 1. z < t", "using order.strict_trans"], ["proof (prove)\nusing this:\n  y < t\n  z < y \\<and> zcount vb z < 0\n  \\<lbrakk>?a < ?b; ?b < ?c\\<rbrakk> \\<Longrightarrow> ?a < ?c\n\ngoal (1 subgoal):\n 1. z < t", "by blast"], ["proof (state)\nthis:\n  z < t\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "with x y z"], ["proof (chain)\npicking this:\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n  y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y\n  z < y \\<and> zcount vb z < 0\n  z < t", "have \"\\<not> zcount vb z + zcount vc z < 0\""], ["proof (prove)\nusing this:\n  x < t \\<and>\n  (zcount va x < 0 \\<or> zcount vb x < 0) \\<and> nonpos_upto va x\n  y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y\n  z < y \\<and> zcount vb z < 0\n  z < t\n\ngoal (1 subgoal):\n 1. \\<not> zcount vb z + zcount vc z < 0", "by (metis assm less_imp_le not_less order.strict_trans order.strict_trans1)"], ["proof (state)\nthis:\n  \\<not> zcount vb z + zcount vc z < 0\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "with z"], ["proof (chain)\npicking this:\n  z < y \\<and> zcount vb z < 0\n  \\<not> zcount vb z + zcount vc z < 0", "have \"zcount vc z > 0\""], ["proof (prove)\nusing this:\n  z < y \\<and> zcount vb z < 0\n  \\<not> zcount vb z + zcount vc z < 0\n\ngoal (1 subgoal):\n 1. 0 < zcount vc z", "by linarith"], ["proof (state)\nthis:\n  0 < zcount vc z\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "with y z"], ["proof (chain)\npicking this:\n  y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y\n  z < y \\<and> zcount vb z < 0\n  0 < zcount vc z", "have \"False\""], ["proof (prove)\nusing this:\n  y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y\n  z < y \\<and> zcount vb z < 0\n  0 < zcount vc z\n\ngoal (1 subgoal):\n 1. False", "using order.strict_implies_order not_less"], ["proof (prove)\nusing this:\n  y < x \\<and> zcount vc y < 0 \\<and> nonpos_upto vc y\n  z < y \\<and> zcount vb z < 0\n  0 < zcount vc z\n  ?a < ?b \\<Longrightarrow> ?a \\<le> ?b\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < zcount va ?t2;\n   \\<not> (\\<exists>s<?t2.\n              (zcount va s < 0 \\<or> zcount vb s + zcount vc s < 0) \\<and>\n              \\<not> (\\<exists>u\\<le>s. 0 < zcount va u))\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < zcount va ?t2;\n   \\<not> (\\<exists>s<?t2.\n              (zcount va s < 0 \\<or> zcount vb s + zcount vc s < 0) \\<and>\n              \\<not> (\\<exists>u\\<le>s. 0 < zcount va u))\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < zcount va ?t2;\n   \\<not> (\\<exists>s<?t2.\n              (zcount va s < 0 \\<or> zcount vb s + zcount vc s < 0) \\<and>\n              \\<not> (\\<exists>u\\<le>s. 0 < zcount va u))\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "using beta_upright_def zcount_union"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < zcount va ?t2;\n   \\<not> (\\<exists>s<?t2.\n              (zcount va s < 0 \\<or> zcount vb s + zcount vc s < 0) \\<and>\n              \\<not> (\\<exists>u\\<le>s. 0 < zcount va u))\\<rbrakk>\n  \\<Longrightarrow> False\n  beta_upright ?va ?vb =\n  (\\<forall>t.\n      0 < zcount ?va t \\<longrightarrow>\n      (\\<exists>s<t. zcount ?va s < 0 \\<or> zcount ?vb s < 0))\n  zcount (?M + ?N) ?a = zcount ?M ?a + zcount ?N ?a\n\ngoal (1 subgoal):\n 1. beta_upright va (vb + vc)", "by fastforce"], ["proof (state)\nthis:\n  beta_upright va (vb + vc)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition InfoAt where\n  \"InfoAt c k p q = (if 0 \\<le> k \\<and> k < length (c_msg c p q) then (c_msg c p q) ! k else 0)\""], ["", "definition InvInfoAtBetaUpright where\n  \"InvInfoAtBetaUpright c = (\\<forall>k p q. beta_upright (InfoAt c k p q) (IncomingInfo c (k+1) p q))\""], ["", "lemma init_InvInfoAtBetaUpright: \"init_config c \\<Longrightarrow> InvInfoAtBetaUpright c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_config c \\<Longrightarrow> InvInfoAtBetaUpright c", "unfolding init_config_def InvInfoAtBetaUpright_def beta_upright_def IncomingInfo_def InfoAt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p. c_temp c p = {#}\\<^sub>z) \\<and>\n    (\\<forall>p1 p2. c_msg c p1 p2 = []) \\<and>\n    (\\<forall>p. c_glob c p = c_records c) \\<and>\n    (\\<forall>t. 0 \\<le> zcount (c_records c) t) \\<Longrightarrow>\n    \\<forall>k p q t.\n       0 < zcount\n            (if 0 \\<le> k \\<and> k < length (c_msg c p q)\n             then c_msg c p q ! k else {#}\\<^sub>z)\n            t \\<longrightarrow>\n       (\\<exists>s<t.\n           zcount\n            (if 0 \\<le> k \\<and> k < length (c_msg c p q)\n             then c_msg c p q ! k else {#}\\<^sub>z)\n            s\n           < 0 \\<or>\n           zcount (sum_list (drop (k + 1) (c_msg c p q)) + c_temp c p) s\n           < 0)", "by simp"], ["", "lemma next_inv[consumes 1, case_names next_performop next_sendupd next_recvupd stutter]:\n  assumes \"next s\"\n    and     \"next_performop s \\<Longrightarrow> P\"\n    and     \"next_sendupd s \\<Longrightarrow> P\"\n    and     \"next_recvupd s \\<Longrightarrow> P\"\n    and     \"shd (stl s) = shd s \\<Longrightarrow> P\"\n  shows   \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  next s\n  next_performop s \\<Longrightarrow> P\n  next_sendupd s \\<Longrightarrow> P\n  next_recvupd s \\<Longrightarrow> P\n  shd (stl s) = shd s \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "unfolding next_def"], ["proof (prove)\nusing this:\n  next_performop s \\<or>\n  next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s\n  next_performop s \\<Longrightarrow> P\n  next_sendupd s \\<Longrightarrow> P\n  next_recvupd s \\<Longrightarrow> P\n  shd (stl s) = shd s \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["", "lemma next_InvInfoAtBetaUpright:\n  assumes a1: \"next s\"\n    and     a2: \"InvInfoAtBetaUpright (shd s)\"\n    and     a3: \"InvIncomingInfoUpright (shd s)\"\n    and     a4: \"InvTempUpright (shd s)\"\n  shows   \"InvInfoAtBetaUpright (shd (stl s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvInfoAtBetaUpright (shd (stl s))", "using assms"], ["proof (prove)\nusing this:\n  next s\n  InvInfoAtBetaUpright (shd s)\n  InvIncomingInfoUpright (shd s)\n  InvTempUpright (shd s)\n\ngoal (1 subgoal):\n 1. InvInfoAtBetaUpright (shd (stl s))", "proof (cases rule: next_inv)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_performop s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 2. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 3. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 4. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))", "case next_performop"], ["proof (state)\nthis:\n  next_performop s\n\ngoal (4 subgoals):\n 1. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_performop s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 2. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 3. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 4. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))", "then"], ["proof (chain)\npicking this:\n  next_performop s", "show ?thesis"], ["proof (prove)\nusing this:\n  next_performop s\n\ngoal (1 subgoal):\n 1. InvInfoAtBetaUpright (shd (stl s))", "unfolding next_performop'_def Let_def InvInfoAtBetaUpright_def"], ["proof (prove)\nusing this:\n  \\<exists>p c r.\n     (\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t) \\<and>\n     upright (zmset_of r - zmset_of c) \\<and>\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>k p q.\n       beta_upright (InfoAt (shd (stl s)) k p q)\n        (IncomingInfo (shd (stl s)) (k + 1) p q)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p c r k pa q.\n       \\<lbrakk>\\<forall>t.\n                   int (count c t) \\<le> zcount (c_records (shd s)) t;\n        upright (zmset_of r - zmset_of c);\n        shd (stl s) = shd s\n        \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n           c_temp := (c_temp (shd s))\n             (p := c_temp (shd s) p +\n                   (zmset_of r - zmset_of c))\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k pa q)\n                          (IncomingInfo (shd (stl s)) (k + 1) pa q)", "subgoal for p c r k' p' q'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p +\n                (zmset_of r - zmset_of c))\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "proof (cases \"p=p'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p = p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "let ?\\<Delta> = \"zmset_of r - zmset_of c\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p = p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "assume upright_\\<Delta>: \"upright ?\\<Delta>\""], ["proof (state)\nthis:\n  upright (zmset_of r - zmset_of c)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p = p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "assume conf: \"shd (stl s) = shd s\\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))(p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>\""], ["proof (state)\nthis:\n  shd (stl s) = shd s\n  \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p = p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "case True"], ["proof (state)\nthis:\n  p = p'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p = p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "then"], ["proof (chain)\npicking this:\n  p = p'", "have iid: \"IncomingInfo (shd (stl s)) (k'+1) p' q' = IncomingInfo (shd s) (k'+1) p' q' + ?\\<Delta>\""], ["proof (prove)\nusing this:\n  p = p'\n\ngoal (1 subgoal):\n 1. IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n    IncomingInfo (shd s) (k' + 1) p' q' + (zmset_of r - zmset_of c)", "by (simp add: IncomingInfo_def conf)"], ["proof (state)\nthis:\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q' + (zmset_of r - zmset_of c)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p = p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "from a2"], ["proof (chain)\npicking this:\n  InvInfoAtBetaUpright (shd s)", "have bu: \"beta_upright (InfoAt (shd s) k' p' q') (IncomingInfo (shd s) (k'+1) p' q')\""], ["proof (prove)\nusing this:\n  InvInfoAtBetaUpright (shd s)\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd s) k' p' q')\n     (IncomingInfo (shd s) (k' + 1) p' q')", "using InvInfoAtBetaUpright_def"], ["proof (prove)\nusing this:\n  InvInfoAtBetaUpright (shd s)\n  InvInfoAtBetaUpright ?c =\n  (\\<forall>k p q.\n      beta_upright (InfoAt ?c k p q) (IncomingInfo ?c (k + 1) p q))\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd s) k' p' q')\n     (IncomingInfo (shd s) (k' + 1) p' q')", "by fastforce"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd s) k' p' q')\n   (IncomingInfo (shd s) (k' + 1) p' q')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p = p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "unfolding iid"], ["proof (prove)\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd s) (k' + 1) p' q' + (zmset_of r - zmset_of c))", "apply (rule beta_upright_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. upright (IncomingInfo (shd s) (k' + 1) p' q')\n 2. upright (zmset_of r - zmset_of c)\n 3. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd s) (k' + 1) p' q')", "apply (meson InvIncomingInfoUpright_def a3)"], ["proof (prove)\ngoal (2 subgoals):\n 1. upright (zmset_of r - zmset_of c)\n 2. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd s) (k' + 1) p' q')", "apply (rule upright_\\<Delta>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd s) (k' + 1) p' q')", "using bu"], ["proof (prove)\nusing this:\n  beta_upright (InfoAt (shd s) k' p' q')\n   (IncomingInfo (shd s) (k' + 1) p' q')\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd s) (k' + 1) p' q')", "unfolding conf InfoAt_def"], ["proof (prove)\nusing this:\n  beta_upright\n   (if 0 \\<le> k' \\<and> k' < length (c_msg (shd s) p' q')\n    then c_msg (shd s) p' q' ! k' else {#}\\<^sub>z)\n   (IncomingInfo (shd s) (k' + 1) p' q')\n\ngoal (1 subgoal):\n 1. beta_upright\n     (if 0 \\<le> k' \\<and>\n         k' < length\n               (c_msg\n                 (shd s\n                  \\<lparr>c_records :=\n                            c_records (shd s) + (zmset_of r - zmset_of c),\n                     c_temp := (c_temp (shd s))\n                       (p := c_temp (shd s) p +\n                             (zmset_of r - zmset_of c))\\<rparr>)\n                 p' q')\n      then c_msg\n            (shd s\n             \\<lparr>c_records :=\n                       c_records (shd s) + (zmset_of r - zmset_of c),\n                c_temp := (c_temp (shd s))\n                  (p := c_temp (shd s) p +\n                        (zmset_of r - zmset_of c))\\<rparr>)\n            p' q' !\n           k'\n      else {#}\\<^sub>z)\n     (IncomingInfo (shd s) (k' + 1) p' q')", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd (stl s)) k' p' q')\n   (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "let ?\\<Delta> = \"zmset_of r - zmset_of c\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "assume conf: \"shd (stl s) = shd s\\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))(p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>\""], ["proof (state)\nthis:\n  shd (stl s) = shd s\n  \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "from a2"], ["proof (chain)\npicking this:\n  InvInfoAtBetaUpright (shd s)", "have bu: \"beta_upright (InfoAt (shd s) k p q) (IncomingInfo (shd s) (k + 1) p q)\" for k p q"], ["proof (prove)\nusing this:\n  InvInfoAtBetaUpright (shd s)\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd s) k p q) (IncomingInfo (shd s) (k + 1) p q)", "using InvInfoAtBetaUpright_def"], ["proof (prove)\nusing this:\n  InvInfoAtBetaUpright (shd s)\n  InvInfoAtBetaUpright ?c =\n  (\\<forall>k p q.\n      beta_upright (InfoAt ?c k p q) (IncomingInfo ?c (k + 1) p q))\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd s) k p q) (IncomingInfo (shd s) (k + 1) p q)", "by fastforce"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd s) ?k ?p ?q)\n   (IncomingInfo (shd s) (?k + 1) ?p ?q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "case False"], ["proof (state)\nthis:\n  p \\<noteq> p'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> p'", "have ii: \"IncomingInfo (shd (stl s)) (k'+1) p' q' = IncomingInfo (shd s) (k'+1) p' q'\""], ["proof (prove)\nusing this:\n  p \\<noteq> p'\n\ngoal (1 subgoal):\n 1. IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n    IncomingInfo (shd s) (k' + 1) p' q'", "unfolding IncomingInfo_def"], ["proof (prove)\nusing this:\n  p \\<noteq> p'\n\ngoal (1 subgoal):\n 1. sum_list (drop (k' + 1) (c_msg (shd (stl s)) p' q')) +\n    c_temp (shd (stl s)) p' =\n    sum_list (drop (k' + 1) (c_msg (shd s) p' q')) + c_temp (shd s) p'", "by (simp add: conf)"], ["proof (state)\nthis:\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. int (count c t) \\<le> zcount (c_records (shd s)) t;\n     upright (zmset_of r - zmset_of c);\n     shd (stl s) = shd s\n     \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "with bu[of k' p' q']"], ["proof (chain)\npicking this:\n  beta_upright (InfoAt (shd s) k' p' q')\n   (IncomingInfo (shd s) (k' + 1) p' q')\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q'", "show ?thesis"], ["proof (prove)\nusing this:\n  beta_upright (InfoAt (shd s) k' p' q')\n   (IncomingInfo (shd s) (k' + 1) p' q')\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q'\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "unfolding conf InfoAt_def"], ["proof (prove)\nusing this:\n  beta_upright\n   (if 0 \\<le> k' \\<and> k' < length (c_msg (shd s) p' q')\n    then c_msg (shd s) p' q' ! k' else {#}\\<^sub>z)\n   (IncomingInfo (shd s) (k' + 1) p' q')\n  IncomingInfo\n   (shd s\n    \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n       c_temp := (c_temp (shd s))\n         (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>)\n   (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q'\n\ngoal (1 subgoal):\n 1. beta_upright\n     (if 0 \\<le> k' \\<and>\n         k' < length\n               (c_msg\n                 (shd s\n                  \\<lparr>c_records :=\n                            c_records (shd s) + (zmset_of r - zmset_of c),\n                     c_temp := (c_temp (shd s))\n                       (p := c_temp (shd s) p +\n                             (zmset_of r - zmset_of c))\\<rparr>)\n                 p' q')\n      then c_msg\n            (shd s\n             \\<lparr>c_records :=\n                       c_records (shd s) + (zmset_of r - zmset_of c),\n                c_temp := (c_temp (shd s))\n                  (p := c_temp (shd s) p +\n                        (zmset_of r - zmset_of c))\\<rparr>)\n            p' q' !\n           k'\n      else {#}\\<^sub>z)\n     (IncomingInfo\n       (shd s\n        \\<lparr>c_records := c_records (shd s) + (zmset_of r - zmset_of c),\n           c_temp := (c_temp (shd s))\n             (p := c_temp (shd s) p + (zmset_of r - zmset_of c))\\<rparr>)\n       (k' + 1) p' q')", "by auto"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd (stl s)) k' p' q')\n   (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  InvInfoAtBetaUpright (shd (stl s))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 2. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 3. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 2. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 3. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))", "case next_sendupd"], ["proof (state)\nthis:\n  next_sendupd s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 2. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 3. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))", "then"], ["proof (chain)\npicking this:\n  next_sendupd s", "show ?thesis"], ["proof (prove)\nusing this:\n  next_sendupd s\n\ngoal (1 subgoal):\n 1. InvInfoAtBetaUpright (shd (stl s))", "unfolding next_sendupd'_def Let_def InvInfoAtBetaUpright_def"], ["proof (prove)\nusing this:\n  \\<exists>p tt.\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n     {#}\\<^sub>z \\<and>\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}) \\<and>\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>k p q.\n       beta_upright (InfoAt (shd (stl s)) k p q)\n        (IncomingInfo (shd (stl s)) (k + 1) p q)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p tt k pa q.\n       \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n                {#}\\<^sub>z;\n        upright\n         (c_temp (shd s) p -\n          {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n        shd (stl s) = shd s\n        \\<lparr>c_msg := (c_msg (shd s))\n                  (p := \\<lambda>q.\n                           c_msg (shd s) p q @\n                           [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                             t \\<in> tt#}]),\n           c_temp := (c_temp (shd s))\n             (p := c_temp (shd s) p -\n                   {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                    t \\<in> tt#})\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k pa q)\n                          (IncomingInfo (shd (stl s)) (k + 1) pa q)", "subgoal for p tt k' p' q'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                 t \\<in> tt#})\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "proof (cases \"p=p'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p = p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "let ?\\<gamma> = \"{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p = p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "assume conf: \"shd (stl s) = (shd s)\\<lparr>c_msg := (c_msg (shd s))(p := \\<lambda>q. c_msg (shd s) p q @ [?\\<gamma>]),\n              c_temp := (c_temp (shd s))(p := c_temp (shd s) p - ?\\<gamma>)\\<rparr>\""], ["proof (state)\nthis:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p = p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "from a2"], ["proof (chain)\npicking this:\n  InvInfoAtBetaUpright (shd s)", "have buia: \"beta_upright (InfoAt (shd s) k' p' q') (IncomingInfo (shd s) (k'+1) p' q')\""], ["proof (prove)\nusing this:\n  InvInfoAtBetaUpright (shd s)\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd s) k' p' q')\n     (IncomingInfo (shd s) (k' + 1) p' q')", "using InvInfoAtBetaUpright_def"], ["proof (prove)\nusing this:\n  InvInfoAtBetaUpright (shd s)\n  InvInfoAtBetaUpright ?c =\n  (\\<forall>k p q.\n      beta_upright (InfoAt ?c k p q) (IncomingInfo ?c (k + 1) p q))\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd s) k' p' q')\n     (IncomingInfo (shd s) (k' + 1) p' q')", "by force"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd s) k' p' q')\n   (IncomingInfo (shd s) (k' + 1) p' q')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p = p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "from a4"], ["proof (chain)\npicking this:\n  InvTempUpright (shd s)", "have tu: \"upright (c_temp (shd s) p)\""], ["proof (prove)\nusing this:\n  InvTempUpright (shd s)\n\ngoal (1 subgoal):\n 1. upright (c_temp (shd s) p)", "by (simp add: InvTempUpright_def)"], ["proof (state)\nthis:\n  upright (c_temp (shd s) p)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p = p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "case True"], ["proof (state)\nthis:\n  p = p'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p = p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "then"], ["proof (chain)\npicking this:\n  p = p'", "show ?thesis"], ["proof (prove)\nusing this:\n  p = p'\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "proof (cases k' rule: linorder_cases[where y = \"length (c_msg (shd s) p' q')\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>p = p'; k' = length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 3. \\<lbrakk>p = p'; length (c_msg (shd s) p' q') < k'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "case greater"], ["proof (state)\nthis:\n  length (c_msg (shd s) p' q') < k'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>p = p'; k' = length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 3. \\<lbrakk>p = p'; length (c_msg (shd s) p' q') < k'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "then"], ["proof (chain)\npicking this:\n  length (c_msg (shd s) p' q') < k'", "have \"InfoAt (shd (stl s)) k' p' q' = 0\""], ["proof (prove)\nusing this:\n  length (c_msg (shd s) p' q') < k'\n\ngoal (1 subgoal):\n 1. InfoAt (shd (stl s)) k' p' q' = {#}\\<^sub>z", "by (auto simp: conf InfoAt_def)"], ["proof (state)\nthis:\n  InfoAt (shd (stl s)) k' p' q' = {#}\\<^sub>z\n\ngoal (3 subgoals):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>p = p'; k' = length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 3. \\<lbrakk>p = p'; length (c_msg (shd s) p' q') < k'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "then"], ["proof (chain)\npicking this:\n  InfoAt (shd (stl s)) k' p' q' = {#}\\<^sub>z", "show ?thesis"], ["proof (prove)\nusing this:\n  InfoAt (shd (stl s)) k' p' q' = {#}\\<^sub>z\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "by (simp add: beta_upright_0)"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd (stl s)) k' p' q')\n   (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>p = p'; k' = length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>p = p'; k' = length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "case equal"], ["proof (state)\nthis:\n  k' = length (c_msg (shd s) p' q')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>p = p'; k' = length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "with True conf"], ["proof (chain)\npicking this:\n  p = p'\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n  k' = length (c_msg (shd s) p' q')", "have \"InfoAt (shd (stl s)) k' p' q' = ?\\<gamma>\""], ["proof (prove)\nusing this:\n  p = p'\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n  k' = length (c_msg (shd s) p' q')\n\ngoal (1 subgoal):\n 1. InfoAt (shd (stl s)) k' p' q' =\n    {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}", "by (simp add: InfoAt_def)"], ["proof (state)\nthis:\n  InfoAt (shd (stl s)) k' p' q' =\n  {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>p = p'; k' = length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "then"], ["proof (chain)\npicking this:\n  InfoAt (shd (stl s)) k' p' q' =\n  {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}", "have pi: \"PositiveImplies (InfoAt (shd (stl s)) k' p' q') (c_temp (shd s) p)\""], ["proof (prove)\nusing this:\n  InfoAt (shd (stl s)) k' p' q' =\n  {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}\n\ngoal (1 subgoal):\n 1. PositiveImplies (InfoAt (shd (stl s)) k' p' q') (c_temp (shd s) p)", "by (simp add: PositiveImplies_def)"], ["proof (state)\nthis:\n  PositiveImplies (InfoAt (shd (stl s)) k' p' q') (c_temp (shd s) p)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>p = p'; k' = length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "from conf"], ["proof (chain)\npicking this:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>", "have \"c_temp (shd s) p = c_temp (shd (stl s)) p + ?\\<gamma>\""], ["proof (prove)\nusing this:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n\ngoal (1 subgoal):\n 1. c_temp (shd s) p =\n    c_temp (shd (stl s)) p +\n    {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}", "by simp"], ["proof (state)\nthis:\n  c_temp (shd s) p =\n  c_temp (shd (stl s)) p + {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>p = p'; k' = length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "with equal True conf tu pi"], ["proof (chain)\npicking this:\n  k' = length (c_msg (shd s) p' q')\n  p = p'\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n  upright (c_temp (shd s) p)\n  PositiveImplies (InfoAt (shd (stl s)) k' p' q') (c_temp (shd s) p)\n  c_temp (shd s) p =\n  c_temp (shd (stl s)) p + {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}", "have butemp: \"beta_upright (InfoAt (shd (stl s)) k' p' q') (c_temp (shd (stl s)) p)\""], ["proof (prove)\nusing this:\n  k' = length (c_msg (shd s) p' q')\n  p = p'\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n  upright (c_temp (shd s) p)\n  PositiveImplies (InfoAt (shd (stl s)) k' p' q') (c_temp (shd s) p)\n  c_temp (shd s) p =\n  c_temp (shd (stl s)) p + {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd (stl s)) k' p' q') (c_temp (shd (stl s)) p)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k' = length (c_msg (shd s) p' q'); p = p';\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     upright (c_temp (shd s) p);\n     PositiveImplies (InfoAt (shd (stl s)) k' p' q') (c_temp (shd s) p);\n     c_temp (shd s) p =\n     c_temp (shd (stl s)) p +\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (c_temp (shd (stl s)) p)", "apply (rule betaupright_PositiveImplies)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k' = length (c_msg (shd s) p' q'); p = p';\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     upright (c_temp (shd s) p);\n     PositiveImplies (InfoAt (shd (stl s)) k' p' q') (c_temp (shd s) p);\n     c_temp (shd s) p =\n     c_temp (shd (stl s)) p +\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}\\<rbrakk>\n    \\<Longrightarrow> upright\n                       (InfoAt (shd (stl s)) k' p' q' +\n                        c_temp (shd (stl s)) p)\n 2. \\<lbrakk>k' = length (c_msg (shd s) p' q'); p = p';\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     upright (c_temp (shd s) p);\n     PositiveImplies (InfoAt (shd (stl s)) k' p' q') (c_temp (shd s) p);\n     c_temp (shd s) p =\n     c_temp (shd (stl s)) p +\n     {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}\\<rbrakk>\n    \\<Longrightarrow> PositiveImplies (InfoAt (shd (stl s)) k' p' q')\n                       (InfoAt (shd (stl s)) k' p' q' +\n                        c_temp (shd (stl s)) p)", "apply (auto simp add: InfoAt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd (stl s)) k' p' q') (c_temp (shd (stl s)) p)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>p = p'; k' = length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "with True equal conf"], ["proof (chain)\npicking this:\n  p = p'\n  k' = length (c_msg (shd s) p' q')\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n  beta_upright (InfoAt (shd (stl s)) k' p' q') (c_temp (shd (stl s)) p)", "have \"IncomingInfo (shd (stl s)) (k'+1) p' q' = c_temp (shd (stl s)) p\""], ["proof (prove)\nusing this:\n  p = p'\n  k' = length (c_msg (shd s) p' q')\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n  beta_upright (InfoAt (shd (stl s)) k' p' q') (c_temp (shd (stl s)) p)\n\ngoal (1 subgoal):\n 1. IncomingInfo (shd (stl s)) (k' + 1) p' q' = c_temp (shd (stl s)) p", "by (simp add: IncomingInfo_def)"], ["proof (state)\nthis:\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' = c_temp (shd (stl s)) p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>p = p'; k' = length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "with butemp"], ["proof (chain)\npicking this:\n  beta_upright (InfoAt (shd (stl s)) k' p' q') (c_temp (shd (stl s)) p)\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' = c_temp (shd (stl s)) p", "show ?thesis"], ["proof (prove)\nusing this:\n  beta_upright (InfoAt (shd (stl s)) k' p' q') (c_temp (shd (stl s)) p)\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' = c_temp (shd (stl s)) p\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "by simp"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd (stl s)) k' p' q')\n   (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "case less"], ["proof (state)\nthis:\n  k' < length (c_msg (shd s) p' q')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "with conf"], ["proof (chain)\npicking this:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n  k' < length (c_msg (shd s) p' q')", "have unch_ia: \"InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'\""], ["proof (prove)\nusing this:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n  k' < length (c_msg (shd s) p' q')\n\ngoal (1 subgoal):\n 1. InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'", "by (auto simp: nth_append InfoAt_def)"], ["proof (state)\nthis:\n  InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "from conf less"], ["proof (chain)\npicking this:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n  k' < length (c_msg (shd s) p' q')", "have \"IncomingInfo (shd (stl s)) (k'+1) p' q' = IncomingInfo (shd s) (k'+1) p' q'\""], ["proof (prove)\nusing this:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n  k' < length (c_msg (shd s) p' q')\n\ngoal (1 subgoal):\n 1. IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n    IncomingInfo (shd s) (k' + 1) p' q'", "by (auto simp: IncomingInfo_def)"], ["proof (state)\nthis:\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = p'; k' < length (c_msg (shd s) p' q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "with buia unch_ia"], ["proof (chain)\npicking this:\n  beta_upright (InfoAt (shd s) k' p' q')\n   (IncomingInfo (shd s) (k' + 1) p' q')\n  InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q'", "show ?thesis"], ["proof (prove)\nusing this:\n  beta_upright (InfoAt (shd s) k' p' q')\n   (IncomingInfo (shd s) (k' + 1) p' q')\n  InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q'\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "by simp"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd (stl s)) k' p' q')\n   (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd (stl s)) k' p' q')\n   (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "let ?\\<gamma> = \"{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "assume conf: \"shd (stl s) = (shd s)\\<lparr>c_msg := (c_msg (shd s))(p := \\<lambda>q. c_msg (shd s) p q @ [?\\<gamma>]),\n              c_temp := (c_temp (shd s))(p := c_temp (shd s) p - ?\\<gamma>)\\<rparr>\""], ["proof (state)\nthis:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "from a2"], ["proof (chain)\npicking this:\n  InvInfoAtBetaUpright (shd s)", "have buia: \"beta_upright (InfoAt (shd s) k' p' q') (IncomingInfo (shd s) (k'+1) p' q')\""], ["proof (prove)\nusing this:\n  InvInfoAtBetaUpright (shd s)\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd s) k' p' q')\n     (IncomingInfo (shd s) (k' + 1) p' q')", "using InvInfoAtBetaUpright_def"], ["proof (prove)\nusing this:\n  InvInfoAtBetaUpright (shd s)\n  InvInfoAtBetaUpright ?c =\n  (\\<forall>k p q.\n      beta_upright (InfoAt ?c k p q) (IncomingInfo ?c (k + 1) p q))\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd s) k' p' q')\n     (IncomingInfo (shd s) (k' + 1) p' q')", "by force"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd s) k' p' q')\n   (IncomingInfo (shd s) (k' + 1) p' q')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "case False"], ["proof (state)\nthis:\n  p \\<noteq> p'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "with conf"], ["proof (chain)\npicking this:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n  p \\<noteq> p'", "have unchia: \"InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'\""], ["proof (prove)\nusing this:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n  p \\<noteq> p'\n\ngoal (1 subgoal):\n 1. InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'", "by (simp add: InfoAt_def)"], ["proof (state)\nthis:\n  InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "from False conf"], ["proof (chain)\npicking this:\n  p \\<noteq> p'\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>", "have unchii: \"IncomingInfo (shd (stl s)) (k'+1) p' q' = IncomingInfo (shd s) (k'+1) p' q'\""], ["proof (prove)\nusing this:\n  p \\<noteq> p'\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := \\<lambda>q.\n                     c_msg (shd s) p q @\n                     [{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#}]),\n     c_temp := (c_temp (shd s))\n       (p := c_temp (shd s) p -\n             {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>\n\ngoal (1 subgoal):\n 1. IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n    IncomingInfo (shd s) (k' + 1) p' q'", "by (simp add: IncomingInfo_def)"], ["proof (state)\nthis:\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#} \\<noteq>\n             {#}\\<^sub>z;\n     upright\n      (c_temp (shd s) p -\n       {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#});\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := \\<lambda>q.\n                        c_msg (shd s) p q @\n                        [{#t \\<in>#\\<^sub>z c_temp (shd s) p.\n                          t \\<in> tt#}]),\n        c_temp := (c_temp (shd s))\n          (p := c_temp (shd s) p -\n                {#t \\<in>#\\<^sub>z c_temp (shd s) p. t \\<in> tt#})\\<rparr>;\n     p \\<noteq> p'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "from unchia unchii buia"], ["proof (chain)\npicking this:\n  InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q'\n  beta_upright (InfoAt (shd s) k' p' q')\n   (IncomingInfo (shd s) (k' + 1) p' q')", "show ?thesis"], ["proof (prove)\nusing this:\n  InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q'\n  beta_upright (InfoAt (shd s) k' p' q')\n   (IncomingInfo (shd s) (k' + 1) p' q')\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "by simp"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd (stl s)) k' p' q')\n   (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  InvInfoAtBetaUpright (shd (stl s))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 2. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 2. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))", "case next_recvupd"], ["proof (state)\nthis:\n  next_recvupd s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); next_recvupd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))\n 2. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))", "then"], ["proof (chain)\npicking this:\n  next_recvupd s", "show ?thesis"], ["proof (prove)\nusing this:\n  next_recvupd s\n\ngoal (1 subgoal):\n 1. InvInfoAtBetaUpright (shd (stl s))", "unfolding next_recvupd'_def Let_def InvInfoAtBetaUpright_def"], ["proof (prove)\nusing this:\n  \\<exists>p q.\n     c_msg (shd s) p q \\<noteq> [] \\<and>\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>k p q.\n       beta_upright (InfoAt (shd (stl s)) k p q)\n        (IncomingInfo (shd (stl s)) (k + 1) p q)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q k pa qa.\n       \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n        shd (stl s) = shd s\n        \\<lparr>c_msg := (c_msg (shd s))\n                  (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n           c_glob := (c_glob (shd s))\n             (q := c_glob (shd s) q +\n                   hd (c_msg (shd s) p q))\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k pa qa)\n                          (IncomingInfo (shd (stl s)) (k + 1) pa qa)", "subgoal for p q k' p' q'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "proof (cases \"p = p' \\<and> q = q'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     p = p' \\<and> q = q'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     \\<not> (p = p' \\<and> q = q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "assume conf: \"shd (stl s) = (shd s)\\<lparr>c_msg := (c_msg (shd s))(p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n              c_glob := (c_glob (shd s))(q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\""], ["proof (state)\nthis:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n     c_glob := (c_glob (shd s))\n       (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     p = p' \\<and> q = q'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     \\<not> (p = p' \\<and> q = q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "case True"], ["proof (state)\nthis:\n  p = p' \\<and> q = q'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     p = p' \\<and> q = q'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     \\<not> (p = p' \\<and> q = q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "with conf"], ["proof (chain)\npicking this:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n     c_glob := (c_glob (shd s))\n       (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\n  p = p' \\<and> q = q'", "have iisuc: \"IncomingInfo (shd (stl s)) (k'+1) p' q' = IncomingInfo (shd s) (k'+2) p' q'\""], ["proof (prove)\nusing this:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n     c_glob := (c_glob (shd s))\n       (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\n  p = p' \\<and> q = q'\n\ngoal (1 subgoal):\n 1. IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n    IncomingInfo (shd s) (k' + 2) p' q'", "by (simp add: drop_Suc IncomingInfo_def)"], ["proof (state)\nthis:\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 2) p' q'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     p = p' \\<and> q = q'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     \\<not> (p = p' \\<and> q = q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "with True conf"], ["proof (chain)\npicking this:\n  p = p' \\<and> q = q'\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n     c_glob := (c_glob (shd s))\n       (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 2) p' q'", "have iasuc: \"InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) (k'+1) p' q'\""], ["proof (prove)\nusing this:\n  p = p' \\<and> q = q'\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n     c_glob := (c_glob (shd s))\n       (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 2) p' q'\n\ngoal (1 subgoal):\n 1. InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) (k' + 1) p' q'", "by (simp add: less_diff_conv nth_tl InfoAt_def)"], ["proof (state)\nthis:\n  InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) (k' + 1) p' q'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     p = p' \\<and> q = q'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     \\<not> (p = p' \\<and> q = q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "from a2"], ["proof (chain)\npicking this:\n  InvInfoAtBetaUpright (shd s)", "have \"beta_upright (InfoAt (shd s) (k'+1) p' q') (IncomingInfo (shd s) (k'+2) p' q')\""], ["proof (prove)\nusing this:\n  InvInfoAtBetaUpright (shd s)\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd s) (k' + 1) p' q')\n     (IncomingInfo (shd s) (k' + 2) p' q')", "using InvInfoAtBetaUpright_def"], ["proof (prove)\nusing this:\n  InvInfoAtBetaUpright (shd s)\n  InvInfoAtBetaUpright ?c =\n  (\\<forall>k p q.\n      beta_upright (InfoAt ?c k p q) (IncomingInfo ?c (k + 1) p q))\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd s) (k' + 1) p' q')\n     (IncomingInfo (shd s) (k' + 2) p' q')", "by fastforce"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd s) (k' + 1) p' q')\n   (IncomingInfo (shd s) (k' + 2) p' q')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     p = p' \\<and> q = q'\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n 2. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     \\<not> (p = p' \\<and> q = q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "with iisuc iasuc"], ["proof (chain)\npicking this:\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 2) p' q'\n  InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) (k' + 1) p' q'\n  beta_upright (InfoAt (shd s) (k' + 1) p' q')\n   (IncomingInfo (shd s) (k' + 2) p' q')", "show ?thesis"], ["proof (prove)\nusing this:\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 2) p' q'\n  InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) (k' + 1) p' q'\n  beta_upright (InfoAt (shd s) (k' + 1) p' q')\n   (IncomingInfo (shd s) (k' + 2) p' q')\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "by simp"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd (stl s)) k' p' q')\n   (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     \\<not> (p = p' \\<and> q = q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     \\<not> (p = p' \\<and> q = q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "assume conf: \"shd (stl s) = (shd s)\\<lparr>c_msg := (c_msg (shd s))(p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n              c_glob := (c_glob (shd s))(q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\""], ["proof (state)\nthis:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n     c_glob := (c_glob (shd s))\n       (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     \\<not> (p = p' \\<and> q = q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "from a2"], ["proof (chain)\npicking this:\n  InvInfoAtBetaUpright (shd s)", "have buia: \"beta_upright (InfoAt (shd s) k' p' q') (IncomingInfo (shd s) (k'+1) p' q')\""], ["proof (prove)\nusing this:\n  InvInfoAtBetaUpright (shd s)\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd s) k' p' q')\n     (IncomingInfo (shd s) (k' + 1) p' q')", "by (simp add: InvInfoAtBetaUpright_def)"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd s) k' p' q')\n   (IncomingInfo (shd s) (k' + 1) p' q')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     \\<not> (p = p' \\<and> q = q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "case False"], ["proof (state)\nthis:\n  \\<not> (p = p' \\<and> q = q')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     \\<not> (p = p' \\<and> q = q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "with conf"], ["proof (chain)\npicking this:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n     c_glob := (c_glob (shd s))\n       (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\n  \\<not> (p = p' \\<and> q = q')", "have unchii: \"IncomingInfo (shd (stl s)) (k'+1) p' q' = IncomingInfo (shd s) (k'+1) p' q'\""], ["proof (prove)\nusing this:\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n     c_glob := (c_glob (shd s))\n       (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\n  \\<not> (p = p' \\<and> q = q')\n\ngoal (1 subgoal):\n 1. IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n    IncomingInfo (shd s) (k' + 1) p' q'", "by (auto simp: IncomingInfo_def)"], ["proof (state)\nthis:\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     \\<not> (p = p' \\<and> q = q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "from False conf"], ["proof (chain)\npicking this:\n  \\<not> (p = p' \\<and> q = q')\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n     c_glob := (c_glob (shd s))\n       (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>", "have unchia: \"InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'\""], ["proof (prove)\nusing this:\n  \\<not> (p = p' \\<and> q = q')\n  shd (stl s) = shd s\n  \\<lparr>c_msg := (c_msg (shd s))\n            (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n     c_glob := (c_glob (shd s))\n       (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\n\ngoal (1 subgoal):\n 1. InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'", "by (auto simp: InfoAt_def)"], ["proof (state)\nthis:\n  InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c_msg (shd s) p q \\<noteq> [];\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>;\n     \\<not> (p = p' \\<and> q = q')\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd (stl s)) k' p' q')\n                       (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "from unchii unchia buia"], ["proof (chain)\npicking this:\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q'\n  InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'\n  beta_upright (InfoAt (shd s) k' p' q')\n   (IncomingInfo (shd s) (k' + 1) p' q')", "show ?thesis"], ["proof (prove)\nusing this:\n  IncomingInfo (shd (stl s)) (k' + 1) p' q' =\n  IncomingInfo (shd s) (k' + 1) p' q'\n  InfoAt (shd (stl s)) k' p' q' = InfoAt (shd s) k' p' q'\n  beta_upright (InfoAt (shd s) k' p' q')\n   (IncomingInfo (shd s) (k' + 1) p' q')\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd (stl s)) k' p' q')\n     (IncomingInfo (shd (stl s)) (k' + 1) p' q')", "by simp"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd (stl s)) k' p' q')\n   (IncomingInfo (shd (stl s)) (k' + 1) p' q')\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  InvInfoAtBetaUpright (shd (stl s))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>InvInfoAtBetaUpright (shd s); InvIncomingInfoUpright (shd s);\n     InvTempUpright (shd s); shd (stl s) = shd s\\<rbrakk>\n    \\<Longrightarrow> InvInfoAtBetaUpright (shd (stl s))", "qed simp"], ["", "lemma alw_InvInfoAtBetaUpright_aux: \"alw (holds InvTempUpright) s \\<Longrightarrow> alw (holds InvIncomingInfoUpright) s \\<Longrightarrow> holds InvInfoAtBetaUpright s \\<Longrightarrow> alw next s \\<Longrightarrow> alw (holds InvInfoAtBetaUpright) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (holds InvTempUpright) s;\n     alw (holds InvIncomingInfoUpright) s; holds InvInfoAtBetaUpright s;\n     alw next s\\<rbrakk>\n    \\<Longrightarrow> alw (holds InvInfoAtBetaUpright) s", "by (coinduction arbitrary: s rule: alw.coinduct) (auto intro!: next_InvInfoAtBetaUpright)"], ["", "lemma alw_InvInfoAtBetaUpright: \"spec s \\<Longrightarrow> alw (holds InvInfoAtBetaUpright) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds InvInfoAtBetaUpright) s", "by (simp add: alw_InvTempUpright alw_InvIncomingInfoUpright alw_InvInfoAtBetaUpright_aux init_InvInfoAtBetaUpright spec_def)"], ["", "definition InvGlobalInfoAtBetaUpright where\n  \"InvGlobalInfoAtBetaUpright c = (\\<forall>k p q. beta_upright (InfoAt c k p q) (GlobalIncomingInfo c (k+1) p q))\""], ["", "lemma finite_induct_select [consumes 1, case_names empty select]:\n  assumes \"finite S\"\n    and empty: \"P {}\"\n    and select: \"\\<And>T. finite T \\<Longrightarrow> T \\<subset> S \\<Longrightarrow> P T \\<Longrightarrow> \\<exists>s\\<in>S - T. P (insert s T)\"\n  shows \"P S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P S", "from assms(1)"], ["proof (chain)\npicking this:\n  finite S", "have \"P S \\<and> finite S\""], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. P S \\<and> finite S", "by (induct S rule: finite_induct_select) (auto intro: empty select)"], ["proof (state)\nthis:\n  P S \\<and> finite S\n\ngoal (1 subgoal):\n 1. P S", "then"], ["proof (chain)\npicking this:\n  P S \\<and> finite S", "show ?thesis"], ["proof (prove)\nusing this:\n  P S \\<and> finite S\n\ngoal (1 subgoal):\n 1. P S", "by blast"], ["proof (state)\nthis:\n  P S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma predicate_sum_decompose:\n  fixes f :: \"'a \\<Rightarrow> ('b :: ab_group_add)\"\n  assumes \"finite X\"\n    and     \"x\\<in>X\"\n    and     \"A (f x)\"\n    and     \"\\<forall>Z. B (sum f Z)\"\n    and     \"\\<And>x Z. A (f x) \\<Longrightarrow> B (sum f Z) \\<Longrightarrow> A (f x + sum f Z)\"\n    and     \"\\<And>x Z. B (f x) \\<Longrightarrow> A (sum f Z) \\<Longrightarrow> A (f x + sum f Z)\"\n  shows \"A (\\<Sum>x\\<in>X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (sum f X)", "using assms(1,2,3)"], ["proof (prove)\nusing this:\n  finite X\n  x \\<in> X\n  A (f x)\n\ngoal (1 subgoal):\n 1. A (sum f X)", "apply (induct X rule: finite_induct_select)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {}; A (f x)\\<rbrakk> \\<Longrightarrow> A (sum f {})\n 2. \\<And>T.\n       \\<lbrakk>finite T; T \\<subset> X;\n        \\<lbrakk>x \\<in> T; A (f x)\\<rbrakk>\n        \\<Longrightarrow> A (sum f T)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>X - T.\n                            x \\<in> insert s T \\<longrightarrow>\n                            A (f x) \\<longrightarrow> A (sum f (insert s T))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>finite T; T \\<subset> X;\n        \\<lbrakk>x \\<in> T; A (f x)\\<rbrakk>\n        \\<Longrightarrow> A (sum f T)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>X - T.\n                            x \\<in> insert s T \\<longrightarrow>\n                            A (f x) \\<longrightarrow> A (sum f (insert s T))", "apply (simp only: sum.insert_remove)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>finite T; T \\<subset> X;\n        \\<lbrakk>x \\<in> T; A (f x)\\<rbrakk>\n        \\<Longrightarrow> A (sum f T)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>X - T.\n                            x \\<in> insert s T \\<longrightarrow>\n                            A (f x) \\<longrightarrow>\n                            A (f s + sum f (T - {s}))", "subgoal for T"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite T; T \\<subset> X;\n     \\<lbrakk>x \\<in> T; A (f x)\\<rbrakk>\n     \\<Longrightarrow> A (sum f T)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<in>X - T.\n                         x \\<in> insert s T \\<longrightarrow>\n                         A (f x) \\<longrightarrow> A (f s + sum f (T - {s}))", "apply (cases \"x \\<in> T\"; simp add: assms(3))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite T; T \\<subset> X; A (sum f T); x \\<in> T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<in>X - T. A (f s + sum f T)\n 2. \\<lbrakk>finite T; T \\<subset> X; x \\<notin> T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<in>X - T.\n                         x = s \\<longrightarrow>\n                         A (f s) \\<longrightarrow> A (f s + sum f T)", "apply (drule psubset_imp_ex_mem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite T; A (sum f T); x \\<in> T;\n     \\<exists>b. b \\<in> X - T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<in>X - T. A (f s + sum f T)\n 2. \\<lbrakk>finite T; T \\<subset> X; x \\<notin> T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<in>X - T.\n                         x = s \\<longrightarrow>\n                         A (f s) \\<longrightarrow> A (f s + sum f T)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>finite T; A (sum f T); x \\<in> T; b \\<in> X;\n        b \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>X - T. A (f s + sum f T)\n 2. \\<lbrakk>finite T; T \\<subset> X; x \\<notin> T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<in>X - T.\n                         x = s \\<longrightarrow>\n                         A (f s) \\<longrightarrow> A (f s + sum f T)", "subgoal for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite T; A (sum f T); x \\<in> T; z \\<in> X;\n     z \\<notin> T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<in>X - T. A (f s + sum f T)", "apply (rule bexI[of _ z])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite T; A (sum f T); x \\<in> T; z \\<in> X;\n     z \\<notin> T\\<rbrakk>\n    \\<Longrightarrow> A (f z + sum f T)\n 2. \\<lbrakk>finite T; A (sum f T); x \\<in> T; z \\<in> X;\n     z \\<notin> T\\<rbrakk>\n    \\<Longrightarrow> z \\<in> X - T", "apply (rule assms(6)[of z T])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite T; A (sum f T); x \\<in> T; z \\<in> X;\n     z \\<notin> T\\<rbrakk>\n    \\<Longrightarrow> B (f z)\n 2. \\<lbrakk>finite T; A (sum f T); x \\<in> T; z \\<in> X;\n     z \\<notin> T\\<rbrakk>\n    \\<Longrightarrow> A (sum f T)\n 3. \\<lbrakk>finite T; A (sum f T); x \\<in> T; z \\<in> X;\n     z \\<notin> T\\<rbrakk>\n    \\<Longrightarrow> z \\<in> X - T", "apply (rule assms(4)[THEN spec, of \"{z}\", simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite T; A (sum f T); x \\<in> T; z \\<in> X;\n     z \\<notin> T\\<rbrakk>\n    \\<Longrightarrow> A (sum f T)\n 2. \\<lbrakk>finite T; A (sum f T); x \\<in> T; z \\<in> X;\n     z \\<notin> T\\<rbrakk>\n    \\<Longrightarrow> z \\<in> X - T", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite T; A (sum f T); x \\<in> T; z \\<in> X;\n     z \\<notin> T\\<rbrakk>\n    \\<Longrightarrow> z \\<in> X - T", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite T; T \\<subset> X; x \\<notin> T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<in>X - T.\n                         x = s \\<longrightarrow>\n                         A (f s) \\<longrightarrow> A (f s + sum f T)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>finite T; x \\<notin> T; T \\<subseteq> X;\n        \\<forall>s\\<in>X - T.\n           x = s \\<and> A (f s) \\<and> \\<not> A (f s + sum f T);\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> T", "apply (drule bspec[of _ _ x])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>finite T; x \\<notin> T; T \\<subseteq> X; xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X - T\n 2. \\<And>xa.\n       \\<lbrakk>finite T; x \\<notin> T; T \\<subseteq> X; xa \\<in> X;\n        x = x \\<and> A (f x) \\<and> \\<not> A (f x + sum f T)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> T", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>finite T; x \\<notin> T; T \\<subseteq> X; xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 2. \\<And>xa.\n       \\<lbrakk>finite T; x \\<notin> T; T \\<subseteq> X; xa \\<in> X;\n        A (f x); \\<not> A (f x + sum f T)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> T", "apply (rule assms(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>finite T; x \\<notin> T; T \\<subseteq> X; xa \\<in> X;\n        A (f x); \\<not> A (f x + sum f T)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> T", "using assms(4,5)"], ["proof (prove)\nusing this:\n  \\<forall>Z. B (sum f Z)\n  \\<lbrakk>A (f ?x); B (sum f ?Z)\\<rbrakk>\n  \\<Longrightarrow> A (f ?x + sum f ?Z)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>finite T; x \\<notin> T; T \\<subseteq> X; xa \\<in> X;\n        A (f x); \\<not> A (f x + sum f T)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> T", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invs_imp_InvGlobalInfoAtBetaUpright:\n  assumes \"holds InvInfoAtBetaUpright s\"\n    and     \"holds InvGlobalIncomingInfoUpright s\"\n    and     \"holds InvIncomingInfoUpright s\"\n  shows   \"holds InvGlobalInfoAtBetaUpright s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. holds InvGlobalInfoAtBetaUpright s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. holds InvGlobalInfoAtBetaUpright s", "have uii: \"\\<forall>k p q. upright (IncomingInfo (shd s) k p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k p q. upright (IncomingInfo (shd s) k p q)", "by (rule assms(3)[unfolded InvIncomingInfoUpright_def, simplified])"], ["proof (state)\nthis:\n  \\<forall>k p q. upright (IncomingInfo (shd s) k p q)\n\ngoal (1 subgoal):\n 1. holds InvGlobalInfoAtBetaUpright s", "have ugii: \"\\<forall>k p q. upright (GlobalIncomingInfo (shd s) k p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k p q. upright (GlobalIncomingInfo (shd s) k p q)", "by (rule assms(2)[unfolded InvGlobalIncomingInfoUpright_def, simplified])"], ["proof (state)\nthis:\n  \\<forall>k p q. upright (GlobalIncomingInfo (shd s) k p q)\n\ngoal (1 subgoal):\n 1. holds InvGlobalInfoAtBetaUpright s", "have buia: \"\\<forall>k p q. beta_upright (InfoAt (shd s) k p q) (IncomingInfo (shd s) (Suc k) p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k p q.\n       beta_upright (InfoAt (shd s) k p q)\n        (IncomingInfo (shd s) (Suc k) p q)", "by (rule assms(1)[unfolded InvInfoAtBetaUpright_def, simplified])"], ["proof (state)\nthis:\n  \\<forall>k p q.\n     beta_upright (InfoAt (shd s) k p q) (IncomingInfo (shd s) (Suc k) p q)\n\ngoal (1 subgoal):\n 1. holds InvGlobalInfoAtBetaUpright s", "from uii ugii buia"], ["proof (chain)\npicking this:\n  \\<forall>k p q. upright (IncomingInfo (shd s) k p q)\n  \\<forall>k p q. upright (GlobalIncomingInfo (shd s) k p q)\n  \\<forall>k p q.\n     beta_upright (InfoAt (shd s) k p q) (IncomingInfo (shd s) (Suc k) p q)", "have \"\\<forall>k p q. beta_upright (InfoAt (shd s) k p q) (GlobalIncomingInfo (shd s) (Suc k) p q)\""], ["proof (prove)\nusing this:\n  \\<forall>k p q. upright (IncomingInfo (shd s) k p q)\n  \\<forall>k p q. upright (GlobalIncomingInfo (shd s) k p q)\n  \\<forall>k p q.\n     beta_upright (InfoAt (shd s) k p q) (IncomingInfo (shd s) (Suc k) p q)\n\ngoal (1 subgoal):\n 1. \\<forall>k p q.\n       beta_upright (InfoAt (shd s) k p q)\n        (GlobalIncomingInfo (shd s) (Suc k) p q)", "unfolding GlobalIncomingInfo_def"], ["proof (prove)\nusing this:\n  \\<forall>k p q. upright (IncomingInfo (shd s) k p q)\n  \\<forall>k p q.\n     upright\n      (\\<Sum>p'\\<in>UNIV.\n         IncomingInfo (shd s) (if p' = p then k else 0) p' q)\n  \\<forall>k p q.\n     beta_upright (InfoAt (shd s) k p q) (IncomingInfo (shd s) (Suc k) p q)\n\ngoal (1 subgoal):\n 1. \\<forall>k p q.\n       beta_upright (InfoAt (shd s) k p q)\n        (\\<Sum>p'\\<in>UNIV.\n           IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k p q.\n                         beta_upright (InfoAt (shd s) k p q)\n                          (\\<Sum>p'\\<in>UNIV.\n                             IncomingInfo (shd s)\n                              (if p' = p then Suc k else 0) p' q)", "apply (rule allI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k p q.\n       \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n        \\<forall>k p q.\n           upright\n            (\\<Sum>p'\\<in>UNIV.\n               IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n        \\<forall>k p q.\n           beta_upright (InfoAt (shd s) k p q)\n            (IncomingInfo (shd s) (Suc k) p q)\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                          (\\<Sum>p'\\<in>UNIV.\n                             IncomingInfo (shd s)\n                              (if p' = p then Suc k else 0) p' q)", "subgoal for k p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       (\\<Sum>p'\\<in>UNIV.\n                          IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                           p' q)", "apply (rule predicate_sum_decompose[of UNIV p \"\\<lambda>v. beta_upright (InfoAt (shd s) k p q) v\" \"\\<lambda>p'. IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q\" upright])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q)\\<rbrakk>\n    \\<Longrightarrow> finite UNIV\n 2. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q)\\<rbrakk>\n    \\<Longrightarrow> p \\<in> UNIV\n 3. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       (IncomingInfo (shd s) (if p = p then Suc k else 0) p\n                         q)\n 4. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>Z.\n                         upright\n                          (\\<Sum>p'\\<in>Z.\n                             IncomingInfo (shd s)\n                              (if p' = p then Suc k else 0) p' q)\n 5. \\<And>p' Z.\n       \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n        \\<forall>k p q.\n           upright\n            (\\<Sum>p'\\<in>UNIV.\n               IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n        \\<forall>k p q.\n           beta_upright (InfoAt (shd s) k p q)\n            (IncomingInfo (shd s) (Suc k) p q);\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n        upright\n         (\\<Sum>p'\\<in>Z.\n            IncomingInfo (shd s) (if p' = p then Suc k else 0) p'\n             q)\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                          (IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q +\n                           (\\<Sum>p'\\<in>Z.\n                              IncomingInfo (shd s)\n                               (if p' = p then Suc k else 0) p' q))\n 6. \\<And>p' Z.\n       \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n        \\<forall>k p q.\n           upright\n            (\\<Sum>p'\\<in>UNIV.\n               IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n        \\<forall>k p q.\n           beta_upright (InfoAt (shd s) k p q)\n            (IncomingInfo (shd s) (Suc k) p q);\n        upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n        beta_upright (InfoAt (shd s) k p q)\n         (\\<Sum>p'\\<in>Z.\n            IncomingInfo (shd s) (if p' = p then Suc k else 0) p'\n             q)\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                          (IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q +\n                           (\\<Sum>p'\\<in>Z.\n                              IncomingInfo (shd s)\n                               (if p' = p then Suc k else 0) p' q))", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q)\\<rbrakk>\n    \\<Longrightarrow> p \\<in> UNIV\n 2. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       (IncomingInfo (shd s) (if p = p then Suc k else 0) p\n                         q)\n 3. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>Z.\n                         upright\n                          (\\<Sum>p'\\<in>Z.\n                             IncomingInfo (shd s)\n                              (if p' = p then Suc k else 0) p' q)\n 4. \\<And>p' Z.\n       \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n        \\<forall>k p q.\n           upright\n            (\\<Sum>p'\\<in>UNIV.\n               IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n        \\<forall>k p q.\n           beta_upright (InfoAt (shd s) k p q)\n            (IncomingInfo (shd s) (Suc k) p q);\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n        upright\n         (\\<Sum>p'\\<in>Z.\n            IncomingInfo (shd s) (if p' = p then Suc k else 0) p'\n             q)\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                          (IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q +\n                           (\\<Sum>p'\\<in>Z.\n                              IncomingInfo (shd s)\n                               (if p' = p then Suc k else 0) p' q))\n 5. \\<And>p' Z.\n       \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n        \\<forall>k p q.\n           upright\n            (\\<Sum>p'\\<in>UNIV.\n               IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n        \\<forall>k p q.\n           beta_upright (InfoAt (shd s) k p q)\n            (IncomingInfo (shd s) (Suc k) p q);\n        upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n        beta_upright (InfoAt (shd s) k p q)\n         (\\<Sum>p'\\<in>Z.\n            IncomingInfo (shd s) (if p' = p then Suc k else 0) p'\n             q)\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                          (IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q +\n                           (\\<Sum>p'\\<in>Z.\n                              IncomingInfo (shd s)\n                               (if p' = p then Suc k else 0) p' q))", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       (IncomingInfo (shd s) (if p = p then Suc k else 0) p\n                         q)\n 2. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>Z.\n                         upright\n                          (\\<Sum>p'\\<in>Z.\n                             IncomingInfo (shd s)\n                              (if p' = p then Suc k else 0) p' q)\n 3. \\<And>p' Z.\n       \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n        \\<forall>k p q.\n           upright\n            (\\<Sum>p'\\<in>UNIV.\n               IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n        \\<forall>k p q.\n           beta_upright (InfoAt (shd s) k p q)\n            (IncomingInfo (shd s) (Suc k) p q);\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n        upright\n         (\\<Sum>p'\\<in>Z.\n            IncomingInfo (shd s) (if p' = p then Suc k else 0) p'\n             q)\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                          (IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q +\n                           (\\<Sum>p'\\<in>Z.\n                              IncomingInfo (shd s)\n                               (if p' = p then Suc k else 0) p' q))\n 4. \\<And>p' Z.\n       \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n        \\<forall>k p q.\n           upright\n            (\\<Sum>p'\\<in>UNIV.\n               IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n        \\<forall>k p q.\n           beta_upright (InfoAt (shd s) k p q)\n            (IncomingInfo (shd s) (Suc k) p q);\n        upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n        beta_upright (InfoAt (shd s) k p q)\n         (\\<Sum>p'\\<in>Z.\n            IncomingInfo (shd s) (if p' = p then Suc k else 0) p'\n             q)\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                          (IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q +\n                           (\\<Sum>p'\\<in>Z.\n                              IncomingInfo (shd s)\n                               (if p' = p then Suc k else 0) p' q))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>Z.\n                         upright\n                          (\\<Sum>p'\\<in>Z.\n                             IncomingInfo (shd s)\n                              (if p' = p then Suc k else 0) p' q)\n 2. \\<And>p' Z.\n       \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n        \\<forall>k p q.\n           upright\n            (\\<Sum>p'\\<in>UNIV.\n               IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n        \\<forall>k p q.\n           beta_upright (InfoAt (shd s) k p q)\n            (IncomingInfo (shd s) (Suc k) p q);\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n        upright\n         (\\<Sum>p'\\<in>Z.\n            IncomingInfo (shd s) (if p' = p then Suc k else 0) p'\n             q)\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                          (IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q +\n                           (\\<Sum>p'\\<in>Z.\n                              IncomingInfo (shd s)\n                               (if p' = p then Suc k else 0) p' q))\n 3. \\<And>p' Z.\n       \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n        \\<forall>k p q.\n           upright\n            (\\<Sum>p'\\<in>UNIV.\n               IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n        \\<forall>k p q.\n           beta_upright (InfoAt (shd s) k p q)\n            (IncomingInfo (shd s) (Suc k) p q);\n        upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n        beta_upright (InfoAt (shd s) k p q)\n         (\\<Sum>p'\\<in>Z.\n            IncomingInfo (shd s) (if p' = p then Suc k else 0) p'\n             q)\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                          (IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q +\n                           (\\<Sum>p'\\<in>Z.\n                              IncomingInfo (shd s)\n                               (if p' = p then Suc k else 0) p' q))", "apply (simp add: upright_sum_upright)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p' Z.\n       \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n        \\<forall>k p q.\n           upright\n            (\\<Sum>p'\\<in>UNIV.\n               IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n        \\<forall>k p q.\n           beta_upright (InfoAt (shd s) k p q)\n            (IncomingInfo (shd s) (Suc k) p q);\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n        upright\n         (\\<Sum>p'\\<in>Z.\n            IncomingInfo (shd s) (if p' = p then Suc k else 0) p'\n             q)\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                          (IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q +\n                           (\\<Sum>p'\\<in>Z.\n                              IncomingInfo (shd s)\n                               (if p' = p then Suc k else 0) p' q))\n 2. \\<And>p' Z.\n       \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n        \\<forall>k p q.\n           upright\n            (\\<Sum>p'\\<in>UNIV.\n               IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n        \\<forall>k p q.\n           beta_upright (InfoAt (shd s) k p q)\n            (IncomingInfo (shd s) (Suc k) p q);\n        upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n        beta_upright (InfoAt (shd s) k p q)\n         (\\<Sum>p'\\<in>Z.\n            IncomingInfo (shd s) (if p' = p then Suc k else 0) p'\n             q)\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                          (IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q +\n                           (\\<Sum>p'\\<in>Z.\n                              IncomingInfo (shd s)\n                               (if p' = p then Suc k else 0) p' q))", "subgoal for p' X"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     beta_upright (InfoAt (shd s) k p q)\n      (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     upright\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       (IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                         p' q +\n                        (\\<Sum>p'\\<in>X.\n                           IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q))", "apply (rule beta_upright_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     beta_upright (InfoAt (shd s) k p q)\n      (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     upright\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> upright\n                       (IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                         p' q)\n 2. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     beta_upright (InfoAt (shd s) k p q)\n      (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     upright\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> upright\n                       (\\<Sum>p'\\<in>X.\n                          IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                           p' q)\n 3. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     beta_upright (InfoAt (shd s) k p q)\n      (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     upright\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       (IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                         p' q)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     beta_upright (InfoAt (shd s) k p q)\n      (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     upright\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> upright\n                       (\\<Sum>p'\\<in>X.\n                          IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                           p' q)\n 2. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     beta_upright (InfoAt (shd s) k p q)\n      (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     upright\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       (IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                         p' q)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     beta_upright (InfoAt (shd s) k p q)\n      (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     upright\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       (IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                         p' q)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p' Z.\n       \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n        \\<forall>k p q.\n           upright\n            (\\<Sum>p'\\<in>UNIV.\n               IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n        \\<forall>k p q.\n           beta_upright (InfoAt (shd s) k p q)\n            (IncomingInfo (shd s) (Suc k) p q);\n        upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n        beta_upright (InfoAt (shd s) k p q)\n         (\\<Sum>p'\\<in>Z.\n            IncomingInfo (shd s) (if p' = p then Suc k else 0) p'\n             q)\\<rbrakk>\n       \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                          (IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q +\n                           (\\<Sum>p'\\<in>Z.\n                              IncomingInfo (shd s)\n                               (if p' = p then Suc k else 0) p' q))", "subgoal for p' X"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     beta_upright (InfoAt (shd s) k p q)\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       (IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                         p' q +\n                        (\\<Sum>p'\\<in>X.\n                           IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q))", "apply (subst add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     beta_upright (InfoAt (shd s) k p q)\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       ((\\<Sum>p'\\<in>X.\n                           IncomingInfo (shd s)\n                            (if p' = p then Suc k else 0) p' q) +\n                        IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                         p' q)", "apply (rule beta_upright_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     beta_upright (InfoAt (shd s) k p q)\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> upright\n                       (\\<Sum>p'\\<in>X.\n                          IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                           p' q)\n 2. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     beta_upright (InfoAt (shd s) k p q)\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> upright\n                       (IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                         p' q)\n 3. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     beta_upright (InfoAt (shd s) k p q)\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       (\\<Sum>p'\\<in>X.\n                          IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                           p' q)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     beta_upright (InfoAt (shd s) k p q)\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> upright\n                       (\\<Sum>p'\\<in>X.\n                          IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                           p' q)\n 2. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     beta_upright (InfoAt (shd s) k p q)\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> upright\n                       (IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                         p' q)\n 3. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     beta_upright (InfoAt (shd s) k p q)\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       (\\<Sum>p'\\<in>X.\n                          IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                           p' q)", "apply (simp add: upright_sum_upright)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     beta_upright (InfoAt (shd s) k p q)\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> upright\n                       (IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                         p' q)\n 2. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     beta_upright (InfoAt (shd s) k p q)\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       (\\<Sum>p'\\<in>X.\n                          IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                           p' q)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k p q. upright (IncomingInfo (shd s) k p q);\n     \\<forall>k p q.\n        upright\n         (\\<Sum>p'\\<in>UNIV.\n            IncomingInfo (shd s) (if p' = p then k else 0) p' q);\n     \\<forall>k p q.\n        beta_upright (InfoAt (shd s) k p q)\n         (IncomingInfo (shd s) (Suc k) p q);\n     upright (IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q);\n     beta_upright (InfoAt (shd s) k p q)\n      (\\<Sum>p'\\<in>X.\n         IncomingInfo (shd s) (if p' = p then Suc k else 0) p' q)\\<rbrakk>\n    \\<Longrightarrow> beta_upright (InfoAt (shd s) k p q)\n                       (\\<Sum>p'\\<in>X.\n                          IncomingInfo (shd s) (if p' = p then Suc k else 0)\n                           p' q)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>k p q.\n     beta_upright (InfoAt (shd s) k p q)\n      (GlobalIncomingInfo (shd s) (Suc k) p q)\n\ngoal (1 subgoal):\n 1. holds InvGlobalInfoAtBetaUpright s", "then"], ["proof (chain)\npicking this:\n  \\<forall>k p q.\n     beta_upright (InfoAt (shd s) k p q)\n      (GlobalIncomingInfo (shd s) (Suc k) p q)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>k p q.\n     beta_upright (InfoAt (shd s) k p q)\n      (GlobalIncomingInfo (shd s) (Suc k) p q)\n\ngoal (1 subgoal):\n 1. holds InvGlobalInfoAtBetaUpright s", "by (simp add: InvGlobalInfoAtBetaUpright_def)"], ["proof (state)\nthis:\n  holds InvGlobalInfoAtBetaUpright s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alw_InvGlobalInfoAtBetaUpright: \"spec s \\<Longrightarrow> alw (holds InvGlobalInfoAtBetaUpright) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds InvGlobalInfoAtBetaUpright) s", "by (meson alw_InvGlobalIncomingInfoUpright alw_InvIncomingInfoUpright alw_InvInfoAtBetaUpright alw_iff_sdrop invs_imp_InvGlobalInfoAtBetaUpright)"], ["", "definition SafeStickyGlobVacantUpto :: \"('p :: finite, 't :: order) computation \\<Rightarrow> bool\" where\n  \"SafeStickyGlobVacantUpto s = (\\<forall>q t. GlobVacantUpto (shd s) q t \\<longrightarrow> alw (holds (\\<lambda>c. GlobVacantUpto c q t)) s)\""], ["", "lemma gvut1:\n  \"GlobVacantUpto (shd s) q t \\<Longrightarrow> next_performop s \\<Longrightarrow> GlobVacantUpto (shd (stl s)) q t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>GlobVacantUpto (shd s) q t; next_performop s\\<rbrakk>\n    \\<Longrightarrow> GlobVacantUpto (shd (stl s)) q t", "by (auto simp add: next_performop'_def Let_def vacant_upto_def upright_def)"], ["", "lemma gvut2:\n  \"GlobVacantUpto (shd s) q t \\<Longrightarrow> next_sendupd s \\<Longrightarrow> GlobVacantUpto (shd (stl s)) q t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>GlobVacantUpto (shd s) q t; next_sendupd s\\<rbrakk>\n    \\<Longrightarrow> GlobVacantUpto (shd (stl s)) q t", "by (auto simp add: next_sendupd'_def Let_def)"], ["", "lemma gvut3:\n  assumes\n    gvu: \"GlobVacantUpto (shd s) q t\" and\n    igvuin: \"InvGlobVacantUptoImpliesNrec (shd s)\" and\n    igrc: \"InvGlobalRecordCount (shd s)\" and\n    igiiu: \"InvGlobalIncomingInfoUpright (shd s)\" and\n    igiabu: \"InvGlobalInfoAtBetaUpright (shd s)\" and\n    \"next\": \"next_recvupd s\"\n  shows \"GlobVacantUpto (shd (stl s)) q t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "let ?GII0 = \"GlobalIncomingInfo (shd s) 0 p q\""], ["proof (state)\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "let ?GII1 = \"GlobalIncomingInfo (shd s) 1 p q\""], ["proof (state)\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "let ?\\<kappa> = \"hd (c_msg (shd s) p q)\""], ["proof (state)\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "from igiiu"], ["proof (chain)\npicking this:\n  InvGlobalIncomingInfoUpright (shd s)", "have uGII1: \"upright ?GII1\""], ["proof (prove)\nusing this:\n  InvGlobalIncomingInfoUpright (shd s)\n\ngoal (1 subgoal):\n 1. upright (GlobalIncomingInfo (shd s) 1 p q)", "unfolding InvGlobalIncomingInfoUpright_def"], ["proof (prove)\nusing this:\n  \\<forall>k p q. upright (GlobalIncomingInfo (shd s) k p q)\n\ngoal (1 subgoal):\n 1. upright (GlobalIncomingInfo (shd s) 1 p q)", "by simp"], ["proof (state)\nthis:\n  upright (GlobalIncomingInfo (shd s) 1 p q)\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "assume globk: \"c_glob (shd (stl s)) q = c_glob (shd s) q + ?\\<kappa>\""], ["proof (state)\nthis:\n  c_glob (shd (stl s)) q = c_glob (shd s) q + hd (c_msg (shd s) p q)\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "assume nonempty: \"c_msg (shd s) p q \\<noteq> []\""], ["proof (state)\nthis:\n  c_msg (shd s) p q \\<noteq> []\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "then"], ["proof (chain)\npicking this:\n  c_msg (shd s) p q \\<noteq> []", "have sumGIIsk: \"?GII0 = ?GII1 + ?\\<kappa>\""], ["proof (prove)\nusing this:\n  c_msg (shd s) p q \\<noteq> []\n\ngoal (1 subgoal):\n 1. GlobalIncomingInfo (shd s) 0 p q =\n    GlobalIncomingInfo (shd s) 1 p q + hd (c_msg (shd s) p q)", "unfolding GlobalIncomingInfo_def IncomingInfo_def"], ["proof (prove)\nusing this:\n  c_msg (shd s) p q \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<Sum>p'\\<in>UNIV.\n       sum_list (drop (if p' = p then 0 else 0) (c_msg (shd s) p' q)) +\n       c_temp (shd s) p') =\n    (\\<Sum>p'\\<in>UNIV.\n       sum_list (drop (if p' = p then 1 else 0) (c_msg (shd s) p' q)) +\n       c_temp (shd s) p') +\n    hd (c_msg (shd s) p q)", "by (auto simp: sum.remove ac_simps neq_Nil_conv)"], ["proof (state)\nthis:\n  GlobalIncomingInfo (shd s) 0 p q =\n  GlobalIncomingInfo (shd s) 1 p q + hd (c_msg (shd s) p q)\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "from nonempty"], ["proof (chain)\npicking this:\n  c_msg (shd s) p q \\<noteq> []", "have IA0k: \"?\\<kappa> = InfoAt (shd s) 0 p q\""], ["proof (prove)\nusing this:\n  c_msg (shd s) p q \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (c_msg (shd s) p q) = InfoAt (shd s) 0 p q", "by (simp add: InfoAt_def hd_conv_nth)"], ["proof (state)\nthis:\n  hd (c_msg (shd s) p q) = InfoAt (shd s) 0 p q\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "from igiabu nonempty"], ["proof (chain)\npicking this:\n  InvGlobalInfoAtBetaUpright (shd s)\n  c_msg (shd s) p q \\<noteq> []", "have bukGII1: \"beta_upright ?\\<kappa> ?GII1\""], ["proof (prove)\nusing this:\n  InvGlobalInfoAtBetaUpright (shd s)\n  c_msg (shd s) p q \\<noteq> []\n\ngoal (1 subgoal):\n 1. beta_upright (hd (c_msg (shd s) p q)) (GlobalIncomingInfo (shd s) 1 p q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalInfoAtBetaUpright (shd s);\n     c_msg (shd s) p q \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> beta_upright (hd (c_msg (shd s) p q))\n                       (GlobalIncomingInfo (shd s) 1 p q)", "note igiabu"], ["proof (state)\nthis:\n  InvGlobalInfoAtBetaUpright (shd s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalInfoAtBetaUpright (shd s);\n     c_msg (shd s) p q \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> beta_upright (hd (c_msg (shd s) p q))\n                       (GlobalIncomingInfo (shd s) 1 p q)", "then"], ["proof (chain)\npicking this:\n  InvGlobalInfoAtBetaUpright (shd s)", "have \"beta_upright (InfoAt (shd s) 0 p q) (GlobalIncomingInfo (shd s) 1 p q)\""], ["proof (prove)\nusing this:\n  InvGlobalInfoAtBetaUpright (shd s)\n\ngoal (1 subgoal):\n 1. beta_upright (InfoAt (shd s) 0 p q) (GlobalIncomingInfo (shd s) 1 p q)", "by (simp add: InvGlobalInfoAtBetaUpright_def)"], ["proof (state)\nthis:\n  beta_upright (InfoAt (shd s) 0 p q) (GlobalIncomingInfo (shd s) 1 p q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobalInfoAtBetaUpright (shd s);\n     c_msg (shd s) p q \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> beta_upright (hd (c_msg (shd s) p q))\n                       (GlobalIncomingInfo (shd s) 1 p q)", "with IA0k"], ["proof (chain)\npicking this:\n  hd (c_msg (shd s) p q) = InfoAt (shd s) 0 p q\n  beta_upright (InfoAt (shd s) 0 p q) (GlobalIncomingInfo (shd s) 1 p q)", "show ?thesis"], ["proof (prove)\nusing this:\n  hd (c_msg (shd s) p q) = InfoAt (shd s) 0 p q\n  beta_upright (InfoAt (shd s) 0 p q) (GlobalIncomingInfo (shd s) 1 p q)\n\ngoal (1 subgoal):\n 1. beta_upright (hd (c_msg (shd s) p q)) (GlobalIncomingInfo (shd s) 1 p q)", "by simp"], ["proof (state)\nthis:\n  beta_upright (hd (c_msg (shd s) p q)) (GlobalIncomingInfo (shd s) 1 p q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  beta_upright (hd (c_msg (shd s) p q)) (GlobalIncomingInfo (shd s) 1 p q)\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "from igvuin gvu"], ["proof (chain)\npicking this:\n  InvGlobVacantUptoImpliesNrec (shd s)\n  GlobVacantUpto (shd s) q t", "have nvu: \"NrecVacantUpto (shd s) t\""], ["proof (prove)\nusing this:\n  InvGlobVacantUptoImpliesNrec (shd s)\n  GlobVacantUpto (shd s) q t\n\ngoal (1 subgoal):\n 1. NrecVacantUpto (shd s) t", "unfolding InvGlobVacantUptoImpliesNrec_def"], ["proof (prove)\nusing this:\n  \\<forall>t q.\n     GlobVacantUpto (shd s) q t \\<longrightarrow> NrecVacantUpto (shd s) t\n  GlobVacantUpto (shd s) q t\n\ngoal (1 subgoal):\n 1. NrecVacantUpto (shd s) t", "by blast"], ["proof (state)\nthis:\n  NrecVacantUpto (shd s) t\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "with igrc"], ["proof (chain)\npicking this:\n  InvGlobalRecordCount (shd s)\n  NrecVacantUpto (shd s) t", "have \"c_records (shd s) = c_glob (shd s) q + ?GII0\""], ["proof (prove)\nusing this:\n  InvGlobalRecordCount (shd s)\n  NrecVacantUpto (shd s) t\n\ngoal (1 subgoal):\n 1. c_records (shd s) = c_glob (shd s) q + GlobalIncomingInfo (shd s) 0 p q", "unfolding GlobalIncomingInfo_def IncomingInfo_def InvGlobalRecordCount_def"], ["proof (prove)\nusing this:\n  \\<forall>q.\n     c_records (shd s) =\n     (\\<Sum>p'\\<in>UNIV.\n        sum_list (drop (if p' = q then 0 else 0) (c_msg (shd s) p' q)) +\n        c_temp (shd s) p') +\n     c_glob (shd s) q\n  NrecVacantUpto (shd s) t\n\ngoal (1 subgoal):\n 1. c_records (shd s) =\n    c_glob (shd s) q +\n    (\\<Sum>p'\\<in>UNIV.\n       sum_list (drop (if p' = p then 0 else 0) (c_msg (shd s) p' q)) +\n       c_temp (shd s) p')", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  c_records (shd s) = c_glob (shd s) q + GlobalIncomingInfo (shd s) 0 p q\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "with gvu nvu"], ["proof (chain)\npicking this:\n  GlobVacantUpto (shd s) q t\n  NrecVacantUpto (shd s) t\n  c_records (shd s) = c_glob (shd s) q + GlobalIncomingInfo (shd s) 0 p q", "have vuGII0: \"vacant_upto ?GII0 t\""], ["proof (prove)\nusing this:\n  GlobVacantUpto (shd s) q t\n  NrecVacantUpto (shd s) t\n  c_records (shd s) = c_glob (shd s) q + GlobalIncomingInfo (shd s) 0 p q\n\ngoal (1 subgoal):\n 1. vacant_upto (GlobalIncomingInfo (shd s) 0 p q) t", "by (simp add: vacant_upto_def)"], ["proof (state)\nthis:\n  vacant_upto (GlobalIncomingInfo (shd s) 0 p q) t\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "from bukGII1 uGII1"], ["proof (chain)\npicking this:\n  beta_upright (hd (c_msg (shd s) p q)) (GlobalIncomingInfo (shd s) 1 p q)\n  upright (GlobalIncomingInfo (shd s) 1 p q)", "have \"vacant_upto ?\\<kappa> t\""], ["proof (prove)\nusing this:\n  beta_upright (hd (c_msg (shd s) p q)) (GlobalIncomingInfo (shd s) 1 p q)\n  upright (GlobalIncomingInfo (shd s) 1 p q)\n\ngoal (1 subgoal):\n 1. vacant_upto (hd (c_msg (shd s) p q)) t", "by (rule betaupright_upright_vut[of ?\\<kappa> ?GII1]) (metis vuGII0 add.commute sumGIIsk)"], ["proof (state)\nthis:\n  vacant_upto (hd (c_msg (shd s) p q)) t\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "with gvu"], ["proof (chain)\npicking this:\n  GlobVacantUpto (shd s) q t\n  vacant_upto (hd (c_msg (shd s) p q)) t", "have \"GlobVacantUpto (shd (stl s)) q t\""], ["proof (prove)\nusing this:\n  GlobVacantUpto (shd s) q t\n  vacant_upto (hd (c_msg (shd s) p q)) t\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "by (simp add: globk vacant_upto_def)"], ["proof (state)\nthis:\n  GlobVacantUpto (shd (stl s)) q t\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "}"], ["proof (state)\nthis:\n  \\<lbrakk>c_glob (shd (stl s)) q =\n           c_glob (shd s) q + hd (c_msg (shd s) ?p2 q);\n   c_msg (shd s) ?p2 q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> GlobVacantUpto (shd (stl s)) q t\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>c_glob (shd (stl s)) q =\n           c_glob (shd s) q + hd (c_msg (shd s) ?p2 q);\n   c_msg (shd s) ?p2 q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> GlobVacantUpto (shd (stl s)) q t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>c_glob (shd (stl s)) q =\n           c_glob (shd s) q + hd (c_msg (shd s) ?p2 q);\n   c_msg (shd s) ?p2 q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> GlobVacantUpto (shd (stl s)) q t\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>c_glob (shd (stl s)) q =\n           c_glob (shd s) q + hd (c_msg (shd s) ?p2 q);\n   c_msg (shd s) ?p2 q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> GlobVacantUpto (shd (stl s)) q t\n  GlobVacantUpto (shd s) q t\n  InvGlobVacantUptoImpliesNrec (shd s)\n  InvGlobalRecordCount (shd s)\n  InvGlobalIncomingInfoUpright (shd s)\n  InvGlobalInfoAtBetaUpright (shd s)\n  next_recvupd s\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "unfolding next_recvupd'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>c_glob (shd (stl s)) q =\n           c_glob (shd s) q + hd (c_msg (shd s) ?p2 q);\n   c_msg (shd s) ?p2 q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> GlobVacantUpto (shd (stl s)) q t\n  GlobVacantUpto (shd s) q t\n  InvGlobVacantUptoImpliesNrec (shd s)\n  InvGlobalRecordCount (shd s)\n  InvGlobalIncomingInfoUpright (shd s)\n  InvGlobalInfoAtBetaUpright (shd s)\n  \\<exists>p q.\n     c_msg (shd s) p q \\<noteq> [] \\<and>\n     shd (stl s) = shd s\n     \\<lparr>c_msg := (c_msg (shd s))\n               (p := (c_msg (shd s) p)(q := tl (c_msg (shd s) p q))),\n        c_glob := (c_glob (shd s))\n          (q := c_glob (shd s) q + hd (c_msg (shd s) p q))\\<rparr>\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl s)) q t", "by auto"], ["proof (state)\nthis:\n  GlobVacantUpto (shd (stl s)) q t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spec_imp_SafeStickyGlobVacantUpto_aux:\n  assumes\n    \"alw (holds (\\<lambda>c. InvGlobVacantUptoImpliesNrec c)) s\" and\n    \"alw (holds (\\<lambda>c. InvGlobalRecordCount c)) s\" and\n    \"alw (holds (\\<lambda>c. InvGlobalIncomingInfoUpright c)) s\" and\n    \"alw (holds (\\<lambda>c. InvGlobalInfoAtBetaUpright c)) s\" and\n    \"alw next s\"\n  shows \"alw SafeStickyGlobVacantUpto s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw SafeStickyGlobVacantUpto s", "using assms"], ["proof (prove)\nusing this:\n  alw (holds InvGlobVacantUptoImpliesNrec) s\n  alw (holds InvGlobalRecordCount) s\n  alw (holds InvGlobalIncomingInfoUpright) s\n  alw (holds InvGlobalInfoAtBetaUpright) s\n  alw next s\n\ngoal (1 subgoal):\n 1. alw SafeStickyGlobVacantUpto s", "apply (coinduction arbitrary: s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s; alw next s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            s = xs \\<and>\n                            SafeStickyGlobVacantUpto xs \\<and>\n                            ((\\<exists>s.\n                                 stl xs = s \\<and>\n                                 alw (holds InvGlobVacantUptoImpliesNrec)\n                                  s \\<and>\n                                 alw (holds InvGlobalRecordCount) s \\<and>\n                                 alw (holds InvGlobalIncomingInfoUpright)\n                                  s \\<and>\n                                 alw (holds InvGlobalInfoAtBetaUpright)\n                                  s \\<and>\n                                 alw next s) \\<or>\n                             alw SafeStickyGlobVacantUpto (stl xs))", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n     alw (holds InvGlobalRecordCount) s;\n     alw (holds InvGlobalIncomingInfoUpright) s;\n     alw (holds InvGlobalInfoAtBetaUpright) s; alw next s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         s = xs \\<and>\n                         SafeStickyGlobVacantUpto xs \\<and>\n                         ((\\<exists>s.\n                              stl xs = s \\<and>\n                              alw (holds InvGlobVacantUptoImpliesNrec)\n                               s \\<and>\n                              alw (holds InvGlobalRecordCount) s \\<and>\n                              alw (holds InvGlobalIncomingInfoUpright)\n                               s \\<and>\n                              alw (holds InvGlobalInfoAtBetaUpright)\n                               s \\<and>\n                              alw next s) \\<or>\n                          alw SafeStickyGlobVacantUpto (stl xs))", "unfolding spec_def next_def SafeStickyGlobVacantUpto_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n     alw (holds InvGlobalRecordCount) s;\n     alw (holds InvGlobalIncomingInfoUpright) s;\n     alw (holds InvGlobalInfoAtBetaUpright) s;\n     alw (\\<lambda>s.\n             next_performop s \\<or>\n             next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n      s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         s = xs \\<and>\n                         (\\<forall>q t.\n                             GlobVacantUpto (shd xs) q t \\<longrightarrow>\n                             alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                              xs) \\<and>\n                         ((\\<exists>s.\n                              stl xs = s \\<and>\n                              alw (holds InvGlobVacantUptoImpliesNrec)\n                               s \\<and>\n                              alw (holds InvGlobalRecordCount) s \\<and>\n                              alw (holds InvGlobalIncomingInfoUpright)\n                               s \\<and>\n                              alw (holds InvGlobalInfoAtBetaUpright)\n                               s \\<and>\n                              alw (\\<lambda>s.\nnext_performop s \\<or>\nnext_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n                               s) \\<or>\n                          alw (\\<lambda>s.\n                                  \\<forall>q t.\n                                     GlobVacantUpto (shd s) q\nt \\<longrightarrow>\n                                     alw\n(holds (\\<lambda>c. GlobVacantUpto c q t)) s)\n                           (stl xs))", "apply (rule exI[of _ s])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n     alw (holds InvGlobalRecordCount) s;\n     alw (holds InvGlobalIncomingInfoUpright) s;\n     alw (holds InvGlobalInfoAtBetaUpright) s;\n     alw (\\<lambda>s.\n             next_performop s \\<or>\n             next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n      s\\<rbrakk>\n    \\<Longrightarrow> s = s \\<and>\n                      (\\<forall>q t.\n                          GlobVacantUpto (shd s) q t \\<longrightarrow>\n                          alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                           s) \\<and>\n                      ((\\<exists>s.\n                           stl s = s \\<and>\n                           alw (holds InvGlobVacantUptoImpliesNrec) s \\<and>\n                           alw (holds InvGlobalRecordCount) s \\<and>\n                           alw (holds InvGlobalIncomingInfoUpright) s \\<and>\n                           alw (holds InvGlobalInfoAtBetaUpright) s \\<and>\n                           alw (\\<lambda>s.\n                                   next_performop s \\<or>\n                                   next_sendupd s \\<or>\n                                   next_recvupd s \\<or> shd (stl s) = shd s)\n                            s) \\<or>\n                       alw (\\<lambda>s.\n                               \\<forall>q t.\n                                  GlobVacantUpto (shd s) q\n                                   t \\<longrightarrow>\n                                  alw (holds\n  (\\<lambda>c. GlobVacantUpto c q t))\n                                   s)\n                        (stl s))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q t.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t\\<rbrakk>\n       \\<Longrightarrow> alw (holds (\\<lambda>c. GlobVacantUpto c q t)) s\n 2. \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n     alw (holds InvGlobalRecordCount) s;\n     alw (holds InvGlobalIncomingInfoUpright) s;\n     alw (holds InvGlobalInfoAtBetaUpright) s;\n     alw (\\<lambda>s.\n             next_performop s \\<or>\n             next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n      s;\n     \\<not> alw (\\<lambda>s.\n                    \\<forall>q t.\n                       GlobVacantUpto (shd s) q t \\<longrightarrow>\n                       alw (holds (\\<lambda>c. GlobVacantUpto c q t)) s)\n             (stl s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s.\n                         stl s = s \\<and>\n                         alw (holds InvGlobVacantUptoImpliesNrec) s \\<and>\n                         alw (holds InvGlobalRecordCount) s \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright) s \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright) s \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          s", "subgoal for q t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n     alw (holds InvGlobalRecordCount) s;\n     alw (holds InvGlobalIncomingInfoUpright) s;\n     alw (holds InvGlobalInfoAtBetaUpright) s;\n     alw (\\<lambda>s.\n             next_performop s \\<or>\n             next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n      s;\n     GlobVacantUpto (shd s) q t\\<rbrakk>\n    \\<Longrightarrow> alw (holds (\\<lambda>c. GlobVacantUpto c q t)) s", "apply (coinduction arbitrary: s rule: alw.coinduct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            s = xs \\<and>\n                            holds (\\<lambda>c. GlobVacantUpto c q t)\n                             xs \\<and>\n                            ((\\<exists>s.\n                                 stl xs = s \\<and>\n                                 alw (holds InvGlobVacantUptoImpliesNrec)\n                                  s \\<and>\n                                 alw (holds InvGlobalRecordCount) s \\<and>\n                                 alw (holds InvGlobalIncomingInfoUpright)\n                                  s \\<and>\n                                 alw (holds InvGlobalInfoAtBetaUpright)\n                                  s \\<and>\n                                 alw (\\<lambda>s.\n   next_performop s \\<or>\n   next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n                                  s \\<and>\n                                 GlobVacantUpto (shd s) q t) \\<or>\n                             alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                              (stl xs))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobVacantUptoImpliesNrec)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalRecordCount) (stl s) \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright)\n                          (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         GlobVacantUpto (shd (stl s)) q t", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobVacantUptoImpliesNrec) (stl s)\n 2. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobalRecordCount) (stl s) \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright)\n                          (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         GlobVacantUpto (shd (stl s)) q t", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobalRecordCount) (stl s) \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright)\n                          (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         GlobVacantUpto (shd (stl s)) q t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobalRecordCount) (stl s) \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright)\n                          (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         GlobVacantUpto (shd (stl s)) q t", "fix sb :: \"('a, 'b) configuration stream\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobalRecordCount) (stl s) \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright)\n                          (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         GlobVacantUpto (shd (stl s)) q t", "assume a1: \"alw (holds InvGlobVacantUptoImpliesNrec) sb\""], ["proof (state)\nthis:\n  alw (holds InvGlobVacantUptoImpliesNrec) sb\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobalRecordCount) (stl s) \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright)\n                          (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         GlobVacantUpto (shd (stl s)) q t", "assume a2: \"alw (holds InvGlobalRecordCount) sb\""], ["proof (state)\nthis:\n  alw (holds InvGlobalRecordCount) sb\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobalRecordCount) (stl s) \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright)\n                          (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         GlobVacantUpto (shd (stl s)) q t", "assume a3: \"alw (holds InvGlobalIncomingInfoUpright) sb\""], ["proof (state)\nthis:\n  alw (holds InvGlobalIncomingInfoUpright) sb\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobalRecordCount) (stl s) \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright)\n                          (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         GlobVacantUpto (shd (stl s)) q t", "assume a4: \"alw (holds InvGlobalInfoAtBetaUpright) sb\""], ["proof (state)\nthis:\n  alw (holds InvGlobalInfoAtBetaUpright) sb\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobalRecordCount) (stl s) \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright)\n                          (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         GlobVacantUpto (shd (stl s)) q t", "assume a5: \"alw (\\<lambda>s. next_performop s \\<or> next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s) sb\""], ["proof (state)\nthis:\n  alw (\\<lambda>s.\n          next_performop s \\<or>\n          next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n   sb\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobalRecordCount) (stl s) \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright)\n                          (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         GlobVacantUpto (shd (stl s)) q t", "assume a6: \"GlobVacantUpto (shd sb) q t\""], ["proof (state)\nthis:\n  GlobVacantUpto (shd sb) q t\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobalRecordCount) (stl s) \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright)\n                          (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         GlobVacantUpto (shd (stl s)) q t", "have \"next_performop sb \\<or> next_sendupd sb \\<or> next_recvupd sb \\<or> shd (stl sb) = shd sb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next_performop sb \\<or>\n    next_sendupd sb \\<or> next_recvupd sb \\<or> shd (stl sb) = shd sb", "using a5"], ["proof (prove)\nusing this:\n  alw (\\<lambda>s.\n          next_performop s \\<or>\n          next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n   sb\n\ngoal (1 subgoal):\n 1. next_performop sb \\<or>\n    next_sendupd sb \\<or> next_recvupd sb \\<or> shd (stl sb) = shd sb", "by blast"], ["proof (state)\nthis:\n  next_performop sb \\<or>\n  next_sendupd sb \\<or> next_recvupd sb \\<or> shd (stl sb) = shd sb\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobalRecordCount) (stl s) \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright)\n                          (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         GlobVacantUpto (shd (stl s)) q t", "then"], ["proof (chain)\npicking this:\n  next_performop sb \\<or>\n  next_sendupd sb \\<or> next_recvupd sb \\<or> shd (stl sb) = shd sb", "have \"GlobVacantUpto (shd (stl sb)) q t\""], ["proof (prove)\nusing this:\n  next_performop sb \\<or>\n  next_sendupd sb \\<or> next_recvupd sb \\<or> shd (stl sb) = shd sb\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl sb)) q t", "using a6 a4 a3 a2 a1"], ["proof (prove)\nusing this:\n  next_performop sb \\<or>\n  next_sendupd sb \\<or> next_recvupd sb \\<or> shd (stl sb) = shd sb\n  GlobVacantUpto (shd sb) q t\n  alw (holds InvGlobalInfoAtBetaUpright) sb\n  alw (holds InvGlobalIncomingInfoUpright) sb\n  alw (holds InvGlobalRecordCount) sb\n  alw (holds InvGlobVacantUptoImpliesNrec) sb\n\ngoal (1 subgoal):\n 1. GlobVacantUpto (shd (stl sb)) q t", "by (metis (no_types) alwD gvut1 gvut2 gvut3 holds.elims(2))"], ["proof (state)\nthis:\n  GlobVacantUpto (shd (stl sb)) q t\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n        alw (holds InvGlobalRecordCount) s;\n        alw (holds InvGlobalIncomingInfoUpright) s;\n        alw (holds InvGlobalInfoAtBetaUpright) s;\n        alw (\\<lambda>s.\n                next_performop s \\<or>\n                next_sendupd s \\<or>\n                next_recvupd s \\<or> shd (stl s) = shd s)\n         s;\n        GlobVacantUpto (shd s) q t;\n        \\<not> alw (holds (\\<lambda>c. GlobVacantUpto c q t))\n                (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds InvGlobalRecordCount) (stl s) \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright)\n                          (stl s) \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright)\n                          (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          (stl s) \\<and>\n                         GlobVacantUpto (shd (stl s)) q t", "then"], ["proof (chain)\npicking this:\n  GlobVacantUpto (shd (stl sb)) q t", "show \"alw (holds InvGlobalRecordCount) (stl sb) \\<and> alw (holds InvGlobalIncomingInfoUpright) (stl sb) \\<and> alw (holds InvGlobalInfoAtBetaUpright) (stl sb) \\<and> alw (\\<lambda>s. next_performop s \\<or> next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s) (stl sb) \\<and> GlobVacantUpto (shd (stl sb)) q t\""], ["proof (prove)\nusing this:\n  GlobVacantUpto (shd (stl sb)) q t\n\ngoal (1 subgoal):\n 1. alw (holds InvGlobalRecordCount) (stl sb) \\<and>\n    alw (holds InvGlobalIncomingInfoUpright) (stl sb) \\<and>\n    alw (holds InvGlobalInfoAtBetaUpright) (stl sb) \\<and>\n    alw (\\<lambda>s.\n            next_performop s \\<or>\n            next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n     (stl sb) \\<and>\n    GlobVacantUpto (shd (stl sb)) q t", "using a5 a4 a3 a2"], ["proof (prove)\nusing this:\n  GlobVacantUpto (shd (stl sb)) q t\n  alw (\\<lambda>s.\n          next_performop s \\<or>\n          next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n   sb\n  alw (holds InvGlobalInfoAtBetaUpright) sb\n  alw (holds InvGlobalIncomingInfoUpright) sb\n  alw (holds InvGlobalRecordCount) sb\n\ngoal (1 subgoal):\n 1. alw (holds InvGlobalRecordCount) (stl sb) \\<and>\n    alw (holds InvGlobalIncomingInfoUpright) (stl sb) \\<and>\n    alw (holds InvGlobalInfoAtBetaUpright) (stl sb) \\<and>\n    alw (\\<lambda>s.\n            next_performop s \\<or>\n            next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n     (stl sb) \\<and>\n    GlobVacantUpto (shd (stl sb)) q t", "by blast"], ["proof (state)\nthis:\n  alw (holds InvGlobalRecordCount) (stl sb) \\<and>\n  alw (holds InvGlobalIncomingInfoUpright) (stl sb) \\<and>\n  alw (holds InvGlobalInfoAtBetaUpright) (stl sb) \\<and>\n  alw (\\<lambda>s.\n          next_performop s \\<or>\n          next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n   (stl sb) \\<and>\n  GlobVacantUpto (shd (stl sb)) q t\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (holds InvGlobVacantUptoImpliesNrec) s;\n     alw (holds InvGlobalRecordCount) s;\n     alw (holds InvGlobalIncomingInfoUpright) s;\n     alw (holds InvGlobalInfoAtBetaUpright) s;\n     alw (\\<lambda>s.\n             next_performop s \\<or>\n             next_sendupd s \\<or> next_recvupd s \\<or> shd (stl s) = shd s)\n      s;\n     \\<not> alw (\\<lambda>s.\n                    \\<forall>q t.\n                       GlobVacantUpto (shd s) q t \\<longrightarrow>\n                       alw (holds (\\<lambda>c. GlobVacantUpto c q t)) s)\n             (stl s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s.\n                         stl s = s \\<and>\n                         alw (holds InvGlobVacantUptoImpliesNrec) s \\<and>\n                         alw (holds InvGlobalRecordCount) s \\<and>\n                         alw (holds InvGlobalIncomingInfoUpright) s \\<and>\n                         alw (holds InvGlobalInfoAtBetaUpright) s \\<and>\n                         alw (\\<lambda>s.\n                                 next_performop s \\<or>\n                                 next_sendupd s \\<or>\n                                 next_recvupd s \\<or> shd (stl s) = shd s)\n                          s", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma spec_imp_SafeStickyGlobVacantUpto: \"spec s \\<Longrightarrow> alw SafeStickyGlobVacantUpto s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw SafeStickyGlobVacantUpto s", "apply (rule spec_imp_SafeStickyGlobVacantUpto_aux)"], ["proof (prove)\ngoal (5 subgoals):\n 1. spec s \\<Longrightarrow> alw (holds InvGlobVacantUptoImpliesNrec) s\n 2. spec s \\<Longrightarrow> alw (holds InvGlobalRecordCount) s\n 3. spec s \\<Longrightarrow> alw (holds InvGlobalIncomingInfoUpright) s\n 4. spec s \\<Longrightarrow> alw (holds InvGlobalInfoAtBetaUpright) s\n 5. spec s \\<Longrightarrow> alw next s", "apply (simp add: spec_imp_inv1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. spec s \\<Longrightarrow> alw (holds InvGlobalRecordCount) s\n 2. spec s \\<Longrightarrow> alw (holds InvGlobalIncomingInfoUpright) s\n 3. spec s \\<Longrightarrow> alw (holds InvGlobalInfoAtBetaUpright) s\n 4. spec s \\<Longrightarrow> alw next s", "apply (simp add: alw_InvGlobalRecordCount)"], ["proof (prove)\ngoal (3 subgoals):\n 1. spec s \\<Longrightarrow> alw (holds InvGlobalIncomingInfoUpright) s\n 2. spec s \\<Longrightarrow> alw (holds InvGlobalInfoAtBetaUpright) s\n 3. spec s \\<Longrightarrow> alw next s", "apply (simp add: alw_InvGlobalIncomingInfoUpright)"], ["proof (prove)\ngoal (2 subgoals):\n 1. spec s \\<Longrightarrow> alw (holds InvGlobalInfoAtBetaUpright) s\n 2. spec s \\<Longrightarrow> alw next s", "apply (simp add: alw_InvGlobalInfoAtBetaUpright)"], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw next s", "apply (simp add: spec_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition SafeGlobMono where\n  \"SafeGlobMono c0 c1 = (\\<forall>p t. GlobVacantUpto c0 p t \\<longrightarrow> GlobVacantUpto c1 p t)\""], ["", "lemma alw_SafeGlobMono: \"spec s \\<Longrightarrow> alw (relates SafeGlobMono) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (relates SafeGlobMono) s", "apply (drule spec_imp_SafeStickyGlobVacantUpto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw SafeStickyGlobVacantUpto s \\<Longrightarrow>\n    alw (relates SafeGlobMono) s", "apply (erule alw_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       SafeStickyGlobVacantUpto xs \\<Longrightarrow> relates SafeGlobMono xs", "apply (fastforce simp: SafeStickyGlobVacantUpto_def SafeGlobMono_def relates_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}