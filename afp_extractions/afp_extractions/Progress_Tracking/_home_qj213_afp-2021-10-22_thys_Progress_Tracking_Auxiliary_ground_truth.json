{"file_name": "/home/qj213/afp-2021-10-22/thys/Progress_Tracking/Auxiliary.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Progress_Tracking", "problem_names": ["lemma sum_list_hd_tl:\n  fixes xs :: \"(_ :: group_add) list\"\n  shows \"xs \\<noteq> [] \\<Longrightarrow> sum_list (tl xs) = (- hd xs) + sum_list xs\"", "lemma finite_distinct_bounded: \"finite A \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs \\<subseteq> A}\"", "lemma Sum_eq_pick_changed_elem:\n  assumes \"finite M\"\n    and \"m \\<in> M\" \"f m = g m + \\<Delta>\"\n    and \"\\<And>n. n \\<noteq> m \\<and> n \\<in> M \\<Longrightarrow> f n = g n\"\n  shows \"(\\<Sum>x\\<in>M. f x) = (\\<Sum>x\\<in>M. g x) + \\<Delta>\"", "lemma sum_pos_ex_elem_pos: \"(0::int) < (\\<Sum>m\\<in>M. f m) \\<Longrightarrow> \\<exists>m\\<in>M. 0 < f m\"", "lemma sum_if_distrib_add: \"finite A \\<Longrightarrow> b \\<in> A \\<Longrightarrow> (\\<Sum>a\\<in>A. if a=b then X b + Y a else X a) = (\\<Sum>a\\<in>A. X a) + Y b\"", "lemma (in order) order_finite_set_exists_foundation:\n  fixes   t :: 'a\n  assumes \"finite M\"\n    and   \"t \\<in> M\"\n  shows   \"\\<exists>s\\<in>M. s \\<le> t \\<and> (\\<forall>u\\<in>M. \\<not> u < s)\"", "lemma order_finite_set_obtain_foundation:\n  fixes   t :: \"_ :: order\"\n  assumes \"finite M\"\n    and   \"t \\<in> M\"\n  obtains s where \"s \\<in> M\" \"s \\<le> t\" \"\\<forall>u\\<in>M. \\<not> u < s\"", "lemma finite_nonzero_count: \"finite {t. count M t > 0}\"", "lemma finite_count[simp]: \"finite {t. count M t > i}\"", "lemma zcount_zmset_of_nonneg[simp]: \"0 \\<le> zcount (zmset_of M) t\"", "lemma finite_zcount_pos[simp]: \"finite {t. zcount M t > 0}\"", "lemma finite_zcount_neg[simp]: \"finite {t. zcount M t < 0}\"", "lemma pos_zcount_in_zmset: \"0 < zcount M x \\<Longrightarrow> x \\<in>#\\<^sub>z M\"", "lemma zmset_elem_nonneg: \"x \\<in>#\\<^sub>z M \\<Longrightarrow> (\\<And>x. x \\<in>#\\<^sub>z M \\<Longrightarrow> 0 \\<le> zcount M x) \\<Longrightarrow> 0 < zcount M x\"", "lemma zero_le_sum_single: \"0 \\<le> zcount (\\<Sum>x\\<in>M. {#f x#}\\<^sub>z) t\"", "lemma mem_zmset_of[simp]: \"x \\<in>#\\<^sub>z zmset_of M \\<longleftrightarrow> x \\<in># M\"", "lemma mset_neg_minus: \"mset_neg (abs_zmultiset (Mp,Mn)) = Mn-Mp\"", "lemma mset_pos_minus: \"mset_pos (abs_zmultiset (Mp,Mn)) = Mp-Mn\"", "lemma mset_neg_sum_set: \"(\\<And>m. m \\<in> M \\<Longrightarrow> mset_neg (f m) = {#}) \\<Longrightarrow> mset_neg (\\<Sum>m\\<in>M. f m) = {#}\"", "lemma mset_neg_empty_iff: \"mset_neg M = {#} \\<longleftrightarrow> (\\<forall>t. 0 \\<le> zcount M t)\"", "lemma mset_neg_zcount_nonneg: \"mset_neg M = {#} \\<Longrightarrow> 0 \\<le> zcount M t\"", "lemma in_zmset_conv_pos_neg_disj: \"x \\<in>#\\<^sub>z M \\<longleftrightarrow> x \\<in># mset_pos M \\<or> x \\<in># mset_neg M\"", "lemma in_zmset_notin_mset_pos[simp]: \"x \\<in>#\\<^sub>z M \\<Longrightarrow> x \\<notin># mset_pos M \\<Longrightarrow> x \\<in># mset_neg M\"", "lemma in_zmset_notin_mset_neg[simp]: \"x \\<in>#\\<^sub>z M \\<Longrightarrow> x \\<notin># mset_neg M \\<Longrightarrow> x \\<in># mset_pos M\"", "lemma in_mset_pos_in_zmset: \"x \\<in># mset_pos M \\<Longrightarrow> x \\<in>#\\<^sub>z M\"", "lemma in_mset_neg_in_zmset: \"x \\<in># mset_neg M \\<Longrightarrow> x \\<in>#\\<^sub>z M\"", "lemma set_zmset_eq_set_mset_union: \"set_zmset M = set_mset (mset_pos M) \\<union> set_mset (mset_neg M)\"", "lemma member_mset_pos_iff_zcount: \"x \\<in># mset_pos M \\<longleftrightarrow> 0 < zcount M x\"", "lemma member_mset_neg_iff_zcount: \"x \\<in># mset_neg M \\<longleftrightarrow> zcount M x < 0\"", "lemma mset_pos_mset_neg_disjoint[simp]: \"set_mset (mset_pos \\<Delta>) \\<inter> set_mset (mset_neg \\<Delta>) = {}\"", "lemma zcount_sum: \"zcount (\\<Sum>M\\<in>MM. f M) t = (\\<Sum>M\\<in>MM. zcount (f M) t)\"", "lemma zcount_filter_invariant: \"zcount {# t'\\<in>#\\<^sub>zM. t'=t #} t = zcount M t\"", "lemma in_filter_zmset_in_zmset[simp]: \"x \\<in>#\\<^sub>z filter_zmset P M \\<Longrightarrow> x \\<in>#\\<^sub>z M\"", "lemma pos_filter_zmset_pos_zmset[simp]: \"0 < zcount (filter_zmset P M) x \\<Longrightarrow> 0 < zcount M x\"", "lemma neg_filter_zmset_neg_zmset[simp]: \"0 > zcount (filter_zmset P M) x \\<Longrightarrow> 0 > zcount M x\"", "lemma zcount_update_zmultiset: \"zcount (update_zmultiset M t n) t' = zcount M t' + (if t = t' then n else 0)\"", "lemma (in order) order_zmset_exists_foundation:\n  fixes   t :: 'a\n  assumes \"0 < zcount M t\"\n  shows   \"\\<exists>s. s \\<le> t \\<and> 0 < zcount M s \\<and> (\\<forall>u. 0 < zcount M u \\<longrightarrow> \\<not> u < s)\"", "lemma (in order) order_zmset_exists_foundation':\n  fixes   t :: 'a\n  assumes \"0 < zcount M t\"\n  shows   \"\\<exists>s. s \\<le> t \\<and> 0 < zcount M s \\<and> (\\<forall>u<s. zcount M u \\<le> 0)\"", "lemma (in order) order_zmset_exists_foundation_neg:\n  fixes   t :: 'a\n  assumes \"zcount M t < 0\"\n  shows   \"\\<exists>s. s \\<le> t \\<and> zcount M s < 0 \\<and> (\\<forall>u. zcount M u < 0 \\<longrightarrow> \\<not> u < s)\"", "lemma (in order) order_zmset_exists_foundation_neg':\n  fixes   t :: 'a\n  assumes \"zcount M t < 0\"\n  shows   \"\\<exists>s. s \\<le> t \\<and> zcount M s < 0 \\<and> (\\<forall>u<s. 0 \\<le> zcount M u)\"", "lemma (in order) elem_order_zmset_exists_foundation:\n  fixes x :: 'a\n  assumes \"x \\<in>#\\<^sub>z M\"\n  shows   \"\\<exists>s\\<in>#\\<^sub>zM. s \\<le> x \\<and> (\\<forall>u\\<in>#\\<^sub>zM. \\<not> u < s)\"", "lemma image_zmset_empty[simp]: \"image_zmset f {#}\\<^sub>z = {#}\\<^sub>z\"", "lemma image_zmset_single[simp]: \"image_zmset f {#x#}\\<^sub>z = {#f x#}\\<^sub>z\"", "lemma image_zmset_union[simp]: \"image_zmset f (M + N) = image_zmset f M + image_zmset f N\"", "lemma image_zmset_Diff[simp]: \"image_zmset f (A - B) = image_zmset f A - image_zmset f B\"", "lemma mset_neg_image_zmset: \"mset_neg M = {#} \\<Longrightarrow> mset_neg (image_zmset f M) = {#}\"", "lemma nonneg_zcount_image_zmset[simp]: \"(\\<And>t. 0 \\<le> zcount M t) \\<Longrightarrow> 0 \\<le> zcount (image_zmset f M) t\"", "lemma image_zmset_add_zmset[simp]: \"image_zmset f (add_zmset t M) = add_zmset (f t) (image_zmset f M)\"", "lemma pos_zcount_image_zmset[simp]: \"(\\<And>t. 0 \\<le> zcount M t) \\<Longrightarrow> 0 < zcount M t \\<Longrightarrow> 0 < zcount (image_zmset f M) (f t)\"", "lemma set_zmset_transfer[transfer_rule]:\n  \"(rel_fun (pcr_zmultiset (=)) (rel_set (=)))\n   (\\<lambda>(Mp, Mn). set_mset Mp \\<union> set_mset Mn - {x. count Mp x = count Mn x}) set_zmset\"", "lemma zcount_image_zmset:\n  \"zcount (image_zmset f M) x = (\\<Sum>y \\<in> f -` {x} \\<inter> set_zmset M. zcount M y)\"", "lemma zmset_empty_image_zmset_empty: \"(\\<And>t. zcount M t = 0) \\<Longrightarrow> zcount (image_zmset f M) t = 0\"", "lemma in_image_zmset_in_zmset: \"t \\<in>#\\<^sub>z image_zmset f M \\<Longrightarrow> \\<exists>t. t \\<in>#\\<^sub>z M\"", "lemma zcount_image_zmset_zero: \"(\\<And>m. m \\<in>#\\<^sub>z M \\<Longrightarrow> f m \\<noteq> x) \\<Longrightarrow> x \\<notin>#\\<^sub>z image_zmset f M\"", "lemma image_zmset_pre: \"t \\<in>#\\<^sub>z image_zmset f M \\<Longrightarrow> \\<exists>m. m \\<in>#\\<^sub>z M \\<and> f m = t\"", "lemma pos_image_zmset_obtain_pre:\n  \"(\\<And>t. 0 \\<le> zcount M t) \\<Longrightarrow> 0 < zcount (image_zmset f M) t \\<Longrightarrow> \\<exists>m. 0 < zcount M m \\<and> f m = t\"", "lemma relatesD[dest]: \"relates P s \\<Longrightarrow> P (shd s) (shd (stl s))\"", "lemma alw_relatesD[dest]: \"alw (relates P) s \\<Longrightarrow> P (shd s) (shd (stl s))\"", "lemma relatesI[intro]: \"P (shd s) (shd (stl s)) \\<Longrightarrow> relates P s\"", "lemma alw_holds_smap_conv_comp: \"alw (holds P) (smap f s) = alw (\\<lambda>s. (P o f) (shd s)) s\"", "lemma alw_relates: \"alw (relates P) s \\<longleftrightarrow> P (shd s) (shd (stl s)) \\<and> alw (relates P) (stl s)\""], "translations": [["", "lemma sum_list_hd_tl:\n  fixes xs :: \"(_ :: group_add) list\"\n  shows \"xs \\<noteq> [] \\<Longrightarrow> sum_list (tl xs) = (- hd xs) + sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (tl xs) = - hd xs + sum_list xs", "by (cases xs) simp_all"], ["", "lemma finite_distinct_bounded: \"finite A \\<Longrightarrow> finite {xs. distinct xs \\<and> set xs \\<subseteq> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    finite {xs. distinct xs \\<and> set xs \\<subseteq> A}", "apply (rule finite_subset[of _ \"\\<Union>n \\<in> {0 .. card A}. {xs.  length xs = n \\<and> distinct xs \\<and> set xs \\<subseteq> A}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    {xs. distinct xs \\<and> set xs \\<subseteq> A}\n    \\<subseteq> (\\<Union>n\\<in>{0..card A}.\n                    {xs.\n                     length xs = n \\<and>\n                     distinct xs \\<and> set xs \\<subseteq> A})\n 2. finite A \\<Longrightarrow>\n    finite\n     (\\<Union>n\\<in>{0..card A}.\n         {xs. length xs = n \\<and> distinct xs \\<and> set xs \\<subseteq> A})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    {xs. distinct xs \\<and> set xs \\<subseteq> A}\n    \\<subseteq> (\\<Union>n\\<in>{0..card A}.\n                    {xs.\n                     length xs = n \\<and>\n                     distinct xs \\<and> set xs \\<subseteq> A})", "by clarsimp (metis card_mono distinct_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    finite\n     (\\<Union>n\\<in>{0..card A}.\n         {xs. length xs = n \\<and> distinct xs \\<and> set xs \\<subseteq> A})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    finite\n     (\\<Union>n\\<in>{0..card A}.\n         {xs. length xs = n \\<and> distinct xs \\<and> set xs \\<subseteq> A})", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Sums\\<close>"], ["", "lemma Sum_eq_pick_changed_elem:\n  assumes \"finite M\"\n    and \"m \\<in> M\" \"f m = g m + \\<Delta>\"\n    and \"\\<And>n. n \\<noteq> m \\<and> n \\<in> M \\<Longrightarrow> f n = g n\"\n  shows \"(\\<Sum>x\\<in>M. f x) = (\\<Sum>x\\<in>M. g x) + \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f M = sum g M + \\<Delta>", "using assms"], ["proof (prove)\nusing this:\n  finite M\n  m \\<in> M\n  f m = g m + \\<Delta>\n  ?n \\<noteq> m \\<and> ?n \\<in> M \\<Longrightarrow> f ?n = g ?n\n\ngoal (1 subgoal):\n 1. sum f M = sum g M + \\<Delta>", "proof (induct M arbitrary: m rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> {}; f m = g m + \\<Delta>;\n        \\<And>n.\n           n \\<noteq> m \\<and> n \\<in> {} \\<Longrightarrow>\n           f n = g n\\<rbrakk>\n       \\<Longrightarrow> sum f {} = sum g {} + \\<Delta>\n 2. \\<And>x F m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>m.\n           \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n            \\<And>n.\n               n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n               f n = g n\\<rbrakk>\n           \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n        m \\<in> insert x F; f m = g m + \\<Delta>;\n        \\<And>n.\n           n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow>\n           f n = g n\\<rbrakk>\n       \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>", "case empty"], ["proof (state)\nthis:\n  m \\<in> {}\n  f m = g m + \\<Delta>\n  ?n \\<noteq> m \\<and> ?n \\<in> {} \\<Longrightarrow> f ?n = g ?n\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> {}; f m = g m + \\<Delta>;\n        \\<And>n.\n           n \\<noteq> m \\<and> n \\<in> {} \\<Longrightarrow>\n           f n = g n\\<rbrakk>\n       \\<Longrightarrow> sum f {} = sum g {} + \\<Delta>\n 2. \\<And>x F m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>m.\n           \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n            \\<And>n.\n               n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n               f n = g n\\<rbrakk>\n           \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n        m \\<in> insert x F; f m = g m + \\<Delta>;\n        \\<And>n.\n           n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow>\n           f n = g n\\<rbrakk>\n       \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>", "then"], ["proof (chain)\npicking this:\n  m \\<in> {}\n  f m = g m + \\<Delta>\n  ?n \\<noteq> m \\<and> ?n \\<in> {} \\<Longrightarrow> f ?n = g ?n", "show ?case"], ["proof (prove)\nusing this:\n  m \\<in> {}\n  f m = g m + \\<Delta>\n  ?n \\<noteq> m \\<and> ?n \\<in> {} \\<Longrightarrow> f ?n = g ?n\n\ngoal (1 subgoal):\n 1. sum f {} = sum g {} + \\<Delta>", "by simp"], ["proof (state)\nthis:\n  sum f {} = sum g {} + \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x F m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>m.\n           \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n            \\<And>n.\n               n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n               f n = g n\\<rbrakk>\n           \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n        m \\<in> insert x F; f m = g m + \\<Delta>;\n        \\<And>n.\n           n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow>\n           f n = g n\\<rbrakk>\n       \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>m.\n           \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n            \\<And>n.\n               n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n               f n = g n\\<rbrakk>\n           \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n        m \\<in> insert x F; f m = g m + \\<Delta>;\n        \\<And>n.\n           n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow>\n           f n = g n\\<rbrakk>\n       \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>?m \\<in> F; f ?m = g ?m + \\<Delta>;\n   \\<And>n.\n      n \\<noteq> ?m \\<and> n \\<in> F \\<Longrightarrow> f n = g n\\<rbrakk>\n  \\<Longrightarrow> sum f F = sum g F + \\<Delta>\n  m \\<in> insert x F\n  f m = g m + \\<Delta>\n  ?n \\<noteq> m \\<and> ?n \\<in> insert x F \\<Longrightarrow> f ?n = g ?n\n\ngoal (1 subgoal):\n 1. \\<And>x F m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>m.\n           \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n            \\<And>n.\n               n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n               f n = g n\\<rbrakk>\n           \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n        m \\<in> insert x F; f m = g m + \\<Delta>;\n        \\<And>n.\n           n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow>\n           f n = g n\\<rbrakk>\n       \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>", "then"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>?m \\<in> F; f ?m = g ?m + \\<Delta>;\n   \\<And>n.\n      n \\<noteq> ?m \\<and> n \\<in> F \\<Longrightarrow> f n = g n\\<rbrakk>\n  \\<Longrightarrow> sum f F = sum g F + \\<Delta>\n  m \\<in> insert x F\n  f m = g m + \\<Delta>\n  ?n \\<noteq> m \\<and> ?n \\<in> insert x F \\<Longrightarrow> f ?n = g ?n", "show ?case"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>?m \\<in> F; f ?m = g ?m + \\<Delta>;\n   \\<And>n.\n      n \\<noteq> ?m \\<and> n \\<in> F \\<Longrightarrow> f n = g n\\<rbrakk>\n  \\<Longrightarrow> sum f F = sum g F + \\<Delta>\n  m \\<in> insert x F\n  f m = g m + \\<Delta>\n  ?n \\<noteq> m \\<and> ?n \\<in> insert x F \\<Longrightarrow> f ?n = g ?n\n\ngoal (1 subgoal):\n 1. sum f (insert x F) = sum g (insert x F) + \\<Delta>", "proof (cases \"x=m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite F; x \\<notin> F;\n     \\<And>m.\n        \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n         \\<And>n.\n            n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n            f n = g n\\<rbrakk>\n        \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n     m \\<in> insert x F; f m = g m + \\<Delta>;\n     \\<And>n.\n        n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow> f n = g n;\n     x = m\\<rbrakk>\n    \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>\n 2. \\<lbrakk>finite F; x \\<notin> F;\n     \\<And>m.\n        \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n         \\<And>n.\n            n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n            f n = g n\\<rbrakk>\n        \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n     m \\<in> insert x F; f m = g m + \\<Delta>;\n     \\<And>n.\n        n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow> f n = g n;\n     x \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>", "case True"], ["proof (state)\nthis:\n  x = m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite F; x \\<notin> F;\n     \\<And>m.\n        \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n         \\<And>n.\n            n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n            f n = g n\\<rbrakk>\n        \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n     m \\<in> insert x F; f m = g m + \\<Delta>;\n     \\<And>n.\n        n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow> f n = g n;\n     x = m\\<rbrakk>\n    \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>\n 2. \\<lbrakk>finite F; x \\<notin> F;\n     \\<And>m.\n        \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n         \\<And>n.\n            n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n            f n = g n\\<rbrakk>\n        \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n     m \\<in> insert x F; f m = g m + \\<Delta>;\n     \\<And>n.\n        n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow> f n = g n;\n     x \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>", "with insert"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>?m \\<in> F; f ?m = g ?m + \\<Delta>;\n   \\<And>n.\n      n \\<noteq> ?m \\<and> n \\<in> F \\<Longrightarrow> f n = g n\\<rbrakk>\n  \\<Longrightarrow> sum f F = sum g F + \\<Delta>\n  m \\<in> insert x F\n  f m = g m + \\<Delta>\n  ?n \\<noteq> m \\<and> ?n \\<in> insert x F \\<Longrightarrow> f ?n = g ?n\n  x = m", "have \"sum f F = sum g F\""], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>?m \\<in> F; f ?m = g ?m + \\<Delta>;\n   \\<And>n.\n      n \\<noteq> ?m \\<and> n \\<in> F \\<Longrightarrow> f n = g n\\<rbrakk>\n  \\<Longrightarrow> sum f F = sum g F + \\<Delta>\n  m \\<in> insert x F\n  f m = g m + \\<Delta>\n  ?n \\<noteq> m \\<and> ?n \\<in> insert x F \\<Longrightarrow> f ?n = g ?n\n  x = m\n\ngoal (1 subgoal):\n 1. sum f F = sum g F", "by (intro sum.cong[OF refl]) force"], ["proof (state)\nthis:\n  sum f F = sum g F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite F; x \\<notin> F;\n     \\<And>m.\n        \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n         \\<And>n.\n            n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n            f n = g n\\<rbrakk>\n        \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n     m \\<in> insert x F; f m = g m + \\<Delta>;\n     \\<And>n.\n        n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow> f n = g n;\n     x = m\\<rbrakk>\n    \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>\n 2. \\<lbrakk>finite F; x \\<notin> F;\n     \\<And>m.\n        \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n         \\<And>n.\n            n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n            f n = g n\\<rbrakk>\n        \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n     m \\<in> insert x F; f m = g m + \\<Delta>;\n     \\<And>n.\n        n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow> f n = g n;\n     x \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>", "with insert True"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>?m \\<in> F; f ?m = g ?m + \\<Delta>;\n   \\<And>n.\n      n \\<noteq> ?m \\<and> n \\<in> F \\<Longrightarrow> f n = g n\\<rbrakk>\n  \\<Longrightarrow> sum f F = sum g F + \\<Delta>\n  m \\<in> insert x F\n  f m = g m + \\<Delta>\n  ?n \\<noteq> m \\<and> ?n \\<in> insert x F \\<Longrightarrow> f ?n = g ?n\n  x = m\n  sum f F = sum g F", "show ?thesis"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>?m \\<in> F; f ?m = g ?m + \\<Delta>;\n   \\<And>n.\n      n \\<noteq> ?m \\<and> n \\<in> F \\<Longrightarrow> f n = g n\\<rbrakk>\n  \\<Longrightarrow> sum f F = sum g F + \\<Delta>\n  m \\<in> insert x F\n  f m = g m + \\<Delta>\n  ?n \\<noteq> m \\<and> ?n \\<in> insert x F \\<Longrightarrow> f ?n = g ?n\n  x = m\n  sum f F = sum g F\n\ngoal (1 subgoal):\n 1. sum f (insert x F) = sum g (insert x F) + \\<Delta>", "by (auto simp: add.commute add.left_commute)"], ["proof (state)\nthis:\n  sum f (insert x F) = sum g (insert x F) + \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F; x \\<notin> F;\n     \\<And>m.\n        \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n         \\<And>n.\n            n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n            f n = g n\\<rbrakk>\n        \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n     m \\<in> insert x F; f m = g m + \\<Delta>;\n     \\<And>n.\n        n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow> f n = g n;\n     x \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F; x \\<notin> F;\n     \\<And>m.\n        \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n         \\<And>n.\n            n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n            f n = g n\\<rbrakk>\n        \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n     m \\<in> insert x F; f m = g m + \\<Delta>;\n     \\<And>n.\n        n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow> f n = g n;\n     x \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>", "case False"], ["proof (state)\nthis:\n  x \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F; x \\<notin> F;\n     \\<And>m.\n        \\<lbrakk>m \\<in> F; f m = g m + \\<Delta>;\n         \\<And>n.\n            n \\<noteq> m \\<and> n \\<in> F \\<Longrightarrow>\n            f n = g n\\<rbrakk>\n        \\<Longrightarrow> sum f F = sum g F + \\<Delta>;\n     m \\<in> insert x F; f m = g m + \\<Delta>;\n     \\<And>n.\n        n \\<noteq> m \\<and> n \\<in> insert x F \\<Longrightarrow> f n = g n;\n     x \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> sum f (insert x F) = sum g (insert x F) + \\<Delta>", "with insert"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>?m \\<in> F; f ?m = g ?m + \\<Delta>;\n   \\<And>n.\n      n \\<noteq> ?m \\<and> n \\<in> F \\<Longrightarrow> f n = g n\\<rbrakk>\n  \\<Longrightarrow> sum f F = sum g F + \\<Delta>\n  m \\<in> insert x F\n  f m = g m + \\<Delta>\n  ?n \\<noteq> m \\<and> ?n \\<in> insert x F \\<Longrightarrow> f ?n = g ?n\n  x \\<noteq> m", "show ?thesis"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>?m \\<in> F; f ?m = g ?m + \\<Delta>;\n   \\<And>n.\n      n \\<noteq> ?m \\<and> n \\<in> F \\<Longrightarrow> f n = g n\\<rbrakk>\n  \\<Longrightarrow> sum f F = sum g F + \\<Delta>\n  m \\<in> insert x F\n  f m = g m + \\<Delta>\n  ?n \\<noteq> m \\<and> ?n \\<in> insert x F \\<Longrightarrow> f ?n = g ?n\n  x \\<noteq> m\n\ngoal (1 subgoal):\n 1. sum f (insert x F) = sum g (insert x F) + \\<Delta>", "by (auto simp: add.assoc)"], ["proof (state)\nthis:\n  sum f (insert x F) = sum g (insert x F) + \\<Delta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum f (insert x F) = sum g (insert x F) + \\<Delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_pos_ex_elem_pos: \"(0::int) < (\\<Sum>m\\<in>M. f m) \\<Longrightarrow> \\<exists>m\\<in>M. 0 < f m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sum f M \\<Longrightarrow> \\<exists>m\\<in>M. 0 < f m", "by (meson not_le sum_nonpos)"], ["", "lemma sum_if_distrib_add: \"finite A \\<Longrightarrow> b \\<in> A \\<Longrightarrow> (\\<Sum>a\\<in>A. if a=b then X b + Y a else X a) = (\\<Sum>a\\<in>A. X a) + Y b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; b \\<in> A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>a\\<in>A. if a = b then X b + Y a else X a) =\n                      sum X A + Y b", "by (simp add: Sum_eq_pick_changed_elem)"], ["", "subsection\\<open>Partial Orders\\<close>"], ["", "lemma (in order) order_finite_set_exists_foundation:\n  fixes   t :: 'a\n  assumes \"finite M\"\n    and   \"t \\<in> M\"\n  shows   \"\\<exists>s\\<in>M. s \\<le> t \\<and> (\\<forall>u\\<in>M. \\<not> u < s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>M. s \\<le> t \\<and> (\\<forall>u\\<in>M. \\<not> u < s)", "using assms"], ["proof (prove)\nusing this:\n  finite M\n  t \\<in> M\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>M. s \\<le> t \\<and> (\\<forall>u\\<in>M. \\<not> u < s)", "by (simp add: dual_order.strict_iff_order finite_has_minimal2)"], ["", "lemma order_finite_set_obtain_foundation:\n  fixes   t :: \"_ :: order\"\n  assumes \"finite M\"\n    and   \"t \\<in> M\"\n  obtains s where \"s \\<in> M\" \"s \\<le> t\" \"\\<forall>u\\<in>M. \\<not> u < s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> M; s \\<le> t;\n         \\<forall>u\\<in>M. \\<not> u < s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms order_finite_set_exists_foundation"], ["proof (prove)\nusing this:\n  finite M\n  t \\<in> M\n  \\<lbrakk>finite ?M; ?t \\<in> ?M\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s\\<in>?M.\n                       s \\<le> ?t \\<and> (\\<forall>u\\<in>?M. \\<not> u < s)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> M; s \\<le> t;\n         \\<forall>u\\<in>M. \\<not> u < s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "subsection\\<open>Multisets\\<close>"], ["", "lemma finite_nonzero_count: \"finite {t. count M t > 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. 0 < count M t}", "using count"], ["proof (prove)\nusing this:\n  count ?x \\<in> multiset\n\ngoal (1 subgoal):\n 1. finite {t. 0 < count M t}", "unfolding multiset_def"], ["proof (prove)\nusing this:\n  count ?x \\<in> {f. finite {x. 0 < f x}}\n\ngoal (1 subgoal):\n 1. finite {t. 0 < count M t}", "by auto"], ["", "lemma finite_count[simp]: \"finite {t. count M t > i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. i < count M t}", "by (rule finite_subset[OF _ finite_nonzero_count[of M]]) (auto simp only: set_mset_def)"], ["", "subsection\\<open>Signed Multisets\\<close>"], ["", "lemma zcount_zmset_of_nonneg[simp]: \"0 \\<le> zcount (zmset_of M) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> zcount (zmset_of M) t", "by simp"], ["", "lemma finite_zcount_pos[simp]: \"finite {t. zcount M t > 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. 0 < zcount M t}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       finite\n        {t. 0 < (case M of\n                 (Mp, Mn) \\<Rightarrow>\n                   \\<lambda>x. int (count Mp x) - int (count Mn x))\n                 t}", "subgoal for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. 0 < (case M of\n              (Mp, Mn) \\<Rightarrow>\n                \\<lambda>x. int (count Mp x) - int (count Mn x))\n              t}", "apply (rule finite_subset[OF _ finite_Un[THEN iffD2, OF conjI[OF finite_nonzero_count finite_nonzero_count]], of _ \"fst M\" \"snd M\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. 0 < (case M of\n             (Mp, Mn) \\<Rightarrow>\n               \\<lambda>x. int (count Mp x) - int (count Mn x))\n             t}\n    \\<subseteq> {t. 0 < count (fst M) t} \\<union> {t. 0 < count (snd M) t}", "apply (auto simp only: set_mset_def fst_conv snd_conv split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_zcount_neg[simp]: \"finite {t. zcount M t < 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. zcount M t < 0}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       finite\n        {t. (case M of\n             (Mp, Mn) \\<Rightarrow>\n               \\<lambda>x. int (count Mp x) - int (count Mn x))\n             t\n            < 0}", "subgoal for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. (case M of\n          (Mp, Mn) \\<Rightarrow>\n            \\<lambda>x. int (count Mp x) - int (count Mn x))\n          t\n         < 0}", "apply (rule finite_subset[OF _ finite_Un[THEN iffD2, OF conjI[OF finite_nonzero_count finite_nonzero_count]], of _ \"fst M\" \"snd M\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. (case M of\n         (Mp, Mn) \\<Rightarrow>\n           \\<lambda>x. int (count Mp x) - int (count Mn x))\n         t\n        < 0}\n    \\<subseteq> {t. 0 < count (fst M) t} \\<union> {t. 0 < count (snd M) t}", "apply (auto simp only: set_mset_def fst_conv snd_conv split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pos_zcount_in_zmset: \"0 < zcount M x \\<Longrightarrow> x \\<in>#\\<^sub>z M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount M x \\<Longrightarrow> x \\<in>#\\<^sub>z M", "by (simp add: zcount_inI)"], ["", "lemma zmset_elem_nonneg: \"x \\<in>#\\<^sub>z M \\<Longrightarrow> (\\<And>x. x \\<in>#\\<^sub>z M \\<Longrightarrow> 0 \\<le> zcount M x) \\<Longrightarrow> 0 < zcount M x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in>#\\<^sub>z M;\n     \\<And>x.\n        x \\<in>#\\<^sub>z M \\<Longrightarrow> 0 \\<le> zcount M x\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount M x", "by (simp add: order.order_iff_strict zcount_eq_zero_iff)"], ["", "lemma zero_le_sum_single: \"0 \\<le> zcount (\\<Sum>x\\<in>M. {#f x#}\\<^sub>z) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> zcount (\\<Sum>x\\<in>M. {#f x#}\\<^sub>z) t", "by (induct M rule: infinite_finite_induct) auto"], ["", "lemma mem_zmset_of[simp]: \"x \\<in>#\\<^sub>z zmset_of M \\<longleftrightarrow> x \\<in># M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in>#\\<^sub>z zmset_of M) = (x \\<in># M)", "by (simp add: set_zmset_def)"], ["", "lemma mset_neg_minus: \"mset_neg (abs_zmultiset (Mp,Mn)) = Mn-Mp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_neg (abs_zmultiset (Mp, Mn)) = Mn - Mp", "by (simp add: mset_neg.abs_eq)"], ["", "lemma mset_pos_minus: \"mset_pos (abs_zmultiset (Mp,Mn)) = Mp-Mn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_pos (abs_zmultiset (Mp, Mn)) = Mp - Mn", "by (simp add: mset_pos.abs_eq)"], ["", "lemma mset_neg_sum_set: \"(\\<And>m. m \\<in> M \\<Longrightarrow> mset_neg (f m) = {#}) \\<Longrightarrow> mset_neg (\\<Sum>m\\<in>M. f m) = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m \\<in> M \\<Longrightarrow> mset_neg (f m) = {#}) \\<Longrightarrow>\n    mset_neg (sum f M) = {#}", "by (induct M rule: infinite_finite_induct) auto"], ["", "lemma mset_neg_empty_iff: \"mset_neg M = {#} \\<longleftrightarrow> (\\<forall>t. 0 \\<le> zcount M t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset_neg M = {#}) = (\\<forall>t. 0 \\<le> zcount M t)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. mset_neg M = {#} \\<Longrightarrow> \\<forall>t. 0 \\<le> zcount M t\n 2. \\<forall>t. 0 \\<le> zcount M t \\<Longrightarrow> mset_neg M = {#}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_neg M = {#} \\<Longrightarrow> \\<forall>t. 0 \\<le> zcount M t", "by (metis add.commute add.right_neutral mset_pos_as_neg zcount_zmset_of_nonneg zmset_of_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t. 0 \\<le> zcount M t \\<Longrightarrow> mset_neg M = {#}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t. 0 \\<le> zcount M t \\<Longrightarrow> mset_neg M = {#}", "apply (induct rule: zmultiset.abs_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<forall>t. 0 \\<le> zcount (abs_zmultiset y) t \\<Longrightarrow>\n       mset_neg (abs_zmultiset y) = {#}", "subgoal for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t. 0 \\<le> zcount (abs_zmultiset y) t \\<Longrightarrow>\n    mset_neg (abs_zmultiset y) = {#}", "apply (induct y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<forall>t. 0 \\<le> zcount (abs_zmultiset (a, b)) t \\<Longrightarrow>\n       mset_neg (abs_zmultiset (a, b)) = {#}", "apply (subst mset_neg_minus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<forall>t. 0 \\<le> zcount (abs_zmultiset (a, b)) t \\<Longrightarrow>\n       b - a = {#}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<forall>t.\n          0 \\<le> (case (a, b) of\n                   (Mp, Mn) \\<Rightarrow>\n                     \\<lambda>x. int (count Mp x) - int (count Mn x))\n                   t \\<Longrightarrow>\n       b - a = {#}", "apply (simp add: Diff_eq_empty_iff_mset mset_subset_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mset_neg_zcount_nonneg: \"mset_neg M = {#} \\<Longrightarrow> 0 \\<le> zcount M t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_neg M = {#} \\<Longrightarrow> 0 \\<le> zcount M t", "by (subst (asm) mset_neg_empty_iff) simp"], ["", "lemma in_zmset_conv_pos_neg_disj: \"x \\<in>#\\<^sub>z M \\<longleftrightarrow> x \\<in># mset_pos M \\<or> x \\<in># mset_neg M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in>#\\<^sub>z M) = (x \\<in># mset_pos M \\<or> x \\<in># mset_neg M)", "by (metis count_mset_pos in_diff_zcount mem_zmset_of mset_pos_neg_partition nat_code(2) not_in_iff zcount_ne_zero_iff)"], ["", "lemma in_zmset_notin_mset_pos[simp]: \"x \\<in>#\\<^sub>z M \\<Longrightarrow> x \\<notin># mset_pos M \\<Longrightarrow> x \\<in># mset_neg M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in>#\\<^sub>z M; x \\<notin># mset_pos M\\<rbrakk>\n    \\<Longrightarrow> x \\<in># mset_neg M", "by (auto simp: in_zmset_conv_pos_neg_disj)"], ["", "lemma in_zmset_notin_mset_neg[simp]: \"x \\<in>#\\<^sub>z M \\<Longrightarrow> x \\<notin># mset_neg M \\<Longrightarrow> x \\<in># mset_pos M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in>#\\<^sub>z M; x \\<notin># mset_neg M\\<rbrakk>\n    \\<Longrightarrow> x \\<in># mset_pos M", "by (auto simp: in_zmset_conv_pos_neg_disj)"], ["", "lemma in_mset_pos_in_zmset: \"x \\<in># mset_pos M \\<Longrightarrow> x \\<in>#\\<^sub>z M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in># mset_pos M \\<Longrightarrow> x \\<in>#\\<^sub>z M", "by (auto intro: iffD2[OF in_zmset_conv_pos_neg_disj])"], ["", "lemma in_mset_neg_in_zmset: \"x \\<in># mset_neg M \\<Longrightarrow> x \\<in>#\\<^sub>z M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in># mset_neg M \\<Longrightarrow> x \\<in>#\\<^sub>z M", "by (auto intro: iffD2[OF in_zmset_conv_pos_neg_disj])"], ["", "lemma set_zmset_eq_set_mset_union: \"set_zmset M = set_mset (mset_pos M) \\<union> set_mset (mset_neg M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_zmset M = set_mset (mset_pos M) \\<union> set_mset (mset_neg M)", "by (auto dest: in_mset_pos_in_zmset in_mset_neg_in_zmset)"], ["", "lemma member_mset_pos_iff_zcount: \"x \\<in># mset_pos M \\<longleftrightarrow> 0 < zcount M x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in># mset_pos M) = (0 < zcount M x)", "using not_in_iff pos_zcount_in_zmset"], ["proof (prove)\nusing this:\n  (?x \\<notin># ?M) = (count ?M ?x = 0)\n  0 < zcount ?M ?x \\<Longrightarrow> ?x \\<in>#\\<^sub>z ?M\n\ngoal (1 subgoal):\n 1. (x \\<in># mset_pos M) = (0 < zcount M x)", "by force"], ["", "lemma member_mset_neg_iff_zcount: \"x \\<in># mset_neg M \\<longleftrightarrow> zcount M x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in># mset_neg M) = (zcount M x < 0)", "by (metis member_mset_pos_iff_zcount mset_pos_uminus neg_le_0_iff_le not_le zcount_uminus)"], ["", "lemma mset_pos_mset_neg_disjoint[simp]: \"set_mset (mset_pos \\<Delta>) \\<inter> set_mset (mset_neg \\<Delta>) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (mset_pos \\<Delta>) \\<inter> set_mset (mset_neg \\<Delta>) = {}", "by (auto simp: member_mset_pos_iff_zcount member_mset_neg_iff_zcount)"], ["", "lemma zcount_sum: \"zcount (\\<Sum>M\\<in>MM. f M) t = (\\<Sum>M\\<in>MM. zcount (f M) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (sum f MM) t = (\\<Sum>M\\<in>MM. zcount (f M) t)", "by (induct MM rule: infinite_finite_induct) auto"], ["", "lemma zcount_filter_invariant: \"zcount {# t'\\<in>#\\<^sub>zM. t'=t #} t = zcount M t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount {#t' \\<in>#\\<^sub>z M. t' = t#} t = zcount M t", "by auto"], ["", "lemma in_filter_zmset_in_zmset[simp]: \"x \\<in>#\\<^sub>z filter_zmset P M \\<Longrightarrow> x \\<in>#\\<^sub>z M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in>#\\<^sub>z filter_zmset P M \\<Longrightarrow> x \\<in>#\\<^sub>z M", "by (metis count_filter_zmset zcount_ne_zero_iff)"], ["", "lemma pos_filter_zmset_pos_zmset[simp]: \"0 < zcount (filter_zmset P M) x \\<Longrightarrow> 0 < zcount M x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount (filter_zmset P M) x \\<Longrightarrow> 0 < zcount M x", "by (metis (full_types) count_filter_zmset less_irrefl)"], ["", "lemma neg_filter_zmset_neg_zmset[simp]: \"0 > zcount (filter_zmset P M) x \\<Longrightarrow> 0 > zcount M x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (filter_zmset P M) x < 0 \\<Longrightarrow> zcount M x < 0", "by (metis (full_types) count_filter_zmset less_irrefl)"], ["", "lift_definition update_zmultiset :: \"'t zmultiset \\<Rightarrow> 't \\<Rightarrow> int \\<Rightarrow> 't zmultiset\" is\n  \"\\<lambda>(A,B) T D.(if D>0 then (A + replicate_mset (nat D) T, B)\n                    else (A,B + replicate_mset (nat (-D)) T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2 t int.\n       equiv_zmset prod1 prod2 \\<Longrightarrow>\n       equiv_zmset\n        ((case prod1 of\n          (A, B) \\<Rightarrow>\n            \\<lambda>T D.\n               if 0 < D then (A + replicate_mset (nat D) T, B)\n               else (A, B + replicate_mset (nat (- D)) T))\n          t int)\n        ((case prod2 of\n          (A, B) \\<Rightarrow>\n            \\<lambda>T D.\n               if 0 < D then (A + replicate_mset (nat D) T, B)\n               else (A, B + replicate_mset (nat (- D)) T))\n          t int)", "by (auto simp: equiv_zmset_def if_split)"], ["", "lemma zcount_update_zmultiset: \"zcount (update_zmultiset M t n) t' = zcount M t' + (if t = t' then n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (update_zmultiset M t n) t' =\n    zcount M t' + (if t = t' then n else 0)", "by transfer auto"], ["", "lemma (in order) order_zmset_exists_foundation:\n  fixes   t :: 'a\n  assumes \"0 < zcount M t\"\n  shows   \"\\<exists>s. s \\<le> t \\<and> 0 < zcount M s \\<and> (\\<forall>u. 0 < zcount M u \\<longrightarrow> \\<not> u < s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t.\n       0 < zcount M s \\<and>\n       (\\<forall>u. 0 < zcount M u \\<longrightarrow> \\<not> u < s)", "using assms"], ["proof (prove)\nusing this:\n  0 < zcount M t\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t.\n       0 < zcount M s \\<and>\n       (\\<forall>u. 0 < zcount M u \\<longrightarrow> \\<not> u < s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < zcount M t \\<Longrightarrow>\n    \\<exists>s\\<le>t.\n       0 < zcount M s \\<and>\n       (\\<forall>u. 0 < zcount M u \\<longrightarrow> \\<not> u < s)", "let ?M = \"{t. 0 < zcount M t}\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < zcount M t \\<Longrightarrow>\n    \\<exists>s\\<le>t.\n       0 < zcount M s \\<and>\n       (\\<forall>u. 0 < zcount M u \\<longrightarrow> \\<not> u < s)", "from assms"], ["proof (chain)\npicking this:\n  0 < zcount M t", "have \"t \\<in> ?M\""], ["proof (prove)\nusing this:\n  0 < zcount M t\n\ngoal (1 subgoal):\n 1. t \\<in> {t. 0 < zcount M t}", "by simp"], ["proof (state)\nthis:\n  t \\<in> {t. 0 < zcount M t}\n\ngoal (1 subgoal):\n 1. 0 < zcount M t \\<Longrightarrow>\n    \\<exists>s\\<le>t.\n       0 < zcount M s \\<and>\n       (\\<forall>u. 0 < zcount M u \\<longrightarrow> \\<not> u < s)", "then"], ["proof (chain)\npicking this:\n  t \\<in> {t. 0 < zcount M t}", "have \"\\<exists>s\\<in>?M. s \\<le> t \\<and> (\\<forall>u\\<in>?M. \\<not> u < s)\""], ["proof (prove)\nusing this:\n  t \\<in> {t. 0 < zcount M t}\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>{t. 0 < zcount M t}.\n       s \\<le> t \\<and> (\\<forall>u\\<in>{t. 0 < zcount M t}. \\<not> u < s)", "by - (drule order_finite_set_exists_foundation[rotated 1], auto)"], ["proof (state)\nthis:\n  \\<exists>s\\<in>{t. 0 < zcount M t}.\n     s \\<le> t \\<and> (\\<forall>u\\<in>{t. 0 < zcount M t}. \\<not> u < s)\n\ngoal (1 subgoal):\n 1. 0 < zcount M t \\<Longrightarrow>\n    \\<exists>s\\<le>t.\n       0 < zcount M s \\<and>\n       (\\<forall>u. 0 < zcount M u \\<longrightarrow> \\<not> u < s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>s\\<in>{t. 0 < zcount M t}.\n     s \\<le> t \\<and> (\\<forall>u\\<in>{t. 0 < zcount M t}. \\<not> u < s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s\\<in>{t. 0 < zcount M t}.\n     s \\<le> t \\<and> (\\<forall>u\\<in>{t. 0 < zcount M t}. \\<not> u < s)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t.\n       0 < zcount M s \\<and>\n       (\\<forall>u. 0 < zcount M u \\<longrightarrow> \\<not> u < s)", "by auto"], ["proof (state)\nthis:\n  \\<exists>s\\<le>t.\n     0 < zcount M s \\<and>\n     (\\<forall>u. 0 < zcount M u \\<longrightarrow> \\<not> u < s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in order) order_zmset_exists_foundation':\n  fixes   t :: 'a\n  assumes \"0 < zcount M t\"\n  shows   \"\\<exists>s. s \\<le> t \\<and> 0 < zcount M s \\<and> (\\<forall>u<s. zcount M u \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t.\n       0 < zcount M s \\<and> (\\<forall>u<s. zcount M u \\<le> 0)", "using assms order_zmset_exists_foundation"], ["proof (prove)\nusing this:\n  0 < zcount M t\n  0 < zcount ?M ?t \\<Longrightarrow>\n  \\<exists>s\\<le>?t.\n     0 < zcount ?M s \\<and>\n     (\\<forall>u. 0 < zcount ?M u \\<longrightarrow> \\<not> u < s)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t.\n       0 < zcount M s \\<and> (\\<forall>u<s. zcount M u \\<le> 0)", "by (meson le_less_linear)"], ["", "lemma (in order) order_zmset_exists_foundation_neg:\n  fixes   t :: 'a\n  assumes \"zcount M t < 0\"\n  shows   \"\\<exists>s. s \\<le> t \\<and> zcount M s < 0 \\<and> (\\<forall>u. zcount M u < 0 \\<longrightarrow> \\<not> u < s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t.\n       zcount M s < 0 \\<and>\n       (\\<forall>u. zcount M u < 0 \\<longrightarrow> \\<not> u < s)", "using assms"], ["proof (prove)\nusing this:\n  zcount M t < 0\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t.\n       zcount M s < 0 \\<and>\n       (\\<forall>u. zcount M u < 0 \\<longrightarrow> \\<not> u < s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zcount M t < 0 \\<Longrightarrow>\n    \\<exists>s\\<le>t.\n       zcount M s < 0 \\<and>\n       (\\<forall>u. zcount M u < 0 \\<longrightarrow> \\<not> u < s)", "let ?M = \"{t. zcount M t < 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. zcount M t < 0 \\<Longrightarrow>\n    \\<exists>s\\<le>t.\n       zcount M s < 0 \\<and>\n       (\\<forall>u. zcount M u < 0 \\<longrightarrow> \\<not> u < s)", "from assms"], ["proof (chain)\npicking this:\n  zcount M t < 0", "have \"t \\<in> ?M\""], ["proof (prove)\nusing this:\n  zcount M t < 0\n\ngoal (1 subgoal):\n 1. t \\<in> {t. zcount M t < 0}", "by simp"], ["proof (state)\nthis:\n  t \\<in> {t. zcount M t < 0}\n\ngoal (1 subgoal):\n 1. zcount M t < 0 \\<Longrightarrow>\n    \\<exists>s\\<le>t.\n       zcount M s < 0 \\<and>\n       (\\<forall>u. zcount M u < 0 \\<longrightarrow> \\<not> u < s)", "then"], ["proof (chain)\npicking this:\n  t \\<in> {t. zcount M t < 0}", "have \"\\<exists>s\\<in>?M. s \\<le> t \\<and> (\\<forall>u\\<in>?M. \\<not> u < s)\""], ["proof (prove)\nusing this:\n  t \\<in> {t. zcount M t < 0}\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>{t. zcount M t < 0}.\n       s \\<le> t \\<and> (\\<forall>u\\<in>{t. zcount M t < 0}. \\<not> u < s)", "by - (drule order_finite_set_exists_foundation[rotated 1], auto)"], ["proof (state)\nthis:\n  \\<exists>s\\<in>{t. zcount M t < 0}.\n     s \\<le> t \\<and> (\\<forall>u\\<in>{t. zcount M t < 0}. \\<not> u < s)\n\ngoal (1 subgoal):\n 1. zcount M t < 0 \\<Longrightarrow>\n    \\<exists>s\\<le>t.\n       zcount M s < 0 \\<and>\n       (\\<forall>u. zcount M u < 0 \\<longrightarrow> \\<not> u < s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>s\\<in>{t. zcount M t < 0}.\n     s \\<le> t \\<and> (\\<forall>u\\<in>{t. zcount M t < 0}. \\<not> u < s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s\\<in>{t. zcount M t < 0}.\n     s \\<le> t \\<and> (\\<forall>u\\<in>{t. zcount M t < 0}. \\<not> u < s)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t.\n       zcount M s < 0 \\<and>\n       (\\<forall>u. zcount M u < 0 \\<longrightarrow> \\<not> u < s)", "by auto"], ["proof (state)\nthis:\n  \\<exists>s\\<le>t.\n     zcount M s < 0 \\<and>\n     (\\<forall>u. zcount M u < 0 \\<longrightarrow> \\<not> u < s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in order) order_zmset_exists_foundation_neg':\n  fixes   t :: 'a\n  assumes \"zcount M t < 0\"\n  shows   \"\\<exists>s. s \\<le> t \\<and> zcount M s < 0 \\<and> (\\<forall>u<s. 0 \\<le> zcount M u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t.\n       zcount M s < 0 \\<and> (\\<forall>u<s. 0 \\<le> zcount M u)", "using assms order_zmset_exists_foundation_neg"], ["proof (prove)\nusing this:\n  zcount M t < 0\n  zcount ?M ?t < 0 \\<Longrightarrow>\n  \\<exists>s\\<le>?t.\n     zcount ?M s < 0 \\<and>\n     (\\<forall>u. zcount ?M u < 0 \\<longrightarrow> \\<not> u < s)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t.\n       zcount M s < 0 \\<and> (\\<forall>u<s. 0 \\<le> zcount M u)", "by (meson le_less_linear)"], ["", "lemma (in order) elem_order_zmset_exists_foundation:\n  fixes x :: 'a\n  assumes \"x \\<in>#\\<^sub>z M\"\n  shows   \"\\<exists>s\\<in>#\\<^sub>zM. s \\<le> x \\<and> (\\<forall>u\\<in>#\\<^sub>zM. \\<not> u < s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>#\\<^sub>zM.\n       s \\<le> x \\<and> (\\<forall>u\\<in>#\\<^sub>zM. \\<not> u < s)", "by (rule order_finite_set_exists_foundation[OF finite_set_zmset, OF assms(1)])"], ["", "subsubsection\\<open>Image of a Signed Multiset\\<close>"], ["", "lift_definition image_zmset :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a zmultiset \\<Rightarrow> 'b zmultiset\" is\n  \"\\<lambda>f (M, N). (image_mset f M, image_mset f N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun prod1 prod2.\n       equiv_zmset prod1 prod2 \\<Longrightarrow>\n       equiv_zmset\n        (case prod1 of\n         (M, N) \\<Rightarrow> (image_mset fun M, image_mset fun N))\n        (case prod2 of\n         (M, N) \\<Rightarrow> (image_mset fun M, image_mset fun N))", "by (auto simp: equiv_zmset_def simp flip: image_mset_union)"], ["", "syntax (ASCII)\n  \"_comprehension_zmset\" :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'b zmultiset \\<Rightarrow> 'a zmultiset\"  (\"({#_/. _ :#z _#})\")"], ["", "syntax\n  \"_comprehension_zmset\" :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'b zmultiset \\<Rightarrow> 'a zmultiset\"  (\"({#_/. _ \\<in>#\\<^sub>z _#})\")"], ["", "translations\n  \"{#e. x \\<in>#\\<^sub>z M#}\" \\<rightleftharpoons> \"CONST image_zmset (\\<lambda>x. e) M\""], ["", "lemma image_zmset_empty[simp]: \"image_zmset f {#}\\<^sub>z = {#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Auxiliary.image_zmset f {#}\\<^sub>z = {#}\\<^sub>z", "by transfer (auto simp: equiv_zmset_def)"], ["", "lemma image_zmset_single[simp]: \"image_zmset f {#x#}\\<^sub>z = {#f x#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Auxiliary.image_zmset f {#x#}\\<^sub>z = {#f x#}\\<^sub>z", "by transfer (simp add: equiv_zmset_def)"], ["", "lemma image_zmset_union[simp]: \"image_zmset f (M + N) = image_zmset f M + image_zmset f N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Auxiliary.image_zmset f (M + N) =\n    Auxiliary.image_zmset f M + Auxiliary.image_zmset f N", "by transfer (auto simp: equiv_zmset_def)"], ["", "lemma image_zmset_Diff[simp]: \"image_zmset f (A - B) = image_zmset f A - image_zmset f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Auxiliary.image_zmset f (A - B) =\n    Auxiliary.image_zmset f A - Auxiliary.image_zmset f B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Auxiliary.image_zmset f (A - B) =\n    Auxiliary.image_zmset f A - Auxiliary.image_zmset f B", "have \"image_zmset f (A - B + B) = image_zmset f (A - B) + image_zmset f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Auxiliary.image_zmset f (A - B + B) =\n    Auxiliary.image_zmset f (A - B) + Auxiliary.image_zmset f B", "using image_zmset_union"], ["proof (prove)\nusing this:\n  Auxiliary.image_zmset ?f (?M + ?N) =\n  Auxiliary.image_zmset ?f ?M + Auxiliary.image_zmset ?f ?N\n\ngoal (1 subgoal):\n 1. Auxiliary.image_zmset f (A - B + B) =\n    Auxiliary.image_zmset f (A - B) + Auxiliary.image_zmset f B", "by blast"], ["proof (state)\nthis:\n  Auxiliary.image_zmset f (A - B + B) =\n  Auxiliary.image_zmset f (A - B) + Auxiliary.image_zmset f B\n\ngoal (1 subgoal):\n 1. Auxiliary.image_zmset f (A - B) =\n    Auxiliary.image_zmset f A - Auxiliary.image_zmset f B", "then"], ["proof (chain)\npicking this:\n  Auxiliary.image_zmset f (A - B + B) =\n  Auxiliary.image_zmset f (A - B) + Auxiliary.image_zmset f B", "show ?thesis"], ["proof (prove)\nusing this:\n  Auxiliary.image_zmset f (A - B + B) =\n  Auxiliary.image_zmset f (A - B) + Auxiliary.image_zmset f B\n\ngoal (1 subgoal):\n 1. Auxiliary.image_zmset f (A - B) =\n    Auxiliary.image_zmset f A - Auxiliary.image_zmset f B", "by simp"], ["proof (state)\nthis:\n  Auxiliary.image_zmset f (A - B) =\n  Auxiliary.image_zmset f A - Auxiliary.image_zmset f B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_neg_image_zmset: \"mset_neg M = {#} \\<Longrightarrow> mset_neg (image_zmset f M) = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_neg M = {#} \\<Longrightarrow>\n    mset_neg (Auxiliary.image_zmset f M) = {#}", "unfolding multiset_eq_iff count_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. count (mset_neg M) a = 0 \\<Longrightarrow>\n    \\<forall>a. count (mset_neg (Auxiliary.image_zmset f M)) a = 0", "by transfer (auto simp add: image_mset_subseteq_mono mset_subset_eqI mset_subset_eq_count)"], ["", "lemma nonneg_zcount_image_zmset[simp]: \"(\\<And>t. 0 \\<le> zcount M t) \\<Longrightarrow> 0 \\<le> zcount (image_zmset f M) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. 0 \\<le> zcount M t) \\<Longrightarrow>\n    0 \\<le> zcount (Auxiliary.image_zmset f M) t", "by (meson mset_neg_empty_iff mset_neg_image_zmset)"], ["", "lemma image_zmset_add_zmset[simp]: \"image_zmset f (add_zmset t M) = add_zmset (f t) (image_zmset f M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Auxiliary.image_zmset f (add_zmset t M) =\n    add_zmset (f t) (Auxiliary.image_zmset f M)", "by transfer (auto simp: equiv_zmset_def)"], ["", "lemma pos_zcount_image_zmset[simp]: \"(\\<And>t. 0 \\<le> zcount M t) \\<Longrightarrow> 0 < zcount M t \\<Longrightarrow> 0 < zcount (image_zmset f M) (f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t; 0 < zcount M t\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount (Auxiliary.image_zmset f M) (f t)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M t f.\n       \\<lbrakk>\\<And>t.\n                   0 \\<le> (case M of\n                            (Mp, Mn) \\<Rightarrow>\n                              \\<lambda>x.\n                                 int (count Mp x) - int (count Mn x))\n                            t;\n        0 < (case M of\n             (Mp, Mn) \\<Rightarrow>\n               \\<lambda>x. int (count Mp x) - int (count Mn x))\n             t\\<rbrakk>\n       \\<Longrightarrow> 0 < (case case M of\n                                   (M, N) \\<Rightarrow>\n                                     (image_mset f M, image_mset f N) of\n                              (Mp, Mn) \\<Rightarrow>\n                                \\<lambda>x.\n                                   int (count Mp x) - int (count Mn x))\n                              (f t)", "subgoal for M t f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                0 \\<le> (case M of\n                         (Mp, Mn) \\<Rightarrow>\n                           \\<lambda>x. int (count Mp x) - int (count Mn x))\n                         t;\n     0 < (case M of\n          (Mp, Mn) \\<Rightarrow>\n            \\<lambda>x. int (count Mp x) - int (count Mn x))\n          t\\<rbrakk>\n    \\<Longrightarrow> 0 < (case case M of\n                                (M, N) \\<Rightarrow>\n                                  (image_mset f M, image_mset f N) of\n                           (Mp, Mn) \\<Rightarrow>\n                             \\<lambda>x.\n                                int (count Mp x) - int (count Mn x))\n                           (f t)", "apply (induct M)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>t.\n                   0 \\<le> (case (a, b) of\n                            (Mp, Mn) \\<Rightarrow>\n                              \\<lambda>x.\n                                 int (count Mp x) - int (count Mn x))\n                            t;\n        0 < (case (a, b) of\n             (Mp, Mn) \\<Rightarrow>\n               \\<lambda>x. int (count Mp x) - int (count Mn x))\n             t\\<rbrakk>\n       \\<Longrightarrow> 0 < (case case (a, b) of\n                                   (M, N) \\<Rightarrow>\n                                     (image_mset f M, image_mset f N) of\n                              (Mp, Mn) \\<Rightarrow>\n                                \\<lambda>x.\n                                   int (count Mp x) - int (count Mn x))\n                              (f t)", "subgoal for Mp Mn"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                0 \\<le> (case (Mp, Mn) of\n                         (Mp, Mn) \\<Rightarrow>\n                           \\<lambda>x. int (count Mp x) - int (count Mn x))\n                         t;\n     0 < (case (Mp, Mn) of\n          (Mp, Mn) \\<Rightarrow>\n            \\<lambda>x. int (count Mp x) - int (count Mn x))\n          t\\<rbrakk>\n    \\<Longrightarrow> 0 < (case case (Mp, Mn) of\n                                (M, N) \\<Rightarrow>\n                                  (image_mset f M, image_mset f N) of\n                           (Mp, Mn) \\<Rightarrow>\n                             \\<lambda>x.\n                                int (count Mp x) - int (count Mn x))\n                           (f t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. count Mn t \\<le> count Mp t;\n     count Mn t < count Mp t\\<rbrakk>\n    \\<Longrightarrow> count (image_mset f Mn) (f t)\n                      < count (image_mset f Mp) (f t)", "apply (metis count_diff count_image_mset_ge_count image_mset_Diff less_le_trans subseteq_mset_def zero_less_diff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_zmset_transfer[transfer_rule]:\n  \"(rel_fun (pcr_zmultiset (=)) (rel_set (=)))\n   (\\<lambda>(Mp, Mn). set_mset Mp \\<union> set_mset Mn - {x. count Mp x = count Mn x}) set_zmset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (pcr_zmultiset (=)) (rel_set (=))\n     (\\<lambda>(Mp, Mn).\n         set_mset Mp \\<union> set_mset Mn - {x. count Mp x = count Mn x})\n     set_zmset", "by (auto simp: rel_fun_def pcr_zmultiset_def cr_zmultiset_def\n      rel_set_eq multiset.rel_eq set_zmset_def zcount.abs_eq count_eq_zero_iff[symmetric]\n      simp del: zcount_ne_zero_iff)"], ["", "lemma zcount_image_zmset:\n  \"zcount (image_zmset f M) x = (\\<Sum>y \\<in> f -` {x} \\<inter> set_zmset M. zcount M y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (Auxiliary.image_zmset f M) x =\n    sum (zcount M) (f -` {x} \\<inter> set_zmset M)", "apply (transfer fixing: f x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       (case case M of\n             (M, N) \\<Rightarrow> (image_mset f M, image_mset f N) of\n        (Mp, Mn) \\<Rightarrow>\n          \\<lambda>x. int (count Mp x) - int (count Mn x))\n        x =\n       sum (case M of\n            (Mp, Mn) \\<Rightarrow>\n              \\<lambda>x. int (count Mp x) - int (count Mn x))\n        (f -` {x} \\<inter>\n         (case M of\n          (Mp, Mn) \\<Rightarrow>\n            set_mset Mp \\<union> set_mset Mn -\n            {x. count Mp x = count Mn x}))", "subgoal for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case M of (M, N) \\<Rightarrow> (image_mset f M, image_mset f N) of\n     (Mp, Mn) \\<Rightarrow> \\<lambda>x. int (count Mp x) - int (count Mn x))\n     x =\n    sum (case M of\n         (Mp, Mn) \\<Rightarrow>\n           \\<lambda>x. int (count Mp x) - int (count Mn x))\n     (f -` {x} \\<inter>\n      (case M of\n       (Mp, Mn) \\<Rightarrow>\n         set_mset Mp \\<union> set_mset Mn - {x. count Mp x = count Mn x}))", "apply (cases M; clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       M = (a, b) \\<Longrightarrow>\n       int (count (image_mset f a) x) - int (count (image_mset f b) x) =\n       (\\<Sum>x\\<in>f -` {x} \\<inter>\n                    (set_mset a \\<union> set_mset b -\n                     {x. count a x = count b x}).\n          int (count a x) - int (count b x))", "subgoal for Mp Mn"], ["proof (prove)\ngoal (1 subgoal):\n 1. M = (Mp, Mn) \\<Longrightarrow>\n    int (count (image_mset f Mp) x) - int (count (image_mset f Mn) x) =\n    (\\<Sum>x\\<in>f -` {x} \\<inter>\n                 (set_mset Mp \\<union> set_mset Mn -\n                  {x. count Mp x = count Mn x}).\n       int (count Mp x) - int (count Mn x))", "unfolding count_image_mset int_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. M = (Mp, Mn) \\<Longrightarrow>\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) -\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n    (\\<Sum>x\\<in>f -` {x} \\<inter>\n                 (set_mset Mp \\<union> set_mset Mn -\n                  {x. count Mp x = count Mn x}).\n       int (count Mp x) - int (count Mn x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M = (Mp, Mn) \\<Longrightarrow>\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) -\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n    (\\<Sum>x\\<in>f -` {x} \\<inter>\n                 (set_mset Mp \\<union> set_mset Mn -\n                  {x. count Mp x = count Mn x}).\n       int (count Mp x) - int (count Mn x))", "have \"(\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) =\n        (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn). int (count Mp x))\" (is \"?S1 = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) =\n    (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n       int (count Mp x))", "by (subst sum.same_carrier[where C=\"f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn)\"])\n          (auto simp: count_eq_zero_iff)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) =\n  (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n     int (count Mp x))\n\ngoal (1 subgoal):\n 1. M = (Mp, Mn) \\<Longrightarrow>\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) -\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n    (\\<Sum>x\\<in>f -` {x} \\<inter>\n                 (set_mset Mp \\<union> set_mset Mn -\n                  {x. count Mp x = count Mn x}).\n       int (count Mp x) - int (count Mn x))", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) =\n  (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n     int (count Mp x))\n\ngoal (1 subgoal):\n 1. M = (Mp, Mn) \\<Longrightarrow>\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) -\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n    (\\<Sum>x\\<in>f -` {x} \\<inter>\n                 (set_mset Mp \\<union> set_mset Mn -\n                  {x. count Mp x = count Mn x}).\n       int (count Mp x) - int (count Mn x))", "have \"(\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n        (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn). int (count Mn x))\"(is \"?S2 = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n    (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n       int (count Mn x))", "by (subst sum.same_carrier[where C=\"f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn)\"])\n          (auto simp: count_eq_zero_iff)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n  (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n     int (count Mn x))\n\ngoal (1 subgoal):\n 1. M = (Mp, Mn) \\<Longrightarrow>\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) -\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n    (\\<Sum>x\\<in>f -` {x} \\<inter>\n                 (set_mset Mp \\<union> set_mset Mn -\n                  {x. count Mp x = count Mn x}).\n       int (count Mp x) - int (count Mn x))", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n  (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n     int (count Mn x))\n\ngoal (1 subgoal):\n 1. M = (Mp, Mn) \\<Longrightarrow>\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) -\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n    (\\<Sum>x\\<in>f -` {x} \\<inter>\n                 (set_mset Mp \\<union> set_mset Mn -\n                  {x. count Mp x = count Mn x}).\n       int (count Mp x) - int (count Mn x))", "have \"(\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn - {x. count Mp x = count Mn x}). int (count Mp x) - int (count Mn x))\n        = (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn). int (count Mp x) - int (count Mn x))\"\n        (is \"?S = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f -` {x} \\<inter>\n                 (set_mset Mp \\<union> set_mset Mn -\n                  {x. count Mp x = count Mn x}).\n       int (count Mp x) - int (count Mn x)) =\n    (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n       int (count Mp x) - int (count Mn x))", "by (subst sum.same_carrier[where C=\"f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn)\"]) auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f -` {x} \\<inter>\n               (set_mset Mp \\<union> set_mset Mn -\n                {x. count Mp x = count Mn x}).\n     int (count Mp x) - int (count Mn x)) =\n  (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n     int (count Mp x) - int (count Mn x))\n\ngoal (1 subgoal):\n 1. M = (Mp, Mn) \\<Longrightarrow>\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) -\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n    (\\<Sum>x\\<in>f -` {x} \\<inter>\n                 (set_mset Mp \\<union> set_mset Mn -\n                  {x. count Mp x = count Mn x}).\n       int (count Mp x) - int (count Mn x))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) =\n  (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n     int (count Mp x))\n  (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n  (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n     int (count Mn x))\n  (\\<Sum>x\\<in>f -` {x} \\<inter>\n               (set_mset Mp \\<union> set_mset Mn -\n                {x. count Mp x = count Mn x}).\n     int (count Mp x) - int (count Mn x)) =\n  (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n     int (count Mp x) - int (count Mn x))", "show \"?S1 - ?S2 = ?S\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) =\n  (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n     int (count Mp x))\n  (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n  (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n     int (count Mn x))\n  (\\<Sum>x\\<in>f -` {x} \\<inter>\n               (set_mset Mp \\<union> set_mset Mn -\n                {x. count Mp x = count Mn x}).\n     int (count Mp x) - int (count Mn x)) =\n  (\\<Sum>x\\<in>f -` {x} \\<inter> (set_mset Mp \\<union> set_mset Mn).\n     int (count Mp x) - int (count Mn x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) -\n    (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n    (\\<Sum>x\\<in>f -` {x} \\<inter>\n                 (set_mset Mp \\<union> set_mset Mn -\n                  {x. count Mp x = count Mn x}).\n       int (count Mp x) - int (count Mn x))", "by (auto simp: sum_subtractf)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mp. int (count Mp x)) -\n  (\\<Sum>x\\<in>f -` {x} \\<inter> set_mset Mn. int (count Mn x)) =\n  (\\<Sum>x\\<in>f -` {x} \\<inter>\n               (set_mset Mp \\<union> set_mset Mn -\n                {x. count Mp x = count Mn x}).\n     int (count Mp x) - int (count Mn x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma zmset_empty_image_zmset_empty: \"(\\<And>t. zcount M t = 0) \\<Longrightarrow> zcount (image_zmset f M) t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. zcount M t = 0) \\<Longrightarrow>\n    zcount (Auxiliary.image_zmset f M) t = 0", "by (auto simp: zcount_image_zmset)"], ["", "lemma in_image_zmset_in_zmset: \"t \\<in>#\\<^sub>z image_zmset f M \\<Longrightarrow> \\<exists>t. t \\<in>#\\<^sub>z M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in>#\\<^sub>z Auxiliary.image_zmset f M \\<Longrightarrow>\n    \\<exists>t. t \\<in>#\\<^sub>z M", "by (rule ccontr) simp"], ["", "lemma zcount_image_zmset_zero: \"(\\<And>m. m \\<in>#\\<^sub>z M \\<Longrightarrow> f m \\<noteq> x) \\<Longrightarrow> x \\<notin>#\\<^sub>z image_zmset f M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m \\<in>#\\<^sub>z M \\<Longrightarrow>\n        f m \\<noteq> x) \\<Longrightarrow>\n    x \\<notin>#\\<^sub>z Auxiliary.image_zmset f M", "unfolding set_zmset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m \\<in> {x. zcount M x \\<noteq> 0} \\<Longrightarrow>\n        f m \\<noteq> x) \\<Longrightarrow>\n    x \\<notin> {x. zcount (Auxiliary.image_zmset f M) x \\<noteq> 0}", "by (simp add: zcount_image_zmset) (metis Int_emptyI sum.empty vimage_singleton_eq)"], ["", "lemma image_zmset_pre: \"t \\<in>#\\<^sub>z image_zmset f M \\<Longrightarrow> \\<exists>m. m \\<in>#\\<^sub>z M \\<and> f m = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in>#\\<^sub>z Auxiliary.image_zmset f M \\<Longrightarrow>\n    \\<exists>m. m \\<in>#\\<^sub>z M \\<and> f m = t", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in>#\\<^sub>z Auxiliary.image_zmset f M;\n     \\<nexists>m. m \\<in>#\\<^sub>z M \\<and> f m = t\\<rbrakk>\n    \\<Longrightarrow> False", "assume t: \"t \\<in>#\\<^sub>z image_zmset f M\""], ["proof (state)\nthis:\n  t \\<in>#\\<^sub>z Auxiliary.image_zmset f M\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in>#\\<^sub>z Auxiliary.image_zmset f M;\n     \\<nexists>m. m \\<in>#\\<^sub>z M \\<and> f m = t\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"\\<nexists>m. m \\<in>#\\<^sub>z M \\<and> f m = t\""], ["proof (state)\nthis:\n  \\<nexists>m. m \\<in>#\\<^sub>z M \\<and> f m = t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in>#\\<^sub>z Auxiliary.image_zmset f M;\n     \\<nexists>m. m \\<in>#\\<^sub>z M \\<and> f m = t\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>m. m \\<in>#\\<^sub>z M \\<and> f m = t", "have \"m \\<in>#\\<^sub>z M \\<Longrightarrow> \\<not> f m = t\" for m"], ["proof (prove)\nusing this:\n  \\<nexists>m. m \\<in>#\\<^sub>z M \\<and> f m = t\n\ngoal (1 subgoal):\n 1. m \\<in>#\\<^sub>z M \\<Longrightarrow> f m \\<noteq> t", "by blast"], ["proof (state)\nthis:\n  ?m \\<in>#\\<^sub>z M \\<Longrightarrow> f ?m \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in>#\\<^sub>z Auxiliary.image_zmset f M;\n     \\<nexists>m. m \\<in>#\\<^sub>z M \\<and> f m = t\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ?m \\<in>#\\<^sub>z M \\<Longrightarrow> f ?m \\<noteq> t", "have \"zcount (image_zmset f M) t = 0\""], ["proof (prove)\nusing this:\n  ?m \\<in>#\\<^sub>z M \\<Longrightarrow> f ?m \\<noteq> t\n\ngoal (1 subgoal):\n 1. zcount (Auxiliary.image_zmset f M) t = 0", "by (meson t zcount_image_zmset_zero)"], ["proof (state)\nthis:\n  zcount (Auxiliary.image_zmset f M) t = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in>#\\<^sub>z Auxiliary.image_zmset f M;\n     \\<nexists>m. m \\<in>#\\<^sub>z M \\<and> f m = t\\<rbrakk>\n    \\<Longrightarrow> False", "with t"], ["proof (chain)\npicking this:\n  t \\<in>#\\<^sub>z Auxiliary.image_zmset f M\n  zcount (Auxiliary.image_zmset f M) t = 0", "show False"], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z Auxiliary.image_zmset f M\n  zcount (Auxiliary.image_zmset f M) t = 0\n\ngoal (1 subgoal):\n 1. False", "by (meson zcount_ne_zero_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pos_image_zmset_obtain_pre:\n  \"(\\<And>t. 0 \\<le> zcount M t) \\<Longrightarrow> 0 < zcount (image_zmset f M) t \\<Longrightarrow> \\<exists>m. 0 < zcount M m \\<and> f m = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t;\n     0 < zcount (Auxiliary.image_zmset f M) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m. 0 < zcount M m \\<and> f m = t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t;\n     0 < zcount (Auxiliary.image_zmset f M) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m. 0 < zcount M m \\<and> f m = t", "assume nonneg: \"0 \\<le> zcount M t\" for t"], ["proof (state)\nthis:\n  0 \\<le> zcount M ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t;\n     0 < zcount (Auxiliary.image_zmset f M) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m. 0 < zcount M m \\<and> f m = t", "assume \"0 < zcount (image_zmset f M) t\""], ["proof (state)\nthis:\n  0 < zcount (Auxiliary.image_zmset f M) t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t;\n     0 < zcount (Auxiliary.image_zmset f M) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m. 0 < zcount M m \\<and> f m = t", "then"], ["proof (chain)\npicking this:\n  0 < zcount (Auxiliary.image_zmset f M) t", "have \"t \\<in>#\\<^sub>z image_zmset f M\""], ["proof (prove)\nusing this:\n  0 < zcount (Auxiliary.image_zmset f M) t\n\ngoal (1 subgoal):\n 1. t \\<in>#\\<^sub>z Auxiliary.image_zmset f M", "by (simp add: pos_zcount_in_zmset)"], ["proof (state)\nthis:\n  t \\<in>#\\<^sub>z Auxiliary.image_zmset f M\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t;\n     0 < zcount (Auxiliary.image_zmset f M) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m. 0 < zcount M m \\<and> f m = t", "then"], ["proof (chain)\npicking this:\n  t \\<in>#\\<^sub>z Auxiliary.image_zmset f M", "obtain x where x: \"x \\<in>#\\<^sub>z M\" \"f x = t\""], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z Auxiliary.image_zmset f M\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in>#\\<^sub>z M; f x = t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: image_zmset_pre)"], ["proof (state)\nthis:\n  x \\<in>#\\<^sub>z M\n  f x = t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t;\n     0 < zcount (Auxiliary.image_zmset f M) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m. 0 < zcount M m \\<and> f m = t", "with nonneg"], ["proof (chain)\npicking this:\n  0 \\<le> zcount M ?t\n  x \\<in>#\\<^sub>z M\n  f x = t", "have \"0 < zcount M x\""], ["proof (prove)\nusing this:\n  0 \\<le> zcount M ?t\n  x \\<in>#\\<^sub>z M\n  f x = t\n\ngoal (1 subgoal):\n 1. 0 < zcount M x", "by (meson zmset_elem_nonneg)"], ["proof (state)\nthis:\n  0 < zcount M x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t;\n     0 < zcount (Auxiliary.image_zmset f M) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m. 0 < zcount M m \\<and> f m = t", "with x"], ["proof (chain)\npicking this:\n  x \\<in>#\\<^sub>z M\n  f x = t\n  0 < zcount M x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in>#\\<^sub>z M\n  f x = t\n  0 < zcount M x\n\ngoal (1 subgoal):\n 1. \\<exists>m. 0 < zcount M m \\<and> f m = t", "by auto"], ["proof (state)\nthis:\n  \\<exists>m. 0 < zcount M m \\<and> f m = t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Streams\\<close>"], ["", "definition relates :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a stream \\<Rightarrow> bool\" where\n  \"relates \\<phi> s = \\<phi> (shd s) (shd (stl s))\""], ["", "lemma relatesD[dest]: \"relates P s \\<Longrightarrow> P (shd s) (shd (stl s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relates P s \\<Longrightarrow> P (shd s) (shd (stl s))", "unfolding relates_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (shd s) (shd (stl s)) \\<Longrightarrow> P (shd s) (shd (stl s))", "by simp"], ["", "lemma alw_relatesD[dest]: \"alw (relates P) s \\<Longrightarrow> P (shd s) (shd (stl s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (relates P) s \\<Longrightarrow> P (shd s) (shd (stl s))", "by auto"], ["", "lemma relatesI[intro]: \"P (shd s) (shd (stl s)) \\<Longrightarrow> relates P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (shd s) (shd (stl s)) \\<Longrightarrow> relates P s", "by (auto simp: relates_def)"], ["", "lemma alw_holds_smap_conv_comp: \"alw (holds P) (smap f s) = alw (\\<lambda>s. (P o f) (shd s)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (holds P) (smap f s) = alw (\\<lambda>s. (P \\<circ> f) (shd s)) s", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. alw (holds P) (smap f s) \\<Longrightarrow>\n    alw (\\<lambda>s. (P \\<circ> f) (shd s)) s\n 2. alw (\\<lambda>s. (P \\<circ> f) (shd s)) s \\<Longrightarrow>\n    alw (holds P) (smap f s)", "apply (coinduction arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       alw (holds P) (smap f s) \\<Longrightarrow>\n       \\<exists>xs.\n          s = xs \\<and>\n          (P \\<circ> f) (shd xs) \\<and>\n          ((\\<exists>s. stl xs = s \\<and> alw (holds P) (smap f s)) \\<or>\n           alw (\\<lambda>s. (P \\<circ> f) (shd s)) (stl xs))\n 2. alw (\\<lambda>s. (P \\<circ> f) (shd s)) s \\<Longrightarrow>\n    alw (holds P) (smap f s)", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>s. (P \\<circ> f) (shd s)) s \\<Longrightarrow>\n    alw (holds P) (smap f s)", "apply (coinduction arbitrary: s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       alw (\\<lambda>s. (P \\<circ> f) (shd s)) s \\<Longrightarrow>\n       \\<exists>xs.\n          smap f s = xs \\<and>\n          holds P xs \\<and>\n          ((\\<exists>s.\n               stl xs = smap f s \\<and>\n               alw (\\<lambda>s. (P \\<circ> f) (shd s)) s) \\<or>\n           alw (holds P) (stl xs))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma alw_relates: \"alw (relates P) s \\<longleftrightarrow> P (shd s) (shd (stl s)) \\<and> alw (relates P) (stl s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (relates P) s =\n    (P (shd s) (shd (stl s)) \\<and> alw (relates P) (stl s))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. alw (relates P) s \\<Longrightarrow>\n    P (shd s) (shd (stl s)) \\<and> alw (relates P) (stl s)\n 2. P (shd s) (shd (stl s)) \\<and> alw (relates P) (stl s) \\<Longrightarrow>\n    alw (relates P) s", "apply (auto simp: relates_def dest: alwD) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (shd s) (shd (stl s)) \\<and> alw (relates P) (stl s) \\<Longrightarrow>\n    alw (relates P) s", "apply (coinduction arbitrary: s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       P (shd s) (shd (stl s)) \\<and>\n       alw (relates P) (stl s) \\<Longrightarrow>\n       \\<exists>xs.\n          s = xs \\<and>\n          relates P xs \\<and>\n          ((\\<exists>s.\n               stl xs = s \\<and>\n               P (shd s) (shd (stl s)) \\<and> alw (relates P) (stl s)) \\<or>\n           alw (relates P) (stl xs))", "apply (auto simp: relates_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Notation\\<close>"], ["", "no_notation AND  (infix \"aand\" 60)"], ["", "no_notation OR   (infix \"or\" 60)"], ["", "no_notation IMPL (infix \"imp\" 60)"], ["", "notation AND  (infixr \"aand\" 70)"], ["", "notation OR   (infixr \"or\" 65)"], ["", "notation IMPL (infixr \"imp\" 60)"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}