{"file_name": "/home/qj213/afp-2021-10-22/thys/Progress_Tracking/Combined.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Progress_Tracking", "problem_names": ["lemma fold_invar:\n  assumes \"finite M\"\n    and   \"P z\"\n    and   \"\\<forall>z. \\<forall>x\\<in>M. P z \\<longrightarrow> P (f x z)\"\n    and   \"comp_fun_commute f\"\n  shows   \"P (Finite_Set.fold f z M)\"", "lemma cri_asym1: \"x <\\<^sub>p y \\<longrightarrow> \\<not> y <\\<^sub>p x\"\n  for x y", "lemma cri_asym2: \"x <\\<^sub>p y \\<longrightarrow> x \\<noteq> y\"", "lemma wf_cri: \"wf {(l, l'). (l, t) <\\<^sub>p (l', t)}\"", "lemma NextPerformOpD:\n  assumes \"NextPerformOp' c0 c1 p \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self\"\n  shows\n    \"cri.next_performop' (exchange_config c0) (exchange_config c1) p \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self\"\n    \"unchanged prop_config c0 c1\"\n    \"unchanged init c0 c1\"", "lemma NextSendUpdD:\n  assumes \"NextSendUpd' c0 c1 p tt\"\n  shows\n    \"cri.next_sendupd' (exchange_config c0) (exchange_config c1) p tt\"\n    \"unchanged prop_config c0 c1\"\n    \"unchanged init c0 c1\"", "lemma NextRecvUpdD:\n  assumes \"NextRecvUpd' c0 c1 p q\"\n  shows\n    \"init c0 q\"\n    \"cri.next_recvupd' (exchange_config c0) (exchange_config c1) p q\"\n    \"unchanged init c0 c1\"\n    \"(\\<forall>p'. prop_config c1 p' =\n         (if p' = q\n          then cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q))\n          else prop_config c0 p'))\"", "lemma NextPropagateD:\n  assumes \"NextPropagate' c0 c1 p\"\n  shows\n    \"unchanged exchange_config c0 c1\"\n    \"init c1 = (init c0)(p := True)\"\n    \"(\\<forall>p'. Some (prop_config c1 p') =\n         (if p' = p\n          then propagate_all (prop_config c0 p')\n          else Some (prop_config c0 p')))\"", "lemma NextRecvCapD:\n  assumes \"NextRecvCap' c0 c1 p t\"\n  shows\n    \"cri.next_recvcap' (exchange_config c0) (exchange_config c1) p t\"\n    \"unchanged prop_config c0 c1\"\n    \"unchanged init c0 c1\"", "lemma apply_cm_is_cm:\n  \"\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t \\<Longrightarrow> n \\<noteq> 0 \\<Longrightarrow> next_change_multiplicity' c (apply_cm c loc t n) loc t n\"", "lemma update_zmultiset_commute:\n  \"update_zmultiset (update_zmultiset M t' n') t n = update_zmultiset (update_zmultiset M t n) t' n'\"", "lemma apply_cm_commute: \"apply_cm (apply_cm c loc t n) loc' t' n' = apply_cm (apply_cm c loc' t' n') loc t n\"", "lemma comp_fun_commute_apply_cm[simp]: \"comp_fun_commute (\\<lambda>(loc, t) c. apply_cm c loc t (f loc t))\"", "lemma ex_cm_imp_conds:\n  assumes \"\\<exists>c'. next_change_multiplicity' c c' loc t n\"\n  shows \"\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t\" \"n \\<noteq> 0\"", "lemma the_cm_eq_apply_cm:\n  assumes \"\\<exists>c'. next_change_multiplicity' c c' loc t n\"\n  shows   \"the_cm c loc t n = apply_cm c loc t n\"", "lemma apply_cm_preserves_cond:\n  assumes \"\\<forall>(loc,t)\\<in>set_zmset \\<Delta>. \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\"\n  shows   \"\\<forall>(loc,t)\\<in>set_zmset \\<Delta>. \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp (apply_cm c0 loc' t'' n) loc) \\<and> t' \\<le> t\"", "lemma cm_all_eq_cm_all':\n  assumes \"\\<forall>(loc,t)\\<in>set_zmset \\<Delta>. \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\"\n  shows   \"cm_all c0 \\<Delta> = cm_all' c0 \\<Delta>\"", "lemma cm_eq_the_cm:\n  assumes \"next_change_multiplicity' c c' loc t n\"\n  shows   \"the_cm c loc t n = c'\"", "lemma zcount_ps_apply_cm:\n  \"zcount (c_pts (apply_cm c loc t n) loc') t' = zcount (c_pts c loc') t' + (if loc = loc' \\<and> t = t' then n else 0)\"", "lemma zcount_pointstamps_update: \"zcount (c_pts (c\\<lparr>c_pts:=M\\<rparr>) loc) x = zcount (M loc) x\"", "lemma nop: \"loc1 \\<noteq> loc2 \\<or> t1 \\<noteq> t2 \\<longrightarrow>\n    zcount (c_pts (apply_cm c loc2 t2 (zcount \\<Delta> (loc2, t2))) loc1) t1 =\n    zcount (c_pts c loc1) t1\"", "lemma fold_nop:\n  \"zcount (c_pts (Finite_Set.fold (\\<lambda>(loc', t') c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t'))) c\n                          (set_zmset \\<Delta> - {(loc, t)})) loc) t\n  = zcount (c_pts c loc) t\"", "lemma zcount_pointstamps_cm_all':\n  \"zcount (c_pts (cm_all' c \\<Delta>) loc) x\n = zcount (c_pts c loc) x + zcount \\<Delta> (loc,x)\"", "lemma implications_apply_cm[simp]: \"c_imp (apply_cm c loc t n) = c_imp c\"", "lemma implications_cm_all[simp]:\n  \"c_imp (cm_all' c \\<Delta>) = c_imp c\"", "lemma lift_cm_inv_cm_all':\n  assumes \"(\\<And>c0 c1 loc t n. P c0 \\<Longrightarrow> next_change_multiplicity' c0 c1 loc t n \\<Longrightarrow> P c1)\"\n    and   \"\\<forall>(loc,t)\\<in>#\\<^sub>z\\<Delta>. \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\"\n    and   \"P c0\"\n  shows   \"P (cm_all' c0 \\<Delta>)\"", "lemma lift_cm_inv_cm_all:\n  assumes \"\\<And>c0 c1 loc t n. P c0 \\<Longrightarrow> next_change_multiplicity' c0 c1 loc t n \\<Longrightarrow> P c1\"\n    and   \"\\<forall>(loc,t)\\<in>#\\<^sub>z\\<Delta>. \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\"\n    and   \"P c0\"\n  shows   \"P (cm_all c0 \\<Delta>)\"", "lemma obtain_min_worklist:\n  assumes \"(a (loc'::(_ :: finite))::(('t :: order) zmultiset)) \\<noteq> {#}\\<^sub>z\"\n  obtains loc t\n  where \"t \\<in>#\\<^sub>z a loc\"\n    and \"\\<forall>t' loc'. t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t\"", "lemma propagate_pointstamps_eq:\n  assumes \"c_work c loc \\<noteq> {#}\\<^sub>z\"\n  shows   \"c_pts c = c_pts (SOME c'. \\<exists>loc t. next_propagate' c c' loc t)\"", "lemma propagate_all_imp_InvGlobPointstampsEq:\n  \"Some c1 = propagate_all c0 \\<Longrightarrow> c_pts c0 = c_pts c1\"", "lemma exists_next_propagate':\n  assumes \"c_work c loc \\<noteq> {#}\\<^sub>z\"\n  shows   \"\\<exists>c' loc t. next_propagate' c c' loc t\"", "lemma lift_propagate_inv_propagate_all:\n  assumes \"(\\<And>c0 c1 loc t. P c0 \\<Longrightarrow> next_propagate' c0 c1 loc t \\<Longrightarrow> P c1)\"\n    and   \"P c0\"\n    and   \"propagate_all c0 = Some c1\"\n  shows   \"P c1\"", "lemma next_imp_exchange_next:\n  \"Next' c0 c1 \\<Longrightarrow> cri.next' (exchange_config c0) (exchange_config c1)\"", "lemma alw_next_imp_exchange_next: \"alw Next s \\<Longrightarrow> alw cri.next (smap exchange_config s)\"", "lemma spec_imp_exchange_spec: \"FullSpec s \\<Longrightarrow> cri.spec (smap exchange_config s)\"", "lemma lift_exchange_invariant:\n  assumes \"\\<And>s. cri.spec s \\<Longrightarrow> alw (holds P) s\"\n  shows   \"FullSpec s \\<Longrightarrow> alw (\\<lambda>s. P (exchange_config (shd s))) s\"", "lemmas\n  exch_alw_InvCapsNonneg                 = lift_exchange_invariant[OF cri.alw_InvCapsNonneg, unfolded atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvRecordCount                = lift_exchange_invariant[OF cri.alw_InvRecordCount, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvRecordsNonneg              = lift_exchange_invariant[OF cri.alw_InvRecordsNonneg, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvGlobVacantImpRecordsVacant = lift_exchange_invariant[OF cri.alw_InvGlobVacantImpRecordsVacant, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvGlobNonposImpRecordsNonpos = lift_exchange_invariant[OF cri.alw_InvGlobNonposImpRecordsNonpos, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvJustifiedGII               = lift_exchange_invariant[OF cri.alw_InvJustifiedGII, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvJustifiedII                = lift_exchange_invariant[OF cri.alw_InvJustifiedII, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvGlobNonposEqVacant         = lift_exchange_invariant[OF cri.alw_InvGlobNonposEqVacant, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvMsgInGlob                  = lift_exchange_invariant[OF cri.alw_InvMsgInGlob, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvTempJustified              = lift_exchange_invariant[OF cri.alw_InvTempJustified, simplified atomize_imp, simplified, folded atomize_imp]", "lemma safe_combined_implies_safe_combined2:\n  assumes \"cri.InvCapsNonneg (exchange_config c)\"\n    and   \"safe_combined c\"\n  shows   \"safe_combined2 c\"", "lemma msg_is_cm_safe:\n  fixes c :: \"('p::finite, 't::order, 'loc) configuration\"\n  assumes \"safe (prop_config c q)\"\n    and   \"InvGlobPointstampsEq c\"\n    and   \"cri.InvMsgInGlob (exchange_config c)\"\n    and   \"c_msg (exchange_config c) p q \\<noteq> []\"\n  shows   \"\\<forall>(loc,t) \\<in>#\\<^sub>z (hd (c_msg (exchange_config c) p q)). \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp (prop_config c q) loc) \\<and> t' \\<le> t\"", "lemma NextRecvUpd'_preserves_prop_safe:\n  assumes \"prop_safe (prop_config c0 q)\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"cri.InvMsgInGlob (exchange_config c0)\"\n    and   \"NextRecvUpd' c0 c1 p q\"\n  shows   \"prop_safe (prop_config c1 q)\"", "lemma NextRecvUpd'_preserves_InvGlobPointstampsEq:\n  assumes \"impl_safe (prop_config c0 q) \\<and> safe (prop_config c0 q)\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"cri.InvMsgInGlob (exchange_config c0)\"\n    and   \"NextRecvUpd' c0 c1 p q\"\n  shows   \"InvGlobPointstampsEq c1\"", "lemma NextPropagate'_causes_safe:\n  assumes \"NextPropagate' c0 c1 p\"\n    and   \"inv_imps_work_sum (prop_config c1 p)\"\n    and   \"inv_implications_nonneg (prop_config c1 p)\"\n  shows   \"safe (prop_config c1 p)\" \"impl_safe (prop_config c1 p)\"", "lemma NextPropagate'_preserves_safe:\n  assumes \"NextPropagate' c0 c1 q\"\n    and   \"inv_imps_work_sum (prop_config c1 p)\"\n    and   \"inv_implications_nonneg (prop_config c1 p)\"\n    and   \"safe (prop_config c0 p)\"\n  shows   \"safe (prop_config c1 p)\"", "lemma NextPropagate'_preserves_impl_safe:\n  assumes \"NextPropagate' c0 c1 q\"\n    and   \"inv_imps_work_sum (prop_config c1 p)\"\n    and   \"inv_implications_nonneg (prop_config c1 p)\"\n    and   \"impl_safe (prop_config c0 p)\"\n  shows   \"impl_safe (prop_config c1 p)\"", "lemma NextRecvUpd'_preserves_inv_init_imp_prop_safe:\n  assumes \"cri.InvMsgInGlob (exchange_config c0)\"\n    and   \"inv_init_imp_prop_safe c0\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"NextRecvUpd' c0 c1 p q\"\n  shows   \"inv_init_imp_prop_safe c1\"", "lemma NextRecvUpd'_preserves_prop_invs:\n  assumes \"cri.InvMsgInGlob (exchange_config c0)\"\n    and   \"inv_init_imp_prop_safe c0\"\n    and   \"\\<forall>p. prop_invs (prop_config c0 p)\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"NextRecvUpd' c0 c1 p q\"\n  shows   \"\\<forall>p. prop_invs (prop_config c1 p)\"", "lemma NextPropagate'_preserves_prop_invs:\n  assumes \"prop_invs (prop_config c0 q)\"\n    and   \"NextPropagate' c0 c1 p\"\n  shows   \"prop_invs (prop_config c1 q)\"", "lemma NextPropagate'_preserves_inv_init_imp_prop_safe:\n  assumes \"prop_invs (prop_config c0 p)\"\n    and   \"inv_init_imp_prop_safe c0\"\n    and   \"NextPropagate' c0 c1 p\"\n  shows   \"inv_init_imp_prop_safe c1\"", "lemma Next'_preserves_invs:\n  assumes \"cri.InvMsgInGlob (exchange_config c0)\"\n    and   \"inv_init_imp_prop_safe c0\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"Next' c0 c1\"\n    and   \"\\<forall>p. prop_invs (prop_config c0 p)\"\n  shows\n    \"inv_init_imp_prop_safe c1\"\n    \"\\<forall>p. prop_invs (prop_config c1 p)\"\n    \"InvGlobPointstampsEq c1\"", "lemma init_imp_InvGlobPointstampsEq: \"InitConfig c \\<Longrightarrow> InvGlobPointstampsEq c\"", "lemma init_imp_inv_init_imp_prop_safe: \"InitConfig c \\<Longrightarrow> inv_init_imp_prop_safe c\"", "lemma init_imp_prop_invs: \"InitConfig c \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c p)\"", "lemma alw_Next'_alw_invs:\n  assumes \"holds all_invs s\"\n    and   \"alw (holds (\\<lambda>c. cri.InvMsgInGlob (exchange_config c))) s\"\n    and   \"alw Next s\"\n  shows   \"alw (holds all_invs) s\"", "lemma alw_invs: \"FullSpec s \\<Longrightarrow> alw (holds all_invs) s\"", "lemma alw_InvGlobPointstampsEq: \"FullSpec s \\<Longrightarrow> alw (holds InvGlobPointstampsEq) s\"", "lemma alw_inv_init_imp_prop_safe: \"FullSpec s \\<Longrightarrow> alw (holds inv_init_imp_prop_safe) s\"", "lemma alw_holds_conv_shd: \"alw (holds \\<phi>) s = alw (\\<lambda>s. \\<phi> (shd s)) s\"", "lemma alw_prop_invs: \"FullSpec s \\<Longrightarrow> alw (holds (\\<lambda>c. \\<forall>p. prop_invs (prop_config c p))) s\"", "lemma nrec_pts_delayed:\n  assumes \"cri.InvGlobNonposImpRecordsNonpos (exchange_config c)\"\n    and \"zcount (cri.records (exchange_config c)) x > 0\"\n  shows \"\\<exists>x'. x' \\<le>\\<^sub>p x \\<and> zcount (c_glob (exchange_config c) p) x' > 0\"", "lemma help_lemma:\n  assumes \"0 < zcount (c_pts (prop_config c p) loc0) t0\"\n    and \"(loc0, t0) \\<le>\\<^sub>p (loc1, t1)\"\n    and \"s2 \\<in>\\<^sub>A path_summary loc1 loc2\"\n    and \"safe (prop_config c p)\"\n  shows \"\\<exists> t2. (t2 \\<le> results_in t1 s2\n                \\<and> t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2))\"", "lemma lift_prop_inv_NextPropagate':\n  assumes \"(\\<And>c0 c1 loc t. P c0 \\<Longrightarrow> next_propagate' c0 c1 loc t \\<Longrightarrow> P c1)\"\n  shows   \"P (prop_config c0 p') \\<Longrightarrow> NextPropagate' c0 c1 p \\<Longrightarrow> P (prop_config c1 p')\"", "lemma NextRecvUpd'_next':\n  assumes \"safe (prop_config c0 q)\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"cri.InvMsgInGlob (exchange_config c0)\"\n    and   \"NextRecvUpd' c0 c1 p q\"\n  shows   \"next'\\<^sup>+\\<^sup>+ (prop_config c0 q') (prop_config c1 q')\"", "lemma NextPropagate'_next':\n  assumes \"NextPropagate' c0 c1 p\"\n  shows   \"next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c1 q)\"", "lemma next_imp_propagate_next:\n  assumes \"inv_init_imp_prop_safe c0\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"cri.InvMsgInGlob (exchange_config c0)\"\n  shows   \"Next' c0 c1 \\<Longrightarrow> next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)\"", "lemma alw_next_imp_propagate_next:\n  assumes \"alw (holds inv_init_imp_prop_safe) s\"\n    and   \"alw (holds InvGlobPointstampsEq) s\"\n    and   \"alw (holds cri.InvMsgInGlob) (smap exchange_config s)\"\n    and   \"alw Next s\"\n  shows   \"alw (relates (next'\\<^sup>+\\<^sup>+)) (smap (\\<lambda>s. prop_config s p) s)\"", "lemma spec_imp_propagate_spec: \"FullSpec s \\<Longrightarrow> (holds init_config aand alw (relates (next'\\<^sup>+\\<^sup>+))) (smap (\\<lambda>c. prop_config c p) s)\"", "lemma safe_satisfied:\n  assumes \"cri.InvGlobNonposImpRecordsNonpos (exchange_config c)\"\n    and \"inv_init_imp_prop_safe c\"\n    and \"InvGlobPointstampsEq c\"\n  shows \"safe_combined c\"", "lemma alw_safe_combined: \"FullSpec s \\<Longrightarrow> alw (holds safe_combined) s\"", "lemma alw_safe_combined2: \"FullSpec s \\<Longrightarrow> alw (holds safe_combined2) s\"", "lemma alw_implication_frontier_eq_implied_frontier:\n  \"FullSpec s \\<Longrightarrow> \n    alw (holds (\\<lambda>c. worklists_vacant_to (prop_config c p) b \\<longrightarrow>\n      b \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc) \\<longleftrightarrow> b \\<in>\\<^sub>A implied_frontier (c_pts (prop_config c p)) loc)) s\""], "translations": [["", "lemma fold_invar:\n  assumes \"finite M\"\n    and   \"P z\"\n    and   \"\\<forall>z. \\<forall>x\\<in>M. P z \\<longrightarrow> P (f x z)\"\n    and   \"comp_fun_commute f\"\n  shows   \"P (Finite_Set.fold f z M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (Finite_Set.fold f z M)", "using assms"], ["proof (prove)\nusing this:\n  finite M\n  P z\n  \\<forall>z. \\<forall>x\\<in>M. P z \\<longrightarrow> P (f x z)\n  comp_fun_commute f\n\ngoal (1 subgoal):\n 1. P (Finite_Set.fold f z M)", "by (induct M arbitrary: z rule: finite_induct) (auto simp: comp_fun_commute.fold_insert)"], ["", "subsection\\<open>Could-result-in Relation\\<close>"], ["", "context dataflow_topology begin"], ["", "definition cri_less_eq :: \"('loc \\<times> 't) \\<Rightarrow> ('loc \\<times> 't) \\<Rightarrow> bool\" (\"_\\<le>\\<^sub>p_\" [51,51] 50) where\n  \"cri_less_eq =\n    (\\<lambda>(loc1,t1) (loc2,t2). (\\<exists>s. s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and> results_in t1 s \\<le> t2))\""], ["", "definition cri_less :: \"('loc \\<times> 't) \\<Rightarrow> ('loc \\<times> 't) \\<Rightarrow> bool\" (\"_<\\<^sub>p_\" [51,51] 50) where\n  \"cri_less x y = (x \\<le>\\<^sub>p y \\<and> x \\<noteq> y)\""], ["", "lemma cri_asym1: \"x <\\<^sub>p y \\<longrightarrow> \\<not> y <\\<^sub>p x\"\n  for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px", "apply (cases x; cases y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba);\n        \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\\<rbrakk>\n       \\<Longrightarrow> False", "fix loc1 t1 loc2 t2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba);\n        \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\\<rbrakk>\n       \\<Longrightarrow> False", "assume as: \"\\<not> (x <\\<^sub>p y \\<longrightarrow> \\<not> y <\\<^sub>p x)\" \"x = (loc1, t1)\" \"y = (loc2, t2)\""], ["proof (state)\nthis:\n  \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\n  x = (loc1, t1)\n  y = (loc2, t2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba);\n        \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\n  x = (loc1, t1)\n  y = (loc2, t2)", "have as1: \"loc1 \\<noteq> loc2\""], ["proof (prove)\nusing this:\n  \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\n  x = (loc1, t1)\n  y = (loc2, t2)\n\ngoal (1 subgoal):\n 1. loc1 \\<noteq> loc2", "unfolding cri_less_def cri_less_eq_def"], ["proof (prove)\nusing this:\n  \\<not> ((case x of\n           (loc1, t1) \\<Rightarrow>\n             \\<lambda>(loc2, t2).\n                \\<exists>s.\n                   s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                   results_in t1 s \\<le> t2)\n           y \\<and>\n          x \\<noteq> y \\<longrightarrow>\n          \\<not> ((case y of\n                   (loc1, t1) \\<Rightarrow>\n                     \\<lambda>(loc2, t2).\n                        \\<exists>s.\n                           s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                           results_in t1 s \\<le> t2)\n                   x \\<and>\n                  y \\<noteq> x))\n  x = (loc1, t1)\n  y = (loc2, t2)\n\ngoal (1 subgoal):\n 1. loc1 \\<noteq> loc2", "by clarsimp\n      (metis add.right_neutral order.antisym order.trans le_plus(2) results_in_mono(2) results_in_zero)"], ["proof (state)\nthis:\n  loc1 \\<noteq> loc2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba);\n        \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\\<rbrakk>\n       \\<Longrightarrow> False", "from as"], ["proof (chain)\npicking this:\n  \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\n  x = (loc1, t1)\n  y = (loc2, t2)", "obtain s1 where s1: \"s1 \\<in>\\<^sub>A path_summary loc1 loc2\"\n    \"results_in t1 s1 \\<le> t2\""], ["proof (prove)\nusing this:\n  \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\n  x = (loc1, t1)\n  y = (loc2, t2)\n\ngoal (1 subgoal):\n 1. (\\<And>s1.\n        \\<lbrakk>s1 \\<in>\\<^sub>A path_summary loc1 loc2;\n         results_in t1 s1 \\<le> t2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cri_less_def cri_less_eq_def"], ["proof (prove)\nusing this:\n  \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\n  x = (loc1, t1)\n  y = (loc2, t2)\n  (?x<\\<^sub>p?y) = (?x\\<le>\\<^sub>p?y \\<and> ?x \\<noteq> ?y)\n  cri_less_eq =\n  (\\<lambda>(loc1, t1) (loc2, t2).\n      \\<exists>s.\n         s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n         results_in t1 s \\<le> t2)\n\ngoal (1 subgoal):\n 1. (\\<And>s1.\n        \\<lbrakk>s1 \\<in>\\<^sub>A path_summary loc1 loc2;\n         results_in t1 s1 \\<le> t2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s1 \\<in>\\<^sub>A path_summary loc1 loc2\n  results_in t1 s1 \\<le> t2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba);\n        \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  s1 \\<in>\\<^sub>A path_summary loc1 loc2\n  results_in t1 s1 \\<le> t2", "obtain path1 where path1: \"flow.path loc1 loc2 path1\"\n    \"s1 = flow.sum_path_weights path1\"\n    \"path1 \\<noteq> []\""], ["proof (prove)\nusing this:\n  s1 \\<in>\\<^sub>A path_summary loc1 loc2\n  results_in t1 s1 \\<le> t2\n\ngoal (1 subgoal):\n 1. (\\<And>path1.\n        \\<lbrakk>path loc1 loc2 path1;\n         s1 = sum_weights (map (\\<lambda>(s, l, t). l) path1);\n         path1 \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using as1 flow.path_weight_conv_path flow.path0E"], ["proof (prove)\nusing this:\n  s1 \\<in>\\<^sub>A path_summary loc1 loc2\n  results_in t1 s1 \\<le> t2\n  loc1 \\<noteq> loc2\n  ?s \\<in>\\<^sub>A path_summary ?l1.0 ?l2.0 \\<Longrightarrow>\n  \\<exists>xs.\n     path ?l1.0 ?l2.0 xs \\<and>\n     ?s = sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<and>\n     (\\<forall>ys.\n         path ?l1.0 ?l2.0 ys \\<longrightarrow>\n         \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ys)\n                < sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  \\<lbrakk>path ?l1.0 ?l2.0 []; ?l2.0 = ?l1.0 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>path1.\n        \\<lbrakk>path loc1 loc2 path1;\n         s1 = sum_weights (map (\\<lambda>(s, l, t). l) path1);\n         path1 \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path loc1 loc2 path1\n  s1 = sum_weights (map (\\<lambda>(s, l, t). l) path1)\n  path1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba);\n        \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\\<rbrakk>\n       \\<Longrightarrow> False", "from as"], ["proof (chain)\npicking this:\n  \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\n  x = (loc1, t1)\n  y = (loc2, t2)", "obtain s2 where s2: \"s2 \\<in>\\<^sub>A path_summary loc2 loc1\"\n    \"results_in t2 s2 \\<le> t1\""], ["proof (prove)\nusing this:\n  \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\n  x = (loc1, t1)\n  y = (loc2, t2)\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>s2 \\<in>\\<^sub>A path_summary loc2 loc1;\n         results_in t2 s2 \\<le> t1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cri_less_def cri_less_eq_def"], ["proof (prove)\nusing this:\n  \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\n  x = (loc1, t1)\n  y = (loc2, t2)\n  (?x<\\<^sub>p?y) = (?x\\<le>\\<^sub>p?y \\<and> ?x \\<noteq> ?y)\n  cri_less_eq =\n  (\\<lambda>(loc1, t1) (loc2, t2).\n      \\<exists>s.\n         s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n         results_in t1 s \\<le> t2)\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>s2 \\<in>\\<^sub>A path_summary loc2 loc1;\n         results_in t2 s2 \\<le> t1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s2 \\<in>\\<^sub>A path_summary loc2 loc1\n  results_in t2 s2 \\<le> t1\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba);\n        \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  s2 \\<in>\\<^sub>A path_summary loc2 loc1\n  results_in t2 s2 \\<le> t1", "obtain path2 where path2: \"flow.path loc2 loc1 path2\"\n    \"s2 = flow.sum_path_weights path2\"\n    \"path2 \\<noteq> []\""], ["proof (prove)\nusing this:\n  s2 \\<in>\\<^sub>A path_summary loc2 loc1\n  results_in t2 s2 \\<le> t1\n\ngoal (1 subgoal):\n 1. (\\<And>path2.\n        \\<lbrakk>path loc2 loc1 path2;\n         s2 = sum_weights (map (\\<lambda>(s, l, t). l) path2);\n         path2 \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using as1 flow.path_weight_conv_path flow.path0E"], ["proof (prove)\nusing this:\n  s2 \\<in>\\<^sub>A path_summary loc2 loc1\n  results_in t2 s2 \\<le> t1\n  loc1 \\<noteq> loc2\n  ?s \\<in>\\<^sub>A path_summary ?l1.0 ?l2.0 \\<Longrightarrow>\n  \\<exists>xs.\n     path ?l1.0 ?l2.0 xs \\<and>\n     ?s = sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<and>\n     (\\<forall>ys.\n         path ?l1.0 ?l2.0 ys \\<longrightarrow>\n         \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ys)\n                < sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  \\<lbrakk>path ?l1.0 ?l2.0 []; ?l2.0 = ?l1.0 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>path2.\n        \\<lbrakk>path loc2 loc1 path2;\n         s2 = sum_weights (map (\\<lambda>(s, l, t). l) path2);\n         path2 \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path loc2 loc1 path2\n  s2 = sum_weights (map (\\<lambda>(s, l, t). l) path2)\n  path2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba);\n        \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\\<rbrakk>\n       \\<Longrightarrow> False", "with path1"], ["proof (chain)\npicking this:\n  path loc1 loc2 path1\n  s1 = sum_weights (map (\\<lambda>(s, l, t). l) path1)\n  path1 \\<noteq> []\n  path loc2 loc1 path2\n  s2 = sum_weights (map (\\<lambda>(s, l, t). l) path2)\n  path2 \\<noteq> []", "have path_total: \"flow.path loc1 loc1 (path1@path2)\""], ["proof (prove)\nusing this:\n  path loc1 loc2 path1\n  s1 = sum_weights (map (\\<lambda>(s, l, t). l) path1)\n  path1 \\<noteq> []\n  path loc2 loc1 path2\n  s2 = sum_weights (map (\\<lambda>(s, l, t). l) path2)\n  path2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. path loc1 loc1 (path1 @ path2)", "using flow.path_trans path2(3)"], ["proof (prove)\nusing this:\n  path loc1 loc2 path1\n  s1 = sum_weights (map (\\<lambda>(s, l, t). l) path1)\n  path1 \\<noteq> []\n  path loc2 loc1 path2\n  s2 = sum_weights (map (\\<lambda>(s, l, t). l) path2)\n  path2 \\<noteq> []\n  \\<lbrakk>path ?l1.0 ?l2.0 ?xs; path ?l2.0 ?l3.0 ?ys\\<rbrakk>\n  \\<Longrightarrow> path ?l1.0 ?l3.0 (?xs @ ?ys)\n  path2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. path loc1 loc1 (path1 @ path2)", "by blast"], ["proof (state)\nthis:\n  path loc1 loc1 (path1 @ path2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba);\n        \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path loc1 loc1 (path1 @ path2)", "obtain s3 where s3: \"s3 = flow.sum_path_weights (path1@path2)\""], ["proof (prove)\nusing this:\n  path loc1 loc1 (path1 @ path2)\n\ngoal (1 subgoal):\n 1. (\\<And>s3.\n        s3 =\n        sum_weights\n         (map (\\<lambda>(s, l, t). l) (path1 @ path2)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s3 = sum_weights (map (\\<lambda>(s, l, t). l) (path1 @ path2))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba);\n        \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  s3 = sum_weights (map (\\<lambda>(s, l, t). l) (path1 @ path2))", "have s3_sum: \"s3 = followed_by s1 s2\""], ["proof (prove)\nusing this:\n  s3 = sum_weights (map (\\<lambda>(s, l, t). l) (path1 @ path2))\n\ngoal (1 subgoal):\n 1. s3 = followed_by s1 s2", "using path1 path2 flow.sum_weights_append"], ["proof (prove)\nusing this:\n  s3 = sum_weights (map (\\<lambda>(s, l, t). l) (path1 @ path2))\n  path loc1 loc2 path1\n  s1 = sum_weights (map (\\<lambda>(s, l, t). l) path1)\n  path1 \\<noteq> []\n  path loc2 loc1 path2\n  s2 = sum_weights (map (\\<lambda>(s, l, t). l) path2)\n  path2 \\<noteq> []\n  sum_weights (?ys @ ?xs) = followed_by (sum_weights ?ys) (sum_weights ?xs)\n\ngoal (1 subgoal):\n 1. s3 = followed_by s1 s2", "by auto"], ["proof (state)\nthis:\n  s3 = followed_by s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba);\n        \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<not> t1 < results_in t1 s3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t1 < results_in t1 s3", "using s3_sum s1(2) s2(2) followed_by_summary"], ["proof (prove)\nusing this:\n  s3 = followed_by s1 s2\n  results_in t1 s1 \\<le> t2\n  results_in t2 s2 \\<le> t1\n  results_in (results_in ?t ?s1.0) ?s2.0 =\n  results_in ?t (followed_by ?s1.0 ?s2.0)\n\ngoal (1 subgoal):\n 1. \\<not> t1 < results_in t1 s3", "by (metis le_less_trans less_le_not_le results_in_mono(1))"], ["proof (state)\nthis:\n  \\<not> t1 < results_in t1 s3\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba);\n        \\<not> (x<\\<^sub>py \\<longrightarrow> \\<not> y<\\<^sub>px)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> t1 < results_in t1 s3", "show False"], ["proof (prove)\nusing this:\n  \\<not> t1 < results_in t1 s3\n\ngoal (1 subgoal):\n 1. False", "using path_total no_zero_cycle s3 path1(3) path2(3)"], ["proof (prove)\nusing this:\n  \\<not> t1 < results_in t1 s3\n  path loc1 loc1 (path1 @ path2)\n  \\<lbrakk>path ?loc ?loc ?xs; ?xs \\<noteq> [];\n   ?s = sum_weights (map (\\<lambda>(s, l, t). l) ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?t < results_in ?t ?s\n  s3 = sum_weights (map (\\<lambda>(s, l, t). l) (path1 @ path2))\n  path1 \\<noteq> []\n  path2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cri_asym2: \"x <\\<^sub>p y \\<longrightarrow> x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x<\\<^sub>py \\<longrightarrow> x \\<noteq> y", "by (simp add: cri_less_def)"], ["", "sublocale cri: order cri_less_eq cri_less"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.order cri_less_eq cri_less", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       (x<\\<^sub>py) = (x\\<le>\\<^sub>py \\<and> \\<not> y\\<le>\\<^sub>px)\n 2. \\<And>x. x\\<le>\\<^sub>px\n 3. \\<And>x y z.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>pz\\<rbrakk>\n       \\<Longrightarrow> x\\<le>\\<^sub>pz\n 4. \\<And>x y.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>px\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x_<\\<^sub>py_) = (x_\\<le>\\<^sub>py_ \\<and> \\<not> y_\\<le>\\<^sub>px_)", "using cri_asym1 cri_asym2 cri_less_def"], ["proof (prove)\nusing this:\n  ?x<\\<^sub>p?y \\<longrightarrow> \\<not> ?y<\\<^sub>p?x\n  ?x<\\<^sub>p?y \\<longrightarrow> ?x \\<noteq> ?y\n  (?x<\\<^sub>p?y) = (?x\\<le>\\<^sub>p?y \\<and> ?x \\<noteq> ?y)\n\ngoal (1 subgoal):\n 1. (x_<\\<^sub>py_) = (x_\\<le>\\<^sub>py_ \\<and> \\<not> y_\\<le>\\<^sub>px_)", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x\\<le>\\<^sub>px\n 2. \\<And>x y z.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>pz\\<rbrakk>\n       \\<Longrightarrow> x\\<le>\\<^sub>pz\n 3. \\<And>x y.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>px\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<le>\\<^sub>px", "unfolding cri_less_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of\n     (loc1, t1) \\<Rightarrow>\n       \\<lambda>(loc2, t2).\n          \\<exists>s.\n             s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n             results_in t1 s \\<le> t2)\n     x", "using flow.path_weight_refl results_in_zero"], ["proof (prove)\nusing this:\n  (0::'sum) \\<in>\\<^sub>A path_summary ?loc ?loc\n  results_in ?t (0::'sum) = ?t\n\ngoal (1 subgoal):\n 1. (case x of\n     (loc1, t1) \\<Rightarrow>\n       \\<lambda>(loc2, t2).\n          \\<exists>s.\n             s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n             results_in t1 s \\<le> t2)\n     x", "by fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>pz\\<rbrakk>\n       \\<Longrightarrow> x\\<le>\\<^sub>pz\n 2. \\<And>x y.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>px\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal\n    for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>pz\\<rbrakk>\n    \\<Longrightarrow> x\\<le>\\<^sub>pz", "apply (cases x; cases y; cases z)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>pz; x = (a, b); y = (aa, ba);\n        z = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> x\\<le>\\<^sub>pz", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>pz; x = (a, b); y = (aa, ba);\n        z = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> x\\<le>\\<^sub>pz", "fix a b aa ba ab bb"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>pz; x = (a, b); y = (aa, ba);\n        z = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> x\\<le>\\<^sub>pz", "assume as: \"x \\<le>\\<^sub>p y\" \"y \\<le>\\<^sub>p z\" \"x = (a, b)\" \"y = (aa, ba)\" \"z = (ab, bb)\""], ["proof (state)\nthis:\n  x\\<le>\\<^sub>py\n  y\\<le>\\<^sub>pz\n  x = (a, b)\n  y = (aa, ba)\n  z = (ab, bb)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>pz; x = (a, b); y = (aa, ba);\n        z = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> x\\<le>\\<^sub>pz", "then"], ["proof (chain)\npicking this:\n  x\\<le>\\<^sub>py\n  y\\<le>\\<^sub>pz\n  x = (a, b)\n  y = (aa, ba)\n  z = (ab, bb)", "obtain s1 where s1: \"s1 \\<in>\\<^sub>A path_summary a aa\" \"results_in b s1 \\<le> ba\""], ["proof (prove)\nusing this:\n  x\\<le>\\<^sub>py\n  y\\<le>\\<^sub>pz\n  x = (a, b)\n  y = (aa, ba)\n  z = (ab, bb)\n\ngoal (1 subgoal):\n 1. (\\<And>s1.\n        \\<lbrakk>s1 \\<in>\\<^sub>A path_summary a aa;\n         results_in b s1 \\<le> ba\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cri_less_eq_def"], ["proof (prove)\nusing this:\n  x\\<le>\\<^sub>py\n  y\\<le>\\<^sub>pz\n  x = (a, b)\n  y = (aa, ba)\n  z = (ab, bb)\n  cri_less_eq =\n  (\\<lambda>(loc1, t1) (loc2, t2).\n      \\<exists>s.\n         s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n         results_in t1 s \\<le> t2)\n\ngoal (1 subgoal):\n 1. (\\<And>s1.\n        \\<lbrakk>s1 \\<in>\\<^sub>A path_summary a aa;\n         results_in b s1 \\<le> ba\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s1 \\<in>\\<^sub>A path_summary a aa\n  results_in b s1 \\<le> ba\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>pz; x = (a, b); y = (aa, ba);\n        z = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> x\\<le>\\<^sub>pz", "from as(2,4,5)"], ["proof (chain)\npicking this:\n  y\\<le>\\<^sub>pz\n  y = (aa, ba)\n  z = (ab, bb)", "obtain s2 where s2: \"s2 \\<in>\\<^sub>A path_summary aa ab\" \"results_in ba s2 \\<le> bb\""], ["proof (prove)\nusing this:\n  y\\<le>\\<^sub>pz\n  y = (aa, ba)\n  z = (ab, bb)\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>s2 \\<in>\\<^sub>A path_summary aa ab;\n         results_in ba s2 \\<le> bb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cri_less_eq_def"], ["proof (prove)\nusing this:\n  y\\<le>\\<^sub>pz\n  y = (aa, ba)\n  z = (ab, bb)\n  cri_less_eq =\n  (\\<lambda>(loc1, t1) (loc2, t2).\n      \\<exists>s.\n         s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n         results_in t1 s \\<le> t2)\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>s2 \\<in>\\<^sub>A path_summary aa ab;\n         results_in ba s2 \\<le> bb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s2 \\<in>\\<^sub>A path_summary aa ab\n  results_in ba s2 \\<le> bb\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>pz; x = (a, b); y = (aa, ba);\n        z = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> x\\<le>\\<^sub>pz", "with s1"], ["proof (chain)\npicking this:\n  s1 \\<in>\\<^sub>A path_summary a aa\n  results_in b s1 \\<le> ba\n  s2 \\<in>\\<^sub>A path_summary aa ab\n  results_in ba s2 \\<le> bb", "obtain s3 where s3: \"s3 \\<in>\\<^sub>A path_summary a ab\" \"s3 \\<le> followed_by s1 s2\""], ["proof (prove)\nusing this:\n  s1 \\<in>\\<^sub>A path_summary a aa\n  results_in b s1 \\<le> ba\n  s2 \\<in>\\<^sub>A path_summary aa ab\n  results_in ba s2 \\<le> bb\n\ngoal (1 subgoal):\n 1. (\\<And>s3.\n        \\<lbrakk>s3 \\<in>\\<^sub>A path_summary a ab;\n         s3 \\<le> followed_by s1 s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using flow.path_weight_elem_trans"], ["proof (prove)\nusing this:\n  s1 \\<in>\\<^sub>A path_summary a aa\n  results_in b s1 \\<le> ba\n  s2 \\<in>\\<^sub>A path_summary aa ab\n  results_in ba s2 \\<le> bb\n  \\<lbrakk>?s \\<in>\\<^sub>A path_summary ?l1.0 ?l2.0;\n   ?s' \\<in>\\<^sub>A path_summary ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u.\n                       u \\<in>\\<^sub>A path_summary ?l1.0 ?l3.0 \\<and>\n                       u \\<le> followed_by ?s ?s'\n\ngoal (1 subgoal):\n 1. (\\<And>s3.\n        \\<lbrakk>s3 \\<in>\\<^sub>A path_summary a ab;\n         s3 \\<le> followed_by s1 s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s3 \\<in>\\<^sub>A path_summary a ab\n  s3 \\<le> followed_by s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>pz; x = (a, b); y = (aa, ba);\n        z = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> x\\<le>\\<^sub>pz", "with s1 s2"], ["proof (chain)\npicking this:\n  s1 \\<in>\\<^sub>A path_summary a aa\n  results_in b s1 \\<le> ba\n  s2 \\<in>\\<^sub>A path_summary aa ab\n  results_in ba s2 \\<le> bb\n  s3 \\<in>\\<^sub>A path_summary a ab\n  s3 \\<le> followed_by s1 s2", "have \"results_in b s3 \\<le> bb\""], ["proof (prove)\nusing this:\n  s1 \\<in>\\<^sub>A path_summary a aa\n  results_in b s1 \\<le> ba\n  s2 \\<in>\\<^sub>A path_summary aa ab\n  results_in ba s2 \\<le> bb\n  s3 \\<in>\\<^sub>A path_summary a ab\n  s3 \\<le> followed_by s1 s2\n\ngoal (1 subgoal):\n 1. results_in b s3 \\<le> bb", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<in>\\<^sub>A path_summary a aa; results_in b s1 \\<le> ba;\n     s2 \\<in>\\<^sub>A path_summary aa ab; results_in ba s2 \\<le> bb;\n     s3 \\<in>\\<^sub>A path_summary a ab; s3 \\<le> followed_by s1 s2\\<rbrakk>\n    \\<Longrightarrow> results_in b s3 \\<le> bb", "have \"\\<forall>s. results_in (results_in b s1) s \\<le> results_in ba s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. results_in (results_in b s1) s \\<le> results_in ba s", "by (meson results_in_mono(1) s1(2))"], ["proof (state)\nthis:\n  \\<forall>s. results_in (results_in b s1) s \\<le> results_in ba s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<in>\\<^sub>A path_summary a aa; results_in b s1 \\<le> ba;\n     s2 \\<in>\\<^sub>A path_summary aa ab; results_in ba s2 \\<le> bb;\n     s3 \\<in>\\<^sub>A path_summary a ab; s3 \\<le> followed_by s1 s2\\<rbrakk>\n    \\<Longrightarrow> results_in b s3 \\<le> bb", "then"], ["proof (chain)\npicking this:\n  \\<forall>s. results_in (results_in b s1) s \\<le> results_in ba s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>s. results_in (results_in b s1) s \\<le> results_in ba s\n\ngoal (1 subgoal):\n 1. results_in b s3 \\<le> bb", "by (metis (no_types) results_in_mono(2) followed_by_summary order_trans s2(2) s3(2))"], ["proof (state)\nthis:\n  results_in b s3 \\<le> bb\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  results_in b s3 \\<le> bb\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>pz; x = (a, b); y = (aa, ba);\n        z = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> x\\<le>\\<^sub>pz", "with as s3"], ["proof (chain)\npicking this:\n  x\\<le>\\<^sub>py\n  y\\<le>\\<^sub>pz\n  x = (a, b)\n  y = (aa, ba)\n  z = (ab, bb)\n  s3 \\<in>\\<^sub>A path_summary a ab\n  s3 \\<le> followed_by s1 s2\n  results_in b s3 \\<le> bb", "show ?thesis"], ["proof (prove)\nusing this:\n  x\\<le>\\<^sub>py\n  y\\<le>\\<^sub>pz\n  x = (a, b)\n  y = (aa, ba)\n  z = (ab, bb)\n  s3 \\<in>\\<^sub>A path_summary a ab\n  s3 \\<le> followed_by s1 s2\n  results_in b s3 \\<le> bb\n\ngoal (1 subgoal):\n 1. x\\<le>\\<^sub>pz", "unfolding cri_less_eq_def"], ["proof (prove)\nusing this:\n  (case x of\n   (loc1, t1) \\<Rightarrow>\n     \\<lambda>(loc2, t2).\n        \\<exists>s.\n           s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n           results_in t1 s \\<le> t2)\n   y\n  (case y of\n   (loc1, t1) \\<Rightarrow>\n     \\<lambda>(loc2, t2).\n        \\<exists>s.\n           s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n           results_in t1 s \\<le> t2)\n   z\n  x = (a, b)\n  y = (aa, ba)\n  z = (ab, bb)\n  s3 \\<in>\\<^sub>A path_summary a ab\n  s3 \\<le> followed_by s1 s2\n  results_in b s3 \\<le> bb\n\ngoal (1 subgoal):\n 1. (case x of\n     (loc1, t1) \\<Rightarrow>\n       \\<lambda>(loc2, t2).\n          \\<exists>s.\n             s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n             results_in t1 s \\<le> t2)\n     z", "by blast"], ["proof (state)\nthis:\n  x\\<le>\\<^sub>pz\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>px\\<rbrakk>\n       \\<Longrightarrow> x = y", "using cri_asym1 cri_asym2 cri_less_def"], ["proof (prove)\nusing this:\n  ?x<\\<^sub>p?y \\<longrightarrow> \\<not> ?y<\\<^sub>p?x\n  ?x<\\<^sub>p?y \\<longrightarrow> ?x \\<noteq> ?y\n  (?x<\\<^sub>p?y) = (?x\\<le>\\<^sub>p?y \\<and> ?x \\<noteq> ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x\\<le>\\<^sub>py; y\\<le>\\<^sub>px\\<rbrakk>\n       \\<Longrightarrow> x = y", "by blast"], ["", "lemma wf_cri: \"wf {(l, l'). (l, t) <\\<^sub>p (l', t)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(l, l'). (l, t)<\\<^sub>p(l', t)}", "by (rule finite_acyclic_wf)\n    (auto intro: cri.acyclicI_order[THEN acyclic_converse[THEN iffD1]])"], ["", "end"], ["", "subsection\\<open>Specification\\<close>"], ["", "subsubsection\\<open>Configuration\\<close>"], ["", "record ('p::finite, 't::order, 'loc) configuration =\n  exchange_config :: \"('p, ('loc \\<times> 't)) Exchange.configuration\"\n  prop_config :: \"'p \\<Rightarrow> ('loc, 't) Propagate.configuration\"\n  init :: \"'p \\<Rightarrow> bool\""], ["", "(* True = initialization finished *)"], ["", "type_synonym ('p, 't, 'loc) computation = \"('p, 't, 'loc) configuration stream\""], ["", "context dataflow_topology begin"], ["", "definition the_cm where\n  \"the_cm c loc t n = (THE c'. next_change_multiplicity' c c' loc t n)\""], ["", "text\\<open>@{term the_cm} is not commutative in general, only if the necessary conditions hold. It can be converted\nto @{term apply_cm} for which we prove @{term comp_fun_commute}.\\<close>"], ["", "definition apply_cm where\n  \"apply_cm c loc t n =\n    (let new_pointstamps = (\\<lambda>loc'.\n                (if loc' = loc then update_zmultiset (c_pts c loc') t n\n                               else c_pts c loc')) in\n        c \\<lparr> c_pts := new_pointstamps \\<rparr>\n          \\<lparr> c_work :=\n            (\\<lambda>loc'. c_work c loc' + frontier_changes (new_pointstamps loc') (c_pts c loc'))\\<rparr>)\""], ["", "definition cm_all' where\n  \"cm_all' c0 \\<Delta> =\n      Finite_Set.fold (\\<lambda>(loc, t) c. apply_cm c loc t (zcount \\<Delta> (loc,t))) c0 (set_zmset \\<Delta>)\""], ["", "definition cm_all where\n  \"cm_all c0 \\<Delta> =\n      Finite_Set.fold (\\<lambda>(loc, t) c. the_cm c loc t (zcount \\<Delta> (loc,t))) c0 (set_zmset \\<Delta>)\""], ["", "definition \"propagate_all c0 = while_option (\\<lambda>c. \\<exists>loc. (c_work c loc) \\<noteq> {#}\\<^sub>z)\n                                            (\\<lambda>c. SOME c'. \\<exists>loc t. next_propagate' c c' loc t) c0\""], ["", "subsubsection\\<open>Initial state and state transitions\\<close>"], ["", "definition InitConfig :: \"('p::finite, 't::order, 'loc) configuration \\<Rightarrow> bool\" where\n  \"InitConfig c =\n      ((\\<forall>p. init c p = False)\n    \\<and> cri.init_config (exchange_config c)\n    \\<and> (\\<forall>p loc t. zcount (c_pts (prop_config c p) loc) t\n       = zcount (c_glob (exchange_config c) p) (loc, t))\n    \\<and> (\\<forall>w. init_config (prop_config c w)))\""], ["", "definition NextPerformOp' :: \"('p::finite, 't::order, 'loc) configuration \\<Rightarrow> ('p, 't, 'loc) configuration\n                              \\<Rightarrow> 'p \\<Rightarrow> ('loc \\<times> 't) multiset \\<Rightarrow> ('p \\<times> ('loc \\<times> 't)) multiset \\<Rightarrow> ('loc \\<times> 't) multiset \\<Rightarrow> bool\" where\n  \"NextPerformOp' c0 c1 p \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self = (\n     cri.next_performop' (exchange_config c0) (exchange_config c1) p \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self\n   \\<and> unchanged prop_config c0 c1\n   \\<and> unchanged init c0 c1)\""], ["", "abbreviation NextPerformOp where\n  \"NextPerformOp c0 c1 \\<equiv> \\<exists>p \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self. NextPerformOp' c0 c1 p \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self\""], ["", "definition NextRecvCap'\n  :: \"('p::finite, 't::order, 'loc) configuration \\<Rightarrow> ('p, 't, 'loc) configuration \\<Rightarrow> 'p \\<Rightarrow> 'loc \\<times> 't \\<Rightarrow> bool\" where\n  \"NextRecvCap' c0 c1 p t = (\n     cri.next_recvcap' (exchange_config c0) (exchange_config c1) p t\n   \\<and> unchanged prop_config c0 c1\n   \\<and> unchanged init c0 c1)\""], ["", "abbreviation NextRecvCap where\n  \"NextRecvCap c0 c1 \\<equiv> \\<exists>p t. NextRecvCap' c0 c1 p t\""], ["", "definition NextSendUpd' :: \"('p::finite, 't::order, 'loc) configuration \\<Rightarrow> ('p, 't, 'loc) configuration\n                              \\<Rightarrow> 'p \\<Rightarrow> ('loc \\<times> 't) set \\<Rightarrow> bool\" where\n  \"NextSendUpd' c0 c1 p tt = (\n    cri.next_sendupd' (exchange_config c0) (exchange_config c1) p tt\n  \\<and> unchanged prop_config c0 c1\n  \\<and> unchanged init c0 c1)\""], ["", "abbreviation NextSendUpd where\n  \"NextSendUpd c0 c1 \\<equiv> \\<exists>p tt. NextSendUpd' c0 c1 p tt\""], ["", "definition NextRecvUpd' :: \"('p::finite, 't::order, 'loc) configuration \\<Rightarrow> ('p, 't, 'loc) configuration\n                              \\<Rightarrow> 'p \\<Rightarrow> 'p \\<Rightarrow> bool\" where\n  \"NextRecvUpd' c0 c1 p q = (\n     init c0 q \\<comment> \\<open>Once init is set we are guaranteed that the CM transitions' premises are satisfied\\<close>\n   \\<and> cri.next_recvupd' (exchange_config c0) (exchange_config c1) p q\n   \\<and> unchanged init c0 c1\n   \\<and> (\\<forall>p'. prop_config c1 p' =\n          (if p' = q\n           then cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q))\n           else prop_config c0 p')))\""], ["", "abbreviation NextRecvUpd where\n  \"NextRecvUpd c0 c1 \\<equiv> \\<exists>p q. NextRecvUpd' c0 c1 p q\""], ["", "definition NextPropagate' :: \"('p::finite, 't::order, 'loc) configuration \\<Rightarrow> ('p, 't, 'loc) configuration\n                              \\<Rightarrow> 'p \\<Rightarrow> bool\" where\n  \"NextPropagate' c0 c1 p = (\n     unchanged exchange_config c0 c1\n   \\<and>  init c1 = (init c0)(p := True)\n   \\<and> (\\<forall>p'. Some (prop_config c1 p') =\n          (if p' = p\n           then propagate_all (prop_config c0 p')\n           else Some (prop_config c0 p'))))\""], ["", "abbreviation NextPropagate where\n  \"NextPropagate c0 c1 \\<equiv> \\<exists>p. NextPropagate' c0 c1 p\""], ["", "definition \"Next'\" where\n  \"Next' c0 c1 = (NextPerformOp c0 c1 \\<or> NextSendUpd c0 c1 \\<or> NextRecvUpd c0 c1 \\<or> NextPropagate c0 c1 \\<or> NextRecvCap c0 c1 \\<or> c1 = c0)\""], ["", "abbreviation \"Next\" where\n  \"Next s \\<equiv> Next' (shd s) (shd (stl s))\""], ["", "definition FullSpec :: \"('p :: finite, 't :: order, 'loc) computation \\<Rightarrow> bool\" where\n  \"FullSpec s = (holds InitConfig s \\<and> alw Next s)\""], ["", "lemma NextPerformOpD:\n  assumes \"NextPerformOp' c0 c1 p \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self\"\n  shows\n    \"cri.next_performop' (exchange_config c0) (exchange_config c1) p \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self\"\n    \"unchanged prop_config c0 c1\"\n    \"unchanged init c0 c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cri.next_performop' (exchange_config c0) (exchange_config c1) p\n     \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self &&&\n    prop_config c1 = prop_config c0 &&& init c1 = init c0", "using assms"], ["proof (prove)\nusing this:\n  NextPerformOp' c0 c1 p \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self\n\ngoal (1 subgoal):\n 1. cri.next_performop' (exchange_config c0) (exchange_config c1) p\n     \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self &&&\n    prop_config c1 = prop_config c0 &&& init c1 = init c0", "unfolding NextPerformOp'_def"], ["proof (prove)\nusing this:\n  cri.next_performop' (exchange_config c0) (exchange_config c1) p\n   \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self \\<and>\n  prop_config c1 = prop_config c0 \\<and> init c1 = init c0\n\ngoal (1 subgoal):\n 1. cri.next_performop' (exchange_config c0) (exchange_config c1) p\n     \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self &&&\n    prop_config c1 = prop_config c0 &&& init c1 = init c0", "by simp_all"], ["", "lemma NextSendUpdD:\n  assumes \"NextSendUpd' c0 c1 p tt\"\n  shows\n    \"cri.next_sendupd' (exchange_config c0) (exchange_config c1) p tt\"\n    \"unchanged prop_config c0 c1\"\n    \"unchanged init c0 c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cri.next_sendupd' (exchange_config c0) (exchange_config c1) p tt &&&\n    prop_config c1 = prop_config c0 &&& init c1 = init c0", "using assms"], ["proof (prove)\nusing this:\n  NextSendUpd' c0 c1 p tt\n\ngoal (1 subgoal):\n 1. cri.next_sendupd' (exchange_config c0) (exchange_config c1) p tt &&&\n    prop_config c1 = prop_config c0 &&& init c1 = init c0", "unfolding NextSendUpd'_def"], ["proof (prove)\nusing this:\n  cri.next_sendupd' (exchange_config c0) (exchange_config c1) p tt \\<and>\n  prop_config c1 = prop_config c0 \\<and> init c1 = init c0\n\ngoal (1 subgoal):\n 1. cri.next_sendupd' (exchange_config c0) (exchange_config c1) p tt &&&\n    prop_config c1 = prop_config c0 &&& init c1 = init c0", "by simp_all"], ["", "lemma NextRecvUpdD:\n  assumes \"NextRecvUpd' c0 c1 p q\"\n  shows\n    \"init c0 q\"\n    \"cri.next_recvupd' (exchange_config c0) (exchange_config c1) p q\"\n    \"unchanged init c0 c1\"\n    \"(\\<forall>p'. prop_config c1 p' =\n         (if p' = q\n          then cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q))\n          else prop_config c0 p'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (init c0 q &&&\n     cri.next_recvupd' (exchange_config c0) (exchange_config c1) p q) &&&\n    init c1 = init c0 &&&\n    \\<forall>p'.\n       prop_config c1 p' =\n       (if p' = q\n        then cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q))\n        else prop_config c0 p')", "using assms"], ["proof (prove)\nusing this:\n  NextRecvUpd' c0 c1 p q\n\ngoal (1 subgoal):\n 1. (init c0 q &&&\n     cri.next_recvupd' (exchange_config c0) (exchange_config c1) p q) &&&\n    init c1 = init c0 &&&\n    \\<forall>p'.\n       prop_config c1 p' =\n       (if p' = q\n        then cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q))\n        else prop_config c0 p')", "unfolding NextRecvUpd'_def"], ["proof (prove)\nusing this:\n  init c0 q \\<and>\n  cri.next_recvupd' (exchange_config c0) (exchange_config c1) p q \\<and>\n  init c1 = init c0 \\<and>\n  (\\<forall>p'.\n      prop_config c1 p' =\n      (if p' = q\n       then cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q))\n       else prop_config c0 p'))\n\ngoal (1 subgoal):\n 1. (init c0 q &&&\n     cri.next_recvupd' (exchange_config c0) (exchange_config c1) p q) &&&\n    init c1 = init c0 &&&\n    \\<forall>p'.\n       prop_config c1 p' =\n       (if p' = q\n        then cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q))\n        else prop_config c0 p')", "by simp_all"], ["", "lemma NextPropagateD:\n  assumes \"NextPropagate' c0 c1 p\"\n  shows\n    \"unchanged exchange_config c0 c1\"\n    \"init c1 = (init c0)(p := True)\"\n    \"(\\<forall>p'. Some (prop_config c1 p') =\n         (if p' = p\n          then propagate_all (prop_config c0 p')\n          else Some (prop_config c0 p')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exchange_config c1 = exchange_config c0 &&&\n    init c1 = (init c0)(p := True) &&&\n    \\<forall>p'.\n       Some (prop_config c1 p') =\n       (if p' = p then propagate_all (prop_config c0 p')\n        else Some (prop_config c0 p'))", "using assms"], ["proof (prove)\nusing this:\n  NextPropagate' c0 c1 p\n\ngoal (1 subgoal):\n 1. exchange_config c1 = exchange_config c0 &&&\n    init c1 = (init c0)(p := True) &&&\n    \\<forall>p'.\n       Some (prop_config c1 p') =\n       (if p' = p then propagate_all (prop_config c0 p')\n        else Some (prop_config c0 p'))", "unfolding NextPropagate'_def"], ["proof (prove)\nusing this:\n  exchange_config c1 = exchange_config c0 \\<and>\n  init c1 = (init c0)(p := True) \\<and>\n  (\\<forall>p'.\n      Some (prop_config c1 p') =\n      (if p' = p then propagate_all (prop_config c0 p')\n       else Some (prop_config c0 p')))\n\ngoal (1 subgoal):\n 1. exchange_config c1 = exchange_config c0 &&&\n    init c1 = (init c0)(p := True) &&&\n    \\<forall>p'.\n       Some (prop_config c1 p') =\n       (if p' = p then propagate_all (prop_config c0 p')\n        else Some (prop_config c0 p'))", "by simp_all"], ["", "lemma NextRecvCapD:\n  assumes \"NextRecvCap' c0 c1 p t\"\n  shows\n    \"cri.next_recvcap' (exchange_config c0) (exchange_config c1) p t\"\n    \"unchanged prop_config c0 c1\"\n    \"unchanged init c0 c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cri.next_recvcap' (exchange_config c0) (exchange_config c1) p t &&&\n    prop_config c1 = prop_config c0 &&& init c1 = init c0", "using assms"], ["proof (prove)\nusing this:\n  NextRecvCap' c0 c1 p t\n\ngoal (1 subgoal):\n 1. cri.next_recvcap' (exchange_config c0) (exchange_config c1) p t &&&\n    prop_config c1 = prop_config c0 &&& init c1 = init c0", "unfolding NextRecvCap'_def"], ["proof (prove)\nusing this:\n  cri.next_recvcap' (exchange_config c0) (exchange_config c1) p t \\<and>\n  prop_config c1 = prop_config c0 \\<and> init c1 = init c0\n\ngoal (1 subgoal):\n 1. cri.next_recvcap' (exchange_config c0) (exchange_config c1) p t &&&\n    prop_config c1 = prop_config c0 &&& init c1 = init c0", "by simp_all"], ["", "subsection\\<open>Auxiliary Lemmas\\<close>"], ["", "subsubsection\\<open>Auxiliary Lemmas for CM Conversion\\<close>"], ["", "lemma apply_cm_is_cm:\n  \"\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t \\<Longrightarrow> n \\<noteq> 0 \\<Longrightarrow> next_change_multiplicity' c (apply_cm c loc t n) loc t n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>t'.\n                t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> next_change_multiplicity' c (apply_cm c loc t n) loc t\n                       n", "by (auto simp: next_change_multiplicity'_def apply_cm_def\n      intro!: Propagate.configuration.equality)"], ["", "lemma update_zmultiset_commute:\n  \"update_zmultiset (update_zmultiset M t' n') t n = update_zmultiset (update_zmultiset M t n) t' n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update_zmultiset (update_zmultiset M t' n') t n =\n    update_zmultiset (update_zmultiset M t n) t' n'", "by transfer (auto simp: equiv_zmset_def split: if_splits)"], ["", "lemma apply_cm_commute: \"apply_cm (apply_cm c loc t n) loc' t' n' = apply_cm (apply_cm c loc' t' n') loc t n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cm (apply_cm c loc t n) loc' t' n' =\n    apply_cm (apply_cm c loc' t' n') loc t n", "unfolding apply_cm_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<lparr>c_pts :=\n               \\<lambda>loc'.\n                  if loc' = loc then update_zmultiset (c_pts c loc') t n\n                  else c_pts c loc',\n        c_work :=\n          \\<lambda>loc'.\n             c_work c loc' +\n             frontier_changes\n              (if loc' = loc then update_zmultiset (c_pts c loc') t n\n               else c_pts c loc')\n              (c_pts c loc'),\n        c_pts :=\n          \\<lambda>loc'a.\n             if loc'a = loc'\n             then update_zmultiset\n                   (c_pts\n                     (c\\<lparr>c_pts :=\n                                 \\<lambda>loc'.\n                                    if loc' = loc\n                                    then update_zmultiset (c_pts c loc') t n\n                                    else c_pts c loc',\n                          c_work :=\n                            \\<lambda>loc'.\n                               c_work c loc' +\n                               frontier_changes\n                                (if loc' = loc\n                                 then update_zmultiset (c_pts c loc') t n\n                                 else c_pts c loc')\n                                (c_pts c loc')\\<rparr>)\n                     loc'a)\n                   t' n'\n             else c_pts\n                   (c\\<lparr>c_pts :=\n                               \\<lambda>loc'.\n                                  if loc' = loc\n                                  then update_zmultiset (c_pts c loc') t n\n                                  else c_pts c loc',\n                        c_work :=\n                          \\<lambda>loc'.\n                             c_work c loc' +\n                             frontier_changes\n                              (if loc' = loc\n                               then update_zmultiset (c_pts c loc') t n\n                               else c_pts c loc')\n                              (c_pts c loc')\\<rparr>)\n                   loc'a,\n        c_work :=\n          \\<lambda>loc'a.\n             c_work\n              (c\\<lparr>c_pts :=\n                          \\<lambda>loc'.\n                             if loc' = loc\n                             then update_zmultiset (c_pts c loc') t n\n                             else c_pts c loc',\n                   c_work :=\n                     \\<lambda>loc'.\n                        c_work c loc' +\n                        frontier_changes\n                         (if loc' = loc\n                          then update_zmultiset (c_pts c loc') t n\n                          else c_pts c loc')\n                         (c_pts c loc')\\<rparr>)\n              loc'a +\n             frontier_changes\n              (if loc'a = loc'\n               then update_zmultiset\n                     (c_pts\n                       (c\\<lparr>c_pts :=\n                                   \\<lambda>loc'.\nif loc' = loc then update_zmultiset (c_pts c loc') t n else c_pts c loc',\n                            c_work :=\n                              \\<lambda>loc'.\n                                 c_work c loc' +\n                                 frontier_changes\n                                  (if loc' = loc\n                                   then update_zmultiset (c_pts c loc') t n\n                                   else c_pts c loc')\n                                  (c_pts c loc')\\<rparr>)\n                       loc'a)\n                     t' n'\n               else c_pts\n                     (c\\<lparr>c_pts :=\n                                 \\<lambda>loc'.\n                                    if loc' = loc\n                                    then update_zmultiset (c_pts c loc') t n\n                                    else c_pts c loc',\n                          c_work :=\n                            \\<lambda>loc'.\n                               c_work c loc' +\n                               frontier_changes\n                                (if loc' = loc\n                                 then update_zmultiset (c_pts c loc') t n\n                                 else c_pts c loc')\n                                (c_pts c loc')\\<rparr>)\n                     loc'a)\n              (c_pts\n                (c\\<lparr>c_pts :=\n                            \\<lambda>loc'.\n                               if loc' = loc\n                               then update_zmultiset (c_pts c loc') t n\n                               else c_pts c loc',\n                     c_work :=\n                       \\<lambda>loc'.\n                          c_work c loc' +\n                          frontier_changes\n                           (if loc' = loc\n                            then update_zmultiset (c_pts c loc') t n\n                            else c_pts c loc')\n                           (c_pts c loc')\\<rparr>)\n                loc'a)\\<rparr> =\n    c\\<lparr>c_pts :=\n               \\<lambda>loc'a.\n                  if loc'a = loc'\n                  then update_zmultiset (c_pts c loc'a) t' n'\n                  else c_pts c loc'a,\n        c_work :=\n          \\<lambda>loc'a.\n             c_work c loc'a +\n             frontier_changes\n              (if loc'a = loc' then update_zmultiset (c_pts c loc'a) t' n'\n               else c_pts c loc'a)\n              (c_pts c loc'a),\n        c_pts :=\n          \\<lambda>loc'a.\n             if loc'a = loc\n             then update_zmultiset\n                   (c_pts\n                     (c\\<lparr>c_pts :=\n                                 \\<lambda>loc'a.\n                                    if loc'a = loc'\n                                    then update_zmultiset (c_pts c loc'a) t'\n    n'\n                                    else c_pts c loc'a,\n                          c_work :=\n                            \\<lambda>loc'a.\n                               c_work c loc'a +\n                               frontier_changes\n                                (if loc'a = loc'\n                                 then update_zmultiset (c_pts c loc'a) t' n'\n                                 else c_pts c loc'a)\n                                (c_pts c loc'a)\\<rparr>)\n                     loc'a)\n                   t n\n             else c_pts\n                   (c\\<lparr>c_pts :=\n                               \\<lambda>loc'a.\n                                  if loc'a = loc'\n                                  then update_zmultiset (c_pts c loc'a) t'\n  n'\n                                  else c_pts c loc'a,\n                        c_work :=\n                          \\<lambda>loc'a.\n                             c_work c loc'a +\n                             frontier_changes\n                              (if loc'a = loc'\n                               then update_zmultiset (c_pts c loc'a) t' n'\n                               else c_pts c loc'a)\n                              (c_pts c loc'a)\\<rparr>)\n                   loc'a,\n        c_work :=\n          \\<lambda>loc'a.\n             c_work\n              (c\\<lparr>c_pts :=\n                          \\<lambda>loc'a.\n                             if loc'a = loc'\n                             then update_zmultiset (c_pts c loc'a) t' n'\n                             else c_pts c loc'a,\n                   c_work :=\n                     \\<lambda>loc'a.\n                        c_work c loc'a +\n                        frontier_changes\n                         (if loc'a = loc'\n                          then update_zmultiset (c_pts c loc'a) t' n'\n                          else c_pts c loc'a)\n                         (c_pts c loc'a)\\<rparr>)\n              loc'a +\n             frontier_changes\n              (if loc'a = loc\n               then update_zmultiset\n                     (c_pts\n                       (c\\<lparr>c_pts :=\n                                   \\<lambda>loc'a.\nif loc'a = loc' then update_zmultiset (c_pts c loc'a) t' n'\nelse c_pts c loc'a,\n                            c_work :=\n                              \\<lambda>loc'a.\n                                 c_work c loc'a +\n                                 frontier_changes\n                                  (if loc'a = loc'\n                                   then update_zmultiset (c_pts c loc'a) t'\n   n'\n                                   else c_pts c loc'a)\n                                  (c_pts c loc'a)\\<rparr>)\n                       loc'a)\n                     t n\n               else c_pts\n                     (c\\<lparr>c_pts :=\n                                 \\<lambda>loc'a.\n                                    if loc'a = loc'\n                                    then update_zmultiset (c_pts c loc'a) t'\n    n'\n                                    else c_pts c loc'a,\n                          c_work :=\n                            \\<lambda>loc'a.\n                               c_work c loc'a +\n                               frontier_changes\n                                (if loc'a = loc'\n                                 then update_zmultiset (c_pts c loc'a) t' n'\n                                 else c_pts c loc'a)\n                                (c_pts c loc'a)\\<rparr>)\n                     loc'a)\n              (c_pts\n                (c\\<lparr>c_pts :=\n                            \\<lambda>loc'a.\n                               if loc'a = loc'\n                               then update_zmultiset (c_pts c loc'a) t' n'\n                               else c_pts c loc'a,\n                     c_work :=\n                       \\<lambda>loc'a.\n                          c_work c loc'a +\n                          frontier_changes\n                           (if loc'a = loc'\n                            then update_zmultiset (c_pts c loc'a) t' n'\n                            else c_pts c loc'a)\n                           (c_pts c loc'a)\\<rparr>)\n                loc'a)\\<rparr>", "by (auto intro!: Propagate.configuration.equality simp: update_zmultiset_commute)"], ["", "lemma comp_fun_commute_apply_cm[simp]: \"comp_fun_commute (\\<lambda>(loc, t) c. apply_cm c loc t (f loc t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute (\\<lambda>(loc, t) c. apply_cm c loc t (f loc t))", "by (auto intro!: Propagate.configuration.equality simp: update_zmultiset_commute comp_fun_commute_def o_def apply_cm_commute)"], ["", "lemma ex_cm_imp_conds:\n  assumes \"\\<exists>c'. next_change_multiplicity' c c' loc t n\"\n  shows \"\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t\" \"n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t'.\n       t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t &&&\n    n \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>c'. next_change_multiplicity' c c' loc t n\n\ngoal (1 subgoal):\n 1. \\<exists>t'.\n       t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t &&&\n    n \\<noteq> 0", "by (auto simp: next_change_multiplicity'_def)"], ["", "lemma the_cm_eq_apply_cm:\n  assumes \"\\<exists>c'. next_change_multiplicity' c c' loc t n\"\n  shows   \"the_cm c loc t n = apply_cm c loc t n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_cm c loc t n = apply_cm c loc t n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. the_cm c loc t n = apply_cm c loc t n", "from assms"], ["proof (chain)\npicking this:\n  \\<exists>c'. next_change_multiplicity' c c' loc t n", "have cond: \"\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t\" \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>c'. next_change_multiplicity' c c' loc t n\n\ngoal (1 subgoal):\n 1. \\<exists>t'.\n       t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t &&&\n    n \\<noteq> 0", "using ex_cm_imp_conds"], ["proof (prove)\nusing this:\n  \\<exists>c'. next_change_multiplicity' c c' loc t n\n  \\<exists>c'. next_change_multiplicity' ?c c' ?loc ?t ?n \\<Longrightarrow>\n  \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp ?c ?loc) \\<and> t' \\<le> ?t\n  \\<exists>c'. next_change_multiplicity' ?c c' ?loc ?t ?n \\<Longrightarrow>\n  ?n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>t'.\n       t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t &&&\n    n \\<noteq> 0", "by blast+"], ["proof (state)\nthis:\n  \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. the_cm c loc t n = apply_cm c loc t n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_cm c loc t n = apply_cm c loc t n", "unfolding the_cm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE c'. next_change_multiplicity' c c' loc t n) = apply_cm c loc t n", "apply (rule the1_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>!c'. next_change_multiplicity' c c' loc t n\n 2. next_change_multiplicity' c (apply_cm c loc t n) loc t n", "apply (rule next_change_multiplicity'_unique[OF cond(2,1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. next_change_multiplicity' c (apply_cm c loc t n) loc t n", "unfolding apply_cm_def next_change_multiplicity'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<and>\n    (\\<exists>t'.\n        t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t) \\<and>\n    (let new_pointstamps =\n           \\<lambda>loc'.\n              if loc' = loc then update_zmultiset (c_pts c loc') t n\n              else c_pts c loc'\n     in c\\<lparr>c_pts := new_pointstamps,\n            c_work :=\n              \\<lambda>loc'.\n                 c_work c loc' +\n                 frontier_changes (new_pointstamps loc')\n                  (c_pts c loc')\\<rparr>) =\n    c\\<lparr>c_pts := (c_pts c)(loc := update_zmultiset (c_pts c loc) t n),\n        c_work := (c_work c)\n          (loc :=\n             c_work c loc +\n             frontier_changes (update_zmultiset (c_pts c loc) t n)\n              (c_pts c loc))\\<rparr>", "using cond"], ["proof (prove)\nusing this:\n  \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<and>\n    (\\<exists>t'.\n        t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t) \\<and>\n    (let new_pointstamps =\n           \\<lambda>loc'.\n              if loc' = loc then update_zmultiset (c_pts c loc') t n\n              else c_pts c loc'\n     in c\\<lparr>c_pts := new_pointstamps,\n            c_work :=\n              \\<lambda>loc'.\n                 c_work c loc' +\n                 frontier_changes (new_pointstamps loc')\n                  (c_pts c loc')\\<rparr>) =\n    c\\<lparr>c_pts := (c_pts c)(loc := update_zmultiset (c_pts c loc) t n),\n        c_work := (c_work c)\n          (loc :=\n             c_work c loc +\n             frontier_changes (update_zmultiset (c_pts c loc) t n)\n              (c_pts c loc))\\<rparr>", "apply (auto intro!: Propagate.configuration.equality)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  the_cm c loc t n = apply_cm c loc t n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_cm_preserves_cond:\n  assumes \"\\<forall>(loc,t)\\<in>set_zmset \\<Delta>. \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\"\n  shows   \"\\<forall>(loc,t)\\<in>set_zmset \\<Delta>. \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp (apply_cm c0 loc' t'' n) loc) \\<and> t' \\<le> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n       \\<exists>t'.\n          t' \\<in>\\<^sub>A frontier\n                            (c_imp (apply_cm c0 loc' t'' n) loc) \\<and>\n          t' \\<le> t", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n     \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\n\ngoal (1 subgoal):\n 1. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n       \\<exists>t'.\n          t' \\<in>\\<^sub>A frontier\n                            (c_imp (apply_cm c0 loc' t'' n) loc) \\<and>\n          t' \\<le> t", "by (auto simp: apply_cm_def)"], ["", "lemma cm_all_eq_cm_all':\n  assumes \"\\<forall>(loc,t)\\<in>set_zmset \\<Delta>. \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\"\n  shows   \"cm_all c0 \\<Delta> = cm_all' c0 \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cm_all c0 \\<Delta> = cm_all' c0 \\<Delta>", "unfolding cm_all_def cm_all'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>(loc, t) c. the_cm c loc t (zcount \\<Delta> (loc, t))) c0\n     (set_zmset \\<Delta>) =\n    Finite_Set.fold\n     (\\<lambda>(loc, t) c. apply_cm c loc t (zcount \\<Delta> (loc, t))) c0\n     (set_zmset \\<Delta>)", "apply (rule fold_closed_eq[where B = \"{c. \\<forall>(loc,t)\\<in>set_zmset \\<Delta>. \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t}\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in>#\\<^sub>z \\<Delta>;\n        b \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                       \\<exists>t'.\n                          t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and>\n                          t' \\<le> t}\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (loc, t) \\<Rightarrow>\n                            \\<lambda>c.\n                               the_cm c loc t (zcount \\<Delta> (loc, t)))\n                          b =\n                         (case a of\n                          (loc, t) \\<Rightarrow>\n                            \\<lambda>c.\n                               apply_cm c loc t (zcount \\<Delta> (loc, t)))\n                          b\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in>#\\<^sub>z \\<Delta>;\n        b \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                       \\<exists>t'.\n                          t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and>\n                          t' \\<le> t}\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (loc, t) \\<Rightarrow>\n                            \\<lambda>c.\n                               apply_cm c loc t (zcount \\<Delta> (loc, t)))\n                          b\n                         \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t}\n 3. c0 \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                    \\<exists>t'.\n                       t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and>\n                       t' \\<le> t}", "subgoal for a \\<Delta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in>#\\<^sub>z \\<Delta>;\n     \\<Delta>\n     \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                  \\<exists>t'.\n                     t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and>\n                     t' \\<le> t}\\<rbrakk>\n    \\<Longrightarrow> (case a of\n                       (loc, t) \\<Rightarrow>\n                         \\<lambda>c.\n                            the_cm c loc t (zcount \\<Delta> (loc, t)))\n                       \\<Delta> =\n                      (case a of\n                       (loc, t) \\<Rightarrow>\n                         \\<lambda>c.\n                            apply_cm c loc t (zcount \\<Delta> (loc, t)))\n                       \\<Delta>", "apply (cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a \\<in>#\\<^sub>z \\<Delta>;\n        \\<Delta>\n        \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                     \\<exists>t'.\n                        t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and>\n                        t' \\<le> t};\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (loc, t) \\<Rightarrow>\n                            \\<lambda>c.\n                               the_cm c loc t (zcount \\<Delta> (loc, t)))\n                          \\<Delta> =\n                         (case a of\n                          (loc, t) \\<Rightarrow>\n                            \\<lambda>c.\n                               apply_cm c loc t (zcount \\<Delta> (loc, t)))\n                          \\<Delta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>x\\<in>#\\<^sub>z\\<Delta>.\n           case x of\n           (loc, t) \\<Rightarrow>\n             \\<exists>t'.\n                t' \\<in>\\<^sub>A frontier (c_imp \\<Delta> loc) \\<and>\n                t' \\<le> t;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> the_cm \\<Delta> aa b (zcount \\<Delta> (aa, b)) =\n                         apply_cm \\<Delta> aa b (zcount \\<Delta> (aa, b))", "apply (rule the_cm_eq_apply_cm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>x\\<in>#\\<^sub>z\\<Delta>.\n           case x of\n           (loc, t) \\<Rightarrow>\n             \\<exists>t'.\n                t' \\<in>\\<^sub>A frontier (c_imp \\<Delta> loc) \\<and>\n                t' \\<le> t;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'.\n                            next_change_multiplicity' \\<Delta> c' aa b\n                             (zcount \\<Delta> (aa, b))", "apply (rule ex1_implies_ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>x\\<in>#\\<^sub>z\\<Delta>.\n           case x of\n           (loc, t) \\<Rightarrow>\n             \\<exists>t'.\n                t' \\<in>\\<^sub>A frontier (c_imp \\<Delta> loc) \\<and>\n                t' \\<le> t;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!c'.\n                            next_change_multiplicity' \\<Delta> c' aa b\n                             (zcount \\<Delta> (aa, b))", "apply (rule next_change_multiplicity'_unique)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>x\\<in>#\\<^sub>z\\<Delta>.\n           case x of\n           (loc, t) \\<Rightarrow>\n             \\<exists>t'.\n                t' \\<in>\\<^sub>A frontier (c_imp \\<Delta> loc) \\<and>\n                t' \\<le> t;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> zcount \\<Delta> (aa, b) \\<noteq> 0\n 2. \\<And>aa b.\n       \\<lbrakk>(aa, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>x\\<in>#\\<^sub>z\\<Delta>.\n           case x of\n           (loc, t) \\<Rightarrow>\n             \\<exists>t'.\n                t' \\<in>\\<^sub>A frontier (c_imp \\<Delta> loc) \\<and>\n                t' \\<le> t;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp \\<Delta> aa) \\<and>\n                            t' \\<le> b", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in>#\\<^sub>z \\<Delta>;\n        b \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                       \\<exists>t'.\n                          t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and>\n                          t' \\<le> t}\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (loc, t) \\<Rightarrow>\n                            \\<lambda>c.\n                               apply_cm c loc t (zcount \\<Delta> (loc, t)))\n                          b\n                         \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t}\n 2. c0 \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                    \\<exists>t'.\n                       t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and>\n                       t' \\<le> t}", "subgoal for a \\<Delta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in>#\\<^sub>z \\<Delta>;\n     \\<Delta>\n     \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                  \\<exists>t'.\n                     t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and>\n                     t' \\<le> t}\\<rbrakk>\n    \\<Longrightarrow> (case a of\n                       (loc, t) \\<Rightarrow>\n                         \\<lambda>c.\n                            apply_cm c loc t (zcount \\<Delta> (loc, t)))\n                       \\<Delta>\n                      \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                                   \\<exists>t'.\nt' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t}", "apply (cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>a \\<in>#\\<^sub>z \\<Delta>;\n        \\<Delta>\n        \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                     \\<exists>t'.\n                        t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and>\n                        t' \\<le> t};\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (loc, t) \\<Rightarrow>\n                            \\<lambda>c.\n                               apply_cm c loc t (zcount \\<Delta> (loc, t)))\n                          \\<Delta>\n                         \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>x\\<in>#\\<^sub>z\\<Delta>.\n           case x of\n           (loc, t) \\<Rightarrow>\n             \\<exists>t'.\n                t' \\<in>\\<^sub>A frontier (c_imp \\<Delta> loc) \\<and>\n                t' \\<le> t;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>#\\<^sub>z\\<Delta>.\n                            case x of\n                            (loc, t) \\<Rightarrow>\n                              \\<exists>t'.\n                                 t' \\<in>\\<^sub>A frontier\n             (c_imp (apply_cm \\<Delta> aa b (zcount \\<Delta> (aa, b)))\n               loc) \\<and>\n                                 t' \\<le> t", "apply (rule apply_cm_preserves_cond)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>x\\<in>#\\<^sub>z\\<Delta>.\n           case x of\n           (loc, t) \\<Rightarrow>\n             \\<exists>t'.\n                t' \\<in>\\<^sub>A frontier (c_imp \\<Delta> loc) \\<and>\n                t' \\<le> t;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                            \\<exists>t'.\n                               t' \\<in>\\<^sub>A frontier\n           (c_imp \\<Delta> loc) \\<and>\n                               t' \\<le> t", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. c0 \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                    \\<exists>t'.\n                       t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and>\n                       t' \\<le> t}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. c0 \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                    \\<exists>t'.\n                       t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and>\n                       t' \\<le> t}", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n     \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\n\ngoal (1 subgoal):\n 1. c0 \\<in> {c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n                    \\<exists>t'.\n                       t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and>\n                       t' \\<le> t}", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cm_eq_the_cm:\n  assumes \"next_change_multiplicity' c c' loc t n\"\n  shows   \"the_cm c loc t n = c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_cm c loc t n = c'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. the_cm c loc t n = c'", "from assms"], ["proof (chain)\npicking this:\n  next_change_multiplicity' c c' loc t n", "have cond: \"\\<exists>u. u \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> u \\<le> t\" \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  next_change_multiplicity' c c' loc t n\n\ngoal (1 subgoal):\n 1. \\<exists>u. u \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> u \\<le> t &&&\n    n \\<noteq> 0", "unfolding next_change_multiplicity'_def"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t) \\<and>\n  c' = c\n  \\<lparr>c_pts := (c_pts c)(loc := update_zmultiset (c_pts c loc) t n),\n     c_work := (c_work c)\n       (loc :=\n          c_work c loc +\n          frontier_changes (update_zmultiset (c_pts c loc) t n)\n           (c_pts c loc))\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>u. u \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> u \\<le> t &&&\n    n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>u. u \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> u \\<le> t\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. the_cm c loc t n = c'", "then"], ["proof (chain)\npicking this:\n  \\<exists>u. u \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> u \\<le> t\n  n \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>u. u \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> u \\<le> t\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. the_cm c loc t n = c'", "using next_change_multiplicity'_unique[OF cond(2,1)] assms the_cm_def"], ["proof (prove)\nusing this:\n  \\<exists>u. u \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> u \\<le> t\n  n \\<noteq> 0\n  \\<exists>!c'. next_change_multiplicity' c c' loc t n\n  next_change_multiplicity' c c' loc t n\n  the_cm ?c ?loc ?t ?n =\n  (THE c'. next_change_multiplicity' ?c c' ?loc ?t ?n)\n\ngoal (1 subgoal):\n 1. the_cm c loc t n = c'", "by auto"], ["proof (state)\nthis:\n  the_cm c loc t n = c'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zcount_ps_apply_cm:\n  \"zcount (c_pts (apply_cm c loc t n) loc') t' = zcount (c_pts c loc') t' + (if loc = loc' \\<and> t = t' then n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (c_pts (apply_cm c loc t n) loc') t' =\n    zcount (c_pts c loc') t' + (if loc = loc' \\<and> t = t' then n else 0)", "by (auto simp: apply_cm_def zcount_update_zmultiset)"], ["", "lemma zcount_pointstamps_update: \"zcount (c_pts (c\\<lparr>c_pts:=M\\<rparr>) loc) x = zcount (M loc) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (c_pts (c\\<lparr>c_pts := M\\<rparr>) loc) x = zcount (M loc) x", "by auto"], ["", "lemma nop: \"loc1 \\<noteq> loc2 \\<or> t1 \\<noteq> t2 \\<longrightarrow>\n    zcount (c_pts (apply_cm c loc2 t2 (zcount \\<Delta> (loc2, t2))) loc1) t1 =\n    zcount (c_pts c loc1) t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loc1 \\<noteq> loc2 \\<or> t1 \\<noteq> t2 \\<longrightarrow>\n    zcount (c_pts (apply_cm c loc2 t2 (zcount \\<Delta> (loc2, t2))) loc1)\n     t1 =\n    zcount (c_pts c loc1) t1", "apply (simp add: apply_cm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. loc1 = loc2 \\<longrightarrow>\n    t1 \\<noteq> t2 \\<longrightarrow>\n    zcount (update_zmultiset (c_pts c loc2) t2 (zcount \\<Delta> (loc2, t2)))\n     t1 =\n    zcount (c_pts c loc2) t1", "using zcount_update_zmultiset"], ["proof (prove)\nusing this:\n  zcount (update_zmultiset ?M ?t ?n) ?t' =\n  zcount ?M ?t' + (if ?t = ?t' then ?n else 0)\n\ngoal (1 subgoal):\n 1. loc1 = loc2 \\<longrightarrow>\n    t1 \\<noteq> t2 \\<longrightarrow>\n    zcount (update_zmultiset (c_pts c loc2) t2 (zcount \\<Delta> (loc2, t2)))\n     t1 =\n    zcount (c_pts c loc2) t1", "by (simp add: zcount_update_zmultiset)"], ["", "lemma fold_nop:\n  \"zcount (c_pts (Finite_Set.fold (\\<lambda>(loc', t') c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t'))) c\n                          (set_zmset \\<Delta> - {(loc, t)})) loc) t\n  = zcount (c_pts c loc) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c (set_zmset \\<Delta> - {(loc, t)}))\n       loc)\n     t =\n    zcount (c_pts c loc) t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c (set_zmset \\<Delta> - {(loc, t)}))\n       loc)\n     t =\n    zcount (c_pts c loc) t", "have \"finite (set_zmset \\<Delta>- {(loc, t)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_zmset \\<Delta> - {(loc, t)})", "using finite_set_zmset"], ["proof (prove)\nusing this:\n  finite (set_zmset ?M)\n\ngoal (1 subgoal):\n 1. finite (set_zmset \\<Delta> - {(loc, t)})", "by blast"], ["proof (state)\nthis:\n  finite (set_zmset \\<Delta> - {(loc, t)})\n\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c (set_zmset \\<Delta> - {(loc, t)}))\n       loc)\n     t =\n    zcount (c_pts c loc) t", "then"], ["proof (chain)\npicking this:\n  finite (set_zmset \\<Delta> - {(loc, t)})", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (set_zmset \\<Delta> - {(loc, t)})\n\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c (set_zmset \\<Delta> - {(loc, t)}))\n       loc)\n     t =\n    zcount (c_pts c loc) t", "proof (induct \"set_zmset \\<Delta> - {(loc, t)}\" arbitrary: \\<Delta> rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Delta>.\n       {} = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n       zcount\n        (c_pts\n          (Finite_Set.fold\n            (\\<lambda>a.\n                case a of\n                (loc', t') \\<Rightarrow>\n                  \\<lambda>c.\n                     apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n            c (set_zmset \\<Delta> - {(loc, t)}))\n          loc)\n        t =\n       zcount (c_pts c loc) t\n 2. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "case empty"], ["proof (state)\nthis:\n  {} = set_zmset \\<Delta> - {(loc, t)}\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta>.\n       {} = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n       zcount\n        (c_pts\n          (Finite_Set.fold\n            (\\<lambda>a.\n                case a of\n                (loc', t') \\<Rightarrow>\n                  \\<lambda>c.\n                     apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n            c (set_zmset \\<Delta> - {(loc, t)}))\n          loc)\n        t =\n       zcount (c_pts c loc) t\n 2. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "then"], ["proof (chain)\npicking this:\n  {} = set_zmset \\<Delta> - {(loc, t)}", "show ?case"], ["proof (prove)\nusing this:\n  {} = set_zmset \\<Delta> - {(loc, t)}\n\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>a.\n             case a of\n             (loc', t') \\<Rightarrow>\n               \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c (set_zmset \\<Delta> - {(loc, t)}))\n       loc)\n     t =\n    zcount (c_pts c loc) t", "using fold_empty"], ["proof (prove)\nusing this:\n  {} = set_zmset \\<Delta> - {(loc, t)}\n  Finite_Set.fold ?f ?z {} = ?z\n\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>a.\n             case a of\n             (loc', t') \\<Rightarrow>\n               \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c (set_zmset \\<Delta> - {(loc, t)}))\n       loc)\n     t =\n    zcount (c_pts c loc) t", "by auto"], ["proof (state)\nthis:\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>a.\n           case a of\n           (loc', t') \\<Rightarrow>\n             \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (set_zmset \\<Delta> - {(loc, t)}))\n     loc)\n   t =\n  zcount (c_pts c loc) t\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "let ?f = \"(\\<lambda>(loc', t') c. apply_cm c loc' t' (zcount \\<Delta>' (loc',t')))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  F = set_zmset ?\\<Delta>21 - {(loc, t)} \\<Longrightarrow>\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (set_zmset ?\\<Delta>21 - {(loc, t)}))\n     loc)\n   t =\n  zcount (c_pts c loc) t\n  insert x F = set_zmset \\<Delta> - {(loc, t)}\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "obtain loc' t' where x_pair: \"x = (loc', t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>loc' t'.\n        x = (loc', t') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  x = (loc', t')\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "from insert"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  F = set_zmset ?\\<Delta>21 - {(loc, t)} \\<Longrightarrow>\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (set_zmset ?\\<Delta>21 - {(loc, t)}))\n     loc)\n   t =\n  zcount (c_pts c loc) t\n  insert x F = set_zmset \\<Delta> - {(loc, t)}", "have nonmember: \"x \\<noteq> (loc, t)\""], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  F = set_zmset ?\\<Delta>21 - {(loc, t)} \\<Longrightarrow>\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (set_zmset ?\\<Delta>21 - {(loc, t)}))\n     loc)\n   t =\n  zcount (c_pts c loc) t\n  insert x F = set_zmset \\<Delta> - {(loc, t)}\n\ngoal (1 subgoal):\n 1. x \\<noteq> (loc, t)", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> (loc, t)\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> (loc, t)", "have finite_s: \"finite F\""], ["proof (prove)\nusing this:\n  x \\<noteq> (loc, t)\n\ngoal (1 subgoal):\n 1. finite F", "using insert"], ["proof (prove)\nusing this:\n  x \\<noteq> (loc, t)\n  finite F\n  x \\<notin> F\n  F = set_zmset ?\\<Delta>21 - {(loc, t)} \\<Longrightarrow>\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (set_zmset ?\\<Delta>21 - {(loc, t)}))\n     loc)\n   t =\n  zcount (c_pts c loc) t\n  insert x F = set_zmset \\<Delta> - {(loc, t)}\n\ngoal (1 subgoal):\n 1. finite F", "by auto"], ["proof (state)\nthis:\n  finite F\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "have commute: \"comp_fun_commute ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute\n     (\\<lambda>(loc', t') c.\n         apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))", "by (simp add: comp_fun_commute_def comp_def apply_cm_commute)"], ["proof (state)\nthis:\n  comp_fun_commute\n   (\\<lambda>(loc', t') c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "with finite_s"], ["proof (chain)\npicking this:\n  finite F\n  comp_fun_commute\n   (\\<lambda>(loc', t') c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))", "have step1:\n      \"Finite_Set.fold ?f c (insert x F) = ?f x (Finite_Set.fold ?f c F)\""], ["proof (prove)\nusing this:\n  finite F\n  comp_fun_commute\n   (\\<lambda>(loc', t') c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>(loc', t') c.\n         apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n     c (insert x F) =\n    (case x of\n     (loc', t') \\<Rightarrow>\n       \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c F)", "by (metis (mono_tags, lifting) comp_fun_commute.fold_insert insert.hyps(1) insert.hyps(2))"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>(loc', t') c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n   c (insert x F) =\n  (case x of\n   (loc', t') \\<Rightarrow>\n     \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n   (Finite_Set.fold\n     (\\<lambda>(loc', t') c.\n         apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n     c F)\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "from nonmember"], ["proof (chain)\npicking this:\n  x \\<noteq> (loc, t)", "have step2:\n      \"zcount (c_pts (?f x (Finite_Set.fold ?f c F)) loc) t\n          = zcount (c_pts (Finite_Set.fold ?f c F) loc) t\""], ["proof (prove)\nusing this:\n  x \\<noteq> (loc, t)\n\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       ((case x of\n         (loc', t') \\<Rightarrow>\n           \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         (Finite_Set.fold\n           (\\<lambda>(loc', t') c.\n               apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n           c F))\n       loc)\n     t =\n    zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c F)\n       loc)\n     t", "using x_pair"], ["proof (prove)\nusing this:\n  x \\<noteq> (loc, t)\n  x = (loc', t')\n\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       ((case x of\n         (loc', t') \\<Rightarrow>\n           \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         (Finite_Set.fold\n           (\\<lambda>(loc', t') c.\n               apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n           c F))\n       loc)\n     t =\n    zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c F)\n       loc)\n     t", "by (metis (mono_tags, lifting) case_prod_conv nop)"], ["proof (state)\nthis:\n  zcount\n   (c_pts\n     ((case x of\n       (loc', t') \\<Rightarrow>\n         \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c F))\n     loc)\n   t =\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c F)\n     loc)\n   t\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "with step1 and x_pair"], ["proof (chain)\npicking this:\n  Finite_Set.fold\n   (\\<lambda>(loc', t') c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n   c (insert x F) =\n  (case x of\n   (loc', t') \\<Rightarrow>\n     \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n   (Finite_Set.fold\n     (\\<lambda>(loc', t') c.\n         apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n     c F)\n  x = (loc', t')\n  zcount\n   (c_pts\n     ((case x of\n       (loc', t') \\<Rightarrow>\n         \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c F))\n     loc)\n   t =\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c F)\n     loc)\n   t", "have final:\n      \"zcount (c_pts (Finite_Set.fold ?f c (insert x F)) loc) t\n          = zcount (c_pts (Finite_Set.fold ?f c F) loc) t\""], ["proof (prove)\nusing this:\n  Finite_Set.fold\n   (\\<lambda>(loc', t') c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n   c (insert x F) =\n  (case x of\n   (loc', t') \\<Rightarrow>\n     \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n   (Finite_Set.fold\n     (\\<lambda>(loc', t') c.\n         apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n     c F)\n  x = (loc', t')\n  zcount\n   (c_pts\n     ((case x of\n       (loc', t') \\<Rightarrow>\n         \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c F))\n     loc)\n   t =\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c F)\n     loc)\n   t\n\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c (insert x F))\n       loc)\n     t =\n    zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c F)\n       loc)\n     t", "by simp"], ["proof (state)\nthis:\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (insert x F))\n     loc)\n   t =\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c F)\n     loc)\n   t\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "from insert(2,4)"], ["proof (chain)\npicking this:\n  x \\<notin> F\n  insert x F = set_zmset \\<Delta> - {(loc, t)}", "obtain \\<Delta>2 where \\<Delta>2: \"\\<Delta>2 = filter_zmset (\\<lambda>y. y\\<noteq>x) \\<Delta>\""], ["proof (prove)\nusing this:\n  x \\<notin> F\n  insert x F = set_zmset \\<Delta> - {(loc, t)}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Delta>2.\n        \\<Delta>2 =\n        {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<Delta>2 = {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#}\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "then"], ["proof (chain)\npicking this:\n  \\<Delta>2 = {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#}", "have \"F = set_zmset \\<Delta>2 - {(loc, t)}\""], ["proof (prove)\nusing this:\n  \\<Delta>2 = {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#}\n\ngoal (1 subgoal):\n 1. F = set_zmset \\<Delta>2 - {(loc, t)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Delta>2 =\n    {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#} \\<Longrightarrow>\n    F = set_zmset \\<Delta>2 - {(loc, t)}", "from \\<Delta>2"], ["proof (chain)\npicking this:\n  \\<Delta>2 = {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#}", "have *: \"x \\<notin>#\\<^sub>z \\<Delta>2\""], ["proof (prove)\nusing this:\n  \\<Delta>2 = {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#}\n\ngoal (1 subgoal):\n 1. x \\<notin>#\\<^sub>z \\<Delta>2", "by (simp add: not_in_iff_zmset)"], ["proof (state)\nthis:\n  x \\<notin>#\\<^sub>z \\<Delta>2\n\ngoal (1 subgoal):\n 1. \\<Delta>2 =\n    {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#} \\<Longrightarrow>\n    F = set_zmset \\<Delta>2 - {(loc, t)}", "from insert(4) and nonmember"], ["proof (chain)\npicking this:\n  insert x F = set_zmset \\<Delta> - {(loc, t)}\n  x \\<noteq> (loc, t)", "have **: \"x \\<in>#\\<^sub>z \\<Delta>\""], ["proof (prove)\nusing this:\n  insert x F = set_zmset \\<Delta> - {(loc, t)}\n  x \\<noteq> (loc, t)\n\ngoal (1 subgoal):\n 1. x \\<in>#\\<^sub>z \\<Delta>", "by blast"], ["proof (state)\nthis:\n  x \\<in>#\\<^sub>z \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<Delta>2 =\n    {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#} \\<Longrightarrow>\n    F = set_zmset \\<Delta>2 - {(loc, t)}", "from \\<Delta>2 **"], ["proof (chain)\npicking this:\n  \\<Delta>2 = {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#}\n  x \\<in>#\\<^sub>z \\<Delta>", "have ***: \"\\<forall>y. y \\<in>#\\<^sub>z \\<Delta> \\<longleftrightarrow> (y \\<in>#\\<^sub>z \\<Delta>2 \\<or> y = x)\""], ["proof (prove)\nusing this:\n  \\<Delta>2 = {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#}\n  x \\<in>#\\<^sub>z \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in>#\\<^sub>z \\<Delta>) =\n       (y \\<in>#\\<^sub>z \\<Delta>2 \\<or> y = x)", "by (metis (mono_tags, lifting) count_filter_zmset zcount_ne_zero_iff)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y \\<in>#\\<^sub>z \\<Delta>) = (y \\<in>#\\<^sub>z \\<Delta>2 \\<or> y = x)\n\ngoal (1 subgoal):\n 1. \\<Delta>2 =\n    {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#} \\<Longrightarrow>\n    F = set_zmset \\<Delta>2 - {(loc, t)}", "with ***"], ["proof (chain)\npicking this:\n  \\<forall>y.\n     (y \\<in>#\\<^sub>z \\<Delta>) = (y \\<in>#\\<^sub>z \\<Delta>2 \\<or> y = x)\n  \\<forall>y.\n     (y \\<in>#\\<^sub>z \\<Delta>) = (y \\<in>#\\<^sub>z \\<Delta>2 \\<or> y = x)", "have \"\\<forall>y. (y \\<in> set_zmset \\<Delta> = (y \\<in> (set_zmset \\<Delta>2 \\<union> {x})))\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y \\<in>#\\<^sub>z \\<Delta>) = (y \\<in>#\\<^sub>z \\<Delta>2 \\<or> y = x)\n  \\<forall>y.\n     (y \\<in>#\\<^sub>z \\<Delta>) = (y \\<in>#\\<^sub>z \\<Delta>2 \\<or> y = x)\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in>#\\<^sub>z \\<Delta>) =\n       (y \\<in> set_zmset \\<Delta>2 \\<union> {x})", "by blast"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y \\<in>#\\<^sub>z \\<Delta>) =\n     (y \\<in> set_zmset \\<Delta>2 \\<union> {x})\n\ngoal (1 subgoal):\n 1. \\<Delta>2 =\n    {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#} \\<Longrightarrow>\n    F = set_zmset \\<Delta>2 - {(loc, t)}", "then"], ["proof (chain)\npicking this:\n  \\<forall>y.\n     (y \\<in>#\\<^sub>z \\<Delta>) =\n     (y \\<in> set_zmset \\<Delta>2 \\<union> {x})", "have \"set_zmset \\<Delta> = set_zmset \\<Delta>2 \\<union> {x}\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y \\<in>#\\<^sub>z \\<Delta>) =\n     (y \\<in> set_zmset \\<Delta>2 \\<union> {x})\n\ngoal (1 subgoal):\n 1. set_zmset \\<Delta> = set_zmset \\<Delta>2 \\<union> {x}", "by (auto simp add: set_eq_iff)"], ["proof (state)\nthis:\n  set_zmset \\<Delta> = set_zmset \\<Delta>2 \\<union> {x}\n\ngoal (1 subgoal):\n 1. \\<Delta>2 =\n    {#y \\<in>#\\<^sub>z \\<Delta>. y \\<noteq> x#} \\<Longrightarrow>\n    F = set_zmset \\<Delta>2 - {(loc, t)}", "with insert(2,3,4) *"], ["proof (chain)\npicking this:\n  x \\<notin> F\n  F = set_zmset ?\\<Delta>21 - {(loc, t)} \\<Longrightarrow>\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (set_zmset ?\\<Delta>21 - {(loc, t)}))\n     loc)\n   t =\n  zcount (c_pts c loc) t\n  insert x F = set_zmset \\<Delta> - {(loc, t)}\n  x \\<notin>#\\<^sub>z \\<Delta>2\n  set_zmset \\<Delta> = set_zmset \\<Delta>2 \\<union> {x}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> F\n  F = set_zmset ?\\<Delta>21 - {(loc, t)} \\<Longrightarrow>\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (set_zmset ?\\<Delta>21 - {(loc, t)}))\n     loc)\n   t =\n  zcount (c_pts c loc) t\n  insert x F = set_zmset \\<Delta> - {(loc, t)}\n  x \\<notin>#\\<^sub>z \\<Delta>2\n  set_zmset \\<Delta> = set_zmset \\<Delta>2 \\<union> {x}\n\ngoal (1 subgoal):\n 1. F = set_zmset \\<Delta>2 - {(loc, t)}", "by (metis (mono_tags, lifting) Diff_insert Diff_insert2 Diff_insert_absorb Un_empty_right Un_insert_right)"], ["proof (state)\nthis:\n  F = set_zmset \\<Delta>2 - {(loc, t)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F = set_zmset \\<Delta>2 - {(loc, t)}\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<Delta>.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<Delta>.\n           F = set_zmset \\<Delta> - {(loc, t)} \\<Longrightarrow>\n           zcount\n            (c_pts\n              (Finite_Set.fold\n                (\\<lambda>(loc', t') c.\n                    apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n                c (set_zmset \\<Delta> - {(loc, t)}))\n              loc)\n            t =\n           zcount (c_pts c loc) t;\n        insert x F = set_zmset \\<Delta> - {(loc, t)}\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (c_pts\n                            (Finite_Set.fold\n                              (\\<lambda>(loc', t') c.\n                                  apply_cm c loc' t'\n                                   (zcount \\<Delta>' (loc', t')))\n                              c (set_zmset \\<Delta> - {(loc, t)}))\n                            loc)\n                          t =\n                         zcount (c_pts c loc) t", "with final insert"], ["proof (chain)\npicking this:\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (insert x F))\n     loc)\n   t =\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c F)\n     loc)\n   t\n  finite F\n  x \\<notin> F\n  F = set_zmset ?\\<Delta>21 - {(loc, t)} \\<Longrightarrow>\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (set_zmset ?\\<Delta>21 - {(loc, t)}))\n     loc)\n   t =\n  zcount (c_pts c loc) t\n  insert x F = set_zmset \\<Delta> - {(loc, t)}\n  F = set_zmset \\<Delta>2 - {(loc, t)}", "show ?case"], ["proof (prove)\nusing this:\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (insert x F))\n     loc)\n   t =\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c F)\n     loc)\n   t\n  finite F\n  x \\<notin> F\n  F = set_zmset ?\\<Delta>21 - {(loc, t)} \\<Longrightarrow>\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (set_zmset ?\\<Delta>21 - {(loc, t)}))\n     loc)\n   t =\n  zcount (c_pts c loc) t\n  insert x F = set_zmset \\<Delta> - {(loc, t)}\n  F = set_zmset \\<Delta>2 - {(loc, t)}\n\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n         c (set_zmset \\<Delta> - {(loc, t)}))\n       loc)\n     t =\n    zcount (c_pts c loc) t", "by metis"], ["proof (state)\nthis:\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (set_zmset \\<Delta> - {(loc, t)}))\n     loc)\n   t =\n  zcount (c_pts c loc) t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta>' (loc', t')))\n       c (set_zmset \\<Delta> - {(loc, t)}))\n     loc)\n   t =\n  zcount (c_pts c loc) t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zcount_pointstamps_cm_all':\n  \"zcount (c_pts (cm_all' c \\<Delta>) loc) x\n = zcount (c_pts c loc) x + zcount \\<Delta> (loc,x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "let ?f = \"(\\<lambda>(loc', t') c. apply_cm c loc' t' (zcount \\<Delta> (loc',t')))\""], ["proof (state)\ngoal (1 subgoal):\n 1. zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "proof (cases \"zcount \\<Delta> (loc,x) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. zcount \\<Delta> (loc, x) = 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)\n 2. zcount \\<Delta> (loc, x) \\<noteq> 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "case case_nonmember: True"], ["proof (state)\nthis:\n  zcount \\<Delta> (loc, x) = 0\n\ngoal (2 subgoals):\n 1. zcount \\<Delta> (loc, x) = 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)\n 2. zcount \\<Delta> (loc, x) \\<noteq> 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "then"], ["proof (chain)\npicking this:\n  zcount \\<Delta> (loc, x) = 0", "have set_zmset\\<Delta>: \"set_zmset \\<Delta> - {(loc, x)} = set_zmset \\<Delta>\""], ["proof (prove)\nusing this:\n  zcount \\<Delta> (loc, x) = 0\n\ngoal (1 subgoal):\n 1. set_zmset \\<Delta> - {(loc, x)} = set_zmset \\<Delta>", "using zcount_eq_zero_iff"], ["proof (prove)\nusing this:\n  zcount \\<Delta> (loc, x) = 0\n  (zcount ?M ?x = 0) = (?x \\<notin>#\\<^sub>z ?M)\n\ngoal (1 subgoal):\n 1. set_zmset \\<Delta> - {(loc, x)} = set_zmset \\<Delta>", "by fastforce"], ["proof (state)\nthis:\n  set_zmset \\<Delta> - {(loc, x)} = set_zmset \\<Delta>\n\ngoal (2 subgoals):\n 1. zcount \\<Delta> (loc, x) = 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)\n 2. zcount \\<Delta> (loc, x) \\<noteq> 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "have \"zcount (c_pts (cm_all' c \\<Delta>) loc) x\n             = zcount (c_pts c loc) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (c_pts (cm_all' c \\<Delta>) loc) x = zcount (c_pts c loc) x", "unfolding cm_all'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc, t) c. apply_cm c loc t (zcount \\<Delta> (loc, t)))\n         c (set_zmset \\<Delta>))\n       loc)\n     x =\n    zcount (c_pts c loc) x", "apply (subst set_zmset\\<Delta>[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc, t) c. apply_cm c loc t (zcount \\<Delta> (loc, t)))\n         c (set_zmset \\<Delta> - {(loc, x)}))\n       loc)\n     x =\n    zcount (c_pts c loc) x", "apply (simp add: fold_nop)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  zcount (c_pts (cm_all' c \\<Delta>) loc) x = zcount (c_pts c loc) x\n\ngoal (2 subgoals):\n 1. zcount \\<Delta> (loc, x) = 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)\n 2. zcount \\<Delta> (loc, x) \\<noteq> 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "with case_nonmember"], ["proof (chain)\npicking this:\n  zcount \\<Delta> (loc, x) = 0\n  zcount (c_pts (cm_all' c \\<Delta>) loc) x = zcount (c_pts c loc) x", "show ?thesis"], ["proof (prove)\nusing this:\n  zcount \\<Delta> (loc, x) = 0\n  zcount (c_pts (cm_all' c \\<Delta>) loc) x = zcount (c_pts c loc) x\n\ngoal (1 subgoal):\n 1. zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "by auto"], ["proof (state)\nthis:\n  zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n  zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)\n\ngoal (1 subgoal):\n 1. zcount \\<Delta> (loc, x) \\<noteq> 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. zcount \\<Delta> (loc, x) \\<noteq> 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "case case_member: False"], ["proof (state)\nthis:\n  zcount \\<Delta> (loc, x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. zcount \\<Delta> (loc, x) \\<noteq> 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "then"], ["proof (chain)\npicking this:\n  zcount \\<Delta> (loc, x) \\<noteq> 0", "have fold_rec: \"Finite_Set.fold ?f c (set_zmset \\<Delta>)\n             = ?f (loc, x) (Finite_Set.fold ?f c (set_zmset \\<Delta> - {(loc, x)}))\""], ["proof (prove)\nusing this:\n  zcount \\<Delta> (loc, x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>(loc', t') c.\n         apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n     c (set_zmset \\<Delta>) =\n    (case (loc, x) of\n     (loc', t') \\<Rightarrow>\n       \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c (set_zmset \\<Delta> - {(loc, x)}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zcount \\<Delta> (loc, x) \\<noteq> 0 \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>(loc', t') c.\n         apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n     c (set_zmset \\<Delta>) =\n    (case (loc, x) of\n     (loc', t') \\<Rightarrow>\n       \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c (set_zmset \\<Delta> - {(loc, x)}))", "have \"(loc, x) \\<in>#\\<^sub>z \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (loc, x) \\<in>#\\<^sub>z \\<Delta>", "by (meson case_member zcount_inI)"], ["proof (state)\nthis:\n  (loc, x) \\<in>#\\<^sub>z \\<Delta>\n\ngoal (1 subgoal):\n 1. zcount \\<Delta> (loc, x) \\<noteq> 0 \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>(loc', t') c.\n         apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n     c (set_zmset \\<Delta>) =\n    (case (loc, x) of\n     (loc', t') \\<Rightarrow>\n       \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c (set_zmset \\<Delta> - {(loc, x)}))", "then"], ["proof (chain)\npicking this:\n  (loc, x) \\<in>#\\<^sub>z \\<Delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  (loc, x) \\<in>#\\<^sub>z \\<Delta>\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>(loc', t') c.\n         apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n     c (set_zmset \\<Delta>) =\n    (case (loc, x) of\n     (loc', t') \\<Rightarrow>\n       \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c (set_zmset \\<Delta> - {(loc, x)}))", "using comp_fun_commute_apply_cm"], ["proof (prove)\nusing this:\n  (loc, x) \\<in>#\\<^sub>z \\<Delta>\n  comp_fun_commute (\\<lambda>(loc, t) c. apply_cm c loc t (?f loc t))\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>(loc', t') c.\n         apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n     c (set_zmset \\<Delta>) =\n    (case (loc, x) of\n     (loc', t') \\<Rightarrow>\n       \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c (set_zmset \\<Delta> - {(loc, x)}))", "apply (intro comp_fun_commute.fold_rec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(loc, x) \\<in>#\\<^sub>z \\<Delta>;\n     \\<And>f.\n        comp_fun_commute\n         (\\<lambda>(loc, t) c. apply_cm c loc t (f loc t))\\<rbrakk>\n    \\<Longrightarrow> comp_fun_commute\n                       (\\<lambda>(loc', t') c.\n                           apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n 2. \\<lbrakk>(loc, x) \\<in>#\\<^sub>z \\<Delta>;\n     \\<And>f.\n        comp_fun_commute\n         (\\<lambda>(loc, t) c. apply_cm c loc t (f loc t))\\<rbrakk>\n    \\<Longrightarrow> finite (set_zmset \\<Delta>)\n 3. \\<lbrakk>(loc, x) \\<in>#\\<^sub>z \\<Delta>;\n     \\<And>f.\n        comp_fun_commute\n         (\\<lambda>(loc, t) c. apply_cm c loc t (f loc t))\\<rbrakk>\n    \\<Longrightarrow> (loc, x) \\<in>#\\<^sub>z \\<Delta>", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>(loc', t') c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n   c (set_zmset \\<Delta>) =\n  (case (loc, x) of\n   (loc', t') \\<Rightarrow>\n     \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n   (Finite_Set.fold\n     (\\<lambda>(loc', t') c.\n         apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n     c (set_zmset \\<Delta> - {(loc, x)}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>(loc', t') c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n   c (set_zmset \\<Delta>) =\n  (case (loc, x) of\n   (loc', t') \\<Rightarrow>\n     \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n   (Finite_Set.fold\n     (\\<lambda>(loc', t') c.\n         apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n     c (set_zmset \\<Delta> - {(loc, x)}))\n\ngoal (1 subgoal):\n 1. zcount \\<Delta> (loc, x) \\<noteq> 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "have \"zcount (c_pts (Finite_Set.fold ?f c (set_zmset \\<Delta> - {(loc, x)})) loc) x\n          = zcount (c_pts c loc) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n         c (set_zmset \\<Delta> - {(loc, x)}))\n       loc)\n     x =\n    zcount (c_pts c loc) x", "by (simp add: fold_nop)"], ["proof (state)\nthis:\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c (set_zmset \\<Delta> - {(loc, x)}))\n     loc)\n   x =\n  zcount (c_pts c loc) x\n\ngoal (1 subgoal):\n 1. zcount \\<Delta> (loc, x) \\<noteq> 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "then"], ["proof (chain)\npicking this:\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c (set_zmset \\<Delta> - {(loc, x)}))\n     loc)\n   x =\n  zcount (c_pts c loc) x", "have \"zcount (c_pts (Finite_Set.fold ?f c (set_zmset \\<Delta>)) loc) x\n             = zcount (c_pts (?f (loc, x) c) loc) x\""], ["proof (prove)\nusing this:\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c (set_zmset \\<Delta> - {(loc, x)}))\n     loc)\n   x =\n  zcount (c_pts c loc) x\n\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n         c (set_zmset \\<Delta>))\n       loc)\n     x =\n    zcount\n     (c_pts\n       ((case (loc, x) of\n         (loc', t') \\<Rightarrow>\n           \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n         c)\n       loc)\n     x", "using fold_nop fold_rec"], ["proof (prove)\nusing this:\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c (set_zmset \\<Delta> - {(loc, x)}))\n     loc)\n   x =\n  zcount (c_pts c loc) x\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount ?\\<Delta>' (loc', t')))\n       ?c (set_zmset ?\\<Delta> - {(?loc, ?t)}))\n     ?loc)\n   ?t =\n  zcount (c_pts ?c ?loc) ?t\n  Finite_Set.fold\n   (\\<lambda>(loc', t') c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n   c (set_zmset \\<Delta>) =\n  (case (loc, x) of\n   (loc', t') \\<Rightarrow>\n     \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n   (Finite_Set.fold\n     (\\<lambda>(loc', t') c.\n         apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n     c (set_zmset \\<Delta> - {(loc, x)}))\n\ngoal (1 subgoal):\n 1. zcount\n     (c_pts\n       (Finite_Set.fold\n         (\\<lambda>(loc', t') c.\n             apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n         c (set_zmset \\<Delta>))\n       loc)\n     x =\n    zcount\n     (c_pts\n       ((case (loc, x) of\n         (loc', t') \\<Rightarrow>\n           \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n         c)\n       loc)\n     x", "by (simp add: zcount_ps_apply_cm)"], ["proof (state)\nthis:\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c (set_zmset \\<Delta>))\n     loc)\n   x =\n  zcount\n   (c_pts\n     ((case (loc, x) of\n       (loc', t') \\<Rightarrow>\n         \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c)\n     loc)\n   x\n\ngoal (1 subgoal):\n 1. zcount \\<Delta> (loc, x) \\<noteq> 0 \\<Longrightarrow>\n    zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "then"], ["proof (chain)\npicking this:\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c (set_zmset \\<Delta>))\n     loc)\n   x =\n  zcount\n   (c_pts\n     ((case (loc, x) of\n       (loc', t') \\<Rightarrow>\n         \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c)\n     loc)\n   x", "show ?thesis"], ["proof (prove)\nusing this:\n  zcount\n   (c_pts\n     (Finite_Set.fold\n       (\\<lambda>(loc', t') c.\n           apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c (set_zmset \\<Delta>))\n     loc)\n   x =\n  zcount\n   (c_pts\n     ((case (loc, x) of\n       (loc', t') \\<Rightarrow>\n         \\<lambda>c. apply_cm c loc' t' (zcount \\<Delta> (loc', t')))\n       c)\n     loc)\n   x\n\ngoal (1 subgoal):\n 1. zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "by (simp add: zcount_ps_apply_cm cm_all'_def)"], ["proof (state)\nthis:\n  zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n  zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n  zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)\n\ngoal (1 subgoal):\n 1. zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "then"], ["proof (chain)\npicking this:\n  zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n  zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", "show ?thesis"], ["proof (prove)\nusing this:\n  zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n  zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)\n\ngoal (1 subgoal):\n 1. zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n    zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)", ".."], ["proof (state)\nthis:\n  zcount (c_pts (cm_all' c \\<Delta>) loc) x =\n  zcount (c_pts c loc) x + zcount \\<Delta> (loc, x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma implications_apply_cm[simp]: \"c_imp (apply_cm c loc t n) = c_imp c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_imp (apply_cm c loc t n) = c_imp c", "by (auto simp: apply_cm_def)"], ["", "lemma implications_cm_all[simp]:\n  \"c_imp (cm_all' c \\<Delta>) = c_imp c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_imp (cm_all' c \\<Delta>) = c_imp c", "unfolding cm_all'_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. c_imp\n     (Finite_Set.fold\n       (\\<lambda>(loc, t) c. apply_cm c loc t (zcount \\<Delta> (loc, t))) c\n       (set_zmset \\<Delta>)) =\n    c_imp c", "apply (rule fold_invar[OF finite_set_zmset])"], ["proof (prove)\ngoal (3 subgoals):\n 1. c_imp c = c_imp c\n 2. \\<forall>z.\n       \\<forall>x\\<in>#\\<^sub>z\\<Delta>.\n          c_imp z = c_imp c \\<longrightarrow>\n          c_imp\n           ((case x of\n             (loc, t) \\<Rightarrow>\n               \\<lambda>c. apply_cm c loc t (zcount \\<Delta> (loc, t)))\n             z) =\n          c_imp c\n 3. comp_fun_commute\n     (\\<lambda>a.\n         case a of\n         (loc, t) \\<Rightarrow>\n           \\<lambda>c. apply_cm c loc t (zcount \\<Delta> (loc, t)))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lift_cm_inv_cm_all':\n  assumes \"(\\<And>c0 c1 loc t n. P c0 \\<Longrightarrow> next_change_multiplicity' c0 c1 loc t n \\<Longrightarrow> P c1)\"\n    and   \"\\<forall>(loc,t)\\<in>#\\<^sub>z\\<Delta>. \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\"\n    and   \"P c0\"\n  shows   \"P (cm_all' c0 \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (cm_all' c0 \\<Delta>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (cm_all' c0 \\<Delta>)", "let ?cond_invar = \"\\<lambda>c. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>. \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. P (cm_all' c0 \\<Delta>)", "let ?invar = \"\\<lambda>c. ?cond_invar c \\<and> P c\""], ["proof (state)\ngoal (1 subgoal):\n 1. P (cm_all' c0 \\<Delta>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (cm_all' c0 \\<Delta>)", "unfolding cm_all'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (Finite_Set.fold\n        (\\<lambda>(loc, t) c. apply_cm c loc t (zcount \\<Delta> (loc, t)))\n        c0 (set_zmset \\<Delta>))", "apply (rule conjunct2[OF fold_invar[OF finite_set_zmset, of ?invar]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n        \\<exists>t'.\n           t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and>\n           t' \\<le> t) \\<and>\n    P c0\n 2. \\<forall>z.\n       \\<forall>x\\<in>#\\<^sub>z\\<Delta>.\n          (\\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n              \\<exists>t'.\n                 t' \\<in>\\<^sub>A frontier (c_imp z loc) \\<and>\n                 t' \\<le> t) \\<and>\n          P z \\<longrightarrow>\n          (\\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n              \\<exists>t'.\n                 t' \\<in>\\<^sub>A frontier\n                                   (c_imp\n                                     ((case x of\n (loc, t) \\<Rightarrow>\n   \\<lambda>c. apply_cm c loc t (zcount \\<Delta> (loc, t)))\n z)\n                                     loc) \\<and>\n                 t' \\<le> t) \\<and>\n          P ((case x of\n              (loc, t) \\<Rightarrow>\n                \\<lambda>c. apply_cm c loc t (zcount \\<Delta> (loc, t)))\n              z)\n 3. comp_fun_commute\n     (\\<lambda>(loc, t) c. apply_cm c loc t (zcount \\<Delta> (loc, t)))", "using assms(2,3)"], ["proof (prove)\nusing this:\n  \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n     \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\n  P c0\n\ngoal (3 subgoals):\n 1. (\\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n        \\<exists>t'.\n           t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and>\n           t' \\<le> t) \\<and>\n    P c0\n 2. \\<forall>z.\n       \\<forall>x\\<in>#\\<^sub>z\\<Delta>.\n          (\\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n              \\<exists>t'.\n                 t' \\<in>\\<^sub>A frontier (c_imp z loc) \\<and>\n                 t' \\<le> t) \\<and>\n          P z \\<longrightarrow>\n          (\\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n              \\<exists>t'.\n                 t' \\<in>\\<^sub>A frontier\n                                   (c_imp\n                                     ((case x of\n (loc, t) \\<Rightarrow>\n   \\<lambda>c. apply_cm c loc t (zcount \\<Delta> (loc, t)))\n z)\n                                     loc) \\<and>\n                 t' \\<le> t) \\<and>\n          P ((case x of\n              (loc, t) \\<Rightarrow>\n                \\<lambda>c. apply_cm c loc t (zcount \\<Delta> (loc, t)))\n              z)\n 3. comp_fun_commute\n     (\\<lambda>(loc, t) c. apply_cm c loc t (zcount \\<Delta> (loc, t)))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>z.\n       \\<forall>x\\<in>#\\<^sub>z\\<Delta>.\n          (\\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n              \\<exists>t'.\n                 t' \\<in>\\<^sub>A frontier (c_imp z loc) \\<and>\n                 t' \\<le> t) \\<and>\n          P z \\<longrightarrow>\n          (\\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n              \\<exists>t'.\n                 t' \\<in>\\<^sub>A frontier\n                                   (c_imp\n                                     ((case x of\n (loc, t) \\<Rightarrow>\n   \\<lambda>c. apply_cm c loc t (zcount \\<Delta> (loc, t)))\n z)\n                                     loc) \\<and>\n                 t' \\<le> t) \\<and>\n          P ((case x of\n              (loc, t) \\<Rightarrow>\n                \\<lambda>c. apply_cm c loc t (zcount \\<Delta> (loc, t)))\n              z)\n 2. comp_fun_commute\n     (\\<lambda>(loc, t) c. apply_cm c loc t (zcount \\<Delta> (loc, t)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       \\<forall>x\\<in>#\\<^sub>z\\<Delta>.\n          (\\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n              \\<exists>t'.\n                 t' \\<in>\\<^sub>A frontier (c_imp z loc) \\<and>\n                 t' \\<le> t) \\<and>\n          P z \\<longrightarrow>\n          (\\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n              \\<exists>t'.\n                 t' \\<in>\\<^sub>A frontier\n                                   (c_imp\n                                     ((case x of\n (loc, t) \\<Rightarrow>\n   \\<lambda>c. apply_cm c loc t (zcount \\<Delta> (loc, t)))\n z)\n                                     loc) \\<and>\n                 t' \\<le> t) \\<and>\n          P ((case x of\n              (loc, t) \\<Rightarrow>\n                \\<lambda>c. apply_cm c loc t (zcount \\<Delta> (loc, t)))\n              z)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z a b aa ba.\n       \\<lbrakk>(a, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n           \\<exists>t'.\n              t' \\<in>\\<^sub>A frontier (c_imp z loc) \\<and> t' \\<le> t;\n        P z; (aa, ba) \\<in>#\\<^sub>z \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (apply_cm z a b (zcount \\<Delta> (a, b))) aa) \\<and>\n                            t' \\<le> ba\n 2. \\<And>z a b.\n       \\<lbrakk>(a, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n           \\<exists>t'.\n              t' \\<in>\\<^sub>A frontier (c_imp z loc) \\<and> t' \\<le> t;\n        P z\\<rbrakk>\n       \\<Longrightarrow> P (apply_cm z a b (zcount \\<Delta> (a, b)))", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z a b.\n       \\<lbrakk>(a, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n           \\<exists>t'.\n              t' \\<in>\\<^sub>A frontier (c_imp z loc) \\<and> t' \\<le> t;\n        P z\\<rbrakk>\n       \\<Longrightarrow> P (apply_cm z a b (zcount \\<Delta> (a, b)))", "apply (rule assms(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z a b.\n       \\<lbrakk>(a, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n           \\<exists>t'.\n              t' \\<in>\\<^sub>A frontier (c_imp z loc) \\<and> t' \\<le> t;\n        P z\\<rbrakk>\n       \\<Longrightarrow> P (?c0.29 z a b)\n 2. \\<And>z a b.\n       \\<lbrakk>(a, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n           \\<exists>t'.\n              t' \\<in>\\<^sub>A frontier (c_imp z loc) \\<and> t' \\<le> t;\n        P z\\<rbrakk>\n       \\<Longrightarrow> next_change_multiplicity' (?c0.29 z a b)\n                          (apply_cm z a b (zcount \\<Delta> (a, b)))\n                          (?loc29 z a b) (?t29 z a b) (?n29 z a b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z a b.\n       \\<lbrakk>(a, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n           \\<exists>t'.\n              t' \\<in>\\<^sub>A frontier (c_imp z loc) \\<and> t' \\<le> t;\n        P z\\<rbrakk>\n       \\<Longrightarrow> next_change_multiplicity' z\n                          (apply_cm z a b (zcount \\<Delta> (a, b)))\n                          (?loc29 z a b) (?t29 z a b) (?n29 z a b)", "apply (rule apply_cm_is_cm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z a b.\n       \\<lbrakk>(a, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n           \\<exists>t'.\n              t' \\<in>\\<^sub>A frontier (c_imp z loc) \\<and> t' \\<le> t;\n        P z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier (c_imp z a) \\<and>\n                            t' \\<le> b\n 2. \\<And>z a b.\n       \\<lbrakk>(a, b) \\<in>#\\<^sub>z \\<Delta>;\n        \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n           \\<exists>t'.\n              t' \\<in>\\<^sub>A frontier (c_imp z loc) \\<and> t' \\<le> t;\n        P z\\<rbrakk>\n       \\<Longrightarrow> zcount \\<Delta> (a, b) \\<noteq> 0", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute\n     (\\<lambda>(loc, t) c. apply_cm c loc t (zcount \\<Delta> (loc, t)))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P (cm_all' c0 \\<Delta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_cm_inv_cm_all:\n  assumes \"\\<And>c0 c1 loc t n. P c0 \\<Longrightarrow> next_change_multiplicity' c0 c1 loc t n \\<Longrightarrow> P c1\"\n    and   \"\\<forall>(loc,t)\\<in>#\\<^sub>z\\<Delta>. \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\"\n    and   \"P c0\"\n  shows   \"P (cm_all c0 \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (cm_all c0 \\<Delta>)", "apply (subst cm_all_eq_cm_all')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n       \\<exists>t'.\n          t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\n 2. P (cm_all' c0 \\<Delta>)", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n     \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\n\ngoal (2 subgoals):\n 1. \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n       \\<exists>t'.\n          t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\n 2. P (cm_all' c0 \\<Delta>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (cm_all' c0 \\<Delta>)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?c0.20;\n   next_change_multiplicity' ?c0.20 ?c1.20 ?loc20 ?t20 ?n20\\<rbrakk>\n  \\<Longrightarrow> P ?c1.20\n  \\<forall>(loc, t)\\<in>#\\<^sub>z\\<Delta>.\n     \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\n  P c0\n\ngoal (1 subgoal):\n 1. P (cm_all' c0 \\<Delta>)", "apply (rule lift_cm_inv_cm_all')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c0 c1 loc t n.\n       \\<lbrakk>P c0; next_change_multiplicity' c0 c1 loc t n\\<rbrakk>\n       \\<Longrightarrow> P (?c0.29 c0 c1 loc t n)\n 2. \\<And>c0 c1 loc t n.\n       \\<lbrakk>P c0; next_change_multiplicity' c0 c1 loc t n\\<rbrakk>\n       \\<Longrightarrow> next_change_multiplicity' (?c0.29 c0 c1 loc t n) c1\n                          (?loc29 c0 c1 loc t n) (?t29 c0 c1 loc t n)\n                          (?n29 c0 c1 loc t n)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Finds a minimal timestamp - location pair in a non-empty zmset (e.g. in c_work) *)"], ["", "lemma obtain_min_worklist:\n  assumes \"(a (loc'::(_ :: finite))::(('t :: order) zmultiset)) \\<noteq> {#}\\<^sub>z\"\n  obtains loc t\n  where \"t \\<in>#\\<^sub>z a loc\"\n    and \"\\<forall>t' loc'. t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t loc.\n        \\<lbrakk>t \\<in>#\\<^sub>z a loc;\n         \\<forall>t' loc'.\n            t' \\<in>#\\<^sub>z a loc' \\<longrightarrow>\n            \\<not> t' < t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  a loc' \\<noteq> {#}\\<^sub>z\n\ngoal (1 subgoal):\n 1. (\\<And>t loc.\n        \\<lbrakk>t \\<in>#\\<^sub>z a loc;\n         \\<forall>t' loc'.\n            t' \\<in>#\\<^sub>z a loc' \\<longrightarrow>\n            \\<not> t' < t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof atomize_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. a loc' \\<noteq> {#}\\<^sub>z \\<Longrightarrow>\n    \\<exists>t loc.\n       t \\<in>#\\<^sub>z a loc \\<and>\n       (\\<forall>t' loc'.\n           t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t)", "obtain f where f: \"f = minimal_antichain (\\<Union>loc'. set_zmset (a loc'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        f =\n        minimal_antichain\n         (\\<Union>loc'. set_zmset (a loc')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f = minimal_antichain (\\<Union>loc'. set_zmset (a loc'))\n\ngoal (1 subgoal):\n 1. a loc' \\<noteq> {#}\\<^sub>z \\<Longrightarrow>\n    \\<exists>t loc.\n       t \\<in>#\\<^sub>z a loc \\<and>\n       (\\<forall>t' loc'.\n           t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t)", "from assms"], ["proof (chain)\npicking this:\n  a loc' \\<noteq> {#}\\<^sub>z", "obtain x' where x': \"x' \\<in> (\\<Union>loc'. set_zmset (a loc'))\""], ["proof (prove)\nusing this:\n  a loc' \\<noteq> {#}\\<^sub>z\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        x' \\<in> (\\<Union>loc'. set_zmset (a loc')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using pos_zcount_in_zmset"], ["proof (prove)\nusing this:\n  a loc' \\<noteq> {#}\\<^sub>z\n  0 < zcount ?M ?x \\<Longrightarrow> ?x \\<in>#\\<^sub>z ?M\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        x' \\<in> (\\<Union>loc'. set_zmset (a loc')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x' \\<in> (\\<Union>loc'. set_zmset (a loc'))\n\ngoal (1 subgoal):\n 1. a loc' \\<noteq> {#}\\<^sub>z \\<Longrightarrow>\n    \\<exists>t loc.\n       t \\<in>#\\<^sub>z a loc \\<and>\n       (\\<forall>t' loc'.\n           t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t)", "from assms"], ["proof (chain)\npicking this:\n  a loc' \\<noteq> {#}\\<^sub>z", "have \"finite  (\\<Union>loc'. set_zmset (a loc'))\""], ["proof (prove)\nusing this:\n  a loc' \\<noteq> {#}\\<^sub>z\n\ngoal (1 subgoal):\n 1. finite (\\<Union>loc'. set_zmset (a loc'))", "using finite_UNIV"], ["proof (prove)\nusing this:\n  a loc' \\<noteq> {#}\\<^sub>z\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite (\\<Union>loc'. set_zmset (a loc'))", "by blast"], ["proof (state)\nthis:\n  finite (\\<Union>loc'. set_zmset (a loc'))\n\ngoal (1 subgoal):\n 1. a loc' \\<noteq> {#}\\<^sub>z \\<Longrightarrow>\n    \\<exists>t loc.\n       t \\<in>#\\<^sub>z a loc \\<and>\n       (\\<forall>t' loc'.\n           t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t)", "with x'"], ["proof (chain)\npicking this:\n  x' \\<in> (\\<Union>loc'. set_zmset (a loc'))\n  finite (\\<Union>loc'. set_zmset (a loc'))", "have \"f \\<noteq> {}\""], ["proof (prove)\nusing this:\n  x' \\<in> (\\<Union>loc'. set_zmset (a loc'))\n  finite (\\<Union>loc'. set_zmset (a loc'))\n\ngoal (1 subgoal):\n 1. f \\<noteq> {}", "unfolding f"], ["proof (prove)\nusing this:\n  x' \\<in> (\\<Union>loc'. set_zmset (a loc'))\n  finite (\\<Union>loc'. set_zmset (a loc'))\n\ngoal (1 subgoal):\n 1. minimal_antichain (\\<Union>loc'. set_zmset (a loc')) \\<noteq> {}", "using minimal_antichain_nonempty"], ["proof (prove)\nusing this:\n  x' \\<in> (\\<Union>loc'. set_zmset (a loc'))\n  finite (\\<Union>loc'. set_zmset (a loc'))\n  \\<lbrakk>finite ?A; ?t \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> minimal_antichain ?A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. minimal_antichain (\\<Union>loc'. set_zmset (a loc')) \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  f \\<noteq> {}\n\ngoal (1 subgoal):\n 1. a loc' \\<noteq> {#}\\<^sub>z \\<Longrightarrow>\n    \\<exists>t loc.\n       t \\<in>#\\<^sub>z a loc \\<and>\n       (\\<forall>t' loc'.\n           t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t)", "then"], ["proof (chain)\npicking this:\n  f \\<noteq> {}", "obtain t where t: \"t \\<in> f\" \"(\\<forall>s\\<in>f. \\<not> s < t)\""], ["proof (prove)\nusing this:\n  f \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> f; \\<forall>s\\<in>f. \\<not> s < t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_min_if_finite f minimal_antichain_def"], ["proof (prove)\nusing this:\n  f \\<noteq> {}\n  \\<lbrakk>finite ?S; ?S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<in>?S. \\<not> (\\<exists>x\\<in>?S. x < m)\n  f = minimal_antichain (\\<Union>loc'. set_zmset (a loc'))\n  minimal_antichain ?A = {x \\<in> ?A. \\<not> (\\<exists>y\\<in>?A. y < x)}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> f; \\<forall>s\\<in>f. \\<not> s < t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  t \\<in> f\n  \\<forall>s\\<in>f. \\<not> s < t\n\ngoal (1 subgoal):\n 1. a loc' \\<noteq> {#}\\<^sub>z \\<Longrightarrow>\n    \\<exists>t loc.\n       t \\<in>#\\<^sub>z a loc \\<and>\n       (\\<forall>t' loc'.\n           t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t)", "with f"], ["proof (chain)\npicking this:\n  f = minimal_antichain (\\<Union>loc'. set_zmset (a loc'))\n  t \\<in> f\n  \\<forall>s\\<in>f. \\<not> s < t", "have thesis1:  \"\\<forall>t' loc'. t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t\" \"\\<exists>loc. t \\<in>#\\<^sub>z a loc\""], ["proof (prove)\nusing this:\n  f = minimal_antichain (\\<Union>loc'. set_zmset (a loc'))\n  t \\<in> f\n  \\<forall>s\\<in>f. \\<not> s < t\n\ngoal (1 subgoal):\n 1. \\<forall>t' loc'.\n       t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t &&&\n    \\<exists>loc. t \\<in>#\\<^sub>z a loc", "by (simp add: minimal_antichain_def)+"], ["proof (state)\nthis:\n  \\<forall>t' loc'. t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t\n  \\<exists>loc. t \\<in>#\\<^sub>z a loc\n\ngoal (1 subgoal):\n 1. a loc' \\<noteq> {#}\\<^sub>z \\<Longrightarrow>\n    \\<exists>t loc.\n       t \\<in>#\\<^sub>z a loc \\<and>\n       (\\<forall>t' loc'.\n           t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t)", "then"], ["proof (chain)\npicking this:\n  \\<forall>t' loc'. t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t\n  \\<exists>loc. t \\<in>#\\<^sub>z a loc", "show \"\\<exists>t loc. t \\<in>#\\<^sub>z a loc \\<and> (\\<forall>t' loc'. t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t)\""], ["proof (prove)\nusing this:\n  \\<forall>t' loc'. t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t\n  \\<exists>loc. t \\<in>#\\<^sub>z a loc\n\ngoal (1 subgoal):\n 1. \\<exists>t loc.\n       t \\<in>#\\<^sub>z a loc \\<and>\n       (\\<forall>t' loc'.\n           t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t)", "by blast"], ["proof (state)\nthis:\n  \\<exists>t loc.\n     t \\<in>#\\<^sub>z a loc \\<and>\n     (\\<forall>t' loc'.\n         t' \\<in>#\\<^sub>z a loc' \\<longrightarrow> \\<not> t' < t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma propagate_pointstamps_eq:\n  assumes \"c_work c loc \\<noteq> {#}\\<^sub>z\"\n  shows   \"c_pts c = c_pts (SOME c'. \\<exists>loc t. next_propagate' c c' loc t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_pts c = c_pts (SOME c'. next_propagate c c')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c_pts c = c_pts (SOME c'. next_propagate c c')", "from assms"], ["proof (chain)\npicking this:\n  c_work c loc \\<noteq> {#}\\<^sub>z", "obtain loc' t where loc't: \"t \\<in>#\\<^sub>z c_work c loc'\"\n    \"\\<forall>t' loc'. t' \\<in>#\\<^sub>z c_work c loc' \\<longrightarrow> \\<not> t' < t\""], ["proof (prove)\nusing this:\n  c_work c loc \\<noteq> {#}\\<^sub>z\n\ngoal (1 subgoal):\n 1. (\\<And>t loc'.\n        \\<lbrakk>t \\<in>#\\<^sub>z c_work c loc';\n         \\<forall>t' loc'.\n            t' \\<in>#\\<^sub>z c_work c loc' \\<longrightarrow>\n            \\<not> t' < t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule obtain_min_worklist[of \"c_work c\" \"loc\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>loc t.\n       \\<lbrakk>\\<And>t loc'.\n                   \\<lbrakk>t \\<in>#\\<^sub>z c_work c loc';\n                    \\<forall>t' loc'.\n                       t' \\<in>#\\<^sub>z c_work c loc' \\<longrightarrow>\n                       \\<not> t' < t\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<in>#\\<^sub>z c_work c loc;\n        \\<forall>t' loc'.\n           t' \\<in>#\\<^sub>z c_work c loc' \\<longrightarrow>\n           \\<not> t' < t\\<rbrakk>\n       \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in>#\\<^sub>z c_work c loc'\n  \\<forall>t' loc'.\n     t' \\<in>#\\<^sub>z c_work c loc' \\<longrightarrow> \\<not> t' < t\n\ngoal (1 subgoal):\n 1. c_pts c = c_pts (SOME c'. next_propagate c c')", "let ?imps = \"\\<lambda>locX. if locX = loc' then c_imp c locX + {#t' \\<in>#\\<^sub>z c_work c locX. t' = t#}\n                                     else c_imp c locX\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_pts c = c_pts (SOME c'. next_propagate c c')", "let ?wl = \"\\<lambda>locX. if locX = loc' then {#t' \\<in>#\\<^sub>z c_work c locX. t' \\<noteq> t#}\n                    else c_work c locX\n                           + after_summary\n                               (frontier_changes (?imps loc') (c_imp c loc'))\n                               (summary loc' locX)\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_pts c = c_pts (SOME c'. next_propagate c c')", "let ?c = \"c\\<lparr>c_imp := ?imps, c_work := ?wl\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_pts c = c_pts (SOME c'. next_propagate c c')", "from loc't assms"], ["proof (chain)\npicking this:\n  t \\<in>#\\<^sub>z c_work c loc'\n  \\<forall>t' loc'.\n     t' \\<in>#\\<^sub>z c_work c loc' \\<longrightarrow> \\<not> t' < t\n  c_work c loc \\<noteq> {#}\\<^sub>z", "have propagate: \"\\<exists>c'. \\<exists>loc t. next_propagate' c c' loc t\""], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z c_work c loc'\n  \\<forall>t' loc'.\n     t' \\<in>#\\<^sub>z c_work c loc' \\<longrightarrow> \\<not> t' < t\n  c_work c loc \\<noteq> {#}\\<^sub>z\n\ngoal (1 subgoal):\n 1. \\<exists>c'. next_propagate c c'", "by (intro exI[of _ ?c] exI[of _ loc'] exI[of _ t])\n      (auto simp add: next_propagate'_def intro!: Propagate.configuration.equality)"], ["proof (state)\nthis:\n  \\<exists>c'. next_propagate c c'\n\ngoal (1 subgoal):\n 1. c_pts c = c_pts (SOME c'. next_propagate c c')", "{"], ["proof (state)\nthis:\n  \\<exists>c'. next_propagate c c'\n\ngoal (1 subgoal):\n 1. c_pts c = c_pts (SOME c'. next_propagate c c')", "fix c' loc t"], ["proof (state)\ngoal (1 subgoal):\n 1. c_pts c = c_pts (SOME c'. next_propagate c c')", "assume \"next_propagate' c c' loc t\""], ["proof (state)\nthis:\n  next_propagate' c c' loc t\n\ngoal (1 subgoal):\n 1. c_pts c = c_pts (SOME c'. next_propagate c c')", "then"], ["proof (chain)\npicking this:\n  next_propagate' c c' loc t", "have \"c_pts c = c_pts c'\""], ["proof (prove)\nusing this:\n  next_propagate' c c' loc t\n\ngoal (1 subgoal):\n 1. c_pts c = c_pts c'", "by (simp add: next_propagate'_def)"], ["proof (state)\nthis:\n  c_pts c = c_pts c'\n\ngoal (1 subgoal):\n 1. c_pts c = c_pts (SOME c'. next_propagate c c')", "}"], ["proof (state)\nthis:\n  next_propagate' c ?c'22 ?loca22 ?ta22 \\<Longrightarrow>\n  c_pts c = c_pts ?c'22\n\ngoal (1 subgoal):\n 1. c_pts c = c_pts (SOME c'. next_propagate c c')", "with propagate"], ["proof (chain)\npicking this:\n  \\<exists>c'. next_propagate c c'\n  next_propagate' c ?c'22 ?loca22 ?ta22 \\<Longrightarrow>\n  c_pts c = c_pts ?c'22", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>c'. next_propagate c c'\n  next_propagate' c ?c'22 ?loca22 ?ta22 \\<Longrightarrow>\n  c_pts c = c_pts ?c'22\n\ngoal (1 subgoal):\n 1. c_pts c = c_pts (SOME c'. next_propagate c c')", "by (simp add: verit_sko_ex')"], ["proof (state)\nthis:\n  c_pts c = c_pts (SOME c'. next_propagate c c')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma propagate_all_imp_InvGlobPointstampsEq:\n  \"Some c1 = propagate_all c0 \\<Longrightarrow> c_pts c0 = c_pts c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some c1 = propagate_all c0 \\<Longrightarrow> c_pts c0 = c_pts c1", "unfolding propagate_all_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some c1 =\n    while_option\n     (\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z)\n     (\\<lambda>c. SOME c'. next_propagate c c') c0 \\<Longrightarrow>\n    c_pts c0 = c_pts c1", "using while_option_rule[where P=\"(\\<lambda>c. c_pts c0 = c_pts c)\"\n      and b=\"(\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z)\"\n      and c=\"(\\<lambda>c. SOME c'. \\<exists>loc t. next_propagate' c c' loc t)\"]\n    propagate_pointstamps_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>s.\n              \\<lbrakk>c_pts c0 = c_pts s;\n               \\<exists>loc. c_work s loc \\<noteq> {#}\\<^sub>z\\<rbrakk>\n              \\<Longrightarrow> c_pts c0 =\n                                c_pts (SOME c'. next_propagate s c');\n   while_option\n    (\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z)\n    (\\<lambda>c. SOME c'. next_propagate c c') ?s =\n   Some ?t;\n   c_pts c0 = c_pts ?s\\<rbrakk>\n  \\<Longrightarrow> c_pts c0 = c_pts ?t\n  c_work ?c ?loc \\<noteq> {#}\\<^sub>z \\<Longrightarrow>\n  c_pts ?c = c_pts (SOME c'. next_propagate ?c c')\n\ngoal (1 subgoal):\n 1. Some c1 =\n    while_option\n     (\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z)\n     (\\<lambda>c. SOME c'. next_propagate c c') c0 \\<Longrightarrow>\n    c_pts c0 = c_pts c1", "by (metis (no_types, lifting))"], ["", "lemma exists_next_propagate':\n  assumes \"c_work c loc \\<noteq> {#}\\<^sub>z\"\n  shows   \"\\<exists>c' loc t. next_propagate' c c' loc t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c'. next_propagate c c'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c'. next_propagate c c'", "from assms"], ["proof (chain)\npicking this:\n  c_work c loc \\<noteq> {#}\\<^sub>z", "obtain loc' t where loc't:\n    \"t \\<in>#\\<^sub>z c_work c loc'\"\n    \"\\<forall>t' loc'. t' \\<in>#\\<^sub>z c_work c loc' \\<longrightarrow> \\<not> t' < t\""], ["proof (prove)\nusing this:\n  c_work c loc \\<noteq> {#}\\<^sub>z\n\ngoal (1 subgoal):\n 1. (\\<And>t loc'.\n        \\<lbrakk>t \\<in>#\\<^sub>z c_work c loc';\n         \\<forall>t' loc'.\n            t' \\<in>#\\<^sub>z c_work c loc' \\<longrightarrow>\n            \\<not> t' < t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_min_worklist)"], ["proof (state)\nthis:\n  t \\<in>#\\<^sub>z c_work c loc'\n  \\<forall>t' loc'.\n     t' \\<in>#\\<^sub>z c_work c loc' \\<longrightarrow> \\<not> t' < t\n\ngoal (1 subgoal):\n 1. \\<exists>c'. next_propagate c c'", "let ?imps = \"\\<lambda>locX. if locX = loc' then c_imp c locX + {#t' \\<in>#\\<^sub>z c_work c locX. t' = t#}\n                                     else c_imp c locX\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c'. next_propagate c c'", "let ?wl = \"\\<lambda>locX. if locX = loc' then {#t' \\<in>#\\<^sub>z c_work c locX. t' \\<noteq> t#}\n                    else c_work c locX\n                           + after_summary\n                               (frontier_changes (?imps loc') (c_imp c loc'))\n                               (summary loc' locX)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c'. next_propagate c c'", "let ?c = \"c\\<lparr>c_imp := ?imps, c_work := ?wl\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c'. next_propagate c c'", "from loc't assms"], ["proof (chain)\npicking this:\n  t \\<in>#\\<^sub>z c_work c loc'\n  \\<forall>t' loc'.\n     t' \\<in>#\\<^sub>z c_work c loc' \\<longrightarrow> \\<not> t' < t\n  c_work c loc \\<noteq> {#}\\<^sub>z", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z c_work c loc'\n  \\<forall>t' loc'.\n     t' \\<in>#\\<^sub>z c_work c loc' \\<longrightarrow> \\<not> t' < t\n  c_work c loc \\<noteq> {#}\\<^sub>z\n\ngoal (1 subgoal):\n 1. \\<exists>c'. next_propagate c c'", "by (intro exI[of _ ?c] exI[of _ loc'] exI[of _ t])\n      (auto simp: next_propagate'_def intro!: Propagate.configuration.equality)"], ["proof (state)\nthis:\n  \\<exists>c'. next_propagate c c'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_propagate_inv_propagate_all:\n  assumes \"(\\<And>c0 c1 loc t. P c0 \\<Longrightarrow> next_propagate' c0 c1 loc t \\<Longrightarrow> P c1)\"\n    and   \"P c0\"\n    and   \"propagate_all c0 = Some c1\"\n  shows   \"P c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P c1", "apply (rule while_option_rule[of P _, rotated, OF assms(3)[unfolded propagate_all_def], OF assms(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>P s;\n        \\<exists>loc. c_work s loc \\<noteq> {#}\\<^sub>z\\<rbrakk>\n       \\<Longrightarrow> P (SOME c'. next_propagate s c')", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s loc.\n       \\<lbrakk>P s; c_work s loc \\<noteq> {#}\\<^sub>z\\<rbrakk>\n       \\<Longrightarrow> P (SOME c'. next_propagate s c')", "subgoal for c loc"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P c; c_work c loc \\<noteq> {#}\\<^sub>z\\<rbrakk>\n    \\<Longrightarrow> P (SOME c'. next_propagate c c')", "apply (drule exists_next_propagate')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P c; \\<exists>c'. next_propagate c c'\\<rbrakk>\n    \\<Longrightarrow> P (SOME c'. next_propagate c c')", "apply (simp add: assms(1) verit_sko_ex')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Exchange is a Subsystem of Tracker\\<close>"], ["", "text\\<open>Steps in the Tracker are valid steps in the Exchange protocol.\\<close>"], ["", "lemma next_imp_exchange_next:\n  \"Next' c0 c1 \\<Longrightarrow> cri.next' (exchange_config c0) (exchange_config c1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Next' c0 c1 \\<Longrightarrow>\n    cri.next' (exchange_config c0) (exchange_config c1)", "unfolding Next'_def cri.next'_def NextPerformOp'_def NextRecvUpd'_def NextSendUpd'_def NextPropagate'_def NextRecvCap'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>p \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self.\n        cri.next_performop' (exchange_config c0) (exchange_config c1) p\n         \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self \\<and>\n        prop_config c1 = prop_config c0 \\<and> init c1 = init c0) \\<or>\n    (\\<exists>p tt.\n        cri.next_sendupd' (exchange_config c0) (exchange_config c1) p\n         tt \\<and>\n        prop_config c1 = prop_config c0 \\<and> init c1 = init c0) \\<or>\n    (\\<exists>p q.\n        init c0 q \\<and>\n        cri.next_recvupd' (exchange_config c0) (exchange_config c1) p\n         q \\<and>\n        init c1 = init c0 \\<and>\n        (\\<forall>p'.\n            prop_config c1 p' =\n            (if p' = q\n             then cm_all (prop_config c0 q)\n                   (hd (c_msg (exchange_config c0) p q))\n             else prop_config c0 p'))) \\<or>\n    (\\<exists>p.\n        exchange_config c1 = exchange_config c0 \\<and>\n        init c1 = (init c0)(p := True) \\<and>\n        (\\<forall>p'.\n            Some (prop_config c1 p') =\n            (if p' = p then propagate_all (prop_config c0 p')\n             else Some (prop_config c0 p')))) \\<or>\n    (\\<exists>p t.\n        cri.next_recvcap' (exchange_config c0) (exchange_config c1) p\n         t \\<and>\n        prop_config c1 = prop_config c0 \\<and> init c1 = init c0) \\<or>\n    c1 = c0 \\<Longrightarrow>\n    cri.next_performop (exchange_config c0) (exchange_config c1) \\<or>\n    cri.next_sendupd (exchange_config c0) (exchange_config c1) \\<or>\n    cri.next_recvupd (exchange_config c0) (exchange_config c1) \\<or>\n    cri.next_recvcap (exchange_config c0) (exchange_config c1) \\<or>\n    exchange_config c1 = exchange_config c0", "by auto"], ["", "lemma alw_next_imp_exchange_next: \"alw Next s \\<Longrightarrow> alw cri.next (smap exchange_config s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw Next s \\<Longrightarrow> alw cri.next (smap exchange_config s)", "by (coinduction arbitrary: s rule: alw.coinduct) (auto dest: alwD next_imp_exchange_next)"], ["", "text\\<open>Any Tracker trace is a valid Exchange trace\\<close>"], ["", "lemma spec_imp_exchange_spec: \"FullSpec s \\<Longrightarrow> cri.spec (smap exchange_config s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow> cri.spec (smap exchange_config s)", "unfolding cri.spec_def FullSpec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. holds InitConfig s \\<and> alw Next s \\<Longrightarrow>\n    holds cri.init_config (smap exchange_config s) \\<and>\n    alw cri.next (smap exchange_config s)", "by (auto simp: InitConfig_def intro: alw_next_imp_exchange_next)"], ["", "lemma lift_exchange_invariant:\n  assumes \"\\<And>s. cri.spec s \\<Longrightarrow> alw (holds P) s\"\n  shows   \"FullSpec s \\<Longrightarrow> alw (\\<lambda>s. P (exchange_config (shd s))) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow>\n    alw (\\<lambda>s. P (exchange_config (shd s))) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow>\n    alw (\\<lambda>s. P (exchange_config (shd s))) s", "assume \"FullSpec s\""], ["proof (state)\nthis:\n  FullSpec s\n\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow>\n    alw (\\<lambda>s. P (exchange_config (shd s))) s", "note spec_imp_exchange_spec[OF this]"], ["proof (state)\nthis:\n  cri.spec (smap exchange_config s)\n\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow>\n    alw (\\<lambda>s. P (exchange_config (shd s))) s", "note assms[OF this]"], ["proof (state)\nthis:\n  alw (holds P) (smap exchange_config s)\n\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow>\n    alw (\\<lambda>s. P (exchange_config (shd s))) s", "then"], ["proof (chain)\npicking this:\n  alw (holds P) (smap exchange_config s)", "show ?thesis"], ["proof (prove)\nusing this:\n  alw (holds P) (smap exchange_config s)\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>s. P (exchange_config (shd s))) s", "by (auto simp: alw_holds_smap_conv_comp)"], ["proof (state)\nthis:\n  alw (\\<lambda>s. P (exchange_config (shd s))) s\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Lifted Exchange invariants\\<close>"], ["", "lemmas\n  exch_alw_InvCapsNonneg                 = lift_exchange_invariant[OF cri.alw_InvCapsNonneg, unfolded atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvRecordCount                = lift_exchange_invariant[OF cri.alw_InvRecordCount, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvRecordsNonneg              = lift_exchange_invariant[OF cri.alw_InvRecordsNonneg, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvGlobVacantImpRecordsVacant = lift_exchange_invariant[OF cri.alw_InvGlobVacantImpRecordsVacant, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvGlobNonposImpRecordsNonpos = lift_exchange_invariant[OF cri.alw_InvGlobNonposImpRecordsNonpos, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvJustifiedGII               = lift_exchange_invariant[OF cri.alw_InvJustifiedGII, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvJustifiedII                = lift_exchange_invariant[OF cri.alw_InvJustifiedII, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvGlobNonposEqVacant         = lift_exchange_invariant[OF cri.alw_InvGlobNonposEqVacant, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvMsgInGlob                  = lift_exchange_invariant[OF cri.alw_InvMsgInGlob, simplified atomize_imp, simplified, folded atomize_imp] and\n  exch_alw_InvTempJustified              = lift_exchange_invariant[OF cri.alw_InvTempJustified, simplified atomize_imp, simplified, folded atomize_imp]"], ["", "subsection\\<open>Definitions\\<close>"], ["", "(* First variant of global safe *)"], ["", "definition safe_combined :: \"('p::finite, 't::order, 'loc) configuration \\<Rightarrow> bool\" where\n  \"safe_combined c \\<equiv> \\<forall>loc1 loc2 t s p.\n        zcount (cri.records (exchange_config c)) (loc1, t) > 0 \\<and> s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and> init c p\n         \\<longrightarrow> (\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2) \\<and> t' \\<le> results_in t s)\""], ["", "(* Second variant of global safe *)"], ["", "definition safe_combined2 :: \"('p::finite, 't::order, 'loc) configuration \\<Rightarrow> bool\" where\n  \"safe_combined2 c \\<equiv> \\<forall>loc1 loc2 t s p1 p2.\n        zcount (c_caps (exchange_config c) p1) (loc1, t) > 0 \\<and> s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and> init c p2\n         \\<longrightarrow> (\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp (prop_config c p2) loc2) \\<and> t' \\<le> results_in t s)\""], ["", "definition InvGlobPointstampsEq :: \"('p :: finite, 't :: order, 'loc) configuration \\<Rightarrow> bool\" where\n  \"InvGlobPointstampsEq c = (\n     (\\<forall>p loc t. zcount (c_pts (prop_config c p) loc) t\n                 = zcount (c_glob (exchange_config c) p) (loc, t)))\""], ["", "lemma safe_combined_implies_safe_combined2:\n  assumes \"cri.InvCapsNonneg (exchange_config c)\"\n    and   \"safe_combined c\"\n  shows   \"safe_combined2 c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_combined2 c", "unfolding safe_combined2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>loc1 loc2 t s p1 p2.\n       0 < zcount (c_caps (exchange_config c) p1) (loc1, t) \\<and>\n       s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n       init c p2 \\<longrightarrow>\n       (\\<exists>t'.\n           t' \\<in>\\<^sub>A frontier (c_imp (prop_config c p2) loc2) \\<and>\n           t' \\<le> results_in t s)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s p1 p2.\n       \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n        s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (prop_config c p2) loc2) \\<and>\n                            t' \\<le> results_in t s", "subgoal for loc1 loc2 t s p1 p2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c p2) loc2) \\<and>\n                         t' \\<le> results_in t s", "apply (rule assms(2)[unfolded safe_combined_def, rule_format, of loc1 t s loc2 p2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount (cri.records (exchange_config c))\n                           (loc1, t) \\<and>\n                      s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                      init c p2", "apply (simp add: cri.records_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount (sum (c_caps (exchange_config c)) UNIV)\n                           (loc1, t) +\n                          int (count\n                                {#t. (p,\n                                t) \\<in># c_data_msg (exchange_config c)#}\n                                (loc1, t))", "apply (rule add_pos_nonneg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount (sum (c_caps (exchange_config c)) UNIV)\n                           (loc1, t)\n 2. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> int (count\n                                    {#t. (p,\n                                    t) \\<in># c_data_msg\n         (exchange_config c)#}\n                                    (loc1, t))", "apply (subst zcount_sum)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> 0 < (\\<Sum>M\\<in>UNIV.\n                             zcount (c_caps (exchange_config c) M)\n                              (loc1, t))\n 2. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> int (count\n                                    {#t. (p,\n                                    t) \\<in># c_data_msg\n         (exchange_config c)#}\n                                    (loc1, t))", "apply (rule sum_pos[where y = p1])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> finite UNIV\n 2. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>M\\<in>UNIV.\n                         0 \\<le> zcount (c_caps (exchange_config c) M)\n                                  (loc1, t)\n 3. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> p1 \\<in> UNIV\n 4. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount (c_caps (exchange_config c) p1) (loc1, t)\n 5. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> int (count\n                                    {#t. (p,\n                                    t) \\<in># c_data_msg\n         (exchange_config c)#}\n                                    (loc1, t))", "using assms(1)"], ["proof (prove)\nusing this:\n  cri.InvCapsNonneg (exchange_config c)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> finite UNIV\n 2. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>M\\<in>UNIV.\n                         0 \\<le> zcount (c_caps (exchange_config c) M)\n                                  (loc1, t)\n 3. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> p1 \\<in> UNIV\n 4. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount (c_caps (exchange_config c) p1) (loc1, t)\n 5. \\<lbrakk>0 < zcount (c_caps (exchange_config c) p1) (loc1, t);\n     s \\<in>\\<^sub>A path_summary loc1 loc2; init c p2\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> int (count\n                                    {#t. (p,\n                                    t) \\<in># c_data_msg\n         (exchange_config c)#}\n                                    (loc1, t))", "apply (simp_all add: cri.InvCapsNonneg_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Propagate is a Subsystem of Tracker\\<close>"], ["", "subsubsection\\<open>CM Conditions\\<close>"], ["", "definition InvMsgCMConditions where\n  \"InvMsgCMConditions c = (\\<forall>p q.\n    init c q \\<longrightarrow> c_msg (exchange_config c) p q \\<noteq> [] \\<longrightarrow>\n     (\\<forall>(loc,t) \\<in>#\\<^sub>z (hd (c_msg (exchange_config c) p q)). \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp (prop_config c q) loc) \\<and> t' \\<le> t))\""], ["", "text\\<open>Pointstamps in incoming messages all satisfy the CM premise, which is required during NextRecvUpd' steps.\\<close>"], ["", "lemma msg_is_cm_safe:\n  fixes c :: \"('p::finite, 't::order, 'loc) configuration\"\n  assumes \"safe (prop_config c q)\"\n    and   \"InvGlobPointstampsEq c\"\n    and   \"cri.InvMsgInGlob (exchange_config c)\"\n    and   \"c_msg (exchange_config c) p q \\<noteq> []\"\n  shows   \"\\<forall>(loc,t) \\<in>#\\<^sub>z (hd (c_msg (exchange_config c) p q)). \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp (prop_config c q) loc) \\<and> t' \\<le> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(loc, t)\\<in>#\\<^sub>zhd (c_msg (exchange_config c) p q).\n       \\<exists>t'.\n          t' \\<in>\\<^sub>A frontier (c_imp (prop_config c q) loc) \\<and>\n          t' \\<le> t", "using assms(3)[unfolded cri.InvMsgInGlob_def, rule_format, OF assms(4)] assms(1)[unfolded safe_def, rule_format]"], ["proof (prove)\nusing this:\n  ?t \\<in>#\\<^sub>z hd (c_msg (exchange_config c) p q) \\<Longrightarrow>\n  \\<exists>t'.\n     t'\\<le>\\<^sub>p?t \\<and> 0 < zcount (c_glob (exchange_config c) q) t'\n  0 < zcount (c_pts (prop_config c q) ?loc1.0) ?t \\<and>\n  ?s \\<in>\\<^sub>A path_summary ?loc1.0 ?loc2.0 \\<Longrightarrow>\n  \\<exists>t'\\<le>results_in ?t ?s.\n     t' \\<in>\\<^sub>A frontier (c_imp (prop_config c q) ?loc2.0)\n\ngoal (1 subgoal):\n 1. \\<forall>(loc, t)\\<in>#\\<^sub>zhd (c_msg (exchange_config c) p q).\n       \\<exists>t'.\n          t' \\<in>\\<^sub>A frontier (c_imp (prop_config c q) loc) \\<and>\n          t' \\<le> t", "apply (clarsimp simp: cri_less_eq_def assms(2)[unfolded InvGlobPointstampsEq_def, rule_format, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a b.\n                   (a, b)\n                   \\<in>#\\<^sub>z hd (c_msg (exchange_config c) p\n q) \\<Longrightarrow>\n                   \\<exists>aa ba.\n                      (\\<exists>s.\n                          s \\<in>\\<^sub>A path_summary aa a \\<and>\n                          results_in ba s \\<le> b) \\<and>\n                      0 < zcount (c_pts (prop_config c q) aa) ba;\n        \\<And>loc1 t s loc2.\n           0 < zcount (c_pts (prop_config c q) loc1) t \\<and>\n           s \\<in>\\<^sub>A path_summary loc1 loc2 \\<Longrightarrow>\n           \\<exists>t'\\<le>results_in t s.\n              t' \\<in>\\<^sub>A frontier (c_imp (prop_config c q) loc2);\n        (a, b) \\<in>#\\<^sub>z hd (c_msg (exchange_config c) p q)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (prop_config c q) a) \\<and>\n                            t' \\<le> b", "using order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a b.\n                   (a, b)\n                   \\<in>#\\<^sub>z hd (c_msg (exchange_config c) p\n q) \\<Longrightarrow>\n                   \\<exists>aa ba.\n                      (\\<exists>s.\n                          s \\<in>\\<^sub>A path_summary aa a \\<and>\n                          results_in ba s \\<le> b) \\<and>\n                      0 < zcount (c_pts (prop_config c q) aa) ba;\n        \\<And>loc1 t s loc2.\n           0 < zcount (c_pts (prop_config c q) loc1) t \\<and>\n           s \\<in>\\<^sub>A path_summary loc1 loc2 \\<Longrightarrow>\n           \\<exists>t'\\<le>results_in t s.\n              t' \\<in>\\<^sub>A frontier (c_imp (prop_config c q) loc2);\n        (a, b) \\<in>#\\<^sub>z hd (c_msg (exchange_config c) p q)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (prop_config c q) a) \\<and>\n                            t' \\<le> b", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open>Propagate Safety and InvGlobPointstampsEq\\<close>"], ["", "text\\<open>To be able to use the @{thm[source] msg_is_cm_safe} lemma at all times and show that Propagate is a\nsubsystem we need to prove that the specification implies Propagate's safe and the\nInvGlobPointstampsEq. Both of these depend on the CM conditions being satisfied during the\nNextRecvUpd' step and the safety proof additionally depends on other Propagate invariants, which\nmeans that we need to prove all of these jointly.\\<close>"], ["", "abbreviation prop_invs where\n  \"prop_invs c \\<equiv> inv_implications_nonneg c \\<and> inv_imps_work_sum c\""], ["", "abbreviation prop_safe where\n  \"prop_safe c \\<equiv> impl_safe c \\<and> safe c\""], ["", "definition inv_init_imp_prop_safe where\n  \"inv_init_imp_prop_safe c = (\\<forall>p. init c p \\<longrightarrow> prop_safe (prop_config c p))\""], ["", "lemma NextRecvUpd'_preserves_prop_safe:\n  assumes \"prop_safe (prop_config c0 q)\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"cri.InvMsgInGlob (exchange_config c0)\"\n    and   \"NextRecvUpd' c0 c1 p q\"\n  shows   \"prop_safe (prop_config c1 q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prop_safe (prop_config c1 q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prop_safe (prop_config c1 q)", "have safe: \"safe (prop_config c0 q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe (prop_config c0 q)", "using assms(1)"], ["proof (prove)\nusing this:\n  prop_safe (prop_config c0 q)\n\ngoal (1 subgoal):\n 1. safe (prop_config c0 q)", "by blast"], ["proof (state)\nthis:\n  safe (prop_config c0 q)\n\ngoal (1 subgoal):\n 1. prop_safe (prop_config c1 q)", "note recvupd_change = cri.next_recvupdD(1)[OF NextRecvUpdD(2)[OF assms(4)]]"], ["proof (state)\nthis:\n  c_msg (exchange_config c0) p q \\<noteq> []\n\ngoal (1 subgoal):\n 1. prop_safe (prop_config c1 q)", "note cm_conds = msg_is_cm_safe[OF safe assms(2,3) recvupd_change]"], ["proof (state)\nthis:\n  \\<forall>(loc, t)\\<in>#\\<^sub>zhd (c_msg (exchange_config c0) p q).\n     \\<exists>t'.\n        t' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc) \\<and>\n        t' \\<le> t\n\ngoal (1 subgoal):\n 1. prop_safe (prop_config c1 q)", "have safes:\n    \"prop_safe c0 \\<Longrightarrow> next_change_multiplicity' c0 c1 loc t n \\<Longrightarrow> prop_safe c1\" for c0 c1 loc t n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prop_safe c0; next_change_multiplicity' c0 c1 loc t n\\<rbrakk>\n    \\<Longrightarrow> prop_safe c1", "using\n      cm_preserves_safe\n      cm_preserves_impl_safe"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe ?c0.0; impl_safe ?c0.0;\n   next_change_multiplicity' ?c0.0 ?c1.0 ?loc ?t ?n\\<rbrakk>\n  \\<Longrightarrow> safe ?c1.0\n  \\<lbrakk>impl_safe ?c0.0;\n   next_change_multiplicity' ?c0.0 ?c1.0 ?loc ?t ?n\\<rbrakk>\n  \\<Longrightarrow> impl_safe ?c1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prop_safe c0; next_change_multiplicity' c0 c1 loc t n\\<rbrakk>\n    \\<Longrightarrow> prop_safe c1", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>prop_safe ?c0.24;\n   next_change_multiplicity' ?c0.24 ?c1.24 ?loc24 ?t24 ?n24\\<rbrakk>\n  \\<Longrightarrow> prop_safe ?c1.24\n\ngoal (1 subgoal):\n 1. prop_safe (prop_config c1 q)", "show \"prop_safe (prop_config c1 q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prop_safe (prop_config c1 q)", "using\n      lift_cm_inv_cm_all[rotated, OF cm_conds, of prop_safe, OF assms(1)]\n      safes\n      NextRecvUpdD(4)[OF assms(4)]"], ["proof (prove)\nusing this:\n  (\\<And>c0 c1 loc t n.\n      \\<lbrakk>prop_safe c0;\n       next_change_multiplicity' c0 c1 loc t n\\<rbrakk>\n      \\<Longrightarrow> prop_safe c1) \\<Longrightarrow>\n  prop_safe\n   (cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q)))\n  \\<lbrakk>prop_safe ?c0.24;\n   next_change_multiplicity' ?c0.24 ?c1.24 ?loc24 ?t24 ?n24\\<rbrakk>\n  \\<Longrightarrow> prop_safe ?c1.24\n  \\<forall>p'.\n     prop_config c1 p' =\n     (if p' = q\n      then cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q))\n      else prop_config c0 p')\n\ngoal (1 subgoal):\n 1. prop_safe (prop_config c1 q)", "by metis"], ["proof (state)\nthis:\n  prop_safe (prop_config c1 q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NextRecvUpd'_preserves_InvGlobPointstampsEq:\n  assumes \"impl_safe (prop_config c0 q) \\<and> safe (prop_config c0 q)\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"cri.InvMsgInGlob (exchange_config c0)\"\n    and   \"NextRecvUpd' c0 c1 p q\"\n  shows   \"InvGlobPointstampsEq c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvGlobPointstampsEq c1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. InvGlobPointstampsEq c1", "have safe: \"safe (prop_config c0 q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe (prop_config c0 q)", "using assms(1)"], ["proof (prove)\nusing this:\n  prop_safe (prop_config c0 q)\n\ngoal (1 subgoal):\n 1. safe (prop_config c0 q)", "by blast"], ["proof (state)\nthis:\n  safe (prop_config c0 q)\n\ngoal (1 subgoal):\n 1. InvGlobPointstampsEq c1", "note recvupd_change = cri.next_recvupdD(1)[OF NextRecvUpdD(2)[OF assms(4)]]"], ["proof (state)\nthis:\n  c_msg (exchange_config c0) p q \\<noteq> []\n\ngoal (1 subgoal):\n 1. InvGlobPointstampsEq c1", "note cm_conds = msg_is_cm_safe[OF safe assms(2,3) recvupd_change]"], ["proof (state)\nthis:\n  \\<forall>(loc, t)\\<in>#\\<^sub>zhd (c_msg (exchange_config c0) p q).\n     \\<exists>t'.\n        t' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc) \\<and>\n        t' \\<le> t\n\ngoal (1 subgoal):\n 1. InvGlobPointstampsEq c1", "show \"InvGlobPointstampsEq c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InvGlobPointstampsEq c1", "using\n      assms(2,4)\n      cm_conds"], ["proof (prove)\nusing this:\n  InvGlobPointstampsEq c0\n  NextRecvUpd' c0 c1 p q\n  \\<forall>(loc, t)\\<in>#\\<^sub>zhd (c_msg (exchange_config c0) p q).\n     \\<exists>t'.\n        t' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc) \\<and>\n        t' \\<le> t\n\ngoal (1 subgoal):\n 1. InvGlobPointstampsEq c1", "unfolding NextRecvUpd'_def cri.next_recvupd'_def Let_def InvGlobPointstampsEq_def"], ["proof (prove)\nusing this:\n  \\<forall>p loc t.\n     zcount (c_pts (prop_config c0 p) loc) t =\n     zcount (c_glob (exchange_config c0) p) (loc, t)\n  init c0 q \\<and>\n  (c_msg (exchange_config c0) p q \\<noteq> [] \\<and>\n   exchange_config c1 = exchange_config c0\n   \\<lparr>c_msg := (c_msg (exchange_config c0))\n             (p := (c_msg (exchange_config c0) p)\n                (q := tl (c_msg (exchange_config c0) p q))),\n      c_glob := (c_glob (exchange_config c0))\n        (q := c_glob (exchange_config c0) q +\n              hd (c_msg (exchange_config c0) p q))\\<rparr>) \\<and>\n  init c1 = init c0 \\<and>\n  (\\<forall>p'.\n      prop_config c1 p' =\n      (if p' = q\n       then cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q))\n       else prop_config c0 p'))\n  \\<forall>(loc, t)\\<in>#\\<^sub>zhd (c_msg (exchange_config c0) p q).\n     \\<exists>t'.\n        t' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc) \\<and>\n        t' \\<le> t\n\ngoal (1 subgoal):\n 1. \\<forall>p loc t.\n       zcount (c_pts (prop_config c1 p) loc) t =\n       zcount (c_glob (exchange_config c1) p) (loc, t)", "by (clarsimp simp: zcount_pointstamps_cm_all' cm_all_eq_cm_all')+"], ["proof (state)\nthis:\n  InvGlobPointstampsEq c1\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>Whenever some worker p propagates it ends up in a Propagate-safe state\\<close>"], ["", "lemma NextPropagate'_causes_safe:\n  assumes \"NextPropagate' c0 c1 p\"\n    and   \"inv_imps_work_sum (prop_config c1 p)\"\n    and   \"inv_implications_nonneg (prop_config c1 p)\"\n  shows   \"safe (prop_config c1 p)\" \"impl_safe (prop_config c1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe (prop_config c1 p) &&& impl_safe (prop_config c1 p)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. safe (prop_config c1 p)\n 2. impl_safe (prop_config c1 p)", "from assms(1)"], ["proof (chain)\npicking this:\n  NextPropagate' c0 c1 p", "have \"Some (prop_config c1 p) = propagate_all (prop_config c0 p)\""], ["proof (prove)\nusing this:\n  NextPropagate' c0 c1 p\n\ngoal (1 subgoal):\n 1. Some (prop_config c1 p) = propagate_all (prop_config c0 p)", "by (simp add: NextPropagate'_def)"], ["proof (state)\nthis:\n  Some (prop_config c1 p) = propagate_all (prop_config c0 p)\n\ngoal (2 subgoals):\n 1. safe (prop_config c1 p)\n 2. impl_safe (prop_config c1 p)", "then"], ["proof (chain)\npicking this:\n  Some (prop_config c1 p) = propagate_all (prop_config c0 p)", "have wl: \"c_work (prop_config c1 p) loc = {#}\\<^sub>z\" for loc"], ["proof (prove)\nusing this:\n  Some (prop_config c1 p) = propagate_all (prop_config c0 p)\n\ngoal (1 subgoal):\n 1. c_work (prop_config c1 p) loc = {#}\\<^sub>z", "unfolding propagate_all_def"], ["proof (prove)\nusing this:\n  Some (prop_config c1 p) =\n  while_option (\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z)\n   (\\<lambda>c. SOME c'. next_propagate c c') (prop_config c0 p)\n\ngoal (1 subgoal):\n 1. c_work (prop_config c1 p) loc = {#}\\<^sub>z", "by (subst (asm) eq_commute) (auto dest: while_option_stop)"], ["proof (state)\nthis:\n  c_work (prop_config c1 p) ?loc24 = {#}\\<^sub>z\n\ngoal (2 subgoals):\n 1. safe (prop_config c1 p)\n 2. impl_safe (prop_config c1 p)", "show \"safe (prop_config c1 p)\" \"impl_safe (prop_config c1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe (prop_config c1 p) &&& impl_safe (prop_config c1 p)", "by (rule safe[OF assms(2,3) wl]) (rule impl_safe[OF assms(2,3) wl])"], ["proof (state)\nthis:\n  safe (prop_config c1 p)\n  impl_safe (prop_config c1 p)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>NextPropagate' preserves Propagate-safe at all workers\\<close>"], ["", "lemma NextPropagate'_preserves_safe:\n  assumes \"NextPropagate' c0 c1 q\"\n    and   \"inv_imps_work_sum (prop_config c1 p)\"\n    and   \"inv_implications_nonneg (prop_config c1 p)\"\n    and   \"safe (prop_config c0 p)\"\n  shows   \"safe (prop_config c1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe (prop_config c1 p)", "apply (cases \"p=q\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = q \\<Longrightarrow> safe (prop_config c1 p)\n 2. p \\<noteq> q \\<Longrightarrow> safe (prop_config c1 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> safe (prop_config c1 p)", "using assms(1-3)"], ["proof (prove)\nusing this:\n  NextPropagate' c0 c1 q\n  inv_imps_work_sum (prop_config c1 p)\n  inv_implications_nonneg (prop_config c1 p)\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> safe (prop_config c1 p)", "by (auto intro: NextPropagate'_causes_safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> safe (prop_config c1 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> safe (prop_config c1 p)", "using assms(1,4)"], ["proof (prove)\nusing this:\n  NextPropagate' c0 c1 q\n  safe (prop_config c0 p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> safe (prop_config c1 p)", "by (auto dest: spec[of _ p] simp: NextPropagate'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma NextPropagate'_preserves_impl_safe:\n  assumes \"NextPropagate' c0 c1 q\"\n    and   \"inv_imps_work_sum (prop_config c1 p)\"\n    and   \"inv_implications_nonneg (prop_config c1 p)\"\n    and   \"impl_safe (prop_config c0 p)\"\n  shows   \"impl_safe (prop_config c1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_safe (prop_config c1 p)", "apply (cases \"p=q\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = q \\<Longrightarrow> impl_safe (prop_config c1 p)\n 2. p \\<noteq> q \\<Longrightarrow> impl_safe (prop_config c1 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> impl_safe (prop_config c1 p)", "using assms(1-3)"], ["proof (prove)\nusing this:\n  NextPropagate' c0 c1 q\n  inv_imps_work_sum (prop_config c1 p)\n  inv_implications_nonneg (prop_config c1 p)\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> impl_safe (prop_config c1 p)", "by (auto intro: NextPropagate'_causes_safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> impl_safe (prop_config c1 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> impl_safe (prop_config c1 p)", "using assms(1,4)"], ["proof (prove)\nusing this:\n  NextPropagate' c0 c1 q\n  impl_safe (prop_config c0 p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> impl_safe (prop_config c1 p)", "by (auto dest: spec[of _ p] simp: NextPropagate'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma NextRecvUpd'_preserves_inv_init_imp_prop_safe:\n  assumes \"cri.InvMsgInGlob (exchange_config c0)\"\n    and   \"inv_init_imp_prop_safe c0\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"NextRecvUpd' c0 c1 p q\"\n  shows   \"inv_init_imp_prop_safe c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_init_imp_prop_safe c1", "using assms(2)"], ["proof (prove)\nusing this:\n  inv_init_imp_prop_safe c0\n\ngoal (1 subgoal):\n 1. inv_init_imp_prop_safe c1", "unfolding inv_init_imp_prop_safe_def"], ["proof (prove)\nusing this:\n  \\<forall>p. init c0 p \\<longrightarrow> prop_safe (prop_config c0 p)\n\ngoal (1 subgoal):\n 1. \\<forall>p. init c1 p \\<longrightarrow> prop_safe (prop_config c1 p)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p.\n                   init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n        init c1 p\\<rbrakk>\n       \\<Longrightarrow> prop_safe (prop_config c1 p)", "subgoal for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p)", "apply (cases \"p=q\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p; p = q\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p)\n 2. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p; p = q\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p)", "apply (drule spec[of _p])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init c1 p; p = q;\n     init c0 p \\<longrightarrow> prop_safe (prop_config c0 p)\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p)", "apply (simp add: NextRecvUpdD(1)[OF assms(4)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init c1 q; p = q; prop_safe (prop_config c0 q)\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 q)", "apply (drule NextRecvUpd'_preserves_prop_safe[OF _ assms(3,1,4)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init c1 q; p = q; prop_safe (prop_config c1 q)\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 q)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p)", "using NextRecvUpdD(3,4)[OF assms(4)]"], ["proof (prove)\nusing this:\n  init c1 = init c0\n  \\<forall>p'.\n     prop_config c1 p' =\n     (if p' = q\n      then cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q))\n      else prop_config c0 p')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p)", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma NextRecvUpd'_preserves_prop_invs:\n  assumes \"cri.InvMsgInGlob (exchange_config c0)\"\n    and   \"inv_init_imp_prop_safe c0\"\n    and   \"\\<forall>p. prop_invs (prop_config c0 p)\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"NextRecvUpd' c0 c1 p q\"\n  shows   \"\\<forall>p. prop_invs (prop_config c1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. prop_invs (prop_config c1 p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>p. prop_invs (prop_config c1 p)", "have safe: \"safe (prop_config c0 q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe (prop_config c0 q)", "using NextRecvUpdD(1) assms(2,5) inv_init_imp_prop_safe_def"], ["proof (prove)\nusing this:\n  NextRecvUpd' ?c0.0 ?c1.0 ?p ?q \\<Longrightarrow> init ?c0.0 ?q\n  inv_init_imp_prop_safe c0\n  NextRecvUpd' c0 c1 p q\n  inv_init_imp_prop_safe ?c =\n  (\\<forall>p. init ?c p \\<longrightarrow> prop_safe (prop_config ?c p))\n\ngoal (1 subgoal):\n 1. safe (prop_config c0 q)", "by blast"], ["proof (state)\nthis:\n  safe (prop_config c0 q)\n\ngoal (1 subgoal):\n 1. \\<forall>p. prop_invs (prop_config c1 p)", "note recvupd_change = cri.next_recvupdD(1)[OF NextRecvUpdD(2)[OF assms(5)]]"], ["proof (state)\nthis:\n  c_msg (exchange_config c0) p q \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>p. prop_invs (prop_config c1 p)", "note cm_conds = msg_is_cm_safe[OF safe assms(4,1) recvupd_change]"], ["proof (state)\nthis:\n  \\<forall>(loc, t)\\<in>#\\<^sub>zhd (c_msg (exchange_config c0) p q).\n     \\<exists>t'.\n        t' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc) \\<and>\n        t' \\<le> t\n\ngoal (1 subgoal):\n 1. \\<forall>p. prop_invs (prop_config c1 p)", "have invs:\n    \"prop_invs c0 \\<Longrightarrow> next_change_multiplicity' c0 c1 loc t n \\<Longrightarrow> prop_invs c1\" for c0 c1 loc t n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prop_invs c0; next_change_multiplicity' c0 c1 loc t n\\<rbrakk>\n    \\<Longrightarrow> prop_invs c1", "using\n      cm_preserves_inv_imps_work_sum\n      cm_preserves_inv_implications_nonneg"], ["proof (prove)\nusing this:\n  \\<lbrakk>next_change_multiplicity' ?c0.0 ?c1.0 ?loc ?t ?n;\n   inv_imps_work_sum ?c0.0\\<rbrakk>\n  \\<Longrightarrow> inv_imps_work_sum ?c1.0\n  \\<lbrakk>next_change_multiplicity' ?c0.0 ?c1.0 ?loc ?t ?n;\n   inv_implications_nonneg ?c0.0\\<rbrakk>\n  \\<Longrightarrow> inv_implications_nonneg ?c1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prop_invs c0; next_change_multiplicity' c0 c1 loc t n\\<rbrakk>\n    \\<Longrightarrow> prop_invs c1", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>prop_invs ?c0.24;\n   next_change_multiplicity' ?c0.24 ?c1.24 ?loc24 ?t24 ?n24\\<rbrakk>\n  \\<Longrightarrow> prop_invs ?c1.24\n\ngoal (1 subgoal):\n 1. \\<forall>p. prop_invs (prop_config c1 p)", "show \"\\<forall>q. prop_invs (prop_config c1 q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q. prop_invs (prop_config c1 q)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q. prop_invs (prop_config c1 q)", "subgoal for q'"], ["proof (prove)\ngoal (1 subgoal):\n 1. prop_invs (prop_config c1 q')", "apply (cases \"q'=q\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. q' = q \\<Longrightarrow> prop_invs (prop_config c1 q')\n 2. q' \\<noteq> q \\<Longrightarrow> prop_invs (prop_config c1 q')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. q' = q \\<Longrightarrow> prop_invs (prop_config c1 q')", "using\n          lift_cm_inv_cm_all[rotated, OF cm_conds, of prop_invs, OF assms(3)[rule_format]]\n          invs\n          NextRecvUpdD(4)[OF assms(5)]"], ["proof (prove)\nusing this:\n  (\\<And>c0 c1 loc t n.\n      \\<lbrakk>prop_invs c0;\n       next_change_multiplicity' c0 c1 loc t n\\<rbrakk>\n      \\<Longrightarrow> prop_invs c1) \\<Longrightarrow>\n  prop_invs\n   (cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q)))\n  \\<lbrakk>prop_invs ?c0.24;\n   next_change_multiplicity' ?c0.24 ?c1.24 ?loc24 ?t24 ?n24\\<rbrakk>\n  \\<Longrightarrow> prop_invs ?c1.24\n  \\<forall>p'.\n     prop_config c1 p' =\n     (if p' = q\n      then cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q))\n      else prop_config c0 p')\n\ngoal (1 subgoal):\n 1. q' = q \\<Longrightarrow> prop_invs (prop_config c1 q')", "by metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. q' \\<noteq> q \\<Longrightarrow> prop_invs (prop_config c1 q')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. q' \\<noteq> q \\<Longrightarrow> prop_invs (prop_config c1 q')", "using NextRecvUpdD(4) assms(3) assms(5)"], ["proof (prove)\nusing this:\n  NextRecvUpd' ?c0.0 ?c1.0 ?p ?q \\<Longrightarrow>\n  \\<forall>p'.\n     prop_config ?c1.0 p' =\n     (if p' = ?q\n      then cm_all (prop_config ?c0.0 ?q)\n            (hd (c_msg (exchange_config ?c0.0) ?p ?q))\n      else prop_config ?c0.0 p')\n  \\<forall>p. prop_invs (prop_config c0 p)\n  NextRecvUpd' c0 c1 p q\n\ngoal (1 subgoal):\n 1. q' \\<noteq> q \\<Longrightarrow> prop_invs (prop_config c1 q')", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>q. prop_invs (prop_config c1 q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NextPropagate'_preserves_prop_invs:\n  assumes \"prop_invs (prop_config c0 q)\"\n    and   \"NextPropagate' c0 c1 p\"\n  shows   \"prop_invs (prop_config c1 q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prop_invs (prop_config c1 q)", "apply (cases \"p=q\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = q \\<Longrightarrow> prop_invs (prop_config c1 q)\n 2. p \\<noteq> q \\<Longrightarrow> prop_invs (prop_config c1 q)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> prop_invs (prop_config c1 q)", "using\n      assms(1)\n      lift_propagate_inv_propagate_all[\n        of prop_invs,\n        rotated 2,\n        OF NextPropagateD(3)[OF assms(2), rule_format, of p, simplified, symmetric]]"], ["proof (prove)\nusing this:\n  prop_invs (prop_config c0 q)\n  \\<lbrakk>\\<And>c0 c1 loc t.\n              \\<lbrakk>prop_invs c0; next_propagate' c0 c1 loc t\\<rbrakk>\n              \\<Longrightarrow> prop_invs c1;\n   prop_invs (prop_config c0 p)\\<rbrakk>\n  \\<Longrightarrow> prop_invs (prop_config c1 p)\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> prop_invs (prop_config c1 q)", "by (simp add: iiws_imp_iipwn p_preserves_inv_implications_nonneg p_preserves_inv_imps_work_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> prop_invs (prop_config c1 q)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> prop_invs (prop_config c1 q)", "by (metis NextPropagateD(3) assms(1) assms(2) option.simps(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma NextPropagate'_preserves_inv_init_imp_prop_safe:\n  assumes \"prop_invs (prop_config c0 p)\"\n    and   \"inv_init_imp_prop_safe c0\"\n    and   \"NextPropagate' c0 c1 p\"\n  shows   \"inv_init_imp_prop_safe c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_init_imp_prop_safe c1", "using assms(2)"], ["proof (prove)\nusing this:\n  inv_init_imp_prop_safe c0\n\ngoal (1 subgoal):\n 1. inv_init_imp_prop_safe c1", "unfolding inv_init_imp_prop_safe_def"], ["proof (prove)\nusing this:\n  \\<forall>p. init c0 p \\<longrightarrow> prop_safe (prop_config c0 p)\n\ngoal (1 subgoal):\n 1. \\<forall>p. init c1 p \\<longrightarrow> prop_safe (prop_config c1 p)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p.\n                   init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n        init c1 p\\<rbrakk>\n       \\<Longrightarrow> prop_safe (prop_config c1 p)", "subgoal for p'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p'\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p')", "apply (cases \"p'=p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p'; p' = p\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p')\n 2. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p'; p' \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p'; p' = p\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p')", "using NextPropagate'_preserves_prop_invs[OF assms(1,3)]"], ["proof (prove)\nusing this:\n  prop_invs (prop_config c1 p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p'; p' = p\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p')", "using NextPropagate'_causes_safe(1,2)[OF assms(3)]"], ["proof (prove)\nusing this:\n  prop_invs (prop_config c1 p)\n  \\<lbrakk>inv_imps_work_sum (prop_config c1 p);\n   inv_implications_nonneg (prop_config c1 p)\\<rbrakk>\n  \\<Longrightarrow> safe (prop_config c1 p)\n  \\<lbrakk>inv_imps_work_sum (prop_config c1 p);\n   inv_implications_nonneg (prop_config c1 p)\\<rbrakk>\n  \\<Longrightarrow> impl_safe (prop_config c1 p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p'; p' = p\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p')", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p'; p' \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p'; p' \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p')", "using NextPropagateD(2,3)[OF assms(3)]"], ["proof (prove)\nusing this:\n  init c1 = (init c0)(p := True)\n  \\<forall>p'.\n     Some (prop_config c1 p') =\n     (if p' = p then propagate_all (prop_config c0 p')\n      else Some (prop_config c0 p'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     init c1 p'; p' \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> prop_safe (prop_config c1 p')", "by (auto dest: spec[of _ p'])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Next'_preserves_invs:\n  assumes \"cri.InvMsgInGlob (exchange_config c0)\"\n    and   \"inv_init_imp_prop_safe c0\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"Next' c0 c1\"\n    and   \"\\<forall>p. prop_invs (prop_config c0 p)\"\n  shows\n    \"inv_init_imp_prop_safe c1\"\n    \"\\<forall>p. prop_invs (prop_config c1 p)\"\n    \"InvGlobPointstampsEq c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_init_imp_prop_safe c1 &&&\n    \\<forall>p. prop_invs (prop_config c1 p) &&& InvGlobPointstampsEq c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_init_imp_prop_safe c1", "using assms(4)"], ["proof (prove)\nusing this:\n  Next' c0 c1\n\ngoal (1 subgoal):\n 1. inv_init_imp_prop_safe c1", "unfolding Next'_def"], ["proof (prove)\nusing this:\n  NextPerformOp c0 c1 \\<or>\n  NextSendUpd c0 c1 \\<or>\n  NextRecvUpd c0 c1 \\<or>\n  NextPropagate c0 c1 \\<or> NextRecvCap c0 c1 \\<or> c1 = c0\n\ngoal (1 subgoal):\n 1. inv_init_imp_prop_safe c1", "using assms(2)"], ["proof (prove)\nusing this:\n  NextPerformOp c0 c1 \\<or>\n  NextSendUpd c0 c1 \\<or>\n  NextRecvUpd c0 c1 \\<or>\n  NextPropagate c0 c1 \\<or> NextRecvCap c0 c1 \\<or> c1 = c0\n  inv_init_imp_prop_safe c0\n\ngoal (1 subgoal):\n 1. inv_init_imp_prop_safe c1", "apply (elim disjE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; NextPerformOp c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 2. \\<lbrakk>inv_init_imp_prop_safe c0; NextSendUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 3. \\<lbrakk>inv_init_imp_prop_safe c0; NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 4. \\<lbrakk>inv_init_imp_prop_safe c0; NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 5. \\<lbrakk>inv_init_imp_prop_safe c0; NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 6. \\<lbrakk>inv_init_imp_prop_safe c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; NextPerformOp c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "unfolding inv_init_imp_prop_safe_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     NextPerformOp c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p.\n                         init c1 p \\<longrightarrow>\n                         prop_safe (prop_config c1 p)", "using NextPerformOpD(2,3)"], ["proof (prove)\nusing this:\n  NextPerformOp' ?c0.0 ?c1.0 ?p ?\\<Delta>neg ?\\<Delta>mint_msg\n   ?\\<Delta>mint_self \\<Longrightarrow>\n  prop_config ?c1.0 = prop_config ?c0.0\n  NextPerformOp' ?c0.0 ?c1.0 ?p ?\\<Delta>neg ?\\<Delta>mint_msg\n   ?\\<Delta>mint_self \\<Longrightarrow>\n  init ?c1.0 = init ?c0.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     NextPerformOp c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p.\n                         init c1 p \\<longrightarrow>\n                         prop_safe (prop_config c1 p)", "by fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; NextSendUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 2. \\<lbrakk>inv_init_imp_prop_safe c0; NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 3. \\<lbrakk>inv_init_imp_prop_safe c0; NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 4. \\<lbrakk>inv_init_imp_prop_safe c0; NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 5. \\<lbrakk>inv_init_imp_prop_safe c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; NextSendUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "unfolding inv_init_imp_prop_safe_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     NextSendUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p.\n                         init c1 p \\<longrightarrow>\n                         prop_safe (prop_config c1 p)", "using NextSendUpdD(2,3)"], ["proof (prove)\nusing this:\n  NextSendUpd' ?c0.0 ?c1.0 ?p ?tt \\<Longrightarrow>\n  prop_config ?c1.0 = prop_config ?c0.0\n  NextSendUpd' ?c0.0 ?c1.0 ?p ?tt \\<Longrightarrow> init ?c1.0 = init ?c0.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     NextSendUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p.\n                         init c1 p \\<longrightarrow>\n                         prop_safe (prop_config c1 p)", "by fastforce"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 2. \\<lbrakk>inv_init_imp_prop_safe c0; NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 3. \\<lbrakk>inv_init_imp_prop_safe c0; NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 4. \\<lbrakk>inv_init_imp_prop_safe c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "using NextRecvUpd'_preserves_inv_init_imp_prop_safe[OF assms(1,2,3)]"], ["proof (prove)\nusing this:\n  NextRecvUpd' c0 ?c1.0 ?p ?q \\<Longrightarrow> inv_init_imp_prop_safe ?c1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 2. \\<lbrakk>inv_init_imp_prop_safe c0; NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 3. \\<lbrakk>inv_init_imp_prop_safe c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "using NextPropagate'_preserves_inv_init_imp_prop_safe assms(5)"], ["proof (prove)\nusing this:\n  \\<lbrakk>prop_invs (prop_config ?c0.0 ?p); inv_init_imp_prop_safe ?c0.0;\n   NextPropagate' ?c0.0 ?c1.0 ?p\\<rbrakk>\n  \\<Longrightarrow> inv_init_imp_prop_safe ?c1.0\n  \\<forall>p. prop_invs (prop_config c0 p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1\n 2. \\<lbrakk>inv_init_imp_prop_safe c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "unfolding inv_init_imp_prop_safe_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p.\n                         init c1 p \\<longrightarrow>\n                         prop_safe (prop_config c1 p)", "using NextRecvCapD(2,3)"], ["proof (prove)\nusing this:\n  NextRecvCap' ?c0.0 ?c1.0 ?p ?t \\<Longrightarrow>\n  prop_config ?c1.0 = prop_config ?c0.0\n  NextRecvCap' ?c0.0 ?c1.0 ?p ?t \\<Longrightarrow> init ?c1.0 = init ?c0.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                init c0 p \\<longrightarrow> prop_safe (prop_config c0 p);\n     NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p.\n                         init c1 p \\<longrightarrow>\n                         prop_safe (prop_config c1 p)", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_init_imp_prop_safe c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> inv_init_imp_prop_safe c1", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>p. prop_invs (prop_config c1 p)\n 2. InvGlobPointstampsEq c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. prop_invs (prop_config c1 p)", "using assms(4)"], ["proof (prove)\nusing this:\n  Next' c0 c1\n\ngoal (1 subgoal):\n 1. \\<forall>p. prop_invs (prop_config c1 p)", "unfolding Next'_def"], ["proof (prove)\nusing this:\n  NextPerformOp c0 c1 \\<or>\n  NextSendUpd c0 c1 \\<or>\n  NextRecvUpd c0 c1 \\<or>\n  NextPropagate c0 c1 \\<or> NextRecvCap c0 c1 \\<or> c1 = c0\n\ngoal (1 subgoal):\n 1. \\<forall>p. prop_invs (prop_config c1 p)", "using assms(5)"], ["proof (prove)\nusing this:\n  NextPerformOp c0 c1 \\<or>\n  NextSendUpd c0 c1 \\<or>\n  NextRecvUpd c0 c1 \\<or>\n  NextPropagate c0 c1 \\<or> NextRecvCap c0 c1 \\<or> c1 = c0\n  \\<forall>p. prop_invs (prop_config c0 p)\n\ngoal (1 subgoal):\n 1. \\<forall>p. prop_invs (prop_config c1 p)", "apply (elim disjE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextPerformOp c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 2. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextSendUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 3. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 4. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 5. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 6. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p); c1 = c0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextPerformOp c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "using NextPerformOpD(2)"], ["proof (prove)\nusing this:\n  NextPerformOp' ?c0.0 ?c1.0 ?p ?\\<Delta>neg ?\\<Delta>mint_msg\n   ?\\<Delta>mint_self \\<Longrightarrow>\n  prop_config ?c1.0 = prop_config ?c0.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextPerformOp c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "by fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextSendUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 2. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 3. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 4. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 5. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p); c1 = c0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextSendUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "using NextSendUpdD(2)"], ["proof (prove)\nusing this:\n  NextSendUpd' ?c0.0 ?c1.0 ?p ?tt \\<Longrightarrow>\n  prop_config ?c1.0 = prop_config ?c0.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextSendUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "by fastforce"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 2. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 3. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 4. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p); c1 = c0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "using assms(1,2,3) NextRecvUpd'_preserves_prop_invs"], ["proof (prove)\nusing this:\n  cri.InvMsgInGlob (exchange_config c0)\n  inv_init_imp_prop_safe c0\n  InvGlobPointstampsEq c0\n  \\<lbrakk>cri.InvMsgInGlob (exchange_config ?c0.0);\n   inv_init_imp_prop_safe ?c0.0;\n   \\<forall>p. prop_invs (prop_config ?c0.0 p); InvGlobPointstampsEq ?c0.0;\n   NextRecvUpd' ?c0.0 ?c1.0 ?p ?q\\<rbrakk>\n  \\<Longrightarrow> \\<forall>p. prop_invs (prop_config ?c1.0 p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 2. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 3. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p); c1 = c0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "using NextPropagate'_preserves_prop_invs"], ["proof (prove)\nusing this:\n  \\<lbrakk>prop_invs (prop_config ?c0.0 ?q);\n   NextPropagate' ?c0.0 ?c1.0 ?p\\<rbrakk>\n  \\<Longrightarrow> prop_invs (prop_config ?c1.0 ?q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)\n 2. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p); c1 = c0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "unfolding inv_init_imp_prop_safe_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "using NextRecvCapD(2,3)"], ["proof (prove)\nusing this:\n  NextRecvCap' ?c0.0 ?c1.0 ?p ?t \\<Longrightarrow>\n  prop_config ?c1.0 = prop_config ?c0.0\n  NextRecvCap' ?c0.0 ?c1.0 ?p ?t \\<Longrightarrow> init ?c1.0 = init ?c0.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p);\n     NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p); c1 = c0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p. prop_invs (prop_config c0 p); c1 = c0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c1 p)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. InvGlobPointstampsEq c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. InvGlobPointstampsEq c1", "using assms(4)"], ["proof (prove)\nusing this:\n  Next' c0 c1\n\ngoal (1 subgoal):\n 1. InvGlobPointstampsEq c1", "unfolding Next'_def"], ["proof (prove)\nusing this:\n  NextPerformOp c0 c1 \\<or>\n  NextSendUpd c0 c1 \\<or>\n  NextRecvUpd c0 c1 \\<or>\n  NextPropagate c0 c1 \\<or> NextRecvCap c0 c1 \\<or> c1 = c0\n\ngoal (1 subgoal):\n 1. InvGlobPointstampsEq c1", "using assms(3)"], ["proof (prove)\nusing this:\n  NextPerformOp c0 c1 \\<or>\n  NextSendUpd c0 c1 \\<or>\n  NextRecvUpd c0 c1 \\<or>\n  NextPropagate c0 c1 \\<or> NextRecvCap c0 c1 \\<or> c1 = c0\n  InvGlobPointstampsEq c0\n\ngoal (1 subgoal):\n 1. InvGlobPointstampsEq c1", "apply (elim disjE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>InvGlobPointstampsEq c0; NextPerformOp c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 2. \\<lbrakk>InvGlobPointstampsEq c0; NextSendUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 3. \\<lbrakk>InvGlobPointstampsEq c0; NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 4. \\<lbrakk>InvGlobPointstampsEq c0; NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 5. \\<lbrakk>InvGlobPointstampsEq c0; NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 6. \\<lbrakk>InvGlobPointstampsEq c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobPointstampsEq c0; NextPerformOp c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1", "by (metis InvGlobPointstampsEq_def NextPerformOpD(1,2) cri.next_performopD(7))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>InvGlobPointstampsEq c0; NextSendUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 2. \\<lbrakk>InvGlobPointstampsEq c0; NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 3. \\<lbrakk>InvGlobPointstampsEq c0; NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 4. \\<lbrakk>InvGlobPointstampsEq c0; NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 5. \\<lbrakk>InvGlobPointstampsEq c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobPointstampsEq c0; NextSendUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1", "by (metis InvGlobPointstampsEq_def NextSendUpdD(1,2) cri.next_sendupdD(5))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>InvGlobPointstampsEq c0; NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 2. \\<lbrakk>InvGlobPointstampsEq c0; NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 3. \\<lbrakk>InvGlobPointstampsEq c0; NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 4. \\<lbrakk>InvGlobPointstampsEq c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobPointstampsEq c0; NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1", "using NextRecvUpdD(1) NextRecvUpd'_preserves_InvGlobPointstampsEq assms(1,2) inv_init_imp_prop_safe_def"], ["proof (prove)\nusing this:\n  NextRecvUpd' ?c0.0 ?c1.0 ?p ?q \\<Longrightarrow> init ?c0.0 ?q\n  \\<lbrakk>prop_safe (prop_config ?c0.0 ?q); InvGlobPointstampsEq ?c0.0;\n   cri.InvMsgInGlob (exchange_config ?c0.0);\n   NextRecvUpd' ?c0.0 ?c1.0 ?p ?q\\<rbrakk>\n  \\<Longrightarrow> InvGlobPointstampsEq ?c1.0\n  cri.InvMsgInGlob (exchange_config c0)\n  inv_init_imp_prop_safe c0\n  inv_init_imp_prop_safe ?c =\n  (\\<forall>p. init ?c p \\<longrightarrow> prop_safe (prop_config ?c p))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobPointstampsEq c0; NextRecvUpd c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>InvGlobPointstampsEq c0; NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 2. \\<lbrakk>InvGlobPointstampsEq c0; NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 3. \\<lbrakk>InvGlobPointstampsEq c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobPointstampsEq c0; NextPropagate c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1", "unfolding NextPropagate'_def InvGlobPointstampsEq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p loc t.\n                zcount (c_pts (prop_config c0 p) loc) t =\n                zcount (c_glob (exchange_config c0) p) (loc, t);\n     \\<exists>p.\n        exchange_config c1 = exchange_config c0 \\<and>\n        init c1 = (init c0)(p := True) \\<and>\n        (\\<forall>p'.\n            Some (prop_config c1 p') =\n            (if p' = p then propagate_all (prop_config c0 p')\n             else Some (prop_config c0 p')))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p loc t.\n                         zcount (c_pts (prop_config c1 p) loc) t =\n                         zcount (c_glob (exchange_config c1) p) (loc, t)", "using propagate_all_imp_InvGlobPointstampsEq"], ["proof (prove)\nusing this:\n  Some ?c1.0 = propagate_all ?c0.0 \\<Longrightarrow>\n  c_pts ?c0.0 = c_pts ?c1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p loc t.\n                zcount (c_pts (prop_config c0 p) loc) t =\n                zcount (c_glob (exchange_config c0) p) (loc, t);\n     \\<exists>p.\n        exchange_config c1 = exchange_config c0 \\<and>\n        init c1 = (init c0)(p := True) \\<and>\n        (\\<forall>p'.\n            Some (prop_config c1 p') =\n            (if p' = p then propagate_all (prop_config c0 p')\n             else Some (prop_config c0 p')))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p loc t.\n                         zcount (c_pts (prop_config c1 p) loc) t =\n                         zcount (c_glob (exchange_config c1) p) (loc, t)", "by (metis option.inject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>InvGlobPointstampsEq c0; NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1\n 2. \\<lbrakk>InvGlobPointstampsEq c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobPointstampsEq c0; NextRecvCap c0 c1\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1", "by (metis InvGlobPointstampsEq_def NextRecvCapD(1) NextRecvCapD(2) cri.next_recvcapD(4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobPointstampsEq c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InvGlobPointstampsEq c0; c1 = c0\\<rbrakk>\n    \\<Longrightarrow> InvGlobPointstampsEq c1", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma init_imp_InvGlobPointstampsEq: \"InitConfig c \\<Longrightarrow> InvGlobPointstampsEq c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InitConfig c \\<Longrightarrow> InvGlobPointstampsEq c", "by (simp add: InitConfig_def cri.init_config_def InvGlobPointstampsEq_def)"], ["", "lemma init_imp_inv_init_imp_prop_safe: \"InitConfig c \\<Longrightarrow> inv_init_imp_prop_safe c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InitConfig c \\<Longrightarrow> inv_init_imp_prop_safe c", "by (simp add: inv_init_imp_prop_safe_def InitConfig_def)"], ["", "lemma init_imp_prop_invs: \"InitConfig c \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InitConfig c \\<Longrightarrow> \\<forall>p. prop_invs (prop_config c p)", "by (simp add: InitConfig_def init_imp_inv_implications_nonneg init_imp_inv_imps_work_sum)"], ["", "abbreviation all_invs where\n  \"all_invs c \\<equiv> InvGlobPointstampsEq c \\<and> inv_init_imp_prop_safe c \\<and> (\\<forall>p. prop_invs (prop_config c p))\""], ["", "lemma alw_Next'_alw_invs:\n  assumes \"holds all_invs s\"\n    and   \"alw (holds (\\<lambda>c. cri.InvMsgInGlob (exchange_config c))) s\"\n    and   \"alw Next s\"\n  shows   \"alw (holds all_invs) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (holds all_invs) s", "using assms"], ["proof (prove)\nusing this:\n  holds all_invs s\n  alw (holds (\\<lambda>c. cri.InvMsgInGlob (exchange_config c))) s\n  alw Next s\n\ngoal (1 subgoal):\n 1. alw (holds all_invs) s", "apply (coinduction arbitrary: s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>holds all_invs s;\n        alw (holds (\\<lambda>c. cri.InvMsgInGlob (exchange_config c))) s;\n        alw Next s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            s = xs \\<and>\n                            holds all_invs xs \\<and>\n                            ((\\<exists>s.\n                                 stl xs = s \\<and>\n                                 holds all_invs s \\<and>\n                                 alw (holds\n (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                                  s \\<and>\n                                 alw Next s) \\<or>\n                             alw (holds all_invs) (stl xs))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> InvGlobPointstampsEq (shd (stl s)) \\<and>\n                         inv_init_imp_prop_safe (shd (stl s)) \\<and>\n                         (\\<forall>p.\n                             prop_invs (prop_config (shd (stl s)) p)) \\<and>\n                         alw (holds\n                               (\\<lambda>c.\n                                   cri.InvMsgInGlob (exchange_config c)))\n                          (stl s) \\<and>\n                         alw Next (stl s)", "apply safe"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> InvGlobPointstampsEq (shd (stl s))\n 2. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> inv_init_imp_prop_safe (shd (stl s))\n 3. \\<And>s p.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> inv_implications_nonneg\n                          (prop_config (shd (stl s)) p)\n 4. \\<And>s p.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> inv_imps_work_sum (prop_config (shd (stl s)) p)\n 5. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds\n                               (\\<lambda>c.\n                                   cri.InvMsgInGlob (exchange_config c)))\n                          (stl s)\n 6. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw Next (stl s)", "apply (metis (mono_tags, lifting) alw_holds2 Next'_preserves_invs(3) alwD)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> inv_init_imp_prop_safe (shd (stl s))\n 2. \\<And>s p.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> inv_implications_nonneg\n                          (prop_config (shd (stl s)) p)\n 3. \\<And>s p.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> inv_imps_work_sum (prop_config (shd (stl s)) p)\n 4. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds\n                               (\\<lambda>c.\n                                   cri.InvMsgInGlob (exchange_config c)))\n                          (stl s)\n 5. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw Next (stl s)", "apply (metis (mono_tags, lifting) alw_holds2 Next'_preserves_invs(1) alwD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s p.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> inv_implications_nonneg\n                          (prop_config (shd (stl s)) p)\n 2. \\<And>s p.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> inv_imps_work_sum (prop_config (shd (stl s)) p)\n 3. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds\n                               (\\<lambda>c.\n                                   cri.InvMsgInGlob (exchange_config c)))\n                          (stl s)\n 4. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw Next (stl s)", "apply (metis (mono_tags, lifting) alw_holds2 Next'_preserves_invs(2) alwD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s p.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> inv_imps_work_sum (prop_config (shd (stl s)) p)\n 2. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds\n                               (\\<lambda>c.\n                                   cri.InvMsgInGlob (exchange_config c)))\n                          (stl s)\n 3. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw Next (stl s)", "apply (metis (mono_tags, lifting) alw_holds2 Next'_preserves_invs(2) alwD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw (holds\n                               (\\<lambda>c.\n                                   cri.InvMsgInGlob (exchange_config c)))\n                          (stl s)\n 2. \\<And>s.\n       \\<lbrakk>alw (holds\n                      (\\<lambda>c. cri.InvMsgInGlob (exchange_config c)))\n                 s;\n        alw Next s; InvGlobPointstampsEq (shd s);\n        inv_init_imp_prop_safe (shd s);\n        \\<forall>p. prop_invs (prop_config (shd s) p);\n        \\<not> alw (holds all_invs) (stl s)\\<rbrakk>\n       \\<Longrightarrow> alw Next (stl s)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma alw_invs: \"FullSpec s \\<Longrightarrow> alw (holds all_invs) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow> alw (holds all_invs) s", "apply (frule exch_alw_InvMsgInGlob)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FullSpec s;\n     alw (\\<lambda>s. cri.InvMsgInGlob (exchange_config (shd s))) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds all_invs) s", "unfolding FullSpec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds InitConfig s \\<and> alw Next s;\n     alw (\\<lambda>s. cri.InvMsgInGlob (exchange_config (shd s))) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds all_invs) s", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (\\<lambda>s. cri.InvMsgInGlob (exchange_config (shd s))) s;\n     InitConfig (shd s); alw Next s\\<rbrakk>\n    \\<Longrightarrow> alw (holds all_invs) s", "apply (frule init_imp_InvGlobPointstampsEq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (\\<lambda>s. cri.InvMsgInGlob (exchange_config (shd s))) s;\n     InitConfig (shd s); alw Next s; InvGlobPointstampsEq (shd s)\\<rbrakk>\n    \\<Longrightarrow> alw (holds all_invs) s", "apply (frule init_imp_inv_init_imp_prop_safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (\\<lambda>s. cri.InvMsgInGlob (exchange_config (shd s))) s;\n     InitConfig (shd s); alw Next s; InvGlobPointstampsEq (shd s);\n     inv_init_imp_prop_safe (shd s)\\<rbrakk>\n    \\<Longrightarrow> alw (holds all_invs) s", "apply (drule init_imp_prop_invs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (\\<lambda>s. cri.InvMsgInGlob (exchange_config (shd s))) s;\n     alw Next s; InvGlobPointstampsEq (shd s);\n     inv_init_imp_prop_safe (shd s);\n     \\<forall>p. prop_invs (prop_config (shd s) p)\\<rbrakk>\n    \\<Longrightarrow> alw (holds all_invs) s", "by (simp add: alw_Next'_alw_invs alw_mono)"], ["", "lemma alw_InvGlobPointstampsEq: \"FullSpec s \\<Longrightarrow> alw (holds InvGlobPointstampsEq) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow> alw (holds InvGlobPointstampsEq) s", "using alw_invs alw_mono holds_mono"], ["proof (prove)\nusing this:\n  FullSpec ?s \\<Longrightarrow> alw (holds all_invs) ?s\n  \\<lbrakk>alw ?\\<phi> ?xs;\n   \\<And>xs. ?\\<phi> xs \\<Longrightarrow> ?\\<psi> xs\\<rbrakk>\n  \\<Longrightarrow> alw ?\\<psi> ?xs\n  \\<lbrakk>holds ?P ?xs; \\<And>x. ?P x \\<Longrightarrow> ?Q x\\<rbrakk>\n  \\<Longrightarrow> holds ?Q ?xs\n\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow> alw (holds InvGlobPointstampsEq) s", "by blast"], ["", "lemma alw_inv_init_imp_prop_safe: \"FullSpec s \\<Longrightarrow> alw (holds inv_init_imp_prop_safe) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow> alw (holds inv_init_imp_prop_safe) s", "using alw_invs alw_mono holds_mono"], ["proof (prove)\nusing this:\n  FullSpec ?s \\<Longrightarrow> alw (holds all_invs) ?s\n  \\<lbrakk>alw ?\\<phi> ?xs;\n   \\<And>xs. ?\\<phi> xs \\<Longrightarrow> ?\\<psi> xs\\<rbrakk>\n  \\<Longrightarrow> alw ?\\<psi> ?xs\n  \\<lbrakk>holds ?P ?xs; \\<And>x. ?P x \\<Longrightarrow> ?Q x\\<rbrakk>\n  \\<Longrightarrow> holds ?Q ?xs\n\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow> alw (holds inv_init_imp_prop_safe) s", "by blast"], ["", "lemma alw_holds_conv_shd: \"alw (holds \\<phi>) s = alw (\\<lambda>s. \\<phi> (shd s)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (holds \\<phi>) s = alw (\\<lambda>s. \\<phi> (shd s)) s", "by (simp add: alw_iff_sdrop)"], ["", "lemma alw_prop_invs: \"FullSpec s \\<Longrightarrow> alw (holds (\\<lambda>c. \\<forall>p. prop_invs (prop_config c p))) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow>\n    alw (holds (\\<lambda>c. \\<forall>p. prop_invs (prop_config c p))) s", "by (auto\n      intro: alw_mono[of \"holds all_invs\" s \"holds (\\<lambda>c. \\<forall>p. prop_invs (prop_config c p))\"]\n      dest: alw_invs)"], ["", "lemma nrec_pts_delayed:\n  assumes \"cri.InvGlobNonposImpRecordsNonpos (exchange_config c)\"\n    and \"zcount (cri.records (exchange_config c)) x > 0\"\n  shows \"\\<exists>x'. x' \\<le>\\<^sub>p x \\<and> zcount (c_glob (exchange_config c) p) x' > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       x'\\<le>\\<^sub>px \\<and> 0 < zcount (c_glob (exchange_config c) p) x'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       x'\\<le>\\<^sub>px \\<and> 0 < zcount (c_glob (exchange_config c) p) x'", "from assms"], ["proof (chain)\npicking this:\n  cri.InvGlobNonposImpRecordsNonpos (exchange_config c)\n  0 < zcount (cri.records (exchange_config c)) x", "have r: \"\\<forall>p. \\<not> cri.nonpos_upto (c_glob (exchange_config c) p) x\""], ["proof (prove)\nusing this:\n  cri.InvGlobNonposImpRecordsNonpos (exchange_config c)\n  0 < zcount (cri.records (exchange_config c)) x\n\ngoal (1 subgoal):\n 1. \\<forall>p. \\<not> cri.GlobNonposUpto (exchange_config c) p x", "unfolding cri.InvGlobNonposImpRecordsNonpos_def cri.nonpos_upto_def"], ["proof (prove)\nusing this:\n  \\<forall>t q.\n     (\\<forall>s.\n         s\\<le>\\<^sub>pt \\<longrightarrow>\n         zcount (c_glob (exchange_config c) q) s \\<le> 0) \\<longrightarrow>\n     (\\<forall>s.\n         s\\<le>\\<^sub>pt \\<longrightarrow>\n         zcount (cri.records (exchange_config c)) s \\<le> 0)\n  0 < zcount (cri.records (exchange_config c)) x\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       \\<not> (\\<forall>s.\n                  s\\<le>\\<^sub>px \\<longrightarrow>\n                  zcount (c_glob (exchange_config c) p) s \\<le> 0)", "by (metis linorder_not_less cri.order.order_iff_strict)"], ["proof (state)\nthis:\n  \\<forall>p. \\<not> cri.GlobNonposUpto (exchange_config c) p x\n\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       x'\\<le>\\<^sub>px \\<and> 0 < zcount (c_glob (exchange_config c) p) x'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       x'\\<le>\\<^sub>px \\<and> 0 < zcount (c_glob (exchange_config c) p) x'", "using r[rule_format, of p]"], ["proof (prove)\nusing this:\n  \\<not> cri.GlobNonposUpto (exchange_config c) p x\n\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       x'\\<le>\\<^sub>px \\<and> 0 < zcount (c_glob (exchange_config c) p) x'", "by (auto simp: cri.nonpos_upto_def not_le)"], ["proof (state)\nthis:\n  \\<exists>x'.\n     x'\\<le>\\<^sub>px \\<and> 0 < zcount (c_glob (exchange_config c) p) x'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma help_lemma:\n  assumes \"0 < zcount (c_pts (prop_config c p) loc0) t0\"\n    and \"(loc0, t0) \\<le>\\<^sub>p (loc1, t1)\"\n    and \"s2 \\<in>\\<^sub>A path_summary loc1 loc2\"\n    and \"safe (prop_config c p)\"\n  shows \"\\<exists> t2. (t2 \\<le> results_in t1 s2\n                \\<and> t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t2\\<le>results_in t1 s2.\n       t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t2\\<le>results_in t1 s2.\n       t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)", "from assms(2)"], ["proof (chain)\npicking this:\n  (loc0, t0)\\<le>\\<^sub>p(loc1, t1)", "obtain s1 where s1: \"s1 \\<in>\\<^sub>A path_summary loc0 loc1\" \"results_in t0 s1 \\<le> t1\""], ["proof (prove)\nusing this:\n  (loc0, t0)\\<le>\\<^sub>p(loc1, t1)\n\ngoal (1 subgoal):\n 1. (\\<And>s1.\n        \\<lbrakk>s1 \\<in>\\<^sub>A path_summary loc0 loc1;\n         results_in t0 s1 \\<le> t1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: cri_less_eq_def)"], ["proof (state)\nthis:\n  s1 \\<in>\\<^sub>A path_summary loc0 loc1\n  results_in t0 s1 \\<le> t1\n\ngoal (1 subgoal):\n 1. \\<exists>t2\\<le>results_in t1 s2.\n       t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)", "from s1(1) assms(3)"], ["proof (chain)\npicking this:\n  s1 \\<in>\\<^sub>A path_summary loc0 loc1\n  s2 \\<in>\\<^sub>A path_summary loc1 loc2", "obtain s_full where s_full: \"s_full \\<in>\\<^sub>A path_summary loc0 loc2\" \"s_full \\<le> followed_by s1 s2\""], ["proof (prove)\nusing this:\n  s1 \\<in>\\<^sub>A path_summary loc0 loc1\n  s2 \\<in>\\<^sub>A path_summary loc1 loc2\n\ngoal (1 subgoal):\n 1. (\\<And>s_full.\n        \\<lbrakk>s_full \\<in>\\<^sub>A path_summary loc0 loc2;\n         s_full \\<le> followed_by s1 s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using flow.path_weight_elem_trans"], ["proof (prove)\nusing this:\n  s1 \\<in>\\<^sub>A path_summary loc0 loc1\n  s2 \\<in>\\<^sub>A path_summary loc1 loc2\n  \\<lbrakk>?s \\<in>\\<^sub>A path_summary ?l1.0 ?l2.0;\n   ?s' \\<in>\\<^sub>A path_summary ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u.\n                       u \\<in>\\<^sub>A path_summary ?l1.0 ?l3.0 \\<and>\n                       u \\<le> followed_by ?s ?s'\n\ngoal (1 subgoal):\n 1. (\\<And>s_full.\n        \\<lbrakk>s_full \\<in>\\<^sub>A path_summary loc0 loc2;\n         s_full \\<le> followed_by s1 s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s_full \\<in>\\<^sub>A path_summary loc0 loc2\n  s_full \\<le> followed_by s1 s2\n\ngoal (1 subgoal):\n 1. \\<exists>t2\\<le>results_in t1 s2.\n       t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)", "from s_full(1) assms(1,4)"], ["proof (chain)\npicking this:\n  s_full \\<in>\\<^sub>A path_summary loc0 loc2\n  0 < zcount (c_pts (prop_config c p) loc0) t0\n  safe (prop_config c p)", "obtain t2 where t2:\n    \"t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)\" \"t2 \\<le> results_in t0 s_full\""], ["proof (prove)\nusing this:\n  s_full \\<in>\\<^sub>A path_summary loc0 loc2\n  0 < zcount (c_pts (prop_config c p) loc0) t0\n  safe (prop_config c p)\n\ngoal (1 subgoal):\n 1. (\\<And>t2.\n        \\<lbrakk>t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2);\n         t2 \\<le> results_in t0 s_full\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding safe_def"], ["proof (prove)\nusing this:\n  s_full \\<in>\\<^sub>A path_summary loc0 loc2\n  0 < zcount (c_pts (prop_config c p) loc0) t0\n  \\<forall>loc1 loc2 t s.\n     0 < zcount (c_pts (prop_config c p) loc1) t \\<and>\n     s \\<in>\\<^sub>A path_summary loc1 loc2 \\<longrightarrow>\n     (\\<exists>t'\\<le>results_in t s.\n         t' \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2))\n\ngoal (1 subgoal):\n 1. (\\<And>t2.\n        \\<lbrakk>t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2);\n         t2 \\<le> results_in t0 s_full\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)\n  t2 \\<le> results_in t0 s_full\n\ngoal (1 subgoal):\n 1. \\<exists>t2\\<le>results_in t1 s2.\n       t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)", "from t2(2) and s_full(2)"], ["proof (chain)\npicking this:\n  t2 \\<le> results_in t0 s_full\n  s_full \\<le> followed_by s1 s2", "have \"t2 \\<le> results_in (results_in t0 s1) s2\""], ["proof (prove)\nusing this:\n  t2 \\<le> results_in t0 s_full\n  s_full \\<le> followed_by s1 s2\n\ngoal (1 subgoal):\n 1. t2 \\<le> results_in (results_in t0 s1) s2", "by (metis followed_by_summary order_trans results_in_mono(2))"], ["proof (state)\nthis:\n  t2 \\<le> results_in (results_in t0 s1) s2\n\ngoal (1 subgoal):\n 1. \\<exists>t2\\<le>results_in t1 s2.\n       t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)", "with s1(2)"], ["proof (chain)\npicking this:\n  results_in t0 s1 \\<le> t1\n  t2 \\<le> results_in (results_in t0 s1) s2", "have \"t2 \\<le> results_in t1 s2\""], ["proof (prove)\nusing this:\n  results_in t0 s1 \\<le> t1\n  t2 \\<le> results_in (results_in t0 s1) s2\n\ngoal (1 subgoal):\n 1. t2 \\<le> results_in t1 s2", "by (meson order.trans results_in_mono(1))"], ["proof (state)\nthis:\n  t2 \\<le> results_in t1 s2\n\ngoal (1 subgoal):\n 1. \\<exists>t2\\<le>results_in t1 s2.\n       t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)", "with t2(1)"], ["proof (chain)\npicking this:\n  t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)\n  t2 \\<le> results_in t1 s2", "show ?thesis"], ["proof (prove)\nusing this:\n  t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)\n  t2 \\<le> results_in t1 s2\n\ngoal (1 subgoal):\n 1. \\<exists>t2\\<le>results_in t1 s2.\n       t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>t2\\<le>results_in t1 s2.\n     t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>Lift an invariant's preservation proof over @{term next_propagate'} to NextPropagate' transitions\\<close>"], ["", "lemma lift_prop_inv_NextPropagate':\n  assumes \"(\\<And>c0 c1 loc t. P c0 \\<Longrightarrow> next_propagate' c0 c1 loc t \\<Longrightarrow> P c1)\"\n  shows   \"P (prop_config c0 p') \\<Longrightarrow> NextPropagate' c0 c1 p \\<Longrightarrow> P (prop_config c1 p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (prop_config c0 p'); NextPropagate' c0 c1 p\\<rbrakk>\n    \\<Longrightarrow> P (prop_config c1 p')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (prop_config c0 p'); NextPropagate' c0 c1 p\\<rbrakk>\n    \\<Longrightarrow> P (prop_config c1 p')", "assume pc0: \"P (prop_config c0 p')\""], ["proof (state)\nthis:\n  P (prop_config c0 p')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P (prop_config c0 p'); NextPropagate' c0 c1 p\\<rbrakk>\n    \\<Longrightarrow> P (prop_config c1 p')", "assume np: \"NextPropagate' c0 c1 p\""], ["proof (state)\nthis:\n  NextPropagate' c0 c1 p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P (prop_config c0 p'); NextPropagate' c0 c1 p\\<rbrakk>\n    \\<Longrightarrow> P (prop_config c1 p')", "have n_p: \"(\\<And>c0 c1. P c0 \\<Longrightarrow> next_propagate c0 c1 \\<Longrightarrow> P c1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c0 c1.\n       \\<lbrakk>P c0; next_propagate c0 c1\\<rbrakk> \\<Longrightarrow> P c1", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?c0.25; next_propagate' ?c0.25 ?c1.25 ?loc25 ?t25\\<rbrakk>\n  \\<Longrightarrow> P ?c1.25\n\ngoal (1 subgoal):\n 1. \\<And>c0 c1.\n       \\<lbrakk>P c0; next_propagate c0 c1\\<rbrakk> \\<Longrightarrow> P c1", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>P ?c0.25; next_propagate ?c0.25 ?c1.25\\<rbrakk>\n  \\<Longrightarrow> P ?c1.25\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P (prop_config c0 p'); NextPropagate' c0 c1 p\\<rbrakk>\n    \\<Longrightarrow> P (prop_config c1 p')", "let ?f = \"\\<lambda>c. SOME c'. next_propagate c c'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (prop_config c0 p'); NextPropagate' c0 c1 p\\<rbrakk>\n    \\<Longrightarrow> P (prop_config c1 p')", "let ?b = \"\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (prop_config c0 p'); NextPropagate' c0 c1 p\\<rbrakk>\n    \\<Longrightarrow> P (prop_config c1 p')", "from np"], ["proof (chain)\npicking this:\n  NextPropagate' c0 c1 p", "have pc1: \"Some (prop_config c1 p) = propagate_all (prop_config c0 p)\""], ["proof (prove)\nusing this:\n  NextPropagate' c0 c1 p\n\ngoal (1 subgoal):\n 1. Some (prop_config c1 p) = propagate_all (prop_config c0 p)", "by (simp add: NextPropagate'_def)"], ["proof (state)\nthis:\n  Some (prop_config c1 p) = propagate_all (prop_config c0 p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P (prop_config c0 p'); NextPropagate' c0 c1 p\\<rbrakk>\n    \\<Longrightarrow> P (prop_config c1 p')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (prop_config c1 p')", "apply (cases \"p'=p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. p' = p \\<Longrightarrow> P (prop_config c1 p')\n 2. p' \\<noteq> p \\<Longrightarrow> P (prop_config c1 p')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p' = p \\<Longrightarrow> P (prop_config c1 p')", "apply (rule while_option_rule[of P ?b ?f \"prop_config c0 p\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>p' = p; P s;\n        \\<exists>loc. c_work s loc \\<noteq> {#}\\<^sub>z\\<rbrakk>\n       \\<Longrightarrow> P (SOME c'. next_propagate s c')\n 2. p' = p \\<Longrightarrow>\n    while_option\n     (\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z)\n     (\\<lambda>c. SOME c'. next_propagate c c') (prop_config c0 p) =\n    Some (prop_config c1 p')\n 3. p' = p \\<Longrightarrow> P (prop_config c0 p)", "apply (rule n_p)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>p' = p; P s;\n        \\<exists>loc. c_work s loc \\<noteq> {#}\\<^sub>z\\<rbrakk>\n       \\<Longrightarrow> P (?c0.29 s)\n 2. \\<And>s.\n       \\<lbrakk>p' = p; P s;\n        \\<exists>loc. c_work s loc \\<noteq> {#}\\<^sub>z\\<rbrakk>\n       \\<Longrightarrow> next_propagate (?c0.29 s)\n                          (SOME c'. next_propagate s c')\n 3. p' = p \\<Longrightarrow>\n    while_option\n     (\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z)\n     (\\<lambda>c. SOME c'. next_propagate c c') (prop_config c0 p) =\n    Some (prop_config c1 p')\n 4. p' = p \\<Longrightarrow> P (prop_config c0 p)", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>p' = p; P s;\n        \\<exists>loc. c_work s loc \\<noteq> {#}\\<^sub>z\\<rbrakk>\n       \\<Longrightarrow> next_propagate s (SOME c'. next_propagate s c')\n 2. p' = p \\<Longrightarrow>\n    while_option\n     (\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z)\n     (\\<lambda>c. SOME c'. next_propagate c c') (prop_config c0 p) =\n    Some (prop_config c1 p')\n 3. p' = p \\<Longrightarrow> P (prop_config c0 p)", "apply (rule iffD1[OF verit_sko_ex])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>p' = p; P s;\n        \\<exists>loc. c_work s loc \\<noteq> {#}\\<^sub>z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. next_propagate s x\n 2. p' = p \\<Longrightarrow>\n    while_option\n     (\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z)\n     (\\<lambda>c. SOME c'. next_propagate c c') (prop_config c0 p) =\n    Some (prop_config c1 p')\n 3. p' = p \\<Longrightarrow> P (prop_config c0 p)", "apply (elim exE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s loc.\n       \\<lbrakk>p' = p; P s; c_work s loc \\<noteq> {#}\\<^sub>z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. next_propagate s x\n 2. p' = p \\<Longrightarrow>\n    while_option\n     (\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z)\n     (\\<lambda>c. SOME c'. next_propagate c c') (prop_config c0 p) =\n    Some (prop_config c1 p')\n 3. p' = p \\<Longrightarrow> P (prop_config c0 p)", "apply (rule exists_next_propagate')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s loc.\n       \\<lbrakk>p' = p; P s; c_work s loc \\<noteq> {#}\\<^sub>z\\<rbrakk>\n       \\<Longrightarrow> c_work s (?loc36 s loc) \\<noteq> {#}\\<^sub>z\n 2. p' = p \\<Longrightarrow>\n    while_option\n     (\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z)\n     (\\<lambda>c. SOME c'. next_propagate c c') (prop_config c0 p) =\n    Some (prop_config c1 p')\n 3. p' = p \\<Longrightarrow> P (prop_config c0 p)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. p' = p \\<Longrightarrow>\n    while_option\n     (\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z)\n     (\\<lambda>c. SOME c'. next_propagate c c') (prop_config c0 p) =\n    Some (prop_config c1 p')\n 2. p' = p \\<Longrightarrow> P (prop_config c0 p)", "using pc1"], ["proof (prove)\nusing this:\n  Some (prop_config c1 p) = propagate_all (prop_config c0 p)\n\ngoal (2 subgoals):\n 1. p' = p \\<Longrightarrow>\n    while_option\n     (\\<lambda>c. \\<exists>loc. c_work c loc \\<noteq> {#}\\<^sub>z)\n     (\\<lambda>c. SOME c'. next_propagate c c') (prop_config c0 p) =\n    Some (prop_config c1 p')\n 2. p' = p \\<Longrightarrow> P (prop_config c0 p)", "apply (simp add: propagate_all_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p' = p \\<Longrightarrow> P (prop_config c0 p)", "using pc0"], ["proof (prove)\nusing this:\n  P (prop_config c0 p')\n\ngoal (1 subgoal):\n 1. p' = p \\<Longrightarrow> P (prop_config c0 p)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. p' \\<noteq> p \\<Longrightarrow> P (prop_config c1 p')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p' \\<noteq> p \\<Longrightarrow> P (prop_config c1 p')", "using np pc0"], ["proof (prove)\nusing this:\n  NextPropagate' c0 c1 p\n  P (prop_config c0 p')\n\ngoal (1 subgoal):\n 1. p' \\<noteq> p \\<Longrightarrow> P (prop_config c1 p')", "by (auto simp: NextPropagate'_def dest!: spec[of _ p'])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P (prop_config c1 p')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Propagate is a Subsystem\\<close>"], ["", "lemma NextRecvUpd'_next':\n  assumes \"safe (prop_config c0 q)\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"cri.InvMsgInGlob (exchange_config c0)\"\n    and   \"NextRecvUpd' c0 c1 p q\"\n  shows   \"next'\\<^sup>+\\<^sup>+ (prop_config c0 q') (prop_config c1 q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q') (prop_config c1 q')", "apply (subst NextRecvUpdD(4)[OF assms(4), rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q')\n     (if q' = q\n      then cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q))\n      else prop_config c0 q')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (q' = q \\<longrightarrow>\n     local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q)\n      (cm_all (prop_config c0 q)\n        (hd (c_msg (exchange_config c0) p q)))) \\<and>\n    (q' \\<noteq> q \\<longrightarrow>\n     local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q') (prop_config c0 q'))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q)\n     (cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q)))\n 2. q' \\<noteq> q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q') (prop_config c0 q')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q)\n     (cm_all (prop_config c0 q) (hd (c_msg (exchange_config c0) p q)))", "apply (subst cm_all_eq_cm_all')"], ["proof (prove)\ngoal (2 subgoals):\n 1. q' = q \\<Longrightarrow>\n    \\<forall>(loc, t)\\<in>#\\<^sub>zhd (c_msg (exchange_config c0) p q).\n       \\<exists>t'.\n          t' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc) \\<and>\n          t' \\<le> t\n 2. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q)\n     (cm_all' (prop_config c0 q) (hd (c_msg (exchange_config c0) p q)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>q' = q;\n        (a, b) \\<in>#\\<^sub>z hd (c_msg (exchange_config c0) p q)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (prop_config c0 q) a) \\<and>\n                            t' \\<le> b\n 2. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q)\n     (cm_all' (prop_config c0 q) (hd (c_msg (exchange_config c0) p q)))", "apply (drule assms(3)[unfolded cri.InvMsgInGlob_def, rule_format, OF cri.next_recvupdD(1)[OF NextRecvUpdD(2)[OF assms(4)]]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>q' = q;\n        \\<exists>t'.\n           t'\\<le>\\<^sub>p(a, b) \\<and>\n           0 < zcount (c_glob (exchange_config c0) q) t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (prop_config c0 q) a) \\<and>\n                            t' \\<le> b\n 2. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q)\n     (cm_all' (prop_config c0 q) (hd (c_msg (exchange_config c0) p q)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>q' = q; (aa, ba)\\<le>\\<^sub>p(a, b);\n        0 < zcount (c_glob (exchange_config c0) q) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (prop_config c0 q) a) \\<and>\n                            t' \\<le> b\n 2. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q)\n     (cm_all' (prop_config c0 q) (hd (c_msg (exchange_config c0) p q)))", "subgoal for loc t loc' t'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; (loc', t')\\<le>\\<^sub>p(loc, t);\n     0 < zcount (c_glob (exchange_config c0) q) (loc', t')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply (subst (asm) assms(2)[unfolded InvGlobPointstampsEq_def, rule_format, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; (loc', t')\\<le>\\<^sub>p(loc, t);\n     0 < zcount (c_pts (prop_config c0 q) loc') t'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply (clarsimp simp: cri_less_eq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n        s \\<in>\\<^sub>A path_summary loc' loc;\n        results_in t' s \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (prop_config c0 q) loc) \\<and>\n                            t' \\<le> t", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "using assms(1)[unfolded safe_def, rule_format, of loc' t' s loc]"], ["proof (prove)\nusing this:\n  0 < zcount (c_pts (prop_config c0 q) loc') t' \\<and>\n  s \\<in>\\<^sub>A path_summary loc' loc \\<Longrightarrow>\n  \\<exists>t'a\\<le>results_in t' s.\n     t'a \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n     0 < zcount (c_pts (prop_config c0 q) loc') t' \\<and>\n     s \\<in>\\<^sub>A path_summary loc' loc \\<Longrightarrow>\n     \\<exists>t'a\\<le>results_in t' s.\n        t'a \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply (drule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount (c_pts (prop_config c0 q) loc') t' \\<and>\n                      s \\<in>\\<^sub>A path_summary loc' loc\n 2. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n     \\<exists>t'a\\<le>results_in t' s.\n        t'a \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n     \\<exists>t'a\\<le>results_in t' s.\n        t'a \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t'a.\n       \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n        s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n        t'a \\<le> results_in t' s;\n        t'a \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (prop_config c0 q) loc) \\<and>\n                            t' \\<le> t", "subgoal for t''"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n     t'' \\<le> results_in t' s;\n     t'' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply (clarsimp intro!: exI[of _ t''])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n     t'' \\<le> results_in t' s;\n     t'' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n    \\<Longrightarrow> t'' \\<le> t", "using order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n     t'' \\<le> results_in t' s;\n     t'' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n    \\<Longrightarrow> t'' \\<le> t", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q)\n     (cm_all' (prop_config c0 q) (hd (c_msg (exchange_config c0) p q)))", "apply (rule lift_cm_inv_cm_all')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c0a c1 loc t n.\n       \\<lbrakk>q' = q; local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) c0a;\n        next_change_multiplicity' c0a c1 loc t n\\<rbrakk>\n       \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) c1\n 2. q' = q \\<Longrightarrow>\n    \\<forall>(loc, t)\\<in>#\\<^sub>zhd (c_msg (exchange_config c0) p q).\n       \\<exists>t'.\n          t' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc) \\<and>\n          t' \\<le> t\n 3. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c0 q)", "apply (rule tranclp.intros(2))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c0a c1 loc t n.\n       \\<lbrakk>q' = q; local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) c0a;\n        next_change_multiplicity' c0a c1 loc t n\\<rbrakk>\n       \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q)\n                          (?b18 c0a c1 loc t n)\n 2. \\<And>c0a c1 loc t n.\n       \\<lbrakk>q' = q; local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) c0a;\n        next_change_multiplicity' c0a c1 loc t n\\<rbrakk>\n       \\<Longrightarrow> local.next' (?b18 c0a c1 loc t n) c1\n 3. q' = q \\<Longrightarrow>\n    \\<forall>(loc, t)\\<in>#\\<^sub>zhd (c_msg (exchange_config c0) p q).\n       \\<exists>t'.\n          t' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc) \\<and>\n          t' \\<le> t\n 4. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c0 q)", "apply (auto simp: next'_def) [2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. q' = q \\<Longrightarrow>\n    \\<forall>(loc, t)\\<in>#\\<^sub>zhd (c_msg (exchange_config c0) p q).\n       \\<exists>t'.\n          t' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc) \\<and>\n          t' \\<le> t\n 2. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c0 q)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>q' = q;\n        (a, b) \\<in>#\\<^sub>z hd (c_msg (exchange_config c0) p q)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (prop_config c0 q) a) \\<and>\n                            t' \\<le> b\n 2. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c0 q)", "apply (drule assms(3)[unfolded cri.InvMsgInGlob_def, rule_format, OF cri.next_recvupdD(1)[OF NextRecvUpdD(2)[OF assms(4)]]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>q' = q;\n        \\<exists>t'.\n           t'\\<le>\\<^sub>p(a, b) \\<and>\n           0 < zcount (c_glob (exchange_config c0) q) t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (prop_config c0 q) a) \\<and>\n                            t' \\<le> b\n 2. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c0 q)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>q' = q; (aa, ba)\\<le>\\<^sub>p(a, b);\n        0 < zcount (c_glob (exchange_config c0) q) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (prop_config c0 q) a) \\<and>\n                            t' \\<le> b\n 2. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c0 q)", "subgoal for loc t loc' t'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; (loc', t')\\<le>\\<^sub>p(loc, t);\n     0 < zcount (c_glob (exchange_config c0) q) (loc', t')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply (subst (asm) assms(2)[unfolded InvGlobPointstampsEq_def, rule_format, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; (loc', t')\\<le>\\<^sub>p(loc, t);\n     0 < zcount (c_pts (prop_config c0 q) loc') t'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply (clarsimp simp: cri_less_eq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n        s \\<in>\\<^sub>A path_summary loc' loc;\n        results_in t' s \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (prop_config c0 q) loc) \\<and>\n                            t' \\<le> t", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "using assms(1)[unfolded safe_def, rule_format, of loc' t' s loc]"], ["proof (prove)\nusing this:\n  0 < zcount (c_pts (prop_config c0 q) loc') t' \\<and>\n  s \\<in>\\<^sub>A path_summary loc' loc \\<Longrightarrow>\n  \\<exists>t'a\\<le>results_in t' s.\n     t'a \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n     0 < zcount (c_pts (prop_config c0 q) loc') t' \\<and>\n     s \\<in>\\<^sub>A path_summary loc' loc \\<Longrightarrow>\n     \\<exists>t'a\\<le>results_in t' s.\n        t'a \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply (drule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount (c_pts (prop_config c0 q) loc') t' \\<and>\n                      s \\<in>\\<^sub>A path_summary loc' loc\n 2. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n     \\<exists>t'a\\<le>results_in t' s.\n        t'a \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n     \\<exists>t'a\\<le>results_in t' s.\n        t'a \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t'a.\n       \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n        s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n        t'a \\<le> results_in t' s;\n        t'a \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier\n        (c_imp (prop_config c0 q) loc) \\<and>\n                            t' \\<le> t", "subgoal for t''"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n     t'' \\<le> results_in t' s;\n     t'' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier\n     (c_imp (prop_config c0 q) loc) \\<and>\n                         t' \\<le> t", "apply (clarsimp intro!: exI[of _ t''])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n     t'' \\<le> results_in t' s;\n     t'' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n    \\<Longrightarrow> t'' \\<le> t", "using order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q' = q; 0 < zcount (c_pts (prop_config c0 q) loc') t';\n     s \\<in>\\<^sub>A path_summary loc' loc; results_in t' s \\<le> t;\n     t'' \\<le> results_in t' s;\n     t'' \\<in>\\<^sub>A frontier (c_imp (prop_config c0 q) loc)\\<rbrakk>\n    \\<Longrightarrow> t'' \\<le> t", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. q' = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c0 q)", "apply (auto simp: next'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. q' \\<noteq> q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q') (prop_config c0 q')", "apply (auto simp: next'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma NextPropagate'_next':\n  assumes \"NextPropagate' c0 c1 p\"\n  shows   \"next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c1 q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c1 q)", "apply (cases \"p=q\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c1 q)\n 2. p \\<noteq> q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c1 q)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c1 q)", "apply (rule lift_propagate_inv_propagate_all[of _ \"prop_config c0 p\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c0a c1 loc t.\n       \\<lbrakk>p = q; local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) c0a;\n        next_propagate' c0a c1 loc t\\<rbrakk>\n       \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) c1\n 2. p = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c0 p)\n 3. p = q \\<Longrightarrow>\n    propagate_all (prop_config c0 p) = Some (prop_config c1 q)", "apply (rule tranclp.intros(2))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c0a c1 loc t.\n       \\<lbrakk>p = q; local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) c0a;\n        next_propagate' c0a c1 loc t\\<rbrakk>\n       \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q)\n                          (?b4 c0a c1 loc t)\n 2. \\<And>c0a c1 loc t.\n       \\<lbrakk>p = q; local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) c0a;\n        next_propagate' c0a c1 loc t\\<rbrakk>\n       \\<Longrightarrow> local.next' (?b4 c0a c1 loc t) c1\n 3. p = q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c0 p)\n 4. p = q \\<Longrightarrow>\n    propagate_all (prop_config c0 p) = Some (prop_config c1 q)", "apply (auto simp: next'_def NextPropagateD(3)[OF assms, rule_format])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c1 q)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 q) (prop_config c1 q)", "by (metis NextPropagateD(3) assms next'_def option.simps(1) tranclp.intros(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma next_imp_propagate_next:\n  assumes \"inv_init_imp_prop_safe c0\"\n    and   \"InvGlobPointstampsEq c0\"\n    and   \"cri.InvMsgInGlob (exchange_config c0)\"\n  shows   \"Next' c0 c1 \\<Longrightarrow> next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Next' c0 c1 \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)", "unfolding Next'_def NextPerformOp'_def NextSendUpd'_def NextRecvCap'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>p \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self.\n        cri.next_performop' (exchange_config c0) (exchange_config c1) p\n         \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self \\<and>\n        prop_config c1 = prop_config c0 \\<and> init c1 = init c0) \\<or>\n    (\\<exists>p tt.\n        cri.next_sendupd' (exchange_config c0) (exchange_config c1) p\n         tt \\<and>\n        prop_config c1 = prop_config c0 \\<and> init c1 = init c0) \\<or>\n    NextRecvUpd c0 c1 \\<or>\n    NextPropagate c0 c1 \\<or>\n    (\\<exists>p t.\n        cri.next_recvcap' (exchange_config c0) (exchange_config c1) p\n         t \\<and>\n        prop_config c1 = prop_config c0 \\<and> init c1 = init c0) \\<or>\n    c1 = c0 \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)", "apply safe"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>pa \\<Delta>neg \\<Delta>mint_msg \\<Delta>mint_self.\n       \\<lbrakk>cri.next_performop' (exchange_config c0)\n                 (exchange_config c1) pa \\<Delta>neg \\<Delta>mint_msg\n                 \\<Delta>mint_self;\n        prop_config c1 = prop_config c0; init c1 = init c0\\<rbrakk>\n       \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                          (prop_config c1 p)\n 2. \\<And>pa tt.\n       \\<lbrakk>cri.next_sendupd' (exchange_config c0) (exchange_config c1)\n                 pa tt;\n        prop_config c1 = prop_config c0; init c1 = init c0\\<rbrakk>\n       \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                          (prop_config c1 p)\n 3. \\<And>pa x.\n       NextRecvUpd' c0 c1 pa x \\<Longrightarrow>\n       local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)\n 4. \\<And>x.\n       NextPropagate' c0 c1 x \\<Longrightarrow>\n       local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)\n 5. \\<And>pa a b.\n       \\<lbrakk>cri.next_recvcap' (exchange_config c0) (exchange_config c1)\n                 pa (a, b);\n        prop_config c1 = prop_config c0; init c1 = init c0\\<rbrakk>\n       \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                          (prop_config c1 p)\n 6. c1 = c0 \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c0 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cri.next_performop' (exchange_config c0) (exchange_config c1)\n              pa_ \\<Delta>neg_ \\<Delta>mint_msg_ \\<Delta>mint_self_;\n     prop_config c1 = prop_config c0; init c1 = init c0\\<rbrakk>\n    \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                       (prop_config c1 p)", "by (auto simp: next'_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>pa tt.\n       \\<lbrakk>cri.next_sendupd' (exchange_config c0) (exchange_config c1)\n                 pa tt;\n        prop_config c1 = prop_config c0; init c1 = init c0\\<rbrakk>\n       \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                          (prop_config c1 p)\n 2. \\<And>pa x.\n       NextRecvUpd' c0 c1 pa x \\<Longrightarrow>\n       local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)\n 3. \\<And>x.\n       NextPropagate' c0 c1 x \\<Longrightarrow>\n       local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)\n 4. \\<And>pa a b.\n       \\<lbrakk>cri.next_recvcap' (exchange_config c0) (exchange_config c1)\n                 pa (a, b);\n        prop_config c1 = prop_config c0; init c1 = init c0\\<rbrakk>\n       \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                          (prop_config c1 p)\n 5. c1 = c0 \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c0 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cri.next_sendupd' (exchange_config c0) (exchange_config c1) pa_\n              tt_;\n     prop_config c1 = prop_config c0; init c1 = init c0\\<rbrakk>\n    \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                       (prop_config c1 p)", "by (auto simp: next'_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>pa x.\n       NextRecvUpd' c0 c1 pa x \\<Longrightarrow>\n       local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)\n 2. \\<And>x.\n       NextPropagate' c0 c1 x \\<Longrightarrow>\n       local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)\n 3. \\<And>pa a b.\n       \\<lbrakk>cri.next_recvcap' (exchange_config c0) (exchange_config c1)\n                 pa (a, b);\n        prop_config c1 = prop_config c0; init c1 = init c0\\<rbrakk>\n       \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                          (prop_config c1 p)\n 4. c1 = c0 \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c0 p)", "subgoal for p' q"], ["proof (prove)\ngoal (1 subgoal):\n 1. NextRecvUpd' c0 c1 p' q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)", "using assms(1)[unfolded inv_init_imp_prop_safe_def, rule_format, of q]"], ["proof (prove)\nusing this:\n  init c0 q \\<Longrightarrow> prop_safe (prop_config c0 q)\n\ngoal (1 subgoal):\n 1. NextRecvUpd' c0 c1 p' q \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NextRecvUpd' c0 c1 p' q;\n     init c0 q \\<Longrightarrow> prop_safe (prop_config c0 q)\\<rbrakk>\n    \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                       (prop_config c1 p)", "apply (drule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. NextRecvUpd' c0 c1 p' q \\<Longrightarrow> init c0 q\n 2. \\<lbrakk>NextRecvUpd' c0 c1 p' q; prop_safe (prop_config c0 q)\\<rbrakk>\n    \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                       (prop_config c1 p)", "apply (rule NextRecvUpdD(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. NextRecvUpd' c0 c1 p' q \\<Longrightarrow> NextRecvUpd' c0 ?c1.4 ?p4 q\n 2. \\<lbrakk>NextRecvUpd' c0 c1 p' q; prop_safe (prop_config c0 q)\\<rbrakk>\n    \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                       (prop_config c1 p)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NextRecvUpd' c0 c1 p' q; prop_safe (prop_config c0 q)\\<rbrakk>\n    \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                       (prop_config c1 p)", "apply (cases \"q=p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>NextRecvUpd' c0 c1 p' q; prop_safe (prop_config c0 q);\n     q = p\\<rbrakk>\n    \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                       (prop_config c1 p)\n 2. \\<lbrakk>NextRecvUpd' c0 c1 p' q; prop_safe (prop_config c0 q);\n     q \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                       (prop_config c1 p)", "apply (auto dest!: NextRecvUpd'_next'[rotated, OF assms(2-)]) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NextRecvUpd' c0 c1 p' q; prop_safe (prop_config c0 q);\n     q \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                       (prop_config c1 p)", "apply (auto simp add: NextRecvUpd'_def next'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       NextPropagate' c0 c1 x \\<Longrightarrow>\n       local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)\n 2. \\<And>pa a b.\n       \\<lbrakk>cri.next_recvcap' (exchange_config c0) (exchange_config c1)\n                 pa (a, b);\n        prop_config c1 = prop_config c0; init c1 = init c0\\<rbrakk>\n       \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                          (prop_config c1 p)\n 3. c1 = c0 \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c0 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. NextPropagate' c0 c1 x_ \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c1 p)", "by (rule NextPropagate'_next')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>pa a b.\n       \\<lbrakk>cri.next_recvcap' (exchange_config c0) (exchange_config c1)\n                 pa (a, b);\n        prop_config c1 = prop_config c0; init c1 = init c0\\<rbrakk>\n       \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                          (prop_config c1 p)\n 2. c1 = c0 \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c0 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cri.next_recvcap' (exchange_config c0) (exchange_config c1) pa_\n              (a_, b_);\n     prop_config c1 = prop_config c0; init c1 = init c0\\<rbrakk>\n    \\<Longrightarrow> local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p)\n                       (prop_config c1 p)", "by (auto simp: next'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 = c0 \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c0 p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 = c0 \\<Longrightarrow>\n    local.next'\\<^sup>+\\<^sup>+ (prop_config c0 p) (prop_config c0 p)", "by (auto simp: next'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma alw_next_imp_propagate_next:\n  assumes \"alw (holds inv_init_imp_prop_safe) s\"\n    and   \"alw (holds InvGlobPointstampsEq) s\"\n    and   \"alw (holds cri.InvMsgInGlob) (smap exchange_config s)\"\n    and   \"alw Next s\"\n  shows   \"alw (relates (next'\\<^sup>+\\<^sup>+)) (smap (\\<lambda>s. prop_config s p) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (relates local.next'\\<^sup>+\\<^sup>+)\n     (smap (\\<lambda>s. prop_config s p) s)", "using assms"], ["proof (prove)\nusing this:\n  alw (holds inv_init_imp_prop_safe) s\n  alw (holds InvGlobPointstampsEq) s\n  alw (holds cri.InvMsgInGlob) (smap exchange_config s)\n  alw Next s\n\ngoal (1 subgoal):\n 1. alw (relates local.next'\\<^sup>+\\<^sup>+)\n     (smap (\\<lambda>s. prop_config s p) s)", "by (coinduction arbitrary: s rule: alw.coinduct) (auto intro!: next_imp_propagate_next simp: relates_def alw_holds_smap_conv_comp)"], ["", "text\\<open>Any Tracker trace is a valid Propagate trace (using the transitive closure of next, since\ntracker may take multiple propagate steps at once).\\<close>"], ["", "lemma spec_imp_propagate_spec: \"FullSpec s \\<Longrightarrow> (holds init_config aand alw (relates (next'\\<^sup>+\\<^sup>+))) (smap (\\<lambda>c. prop_config c p) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow>\n    holds local.init_config (smap (\\<lambda>c. prop_config c p) s) \\<and>\n    alw (relates local.next'\\<^sup>+\\<^sup>+)\n     (smap (\\<lambda>c. prop_config c p) s)", "apply (frule alw_inv_init_imp_prop_safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FullSpec s; alw (holds inv_init_imp_prop_safe) s\\<rbrakk>\n    \\<Longrightarrow> holds local.init_config\n                       (smap (\\<lambda>c. prop_config c p) s) \\<and>\n                      alw (relates local.next'\\<^sup>+\\<^sup>+)\n                       (smap (\\<lambda>c. prop_config c p) s)", "apply (frule alw_InvGlobPointstampsEq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FullSpec s; alw (holds inv_init_imp_prop_safe) s;\n     alw (holds InvGlobPointstampsEq) s\\<rbrakk>\n    \\<Longrightarrow> holds local.init_config\n                       (smap (\\<lambda>c. prop_config c p) s) \\<and>\n                      alw (relates local.next'\\<^sup>+\\<^sup>+)\n                       (smap (\\<lambda>c. prop_config c p) s)", "apply (frule spec_imp_exchange_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FullSpec s; alw (holds inv_init_imp_prop_safe) s;\n     alw (holds InvGlobPointstampsEq) s;\n     cri.spec (smap exchange_config s)\\<rbrakk>\n    \\<Longrightarrow> holds local.init_config\n                       (smap (\\<lambda>c. prop_config c p) s) \\<and>\n                      alw (relates local.next'\\<^sup>+\\<^sup>+)\n                       (smap (\\<lambda>c. prop_config c p) s)", "apply (drule cri.alw_InvMsgInGlob)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FullSpec s; alw (holds inv_init_imp_prop_safe) s;\n     alw (holds InvGlobPointstampsEq) s;\n     alw (holds cri.InvMsgInGlob) (smap exchange_config s)\\<rbrakk>\n    \\<Longrightarrow> holds local.init_config\n                       (smap (\\<lambda>c. prop_config c p) s) \\<and>\n                      alw (relates local.next'\\<^sup>+\\<^sup>+)\n                       (smap (\\<lambda>c. prop_config c p) s)", "apply (auto intro!: alw_next_imp_propagate_next simp: FullSpec_def InitConfig_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Safety Proofs\\<close>"], ["", "lemma safe_satisfied:\n  assumes \"cri.InvGlobNonposImpRecordsNonpos (exchange_config c)\"\n    and \"inv_init_imp_prop_safe c\"\n    and \"InvGlobPointstampsEq c\"\n  shows \"safe_combined c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_combined c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. safe_combined c", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. safe_combined c", "fix loc1 loc2 t s p"], ["proof (state)\ngoal (1 subgoal):\n 1. safe_combined c", "assume as: \"0 < zcount (cri.records (exchange_config c)) (loc1, t)\"\n      \"s \\<in>\\<^sub>A path_summary loc1 loc2\" \"init c p\""], ["proof (state)\nthis:\n  0 < zcount (cri.records (exchange_config c)) (loc1, t)\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  init c p\n\ngoal (1 subgoal):\n 1. safe_combined c", "obtain loc0 t0 where delayed:\n      \"(loc0, t0) \\<le>\\<^sub>p (loc1, t)\" \"0 < zcount (c_glob (exchange_config c) p) (loc0, t0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>loc0 t0.\n        \\<lbrakk>(loc0, t0)\\<le>\\<^sub>p(loc1, t);\n         0 < zcount (c_glob (exchange_config c) p) (loc0, t0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nrec_pts_delayed[OF assms(1) as(1)]"], ["proof (prove)\nusing this:\n  \\<exists>x'.\n     x'\\<le>\\<^sub>p(loc1, t) \\<and>\n     0 < zcount (c_glob (exchange_config c) ?p) x'\n\ngoal (1 subgoal):\n 1. (\\<And>loc0 t0.\n        \\<lbrakk>(loc0, t0)\\<le>\\<^sub>p(loc1, t);\n         0 < zcount (c_glob (exchange_config c) p) (loc0, t0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  (loc0, t0)\\<le>\\<^sub>p(loc1, t)\n  0 < zcount (c_glob (exchange_config c) p) (loc0, t0)\n\ngoal (1 subgoal):\n 1. safe_combined c", "with as(2,3) assms(2)"], ["proof (chain)\npicking this:\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  init c p\n  inv_init_imp_prop_safe c\n  (loc0, t0)\\<le>\\<^sub>p(loc1, t)\n  0 < zcount (c_glob (exchange_config c) p) (loc0, t0)", "have\n      \"\\<exists>t2. t2 \\<le> results_in t s \\<and> t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)\""], ["proof (prove)\nusing this:\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  init c p\n  inv_init_imp_prop_safe c\n  (loc0, t0)\\<le>\\<^sub>p(loc1, t)\n  0 < zcount (c_glob (exchange_config c) p) (loc0, t0)\n\ngoal (1 subgoal):\n 1. \\<exists>t2\\<le>results_in t s.\n       t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)", "using help_lemma delayed"], ["proof (prove)\nusing this:\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  init c p\n  inv_init_imp_prop_safe c\n  (loc0, t0)\\<le>\\<^sub>p(loc1, t)\n  0 < zcount (c_glob (exchange_config c) p) (loc0, t0)\n  \\<lbrakk>0 < zcount (c_pts (prop_config ?c ?p) ?loc0.0) ?t0.0;\n   (?loc0.0, ?t0.0)\\<le>\\<^sub>p(?loc1.0, ?t1.0);\n   ?s2.0 \\<in>\\<^sub>A path_summary ?loc1.0 ?loc2.0;\n   safe (prop_config ?c ?p)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t2\\<le>results_in ?t1.0 ?s2.0.\n                       t2 \\<in>\\<^sub>A frontier\n   (c_imp (prop_config ?c ?p) ?loc2.0)\n  (loc0, t0)\\<le>\\<^sub>p(loc1, t)\n  0 < zcount (c_glob (exchange_config c) p) (loc0, t0)\n\ngoal (1 subgoal):\n 1. \\<exists>t2\\<le>results_in t s.\n       t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)", "by (metis InvGlobPointstampsEq_def assms(3) inv_init_imp_prop_safe_def)"], ["proof (state)\nthis:\n  \\<exists>t2\\<le>results_in t s.\n     t2 \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2)\n\ngoal (1 subgoal):\n 1. safe_combined c", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < zcount (cri.records (exchange_config c)) (?loc1.27, ?t27);\n   ?s27 \\<in>\\<^sub>A path_summary ?loc1.27 ?loc2.27; init c ?p27\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t2\\<le>results_in ?t27 ?s27.\n                       t2 \\<in>\\<^sub>A frontier\n   (c_imp (prop_config c ?p27) ?loc2.27)\n\ngoal (1 subgoal):\n 1. safe_combined c", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < zcount (cri.records (exchange_config c)) (?loc1.27, ?t27);\n   ?s27 \\<in>\\<^sub>A path_summary ?loc1.27 ?loc2.27; init c ?p27\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t2\\<le>results_in ?t27 ?s27.\n                       t2 \\<in>\\<^sub>A frontier\n   (c_imp (prop_config c ?p27) ?loc2.27)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < zcount (cri.records (exchange_config c)) (?loc1.27, ?t27);\n   ?s27 \\<in>\\<^sub>A path_summary ?loc1.27 ?loc2.27; init c ?p27\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t2\\<le>results_in ?t27 ?s27.\n                       t2 \\<in>\\<^sub>A frontier\n   (c_imp (prop_config c ?p27) ?loc2.27)\n\ngoal (1 subgoal):\n 1. safe_combined c", "unfolding safe_combined_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < zcount (cri.records (exchange_config c)) (?loc1.27, ?t27);\n   ?s27 \\<in>\\<^sub>A path_summary ?loc1.27 ?loc2.27; init c ?p27\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t2\\<le>results_in ?t27 ?s27.\n                       t2 \\<in>\\<^sub>A frontier\n   (c_imp (prop_config c ?p27) ?loc2.27)\n\ngoal (1 subgoal):\n 1. \\<forall>loc1 loc2 t s p.\n       0 < zcount (cri.records (exchange_config c)) (loc1, t) \\<and>\n       s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n       init c p \\<longrightarrow>\n       (\\<exists>t'.\n           t' \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc2) \\<and>\n           t' \\<le> results_in t s)", "by blast"], ["proof (state)\nthis:\n  safe_combined c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alw_safe_combined: \"FullSpec s \\<Longrightarrow> alw (holds safe_combined) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow> alw (holds safe_combined) s", "apply (frule alw_inv_init_imp_prop_safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FullSpec s; alw (holds inv_init_imp_prop_safe) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds safe_combined) s", "apply (frule exch_alw_InvGlobNonposImpRecordsNonpos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FullSpec s; alw (holds inv_init_imp_prop_safe) s;\n     alw (\\<lambda>s.\n             cri.InvGlobNonposImpRecordsNonpos (exchange_config (shd s)))\n      s\\<rbrakk>\n    \\<Longrightarrow> alw (holds safe_combined) s", "apply (drule alw_InvGlobPointstampsEq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (holds inv_init_imp_prop_safe) s;\n     alw (\\<lambda>s.\n             cri.InvGlobNonposImpRecordsNonpos (exchange_config (shd s)))\n      s;\n     alw (holds InvGlobPointstampsEq) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds safe_combined) s", "apply (coinduction arbitrary: s rule: alw.coinduct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds inv_init_imp_prop_safe) s;\n        alw (\\<lambda>s.\n                cri.InvGlobNonposImpRecordsNonpos (exchange_config (shd s)))\n         s;\n        alw (holds InvGlobPointstampsEq) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            s = xs \\<and>\n                            holds safe_combined xs \\<and>\n                            ((\\<exists>s.\n                                 stl xs = s \\<and>\n                                 alw (holds inv_init_imp_prop_safe) s \\<and>\n                                 alw (\\<lambda>s.\n   cri.InvGlobNonposImpRecordsNonpos (exchange_config (shd s)))\n                                  s \\<and>\n                                 alw (holds InvGlobPointstampsEq) s) \\<or>\n                             alw (holds safe_combined) (stl xs))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds inv_init_imp_prop_safe) s;\n        alw (\\<lambda>s.\n                cri.InvGlobNonposImpRecordsNonpos (exchange_config (shd s)))\n         s;\n        alw (holds InvGlobPointstampsEq) s\\<rbrakk>\n       \\<Longrightarrow> safe_combined (shd s) \\<and>\n                         (alw (holds inv_init_imp_prop_safe) (stl s) \\<and>\n                          alw (\\<lambda>s.\n                                  cri.InvGlobNonposImpRecordsNonpos\n                                   (exchange_config (shd s)))\n                           (stl s) \\<and>\n                          alw (holds InvGlobPointstampsEq) (stl s) \\<or>\n                          alw (holds safe_combined) (stl s))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds inv_init_imp_prop_safe) s;\n        alw (\\<lambda>s.\n                cri.InvGlobNonposImpRecordsNonpos (exchange_config (shd s)))\n         s;\n        alw (holds InvGlobPointstampsEq) s\\<rbrakk>\n       \\<Longrightarrow> safe_combined (shd s)\n 2. \\<And>s.\n       \\<lbrakk>alw (holds inv_init_imp_prop_safe) s;\n        alw (\\<lambda>s.\n                cri.InvGlobNonposImpRecordsNonpos (exchange_config (shd s)))\n         s;\n        alw (holds InvGlobPointstampsEq) s\\<rbrakk>\n       \\<Longrightarrow> alw (holds inv_init_imp_prop_safe) (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 cri.InvGlobNonposImpRecordsNonpos\n                                  (exchange_config (shd s)))\n                          (stl s) \\<and>\n                         alw (holds InvGlobPointstampsEq) (stl s) \\<or>\n                         alw (holds safe_combined) (stl s)", "apply (metis alwD alw_holds2 safe_satisfied)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds inv_init_imp_prop_safe) s;\n        alw (\\<lambda>s.\n                cri.InvGlobNonposImpRecordsNonpos (exchange_config (shd s)))\n         s;\n        alw (holds InvGlobPointstampsEq) s\\<rbrakk>\n       \\<Longrightarrow> alw (holds inv_init_imp_prop_safe) (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 cri.InvGlobNonposImpRecordsNonpos\n                                  (exchange_config (shd s)))\n                          (stl s) \\<and>\n                         alw (holds InvGlobPointstampsEq) (stl s) \\<or>\n                         alw (holds safe_combined) (stl s)", "apply (rule disjI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>alw (holds inv_init_imp_prop_safe) s;\n        alw (\\<lambda>s.\n                cri.InvGlobNonposImpRecordsNonpos (exchange_config (shd s)))\n         s;\n        alw (holds InvGlobPointstampsEq) s\\<rbrakk>\n       \\<Longrightarrow> alw (holds inv_init_imp_prop_safe) (stl s) \\<and>\n                         alw (\\<lambda>s.\n                                 cri.InvGlobNonposImpRecordsNonpos\n                                  (exchange_config (shd s)))\n                          (stl s) \\<and>\n                         alw (holds InvGlobPointstampsEq) (stl s)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma alw_safe_combined2: \"FullSpec s \\<Longrightarrow> alw (holds safe_combined2) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow> alw (holds safe_combined2) s", "apply (frule exch_alw_InvCapsNonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FullSpec s;\n     alw (\\<lambda>s. cri.InvCapsNonneg (exchange_config (shd s)))\n      s\\<rbrakk>\n    \\<Longrightarrow> alw (holds safe_combined2) s", "apply (drule alw_safe_combined)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (\\<lambda>s. cri.InvCapsNonneg (exchange_config (shd s)))\n              s;\n     alw (holds safe_combined) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds safe_combined2) s", "apply (simp add: alw_iff_sdrop safe_combined_implies_safe_combined2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma alw_implication_frontier_eq_implied_frontier:\n  \"FullSpec s \\<Longrightarrow> \n    alw (holds (\\<lambda>c. worklists_vacant_to (prop_config c p) b \\<longrightarrow>\n      b \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc) \\<longleftrightarrow> b \\<in>\\<^sub>A implied_frontier (c_pts (prop_config c p)) loc)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FullSpec s \\<Longrightarrow>\n    alw (holds\n          (\\<lambda>c.\n              worklists_vacant_to (prop_config c p) b \\<longrightarrow>\n              (b \\<in>\\<^sub>A frontier (c_imp (prop_config c p) loc)) =\n              (b \\<in>\\<^sub>A implied_frontier (c_pts (prop_config c p))\n                                loc)))\n     s", "by (drule alw_prop_invs)\n    (auto simp: implication_frontier_iff_implied_frontier_vacant all_imp_alw elim: alw_mp)"], ["", "end"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}