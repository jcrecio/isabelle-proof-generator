{"file_name": "/home/qj213/afp-2021-10-22/thys/Progress_Tracking/Propagate.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Progress_Tracking", "problem_names": ["lemma results_in_mono:\n  \"t1 \\<le> t2 \\<Longrightarrow> results_in t1 s \\<le> results_in t2 s\"\n  \"s1 \\<le> s2 \\<Longrightarrow> results_in t s1 \\<le> results_in t s2\"", "lemma cm_unchanged_worklist:\n  assumes \"next_change_multiplicity' c0 c1 loc t n\"\n    and   \"loc' \\<noteq> loc\"\n  shows   \"c_work c1 loc' = c_work c0 loc'\"", "lemma next'_inv[consumes 1, case_names next_change_multiplicity next_propagate next_finish_init]:\n  assumes \"next' c0 c1\" \"P c0\"\n    and   \"\\<And>loc t n. P c0 \\<Longrightarrow> next_change_multiplicity' c0 c1 loc t n \\<Longrightarrow> P c1\"\n    and   \"\\<And>loc t. P c0 \\<Longrightarrow> next_propagate' c0 c1 loc t \\<Longrightarrow> P c1\"\n  shows   \"P c1\"", "lemma next_change_multiplicity'_unique:\n  assumes \"n \\<noteq> 0\"\n    and   \"\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t\"\n  shows   \"\\<exists>!c'. next_change_multiplicity' c c' loc t n\"", "lemma frontier_change_zmset_frontier:\n  assumes \"t \\<in>\\<^sub>A frontier M1 - frontier M0\"\n  shows   \"zcount (zmset_frontier M1) t = 1 \\<and> zcount (zmset_frontier M0) t = 0\"", "lemma frontier_empty[simp]: \"frontier {#}\\<^sub>z = {}\\<^sub>A\"", "lemma zmset_frontier_empty[simp]: \"zmset_frontier {#}\\<^sub>z = {#}\\<^sub>z\"", "lemma after_summary_empty[simp]: \"after_summary {#}\\<^sub>z S = {#}\\<^sub>z\"", "lemma after_summary_empty_summary[simp]: \"after_summary M {}\\<^sub>A = {#}\\<^sub>z\"", "lemma mem_frontier_diff:\n  assumes \"t \\<in>\\<^sub>A frontier M - frontier N\"\n  shows   \"zcount (frontier_changes M N) t = 1\"", "lemma mem_frontier_diff':\n  assumes \"t \\<in>\\<^sub>A frontier N - frontier M\"\n  shows   \"zcount (frontier_changes M N) t = -1\"", "lemma not_mem_frontier_diff:\n  assumes \"t \\<notin>\\<^sub>A frontier M - frontier N\"\n    and   \"t \\<notin>\\<^sub>A frontier N - frontier M\"\n  shows   \"zcount (frontier_changes M N) t = 0\"", "lemma mset_neg_after_summary: \"mset_neg M = {#} \\<Longrightarrow> mset_neg (after_summary M S) = {#}\"", "lemma next_p_frontier_change:\n  assumes \"next_propagate' c0 c1 loc t\"\n    and \"summary loc loc' \\<noteq> {}\\<^sub>A\"\n  shows \"c_work c1 loc' =\n         c_work c0 loc'\n          + after_summary\n              (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n              (summary loc loc')\"", "lemma after_summary_union: \"after_summary (M + N) S = after_summary M S + after_summary N S\"", "lemma inv_imps_work_sum_zcount: \"inv_imps_work_sum c \\<longleftrightarrow> inv_imps_work_sum_zcount c\"", "lemma union_frontiers_nonneg: \"0 \\<le> zcount (union_frontiers c loc) t\"", "lemma next_p_union_frontier_change:\n  assumes \"next_propagate' c0 c1 loc t\"\n    and \"summary loc loc' \\<noteq> {}\\<^sub>A\"\n  shows \"union_frontiers c1 loc' =\n         union_frontiers c0 loc'\n          + after_summary\n              (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n              (summary loc loc')\"", "lemma init_imp_inv_imps_work_sum: \"init_config c \\<Longrightarrow> inv_imps_work_sum c\"", "lemma cm_preserves_inv_imps_work_sum:\n  assumes \"next_change_multiplicity' c0 c1 loc t n\"\n    and   \"inv_imps_work_sum c0\"\n  shows   \"inv_imps_work_sum c1\"", "lemma p_preserves_inv_imps_work_sum:\n  assumes \"next_propagate' c0 c1 loc t\"\n    and   \"inv_imps_work_sum c0\"\n  shows   \"inv_imps_work_sum c1\"", "lemma next_preserves_inv_imps_work_sum:\n  assumes \"next s\"\n    and   \"holds inv_imps_work_sum s\"\n  shows   \"nxt (holds inv_imps_work_sum) s\"", "lemma spec_imp_iiws: \"spec s \\<Longrightarrow> alw (holds inv_imps_work_sum) s\"", "lemma iiws_imp_iipwn:\n  assumes \"inv_imps_work_sum c\"\n  shows \"inv_imp_plus_work_nonneg c\"", "lemma spec_imp_iipwn: \"spec s \\<Longrightarrow> alw (holds inv_imp_plus_work_nonneg) s\"", "lemma init_imp_inv_implications_nonneg:\n  assumes \"init_config c\"\n  shows   \"inv_implications_nonneg c\"", "lemma cm_preserves_inv_implications_nonneg:\n  assumes \"next_change_multiplicity' c0 c1 loc t n\"\n    and     \"inv_implications_nonneg c0\"\n  shows   \"inv_implications_nonneg c1\"", "lemma p_preserves_inv_implications_nonneg:\n  assumes \"next_propagate' c0 c1 loc t\"\n    and     \"inv_implications_nonneg c0\"\n    and     \"inv_imp_plus_work_nonneg c0\"\n  shows   \"inv_implications_nonneg c1\"", "lemma next_preserves_inv_implications_nonneg:\n  assumes \"next s\"\n    and     \"holds inv_implications_nonneg s\"\n    and     \"holds inv_imp_plus_work_nonneg s\"\n  shows   \"nxt (holds inv_implications_nonneg) s\"", "lemma alw_inv_implications_nonneg: \"spec s \\<Longrightarrow> alw (holds inv_implications_nonneg) s\"", "lemma after_summary_Diff: \"after_summary (M - N) S = after_summary M S - after_summary N S\"", "lemma mem_zmset_frontier: \"x \\<in>#\\<^sub>z zmset_frontier M \\<longleftrightarrow> x \\<in>\\<^sub>A frontier M\"", "lemma obtain_frontier_elem:\n  assumes \"0 < zcount M t\"\n  obtains u where \"u \\<in>\\<^sub>A frontier M\" \"u \\<le> t\"", "lemma frontier_unionD: \"t \\<in>\\<^sub>A frontier (M+N) \\<Longrightarrow> 0 < zcount M t \\<or> 0 < zcount N t\"", "lemma ps_frontier_in_imps_wl:\n  assumes \"inv_imps_work_sum c\"\n    and   \"0 < zcount (zmset_frontier (c_pts c loc)) t\"\n  shows   \"0 < zcount (c_imp c loc + c_work c loc) t\"", "lemma obtain_elem_frontier:\n  assumes \"0 < zcount M t\"\n  obtains s where \"s \\<le> t \\<and> s \\<in>\\<^sub>A frontier M\"", "lemma obtain_elem_zmset_frontier:\n  assumes \"0 < zcount M t\"\n  obtains s where \"s \\<le> t \\<and> 0 < zcount (zmset_frontier M) s\"", "lemma ps_in_imps_wl:\n  assumes \"inv_imps_work_sum c\"\n    and   \"0 < zcount (c_pts c loc) t\"\n  obtains s where \"s \\<le> t \\<and> 0 < zcount (c_imp c loc + c_work c loc) s\"", "lemma zero_le_after_summary_single[simp]: \"0 \\<le> zcount (after_summary {#t#}\\<^sub>z S) x\"", "lemma one_le_zcount_after_summary: \"s \\<in>\\<^sub>A S \\<Longrightarrow> 1 \\<le> zcount (after_summary {#t#}\\<^sub>z S) (results_in t s)\"", "lemma zero_lt_zcount_after_summary: \"s \\<in>\\<^sub>A S \\<Longrightarrow> 0 < zcount (after_summary {#t#}\\<^sub>z S) (results_in t s)\"", "lemma pos_zcount_after_summary:\n  \"(\\<And>t. 0 \\<le> zcount M t) \\<Longrightarrow> 0 < zcount M t \\<Longrightarrow> s \\<in>\\<^sub>A S \\<Longrightarrow> 0 < zcount (after_summary M S) (results_in t s)\"", "lemma after_summary_nonneg: \"(\\<And>t. 0 \\<le> zcount M t) \\<Longrightarrow> 0 \\<le> zcount (after_summary M S) t\"", "lemma after_summary_zmset_of_nonneg[simp, intro]: \"0 \\<le> zcount (after_summary (zmset_of M) S) t\"", "lemma pos_zcount_union_frontiers:\n  \"zcount (after_summary (zmset_frontier (c_imp c l1)) (summary l1 l2)) (results_in t s)\n    \\<le> zcount (union_frontiers c l2) (results_in t s)\"", "lemma after_summary_Sum_fun: \"finite MM \\<Longrightarrow> after_summary (\\<Sum>M\\<in>MM. f M) A = (\\<Sum>M\\<in>MM. after_summary (f M) A)\"", "lemma after_summary_obtain_pre:\n  assumes \"\\<And>t. 0 \\<le> zcount M t\" (* could prove without this assumption *)\n    and   \"0 < zcount (after_summary M S) t\"\n  obtains t' s where \"0 < zcount M t'\" \"results_in t' s = t\" \"s \\<in>\\<^sub>A S\"", "lemma empty_antichain[dest]: \"x \\<in>\\<^sub>A antichain {} \\<Longrightarrow> False\"", "lemma impWitnessPathEx:\n  assumes \"t \\<in>\\<^sub>A frontier (c_imp c loc2)\"\n  shows \"(\\<exists>loc1 xs. impWitnessPath c loc1 loc2 xs t)\"", "lemma finite_edges: \"finite {(loc1,s,loc2). s \\<in>\\<^sub>A summary loc1 loc2}\"", "lemma longestImpWitnessPathEx:\n  assumes \"t \\<in>\\<^sub>A frontier (c_imp c loc2)\"\n  shows \"(\\<exists>loc1 xs. longestImpWitnessPath c loc1 loc2 xs t)\"", "lemma path_first_loc: \"path l1 l2 xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> xs ! 0 = (l1',s,l2') \\<Longrightarrow> l1 = l1'\"", "lemma find_witness_from_frontier:\n  assumes \"t \\<in>\\<^sub>A frontier (c_imp c loc2)\"\n    and \"inv_imps_work_sum c\"\n  shows \"\\<exists>t' loc1 xs. (path loc1 loc2 xs \\<and> t =  results_in t' (sum_path_weights xs) \\<and>\n           (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or> 0 > zcount (c_work c loc1) t'))\"", "lemma implication_implies_pointstamp:\n  assumes \"t \\<in>\\<^sub>A frontier (c_imp c loc)\"\n    and   \"inv_imps_work_sum c\"\n  shows   \"\\<exists>t' loc' s. s \\<in>\\<^sub>A path_summary loc' loc \\<and> t \\<ge> results_in t' s \\<and>\n               (t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or> 0 > zcount (c_work c loc') t')\"", "lemma results_in_sum_path_weights_append:\n  \"results_in t (sum_path_weights (xs @ [(loc2, s, loc3)])) = results_in (results_in t (sum_path_weights xs)) s\"", "lemma loc_imps_fw_conv_path: \"loc_imps_fw c loc1 loc2 M xs \\<Longrightarrow> path loc1 loc2 xs\"", "lemma path_conv_loc_imps_fw: \"path loc1 loc2 xs \\<Longrightarrow> distinct xs \\<Longrightarrow> \\<exists>M. loc_imps_fw c loc1 loc2 M xs\"", "lemma path_summary_conv_loc_imps_fw:\n  \"s \\<in>\\<^sub>A path_summary loc1 loc2 \\<Longrightarrow> \\<exists>M xs. loc_imps_fw c loc1 loc2 M xs \\<and> sum_path_weights xs = s\"", "lemma image_zmset_id[simp]: \"{#x. x \\<in>#\\<^sub>z M#} = M\"", "lemma sum_pos: \"finite M \\<Longrightarrow> \\<forall>x\\<in>M. 0 \\<le> f x \\<Longrightarrow> y \\<in> M \\<Longrightarrow> 0 < (f y::_::ordered_comm_monoid_add) \\<Longrightarrow> 0 < (\\<Sum>x\\<in>M. f x)\"", "lemma loc_imps_fw_M_in_implications:\n  assumes \"loc_imps_fw c loc1 loc2 M xs\"\n    and   \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"\\<And>loc. c_work c loc = {#}\\<^sub>z\"\n    and   \"0 < zcount M t\"\n  shows   \"\\<exists>s. s \\<le> t \\<and> s \\<in>\\<^sub>A frontier (c_imp c loc2)\"", "lemma loc_imps_fw_M_nonneg[simp]:\n  assumes \"loc_imps_fw c loc1 loc2 M xs\"\n    and   \"inv_implications_nonneg c\"\n  shows \"0 \\<le> zcount M t\"", "lemma loc_imps_fw_implication_in_M:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"loc_imps_fw c loc1 loc2 M xs\"\n    and   \"0 < zcount (c_imp c loc1) t\"\n  shows   \"0 < zcount M (results_in t (sum_path_weights xs))\"", "lemma impl_safe:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"\\<And>loc. c_work c loc = {#}\\<^sub>z\"\n  shows   \"impl_safe c\"", "lemma cm_preserves_impl_safe:\n  assumes \"impl_safe c0\"\n    and   \"next_change_multiplicity' c0 c1 loc t n\"\n  shows   \"impl_safe c1\"", "lemma cm_preserves_safe:\n  assumes \"safe c0\"\n    and   \"impl_safe c0\"\n    and   \"next_change_multiplicity' c0 c1 loc t n\"\n  shows   \"safe c1\"", "lemma in_frontier_diff: \"\\<forall>y\\<in>#\\<^sub>zN. \\<not> y \\<le> x \\<Longrightarrow> x \\<in>\\<^sub>A frontier (M - N) \\<longleftrightarrow> x \\<in>\\<^sub>A frontier M\"", "lemma worklists_vacant_to_trans:\n  \"worklists_vacant_to c t \\<Longrightarrow> t' \\<le> t \\<Longrightarrow> worklists_vacant_to c t'\"", "lemma loc_imps_fw_M_in_implications':\n  assumes \"loc_imps_fw c loc1 loc2 M xs\"\n    and   \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"worklists_vacant_to c t\"\n    and   \"0 < zcount M t\"\n  shows   \"\\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2)\"", "lemma inv_safe:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n  shows   \"inv_safe c\"", "lemma alw_conjI: \"alw P s \\<Longrightarrow> alw Q s \\<Longrightarrow> alw (\\<lambda>s. P s \\<and> Q s) s\"", "lemma alw_inv_safe: \"spec s \\<Longrightarrow> alw (holds inv_safe) s\"", "lemma empty_worklists_vacant_to: \"\\<forall>loc. c_work c loc = {#}\\<^sub>z \\<Longrightarrow> worklists_vacant_to c t\"", "lemma inv_safe_safe: \"(\\<And>loc. c_work c loc = {#}\\<^sub>z) \\<Longrightarrow> inv_safe c \\<Longrightarrow> safe c\"", "lemma safe:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"\\<And>loc. c_work c loc = {#}\\<^sub>z\"\n  shows   \"safe c\"", "lemma in_frontier_least: \"x \\<in>\\<^sub>A frontier M \\<Longrightarrow> \\<forall>y. 0 < zcount M y \\<longrightarrow> \\<not> y < x\"", "lemma in_frontier_trans: \"0 < zcount M y \\<Longrightarrow> x \\<in>\\<^sub>A frontier M \\<Longrightarrow> y \\<le> x \\<Longrightarrow> y \\<in>\\<^sub>A frontier M\"", "lemma implied_frontier_alt_least:\n  assumes \"b \\<in>\\<^sub>A implied_frontier_alt c loc2\"\n  shows \"\\<forall>loc a' s'. a' \\<in>\\<^sub>A frontier (c_pts c loc) \\<longrightarrow> s' \\<in>\\<^sub>A path_summary loc loc2 \\<longrightarrow> \\<not> results_in a' s' < b\"", "lemma implied_frontier_alt_in_pointstamps:\n  assumes \"b \\<in>\\<^sub>A implied_frontier_alt c loc2\"\n  obtains a s loc1 where\n    \"a \\<in>\\<^sub>A frontier (c_pts c loc1)\" \"s \\<in>\\<^sub>A path_summary loc1 loc2\" \"results_in a s = b\"", "lemma in_implied_frontier_alt_in_implication_frontier:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"worklists_vacant_to c b\"\n    and   \"b \\<in>\\<^sub>A implied_frontier_alt c loc2\"\n  shows   \"b \\<in>\\<^sub>A frontier (c_imp c loc2)\"", "lemma in_implication_frontier_in_implied_frontier_alt:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"worklists_vacant_to c b\"\n    and   \"b \\<in>\\<^sub>A frontier (c_imp c loc2)\"\n  shows   \"b \\<in>\\<^sub>A implied_frontier_alt c loc2\"", "lemma implication_frontier_iff_implied_frontier_alt_vacant:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"worklists_vacant_to c b\"\n  shows   \"b \\<in>\\<^sub>A frontier (c_imp c loc) \\<longleftrightarrow> b \\<in>\\<^sub>A implied_frontier_alt c loc\"", "lemma next_propagate_implied_frontier_alt_def:\n  \"next_propagate c c' \\<Longrightarrow> implied_frontier_alt c loc = implied_frontier_alt c' loc\"", "lemma implication_frontier_eq_implied_frontier_alt:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"\\<And>loc. c_work c loc = {#}\\<^sub>z\"\n  shows   \"frontier (c_imp c loc) = implied_frontier_alt c loc\"", "lemma alw_implication_frontier_eq_implied_frontier_alt_empty: \"spec s \\<Longrightarrow>\n  alw (holds (\\<lambda>c. (\\<forall>loc. c_work c loc = {#}\\<^sub>z) \\<longrightarrow> frontier (c_imp c loc) = implied_frontier_alt c loc)) s\"", "lemma alw_implication_frontier_eq_implied_frontier_alt_vacant: \"spec s \\<Longrightarrow>\n  alw (holds (\\<lambda>c. worklists_vacant_to c b \\<longrightarrow> b \\<in>\\<^sub>A frontier (c_imp c loc) \\<longleftrightarrow> b \\<in>\\<^sub>A implied_frontier_alt c loc)) s\"", "lemma antichain_eqI: \"(\\<And>b. b \\<in>\\<^sub>A A \\<longleftrightarrow> b \\<in>\\<^sub>A B) \\<Longrightarrow> A = B\"", "lemma zmset_frontier_zmset_pos: \"zmset_frontier A \\<subseteq>#\\<^sub>z zmset_pos A\"", "lemma image_mset_mono_pos: \n  \"\\<forall>b. 0 \\<le> zcount A b \\<Longrightarrow> \\<forall>b. 0 \\<le> zcount B b \\<Longrightarrow> A \\<subseteq>#\\<^sub>z B \\<Longrightarrow> image_zmset f A \\<subseteq>#\\<^sub>z image_zmset f B\"", "lemma sum_mono_subseteq:\n  \"(\\<And>i. i\\<in>K \\<Longrightarrow> f i \\<subseteq>#\\<^sub>z g i) \\<Longrightarrow> (\\<Sum>i\\<in>K. f i) \\<subseteq>#\\<^sub>z (\\<Sum>i\\<in>K. g i)\"", "lemma after_summary_zmset_frontier: \n  \"after_summary (zmset_frontier A) S \\<subseteq>#\\<^sub>z after_summary (zmset_pos A) S\"", "lemma frontier_eqI: \"\\<forall>b. 0 \\<le> zcount A b \\<Longrightarrow> \\<forall>b. 0 \\<le> zcount B b \\<Longrightarrow>\n  A \\<subseteq>#\\<^sub>z B \\<Longrightarrow> (\\<And>b. b \\<in>#\\<^sub>z B \\<Longrightarrow> \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b) \\<Longrightarrow> frontier A = frontier B\"", "lemma implied_frontier_implied_frontier_alt: \"implied_frontier (c_pts c) loc = implied_frontier_alt c loc\"", "lemmas alw_implication_frontier_eq_implied_frontier_vacant =\n  alw_implication_frontier_eq_implied_frontier_alt_vacant[folded implied_frontier_implied_frontier_alt]", "lemmas implication_frontier_iff_implied_frontier_vacant =\n  implication_frontier_iff_implied_frontier_alt_vacant[folded implied_frontier_implied_frontier_alt]"], "translations": [["", "lemma results_in_mono:\n  \"t1 \\<le> t2 \\<Longrightarrow> results_in t1 s \\<le> results_in t2 s\"\n  \"s1 \\<le> s2 \\<Longrightarrow> results_in t s1 \\<le> results_in t s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t1 \\<le> t2 \\<Longrightarrow>\n     results_in t1 s \\<le> results_in t2 s) &&&\n    (s1 \\<le> s2 \\<Longrightarrow> results_in t s1 \\<le> results_in t s2)", "using results_in_mono_raw"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t1.0 \\<le> ?t2.0; ?s1.0 \\<le> ?s2.0\\<rbrakk>\n  \\<Longrightarrow> results_in ?t1.0 ?s1.0 \\<le> results_in ?t2.0 ?s2.0\n\ngoal (1 subgoal):\n 1. (t1 \\<le> t2 \\<Longrightarrow>\n     results_in t1 s \\<le> results_in t2 s) &&&\n    (s1 \\<le> s2 \\<Longrightarrow> results_in t s1 \\<le> results_in t s2)", "by auto"], ["", "abbreviation \"path_summary \\<equiv> path_weight\""], ["", "abbreviation followed_by :: \"'sum \\<Rightarrow> 'sum \\<Rightarrow> 'sum\" where\n  \"followed_by \\<equiv> plus\""], ["", "definition safe :: \"('loc, 't) configuration \\<Rightarrow> bool\" where\n  \"safe c \\<equiv> \\<forall>loc1 loc2 t s. zcount (c_pts c loc1) t > 0 \\<and> s \\<in>\\<^sub>A path_summary loc1 loc2\n                \\<longrightarrow> (\\<exists>t'\\<le>results_in t s. t' \\<in>\\<^sub>A frontier (c_imp c loc2))\""], ["", "text \\<open>Implications are always non-negative.\\<close>"], ["", "definition inv_implications_nonneg where\n  \"inv_implications_nonneg c = (\\<forall>loc t. zcount (c_imp c loc) t \\<ge> 0)\""], ["", "abbreviation \"unchanged f c0 c1 \\<equiv> f c1 = f c0\""], ["", "abbreviation zmset_frontier where\n  \"zmset_frontier M \\<equiv> zmset_of (mset_set (set_antichain (frontier M)))\""], ["", "definition init_config where\n  \"init_config c \\<equiv> \\<forall>loc.\n      c_imp c loc = {#}\\<^sub>z \\<and>\n      c_work c loc = zmset_frontier (c_pts c loc)\""], ["", "definition after_summary :: \"'t zmultiset \\<Rightarrow> 'sum antichain \\<Rightarrow> 't zmultiset\" where\n  \"after_summary M S \\<equiv> (\\<Sum>s \\<in> set_antichain S. image_zmset (\\<lambda>t. results_in t s) M)\""], ["", "abbreviation frontier_changes :: \"'t zmultiset \\<Rightarrow> 't zmultiset \\<Rightarrow> 't zmultiset\" where\n  \"frontier_changes M N \\<equiv> zmset_frontier M - zmset_frontier N\""], ["", "definition next_change_multiplicity' :: \"('loc, 't) configuration \\<Rightarrow> ('loc, 't) configuration \\<Rightarrow> 'loc \\<Rightarrow> 't \\<Rightarrow> int \\<Rightarrow> bool\" where\n  \"next_change_multiplicity' c0 c1 loc t n \\<equiv>\n    \\<comment> \\<open>n is the non-zero change in pointstamps at loc for timestamp t\\<close>\n     n \\<noteq> 0 \\<and>\n    \\<comment> \\<open>change can only happen at timestamps not in advance of implication-frontier\\<close>\n     (\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n       \\<comment> \\<open>at loc, t is added to pointstamps n times\\<close>\n     c1 = c0\\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n       \\<comment> \\<open>worklist at loc is adjusted by frontier changes\\<close>\n             c_work := (c_work c0)(loc := c_work c0 loc +\n                frontier_changes (update_zmultiset (c_pts c0 loc) t n) (c_pts c0 loc))\\<rparr>\""], ["", "abbreviation next_change_multiplicity :: \"('loc, 't) configuration \\<Rightarrow> ('loc, 't) configuration \\<Rightarrow> bool\" where\n  \"next_change_multiplicity c0 c1 \\<equiv> \\<exists>loc t n. next_change_multiplicity' c0 c1 loc t n\""], ["", "lemma cm_unchanged_worklist:\n  assumes \"next_change_multiplicity' c0 c1 loc t n\"\n    and   \"loc' \\<noteq> loc\"\n  shows   \"c_work c1 loc' = c_work c0 loc'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_work c1 loc' = c_work c0 loc'", "using assms"], ["proof (prove)\nusing this:\n  next_change_multiplicity' c0 c1 loc t n\n  loc' \\<noteq> loc\n\ngoal (1 subgoal):\n 1. c_work c1 loc' = c_work c0 loc'", "unfolding next_change_multiplicity'_def"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>\n  loc' \\<noteq> loc\n\ngoal (1 subgoal):\n 1. c_work c1 loc' = c_work c0 loc'", "by auto"], ["", "definition next_propagate' :: \"('loc, 't) configuration \\<Rightarrow> ('loc, 't) configuration \\<Rightarrow> 'loc \\<Rightarrow> 't \\<Rightarrow> bool\" where\n  \"next_propagate' c0 c1 loc t \\<equiv>\n    \\<comment> \\<open>t is a least timestamp of all worklist entries\\<close>\n      (t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n      (\\<forall>t' loc'. t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow> \\<not> t' < t) \\<and>\n      c1 = c0\\<lparr>c_imp := (c_imp c0)(loc := c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n              c_work := (\\<lambda>loc'.\n                  \\<comment> \\<open>worklist entries for t are removed from loc's worklist\\<close>\n                    if loc' = loc then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n                  \\<comment> \\<open>worklists at other locations change by the loc's frontier change after adding summaries\\<close>\n                    else c_work c0 loc'\n                           + after_summary\n                               (frontier_changes (c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}) (c_imp c0 loc))\n                               (summary loc loc'))\\<rparr>)\""], ["", "abbreviation next_propagate :: \"('loc, 't :: order) configuration \\<Rightarrow> ('loc, 't) configuration \\<Rightarrow> bool\" where\n  \"next_propagate c0 c1 \\<equiv> \\<exists>loc t. next_propagate' c0 c1 loc t\""], ["", "definition \"next'\" where\n  \"next' c0 c1 = (next_propagate c0 c1 \\<or> next_change_multiplicity c0 c1 \\<or> c1 = c0)\""], ["", "abbreviation \"next\" where\n  \"next s \\<equiv> next' (shd s) (shd (stl s))\""], ["", "abbreviation cm_valid where\n  \"cm_valid \\<equiv> nxt (\\<lambda>s. next_change_multiplicity (shd s) (shd (stl s))) impl\n                (\\<lambda>s. next_change_multiplicity (shd s) (shd (stl s))) or nxt (holds (\\<lambda>c. (\\<forall>l. c_work c l = {#}\\<^sub>z)))\""], ["", "definition spec :: \"('loc, 't :: order) computation \\<Rightarrow> bool\" where\n  \"spec \\<equiv> holds init_config aand alw next\""], ["", "lemma next'_inv[consumes 1, case_names next_change_multiplicity next_propagate next_finish_init]:\n  assumes \"next' c0 c1\" \"P c0\"\n    and   \"\\<And>loc t n. P c0 \\<Longrightarrow> next_change_multiplicity' c0 c1 loc t n \\<Longrightarrow> P c1\"\n    and   \"\\<And>loc t. P c0 \\<Longrightarrow> next_propagate' c0 c1 loc t \\<Longrightarrow> P c1\"\n  shows   \"P c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P c1", "using assms"], ["proof (prove)\nusing this:\n  next' c0 c1\n  P c0\n  \\<lbrakk>P c0; next_change_multiplicity' c0 c1 ?loc1 ?t1 ?n1\\<rbrakk>\n  \\<Longrightarrow> P c1\n  \\<lbrakk>P c0; next_propagate' c0 c1 ?loc1 ?t1\\<rbrakk>\n  \\<Longrightarrow> P c1\n\ngoal (1 subgoal):\n 1. P c1", "unfolding next'_def"], ["proof (prove)\nusing this:\n  next_propagate c0 c1 \\<or> next_change_multiplicity c0 c1 \\<or> c1 = c0\n  P c0\n  \\<lbrakk>P c0; next_change_multiplicity' c0 c1 ?loc1 ?t1 ?n1\\<rbrakk>\n  \\<Longrightarrow> P c1\n  \\<lbrakk>P c0; next_propagate' c0 c1 ?loc1 ?t1\\<rbrakk>\n  \\<Longrightarrow> P c1\n\ngoal (1 subgoal):\n 1. P c1", "by auto"], ["", "subsection\\<open>Auxiliary\\<close>"], ["", "lemma next_change_multiplicity'_unique:\n  assumes \"n \\<noteq> 0\"\n    and   \"\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t\"\n  shows   \"\\<exists>!c'. next_change_multiplicity' c c' loc t n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!c'. next_change_multiplicity' c c' loc t n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!c'. next_change_multiplicity' c c' loc t n", "let ?pointstamps' = \"(c_pts c)(loc := update_zmultiset (c_pts c loc) t n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!c'. next_change_multiplicity' c c' loc t n", "let ?worklist' = \"\\<lambda>loc'. c_work c loc' + frontier_changes (?pointstamps' loc') (c_pts c loc')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!c'. next_change_multiplicity' c c' loc t n", "let ?c' = \"c\\<lparr>c_pts := ?pointstamps', c_work := ?worklist'\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!c'. next_change_multiplicity' c c' loc t n", "from assms"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t", "have \"next_change_multiplicity' c ?c' loc t n\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc) \\<and> t' \\<le> t\n\ngoal (1 subgoal):\n 1. next_change_multiplicity' c\n     (c\\<lparr>c_pts := (c_pts c)\n                 (loc := update_zmultiset (c_pts c loc) t n),\n          c_work :=\n            \\<lambda>loc'.\n               c_work c loc' +\n               frontier_changes\n                (((c_pts c)(loc := update_zmultiset (c_pts c loc) t n))\n                  loc')\n                (c_pts c loc')\\<rparr>)\n     loc t n", "by (auto simp: next_change_multiplicity'_def intro!: configuration.equality)"], ["proof (state)\nthis:\n  next_change_multiplicity' c\n   (c\\<lparr>c_pts := (c_pts c)(loc := update_zmultiset (c_pts c loc) t n),\n        c_work :=\n          \\<lambda>loc'.\n             c_work c loc' +\n             frontier_changes\n              (((c_pts c)(loc := update_zmultiset (c_pts c loc) t n)) loc')\n              (c_pts c loc')\\<rparr>)\n   loc t n\n\ngoal (1 subgoal):\n 1. \\<exists>!c'. next_change_multiplicity' c c' loc t n", "then"], ["proof (chain)\npicking this:\n  next_change_multiplicity' c\n   (c\\<lparr>c_pts := (c_pts c)(loc := update_zmultiset (c_pts c loc) t n),\n        c_work :=\n          \\<lambda>loc'.\n             c_work c loc' +\n             frontier_changes\n              (((c_pts c)(loc := update_zmultiset (c_pts c loc) t n)) loc')\n              (c_pts c loc')\\<rparr>)\n   loc t n", "show ?thesis"], ["proof (prove)\nusing this:\n  next_change_multiplicity' c\n   (c\\<lparr>c_pts := (c_pts c)(loc := update_zmultiset (c_pts c loc) t n),\n        c_work :=\n          \\<lambda>loc'.\n             c_work c loc' +\n             frontier_changes\n              (((c_pts c)(loc := update_zmultiset (c_pts c loc) t n)) loc')\n              (c_pts c loc')\\<rparr>)\n   loc t n\n\ngoal (1 subgoal):\n 1. \\<exists>!c'. next_change_multiplicity' c c' loc t n", "by (rule ex1I[of _ ?c'])\n      (auto  simp: next_change_multiplicity'_def intro!: configuration.equality)"], ["proof (state)\nthis:\n  \\<exists>!c'. next_change_multiplicity' c c' loc t n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frontier_change_zmset_frontier:\n  assumes \"t \\<in>\\<^sub>A frontier M1 - frontier M0\"\n  shows   \"zcount (zmset_frontier M1) t = 1 \\<and> zcount (zmset_frontier M0) t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier M1)))) t = 1 \\<and>\n    zcount (zmset_of (mset_set (set_antichain (frontier M0)))) t = 0", "using assms"], ["proof (prove)\nusing this:\n  t \\<in>\\<^sub>A frontier M1 - frontier M0\n\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier M1)))) t = 1 \\<and>\n    zcount (zmset_of (mset_set (set_antichain (frontier M0)))) t = 0", "by (clarsimp simp: ac_Diff_iff) (simp add: member_antichain.rep_eq)"], ["", "lemma frontier_empty[simp]: \"frontier {#}\\<^sub>z = {}\\<^sub>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frontier {#}\\<^sub>z = {}\\<^sub>A", "by transfer' simp"], ["", "lemma zmset_frontier_empty[simp]: \"zmset_frontier {#}\\<^sub>z = {#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zmset_of (mset_set (set_antichain (frontier {#}\\<^sub>z))) = {#}\\<^sub>z", "by simp"], ["", "lemma after_summary_empty[simp]: \"after_summary {#}\\<^sub>z S = {#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. after_summary {#}\\<^sub>z S = {#}\\<^sub>z", "by (simp add: after_summary_def)"], ["", "lemma after_summary_empty_summary[simp]: \"after_summary M {}\\<^sub>A = {#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. after_summary M {}\\<^sub>A = {#}\\<^sub>z", "by (simp add: after_summary_def)"], ["", "lemma mem_frontier_diff:\n  assumes \"t \\<in>\\<^sub>A frontier M - frontier N\"\n  shows   \"zcount (frontier_changes M N) t = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 1", "note assms"], ["proof (state)\nthis:\n  t \\<in>\\<^sub>A frontier M - frontier N\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 1", "then"], ["proof (chain)\npicking this:\n  t \\<in>\\<^sub>A frontier M - frontier N", "have t: \"t \\<in>\\<^sub>A frontier M\" \"t \\<notin>\\<^sub>A frontier N\""], ["proof (prove)\nusing this:\n  t \\<in>\\<^sub>A frontier M - frontier N\n\ngoal (1 subgoal):\n 1. t \\<in>\\<^sub>A frontier M &&& t \\<notin>\\<^sub>A frontier N", "using ac_Diff_iff"], ["proof (prove)\nusing this:\n  t \\<in>\\<^sub>A frontier M - frontier N\n  (?c \\<in>\\<^sub>A ?A - ?B) =\n  (?c \\<in>\\<^sub>A ?A \\<and> ?c \\<notin>\\<^sub>A ?B)\n\ngoal (1 subgoal):\n 1. t \\<in>\\<^sub>A frontier M &&& t \\<notin>\\<^sub>A frontier N", "by blast+"], ["proof (state)\nthis:\n  t \\<in>\\<^sub>A frontier M\n  t \\<notin>\\<^sub>A frontier N\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 1", "from t(1)"], ["proof (chain)\npicking this:\n  t \\<in>\\<^sub>A frontier M", "have \"zcount (zmset_frontier M) t = 1\""], ["proof (prove)\nusing this:\n  t \\<in>\\<^sub>A frontier M\n\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 1", "by (simp add: member_antichain.rep_eq)"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 1\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 1", "moreover"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 1\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 1", "from t(2)"], ["proof (chain)\npicking this:\n  t \\<notin>\\<^sub>A frontier N", "have \"zcount (zmset_frontier N) t = 0\""], ["proof (prove)\nusing this:\n  t \\<notin>\\<^sub>A frontier N\n\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 0", "by (simp add: member_antichain.rep_eq)"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 0\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 1", "ultimately"], ["proof (chain)\npicking this:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 1\n  zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 0", "show \"zcount (frontier_changes M N) t = 1\""], ["proof (prove)\nusing this:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 1\n  zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 0\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 1", "by simp"], ["proof (state)\nthis:\n  zcount (frontier_changes M N) t = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mem_frontier_diff':\n  assumes \"t \\<in>\\<^sub>A frontier N - frontier M\"\n  shows   \"zcount (frontier_changes M N) t = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = - 1", "note assms"], ["proof (state)\nthis:\n  t \\<in>\\<^sub>A frontier N - frontier M\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = - 1", "then"], ["proof (chain)\npicking this:\n  t \\<in>\\<^sub>A frontier N - frontier M", "have t: \"t \\<in>\\<^sub>A frontier N\" \"t \\<notin>\\<^sub>A frontier M\""], ["proof (prove)\nusing this:\n  t \\<in>\\<^sub>A frontier N - frontier M\n\ngoal (1 subgoal):\n 1. t \\<in>\\<^sub>A frontier N &&& t \\<notin>\\<^sub>A frontier M", "using ac_Diff_iff"], ["proof (prove)\nusing this:\n  t \\<in>\\<^sub>A frontier N - frontier M\n  (?c \\<in>\\<^sub>A ?A - ?B) =\n  (?c \\<in>\\<^sub>A ?A \\<and> ?c \\<notin>\\<^sub>A ?B)\n\ngoal (1 subgoal):\n 1. t \\<in>\\<^sub>A frontier N &&& t \\<notin>\\<^sub>A frontier M", "by blast+"], ["proof (state)\nthis:\n  t \\<in>\\<^sub>A frontier N\n  t \\<notin>\\<^sub>A frontier M\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = - 1", "from t(2)"], ["proof (chain)\npicking this:\n  t \\<notin>\\<^sub>A frontier M", "have \"zcount (zmset_frontier M) t = 0\""], ["proof (prove)\nusing this:\n  t \\<notin>\\<^sub>A frontier M\n\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 0", "by (simp add: member_antichain.rep_eq)"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 0\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = - 1", "moreover"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 0\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = - 1", "from t(1)"], ["proof (chain)\npicking this:\n  t \\<in>\\<^sub>A frontier N", "have \"zcount (zmset_frontier N) t = 1\""], ["proof (prove)\nusing this:\n  t \\<in>\\<^sub>A frontier N\n\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 1", "by (simp add: member_antichain.rep_eq)"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 1\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = - 1", "ultimately"], ["proof (chain)\npicking this:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 0\n  zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 1", "show \"zcount (frontier_changes M N) t = -1\""], ["proof (prove)\nusing this:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 0\n  zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 1\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = - 1", "by simp"], ["proof (state)\nthis:\n  zcount (frontier_changes M N) t = - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_mem_frontier_diff:\n  assumes \"t \\<notin>\\<^sub>A frontier M - frontier N\"\n    and   \"t \\<notin>\\<^sub>A frontier N - frontier M\"\n  shows   \"zcount (frontier_changes M N) t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "assume M: \"t \\<in>\\<^sub>A frontier M\""], ["proof (state)\nthis:\n  t \\<in>\\<^sub>A frontier M\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "with assms"], ["proof (chain)\npicking this:\n  t \\<notin>\\<^sub>A frontier M - frontier N\n  t \\<notin>\\<^sub>A frontier N - frontier M\n  t \\<in>\\<^sub>A frontier M", "have N: \"t \\<in>\\<^sub>A frontier N\""], ["proof (prove)\nusing this:\n  t \\<notin>\\<^sub>A frontier M - frontier N\n  t \\<notin>\\<^sub>A frontier N - frontier M\n  t \\<in>\\<^sub>A frontier M\n\ngoal (1 subgoal):\n 1. t \\<in>\\<^sub>A frontier N", "by (auto dest: ac_notin_Diff)"], ["proof (state)\nthis:\n  t \\<in>\\<^sub>A frontier N\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "from M N"], ["proof (chain)\npicking this:\n  t \\<in>\\<^sub>A frontier M\n  t \\<in>\\<^sub>A frontier N", "have \"zcount (zmset_frontier M) t = 1\" \"zcount (zmset_frontier N) t = 1\""], ["proof (prove)\nusing this:\n  t \\<in>\\<^sub>A frontier M\n  t \\<in>\\<^sub>A frontier N\n\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 1 &&&\n    zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 1", "by (simp_all add: member_antichain.rep_eq)"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 1\n  zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 1\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "then"], ["proof (chain)\npicking this:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 1\n  zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 1", "have \"zcount (frontier_changes M N) t = 0\""], ["proof (prove)\nusing this:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 1\n  zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 1\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "by simp"], ["proof (state)\nthis:\n  zcount (frontier_changes M N) t = 0\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "}"], ["proof (state)\nthis:\n  t \\<in>\\<^sub>A frontier M \\<Longrightarrow>\n  zcount (frontier_changes M N) t = 0\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "moreover"], ["proof (state)\nthis:\n  t \\<in>\\<^sub>A frontier M \\<Longrightarrow>\n  zcount (frontier_changes M N) t = 0\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "{"], ["proof (state)\nthis:\n  t \\<in>\\<^sub>A frontier M \\<Longrightarrow>\n  zcount (frontier_changes M N) t = 0\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "assume M: \"t \\<notin>\\<^sub>A frontier M\""], ["proof (state)\nthis:\n  t \\<notin>\\<^sub>A frontier M\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "with assms"], ["proof (chain)\npicking this:\n  t \\<notin>\\<^sub>A frontier M - frontier N\n  t \\<notin>\\<^sub>A frontier N - frontier M\n  t \\<notin>\\<^sub>A frontier M", "have N: \"t \\<notin>\\<^sub>A frontier N\""], ["proof (prove)\nusing this:\n  t \\<notin>\\<^sub>A frontier M - frontier N\n  t \\<notin>\\<^sub>A frontier N - frontier M\n  t \\<notin>\\<^sub>A frontier M\n\ngoal (1 subgoal):\n 1. t \\<notin>\\<^sub>A frontier N", "by (auto dest: ac_notin_Diff)"], ["proof (state)\nthis:\n  t \\<notin>\\<^sub>A frontier N\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "from M N"], ["proof (chain)\npicking this:\n  t \\<notin>\\<^sub>A frontier M\n  t \\<notin>\\<^sub>A frontier N", "have \"zcount (zmset_frontier M) t = 0\" \"zcount (zmset_frontier N) t = 0\""], ["proof (prove)\nusing this:\n  t \\<notin>\\<^sub>A frontier M\n  t \\<notin>\\<^sub>A frontier N\n\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 0 &&&\n    zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 0", "by (simp_all add: member_antichain.rep_eq)"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 0\n  zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 0\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "then"], ["proof (chain)\npicking this:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 0\n  zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 0", "have \"zcount (frontier_changes M N) t = 0\""], ["proof (prove)\nusing this:\n  zcount (zmset_of (mset_set (set_antichain (frontier M)))) t = 0\n  zcount (zmset_of (mset_set (set_antichain (frontier N)))) t = 0\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "by simp"], ["proof (state)\nthis:\n  zcount (frontier_changes M N) t = 0\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "}"], ["proof (state)\nthis:\n  t \\<notin>\\<^sub>A frontier M \\<Longrightarrow>\n  zcount (frontier_changes M N) t = 0\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "ultimately"], ["proof (chain)\npicking this:\n  t \\<in>\\<^sub>A frontier M \\<Longrightarrow>\n  zcount (frontier_changes M N) t = 0\n  t \\<notin>\\<^sub>A frontier M \\<Longrightarrow>\n  zcount (frontier_changes M N) t = 0", "show \"zcount (frontier_changes M N) t = 0\""], ["proof (prove)\nusing this:\n  t \\<in>\\<^sub>A frontier M \\<Longrightarrow>\n  zcount (frontier_changes M N) t = 0\n  t \\<notin>\\<^sub>A frontier M \\<Longrightarrow>\n  zcount (frontier_changes M N) t = 0\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes M N) t = 0", "by blast"], ["proof (state)\nthis:\n  zcount (frontier_changes M N) t = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_neg_after_summary: \"mset_neg M = {#} \\<Longrightarrow> mset_neg (after_summary M S) = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_neg M = {#} \\<Longrightarrow> mset_neg (after_summary M S) = {#}", "by (auto intro: mset_neg_image_zmset mset_neg_sum_set simp: after_summary_def)\n\n\\<comment> \\<open>Changes in loc's frontier are reflected in the worklist of loc'.\\<close>"], ["", "lemma next_p_frontier_change:\n  assumes \"next_propagate' c0 c1 loc t\"\n    and \"summary loc loc' \\<noteq> {}\\<^sub>A\"\n  shows \"c_work c1 loc' =\n         c_work c0 loc'\n          + after_summary\n              (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n              (summary loc loc')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_work c1 loc' =\n    c_work c0 loc' +\n    after_summary (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n     (summary loc loc')", "using assms"], ["proof (prove)\nusing this:\n  next_propagate' c0 c1 loc t\n  summary loc loc' \\<noteq> {}\\<^sub>A\n\ngoal (1 subgoal):\n 1. c_work c1 loc' =\n    c_work c0 loc' +\n    after_summary (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n     (summary loc loc')", "by (auto simp: summary_self next_propagate'_def intro!: configuration.equality)"], ["", "lemma after_summary_union: \"after_summary (M + N) S = after_summary M S + after_summary N S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. after_summary (M + N) S = after_summary M S + after_summary N S", "by (simp add: sum.distrib after_summary_def)"], ["", "subsection\\<open>Invariants\\<close>"], ["", "subsubsection\\<open>Invariant: @{term inv_imps_work_sum}\\<close>\n\n\\<comment> \\<open>Get timestamps in frontiers of loc's predecessor locations, apply respective summaries and\n    return union of results.\\<close>"], ["", "abbreviation union_frontiers :: \"('loc, 't) configuration \\<Rightarrow> 'loc \\<Rightarrow> 't zmultiset\" where\n  \"union_frontiers c loc \\<equiv>\n    (\\<Sum>loc'\\<in>UNIV. after_summary (zmset_frontier (c_imp c loc')) (summary loc' loc))\"\n\n\\<comment> \\<open>Implications + worklist is equal to the frontiers of pointstamps and all preceding nodes\n    (after accounting for summaries).\\<close>"], ["", "definition inv_imps_work_sum :: \"('loc, 't) configuration \\<Rightarrow> bool\" where\n  \"inv_imps_work_sum c \\<equiv>\n    \\<forall>loc. c_imp c loc + c_work c loc\n        = zmset_frontier (c_pts c loc) + union_frontiers c loc\"\n\n\\<comment> \\<open>Version with zcount is easier to reason with\\<close>"], ["", "definition inv_imps_work_sum_zcount :: \"('loc, 't) configuration \\<Rightarrow> bool\" where\n  \"inv_imps_work_sum_zcount c \\<equiv>\n    \\<forall>loc t. zcount (c_imp c loc + c_work c loc) t\n          = zcount (zmset_frontier (c_pts c loc) + union_frontiers c loc) t\""], ["", "lemma inv_imps_work_sum_zcount: \"inv_imps_work_sum c \\<longleftrightarrow> inv_imps_work_sum_zcount c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_imps_work_sum c = inv_imps_work_sum_zcount c", "unfolding inv_imps_work_sum_zcount_def inv_imps_work_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>loc.\n        c_imp c loc + c_work c loc =\n        zmset_of (mset_set (set_antichain (frontier (c_pts c loc)))) +\n        (\\<Sum>loc'\\<in>UNIV.\n           after_summary\n            (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n            (summary loc' loc))) =\n    (\\<forall>loc t.\n        zcount (c_imp c loc + c_work c loc) t =\n        zcount\n         (zmset_of (mset_set (set_antichain (frontier (c_pts c loc)))) +\n          (\\<Sum>loc'\\<in>UNIV.\n             after_summary\n              (zmset_of\n                (mset_set (set_antichain (frontier (c_imp c loc')))))\n              (summary loc' loc)))\n         t)", "by (simp add: zmultiset_eq_iff)"], ["", "lemma union_frontiers_nonneg: \"0 \\<le> zcount (union_frontiers c loc) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> zcount\n             (\\<Sum>loc'\\<in>UNIV.\n                after_summary\n                 (zmset_of\n                   (mset_set (set_antichain (frontier (c_imp c loc')))))\n                 (summary loc' loc))\n             t", "apply (subst zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Sum>M\\<in>UNIV.\n               zcount\n                (after_summary\n                  (zmset_of\n                    (mset_set (set_antichain (frontier (c_imp c M)))))\n                  (summary M loc))\n                t)", "apply (rule sum_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       0 \\<le> zcount\n                (after_summary\n                  (zmset_of\n                    (mset_set (set_antichain (frontier (c_imp c x)))))\n                  (summary x loc))\n                t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<le> zcount\n                (after_summary\n                  (zmset_of\n                    (mset_set (set_antichain (frontier (c_imp c x)))))\n                  (summary x loc))\n                t", "apply (rule mset_neg_zcount_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mset_neg\n        (after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c x)))))\n          (summary x loc)) =\n       {#}", "apply (rule mset_neg_after_summary)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mset_neg\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c x))))) =\n       {#}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma next_p_union_frontier_change:\n  assumes \"next_propagate' c0 c1 loc t\"\n    and \"summary loc loc' \\<noteq> {}\\<^sub>A\"\n  shows \"union_frontiers c1 loc' =\n         union_frontiers c0 loc'\n          + after_summary\n              (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n              (summary loc loc')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')) =\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc'a)))))\n        (summary loc'a loc')) +\n    after_summary (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n     (summary loc loc')", "using assms"], ["proof (prove)\nusing this:\n  next_propagate' c0 c1 loc t\n  summary loc loc' \\<noteq> {}\\<^sub>A\n\ngoal (1 subgoal):\n 1. (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')) =\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc'a)))))\n        (summary loc'a loc')) +\n    after_summary (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n     (summary loc loc')", "apply (subst zmultiset_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>next_propagate' c0 c1 loc t;\n     summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a.\n                         zcount\n                          (\\<Sum>loc'a\\<in>UNIV.\n                             after_summary\n                              (zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_imp c1 loc'a)))))\n                              (summary loc'a loc'))\n                          a =\n                         zcount\n                          ((\\<Sum>loc'a\\<in>UNIV.\n                              after_summary\n                               (zmset_of\n                                 (mset_set\n                                   (set_antichain\n                                     (frontier (c_imp c0 loc'a)))))\n                               (summary loc'a loc')) +\n                           after_summary\n                            (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n                            (summary loc loc'))\n                          a", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>next_propagate' c0 c1 loc t;\n        summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (\\<Sum>loc'a\\<in>UNIV.\n                             after_summary\n                              (zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_imp c1 loc'a)))))\n                              (summary loc'a loc'))\n                          a =\n                         zcount\n                          ((\\<Sum>loc'a\\<in>UNIV.\n                              after_summary\n                               (zmset_of\n                                 (mset_set\n                                   (set_antichain\n                                     (frontier (c_imp c0 loc'a)))))\n                               (summary loc'a loc')) +\n                           after_summary\n                            (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n                            (summary loc loc'))\n                          a", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>next_propagate' c0 c1 loc t;\n     summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n    \\<Longrightarrow> zcount\n                       (\\<Sum>loc'a\\<in>UNIV.\n                          after_summary\n                           (zmset_of\n                             (mset_set\n                               (set_antichain (frontier (c_imp c1 loc'a)))))\n                           (summary loc'a loc'))\n                       x =\n                      zcount\n                       ((\\<Sum>loc'a\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain\n                                  (frontier (c_imp c0 loc'a)))))\n                            (summary loc'a loc')) +\n                        after_summary\n                         (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n                         (summary loc loc'))\n                       x", "apply (simp del: zcount_of_mset image_zmset_Diff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>next_propagate' c0 c1 loc t;\n     summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n    \\<Longrightarrow> zcount\n                       (\\<Sum>loc'a\\<in>UNIV.\n                          after_summary\n                           (zmset_of\n                             (mset_set\n                               (set_antichain (frontier (c_imp c1 loc'a)))))\n                           (summary loc'a loc'))\n                       x =\n                      zcount\n                       (\\<Sum>loc'a\\<in>UNIV.\n                          after_summary\n                           (zmset_of\n                             (mset_set\n                               (set_antichain (frontier (c_imp c0 loc'a)))))\n                           (summary loc'a loc'))\n                       x +\n                      zcount\n                       (after_summary\n                         (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n                         (summary loc loc'))\n                       x", "apply (subst (1 2) zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>next_propagate' c0 c1 loc t;\n     summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>M\\<in>UNIV.\n                         zcount\n                          (after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c1 M)))))\n                            (summary M loc'))\n                          x) =\n                      (\\<Sum>M\\<in>UNIV.\n                         zcount\n                          (after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c0 M)))))\n                            (summary M loc'))\n                          x) +\n                      zcount\n                       (after_summary\n                         (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n                         (summary loc loc'))\n                       x", "apply (rule Sum_eq_pick_changed_elem[of UNIV loc])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>next_propagate' c0 c1 loc t;\n     summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n    \\<Longrightarrow> finite UNIV\n 2. \\<lbrakk>next_propagate' c0 c1 loc t;\n     summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n    \\<Longrightarrow> loc \\<in> UNIV\n 3. \\<lbrakk>next_propagate' c0 c1 loc t;\n     summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n    \\<Longrightarrow> zcount\n                       (after_summary\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c1 loc)))))\n                         (summary loc loc'))\n                       x =\n                      zcount\n                       (after_summary\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c0 loc)))))\n                         (summary loc loc'))\n                       x +\n                      zcount\n                       (after_summary\n                         (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n                         (summary loc loc'))\n                       x\n 4. \\<And>n.\n       \\<lbrakk>next_propagate' c0 c1 loc t;\n        summary loc loc' \\<noteq> {}\\<^sub>A;\n        n \\<noteq> loc \\<and> n \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c1 n)))))\n                            (summary n loc'))\n                          x =\n                         zcount\n                          (after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c0 n)))))\n                            (summary n loc'))\n                          x", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>next_propagate' c0 c1 loc t;\n     summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n    \\<Longrightarrow> loc \\<in> UNIV\n 2. \\<lbrakk>next_propagate' c0 c1 loc t;\n     summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n    \\<Longrightarrow> zcount\n                       (after_summary\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c1 loc)))))\n                         (summary loc loc'))\n                       x =\n                      zcount\n                       (after_summary\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c0 loc)))))\n                         (summary loc loc'))\n                       x +\n                      zcount\n                       (after_summary\n                         (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n                         (summary loc loc'))\n                       x\n 3. \\<And>n.\n       \\<lbrakk>next_propagate' c0 c1 loc t;\n        summary loc loc' \\<noteq> {}\\<^sub>A;\n        n \\<noteq> loc \\<and> n \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c1 n)))))\n                            (summary n loc'))\n                          x =\n                         zcount\n                          (after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c0 n)))))\n                            (summary n loc'))\n                          x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>next_propagate' c0 c1 loc t;\n     summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n    \\<Longrightarrow> zcount\n                       (after_summary\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c1 loc)))))\n                         (summary loc loc'))\n                       x =\n                      zcount\n                       (after_summary\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c0 loc)))))\n                         (summary loc loc'))\n                       x +\n                      zcount\n                       (after_summary\n                         (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n                         (summary loc loc'))\n                       x\n 2. \\<And>n.\n       \\<lbrakk>next_propagate' c0 c1 loc t;\n        summary loc loc' \\<noteq> {}\\<^sub>A;\n        n \\<noteq> loc \\<and> n \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c1 n)))))\n                            (summary n loc'))\n                          x =\n                         zcount\n                          (after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c0 n)))))\n                            (summary n loc'))\n                          x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>next_propagate' c0 c1 loc t;\n     summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n    \\<Longrightarrow> zcount\n                       (after_summary\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c1 loc)))))\n                         (summary loc loc'))\n                       x =\n                      zcount\n                       (after_summary\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c0 loc)))))\n                         (summary loc loc'))\n                       x +\n                      zcount\n                       (after_summary\n                         (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n                         (summary loc loc'))\n                       x", "apply (subst zcount_union[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>next_propagate' c0 c1 loc t;\n     summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n    \\<Longrightarrow> zcount\n                       (after_summary\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c1 loc)))))\n                         (summary loc loc'))\n                       x =\n                      zcount\n                       (after_summary\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c0 loc)))))\n                         (summary loc loc') +\n                        after_summary\n                         (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n                         (summary loc loc'))\n                       x", "apply (subst after_summary_union[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>next_propagate' c0 c1 loc t;\n     summary loc loc' \\<noteq> {}\\<^sub>A\\<rbrakk>\n    \\<Longrightarrow> zcount\n                       (after_summary\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c1 loc)))))\n                         (summary loc loc'))\n                       x =\n                      zcount\n                       (after_summary\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c0 loc)))) +\n                          frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n                         (summary loc loc'))\n                       x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>next_propagate' c0 c1 loc t;\n        summary loc loc' \\<noteq> {}\\<^sub>A;\n        n \\<noteq> loc \\<and> n \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> zcount\n                          (after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c1 n)))))\n                            (summary n loc'))\n                          x =\n                         zcount\n                          (after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c0 n)))))\n                            (summary n loc'))\n                          x", "apply (auto simp: next_propagate'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n\\<comment> \\<open>@{term init_config} satisfies @{term inv_imps_work_sum}\\<close>"], ["", "lemma init_imp_inv_imps_work_sum: \"init_config c \\<Longrightarrow> inv_imps_work_sum c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_config c \\<Longrightarrow> inv_imps_work_sum c", "by (simp add: inv_imps_work_sum_def init_config_def)\n\n\\<comment> \\<open>CM preserves @{term inv_imps_work_sum}\\<close>"], ["", "lemma cm_preserves_inv_imps_work_sum:\n  assumes \"next_change_multiplicity' c0 c1 loc t n\"\n    and   \"inv_imps_work_sum c0\"\n  shows   \"inv_imps_work_sum c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "proof -\n  \\<comment> \\<open>Given CM at loc, t, we show result for loc', t'\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "fix loc t loc' t' n"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume cm': \"next_change_multiplicity' c0 c1 loc t n\""], ["proof (state)\nthis:\n  next_change_multiplicity' c0 c1 loc t n\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note cm = this[unfolded next_change_multiplicity'_def]"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from cm"], ["proof (chain)\npicking this:\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>", "have unchanged_imps: \"unchanged c_imp c0 c1\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>\n\ngoal (1 subgoal):\n 1. c_imp c1 = c_imp c0", "by simp"], ["proof (state)\nthis:\n  c_imp c1 = c_imp c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume \"inv_imps_work_sum c0\""], ["proof (state)\nthis:\n  inv_imps_work_sum c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "then"], ["proof (chain)\npicking this:\n  inv_imps_work_sum c0", "have iiws': \"inv_imps_work_sum_zcount c0\""], ["proof (prove)\nusing this:\n  inv_imps_work_sum c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum_zcount c0", "by (simp add: inv_imps_work_sum_zcount)"], ["proof (state)\nthis:\n  inv_imps_work_sum_zcount c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note iiws = iiws'[unfolded inv_imps_work_sum_zcount_def, THEN spec2]"], ["proof (state)\nthis:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "have unchanged_union: \"union_frontiers c1 locX = union_frontiers c0 locX\" for locX"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' locX)) =\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' locX))", "using unchanged_imps"], ["proof (prove)\nusing this:\n  c_imp c1 = c_imp c0\n\ngoal (1 subgoal):\n 1. (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' locX)) =\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' locX))", "by (auto intro: sum.cong)\n        \\<comment> \\<open>For locations other than loc nothing changes.\\<close>"], ["proof (state)\nthis:\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "{"], ["proof (state)\nthis:\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume loc: \"loc' \\<noteq> loc\""], ["proof (state)\nthis:\n  loc' \\<noteq> loc\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note iiws = iiws'[unfolded inv_imps_work_sum_zcount_def, THEN spec2, of loc' t']"], ["proof (state)\nthis:\n  zcount (c_imp c0 loc' + c_work c0 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from loc cm"], ["proof (chain)\npicking this:\n  loc' \\<noteq> loc\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>", "have unchanged_worklist:\n        \"zcount (c_work c1 loc') t' = zcount (c_work c0 loc') t'\""], ["proof (prove)\nusing this:\n  loc' \\<noteq> loc\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>\n\ngoal (1 subgoal):\n 1. zcount (c_work c1 loc') t' = zcount (c_work c0 loc') t'", "by simp"], ["proof (state)\nthis:\n  zcount (c_work c1 loc') t' = zcount (c_work c0 loc') t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from loc cm"], ["proof (chain)\npicking this:\n  loc' \\<noteq> loc\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>", "have unchanged_frontier:\n        \"zcount (zmset_frontier (c_pts c1 loc')) t'\n       = zcount (zmset_frontier (c_pts c0       loc')) t'\""], ["proof (prove)\nusing this:\n  loc' \\<noteq> loc\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>\n\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))))\n     t' =\n    zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc')))))\n     t'", "by simp"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc'))))) t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "with loc"], ["proof (chain)\npicking this:\n  loc' \\<noteq> loc\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc'))))) t'", "have\n        \"zcount (c_imp c1 loc' + c_work c1 loc') t'\n            = zcount (zmset_frontier (c_pts c1 loc')\n                + union_frontiers c1 loc') t'\""], ["proof (prove)\nusing this:\n  loc' \\<noteq> loc\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc'))))) t'\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc' + c_work c1 loc') t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n      (\\<Sum>loc'a\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n          (summary loc'a loc')))\n     t'", "apply (subst (1 2) zcount_union)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>loc' \\<noteq> loc;\n     zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))))\n      t' =\n     zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc')))))\n      t'\\<rbrakk>\n    \\<Longrightarrow> zcount (c_imp c1 loc') t' +\n                      zcount (c_work c1 loc') t' =\n                      zcount\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c1 loc')))))\n                       t' +\n                      zcount\n                       (\\<Sum>loc'a\\<in>UNIV.\n                          after_summary\n                           (zmset_of\n                             (mset_set\n                               (set_antichain (frontier (c_imp c1 loc'a)))))\n                           (summary loc'a loc'))\n                       t'", "unfolding\n          unchanged_imps\n          unchanged_union\n          unchanged_frontier\n          unchanged_worklist"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>loc' \\<noteq> loc;\n     zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc')))))\n      t' =\n     zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc')))))\n      t'\\<rbrakk>\n    \\<Longrightarrow> zcount (c_imp c0 loc') t' +\n                      zcount (c_work c0 loc') t' =\n                      zcount\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c0 loc')))))\n                       t' +\n                      zcount\n                       (\\<Sum>loc'a\\<in>UNIV.\n                          after_summary\n                           (zmset_of\n                             (mset_set\n                               (set_antichain (frontier (c_imp c0 loc'a)))))\n                           (summary loc'a loc'))\n                       t'", "apply (subst (1 2) zcount_union[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>loc' \\<noteq> loc;\n     zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc')))))\n      t' =\n     zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc')))))\n      t'\\<rbrakk>\n    \\<Longrightarrow> zcount (c_imp c0 loc' + c_work c0 loc') t' =\n                      zcount\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c0 loc')))) +\n                        (\\<Sum>loc'a\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain\n                                  (frontier (c_imp c0 loc'a)))))\n                            (summary loc'a loc')))\n                       t'", "apply (rule iiws)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "}"], ["proof (state)\nthis:\n  loc' \\<noteq> loc \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover\n      \\<comment> \\<open>For pointstamps at location loc we make a case distinction on whether their \"status\" in\n          the frontier has changed.\\<close>"], ["proof (state)\nthis:\n  loc' \\<noteq> loc \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "{"], ["proof (state)\nthis:\n  loc' \\<noteq> loc \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume loc: \"loc' = loc\""], ["proof (state)\nthis:\n  loc' = loc\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note iiws = iiws'[unfolded inv_imps_work_sum_zcount_def, simplified, THEN spec, of loc, simplified]\n        \\<comment> \\<open>If t appeared in the frontier\\<close>"], ["proof (state)\nthis:\n  \\<forall>t.\n     zcount (c_imp c0 loc) t + zcount (c_work c0 loc) t =\n     int (count (mset_set (set_antichain (frontier (c_pts c0 loc)))) t) +\n     zcount\n      (\\<Sum>loc'\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n          (summary loc' loc))\n      t\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "{"], ["proof (state)\nthis:\n  \\<forall>t.\n     zcount (c_imp c0 loc) t + zcount (c_work c0 loc) t =\n     int (count (mset_set (set_antichain (frontier (c_pts c0 loc)))) t) +\n     zcount\n      (\\<Sum>loc'\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n          (summary loc' loc))\n      t\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume t': \"t' \\<in>\\<^sub>A frontier (c_pts c1 loc) - frontier (c_pts c0 loc)\""], ["proof (state)\nthis:\n  t' \\<in>\\<^sub>A frontier (c_pts c1 loc) - frontier (c_pts c0 loc)\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note t'[THEN mem_frontier_diff]\n          \\<comment> \\<open>then the worklist at t increased by 1\\<close>"], ["proof (state)\nthis:\n  zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t' = 1\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "then"], ["proof (chain)\npicking this:\n  zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t' = 1", "have \"zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' + 1\""], ["proof (prove)\nusing this:\n  zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t' = 1\n\ngoal (1 subgoal):\n 1. zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' + 1", "using cm"], ["proof (prove)\nusing this:\n  zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t' = 1\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>\n\ngoal (1 subgoal):\n 1. zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' + 1", "by auto\n            \\<comment> \\<open>and the frontier at t increased by 1\\<close>"], ["proof (state)\nthis:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' + 1\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' + 1\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "have \"zcount (zmset_frontier (c_pts c1 loc)) t'\n              = zcount (zmset_frontier (c_pts c0 loc)) t' + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n     t' =\n    zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n     t' +\n    1", "using t'[THEN frontier_change_zmset_frontier]"], ["proof (prove)\nusing this:\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  1 \\<and>\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n   t' =\n  0\n\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n     t' =\n    zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n     t' +\n    1", "by simp\n            \\<comment> \\<open>and the sum didn't change\\<close>"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n   t' +\n  1\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n   t' +\n  1\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note unchanged_union\n          \\<comment> \\<open>hence, the invariant is preserved.\\<close>"], ["proof (state)\nthis:\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "ultimately"], ["proof (chain)\npicking this:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' + 1\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n   t' +\n  1\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))", "have\n          \"zcount (c_imp c1 loc + c_work c1 loc) t'\n            = zcount (zmset_frontier (c_pts c1 loc)\n              + union_frontiers c1 loc) t'\""], ["proof (prove)\nusing this:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' + 1\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n   t' +\n  1\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc + c_work c1 loc) t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n      (\\<Sum>loc'\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n          (summary loc' loc)))\n     t'", "using iiws unchanged_imps"], ["proof (prove)\nusing this:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' + 1\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n   t' +\n  1\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))\n  \\<forall>t.\n     zcount (c_imp c0 loc) t + zcount (c_work c0 loc) t =\n     int (count (mset_set (set_antichain (frontier (c_pts c0 loc)))) t) +\n     zcount\n      (\\<Sum>loc'\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n          (summary loc' loc))\n      t\n  c_imp c1 = c_imp c0\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc + c_work c1 loc) t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n      (\\<Sum>loc'\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n          (summary loc' loc)))\n     t'", "by simp"], ["proof (state)\nthis:\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "}"], ["proof (state)\nthis:\n  t' \\<in>\\<^sub>A frontier (c_pts c1 loc) -\n                   frontier (c_pts c0 loc) \\<Longrightarrow>\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover\n        \\<comment> \\<open>If t disappeared from the frontier\\<close>"], ["proof (state)\nthis:\n  t' \\<in>\\<^sub>A frontier (c_pts c1 loc) -\n                   frontier (c_pts c0 loc) \\<Longrightarrow>\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "{"], ["proof (state)\nthis:\n  t' \\<in>\\<^sub>A frontier (c_pts c1 loc) -\n                   frontier (c_pts c0 loc) \\<Longrightarrow>\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume t': \"t' \\<in>\\<^sub>A frontier (c_pts c0 loc) - frontier (c_pts c1 loc)\""], ["proof (state)\nthis:\n  t' \\<in>\\<^sub>A frontier (c_pts c0 loc) - frontier (c_pts c1 loc)\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note t'[THEN mem_frontier_diff']\n          \\<comment> \\<open>then the worklist at t decreased by 1\\<close>"], ["proof (state)\nthis:\n  zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t' = - 1\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "then"], ["proof (chain)\npicking this:\n  zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t' = - 1", "have \"zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' - 1\""], ["proof (prove)\nusing this:\n  zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t' = - 1\n\ngoal (1 subgoal):\n 1. zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' - 1", "using cm"], ["proof (prove)\nusing this:\n  zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t' = - 1\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>\n\ngoal (1 subgoal):\n 1. zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' - 1", "by (auto simp: ac_Diff_iff)\n            \\<comment> \\<open>and the frontier at t decreased by 1\\<close>"], ["proof (state)\nthis:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' - 1\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' - 1\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "have \"zcount (zmset_frontier (c_pts c1 loc)) t'\n              = zcount (zmset_frontier (c_pts c0 loc)) t' - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n     t' =\n    zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n     t' -\n    1", "using t'[THEN frontier_change_zmset_frontier]"], ["proof (prove)\nusing this:\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n   t' =\n  1 \\<and>\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  0\n\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n     t' =\n    zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n     t' -\n    1", "by simp\n            \\<comment> \\<open>and the sum didn't change\\<close>"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n   t' -\n  1\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n   t' -\n  1\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note unchanged_union\n          \\<comment> \\<open>hence, the invariant is preserved.\\<close>"], ["proof (state)\nthis:\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "ultimately"], ["proof (chain)\npicking this:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' - 1\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n   t' -\n  1\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))", "have\n          \"zcount (c_imp c1 loc + c_work c1 loc) t'\n            = zcount (zmset_frontier (c_pts c1 loc)\n              + union_frontiers c1 loc) t'\""], ["proof (prove)\nusing this:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' - 1\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n   t' -\n  1\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc + c_work c1 loc) t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n      (\\<Sum>loc'\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n          (summary loc' loc)))\n     t'", "using iiws unchanged_imps"], ["proof (prove)\nusing this:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t' - 1\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n   t' -\n  1\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))\n  \\<forall>t.\n     zcount (c_imp c0 loc) t + zcount (c_work c0 loc) t =\n     int (count (mset_set (set_antichain (frontier (c_pts c0 loc)))) t) +\n     zcount\n      (\\<Sum>loc'\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n          (summary loc' loc))\n      t\n  c_imp c1 = c_imp c0\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc + c_work c1 loc) t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n      (\\<Sum>loc'\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n          (summary loc' loc)))\n     t'", "by simp"], ["proof (state)\nthis:\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "}"], ["proof (state)\nthis:\n  t' \\<in>\\<^sub>A frontier (c_pts c0 loc) -\n                   frontier (c_pts c1 loc) \\<Longrightarrow>\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover\n        \\<comment> \\<open>If t's multiplicity in the frontier didn't change\\<close>"], ["proof (state)\nthis:\n  t' \\<in>\\<^sub>A frontier (c_pts c0 loc) -\n                   frontier (c_pts c1 loc) \\<Longrightarrow>\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "{"], ["proof (state)\nthis:\n  t' \\<in>\\<^sub>A frontier (c_pts c0 loc) -\n                   frontier (c_pts c1 loc) \\<Longrightarrow>\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume a1: \"\\<not> t' \\<in>\\<^sub>A frontier (c_pts c1 loc) - frontier (c_pts c0 loc)\""], ["proof (state)\nthis:\n  t' \\<notin>\\<^sub>A frontier (c_pts c1 loc) - frontier (c_pts c0 loc)\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume a2: \"\\<not> t' \\<in>\\<^sub>A frontier (c_pts c0 loc) - frontier (c_pts c1 loc)\""], ["proof (state)\nthis:\n  t' \\<notin>\\<^sub>A frontier (c_pts c0 loc) - frontier (c_pts c1 loc)\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from a1 a2"], ["proof (chain)\npicking this:\n  t' \\<notin>\\<^sub>A frontier (c_pts c1 loc) - frontier (c_pts c0 loc)\n  t' \\<notin>\\<^sub>A frontier (c_pts c0 loc) - frontier (c_pts c1 loc)", "have \"zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t' = 0\""], ["proof (prove)\nusing this:\n  t' \\<notin>\\<^sub>A frontier (c_pts c1 loc) - frontier (c_pts c0 loc)\n  t' \\<notin>\\<^sub>A frontier (c_pts c0 loc) - frontier (c_pts c1 loc)\n\ngoal (1 subgoal):\n 1. zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t' = 0", "by (intro not_mem_frontier_diff)\n            \\<comment> \\<open>then the worklist at t didn't change\\<close>"], ["proof (state)\nthis:\n  zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t' = 0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "with cm"], ["proof (chain)\npicking this:\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>\n  zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t' = 0", "have \"zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t'\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>\n  zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t' = 0\n\ngoal (1 subgoal):\n 1. zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t'", "by (auto simp: ac_Diff_iff)\n            \\<comment> \\<open>and the frontier at t didn't change\\<close>"], ["proof (state)\nthis:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "have \"zcount (zmset_frontier (c_pts c1 loc)) t'\n            = zcount (zmset_frontier (c_pts c0 loc)) t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n     t' =\n    zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n     t'", "using a1 a2"], ["proof (prove)\nusing this:\n  t' \\<notin>\\<^sub>A frontier (c_pts c1 loc) - frontier (c_pts c0 loc)\n  t' \\<notin>\\<^sub>A frontier (c_pts c0 loc) - frontier (c_pts c1 loc)\n\ngoal (1 subgoal):\n 1. zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n     t' =\n    zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc)))))\n     t'", "apply (clarsimp simp: member_antichain.rep_eq dest!: ac_notin_Diff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<notin> set_antichain\n                          (frontier (c_pts c1 loc) -\n                           frontier (c_pts c0 loc));\n     t' \\<notin> set_antichain\n                  (frontier (c_pts c0 loc) -\n                   frontier (c_pts c1 loc))\\<rbrakk>\n    \\<Longrightarrow> count\n                       (mset_set (set_antichain (frontier (c_pts c1 loc))))\n                       t' =\n                      count\n                       (mset_set (set_antichain (frontier (c_pts c0 loc))))\n                       t'", "apply (metis ac_Diff_iff count_mset_set(1) count_mset_set(3) finite_set_antichain member_antichain.rep_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n            \\<comment> \\<open>and the sum didn't change\\<close>"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc))))) t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc))))) t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note unchanged_union\n          \\<comment> \\<open>hence, the invariant is preserved.\\<close>"], ["proof (state)\nthis:\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "ultimately"], ["proof (chain)\npicking this:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t'\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc))))) t'\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))", "have\n          \"zcount (c_imp c1 loc + c_work c1 loc) t'\n            = zcount (zmset_frontier (c_pts c1 loc)\n              + union_frontiers c1 loc) t'\""], ["proof (prove)\nusing this:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t'\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc))))) t'\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc + c_work c1 loc) t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n      (\\<Sum>loc'\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n          (summary loc' loc)))\n     t'", "using iiws unchanged_imps"], ["proof (prove)\nusing this:\n  zcount (c_work c1 loc) t' = zcount (c_work c0 loc) t'\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))))\n   t' =\n  zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c0 loc))))) t'\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' ?locX1)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' ?locX1))\n  \\<forall>t.\n     zcount (c_imp c0 loc) t + zcount (c_work c0 loc) t =\n     int (count (mset_set (set_antichain (frontier (c_pts c0 loc)))) t) +\n     zcount\n      (\\<Sum>loc'\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n          (summary loc' loc))\n      t\n  c_imp c1 = c_imp c0\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc + c_work c1 loc) t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n      (\\<Sum>loc'\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n          (summary loc' loc)))\n     t'", "by simp"], ["proof (state)\nthis:\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "}"], ["proof (state)\nthis:\n  \\<lbrakk>t' \\<notin>\\<^sub>A frontier (c_pts c1 loc) -\n                               frontier (c_pts c0 loc);\n   t' \\<notin>\\<^sub>A frontier (c_pts c0 loc) -\n                       frontier (c_pts c1 loc)\\<rbrakk>\n  \\<Longrightarrow> zcount (c_imp c1 loc + c_work c1 loc) t' =\n                    zcount\n                     (zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c1 loc)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c1 loc')))))\n                          (summary loc' loc)))\n                     t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "ultimately"], ["proof (chain)\npicking this:\n  t' \\<in>\\<^sub>A frontier (c_pts c1 loc) -\n                   frontier (c_pts c0 loc) \\<Longrightarrow>\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n  t' \\<in>\\<^sub>A frontier (c_pts c0 loc) -\n                   frontier (c_pts c1 loc) \\<Longrightarrow>\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n  \\<lbrakk>t' \\<notin>\\<^sub>A frontier (c_pts c1 loc) -\n                               frontier (c_pts c0 loc);\n   t' \\<notin>\\<^sub>A frontier (c_pts c0 loc) -\n                       frontier (c_pts c1 loc)\\<rbrakk>\n  \\<Longrightarrow> zcount (c_imp c1 loc + c_work c1 loc) t' =\n                    zcount\n                     (zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c1 loc)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c1 loc')))))\n                          (summary loc' loc)))\n                     t'", "have\n        \"zcount (c_imp c1 loc' + c_work c1 loc') t'\n            = zcount (zmset_frontier (c_pts c1 loc')\n              + union_frontiers c1 loc') t'\""], ["proof (prove)\nusing this:\n  t' \\<in>\\<^sub>A frontier (c_pts c1 loc) -\n                   frontier (c_pts c0 loc) \\<Longrightarrow>\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n  t' \\<in>\\<^sub>A frontier (c_pts c0 loc) -\n                   frontier (c_pts c1 loc) \\<Longrightarrow>\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n  \\<lbrakk>t' \\<notin>\\<^sub>A frontier (c_pts c1 loc) -\n                               frontier (c_pts c0 loc);\n   t' \\<notin>\\<^sub>A frontier (c_pts c0 loc) -\n                       frontier (c_pts c1 loc)\\<rbrakk>\n  \\<Longrightarrow> zcount (c_imp c1 loc + c_work c1 loc) t' =\n                    zcount\n                     (zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c1 loc)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c1 loc')))))\n                          (summary loc' loc)))\n                     t'\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc' + c_work c1 loc') t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n      (\\<Sum>loc'a\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n          (summary loc'a loc')))\n     t'", "using loc"], ["proof (prove)\nusing this:\n  t' \\<in>\\<^sub>A frontier (c_pts c1 loc) -\n                   frontier (c_pts c0 loc) \\<Longrightarrow>\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n  t' \\<in>\\<^sub>A frontier (c_pts c0 loc) -\n                   frontier (c_pts c1 loc) \\<Longrightarrow>\n  zcount (c_imp c1 loc + c_work c1 loc) t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)))\n   t'\n  \\<lbrakk>t' \\<notin>\\<^sub>A frontier (c_pts c1 loc) -\n                               frontier (c_pts c0 loc);\n   t' \\<notin>\\<^sub>A frontier (c_pts c0 loc) -\n                       frontier (c_pts c1 loc)\\<rbrakk>\n  \\<Longrightarrow> zcount (c_imp c1 loc + c_work c1 loc) t' =\n                    zcount\n                     (zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c1 loc)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c1 loc')))))\n                          (summary loc' loc)))\n                     t'\n  loc' = loc\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc' + c_work c1 loc') t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n      (\\<Sum>loc'a\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n          (summary loc'a loc')))\n     t'", "by auto"], ["proof (state)\nthis:\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "}"], ["proof (state)\nthis:\n  loc' = loc \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "ultimately"], ["proof (chain)\npicking this:\n  loc' \\<noteq> loc \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n  loc' = loc \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'", "have\n      \"zcount (c_imp c1 loc' + c_work c1 loc') t'\n          = zcount (zmset_frontier (c_pts c1 loc')\n              + union_frontiers c1 loc') t'\""], ["proof (prove)\nusing this:\n  loc' \\<noteq> loc \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n  loc' = loc \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc' + c_work c1 loc') t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n      (\\<Sum>loc'a\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n          (summary loc'a loc')))\n     t'", "by auto"], ["proof (state)\nthis:\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "}"], ["proof (state)\nthis:\n  \\<lbrakk>next_change_multiplicity' c0 c1 ?loca3 ?ta3 ?na3;\n   inv_imps_work_sum c0\\<rbrakk>\n  \\<Longrightarrow> zcount (c_imp c1 ?loc'3 + c_work c1 ?loc'3) ?t'3 =\n                    zcount\n                     (zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c1 ?loc'3)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c1 loc')))))\n                          (summary loc' ?loc'3)))\n                     ?t'3\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "with assms"], ["proof (chain)\npicking this:\n  next_change_multiplicity' c0 c1 loc t n\n  inv_imps_work_sum c0\n  \\<lbrakk>next_change_multiplicity' c0 c1 ?loca3 ?ta3 ?na3;\n   inv_imps_work_sum c0\\<rbrakk>\n  \\<Longrightarrow> zcount (c_imp c1 ?loc'3 + c_work c1 ?loc'3) ?t'3 =\n                    zcount\n                     (zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c1 ?loc'3)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c1 loc')))))\n                          (summary loc' ?loc'3)))\n                     ?t'3", "show ?thesis"], ["proof (prove)\nusing this:\n  next_change_multiplicity' c0 c1 loc t n\n  inv_imps_work_sum c0\n  \\<lbrakk>next_change_multiplicity' c0 c1 ?loca3 ?ta3 ?na3;\n   inv_imps_work_sum c0\\<rbrakk>\n  \\<Longrightarrow> zcount (c_imp c1 ?loc'3 + c_work c1 ?loc'3) ?t'3 =\n                    zcount\n                     (zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c1 ?loc'3)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c1 loc')))))\n                          (summary loc' ?loc'3)))\n                     ?t'3\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "by (auto simp: Let_def inv_imps_work_sum_zcount inv_imps_work_sum_zcount_def)"], ["proof (state)\nthis:\n  inv_imps_work_sum c1\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>PR preserves @{term inv_imps_work_sum}\\<close>"], ["", "lemma p_preserves_inv_imps_work_sum:\n  assumes \"next_propagate' c0 c1 loc t\"\n    and   \"inv_imps_work_sum c0\"\n  shows   \"inv_imps_work_sum c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "proof -\n  \\<comment> \\<open>Given @{term next_propagate'} for loc, t, we show the result for loc', t'.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "fix loc t loc' t'"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume p': \"next_propagate' c0 c1 loc t\""], ["proof (state)\nthis:\n  next_propagate' c0 c1 loc t\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note p = this[unfolded next_propagate'_def]"], ["proof (state)\nthis:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from p"], ["proof (chain)\npicking this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>", "have unchanged_ps: \"unchanged c_pts c0 c1\""], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n\ngoal (1 subgoal):\n 1. c_pts c1 = c_pts c0", "by simp"], ["proof (state)\nthis:\n  c_pts c1 = c_pts c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume \"inv_imps_work_sum c0\""], ["proof (state)\nthis:\n  inv_imps_work_sum c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "then"], ["proof (chain)\npicking this:\n  inv_imps_work_sum c0", "have iiws': \"inv_imps_work_sum_zcount c0\""], ["proof (prove)\nusing this:\n  inv_imps_work_sum c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum_zcount c0", "by (simp add: inv_imps_work_sum_zcount)"], ["proof (state)\nthis:\n  inv_imps_work_sum_zcount c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note iiws = iiws'[unfolded inv_imps_work_sum_zcount_def, THEN spec2]"], ["proof (state)\nthis:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "{"], ["proof (state)\nthis:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume loc: \"loc=loc'\""], ["proof (state)\nthis:\n  loc = loc'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note iiws"], ["proof (state)\nthis:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note unchanged_ps\n        \\<comment> \\<open>The t entries in loc's worklist are shifted to the implications.\\<close>"], ["proof (state)\nthis:\n  c_pts c1 = c_pts c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  c_pts c1 = c_pts c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from p"], ["proof (chain)\npicking this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>", "have \"zcount (c_work c1 loc) t = 0\""], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n\ngoal (1 subgoal):\n 1. zcount (c_work c1 loc) t = 0", "by simp"], ["proof (state)\nthis:\n  zcount (c_work c1 loc) t = 0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  zcount (c_work c1 loc) t = 0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from p"], ["proof (chain)\npicking this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>", "have\n        \"zcount (c_imp c1 loc) t\n         = zcount (c_imp c0 loc) t + zcount (c_work c0 loc) t\""], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc) t =\n    zcount (c_imp c0 loc) t + zcount (c_work c0 loc) t", "by simp\n          \\<comment> \\<open>Since the implications of other locations don't change and loc can't have an edge to\n              itself, @{term union_frontiers} at loc doesn't change.\\<close>"], ["proof (state)\nthis:\n  zcount (c_imp c1 loc) t =\n  zcount (c_imp c0 loc) t + zcount (c_work c0 loc) t\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  zcount (c_imp c1 loc) t =\n  zcount (c_imp c0 loc) t + zcount (c_work c0 loc) t\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from p"], ["proof (chain)\npicking this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>", "have \"union_frontiers c1 loc = union_frontiers c0 loc\""], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n\ngoal (1 subgoal):\n 1. (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)) =\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' loc))", "using summary_self"], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n  summary ?loc ?loc = {}\\<^sub>A\n\ngoal (1 subgoal):\n 1. (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n        (summary loc' loc)) =\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' loc))", "by (auto intro!: sum.cong arg_cong[where f = Sum])\n          \\<comment> \\<open>For all the other timestamps the worklist and implications don't change.\\<close>"], ["proof (state)\nthis:\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' loc)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' loc))\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' loc)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' loc))\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from p"], ["proof (chain)\npicking this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>", "have\n        \"tX \\<noteq> t \\<Longrightarrow> zcount (c_work c1 loc) tX = zcount (c_work c0 loc) tX\" for tX"], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n\ngoal (1 subgoal):\n 1. tX \\<noteq> t \\<Longrightarrow>\n    zcount (c_work c1 loc) tX = zcount (c_work c0 loc) tX", "by simp"], ["proof (state)\nthis:\n  ?tX1 \\<noteq> t \\<Longrightarrow>\n  zcount (c_work c1 loc) ?tX1 = zcount (c_work c0 loc) ?tX1\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  ?tX1 \\<noteq> t \\<Longrightarrow>\n  zcount (c_work c1 loc) ?tX1 = zcount (c_work c0 loc) ?tX1\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from p"], ["proof (chain)\npicking this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>", "have\n        \"tX \\<noteq> t \\<Longrightarrow> zcount (c_imp c1 loc) tX = zcount (c_imp c0 loc) tX\" for tX"], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n\ngoal (1 subgoal):\n 1. tX \\<noteq> t \\<Longrightarrow>\n    zcount (c_imp c1 loc) tX = zcount (c_imp c0 loc) tX", "by simp"], ["proof (state)\nthis:\n  ?tX1 \\<noteq> t \\<Longrightarrow>\n  zcount (c_imp c1 loc) ?tX1 = zcount (c_imp c0 loc) ?tX1\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "ultimately"], ["proof (chain)\npicking this:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n  c_pts c1 = c_pts c0\n  zcount (c_work c1 loc) t = 0\n  zcount (c_imp c1 loc) t =\n  zcount (c_imp c0 loc) t + zcount (c_work c0 loc) t\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' loc)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' loc))\n  ?tX1 \\<noteq> t \\<Longrightarrow>\n  zcount (c_work c1 loc) ?tX1 = zcount (c_work c0 loc) ?tX1\n  ?tX1 \\<noteq> t \\<Longrightarrow>\n  zcount (c_imp c1 loc) ?tX1 = zcount (c_imp c0 loc) ?tX1", "have\n        \"zcount (c_imp c1 loc' + c_work c1 loc') t'\n         = zcount (zmset_frontier (c_pts c1 loc') + union_frontiers c1 loc') t'\""], ["proof (prove)\nusing this:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n  c_pts c1 = c_pts c0\n  zcount (c_work c1 loc) t = 0\n  zcount (c_imp c1 loc) t =\n  zcount (c_imp c0 loc) t + zcount (c_work c0 loc) t\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc')))))\n      (summary loc' loc)) =\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n      (summary loc' loc))\n  ?tX1 \\<noteq> t \\<Longrightarrow>\n  zcount (c_work c1 loc) ?tX1 = zcount (c_work c0 loc) ?tX1\n  ?tX1 \\<noteq> t \\<Longrightarrow>\n  zcount (c_imp c1 loc) ?tX1 = zcount (c_imp c0 loc) ?tX1\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc' + c_work c1 loc') t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n      (\\<Sum>loc'a\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n          (summary loc'a loc')))\n     t'", "unfolding loc"], ["proof (prove)\nusing this:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n  c_pts c1 = c_pts c0\n  zcount (c_work c1 loc') t = 0\n  zcount (c_imp c1 loc') t =\n  zcount (c_imp c0 loc') t + zcount (c_work c0 loc') t\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n      (summary loc'a loc')) =\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc'a)))))\n      (summary loc'a loc'))\n  ?tX1 \\<noteq> t \\<Longrightarrow>\n  zcount (c_work c1 loc') ?tX1 = zcount (c_work c0 loc') ?tX1\n  ?tX1 \\<noteq> t \\<Longrightarrow>\n  zcount (c_imp c1 loc') ?tX1 = zcount (c_imp c0 loc') ?tX1\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc' + c_work c1 loc') t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n      (\\<Sum>loc'a\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n          (summary loc'a loc')))\n     t'", "by (cases \"t=t'\") simp_all"], ["proof (state)\nthis:\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "}"], ["proof (state)\nthis:\n  loc = loc' \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  loc = loc' \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "{"], ["proof (state)\nthis:\n  loc = loc' \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume loc: \"loc\\<noteq>loc'\"\n        \\<comment> \\<open>The implications are unchanged at all locations other than loc.\\<close>"], ["proof (state)\nthis:\n  loc \\<noteq> loc'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from p loc"], ["proof (chain)\npicking this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n  loc \\<noteq> loc'", "have unchanged_imps: \"c_imp c1 loc' = c_imp c0 loc'\""], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n  loc \\<noteq> loc'\n\ngoal (1 subgoal):\n 1. c_imp c1 loc' = c_imp c0 loc'", "by simp"], ["proof (state)\nthis:\n  c_imp c1 loc' = c_imp c0 loc'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "{"], ["proof (state)\nthis:\n  c_imp c1 loc' = c_imp c0 loc'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume sum: \"summary loc loc' = {}\\<^sub>A\""], ["proof (state)\nthis:\n  summary loc loc' = {}\\<^sub>A\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note iiws"], ["proof (state)\nthis:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note unchanged_ps"], ["proof (state)\nthis:\n  c_pts c1 = c_pts c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  c_pts c1 = c_pts c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note unchanged_imps\n          \\<comment> \\<open>The worklist only changes if loc, loc' are connected.\\<close>"], ["proof (state)\nthis:\n  c_imp c1 loc' = c_imp c0 loc'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  c_imp c1 loc' = c_imp c0 loc'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from p loc sum"], ["proof (chain)\npicking this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n  loc \\<noteq> loc'\n  summary loc loc' = {}\\<^sub>A", "have \"c_work c1 loc' = c_work c0 loc'\""], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n  loc \\<noteq> loc'\n  summary loc loc' = {}\\<^sub>A\n\ngoal (1 subgoal):\n 1. c_work c1 loc' = c_work c0 loc'", "by simp\n            \\<comment> \\<open>Since the implications only change at loc and loc is not connected to loc',\n            @{term union_frontiers} doesn't change.\\<close>"], ["proof (state)\nthis:\n  c_work c1 loc' = c_work c0 loc'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  c_work c1 loc' = c_work c0 loc'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from p loc sum"], ["proof (chain)\npicking this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n  loc \\<noteq> loc'\n  summary loc loc' = {}\\<^sub>A", "have \"union_frontiers c1 loc' = union_frontiers c0 loc'\""], ["proof (prove)\nusing this:\n  t \\<in>#\\<^sub>z c_work c0 loc \\<and>\n  (\\<forall>t' loc'.\n      t' \\<in>#\\<^sub>z c_work c0 loc' \\<longrightarrow>\n      \\<not> t' < t) \\<and>\n  c1 = c0\n  \\<lparr>c_imp := (c_imp c0)\n            (loc :=\n               c_imp c0 loc + {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#}),\n     c_work :=\n       \\<lambda>loc'.\n          if loc' = loc\n          then {#t' \\<in>#\\<^sub>z c_work c0 loc'. t' \\<noteq> t#}\n          else c_work c0 loc' +\n               after_summary\n                (frontier_changes\n                  (c_imp c0 loc +\n                   {#t' \\<in>#\\<^sub>z c_work c0 loc. t' = t#})\n                  (c_imp c0 loc))\n                (summary loc loc')\\<rparr>\n  loc \\<noteq> loc'\n  summary loc loc' = {}\\<^sub>A\n\ngoal (1 subgoal):\n 1. (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')) =\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc'a)))))\n        (summary loc'a loc'))", "by (auto intro!: sum.cong arg_cong[where f = Sum])"], ["proof (state)\nthis:\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n      (summary loc'a loc')) =\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc'a)))))\n      (summary loc'a loc'))\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "ultimately"], ["proof (chain)\npicking this:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n  c_pts c1 = c_pts c0\n  c_imp c1 loc' = c_imp c0 loc'\n  c_work c1 loc' = c_work c0 loc'\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n      (summary loc'a loc')) =\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc'a)))))\n      (summary loc'a loc'))", "have\n          \"zcount (c_imp c1 loc' + c_work c1 loc') t'\n           = zcount (zmset_frontier (c_pts c1 loc') + union_frontiers c1 loc') t'\""], ["proof (prove)\nusing this:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n  c_pts c1 = c_pts c0\n  c_imp c1 loc' = c_imp c0 loc'\n  c_work c1 loc' = c_work c0 loc'\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n      (summary loc'a loc')) =\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc'a)))))\n      (summary loc'a loc'))\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc' + c_work c1 loc') t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n      (\\<Sum>loc'a\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n          (summary loc'a loc')))\n     t'", "by simp"], ["proof (state)\nthis:\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "}"], ["proof (state)\nthis:\n  summary loc loc' = {}\\<^sub>A \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  summary loc loc' = {}\\<^sub>A \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "{"], ["proof (state)\nthis:\n  summary loc loc' = {}\\<^sub>A \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "assume sum: \"summary loc loc' \\<noteq> {}\\<^sub>A\"\n          \\<comment> \\<open>@{term union_frontiers} at loc' changed by whatever amount the frontier changed.\\<close>"], ["proof (state)\nthis:\n  summary loc loc' \\<noteq> {}\\<^sub>A\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "note iiws\n          unchanged_imps\n          unchanged_ps"], ["proof (state)\nthis:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n  c_imp c1 loc' = c_imp c0 loc'\n  c_pts c1 = c_pts c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n  c_imp c1 loc' = c_imp c0 loc'\n  c_pts c1 = c_pts c0\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from p' sum"], ["proof (chain)\npicking this:\n  next_propagate' c0 c1 loc t\n  summary loc loc' \\<noteq> {}\\<^sub>A", "have\n          \"union_frontiers c1 loc' =\n           union_frontiers c0 loc'\n            + after_summary\n                (zmset_frontier (c_imp c1 loc) - zmset_frontier (c_imp c0 loc))\n                (summary loc loc')\""], ["proof (prove)\nusing this:\n  next_propagate' c0 c1 loc t\n  summary loc loc' \\<noteq> {}\\<^sub>A\n\ngoal (1 subgoal):\n 1. (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')) =\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc'a)))))\n        (summary loc'a loc')) +\n    after_summary (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n     (summary loc loc')", "by (auto intro!: next_p_union_frontier_change)\n            \\<comment> \\<open>The worklist at loc' changed by the same amount\\<close>"], ["proof (state)\nthis:\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n      (summary loc'a loc')) =\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc'a)))))\n      (summary loc'a loc')) +\n  after_summary (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n   (summary loc loc')\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n      (summary loc'a loc')) =\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc'a)))))\n      (summary loc'a loc')) +\n  after_summary (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n   (summary loc loc')\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "from p' sum"], ["proof (chain)\npicking this:\n  next_propagate' c0 c1 loc t\n  summary loc loc' \\<noteq> {}\\<^sub>A", "have\n          \"c_work c1 loc' =\n           c_work c0 loc'\n            + after_summary\n                (zmset_frontier (c_imp c1 loc) - zmset_frontier (c_imp c0 loc))\n                (summary loc loc')\""], ["proof (prove)\nusing this:\n  next_propagate' c0 c1 loc t\n  summary loc loc' \\<noteq> {}\\<^sub>A\n\ngoal (1 subgoal):\n 1. c_work c1 loc' =\n    c_work c0 loc' +\n    after_summary (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n     (summary loc loc')", "by (auto intro!: next_p_frontier_change)\n            \\<comment> \\<open>The two changes cancel out.\\<close>"], ["proof (state)\nthis:\n  c_work c1 loc' =\n  c_work c0 loc' +\n  after_summary (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n   (summary loc loc')\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "ultimately"], ["proof (chain)\npicking this:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n  c_imp c1 loc' = c_imp c0 loc'\n  c_pts c1 = c_pts c0\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n      (summary loc'a loc')) =\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc'a)))))\n      (summary loc'a loc')) +\n  after_summary (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n   (summary loc loc')\n  c_work c1 loc' =\n  c_work c0 loc' +\n  after_summary (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n   (summary loc loc')", "have\n          \"zcount (c_imp c1 loc' + c_work c1 loc') t'\n         = zcount (zmset_frontier (c_pts c1 loc') + union_frontiers c1 loc') t'\""], ["proof (prove)\nusing this:\n  zcount (c_imp c0 ?x + c_work c0 ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c0 ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc')))))\n        (summary loc' ?x)))\n   ?y\n  c_imp c1 loc' = c_imp c0 loc'\n  c_pts c1 = c_pts c0\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n      (summary loc'a loc')) =\n  (\\<Sum>loc'a\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c0 loc'a)))))\n      (summary loc'a loc')) +\n  after_summary (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n   (summary loc loc')\n  c_work c1 loc' =\n  c_work c0 loc' +\n  after_summary (frontier_changes (c_imp c1 loc) (c_imp c0 loc))\n   (summary loc loc')\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc' + c_work c1 loc') t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n      (\\<Sum>loc'a\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n          (summary loc'a loc')))\n     t'", "by simp"], ["proof (state)\nthis:\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "}"], ["proof (state)\nthis:\n  summary loc loc' \\<noteq> {}\\<^sub>A \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "ultimately"], ["proof (chain)\npicking this:\n  summary loc loc' = {}\\<^sub>A \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n  summary loc loc' \\<noteq> {}\\<^sub>A \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'", "have\n        \"zcount (c_imp c1 loc' + c_work c1 loc') t'\n         = zcount (zmset_frontier (c_pts c1 loc') + union_frontiers c1 loc') t'\""], ["proof (prove)\nusing this:\n  summary loc loc' = {}\\<^sub>A \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n  summary loc loc' \\<noteq> {}\\<^sub>A \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc' + c_work c1 loc') t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n      (\\<Sum>loc'a\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n          (summary loc'a loc')))\n     t'", "by auto"], ["proof (state)\nthis:\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "}"], ["proof (state)\nthis:\n  loc \\<noteq> loc' \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "ultimately"], ["proof (chain)\npicking this:\n  loc = loc' \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n  loc \\<noteq> loc' \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'", "have\n      \"zcount (c_imp c1 loc' + c_work c1 loc') t'\n         = zcount (zmset_frontier (c_pts c1 loc') + union_frontiers c1 loc') t'\""], ["proof (prove)\nusing this:\n  loc = loc' \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n  loc \\<noteq> loc' \\<Longrightarrow>\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. zcount (c_imp c1 loc' + c_work c1 loc') t' =\n    zcount\n     (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n      (\\<Sum>loc'a\\<in>UNIV.\n         after_summary\n          (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n          (summary loc'a loc')))\n     t'", "by (cases \"loc=loc'\") auto"], ["proof (state)\nthis:\n  zcount (c_imp c1 loc' + c_work c1 loc') t' =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c1 loc')))) +\n    (\\<Sum>loc'a\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c1 loc'a)))))\n        (summary loc'a loc')))\n   t'\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "}"], ["proof (state)\nthis:\n  \\<lbrakk>next_propagate' c0 c1 ?loca3 ?ta3; inv_imps_work_sum c0\\<rbrakk>\n  \\<Longrightarrow> zcount (c_imp c1 ?loc'3 + c_work c1 ?loc'3) ?t'3 =\n                    zcount\n                     (zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c1 ?loc'3)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c1 loc')))))\n                          (summary loc' ?loc'3)))\n                     ?t'3\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "with assms"], ["proof (chain)\npicking this:\n  next_propagate' c0 c1 loc t\n  inv_imps_work_sum c0\n  \\<lbrakk>next_propagate' c0 c1 ?loca3 ?ta3; inv_imps_work_sum c0\\<rbrakk>\n  \\<Longrightarrow> zcount (c_imp c1 ?loc'3 + c_work c1 ?loc'3) ?t'3 =\n                    zcount\n                     (zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c1 ?loc'3)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c1 loc')))))\n                          (summary loc' ?loc'3)))\n                     ?t'3", "show ?thesis"], ["proof (prove)\nusing this:\n  next_propagate' c0 c1 loc t\n  inv_imps_work_sum c0\n  \\<lbrakk>next_propagate' c0 c1 ?loca3 ?ta3; inv_imps_work_sum c0\\<rbrakk>\n  \\<Longrightarrow> zcount (c_imp c1 ?loc'3 + c_work c1 ?loc'3) ?t'3 =\n                    zcount\n                     (zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c1 ?loc'3)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c1 loc')))))\n                          (summary loc' ?loc'3)))\n                     ?t'3\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum c1", "by (auto simp: next_propagate'_def Let_def inv_imps_work_sum_zcount inv_imps_work_sum_zcount_def)"], ["proof (state)\nthis:\n  inv_imps_work_sum c1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma next_preserves_inv_imps_work_sum:\n  assumes \"next s\"\n    and   \"holds inv_imps_work_sum s\"\n  shows   \"nxt (holds inv_imps_work_sum) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nxt (holds inv_imps_work_sum) s", "using assms\n    cm_preserves_inv_imps_work_sum\n    p_preserves_inv_imps_work_sum"], ["proof (prove)\nusing this:\n  next s\n  holds inv_imps_work_sum s\n  \\<lbrakk>next_change_multiplicity' ?c0.0 ?c1.0 ?loc ?t ?n;\n   inv_imps_work_sum ?c0.0\\<rbrakk>\n  \\<Longrightarrow> inv_imps_work_sum ?c1.0\n  \\<lbrakk>next_propagate' ?c0.0 ?c1.0 ?loc ?t;\n   inv_imps_work_sum ?c0.0\\<rbrakk>\n  \\<Longrightarrow> inv_imps_work_sum ?c1.0\n\ngoal (1 subgoal):\n 1. nxt (holds inv_imps_work_sum) s", "by (simp, cases rule: next'_inv)"], ["", "lemma spec_imp_iiws: \"spec s \\<Longrightarrow> alw (holds inv_imps_work_sum) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds inv_imps_work_sum) s", "using init_imp_inv_imps_work_sum next_preserves_inv_imps_work_sum"], ["proof (prove)\nusing this:\n  init_config ?c \\<Longrightarrow> inv_imps_work_sum ?c\n  \\<lbrakk>next ?s; holds inv_imps_work_sum ?s\\<rbrakk>\n  \\<Longrightarrow> nxt (holds inv_imps_work_sum) ?s\n\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds inv_imps_work_sum) s", "by (auto intro: alw_invar simp: alw_mono spec_def)"], ["", "subsubsection\\<open>Invariant: @{term inv_imp_plus_work_nonneg}\\<close>"], ["", "text \\<open>There is never an update in the worklist that could cause implications to become negative.\\<close>"], ["", "definition inv_imp_plus_work_nonneg where\n  \"inv_imp_plus_work_nonneg c \\<equiv> \\<forall>loc t. 0 \\<le> zcount (c_imp c loc) t + zcount (c_work c loc) t\""], ["", "lemma iiws_imp_iipwn:\n  assumes \"inv_imps_work_sum c\"\n  shows \"inv_imp_plus_work_nonneg c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_imp_plus_work_nonneg c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_imp_plus_work_nonneg c", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_imp_plus_work_nonneg c", "fix loc"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_imp_plus_work_nonneg c", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_imp_plus_work_nonneg c", "assume \"inv_imps_work_sum c\""], ["proof (state)\nthis:\n  inv_imps_work_sum c\n\ngoal (1 subgoal):\n 1. inv_imp_plus_work_nonneg c", "then"], ["proof (chain)\npicking this:\n  inv_imps_work_sum c", "have iiws': \"inv_imps_work_sum_zcount c\""], ["proof (prove)\nusing this:\n  inv_imps_work_sum c\n\ngoal (1 subgoal):\n 1. inv_imps_work_sum_zcount c", "by (simp add: inv_imps_work_sum_zcount)"], ["proof (state)\nthis:\n  inv_imps_work_sum_zcount c\n\ngoal (1 subgoal):\n 1. inv_imp_plus_work_nonneg c", "note iiws = iiws'[unfolded inv_imps_work_sum_zcount_def, THEN spec2]"], ["proof (state)\nthis:\n  zcount (c_imp c ?x + c_work c ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n        (summary loc' ?x)))\n   ?y\n\ngoal (1 subgoal):\n 1. inv_imp_plus_work_nonneg c", "have \"0 \\<le> zcount (union_frontiers c loc) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> zcount\n             (\\<Sum>loc'\\<in>UNIV.\n                after_summary\n                 (zmset_of\n                   (mset_set (set_antichain (frontier (c_imp c loc')))))\n                 (summary loc' loc))\n             t", "by (simp add: union_frontiers_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> zcount\n           (\\<Sum>loc'\\<in>UNIV.\n              after_summary\n               (zmset_of\n                 (mset_set (set_antichain (frontier (c_imp c loc')))))\n               (summary loc' loc))\n           t\n\ngoal (1 subgoal):\n 1. inv_imp_plus_work_nonneg c", "with iiws"], ["proof (chain)\npicking this:\n  zcount (c_imp c ?x + c_work c ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n        (summary loc' ?x)))\n   ?y\n  0 \\<le> zcount\n           (\\<Sum>loc'\\<in>UNIV.\n              after_summary\n               (zmset_of\n                 (mset_set (set_antichain (frontier (c_imp c loc')))))\n               (summary loc' loc))\n           t", "have \"0 \\<le> zcount (c_imp c loc + c_work c loc) t\""], ["proof (prove)\nusing this:\n  zcount (c_imp c ?x + c_work c ?x) ?y =\n  zcount\n   (zmset_of (mset_set (set_antichain (frontier (c_pts c ?x)))) +\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n        (summary loc' ?x)))\n   ?y\n  0 \\<le> zcount\n           (\\<Sum>loc'\\<in>UNIV.\n              after_summary\n               (zmset_of\n                 (mset_set (set_antichain (frontier (c_imp c loc')))))\n               (summary loc' loc))\n           t\n\ngoal (1 subgoal):\n 1. 0 \\<le> zcount (c_imp c loc + c_work c loc) t", "by simp"], ["proof (state)\nthis:\n  0 \\<le> zcount (c_imp c loc + c_work c loc) t\n\ngoal (1 subgoal):\n 1. inv_imp_plus_work_nonneg c", "}"], ["proof (state)\nthis:\n  inv_imps_work_sum c \\<Longrightarrow>\n  0 \\<le> zcount (c_imp c ?loc3 + c_work c ?loc3) ?t3\n\ngoal (1 subgoal):\n 1. inv_imp_plus_work_nonneg c", "with assms"], ["proof (chain)\npicking this:\n  inv_imps_work_sum c\n  inv_imps_work_sum c \\<Longrightarrow>\n  0 \\<le> zcount (c_imp c ?loc3 + c_work c ?loc3) ?t3", "show ?thesis"], ["proof (prove)\nusing this:\n  inv_imps_work_sum c\n  inv_imps_work_sum c \\<Longrightarrow>\n  0 \\<le> zcount (c_imp c ?loc3 + c_work c ?loc3) ?t3\n\ngoal (1 subgoal):\n 1. inv_imp_plus_work_nonneg c", "by (simp add: inv_imp_plus_work_nonneg_def)"], ["proof (state)\nthis:\n  inv_imp_plus_work_nonneg c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spec_imp_iipwn: \"spec s \\<Longrightarrow> alw (holds inv_imp_plus_work_nonneg) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds inv_imp_plus_work_nonneg) s", "using spec_imp_iiws iiws_imp_iipwn\n    alw_mono holds_mono"], ["proof (prove)\nusing this:\n  spec ?s \\<Longrightarrow> alw (holds inv_imps_work_sum) ?s\n  inv_imps_work_sum ?c \\<Longrightarrow> inv_imp_plus_work_nonneg ?c\n  \\<lbrakk>alw ?\\<phi> ?xs;\n   \\<And>xs. ?\\<phi> xs \\<Longrightarrow> ?\\<psi> xs\\<rbrakk>\n  \\<Longrightarrow> alw ?\\<psi> ?xs\n  \\<lbrakk>holds ?P ?xs; \\<And>x. ?P x \\<Longrightarrow> ?Q x\\<rbrakk>\n  \\<Longrightarrow> holds ?Q ?xs\n\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds inv_imp_plus_work_nonneg) s", "by blast"], ["", "subsubsection\\<open>Invariant: @{term inv_implications_nonneg}\\<close>"], ["", "lemma init_imp_inv_implications_nonneg:\n  assumes \"init_config c\"\n  shows   \"inv_implications_nonneg c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_implications_nonneg c", "using assms"], ["proof (prove)\nusing this:\n  init_config c\n\ngoal (1 subgoal):\n 1. inv_implications_nonneg c", "by (simp add: init_config_def inv_implications_nonneg_def)"], ["", "lemma cm_preserves_inv_implications_nonneg:\n  assumes \"next_change_multiplicity' c0 c1 loc t n\"\n    and     \"inv_implications_nonneg c0\"\n  shows   \"inv_implications_nonneg c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_implications_nonneg c1", "using assms"], ["proof (prove)\nusing this:\n  next_change_multiplicity' c0 c1 loc t n\n  inv_implications_nonneg c0\n\ngoal (1 subgoal):\n 1. inv_implications_nonneg c1", "by (simp add: next_change_multiplicity'_def inv_implications_nonneg_def)"], ["", "lemma p_preserves_inv_implications_nonneg:\n  assumes \"next_propagate' c0 c1 loc t\"\n    and     \"inv_implications_nonneg c0\"\n    and     \"inv_imp_plus_work_nonneg c0\"\n  shows   \"inv_implications_nonneg c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_implications_nonneg c1", "using assms"], ["proof (prove)\nusing this:\n  next_propagate' c0 c1 loc t\n  inv_implications_nonneg c0\n  inv_imp_plus_work_nonneg c0\n\ngoal (1 subgoal):\n 1. inv_implications_nonneg c1", "by (auto simp: next_propagate'_def Let_def inv_implications_nonneg_def inv_imp_plus_work_nonneg_def)"], ["", "lemma next_preserves_inv_implications_nonneg:\n  assumes \"next s\"\n    and     \"holds inv_implications_nonneg s\"\n    and     \"holds inv_imp_plus_work_nonneg s\"\n  shows   \"nxt (holds inv_implications_nonneg) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nxt (holds inv_implications_nonneg) s", "using assms\n    cm_preserves_inv_implications_nonneg\n    p_preserves_inv_implications_nonneg"], ["proof (prove)\nusing this:\n  next s\n  holds inv_implications_nonneg s\n  holds inv_imp_plus_work_nonneg s\n  \\<lbrakk>next_change_multiplicity' ?c0.0 ?c1.0 ?loc ?t ?n;\n   inv_implications_nonneg ?c0.0\\<rbrakk>\n  \\<Longrightarrow> inv_implications_nonneg ?c1.0\n  \\<lbrakk>next_propagate' ?c0.0 ?c1.0 ?loc ?t;\n   inv_implications_nonneg ?c0.0; inv_imp_plus_work_nonneg ?c0.0\\<rbrakk>\n  \\<Longrightarrow> inv_implications_nonneg ?c1.0\n\ngoal (1 subgoal):\n 1. nxt (holds inv_implications_nonneg) s", "by (simp, cases rule: next'_inv)"], ["", "lemma alw_inv_implications_nonneg: \"spec s \\<Longrightarrow> alw (holds inv_implications_nonneg) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds inv_implications_nonneg) s", "apply (frule spec_imp_iipwn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>spec s; alw (holds inv_imp_plus_work_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds inv_implications_nonneg) s", "unfolding spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds init_config s \\<and> alw next s;\n     alw (holds inv_imp_plus_work_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds inv_implications_nonneg) s", "apply (rule alw_invar)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>holds init_config s \\<and> alw next s;\n     alw (holds inv_imp_plus_work_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> holds inv_implications_nonneg s\n 2. \\<lbrakk>holds init_config s \\<and> alw next s;\n     alw (holds inv_imp_plus_work_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (\\<lambda>xs.\n                              holds inv_implications_nonneg\n                               xs \\<longrightarrow>\n                              nxt (holds inv_implications_nonneg) xs)\n                       s", "using init_imp_inv_implications_nonneg"], ["proof (prove)\nusing this:\n  init_config ?c \\<Longrightarrow> inv_implications_nonneg ?c\n\ngoal (2 subgoals):\n 1. \\<lbrakk>holds init_config s \\<and> alw next s;\n     alw (holds inv_imp_plus_work_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> holds inv_implications_nonneg s\n 2. \\<lbrakk>holds init_config s \\<and> alw next s;\n     alw (holds inv_imp_plus_work_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (\\<lambda>xs.\n                              holds inv_implications_nonneg\n                               xs \\<longrightarrow>\n                              nxt (holds inv_implications_nonneg) xs)\n                       s", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>holds init_config s \\<and> alw next s;\n     alw (holds inv_imp_plus_work_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (\\<lambda>xs.\n                              holds inv_implications_nonneg\n                               xs \\<longrightarrow>\n                              nxt (holds inv_implications_nonneg) xs)\n                       s", "using next_preserves_inv_implications_nonneg"], ["proof (prove)\nusing this:\n  \\<lbrakk>next ?s; holds inv_implications_nonneg ?s;\n   holds inv_imp_plus_work_nonneg ?s\\<rbrakk>\n  \\<Longrightarrow> nxt (holds inv_implications_nonneg) ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>holds init_config s \\<and> alw next s;\n     alw (holds inv_imp_plus_work_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (\\<lambda>xs.\n                              holds inv_implications_nonneg\n                               xs \\<longrightarrow>\n                              nxt (holds inv_implications_nonneg) xs)\n                       s", "apply (metis (no_types, lifting) alw_iff_sdrop)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma after_summary_Diff: \"after_summary (M - N) S = after_summary M S - after_summary N S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. after_summary (M - N) S = after_summary M S - after_summary N S", "by (simp add: sum_subtractf after_summary_def)"], ["", "lemma mem_zmset_frontier: \"x \\<in>#\\<^sub>z zmset_frontier M \\<longleftrightarrow> x \\<in>\\<^sub>A frontier M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in>#\\<^sub>z zmset_of (mset_set (set_antichain (frontier M)))) =\n    (x \\<in>\\<^sub>A frontier M)", "by transfer simp"], ["", "lemma obtain_frontier_elem:\n  assumes \"0 < zcount M t\"\n  obtains u where \"u \\<in>\\<^sub>A frontier M\" \"u \\<le> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in>\\<^sub>A frontier M; u \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  0 < zcount M t\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in>\\<^sub>A frontier M; u \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (atomize_elim, transfer)\n    (auto simp: minimal_antichain_def dest: order_zmset_exists_foundation)"], ["", "lemma frontier_unionD: \"t \\<in>\\<^sub>A frontier (M+N) \\<Longrightarrow> 0 < zcount M t \\<or> 0 < zcount N t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in>\\<^sub>A frontier (M + N) \\<Longrightarrow>\n    0 < zcount M t \\<or> 0 < zcount N t", "by transfer' (auto simp: minimal_antichain_def)"], ["", "lemma ps_frontier_in_imps_wl:\n  assumes \"inv_imps_work_sum c\"\n    and   \"0 < zcount (zmset_frontier (c_pts c loc)) t\"\n  shows   \"0 < zcount (c_imp c loc + c_work c loc) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc + c_work c loc) t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc + c_work c loc) t", "have \"0 \\<le> zcount (union_frontiers c loc) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> zcount\n             (\\<Sum>loc'\\<in>UNIV.\n                after_summary\n                 (zmset_of\n                   (mset_set (set_antichain (frontier (c_imp c loc')))))\n                 (summary loc' loc))\n             t", "by (rule union_frontiers_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> zcount\n           (\\<Sum>loc'\\<in>UNIV.\n              after_summary\n               (zmset_of\n                 (mset_set (set_antichain (frontier (c_imp c loc')))))\n               (summary loc' loc))\n           t\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc + c_work c loc) t", "with assms(2)"], ["proof (chain)\npicking this:\n  0 < zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c loc)))))\n       t\n  0 \\<le> zcount\n           (\\<Sum>loc'\\<in>UNIV.\n              after_summary\n               (zmset_of\n                 (mset_set (set_antichain (frontier (c_imp c loc')))))\n               (summary loc' loc))\n           t", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c loc)))))\n       t\n  0 \\<le> zcount\n           (\\<Sum>loc'\\<in>UNIV.\n              after_summary\n               (zmset_of\n                 (mset_set (set_antichain (frontier (c_imp c loc')))))\n               (summary loc' loc))\n           t\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc + c_work c loc) t", "using assms(1)[unfolded inv_imps_work_sum_def, THEN spec, of loc]"], ["proof (prove)\nusing this:\n  0 < zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c loc)))))\n       t\n  0 \\<le> zcount\n           (\\<Sum>loc'\\<in>UNIV.\n              after_summary\n               (zmset_of\n                 (mset_set (set_antichain (frontier (c_imp c loc')))))\n               (summary loc' loc))\n           t\n  c_imp c loc + c_work c loc =\n  zmset_of (mset_set (set_antichain (frontier (c_pts c loc)))) +\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n      (summary loc' loc))\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc + c_work c loc) t", "by fastforce"], ["proof (state)\nthis:\n  0 < zcount (c_imp c loc + c_work c loc) t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obtain_elem_frontier:\n  assumes \"0 < zcount M t\"\n  obtains s where \"s \\<le> t \\<and> s \\<in>\\<^sub>A frontier M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<le> t \\<and> s \\<in>\\<^sub>A frontier M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule order_finite_set_obtain_foundation[of \"{s. zcount M s > 0}\" t thesis])\n    (auto simp: assms antichain_inverse frontier_def member_antichain.rep_eq\n      in_minimal_antichain)"], ["", "lemma obtain_elem_zmset_frontier:\n  assumes \"0 < zcount M t\"\n  obtains s where \"s \\<le> t \\<and> 0 < zcount (zmset_frontier M) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<le> t \\<and>\n        0 < zcount (zmset_of (mset_set (set_antichain (frontier M))))\n             s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  0 < zcount M t\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<le> t \\<and>\n        0 < zcount (zmset_of (mset_set (set_antichain (frontier M))))\n             s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: member_antichain.rep_eq intro: obtain_elem_frontier)"], ["", "lemma ps_in_imps_wl:\n  assumes \"inv_imps_work_sum c\"\n    and   \"0 < zcount (c_pts c loc) t\"\n  obtains s where \"s \\<le> t \\<and> 0 < zcount (c_imp c loc + c_work c loc) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<le> t \\<and>\n        0 < zcount (c_imp c loc + c_work c loc) s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof atomize_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. 0 < zcount (c_imp c loc + c_work c loc) s", "note iiws = assms(1)[unfolded inv_imps_work_sum_def, THEN spec, of loc]"], ["proof (state)\nthis:\n  c_imp c loc + c_work c loc =\n  zmset_of (mset_set (set_antichain (frontier (c_pts c loc)))) +\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n      (summary loc' loc))\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. 0 < zcount (c_imp c loc + c_work c loc) s", "obtain u where u: \" u \\<le> t \\<and> u \\<in>\\<^sub>A frontier (c_pts c loc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<le> t \\<and>\n        u \\<in>\\<^sub>A frontier (c_pts c loc) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2) obtain_elem_frontier"], ["proof (prove)\nusing this:\n  0 < zcount (c_pts c loc) t\n  \\<lbrakk>0 < zcount ?M ?t;\n   \\<And>s.\n      s \\<le> ?t \\<and> s \\<in>\\<^sub>A frontier ?M \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<le> t \\<and>\n        u \\<in>\\<^sub>A frontier (c_pts c loc) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u \\<le> t \\<and> u \\<in>\\<^sub>A frontier (c_pts c loc)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. 0 < zcount (c_imp c loc + c_work c loc) s", "with assms(1)"], ["proof (chain)\npicking this:\n  inv_imps_work_sum c\n  u \\<le> t \\<and> u \\<in>\\<^sub>A frontier (c_pts c loc)", "have \"0 < zcount (c_imp c loc + c_work c loc) u\""], ["proof (prove)\nusing this:\n  inv_imps_work_sum c\n  u \\<le> t \\<and> u \\<in>\\<^sub>A frontier (c_pts c loc)\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc + c_work c loc) u", "apply (intro ps_frontier_in_imps_wl[of c loc u])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inv_imps_work_sum c;\n     u \\<le> t \\<and> u \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> inv_imps_work_sum c\n 2. \\<lbrakk>inv_imps_work_sum c;\n     u \\<le> t \\<and> u \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount\n                           (zmset_of\n                             (mset_set\n                               (set_antichain (frontier (c_pts c loc)))))\n                           u", "apply (auto intro: iffD1[OF member_antichain.rep_eq])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < zcount (c_imp c loc + c_work c loc) u\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. 0 < zcount (c_imp c loc + c_work c loc) s", "with u"], ["proof (chain)\npicking this:\n  u \\<le> t \\<and> u \\<in>\\<^sub>A frontier (c_pts c loc)\n  0 < zcount (c_imp c loc + c_work c loc) u", "show \"\\<exists>s\\<le>t. 0 < zcount (c_imp c loc + c_work c loc) s\""], ["proof (prove)\nusing this:\n  u \\<le> t \\<and> u \\<in>\\<^sub>A frontier (c_pts c loc)\n  0 < zcount (c_imp c loc + c_work c loc) u\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. 0 < zcount (c_imp c loc + c_work c loc) s", "by (auto intro: exI[of _ u])"], ["proof (state)\nthis:\n  \\<exists>s\\<le>t. 0 < zcount (c_imp c loc + c_work c loc) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_le_after_summary_single[simp]: \"0 \\<le> zcount (after_summary {#t#}\\<^sub>z S) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> zcount (after_summary {#t#}\\<^sub>z S) x", "by (auto intro: zero_le_sum_single simp: after_summary_def)"], ["", "lemma one_le_zcount_after_summary: \"s \\<in>\\<^sub>A S \\<Longrightarrow> 1 \\<le> zcount (after_summary {#t#}\\<^sub>z S) (results_in t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A S \\<Longrightarrow>\n    1 \\<le> zcount (after_summary {#t#}\\<^sub>z S) (results_in t s)", "unfolding image_zmset_single after_summary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A S \\<Longrightarrow>\n    1 \\<le> zcount (\\<Sum>s\\<in>set_antichain S. {#results_in t s#}\\<^sub>z)\n             (results_in t s)", "apply (subst zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A S \\<Longrightarrow>\n    1 \\<le> (\\<Sum>M\\<in>set_antichain S.\n               zcount {#results_in t M#}\\<^sub>z (results_in t s))", "apply (subst forw_subst[of 1 \"zcount {#results_in t s#}\\<^sub>z (results_in t s)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. s \\<in>\\<^sub>A S \\<Longrightarrow>\n    1 = zcount {#results_in t s#}\\<^sub>z (results_in t s)\n 2. s \\<in>\\<^sub>A S \\<Longrightarrow>\n    zcount {#results_in t s#}\\<^sub>z (results_in t s)\n    \\<le> (\\<Sum>M\\<in>set_antichain S.\n             zcount {#results_in t M#}\\<^sub>z (results_in t s))\n 3. s \\<in>\\<^sub>A S \\<Longrightarrow> True", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. s \\<in>\\<^sub>A S \\<Longrightarrow>\n    zcount {#results_in t s#}\\<^sub>z (results_in t s)\n    \\<le> (\\<Sum>M\\<in>set_antichain S.\n             zcount {#results_in t M#}\\<^sub>z (results_in t s))\n 2. s \\<in>\\<^sub>A S \\<Longrightarrow> True", "apply (rule sum_nonneg_leq_bound[of \"set_antichain S\" \"\\<lambda>u. zcount {#results_in t u#}\\<^sub>z (results_in t s)\" _ s])"], ["proof (prove)\ngoal (5 subgoals):\n 1. s \\<in>\\<^sub>A S \\<Longrightarrow> finite (set_antichain S)\n 2. \\<And>i.\n       \\<lbrakk>s \\<in>\\<^sub>A S; i \\<in> set_antichain S\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount {#results_in t i#}\\<^sub>z\n                                  (results_in t s)\n 3. s \\<in>\\<^sub>A S \\<Longrightarrow>\n    (\\<Sum>i\\<in>set_antichain S.\n       zcount {#results_in t i#}\\<^sub>z (results_in t s)) =\n    (\\<Sum>M\\<in>set_antichain S.\n       zcount {#results_in t M#}\\<^sub>z (results_in t s))\n 4. s \\<in>\\<^sub>A S \\<Longrightarrow> s \\<in> set_antichain S\n 5. s \\<in>\\<^sub>A S \\<Longrightarrow> True", "apply (auto simp: member_antichain.rep_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma zero_lt_zcount_after_summary: \"s \\<in>\\<^sub>A S \\<Longrightarrow> 0 < zcount (after_summary {#t#}\\<^sub>z S) (results_in t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A S \\<Longrightarrow>\n    0 < zcount (after_summary {#t#}\\<^sub>z S) (results_in t s)", "apply (subst int_one_le_iff_zero_less[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A S \\<Longrightarrow>\n    1 \\<le> zcount (after_summary {#t#}\\<^sub>z S) (results_in t s)", "apply (intro one_le_zcount_after_summary)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A S \\<Longrightarrow> s \\<in>\\<^sub>A S", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pos_zcount_after_summary:\n  \"(\\<And>t. 0 \\<le> zcount M t) \\<Longrightarrow> 0 < zcount M t \\<Longrightarrow> s \\<in>\\<^sub>A S \\<Longrightarrow> 0 < zcount (after_summary M S) (results_in t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t; 0 < zcount M t;\n     s \\<in>\\<^sub>A S\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount (after_summary M S) (results_in t s)", "by (auto intro!: sum_pos2 pos_zcount_image_zmset simp: member_antichain.rep_eq zcount_sum after_summary_def)"], ["", "lemma after_summary_nonneg: \"(\\<And>t. 0 \\<le> zcount M t) \\<Longrightarrow> 0 \\<le> zcount (after_summary M S) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. 0 \\<le> zcount M t) \\<Longrightarrow>\n    0 \\<le> zcount (after_summary M S) t", "by (auto simp: zcount_sum after_summary_def intro: sum_nonneg)"], ["", "lemma after_summary_zmset_of_nonneg[simp, intro]: \"0 \\<le> zcount (after_summary (zmset_of M) S) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> zcount (after_summary (zmset_of M) S) t", "by (simp add: mset_neg_image_zmset mset_neg_sum_set mset_neg_zcount_nonneg after_summary_def)"], ["", "lemma pos_zcount_union_frontiers:\n  \"zcount (after_summary (zmset_frontier (c_imp c l1)) (summary l1 l2)) (results_in t s)\n    \\<le> zcount (union_frontiers c l2) (results_in t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount\n     (after_summary\n       (zmset_of (mset_set (set_antichain (frontier (c_imp c l1)))))\n       (summary l1 l2))\n     (results_in t s)\n    \\<le> zcount\n           (\\<Sum>loc'\\<in>UNIV.\n              after_summary\n               (zmset_of\n                 (mset_set (set_antichain (frontier (c_imp c loc')))))\n               (summary loc' l2))\n           (results_in t s)", "apply (subst zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount\n     (after_summary\n       (zmset_of (mset_set (set_antichain (frontier (c_imp c l1)))))\n       (summary l1 l2))\n     (results_in t s)\n    \\<le> (\\<Sum>M\\<in>UNIV.\n             zcount\n              (after_summary\n                (zmset_of (mset_set (set_antichain (frontier (c_imp c M)))))\n                (summary M l2))\n              (results_in t s))", "apply (rule member_le_sum)"], ["proof (prove)\ngoal (3 subgoals):\n 1. l1 \\<in> UNIV\n 2. \\<And>x.\n       x \\<in> UNIV - {l1} \\<Longrightarrow>\n       0 \\<le> zcount\n                (after_summary\n                  (zmset_of\n                    (mset_set (set_antichain (frontier (c_imp c x)))))\n                  (summary x l2))\n                (results_in t s)\n 3. finite UNIV", "apply (auto intro!: pos_zcount_image_zmset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma after_summary_Sum_fun: \"finite MM \\<Longrightarrow> after_summary (\\<Sum>M\\<in>MM. f M) A = (\\<Sum>M\\<in>MM. after_summary (f M) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite MM \\<Longrightarrow>\n    after_summary (sum f MM) A = (\\<Sum>M\\<in>MM. after_summary (f M) A)", "by (induct MM rule: finite_induct) (auto simp: after_summary_union)"], ["", "lemma after_summary_obtain_pre:\n  assumes \"\\<And>t. 0 \\<le> zcount M t\" (* could prove without this assumption *)\n    and   \"0 < zcount (after_summary M S) t\"\n  obtains t' s where \"0 < zcount M t'\" \"results_in t' s = t\" \"s \\<in>\\<^sub>A S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t' s.\n        \\<lbrakk>0 < zcount M t'; results_in t' s = t;\n         s \\<in>\\<^sub>A S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> zcount M ?t1\n  0 < zcount (after_summary M S) t\n\ngoal (1 subgoal):\n 1. (\\<And>t' s.\n        \\<lbrakk>0 < zcount M t'; results_in t' s = t;\n         s \\<in>\\<^sub>A S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding after_summary_def"], ["proof (prove)\nusing this:\n  0 \\<le> zcount M ?t1\n  0 < zcount\n       (\\<Sum>s\\<in>set_antichain S. {#results_in t s. t \\<in>#\\<^sub>z M#})\n       t\n\ngoal (1 subgoal):\n 1. (\\<And>t' s.\n        \\<lbrakk>0 < zcount M t'; results_in t' s = t;\n         s \\<in>\\<^sub>A S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t;\n     0 < zcount\n          (\\<Sum>s\\<in>set_antichain S.\n             {#results_in t s. t \\<in>#\\<^sub>z M#})\n          t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' s.\n                         0 < zcount M t' \\<and>\n                         results_in t' s = t \\<and> s \\<in>\\<^sub>A S", "apply (subst (asm) zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t;\n     0 < (\\<Sum>Ma\\<in>set_antichain S.\n            zcount {#results_in t Ma. t \\<in>#\\<^sub>z M#} t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' s.\n                         0 < zcount M t' \\<and>\n                         results_in t' s = t \\<and> s \\<in>\\<^sub>A S", "apply (drule sum_pos_ex_elem_pos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t;\n     \\<exists>Ma\\<in>set_antichain S.\n        0 < zcount {#results_in t Ma. t \\<in>#\\<^sub>z M#} t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' s.\n                         0 < zcount M t' \\<and>\n                         results_in t' s = t \\<and> s \\<in>\\<^sub>A S", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ma.\n       \\<lbrakk>\\<And>t. 0 \\<le> zcount M t; Ma \\<in> set_antichain S;\n        0 < zcount {#results_in t Ma. t \\<in>#\\<^sub>z M#} t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t' s.\n                            0 < zcount M t' \\<and>\n                            results_in t' s = t \\<and> s \\<in>\\<^sub>A S", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t; s \\<in> set_antichain S;\n     0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' s.\n                         0 < zcount M t' \\<and>\n                         results_in t' s = t \\<and> s \\<in>\\<^sub>A S", "apply (subst ex_comm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t; s \\<in> set_antichain S;\n     0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y x.\n                         0 < zcount M x \\<and>\n                         results_in x y = t \\<and> y \\<in>\\<^sub>A S", "apply (rule exI[of _ s])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t; s \\<in> set_antichain S;\n     0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         0 < zcount M x \\<and>\n                         results_in x s = t \\<and> s \\<in>\\<^sub>A S", "apply (drule pos_image_zmset_obtain_pre[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>t. 0 \\<le> zcount M t;\n        s \\<in> set_antichain S\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount M t\n 2. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t; s \\<in> set_antichain S;\n     \\<exists>m. 0 < zcount M m \\<and> results_in m s = t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         0 < zcount M x \\<and>\n                         results_in x s = t \\<and> s \\<in>\\<^sub>A S", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t. 0 \\<le> zcount M t; s \\<in> set_antichain S;\n     \\<exists>m. 0 < zcount M m \\<and> results_in m s = t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         0 < zcount M x \\<and>\n                         results_in x s = t \\<and> s \\<in>\\<^sub>A S", "apply (simp add: member_antichain.rep_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma empty_antichain[dest]: \"x \\<in>\\<^sub>A antichain {} \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in>\\<^sub>A antichain {} \\<Longrightarrow> False", "by (metis empty_antichain.abs_eq mem_antichain_nonempty)"], ["", "definition impWitnessPath where\n  \"impWitnessPath c loc1 loc2 xs t = (\n    path loc1 loc2 xs \\<and>\n    distinct xs \\<and>\n    (\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc1) \\<and> t = results_in t' (sum_path_weights xs) \\<and>\n    (\\<forall>k<length xs. (\\<exists>t. t \\<in>\\<^sub>A frontier (c_imp c (TO (xs ! k))) \\<and> t = results_in t' (sum_path_weights (take (k+1) xs))))))\""], ["", "lemma impWitnessPathEx:\n  assumes \"t \\<in>\\<^sub>A frontier (c_imp c loc2)\"\n  shows \"(\\<exists>loc1 xs. impWitnessPath c loc1 loc2 xs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs. impWitnessPath c loc1 loc2 xs t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs. impWitnessPath c loc1 loc2 xs t", "have 1: \"path loc2 loc2 []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path loc2 loc2 []", "by (simp add: path0)"], ["proof (state)\nthis:\n  path loc2 loc2 []\n\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs. impWitnessPath c loc1 loc2 xs t", "have 2: \"distinct []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct []", "by auto"], ["proof (state)\nthis:\n  distinct []\n\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs. impWitnessPath c loc1 loc2 xs t", "have \"0 = sum_path_weights []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'sum) = sum_weights (map (\\<lambda>(s, l, t). l) [])", "using foldr_Nil list.map(1)"], ["proof (prove)\nusing this:\n  foldr ?f [] = id\n  map ?f [] = []\n\ngoal (1 subgoal):\n 1. (0::'sum) = sum_weights (map (\\<lambda>(s, l, t). l) [])", "by auto"], ["proof (state)\nthis:\n  (0::'sum) = sum_weights (map (\\<lambda>(s, l, t). l) [])\n\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs. impWitnessPath c loc1 loc2 xs t", "then"], ["proof (chain)\npicking this:\n  (0::'sum) = sum_weights (map (\\<lambda>(s, l, t). l) [])", "have 3: \"t = results_in t (sum_path_weights [])\""], ["proof (prove)\nusing this:\n  (0::'sum) = sum_weights (map (\\<lambda>(s, l, t). l) [])\n\ngoal (1 subgoal):\n 1. t = results_in t (sum_weights (map (\\<lambda>(s, l, t). l) []))", "by (simp add: results_in_zero)"], ["proof (state)\nthis:\n  t = results_in t (sum_weights (map (\\<lambda>(s, l, t). l) []))\n\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs. impWitnessPath c loc1 loc2 xs t", "with 1 2 assms"], ["proof (chain)\npicking this:\n  path loc2 loc2 []\n  distinct []\n  t \\<in>\\<^sub>A frontier (c_imp c loc2)\n  t = results_in t (sum_weights (map (\\<lambda>(s, l, t). l) []))", "show ?thesis"], ["proof (prove)\nusing this:\n  path loc2 loc2 []\n  distinct []\n  t \\<in>\\<^sub>A frontier (c_imp c loc2)\n  t = results_in t (sum_weights (map (\\<lambda>(s, l, t). l) []))\n\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs. impWitnessPath c loc1 loc2 xs t", "unfolding impWitnessPath_def"], ["proof (prove)\nusing this:\n  path loc2 loc2 []\n  distinct []\n  t \\<in>\\<^sub>A frontier (c_imp c loc2)\n  t = results_in t (sum_weights (map (\\<lambda>(s, l, t). l) []))\n\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs.\n       path loc1 loc2 xs \\<and>\n       distinct xs \\<and>\n       (\\<exists>t'.\n           t' \\<in>\\<^sub>A frontier (c_imp c loc1) \\<and>\n           t =\n           results_in t'\n            (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n           (\\<forall>k<length xs.\n               \\<exists>t.\n                  t \\<in>\\<^sub>A frontier\n                                   (c_imp c\n                                     (case xs ! k of\n(s, l, t) \\<Rightarrow> t)) \\<and>\n                  t =\n                  results_in t'\n                   (sum_weights\n                     (map (\\<lambda>(s, l, t). l) (take (k + 1) xs)))))", "by (force simp: results_in_zero)"], ["proof (state)\nthis:\n  \\<exists>loc1 xs. impWitnessPath c loc1 loc2 xs t\n\ngoal:\nNo subgoals!", "qed"], ["", "definition longestImpWitnessPath where\n  \"longestImpWitnessPath  c loc1 loc2 xs t = (\n  impWitnessPath c loc1 loc2 xs t \\<and>\n  (\\<forall>loc' xs'. impWitnessPath c loc' loc2 xs' t \\<longrightarrow> length (xs') \\<le> length (xs)))\""], ["", "lemma finite_edges: \"finite {(loc1,s,loc2). s \\<in>\\<^sub>A summary loc1 loc2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2}", "let ?sums = \"(\\<Union> ((\\<lambda>(loc1,loc2). set_antichain (summary loc1 loc2)) ` UNIV))\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2}", "have \"finite ?sums\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union>(loc1, loc2). set_antichain (summary loc1 loc2))", "by auto"], ["proof (state)\nthis:\n  finite (\\<Union>(loc1, loc2). set_antichain (summary loc1 loc2))\n\ngoal (1 subgoal):\n 1. finite {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2}", "then"], ["proof (chain)\npicking this:\n  finite (\\<Union>(loc1, loc2). set_antichain (summary loc1 loc2))", "have \"finite ((UNIV::'loc set) \\<times> ?sums \\<times> (UNIV::'loc set))\""], ["proof (prove)\nusing this:\n  finite (\\<Union>(loc1, loc2). set_antichain (summary loc1 loc2))\n\ngoal (1 subgoal):\n 1. finite\n     (UNIV \\<times>\n      (\\<Union>(loc1, loc2). set_antichain (summary loc1 loc2)) \\<times>\n      UNIV)", "by auto"], ["proof (state)\nthis:\n  finite\n   (UNIV \\<times>\n    (\\<Union>(loc1, loc2). set_antichain (summary loc1 loc2)) \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. finite {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2}", "moreover"], ["proof (state)\nthis:\n  finite\n   (UNIV \\<times>\n    (\\<Union>(loc1, loc2). set_antichain (summary loc1 loc2)) \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. finite {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2}", "have \"{(loc1,s,loc2). s \\<in>\\<^sub>A summary loc1 loc2} \\<subseteq> ((UNIV::'loc set) \\<times> ?sums \\<times> (UNIV::'loc set))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2}\n    \\<subseteq> UNIV \\<times>\n                (\\<Union>(loc1, loc2).\n                    set_antichain (summary loc1 loc2)) \\<times>\n                UNIV", "by (force simp: member_antichain.rep_eq)"], ["proof (state)\nthis:\n  {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2}\n  \\<subseteq> UNIV \\<times>\n              (\\<Union>(loc1, loc2).\n                  set_antichain (summary loc1 loc2)) \\<times>\n              UNIV\n\ngoal (1 subgoal):\n 1. finite {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2}", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   (UNIV \\<times>\n    (\\<Union>(loc1, loc2). set_antichain (summary loc1 loc2)) \\<times> UNIV)\n  {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2}\n  \\<subseteq> UNIV \\<times>\n              (\\<Union>(loc1, loc2).\n                  set_antichain (summary loc1 loc2)) \\<times>\n              UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   (UNIV \\<times>\n    (\\<Union>(loc1, loc2). set_antichain (summary loc1 loc2)) \\<times> UNIV)\n  {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2}\n  \\<subseteq> UNIV \\<times>\n              (\\<Union>(loc1, loc2).\n                  set_antichain (summary loc1 loc2)) \\<times>\n              UNIV\n\ngoal (1 subgoal):\n 1. finite {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2}", "by (rule rev_finite_subset)"], ["proof (state)\nthis:\n  finite {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma longestImpWitnessPathEx:\n  assumes \"t \\<in>\\<^sub>A frontier (c_imp c loc2)\"\n  shows \"(\\<exists>loc1 xs. longestImpWitnessPath c loc1 loc2 xs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs. longestImpWitnessPath c loc1 loc2 xs t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs. longestImpWitnessPath c loc1 loc2 xs t", "define paths where \"paths = {(loc1, xs). impWitnessPath c loc1 loc2 xs t}\""], ["proof (state)\nthis:\n  paths = {(loc1, xs). impWitnessPath c loc1 loc2 xs t}\n\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs. longestImpWitnessPath c loc1 loc2 xs t", "with impWitnessPathEx[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>loc1 xs. impWitnessPath c loc1 loc2 xs t\n  paths = {(loc1, xs). impWitnessPath c loc1 loc2 xs t}", "obtain p where \"p \\<in> paths\""], ["proof (prove)\nusing this:\n  \\<exists>loc1 xs. impWitnessPath c loc1 loc2 xs t\n  paths = {(loc1, xs). impWitnessPath c loc1 loc2 xs t}\n\ngoal (1 subgoal):\n 1. (\\<And>p. p \\<in> paths \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p \\<in> paths\n\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs. longestImpWitnessPath c loc1 loc2 xs t", "have \"\\<forall>p. p \\<in> paths \\<longrightarrow> (length \\<circ> snd) p  < card {(loc1,s,loc2). s \\<in>\\<^sub>A summary loc1 loc2} + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       p \\<in> paths \\<longrightarrow>\n       (length \\<circ> snd) p\n       < card {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2} + 1", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> paths \\<Longrightarrow>\n       (length \\<circ> snd) p\n       < card {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2} + 1", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> paths \\<Longrightarrow>\n       (length \\<circ> snd) p\n       < card {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2} + 1", "assume p:  \"p \\<in> paths\""], ["proof (state)\nthis:\n  p \\<in> paths\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> paths \\<Longrightarrow>\n       (length \\<circ> snd) p\n       < card {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2} + 1", "then"], ["proof (chain)\npicking this:\n  p \\<in> paths", "show \"(length \\<circ> snd) p < card {(loc1,s,loc2). s \\<in>\\<^sub>A summary loc1 loc2} + 1\""], ["proof (prove)\nusing this:\n  p \\<in> paths\n\ngoal (1 subgoal):\n 1. (length \\<circ> snd) p\n    < card {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2} + 1", "by (auto simp: paths_def impWitnessPath_def less_Suc_eq_le finite_edges path_edge\n          dest!: distinct_card[symmetric] intro!: card_mono)"], ["proof (state)\nthis:\n  (length \\<circ> snd) p\n  < card {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2} + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p.\n     p \\<in> paths \\<longrightarrow>\n     (length \\<circ> snd) p\n     < card {(loc1, s, loc2). s \\<in>\\<^sub>A summary loc1 loc2} + 1\n\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs. longestImpWitnessPath c loc1 loc2 xs t", "from ex_has_greatest_nat[OF \\<open>p \\<in> paths\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     x \\<in> paths \\<and>\n     (\\<forall>y.\n         y \\<in> paths \\<longrightarrow>\n         (length \\<circ> snd) y \\<le> (length \\<circ> snd) x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<in> paths \\<and>\n     (\\<forall>y.\n         y \\<in> paths \\<longrightarrow>\n         (length \\<circ> snd) y \\<le> (length \\<circ> snd) x)\n\ngoal (1 subgoal):\n 1. \\<exists>loc1 xs. longestImpWitnessPath c loc1 loc2 xs t", "by (auto simp: paths_def longestImpWitnessPath_def)"], ["proof (state)\nthis:\n  \\<exists>loc1 xs. longestImpWitnessPath c loc1 loc2 xs t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_first_loc: \"path l1 l2 xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> xs ! 0 = (l1',s,l2') \\<Longrightarrow> l1 = l1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs; xs \\<noteq> []; xs ! 0 = (l1', s, l2')\\<rbrakk>\n    \\<Longrightarrow> l1 = l1'", "proof (induct arbitrary: l1' s l2 rule: path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l1 l2 l1' s.\n       \\<lbrakk>l1 = l2; [] \\<noteq> []; [] ! 0 = (l1', s, l2')\\<rbrakk>\n       \\<Longrightarrow> l1 = l1'\n 2. \\<And>l1 l2 xs lbl l3 l1' s.\n       \\<lbrakk>path l1 l2 xs;\n        \\<And>l1' s.\n           \\<lbrakk>xs \\<noteq> []; xs ! 0 = (l1', s, l2')\\<rbrakk>\n           \\<Longrightarrow> l1 = l1';\n        lbl \\<in>\\<^sub>A summary l2 l3; xs @ [(l2, lbl, l3)] \\<noteq> [];\n        (xs @ [(l2, lbl, l3)]) ! 0 = (l1', s, l2')\\<rbrakk>\n       \\<Longrightarrow> l1 = l1'", "case (path0 l1 l2)"], ["proof (state)\nthis:\n  l1 = l2\n  [] \\<noteq> []\n  [] ! 0 = (l1', s, l2')\n\ngoal (2 subgoals):\n 1. \\<And>l1 l2 l1' s.\n       \\<lbrakk>l1 = l2; [] \\<noteq> []; [] ! 0 = (l1', s, l2')\\<rbrakk>\n       \\<Longrightarrow> l1 = l1'\n 2. \\<And>l1 l2 xs lbl l3 l1' s.\n       \\<lbrakk>path l1 l2 xs;\n        \\<And>l1' s.\n           \\<lbrakk>xs \\<noteq> []; xs ! 0 = (l1', s, l2')\\<rbrakk>\n           \\<Longrightarrow> l1 = l1';\n        lbl \\<in>\\<^sub>A summary l2 l3; xs @ [(l2, lbl, l3)] \\<noteq> [];\n        (xs @ [(l2, lbl, l3)]) ! 0 = (l1', s, l2')\\<rbrakk>\n       \\<Longrightarrow> l1 = l1'", "then"], ["proof (chain)\npicking this:\n  l1 = l2\n  [] \\<noteq> []\n  [] ! 0 = (l1', s, l2')", "show ?case"], ["proof (prove)\nusing this:\n  l1 = l2\n  [] \\<noteq> []\n  [] ! 0 = (l1', s, l2')\n\ngoal (1 subgoal):\n 1. l1 = l1'", "by auto"], ["proof (state)\nthis:\n  l1 = l1'\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3 l1' s.\n       \\<lbrakk>path l1 l2 xs;\n        \\<And>l1' s.\n           \\<lbrakk>xs \\<noteq> []; xs ! 0 = (l1', s, l2')\\<rbrakk>\n           \\<Longrightarrow> l1 = l1';\n        lbl \\<in>\\<^sub>A summary l2 l3; xs @ [(l2, lbl, l3)] \\<noteq> [];\n        (xs @ [(l2, lbl, l3)]) ! 0 = (l1', s, l2')\\<rbrakk>\n       \\<Longrightarrow> l1 = l1'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3 l1' s.\n       \\<lbrakk>path l1 l2 xs;\n        \\<And>l1' s.\n           \\<lbrakk>xs \\<noteq> []; xs ! 0 = (l1', s, l2')\\<rbrakk>\n           \\<Longrightarrow> l1 = l1';\n        lbl \\<in>\\<^sub>A summary l2 l3; xs @ [(l2, lbl, l3)] \\<noteq> [];\n        (xs @ [(l2, lbl, l3)]) ! 0 = (l1', s, l2')\\<rbrakk>\n       \\<Longrightarrow> l1 = l1'", "case (path l1 l2 xs lbl l3)"], ["proof (state)\nthis:\n  path l1 l2 xs\n  \\<lbrakk>xs \\<noteq> []; xs ! 0 = (?l1'3, ?s3, l2')\\<rbrakk>\n  \\<Longrightarrow> l1 = ?l1'3\n  lbl \\<in>\\<^sub>A summary l2 l3\n  xs @ [(l2, lbl, l3)] \\<noteq> []\n  (xs @ [(l2, lbl, l3)]) ! 0 = (l1', s, l2')\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3 l1' s.\n       \\<lbrakk>path l1 l2 xs;\n        \\<And>l1' s.\n           \\<lbrakk>xs \\<noteq> []; xs ! 0 = (l1', s, l2')\\<rbrakk>\n           \\<Longrightarrow> l1 = l1';\n        lbl \\<in>\\<^sub>A summary l2 l3; xs @ [(l2, lbl, l3)] \\<noteq> [];\n        (xs @ [(l2, lbl, l3)]) ! 0 = (l1', s, l2')\\<rbrakk>\n       \\<Longrightarrow> l1 = l1'", "then"], ["proof (chain)\npicking this:\n  path l1 l2 xs\n  \\<lbrakk>xs \\<noteq> []; xs ! 0 = (?l1'3, ?s3, l2')\\<rbrakk>\n  \\<Longrightarrow> l1 = ?l1'3\n  lbl \\<in>\\<^sub>A summary l2 l3\n  xs @ [(l2, lbl, l3)] \\<noteq> []\n  (xs @ [(l2, lbl, l3)]) ! 0 = (l1', s, l2')", "show ?case"], ["proof (prove)\nusing this:\n  path l1 l2 xs\n  \\<lbrakk>xs \\<noteq> []; xs ! 0 = (?l1'3, ?s3, l2')\\<rbrakk>\n  \\<Longrightarrow> l1 = ?l1'3\n  lbl \\<in>\\<^sub>A summary l2 l3\n  xs @ [(l2, lbl, l3)] \\<noteq> []\n  (xs @ [(l2, lbl, l3)]) ! 0 = (l1', s, l2')\n\ngoal (1 subgoal):\n 1. l1 = l1'", "apply (cases \"xs=[]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>path l1 l2 xs;\n     \\<And>l1' s.\n        \\<lbrakk>xs \\<noteq> []; xs ! 0 = (l1', s, l2')\\<rbrakk>\n        \\<Longrightarrow> l1 = l1';\n     lbl \\<in>\\<^sub>A summary l2 l3; xs @ [(l2, lbl, l3)] \\<noteq> [];\n     (xs @ [(l2, lbl, l3)]) ! 0 = (l1', s, l2'); xs = []\\<rbrakk>\n    \\<Longrightarrow> l1 = l1'\n 2. \\<lbrakk>path l1 l2 xs;\n     \\<And>l1' s.\n        \\<lbrakk>xs \\<noteq> []; xs ! 0 = (l1', s, l2')\\<rbrakk>\n        \\<Longrightarrow> l1 = l1';\n     lbl \\<in>\\<^sub>A summary l2 l3; xs @ [(l2, lbl, l3)] \\<noteq> [];\n     (xs @ [(l2, lbl, l3)]) ! 0 = (l1', s, l2'); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> l1 = l1'", "apply (auto elim: path0E) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path l1 l2 xs;\n     \\<And>l1' s.\n        \\<lbrakk>xs \\<noteq> []; xs ! 0 = (l1', s, l2')\\<rbrakk>\n        \\<Longrightarrow> l1 = l1';\n     lbl \\<in>\\<^sub>A summary l2 l3; xs @ [(l2, lbl, l3)] \\<noteq> [];\n     (xs @ [(l2, lbl, l3)]) ! 0 = (l1', s, l2'); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> l1 = l1'", "apply (rule path(2)[of l1' s])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>path l1 l2 xs;\n     \\<And>l1' s.\n        \\<lbrakk>xs \\<noteq> []; xs ! 0 = (l1', s, l2')\\<rbrakk>\n        \\<Longrightarrow> l1 = l1';\n     lbl \\<in>\\<^sub>A summary l2 l3; xs @ [(l2, lbl, l3)] \\<noteq> [];\n     (xs @ [(l2, lbl, l3)]) ! 0 = (l1', s, l2'); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs \\<noteq> []\n 2. \\<lbrakk>path l1 l2 xs;\n     \\<And>l1' s.\n        \\<lbrakk>xs \\<noteq> []; xs ! 0 = (l1', s, l2')\\<rbrakk>\n        \\<Longrightarrow> l1 = l1';\n     lbl \\<in>\\<^sub>A summary l2 l3; xs @ [(l2, lbl, l3)] \\<noteq> [];\n     (xs @ [(l2, lbl, l3)]) ! 0 = (l1', s, l2'); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs ! 0 = (l1', s, l2')", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  l1 = l1'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_witness_from_frontier:\n  assumes \"t \\<in>\\<^sub>A frontier (c_imp c loc2)\"\n    and \"inv_imps_work_sum c\"\n  shows \"\\<exists>t' loc1 xs. (path loc1 loc2 xs \\<and> t =  results_in t' (sum_path_weights xs) \\<and>\n           (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or> 0 > zcount (c_work c loc1) t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "obtain loc1 xs where longestP: \"longestImpWitnessPath c loc1 loc2 xs t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>loc1 xs.\n        longestImpWitnessPath c loc1 loc2 xs t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(1) longestImpWitnessPathEx"], ["proof (prove)\nusing this:\n  t \\<in>\\<^sub>A frontier (c_imp c loc2)\n  ?t \\<in>\\<^sub>A frontier (c_imp ?c ?loc2.0) \\<Longrightarrow>\n  \\<exists>loc1 xs. longestImpWitnessPath ?c loc1 ?loc2.0 xs ?t\n\ngoal (1 subgoal):\n 1. (\\<And>loc1 xs.\n        longestImpWitnessPath c loc1 loc2 xs t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  longestImpWitnessPath c loc1 loc2 xs t\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "then"], ["proof (chain)\npicking this:\n  longestImpWitnessPath c loc1 loc2 xs t", "obtain t' where t': \"t' \\<in>\\<^sub>A frontier (c_imp c loc1)\" \"t = results_in t' (sum_path_weights xs)\"\n    \"(\\<forall>k<length xs. (\\<exists>t. t \\<in>\\<^sub>A frontier (c_imp c (TO (xs ! k))) \\<and> t = results_in t' (sum_path_weights (take (k+1) xs))))\""], ["proof (prove)\nusing this:\n  longestImpWitnessPath c loc1 loc2 xs t\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in>\\<^sub>A frontier (c_imp c loc1);\n         t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs));\n         \\<forall>k<length xs.\n            \\<exists>t.\n               t \\<in>\\<^sub>A frontier\n                                (c_imp c\n                                  (case xs ! k of\n                                   (s, l, t) \\<Rightarrow> t)) \\<and>\n               t =\n               results_in t'\n                (sum_weights\n                  (map (\\<lambda>(s, l, t). l) (take (k + 1) xs)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: longestImpWitnessPath_def impWitnessPath_def)"], ["proof (state)\nthis:\n  t' \\<in>\\<^sub>A frontier (c_imp c loc1)\n  t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  \\<forall>k<length xs.\n     \\<exists>t.\n        t \\<in>\\<^sub>A frontier\n                         (c_imp c\n                           (case xs ! k of\n                            (s, l, t) \\<Rightarrow> t)) \\<and>\n        t =\n        results_in t'\n         (sum_weights (map (\\<lambda>(s, l, t). l) (take (k + 1) xs)))\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "from t'(1)"], ["proof (chain)\npicking this:\n  t' \\<in>\\<^sub>A frontier (c_imp c loc1)", "have cases: \"0 > zcount (c_work c loc1) t' \\<or>\n             (t' \\<in>#\\<^sub>z (zmset_frontier (c_pts c loc1) + union_frontiers c loc1))\""], ["proof (prove)\nusing this:\n  t' \\<in>\\<^sub>A frontier (c_imp c loc1)\n\ngoal (1 subgoal):\n 1. zcount (c_work c loc1) t' < 0 \\<or>\n    t' \\<in>#\\<^sub>z zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c loc1)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c loc')))))\n                          (summary loc' loc1))", "using assms(2)"], ["proof (prove)\nusing this:\n  t' \\<in>\\<^sub>A frontier (c_imp c loc1)\n  inv_imps_work_sum c\n\ngoal (1 subgoal):\n 1. zcount (c_work c loc1) t' < 0 \\<or>\n    t' \\<in>#\\<^sub>z zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c loc1)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c loc')))))\n                          (summary loc' loc1))", "apply (clarsimp intro!: verit_forall_inst(6) simp: inv_imps_work_sum_def not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in>\\<^sub>A frontier (c_imp c loc1);\n     \\<forall>loc.\n        c_imp c loc + c_work c loc =\n        zmset_of (mset_set (set_antichain (frontier (c_pts c loc)))) +\n        (\\<Sum>loc'\\<in>UNIV.\n           after_summary\n            (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n            (summary loc' loc));\n     0 \\<le> zcount (c_work c loc1) t'\\<rbrakk>\n    \\<Longrightarrow> t' \\<in>#\\<^sub>z zmset_of\n   (mset_set (set_antichain (frontier (c_pts c loc1)))) +\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n      (summary loc' loc1))", "apply (metis add_pos_nonneg mem_zmset_frontier member_frontier_pos_zmset obtain_frontier_elem zcount_empty zcount_ne_zero_iff zcount_union zmset_frontier_empty)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  zcount (c_work c loc1) t' < 0 \\<or>\n  t' \\<in>#\\<^sub>z zmset_of\n                     (mset_set (set_antichain (frontier (c_pts c loc1)))) +\n                    (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "then"], ["proof (chain)\npicking this:\n  zcount (c_work c loc1) t' < 0 \\<or>\n  t' \\<in>#\\<^sub>z zmset_of\n                     (mset_set (set_antichain (frontier (c_pts c loc1)))) +\n                    (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))", "show ?thesis"], ["proof (prove)\nusing this:\n  zcount (c_work c loc1) t' < 0 \\<or>\n  t' \\<in>#\\<^sub>z zmset_of\n                     (mset_set (set_antichain (frontier (c_pts c loc1)))) +\n                    (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>zcount (c_work c loc1) t' < 0 \\<or>\n             t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) +\n                               (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)\n 2. \\<lbrakk>zcount (c_work c loc1) t' < 0 \\<or>\n             t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) +\n                               (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "assume case1: \"0 > zcount (c_work c loc1) t'\""], ["proof (state)\nthis:\n  zcount (c_work c loc1) t' < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>zcount (c_work c loc1) t' < 0 \\<or>\n             t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) +\n                               (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)\n 2. \\<lbrakk>zcount (c_work c loc1) t' < 0 \\<or>\n             t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) +\n                               (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "then"], ["proof (chain)\npicking this:\n  zcount (c_work c loc1) t' < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  zcount (c_work c loc1) t' < 0\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "using t' longestP"], ["proof (prove)\nusing this:\n  zcount (c_work c loc1) t' < 0\n  t' \\<in>\\<^sub>A frontier (c_imp c loc1)\n  t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  \\<forall>k<length xs.\n     \\<exists>t.\n        t \\<in>\\<^sub>A frontier\n                         (c_imp c\n                           (case xs ! k of\n                            (s, l, t) \\<Rightarrow> t)) \\<and>\n        t =\n        results_in t'\n         (sum_weights (map (\\<lambda>(s, l, t). l) (take (k + 1) xs)))\n  longestImpWitnessPath c loc1 loc2 xs t\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "using impWitnessPath_def longestImpWitnessPath_def dataflow_topology_axioms"], ["proof (prove)\nusing this:\n  zcount (c_work c loc1) t' < 0\n  t' \\<in>\\<^sub>A frontier (c_imp c loc1)\n  t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  \\<forall>k<length xs.\n     \\<exists>t.\n        t \\<in>\\<^sub>A frontier\n                         (c_imp c\n                           (case xs ! k of\n                            (s, l, t) \\<Rightarrow> t)) \\<and>\n        t =\n        results_in t'\n         (sum_weights (map (\\<lambda>(s, l, t). l) (take (k + 1) xs)))\n  longestImpWitnessPath c loc1 loc2 xs t\n  impWitnessPath ?c ?loc1.0 ?loc2.0 ?xs ?t =\n  (path ?loc1.0 ?loc2.0 ?xs \\<and>\n   distinct ?xs \\<and>\n   (\\<exists>t'.\n       t' \\<in>\\<^sub>A frontier (c_imp ?c ?loc1.0) \\<and>\n       ?t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) ?xs)) \\<and>\n       (\\<forall>k<length ?xs.\n           \\<exists>t.\n              t \\<in>\\<^sub>A frontier\n                               (c_imp ?c\n                                 (case ?xs ! k of\n                                  (s, l, t) \\<Rightarrow> t)) \\<and>\n              t =\n              results_in t'\n               (sum_weights\n                 (map (\\<lambda>(s, l, t). l) (take (k + 1) ?xs))))))\n  longestImpWitnessPath ?c ?loc1.0 ?loc2.0 ?xs ?t =\n  (impWitnessPath ?c ?loc1.0 ?loc2.0 ?xs ?t \\<and>\n   (\\<forall>loc' xs'.\n       impWitnessPath ?c loc' ?loc2.0 xs' ?t \\<longrightarrow>\n       length xs' \\<le> length ?xs))\n  dataflow_topology summary results_in\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "by blast"], ["proof (state)\nthis:\n  \\<exists>t' loc1 xs.\n     path loc1 loc2 xs \\<and>\n     t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n     (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n      zcount (c_work c loc1) t' < 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>zcount (c_work c loc1) t' < 0 \\<or>\n             t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) +\n                               (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     \\<not> zcount (c_work c loc1) t' < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>zcount (c_work c loc1) t' < 0 \\<or>\n             t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) +\n                               (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     \\<not> zcount (c_work c loc1) t' < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "assume case2: \"\\<not>0 > zcount (c_work c loc1) t'\""], ["proof (state)\nthis:\n  \\<not> zcount (c_work c loc1) t' < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>zcount (c_work c loc1) t' < 0 \\<or>\n             t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) +\n                               (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     \\<not> zcount (c_work c loc1) t' < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "have \"(t' \\<in>#\\<^sub>z (zmset_frontier (c_pts c loc1) + union_frontiers c loc1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<in>#\\<^sub>z zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c loc1)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c loc')))))\n                          (summary loc' loc1))", "using case2 cases"], ["proof (prove)\nusing this:\n  \\<not> zcount (c_work c loc1) t' < 0\n  zcount (c_work c loc1) t' < 0 \\<or>\n  t' \\<in>#\\<^sub>z zmset_of\n                     (mset_set (set_antichain (frontier (c_pts c loc1)))) +\n                    (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))\n\ngoal (1 subgoal):\n 1. t' \\<in>#\\<^sub>z zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c loc1)))) +\n                      (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c loc')))))\n                          (summary loc' loc1))", "by auto"], ["proof (state)\nthis:\n  t' \\<in>#\\<^sub>z zmset_of\n                     (mset_set (set_antichain (frontier (c_pts c loc1)))) +\n                    (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>zcount (c_work c loc1) t' < 0 \\<or>\n             t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) +\n                               (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     \\<not> zcount (c_work c loc1) t' < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "then"], ["proof (chain)\npicking this:\n  t' \\<in>#\\<^sub>z zmset_of\n                     (mset_set (set_antichain (frontier (c_pts c loc1)))) +\n                    (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))", "have case_split2: \"(t' \\<in>#\\<^sub>z zmset_frontier (c_pts c loc1)) \\<or> (t' \\<in>#\\<^sub>z union_frontiers c loc1)\""], ["proof (prove)\nusing this:\n  t' \\<in>#\\<^sub>z zmset_of\n                     (mset_set (set_antichain (frontier (c_pts c loc1)))) +\n                    (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))\n\ngoal (1 subgoal):\n 1. t' \\<in>#\\<^sub>z zmset_of\n                       (mset_set\n                         (set_antichain (frontier (c_pts c loc1)))) \\<or>\n    t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c loc')))))\n                          (summary loc' loc1))", "by (metis (no_types, lifting) add_diff_cancel_left' in_diff_zcount zcount_ne_zero_iff)"], ["proof (state)\nthis:\n  t' \\<in>#\\<^sub>z zmset_of\n                     (mset_set\n                       (set_antichain (frontier (c_pts c loc1)))) \\<or>\n  t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>zcount (c_work c loc1) t' < 0 \\<or>\n             t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) +\n                               (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     \\<not> zcount (c_work c loc1) t' < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "then"], ["proof (chain)\npicking this:\n  t' \\<in>#\\<^sub>z zmset_of\n                     (mset_set\n                       (set_antichain (frontier (c_pts c loc1)))) \\<or>\n  t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))", "show ?thesis"], ["proof (prove)\nusing this:\n  t' \\<in>#\\<^sub>z zmset_of\n                     (mset_set\n                       (set_antichain (frontier (c_pts c loc1)))) \\<or>\n  t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)\n 2. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "assume case2_1: \"t' \\<in>#\\<^sub>z zmset_frontier (c_pts c loc1)\""], ["proof (state)\nthis:\n  t' \\<in>#\\<^sub>z zmset_of\n                     (mset_set (set_antichain (frontier (c_pts c loc1))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)\n 2. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "have \"t' \\<in>\\<^sub>A frontier (c_pts c loc1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<in>\\<^sub>A frontier (c_pts c loc1)", "using case2_1 mem_zmset_frontier"], ["proof (prove)\nusing this:\n  t' \\<in>#\\<^sub>z zmset_of\n                     (mset_set (set_antichain (frontier (c_pts c loc1))))\n  (?x \\<in>#\\<^sub>z zmset_of (mset_set (set_antichain (frontier ?M)))) =\n  (?x \\<in>\\<^sub>A frontier ?M)\n\ngoal (1 subgoal):\n 1. t' \\<in>\\<^sub>A frontier (c_pts c loc1)", "by blast"], ["proof (state)\nthis:\n  t' \\<in>\\<^sub>A frontier (c_pts c loc1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)\n 2. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "then"], ["proof (chain)\npicking this:\n  t' \\<in>\\<^sub>A frontier (c_pts c loc1)", "show ?thesis"], ["proof (prove)\nusing this:\n  t' \\<in>\\<^sub>A frontier (c_pts c loc1)\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "using t' impWitnessPath_def longestImpWitnessPath_def dataflow_topology_axioms longestP"], ["proof (prove)\nusing this:\n  t' \\<in>\\<^sub>A frontier (c_pts c loc1)\n  t' \\<in>\\<^sub>A frontier (c_imp c loc1)\n  t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  \\<forall>k<length xs.\n     \\<exists>t.\n        t \\<in>\\<^sub>A frontier\n                         (c_imp c\n                           (case xs ! k of\n                            (s, l, t) \\<Rightarrow> t)) \\<and>\n        t =\n        results_in t'\n         (sum_weights (map (\\<lambda>(s, l, t). l) (take (k + 1) xs)))\n  impWitnessPath ?c ?loc1.0 ?loc2.0 ?xs ?t =\n  (path ?loc1.0 ?loc2.0 ?xs \\<and>\n   distinct ?xs \\<and>\n   (\\<exists>t'.\n       t' \\<in>\\<^sub>A frontier (c_imp ?c ?loc1.0) \\<and>\n       ?t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) ?xs)) \\<and>\n       (\\<forall>k<length ?xs.\n           \\<exists>t.\n              t \\<in>\\<^sub>A frontier\n                               (c_imp ?c\n                                 (case ?xs ! k of\n                                  (s, l, t) \\<Rightarrow> t)) \\<and>\n              t =\n              results_in t'\n               (sum_weights\n                 (map (\\<lambda>(s, l, t). l) (take (k + 1) ?xs))))))\n  longestImpWitnessPath ?c ?loc1.0 ?loc2.0 ?xs ?t =\n  (impWitnessPath ?c ?loc1.0 ?loc2.0 ?xs ?t \\<and>\n   (\\<forall>loc' xs'.\n       impWitnessPath ?c loc' ?loc2.0 xs' ?t \\<longrightarrow>\n       length xs' \\<le> length ?xs))\n  dataflow_topology summary results_in\n  longestImpWitnessPath c loc1 loc2 xs t\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "by blast"], ["proof (state)\nthis:\n  \\<exists>t' loc1 xs.\n     path loc1 loc2 xs \\<and>\n     t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n     (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n      zcount (c_work c loc1) t' < 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     t' \\<notin>#\\<^sub>z zmset_of\n                           (mset_set\n                             (set_antichain\n                               (frontier (c_pts c loc1))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     t' \\<notin>#\\<^sub>z zmset_of\n                           (mset_set\n                             (set_antichain\n                               (frontier (c_pts c loc1))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "assume \"\\<not>t' \\<in>#\\<^sub>z zmset_frontier (c_pts c loc1)\""], ["proof (state)\nthis:\n  t' \\<notin>#\\<^sub>z zmset_of\n                        (mset_set (set_antichain (frontier (c_pts c loc1))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     t' \\<notin>#\\<^sub>z zmset_of\n                           (mset_set\n                             (set_antichain\n                               (frontier (c_pts c loc1))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "then"], ["proof (chain)\npicking this:\n  t' \\<notin>#\\<^sub>z zmset_of\n                        (mset_set (set_antichain (frontier (c_pts c loc1))))", "have case2_2: \"t' \\<in>#\\<^sub>z  union_frontiers c loc1\""], ["proof (prove)\nusing this:\n  t' \\<notin>#\\<^sub>z zmset_of\n                        (mset_set (set_antichain (frontier (c_pts c loc1))))\n\ngoal (1 subgoal):\n 1. t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c loc')))))\n                          (summary loc' loc1))", "using case_split2"], ["proof (prove)\nusing this:\n  t' \\<notin>#\\<^sub>z zmset_of\n                        (mset_set (set_antichain (frontier (c_pts c loc1))))\n  t' \\<in>#\\<^sub>z zmset_of\n                     (mset_set\n                       (set_antichain (frontier (c_pts c loc1)))) \\<or>\n  t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))\n\ngoal (1 subgoal):\n 1. t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                         after_summary\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_imp c loc')))))\n                          (summary loc' loc1))", "by blast"], ["proof (state)\nthis:\n  t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     t' \\<notin>#\\<^sub>z zmset_of\n                           (mset_set\n                             (set_antichain\n                               (frontier (c_pts c loc1))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "then"], ["proof (chain)\npicking this:\n  t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))", "obtain loc0 t0 s0 where loc0 : \"t0 \\<in>\\<^sub>A frontier (c_imp c loc0)\"\n        \"s0 \\<in>\\<^sub>A (summary loc0 loc1)\"\n        \"t' = results_in t0 s0\""], ["proof (prove)\nusing this:\n  t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                       after_summary\n                        (zmset_of\n                          (mset_set\n                            (set_antichain (frontier (c_imp c loc')))))\n                        (summary loc' loc1))\n\ngoal (1 subgoal):\n 1. (\\<And>t0 loc0 s0.\n        \\<lbrakk>t0 \\<in>\\<^sub>A frontier (c_imp c loc0);\n         s0 \\<in>\\<^sub>A summary loc0 loc1; t' = results_in t0 s0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: after_summary_def set_zmset_def zcount_sum\n            member_antichain.rep_eq[symmetric] zcount_image_zmset card_gt_0_iff\n            simp del: zcount_ne_zero_iff\n            elim!: sum.not_neutral_contains_not_neutral)"], ["proof (state)\nthis:\n  t0 \\<in>\\<^sub>A frontier (c_imp c loc0)\n  s0 \\<in>\\<^sub>A summary loc0 loc1\n  t' = results_in t0 s0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     t' \\<notin>#\\<^sub>z zmset_of\n                           (mset_set\n                             (set_antichain\n                               (frontier (c_pts c loc1))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "let ?xs' = \"(loc0, s0, loc1) # xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     t' \\<notin>#\\<^sub>z zmset_of\n                           (mset_set\n                             (set_antichain\n                               (frontier (c_pts c loc1))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "have path_xs: \"path loc1 loc2 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path loc1 loc2 xs", "using impWitnessPath_def longestImpWitnessPath_def longestP"], ["proof (prove)\nusing this:\n  impWitnessPath ?c ?loc1.0 ?loc2.0 ?xs ?t =\n  (path ?loc1.0 ?loc2.0 ?xs \\<and>\n   distinct ?xs \\<and>\n   (\\<exists>t'.\n       t' \\<in>\\<^sub>A frontier (c_imp ?c ?loc1.0) \\<and>\n       ?t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) ?xs)) \\<and>\n       (\\<forall>k<length ?xs.\n           \\<exists>t.\n              t \\<in>\\<^sub>A frontier\n                               (c_imp ?c\n                                 (case ?xs ! k of\n                                  (s, l, t) \\<Rightarrow> t)) \\<and>\n              t =\n              results_in t'\n               (sum_weights\n                 (map (\\<lambda>(s, l, t). l) (take (k + 1) ?xs))))))\n  longestImpWitnessPath ?c ?loc1.0 ?loc2.0 ?xs ?t =\n  (impWitnessPath ?c ?loc1.0 ?loc2.0 ?xs ?t \\<and>\n   (\\<forall>loc' xs'.\n       impWitnessPath ?c loc' ?loc2.0 xs' ?t \\<longrightarrow>\n       length xs' \\<le> length ?xs))\n  longestImpWitnessPath c loc1 loc2 xs t\n\ngoal (1 subgoal):\n 1. path loc1 loc2 xs", "by blast"], ["proof (state)\nthis:\n  path loc1 loc2 xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     t' \\<notin>#\\<^sub>z zmset_of\n                           (mset_set\n                             (set_antichain\n                               (frontier (c_pts c loc1))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "have is_path_xs': \"path loc0 loc2 ?xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path loc0 loc2 ((loc0, s0, loc1) # xs)", "using longestP"], ["proof (prove)\nusing this:\n  longestImpWitnessPath c loc1 loc2 xs t\n\ngoal (1 subgoal):\n 1. path loc0 loc2 ((loc0, s0, loc1) # xs)", "apply (simp add: longestImpWitnessPath_def impWitnessPath_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. path loc1 loc2 xs \\<and>\n    distinct xs \\<and>\n    (\\<exists>t'.\n        t' \\<in>\\<^sub>A frontier (c_imp c loc1) \\<and>\n        t =\n        results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n        (\\<forall>k<length xs.\n            results_in t'\n             (sum_weights (map (\\<lambda>(s, l, t). l) (take (Suc k) xs)))\n            \\<in>\\<^sub>A frontier\n                           (c_imp c\n                             (case xs ! k of\n                              (s, l, t) \\<Rightarrow> t)))) \\<and>\n    (\\<forall>loc' xs'.\n        path loc' loc2 xs' \\<and>\n        distinct xs' \\<and>\n        (\\<exists>t'.\n            t' \\<in>\\<^sub>A frontier (c_imp c loc') \\<and>\n            t =\n            results_in t'\n             (sum_weights (map (\\<lambda>(s, l, t). l) xs')) \\<and>\n            (\\<forall>k<length xs'.\n                results_in t'\n                 (sum_weights\n                   (map (\\<lambda>(s, l, t). l) (take (Suc k) xs')))\n                \\<in>\\<^sub>A frontier\n                               (c_imp c\n                                 (case xs' ! k of\n                                  (s, l, t) \\<Rightarrow>\n                                    t)))) \\<longrightarrow>\n        length xs' \\<le> length xs) \\<Longrightarrow>\n    path loc0 loc2 ((loc0, s0, loc1) # xs)", "by (metis append_Cons append_Nil path_singleton path_trans loc0(2))"], ["proof (state)\nthis:\n  path loc0 loc2 ((loc0, s0, loc1) # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     t' \\<notin>#\\<^sub>z zmset_of\n                           (mset_set\n                             (set_antichain\n                               (frontier (c_pts c loc1))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "have \"\\<forall>k<length ?xs'.\n              results_in t0 (sum_path_weights (take (k+1) ?xs'))\n              \\<in>\\<^sub>A frontier (c_imp c (TO (?xs' ! k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<length ((loc0, s0, loc1) # xs).\n       results_in t0\n        (sum_weights\n          (map (\\<lambda>(s, l, t). l)\n            (take (k + 1) ((loc0, s0, loc1) # xs))))\n       \\<in>\\<^sub>A frontier\n                      (c_imp c\n                        (case ((loc0, s0, loc1) # xs) ! k of\n                         (s, l, t) \\<Rightarrow> t))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length ((loc0, s0, loc1) # xs) \\<Longrightarrow>\n       results_in t0\n        (sum_weights\n          (map (\\<lambda>(s, l, t). l)\n            (take (k + 1) ((loc0, s0, loc1) # xs))))\n       \\<in>\\<^sub>A frontier\n                      (c_imp c\n                        (case ((loc0, s0, loc1) # xs) ! k of\n                         (s, l, t) \\<Rightarrow> t))", "subgoal for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length ((loc0, s0, loc1) # xs) \\<Longrightarrow>\n    results_in t0\n     (sum_weights\n       (map (\\<lambda>(s, l, t). l) (take (k + 1) ((loc0, s0, loc1) # xs))))\n    \\<in>\\<^sub>A frontier\n                   (c_imp c\n                     (case ((loc0, s0, loc1) # xs) ! k of\n                      (s, l, t) \\<Rightarrow> t))", "apply (cases \"k=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length ((loc0, s0, loc1) # xs); k = 0\\<rbrakk>\n    \\<Longrightarrow> results_in t0\n                       (sum_weights\n                         (map (\\<lambda>(s, l, t). l)\n                           (take (k + 1) ((loc0, s0, loc1) # xs))))\n                      \\<in>\\<^sub>A frontier\n                                     (c_imp c\n (case ((loc0, s0, loc1) # xs) ! k of (s, l, t) \\<Rightarrow> t))\n 2. \\<lbrakk>k < length ((loc0, s0, loc1) # xs); k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> results_in t0\n                       (sum_weights\n                         (map (\\<lambda>(s, l, t). l)\n                           (take (k + 1) ((loc0, s0, loc1) # xs))))\n                      \\<in>\\<^sub>A frontier\n                                     (c_imp c\n (case ((loc0, s0, loc1) # xs) ! k of (s, l, t) \\<Rightarrow> t))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length ((loc0, s0, loc1) # xs); k = 0\\<rbrakk>\n    \\<Longrightarrow> results_in t0\n                       (sum_weights\n                         (map (\\<lambda>(s, l, t). l)\n                           (take (k + 1) ((loc0, s0, loc1) # xs))))\n                      \\<in>\\<^sub>A frontier\n                                     (c_imp c\n (case ((loc0, s0, loc1) # xs) ! k of (s, l, t) \\<Rightarrow> t))", "using loc0(3) t'(1)"], ["proof (prove)\nusing this:\n  t' = results_in t0 s0\n  t' \\<in>\\<^sub>A frontier (c_imp c loc1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length ((loc0, s0, loc1) # xs); k = 0\\<rbrakk>\n    \\<Longrightarrow> results_in t0\n                       (sum_weights\n                         (map (\\<lambda>(s, l, t). l)\n                           (take (k + 1) ((loc0, s0, loc1) # xs))))\n                      \\<in>\\<^sub>A frontier\n                                     (c_imp c\n (case ((loc0, s0, loc1) # xs) ! k of (s, l, t) \\<Rightarrow> t))", "by (auto simp: results_in_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length ((loc0, s0, loc1) # xs); k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> results_in t0\n                       (sum_weights\n                         (map (\\<lambda>(s, l, t). l)\n                           (take (k + 1) ((loc0, s0, loc1) # xs))))\n                      \\<in>\\<^sub>A frontier\n                                     (c_imp c\n (case ((loc0, s0, loc1) # xs) ! k of (s, l, t) \\<Rightarrow> t))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length ((loc0, s0, loc1) # xs); k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> results_in t0\n                       (sum_weights\n                         (map (\\<lambda>(s, l, t). l)\n                           (take (k + 1) ((loc0, s0, loc1) # xs))))\n                      \\<in>\\<^sub>A frontier\n                                     (c_imp c\n (case ((loc0, s0, loc1) # xs) ! k of (s, l, t) \\<Rightarrow> t))", "using t'(3)[rule_format, unfolded loc0(3) followed_by_summary, of \"k-1\", simplified]"], ["proof (prove)\nusing this:\n  k - Suc 0 < length xs \\<Longrightarrow>\n  results_in t0\n   (followed_by s0\n     (sum_weights\n       (map (\\<lambda>(s, l, t). l) (take (Suc (k - Suc 0)) xs))))\n  \\<in>\\<^sub>A frontier\n                 (c_imp c\n                   (case xs ! (k - Suc 0) of (s, l, t) \\<Rightarrow> t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length ((loc0, s0, loc1) # xs); k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> results_in t0\n                       (sum_weights\n                         (map (\\<lambda>(s, l, t). l)\n                           (take (k + 1) ((loc0, s0, loc1) # xs))))\n                      \\<in>\\<^sub>A frontier\n                                     (c_imp c\n (case ((loc0, s0, loc1) # xs) ! k of (s, l, t) \\<Rightarrow> t))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>k<length ((loc0, s0, loc1) # xs).\n     results_in t0\n      (sum_weights\n        (map (\\<lambda>(s, l, t). l)\n          (take (k + 1) ((loc0, s0, loc1) # xs))))\n     \\<in>\\<^sub>A frontier\n                    (c_imp c\n                      (case ((loc0, s0, loc1) # xs) ! k of\n                       (s, l, t) \\<Rightarrow> t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     t' \\<notin>#\\<^sub>z zmset_of\n                           (mset_set\n                             (set_antichain\n                               (frontier (c_pts c loc1))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "note r = this[rule_format]"], ["proof (state)\nthis:\n  ?k < length ((loc0, s0, loc1) # xs) \\<Longrightarrow>\n  results_in t0\n   (sum_weights\n     (map (\\<lambda>(s, l, t). l) (take (?k + 1) ((loc0, s0, loc1) # xs))))\n  \\<in>\\<^sub>A frontier\n                 (c_imp c\n                   (case ((loc0, s0, loc1) # xs) ! ?k of\n                    (s, l, t) \\<Rightarrow> t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     t' \\<notin>#\\<^sub>z zmset_of\n                           (mset_set\n                             (set_antichain\n                               (frontier (c_pts c loc1))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "have distinctxs: \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs", "using longestP"], ["proof (prove)\nusing this:\n  longestImpWitnessPath c loc1 loc2 xs t\n\ngoal (1 subgoal):\n 1. distinct xs", "by (simp add: longestImpWitnessPath_def impWitnessPath_def)"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1)))) \\<or>\n             t' \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                                  after_summary\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_imp c loc')))))\n                                   (summary loc' loc1));\n     t' \\<notin>#\\<^sub>z zmset_of\n                           (mset_set\n                             (set_antichain\n                               (frontier (c_pts c loc1))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "then"], ["proof (chain)\npicking this:\n  distinct xs", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)\n 2. \\<lbrakk>distinct xs; \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "assume case_distinct: \"distinct ?xs'\""], ["proof (state)\nthis:\n  distinct ((loc0, s0, loc1) # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)\n 2. \\<lbrakk>distinct xs; \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "(* show that we have a longer longestImpWitnessPathEx \\<longrightarrow> contradicition *)"], ["proof (state)\nthis:\n  distinct ((loc0, s0, loc1) # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)\n 2. \\<lbrakk>distinct xs; \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "have \"t = results_in t0 (sum_path_weights ?xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t =\n    results_in t0\n     (sum_weights (map (\\<lambda>(s, l, t). l) ((loc0, s0, loc1) # xs)))", "using longestP loc0(3)"], ["proof (prove)\nusing this:\n  longestImpWitnessPath c loc1 loc2 xs t\n  t' = results_in t0 s0\n\ngoal (1 subgoal):\n 1. t =\n    results_in t0\n     (sum_weights (map (\\<lambda>(s, l, t). l) ((loc0, s0, loc1) # xs)))", "apply (simp add: longestImpWitnessPath_def impWitnessPath_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path loc1 loc2 xs \\<and>\n             distinct xs \\<and>\n             (\\<exists>t'.\n                 t' \\<in>\\<^sub>A frontier (c_imp c loc1) \\<and>\n                 t =\n                 results_in t'\n                  (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                 (\\<forall>k<length xs.\n                     results_in t'\n                      (sum_weights\n                        (map (\\<lambda>(s, l, t). l) (take (Suc k) xs)))\n                     \\<in>\\<^sub>A frontier\n                                    (c_imp c\n(case xs ! k of (s, l, t) \\<Rightarrow> t)))) \\<and>\n             (\\<forall>loc' xs'.\n                 path loc' loc2 xs' \\<and>\n                 distinct xs' \\<and>\n                 (\\<exists>t'.\n                     t' \\<in>\\<^sub>A frontier (c_imp c loc') \\<and>\n                     t =\n                     results_in t'\n                      (sum_weights (map (\\<lambda>(s, l, t). l) xs')) \\<and>\n                     (\\<forall>k<length xs'.\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l)\n                              (take (Suc k) xs')))\n                         \\<in>\\<^sub>A frontier\n  (c_imp c (case xs' ! k of (s, l, t) \\<Rightarrow> t)))) \\<longrightarrow>\n                 length xs' \\<le> length xs);\n     t' = results_in t0 s0\\<rbrakk>\n    \\<Longrightarrow> t =\n                      results_in t0\n                       (followed_by s0\n                         (sum_weights (map (\\<lambda>(s, l, t). l) xs)))", "by (simp add: followed_by_summary t'(2))"], ["proof (state)\nthis:\n  t =\n  results_in t0\n   (sum_weights (map (\\<lambda>(s, l, t). l) ((loc0, s0, loc1) # xs)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)\n 2. \\<lbrakk>distinct xs; \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "then"], ["proof (chain)\npicking this:\n  t =\n  results_in t0\n   (sum_weights (map (\\<lambda>(s, l, t). l) ((loc0, s0, loc1) # xs)))", "have impPath: \"impWitnessPath c loc0 loc2 ?xs' t\""], ["proof (prove)\nusing this:\n  t =\n  results_in t0\n   (sum_weights (map (\\<lambda>(s, l, t). l) ((loc0, s0, loc1) # xs)))\n\ngoal (1 subgoal):\n 1. impWitnessPath c loc0 loc2 ((loc0, s0, loc1) # xs) t", "using is_path_xs' case_distinct loc0(1)"], ["proof (prove)\nusing this:\n  t =\n  results_in t0\n   (sum_weights (map (\\<lambda>(s, l, t). l) ((loc0, s0, loc1) # xs)))\n  path loc0 loc2 ((loc0, s0, loc1) # xs)\n  distinct ((loc0, s0, loc1) # xs)\n  t0 \\<in>\\<^sub>A frontier (c_imp c loc0)\n\ngoal (1 subgoal):\n 1. impWitnessPath c loc0 loc2 ((loc0, s0, loc1) # xs) t", "apply (simp add: impWitnessPath_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t =\n             results_in t0\n              (followed_by s0\n                (sum_weights (map (\\<lambda>(s, l, t). l) xs)));\n     path loc0 loc2 ((loc0, s0, loc1) # xs);\n     (loc0, s0, loc1) \\<notin> set xs \\<and> distinct xs;\n     t0 \\<in>\\<^sub>A frontier (c_imp c loc0)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier (c_imp c loc0) \\<and>\n                         results_in t0\n                          (followed_by s0\n                            (sum_weights\n                              (map (\\<lambda>(s, l, t). l) xs))) =\n                         results_in t'\n                          (followed_by s0\n                            (sum_weights\n                              (map (\\<lambda>(s, l, t). l) xs))) \\<and>\n                         (\\<forall>k<Suc (length xs).\n                             results_in t'\n                              (followed_by s0\n                                (sum_weights\n                                  (map (\\<lambda>(s, l, t). l)\n                                    (take k xs))))\n                             \\<in>\\<^sub>A frontier\n      (c_imp c\n        (case ((loc0, s0, loc1) # xs) ! k of (s, l, t) \\<Rightarrow> t)))", "using r"], ["proof (prove)\nusing this:\n  ?k < length ((loc0, s0, loc1) # xs) \\<Longrightarrow>\n  results_in t0\n   (sum_weights\n     (map (\\<lambda>(s, l, t). l) (take (?k + 1) ((loc0, s0, loc1) # xs))))\n  \\<in>\\<^sub>A frontier\n                 (c_imp c\n                   (case ((loc0, s0, loc1) # xs) ! ?k of\n                    (s, l, t) \\<Rightarrow> t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t =\n             results_in t0\n              (followed_by s0\n                (sum_weights (map (\\<lambda>(s, l, t). l) xs)));\n     path loc0 loc2 ((loc0, s0, loc1) # xs);\n     (loc0, s0, loc1) \\<notin> set xs \\<and> distinct xs;\n     t0 \\<in>\\<^sub>A frontier (c_imp c loc0)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier (c_imp c loc0) \\<and>\n                         results_in t0\n                          (followed_by s0\n                            (sum_weights\n                              (map (\\<lambda>(s, l, t). l) xs))) =\n                         results_in t'\n                          (followed_by s0\n                            (sum_weights\n                              (map (\\<lambda>(s, l, t). l) xs))) \\<and>\n                         (\\<forall>k<Suc (length xs).\n                             results_in t'\n                              (followed_by s0\n                                (sum_weights\n                                  (map (\\<lambda>(s, l, t). l)\n                                    (take k xs))))\n                             \\<in>\\<^sub>A frontier\n      (c_imp c\n        (case ((loc0, s0, loc1) # xs) ! k of (s, l, t) \\<Rightarrow> t)))", "by auto"], ["proof (state)\nthis:\n  impWitnessPath c loc0 loc2 ((loc0, s0, loc1) # xs) t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)\n 2. \\<lbrakk>distinct xs; \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "have \"length ?xs' > length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs < length ((loc0, s0, loc1) # xs)", "by auto"], ["proof (state)\nthis:\n  length xs < length ((loc0, s0, loc1) # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)\n 2. \\<lbrakk>distinct xs; \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "then"], ["proof (chain)\npicking this:\n  length xs < length ((loc0, s0, loc1) # xs)", "have \"\\<not> longestImpWitnessPath c loc1 loc2 xs t\""], ["proof (prove)\nusing this:\n  length xs < length ((loc0, s0, loc1) # xs)\n\ngoal (1 subgoal):\n 1. \\<not> longestImpWitnessPath c loc1 loc2 xs t", "using impPath leD"], ["proof (prove)\nusing this:\n  length xs < length ((loc0, s0, loc1) # xs)\n  impWitnessPath c loc0 loc2 ((loc0, s0, loc1) # xs) t\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n\ngoal (1 subgoal):\n 1. \\<not> longestImpWitnessPath c loc1 loc2 xs t", "unfolding longestImpWitnessPath_def"], ["proof (prove)\nusing this:\n  length xs < length ((loc0, s0, loc1) # xs)\n  impWitnessPath c loc0 loc2 ((loc0, s0, loc1) # xs) t\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n\ngoal (1 subgoal):\n 1. \\<not> (impWitnessPath c loc1 loc2 xs t \\<and>\n            (\\<forall>loc' xs'.\n                impWitnessPath c loc' loc2 xs' t \\<longrightarrow>\n                length xs' \\<le> length xs))", "by blast"], ["proof (state)\nthis:\n  \\<not> longestImpWitnessPath c loc1 loc2 xs t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)\n 2. \\<lbrakk>distinct xs; \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "then"], ["proof (chain)\npicking this:\n  \\<not> longestImpWitnessPath c loc1 loc2 xs t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> longestImpWitnessPath c loc1 loc2 xs t\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "using longestP"], ["proof (prove)\nusing this:\n  \\<not> longestImpWitnessPath c loc1 loc2 xs t\n  longestImpWitnessPath c loc1 loc2 xs t\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "by blast"], ["proof (state)\nthis:\n  \\<exists>t' loc1 xs.\n     path loc1 loc2 xs \\<and>\n     t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n     (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n      zcount (c_work c loc1) t' < 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; \\<not> distinct ((loc0, s0, loc1) # xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; \\<not> distinct ((loc0, s0, loc1) # xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "assume \"\\<not> distinct ?xs'\""], ["proof (state)\nthis:\n  \\<not> distinct ((loc0, s0, loc1) # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; \\<not> distinct ((loc0, s0, loc1) # xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "(* show that we have a non-increasing cycle along path (loc0, s0, loc1) # xs *)"], ["proof (state)\nthis:\n  \\<not> distinct ((loc0, s0, loc1) # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; \\<not> distinct ((loc0, s0, loc1) # xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "with distinctxs"], ["proof (chain)\npicking this:\n  distinct xs\n  \\<not> distinct ((loc0, s0, loc1) # xs)", "obtain k where k: \"TO (?xs' ! k) = loc0\" \"k < length ?xs'\""], ["proof (prove)\nusing this:\n  distinct xs\n  \\<not> distinct ((loc0, s0, loc1) # xs)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>(case ((loc0, s0, loc1) # xs) ! k of\n                  (s, l, t) \\<Rightarrow> t) =\n                 loc0;\n         k < length ((loc0, s0, loc1) # xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; \\<not> distinct ((loc0, s0, loc1) # xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         (case ((loc0, s0, loc1) # xs) ! k of\n                          (s, l, t) \\<Rightarrow> t) =\n                         loc0 \\<and>\n                         k < length ((loc0, s0, loc1) # xs)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; (loc0, s0, loc1) \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         (case ((loc0, s0, loc1) # xs) ! k of\n                          (s, l, t) \\<Rightarrow> t) =\n                         loc0 \\<and>\n                         k < Suc (length xs)", "apply (subst (asm) in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs;\n     \\<exists>i<length xs. xs ! i = (loc0, s0, loc1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         (case ((loc0, s0, loc1) # xs) ! k of\n                          (s, l, t) \\<Rightarrow> t) =\n                         loc0 \\<and>\n                         k < Suc (length xs)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>distinct xs; i < length xs;\n        xs ! i = (loc0, s0, loc1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k.\n                            (case ((loc0, s0, loc1) # xs) ! k of\n                             (s, l, t) \\<Rightarrow> t) =\n                            loc0 \\<and>\n                            k < Suc (length xs)", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; i < length xs; xs ! i = (loc0, s0, loc1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         (case ((loc0, s0, loc1) # xs) ! k of\n                          (s, l, t) \\<Rightarrow> t) =\n                         loc0 \\<and>\n                         k < Suc (length xs)", "apply (cases \"i=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; i < length xs; xs ! i = (loc0, s0, loc1);\n     i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         (case ((loc0, s0, loc1) # xs) ! k of\n                          (s, l, t) \\<Rightarrow> t) =\n                         loc0 \\<and>\n                         k < Suc (length xs)\n 2. \\<lbrakk>distinct xs; i < length xs; xs ! i = (loc0, s0, loc1);\n     i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         (case ((loc0, s0, loc1) # xs) ! k of\n                          (s, l, t) \\<Rightarrow> t) =\n                         loc0 \\<and>\n                         k < Suc (length xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; i < length xs; xs ! i = (loc0, s0, loc1);\n     i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         (case ((loc0, s0, loc1) # xs) ! k of\n                          (s, l, t) \\<Rightarrow> t) =\n                         loc0 \\<and>\n                         k < Suc (length xs)", "using path_first_loc[OF path_xs]"], ["proof (prove)\nusing this:\n  \\<lbrakk>xs \\<noteq> []; xs ! 0 = (?l1', ?s, ?l2')\\<rbrakk>\n  \\<Longrightarrow> loc1 = ?l1'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; i < length xs; xs ! i = (loc0, s0, loc1);\n     i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         (case ((loc0, s0, loc1) # xs) ! k of\n                          (s, l, t) \\<Rightarrow> t) =\n                         loc0 \\<and>\n                         k < Suc (length xs)", "by force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; i < length xs; xs ! i = (loc0, s0, loc1);\n     i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         (case ((loc0, s0, loc1) # xs) ! k of\n                          (s, l, t) \\<Rightarrow> t) =\n                         loc0 \\<and>\n                         k < Suc (length xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; i < length xs; xs ! i = (loc0, s0, loc1);\n     i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         (case ((loc0, s0, loc1) # xs) ! k of\n                          (s, l, t) \\<Rightarrow> t) =\n                         loc0 \\<and>\n                         k < Suc (length xs)", "apply (rule exI[of _ i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; i < length xs; xs ! i = (loc0, s0, loc1);\n     i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (case ((loc0, s0, loc1) # xs) ! i of\n                       (s, l, t) \\<Rightarrow> t) =\n                      loc0 \\<and>\n                      i < Suc (length xs)", "using path_xs"], ["proof (prove)\nusing this:\n  path loc1 loc2 xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; i < length xs; xs ! i = (loc0, s0, loc1);\n     i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (case ((loc0, s0, loc1) # xs) ! i of\n                       (s, l, t) \\<Rightarrow> t) =\n                      loc0 \\<and>\n                      i < Suc (length xs)", "apply (auto dest: path_to_eq_from[of _ _ xs \"i-1\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (case ((loc0, s0, loc1) # xs) ! k of (s, l, t) \\<Rightarrow> t) = loc0\n  k < length ((loc0, s0, loc1) # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; \\<not> distinct ((loc0, s0, loc1) # xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "have \"results_in t0 (sum_path_weights (take (k+1) ?xs')) \\<in>\\<^sub>A frontier (c_imp c loc0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. results_in t0\n     (sum_weights\n       (map (\\<lambda>(s, l, t). l) (take (k + 1) ((loc0, s0, loc1) # xs))))\n    \\<in>\\<^sub>A frontier (c_imp c loc0)", "by (rule r[OF k(2), unfolded k(1)])"], ["proof (state)\nthis:\n  results_in t0\n   (sum_weights\n     (map (\\<lambda>(s, l, t). l) (take (k + 1) ((loc0, s0, loc1) # xs))))\n  \\<in>\\<^sub>A frontier (c_imp c loc0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; \\<not> distinct ((loc0, s0, loc1) # xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "moreover"], ["proof (state)\nthis:\n  results_in t0\n   (sum_weights\n     (map (\\<lambda>(s, l, t). l) (take (k + 1) ((loc0, s0, loc1) # xs))))\n  \\<in>\\<^sub>A frontier (c_imp c loc0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; \\<not> distinct ((loc0, s0, loc1) # xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "have \"t0 < results_in t0 (sum_path_weights (take (k+1) ?xs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t0 < results_in t0\n          (sum_weights\n            (map (\\<lambda>(s, l, t). l)\n              (take (k + 1) ((loc0, s0, loc1) # xs))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. t0 < results_in t0\n          (followed_by s0\n            (sum_weights (map (\\<lambda>(s, l, t). l) (take k xs))))", "apply (rule no_zero_cycle[of loc0 \"take (k+1) ?xs'\" \"sum_path_weights (take (k+1) ?xs')\" t0, simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. path loc0 loc0 ((loc0, s0, loc1) # take k xs)", "using is_path_xs' k  path_take_to"], ["proof (prove)\nusing this:\n  path loc0 loc2 ((loc0, s0, loc1) # xs)\n  (case ((loc0, s0, loc1) # xs) ! k of (s, l, t) \\<Rightarrow> t) = loc0\n  k < length ((loc0, s0, loc1) # xs)\n  \\<lbrakk>path ?l1.0 ?l2.0 ?xs; ?m < length ?xs;\n   (case ?xs ! ?m of (s, l, t) \\<Rightarrow> t) = ?l2'\\<rbrakk>\n  \\<Longrightarrow> path ?l1.0 ?l2' (take (?m + 1) ?xs)\n\ngoal (1 subgoal):\n 1. path loc0 loc0 ((loc0, s0, loc1) # take k xs)", "by fastforce"], ["proof (state)\nthis:\n  t0 < results_in t0\n        (sum_weights\n          (map (\\<lambda>(s, l, t). l)\n            (take (k + 1) ((loc0, s0, loc1) # xs))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; \\<not> distinct ((loc0, s0, loc1) # xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' loc1 xs.\n                         path loc1 loc2 xs \\<and>\n                         t =\n                         results_in t'\n                          (sum_weights\n                            (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                         (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n                          zcount (c_work c loc1) t' < 0)", "ultimately"], ["proof (chain)\npicking this:\n  results_in t0\n   (sum_weights\n     (map (\\<lambda>(s, l, t). l) (take (k + 1) ((loc0, s0, loc1) # xs))))\n  \\<in>\\<^sub>A frontier (c_imp c loc0)\n  t0 < results_in t0\n        (sum_weights\n          (map (\\<lambda>(s, l, t). l)\n            (take (k + 1) ((loc0, s0, loc1) # xs))))", "show ?thesis"], ["proof (prove)\nusing this:\n  results_in t0\n   (sum_weights\n     (map (\\<lambda>(s, l, t). l) (take (k + 1) ((loc0, s0, loc1) # xs))))\n  \\<in>\\<^sub>A frontier (c_imp c loc0)\n  t0 < results_in t0\n        (sum_weights\n          (map (\\<lambda>(s, l, t). l)\n            (take (k + 1) ((loc0, s0, loc1) # xs))))\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "using loc0(1) frontier_comparable_False"], ["proof (prove)\nusing this:\n  results_in t0\n   (sum_weights\n     (map (\\<lambda>(s, l, t). l) (take (k + 1) ((loc0, s0, loc1) # xs))))\n  \\<in>\\<^sub>A frontier (c_imp c loc0)\n  t0 < results_in t0\n        (sum_weights\n          (map (\\<lambda>(s, l, t). l)\n            (take (k + 1) ((loc0, s0, loc1) # xs))))\n  t0 \\<in>\\<^sub>A frontier (c_imp c loc0)\n  \\<lbrakk>?x \\<in>\\<^sub>A frontier ?M; ?y \\<in>\\<^sub>A frontier ?M;\n   ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc1 xs.\n       path loc1 loc2 xs \\<and>\n       t =\n       results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n        zcount (c_work c loc1) t' < 0)", "by blast"], ["proof (state)\nthis:\n  \\<exists>t' loc1 xs.\n     path loc1 loc2 xs \\<and>\n     t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n     (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n      zcount (c_work c loc1) t' < 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t' loc1 xs.\n     path loc1 loc2 xs \\<and>\n     t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n     (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n      zcount (c_work c loc1) t' < 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t' loc1 xs.\n     path loc1 loc2 xs \\<and>\n     t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n     (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n      zcount (c_work c loc1) t' < 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t' loc1 xs.\n     path loc1 loc2 xs \\<and>\n     t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n     (t' \\<in>\\<^sub>A frontier (c_pts c loc1) \\<or>\n      zcount (c_work c loc1) t' < 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma implication_implies_pointstamp:\n  assumes \"t \\<in>\\<^sub>A frontier (c_imp c loc)\"\n    and   \"inv_imps_work_sum c\"\n  shows   \"\\<exists>t' loc' s. s \\<in>\\<^sub>A path_summary loc' loc \\<and> t \\<ge> results_in t' s \\<and>\n               (t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or> 0 > zcount (c_work c loc') t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t' loc' s.\n       s \\<in>\\<^sub>A path_summary loc' loc \\<and>\n       results_in t' s \\<le> t \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n        zcount (c_work c loc') t' < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' loc' s.\n       s \\<in>\\<^sub>A path_summary loc' loc \\<and>\n       results_in t' s \\<le> t \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n        zcount (c_work c loc') t' < 0)", "obtain loc' t' xs where witness:\n    \"path loc' loc xs\"\n    \"t = results_in t' (sum_path_weights xs)\"\n    \"t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or> 0 > zcount (c_work c loc') t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>loc' xs t'.\n        \\<lbrakk>path loc' loc xs;\n         t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs));\n         t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n         zcount (c_work c loc') t' < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms find_witness_from_frontier"], ["proof (prove)\nusing this:\n  t \\<in>\\<^sub>A frontier (c_imp c loc)\n  inv_imps_work_sum c\n  \\<lbrakk>?t \\<in>\\<^sub>A frontier (c_imp ?c ?loc2.0);\n   inv_imps_work_sum ?c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t' loc1 xs.\n                       path loc1 ?loc2.0 xs \\<and>\n                       ?t =\n                       results_in t'\n                        (sum_weights\n                          (map (\\<lambda>(s, l, t). l) xs)) \\<and>\n                       (t' \\<in>\\<^sub>A frontier (c_pts ?c loc1) \\<or>\n                        zcount (c_work ?c loc1) t' < 0)\n\ngoal (1 subgoal):\n 1. (\\<And>loc' xs t'.\n        \\<lbrakk>path loc' loc xs;\n         t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs));\n         t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n         zcount (c_work c loc') t' < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path loc' loc xs\n  t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n  zcount (c_work c loc') t' < 0\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc' s.\n       s \\<in>\\<^sub>A path_summary loc' loc \\<and>\n       results_in t' s \\<le> t \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n        zcount (c_work c loc') t' < 0)", "obtain s where s: \"s \\<in>\\<^sub>A path_summary loc' loc\"  \"s \\<le> (sum_path_weights xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in>\\<^sub>A path_summary loc' loc;\n         s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using witness(1) path_path_weight"], ["proof (prove)\nusing this:\n  path loc' loc xs\n  path ?l1.0 ?l2.0 ?xs \\<Longrightarrow>\n  \\<exists>s.\n     s \\<in>\\<^sub>A path_summary ?l1.0 ?l2.0 \\<and>\n     s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) ?xs)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in>\\<^sub>A path_summary loc' loc;\n         s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s \\<in>\\<^sub>A path_summary loc' loc\n  s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc' s.\n       s \\<in>\\<^sub>A path_summary loc' loc \\<and>\n       results_in t' s \\<le> t \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n        zcount (c_work c loc') t' < 0)", "then"], ["proof (chain)\npicking this:\n  s \\<in>\\<^sub>A path_summary loc' loc\n  s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)", "have \"t \\<ge> results_in t' s\""], ["proof (prove)\nusing this:\n  s \\<in>\\<^sub>A path_summary loc' loc\n  s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)\n\ngoal (1 subgoal):\n 1. results_in t' s \\<le> t", "using witness(2) results_in_mono(2)"], ["proof (prove)\nusing this:\n  s \\<in>\\<^sub>A path_summary loc' loc\n  s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)\n  t = results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  ?s1.0 \\<le> ?s2.0 \\<Longrightarrow>\n  results_in ?t ?s1.0 \\<le> results_in ?t ?s2.0\n\ngoal (1 subgoal):\n 1. results_in t' s \\<le> t", "by blast"], ["proof (state)\nthis:\n  results_in t' s \\<le> t\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc' s.\n       s \\<in>\\<^sub>A path_summary loc' loc \\<and>\n       results_in t' s \\<le> t \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n        zcount (c_work c loc') t' < 0)", "then"], ["proof (chain)\npicking this:\n  results_in t' s \\<le> t", "show ?thesis"], ["proof (prove)\nusing this:\n  results_in t' s \\<le> t\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc' s.\n       s \\<in>\\<^sub>A path_summary loc' loc \\<and>\n       results_in t' s \\<le> t \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n        zcount (c_work c loc') t' < 0)", "using witness(3) s"], ["proof (prove)\nusing this:\n  results_in t' s \\<le> t\n  t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n  zcount (c_work c loc') t' < 0\n  s \\<in>\\<^sub>A path_summary loc' loc\n  s \\<le> sum_weights (map (\\<lambda>(s, l, t). l) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>t' loc' s.\n       s \\<in>\\<^sub>A path_summary loc' loc \\<and>\n       results_in t' s \\<le> t \\<and>\n       (t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n        zcount (c_work c loc') t' < 0)", "by auto"], ["proof (state)\nthis:\n  \\<exists>t' loc' s.\n     s \\<in>\\<^sub>A path_summary loc' loc \\<and>\n     results_in t' s \\<le> t \\<and>\n     (t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n      zcount (c_work c loc') t' < 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Proof of Safety\\<close>"], ["", "lemma results_in_sum_path_weights_append:\n  \"results_in t (sum_path_weights (xs @ [(loc2, s, loc3)])) = results_in (results_in t (sum_path_weights xs)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. results_in t\n     (sum_weights (map (\\<lambda>(s, l, t). l) (xs @ [(loc2, s, loc3)]))) =\n    results_in (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n     s", "by (metis followed_by_summary sum_path_weights_append_singleton)"], ["", "context\n  fixes c :: \"('loc, 't) configuration\"\nbegin"], ["", "inductive loc_imps_fw where\n  \"loc_imps_fw loc loc (c_imp c loc) []\" |\n  \"loc_imps_fw loc1 loc2 M xs \\<Longrightarrow> s \\<in>\\<^sub>A summary loc2 loc3 \\<Longrightarrow> distinct (xs @ [(loc2,s,loc3)]) \\<Longrightarrow>\n   loc_imps_fw loc1 loc3 ({# results_in t s. t \\<in>#\\<^sub>z M #} + c_imp c loc3) (xs @ [(loc2,s,loc3)])\""], ["", "end"], ["", "lemma loc_imps_fw_conv_path: \"loc_imps_fw c loc1 loc2 M xs \\<Longrightarrow> path loc1 loc2 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loc_imps_fw c loc1 loc2 M xs \\<Longrightarrow> path loc1 loc2 xs", "by (induct rule: loc_imps_fw.induct) (auto intro: path.intros)"], ["", "lemma path_conv_loc_imps_fw: \"path loc1 loc2 xs \\<Longrightarrow> distinct xs \\<Longrightarrow> \\<exists>M. loc_imps_fw c loc1 loc2 M xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path loc1 loc2 xs; distinct xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M. loc_imps_fw c loc1 loc2 M xs", "proof (induct rule: path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; distinct []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M. loc_imps_fw c l1 l2 M []\n 2. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        distinct xs \\<Longrightarrow> \\<exists>M. loc_imps_fw c l1 l2 M xs;\n        lbl \\<in>\\<^sub>A summary l2 l3;\n        distinct (xs @ [(l2, lbl, l3)])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            loc_imps_fw c l1 l3 M (xs @ [(l2, lbl, l3)])", "case (path0 l1 l2)"], ["proof (state)\nthis:\n  l1 = l2\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       \\<lbrakk>l1 = l2; distinct []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M. loc_imps_fw c l1 l2 M []\n 2. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        distinct xs \\<Longrightarrow> \\<exists>M. loc_imps_fw c l1 l2 M xs;\n        lbl \\<in>\\<^sub>A summary l2 l3;\n        distinct (xs @ [(l2, lbl, l3)])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            loc_imps_fw c l1 l3 M (xs @ [(l2, lbl, l3)])", "then"], ["proof (chain)\npicking this:\n  l1 = l2\n  distinct []", "show ?case"], ["proof (prove)\nusing this:\n  l1 = l2\n  distinct []\n\ngoal (1 subgoal):\n 1. \\<exists>M. loc_imps_fw c l1 l2 M []", "by (auto intro: loc_imps_fw.intros)"], ["proof (state)\nthis:\n  \\<exists>M. loc_imps_fw c l1 l2 M []\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        distinct xs \\<Longrightarrow> \\<exists>M. loc_imps_fw c l1 l2 M xs;\n        lbl \\<in>\\<^sub>A summary l2 l3;\n        distinct (xs @ [(l2, lbl, l3)])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            loc_imps_fw c l1 l3 M (xs @ [(l2, lbl, l3)])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        distinct xs \\<Longrightarrow> \\<exists>M. loc_imps_fw c l1 l2 M xs;\n        lbl \\<in>\\<^sub>A summary l2 l3;\n        distinct (xs @ [(l2, lbl, l3)])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            loc_imps_fw c l1 l3 M (xs @ [(l2, lbl, l3)])", "case (path l1 l2 xs lbl l3)"], ["proof (state)\nthis:\n  path l1 l2 xs\n  distinct xs \\<Longrightarrow> \\<exists>M. loc_imps_fw c l1 l2 M xs\n  lbl \\<in>\\<^sub>A summary l2 l3\n  distinct (xs @ [(l2, lbl, l3)])\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        distinct xs \\<Longrightarrow> \\<exists>M. loc_imps_fw c l1 l2 M xs;\n        lbl \\<in>\\<^sub>A summary l2 l3;\n        distinct (xs @ [(l2, lbl, l3)])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            loc_imps_fw c l1 l3 M (xs @ [(l2, lbl, l3)])", "then"], ["proof (chain)\npicking this:\n  path l1 l2 xs\n  distinct xs \\<Longrightarrow> \\<exists>M. loc_imps_fw c l1 l2 M xs\n  lbl \\<in>\\<^sub>A summary l2 l3\n  distinct (xs @ [(l2, lbl, l3)])", "obtain M where \"loc_imps_fw c l1 l2 M xs\""], ["proof (prove)\nusing this:\n  path l1 l2 xs\n  distinct xs \\<Longrightarrow> \\<exists>M. loc_imps_fw c l1 l2 M xs\n  lbl \\<in>\\<^sub>A summary l2 l3\n  distinct (xs @ [(l2, lbl, l3)])\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        loc_imps_fw c l1 l2 M xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  loc_imps_fw c l1 l2 M xs\n\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs lbl l3.\n       \\<lbrakk>path l1 l2 xs;\n        distinct xs \\<Longrightarrow> \\<exists>M. loc_imps_fw c l1 l2 M xs;\n        lbl \\<in>\\<^sub>A summary l2 l3;\n        distinct (xs @ [(l2, lbl, l3)])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            loc_imps_fw c l1 l3 M (xs @ [(l2, lbl, l3)])", "with path"], ["proof (chain)\npicking this:\n  path l1 l2 xs\n  distinct xs \\<Longrightarrow> \\<exists>M. loc_imps_fw c l1 l2 M xs\n  lbl \\<in>\\<^sub>A summary l2 l3\n  distinct (xs @ [(l2, lbl, l3)])\n  loc_imps_fw c l1 l2 M xs", "show ?case"], ["proof (prove)\nusing this:\n  path l1 l2 xs\n  distinct xs \\<Longrightarrow> \\<exists>M. loc_imps_fw c l1 l2 M xs\n  lbl \\<in>\\<^sub>A summary l2 l3\n  distinct (xs @ [(l2, lbl, l3)])\n  loc_imps_fw c l1 l2 M xs\n\ngoal (1 subgoal):\n 1. \\<exists>M. loc_imps_fw c l1 l3 M (xs @ [(l2, lbl, l3)])", "by (force intro: loc_imps_fw.intros(2))"], ["proof (state)\nthis:\n  \\<exists>M. loc_imps_fw c l1 l3 M (xs @ [(l2, lbl, l3)])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_summary_conv_loc_imps_fw:\n  \"s \\<in>\\<^sub>A path_summary loc1 loc2 \\<Longrightarrow> \\<exists>M xs. loc_imps_fw c loc1 loc2 M xs \\<and> sum_path_weights xs = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A path_summary loc1 loc2 \\<Longrightarrow>\n    \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A path_summary loc1 loc2 \\<Longrightarrow>\n    \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "assume path_sum: \"s \\<in>\\<^sub>A path_summary loc1 loc2\""], ["proof (state)\nthis:\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A path_summary loc1 loc2 \\<Longrightarrow>\n    \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "then"], ["proof (chain)\npicking this:\n  s \\<in>\\<^sub>A path_summary loc1 loc2", "obtain M xs where le: \"path loc1 loc2 xs\" \"loc_imps_fw c loc1 loc2 M xs\" \"sum_path_weights xs \\<le> s\" \"distinct xs\""], ["proof (prove)\nusing this:\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n\ngoal (1 subgoal):\n 1. (\\<And>xs M.\n        \\<lbrakk>path loc1 loc2 xs; loc_imps_fw c loc1 loc2 M xs;\n         sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<le> s;\n         distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A path_summary loc1 loc2 \\<Longrightarrow>\n    \\<exists>xs M.\n       path loc1 loc2 xs \\<and>\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<le> s \\<and>\n       distinct xs", "apply (drule path_weight_conv_path)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       path loc1 loc2 xs \\<and>\n       s = sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<and>\n       (\\<forall>ys.\n           path loc1 loc2 ys \\<longrightarrow>\n           \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ys)\n                  < sum_weights\n                     (map (\\<lambda>(s, l, t). l) xs)) \\<Longrightarrow>\n    \\<exists>xs M.\n       path loc1 loc2 xs \\<and>\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<le> s \\<and>\n       distinct xs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>path loc1 loc2 xs;\n        \\<forall>ys.\n           path loc1 loc2 ys \\<longrightarrow>\n           \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ys)\n                  < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        s = sum_weights (map (\\<lambda>(s, l, t). l) xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            path loc1 loc2 xsa \\<and>\n                            (\\<exists>M.\n                                loc_imps_fw c loc1 loc2 M xsa) \\<and>\n                            sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n                            \\<le> sum_weights\n                                   (map (\\<lambda>(s, l, t). l) xs) \\<and>\n                            distinct xsa", "apply (drule path_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   path loc1 loc2 ys \\<longrightarrow>\n                   \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ys)\n                          < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        s = sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        \\<exists>xs'.\n           distinct xs' \\<and>\n           path loc1 loc2 xs' \\<and>\n           map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n           map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            path loc1 loc2 xsa \\<and>\n                            (\\<exists>M.\n                                loc_imps_fw c loc1 loc2 M xsa) \\<and>\n                            sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n                            \\<le> sum_weights\n                                   (map (\\<lambda>(s, l, t). l) xs) \\<and>\n                            distinct xsa", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xs'.\n       \\<lbrakk>\\<forall>ys.\n                   path loc1 loc2 ys \\<longrightarrow>\n                   \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ys)\n                          < sum_weights (map (\\<lambda>(s, l, t). l) xs);\n        s = sum_weights (map (\\<lambda>(s, l, t). l) xs); distinct xs';\n        path loc1 loc2 xs';\n        map (\\<lambda>(s, l, t). l) xs' \\<preceq>\n        map (\\<lambda>(s, l, t). l) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            path loc1 loc2 xsa \\<and>\n                            (\\<exists>M.\n                                loc_imps_fw c loc1 loc2 M xsa) \\<and>\n                            sum_weights (map (\\<lambda>(s, l, t). l) xsa)\n                            \\<le> sum_weights\n                                   (map (\\<lambda>(s, l, t). l) xs) \\<and>\n                            distinct xsa", "subgoal for ys xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ysa.\n                path loc1 loc2 ysa \\<longrightarrow>\n                \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ysa)\n                       < sum_weights (map (\\<lambda>(s, l, t). l) ys);\n     s = sum_weights (map (\\<lambda>(s, l, t). l) ys); distinct xs;\n     path loc1 loc2 xs;\n     map (\\<lambda>(s, l, t). l) xs \\<preceq>\n     map (\\<lambda>(s, l, t). l) ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         path loc1 loc2 xs \\<and>\n                         (\\<exists>M. loc_imps_fw c loc1 loc2 M xs) \\<and>\n                         sum_weights (map (\\<lambda>(s, l, t). l) xs)\n                         \\<le> sum_weights\n                                (map (\\<lambda>(s, l, t). l) ys) \\<and>\n                         distinct xs", "apply (rule exI[of _ xs])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ysa.\n                path loc1 loc2 ysa \\<longrightarrow>\n                \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ysa)\n                       < sum_weights (map (\\<lambda>(s, l, t). l) ys);\n     s = sum_weights (map (\\<lambda>(s, l, t). l) ys); distinct xs;\n     path loc1 loc2 xs;\n     map (\\<lambda>(s, l, t). l) xs \\<preceq>\n     map (\\<lambda>(s, l, t). l) ys\\<rbrakk>\n    \\<Longrightarrow> path loc1 loc2 xs \\<and>\n                      (\\<exists>M. loc_imps_fw c loc1 loc2 M xs) \\<and>\n                      sum_weights (map (\\<lambda>(s, l, t). l) xs)\n                      \\<le> sum_weights\n                             (map (\\<lambda>(s, l, t). l) ys) \\<and>\n                      distinct xs", "apply (rule conjI, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ysa.\n                path loc1 loc2 ysa \\<longrightarrow>\n                \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ysa)\n                       < sum_weights (map (\\<lambda>(s, l, t). l) ys);\n     s = sum_weights (map (\\<lambda>(s, l, t). l) ys); distinct xs;\n     path loc1 loc2 xs;\n     map (\\<lambda>(s, l, t). l) xs \\<preceq>\n     map (\\<lambda>(s, l, t). l) ys\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>M. loc_imps_fw c loc1 loc2 M xs) \\<and>\n                      sum_weights (map (\\<lambda>(s, l, t). l) xs)\n                      \\<le> sum_weights\n                             (map (\\<lambda>(s, l, t). l) ys) \\<and>\n                      distinct xs", "apply (drule path_conv_loc_imps_fw[of loc1 loc2 xs c])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ysa.\n                path loc1 loc2 ysa \\<longrightarrow>\n                \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ysa)\n                       < sum_weights (map (\\<lambda>(s, l, t). l) ys);\n     s = sum_weights (map (\\<lambda>(s, l, t). l) ys); distinct xs;\n     map (\\<lambda>(s, l, t). l) xs \\<preceq>\n     map (\\<lambda>(s, l, t). l) ys\\<rbrakk>\n    \\<Longrightarrow> distinct xs\n 2. \\<lbrakk>\\<forall>ysa.\n                path loc1 loc2 ysa \\<longrightarrow>\n                \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ysa)\n                       < sum_weights (map (\\<lambda>(s, l, t). l) ys);\n     s = sum_weights (map (\\<lambda>(s, l, t). l) ys); distinct xs;\n     map (\\<lambda>(s, l, t). l) xs \\<preceq>\n     map (\\<lambda>(s, l, t). l) ys;\n     \\<exists>M. loc_imps_fw c loc1 loc2 M xs\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>M. loc_imps_fw c loc1 loc2 M xs) \\<and>\n                      sum_weights (map (\\<lambda>(s, l, t). l) xs)\n                      \\<le> sum_weights\n                             (map (\\<lambda>(s, l, t). l) ys) \\<and>\n                      distinct xs", "using subseq_sum_weights_le"], ["proof (prove)\nusing this:\n  ?xs \\<preceq> ?ys \\<Longrightarrow> sum_weights ?xs \\<le> sum_weights ?ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ysa.\n                path loc1 loc2 ysa \\<longrightarrow>\n                \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ysa)\n                       < sum_weights (map (\\<lambda>(s, l, t). l) ys);\n     s = sum_weights (map (\\<lambda>(s, l, t). l) ys); distinct xs;\n     map (\\<lambda>(s, l, t). l) xs \\<preceq>\n     map (\\<lambda>(s, l, t). l) ys\\<rbrakk>\n    \\<Longrightarrow> distinct xs\n 2. \\<lbrakk>\\<forall>ysa.\n                path loc1 loc2 ysa \\<longrightarrow>\n                \\<not> sum_weights (map (\\<lambda>(s, l, t). l) ysa)\n                       < sum_weights (map (\\<lambda>(s, l, t). l) ys);\n     s = sum_weights (map (\\<lambda>(s, l, t). l) ys); distinct xs;\n     map (\\<lambda>(s, l, t). l) xs \\<preceq>\n     map (\\<lambda>(s, l, t). l) ys;\n     \\<exists>M. loc_imps_fw c loc1 loc2 M xs\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>M. loc_imps_fw c loc1 loc2 M xs) \\<and>\n                      sum_weights (map (\\<lambda>(s, l, t). l) xs)\n                      \\<le> sum_weights\n                             (map (\\<lambda>(s, l, t). l) ys) \\<and>\n                      distinct xs", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  path loc1 loc2 xs\n  loc_imps_fw c loc1 loc2 M xs\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<le> s\n  distinct xs\n\ngoal (1 subgoal):\n 1. s \\<in>\\<^sub>A path_summary loc1 loc2 \\<Longrightarrow>\n    \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "proof (cases \"sum_path_weights xs = s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_weights (map (\\<lambda>(s, l, t). l) xs) = s \\<Longrightarrow>\n    \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s\n 2. sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<noteq>\n    s \\<Longrightarrow>\n    \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "case True"], ["proof (state)\nthis:\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) = s\n\ngoal (2 subgoals):\n 1. sum_weights (map (\\<lambda>(s, l, t). l) xs) = s \\<Longrightarrow>\n    \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s\n 2. sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<noteq>\n    s \\<Longrightarrow>\n    \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "with le"], ["proof (chain)\npicking this:\n  path loc1 loc2 xs\n  loc_imps_fw c loc1 loc2 M xs\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<le> s\n  distinct xs\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "show ?thesis"], ["proof (prove)\nusing this:\n  path loc1 loc2 xs\n  loc_imps_fw c loc1 loc2 M xs\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<le> s\n  distinct xs\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) = s\n\ngoal (1 subgoal):\n 1. \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "by auto"], ["proof (state)\nthis:\n  \\<exists>M xs.\n     loc_imps_fw c loc1 loc2 M xs \\<and>\n     sum_weights (map (\\<lambda>(s, l, t). l) xs) = s\n\ngoal (1 subgoal):\n 1. sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<noteq>\n    s \\<Longrightarrow>\n    \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<noteq>\n    s \\<Longrightarrow>\n    \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "case False"], ["proof (state)\nthis:\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<noteq> s\n\ngoal (1 subgoal):\n 1. sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<noteq>\n    s \\<Longrightarrow>\n    \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "with le"], ["proof (chain)\npicking this:\n  path loc1 loc2 xs\n  loc_imps_fw c loc1 loc2 M xs\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<le> s\n  distinct xs\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<noteq> s", "have \"sum_path_weights xs < s\""], ["proof (prove)\nusing this:\n  path loc1 loc2 xs\n  loc_imps_fw c loc1 loc2 M xs\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<le> s\n  distinct xs\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<noteq> s\n\ngoal (1 subgoal):\n 1. sum_weights (map (\\<lambda>(s, l, t). l) xs) < s", "by auto"], ["proof (state)\nthis:\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) < s\n\ngoal (1 subgoal):\n 1. sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<noteq>\n    s \\<Longrightarrow>\n    \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "with le(1) path_sum"], ["proof (chain)\npicking this:\n  path loc1 loc2 xs\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) < s", "have False"], ["proof (prove)\nusing this:\n  path loc1 loc2 xs\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) < s\n\ngoal (1 subgoal):\n 1. False", "by (auto dest: path_weight_conv_path)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. sum_weights (map (\\<lambda>(s, l, t). l) xs) \\<noteq>\n    s \\<Longrightarrow>\n    \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>M xs.\n       loc_imps_fw c loc1 loc2 M xs \\<and>\n       sum_weights (map (\\<lambda>(s, l, t). l) xs) = s", "by blast"], ["proof (state)\nthis:\n  \\<exists>M xs.\n     loc_imps_fw c loc1 loc2 M xs \\<and>\n     sum_weights (map (\\<lambda>(s, l, t). l) xs) = s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>M xs.\n     loc_imps_fw c loc1 loc2 M xs \\<and>\n     sum_weights (map (\\<lambda>(s, l, t). l) xs) = s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_zmset_id[simp]: \"{#x. x \\<in>#\\<^sub>z M#} = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#x. x \\<in>#\\<^sub>z M#} = M", "by transfer (auto simp: equiv_zmset_def)"], ["", "lemma sum_pos: \"finite M \\<Longrightarrow> \\<forall>x\\<in>M. 0 \\<le> f x \\<Longrightarrow> y \\<in> M \\<Longrightarrow> 0 < (f y::_::ordered_comm_monoid_add) \\<Longrightarrow> 0 < (\\<Sum>x\\<in>M. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite M; \\<forall>x\\<in>M. (0::'b) \\<le> f x; y \\<in> M;\n     (0::'b) < f y\\<rbrakk>\n    \\<Longrightarrow> (0::'b) < sum f M", "proof (induct M rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>{}. (0::'b) \\<le> f x; y \\<in> {};\n     (0::'b) < f y\\<rbrakk>\n    \\<Longrightarrow> (0::'b) < sum f {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>x\\<in>F. (0::'b) \\<le> f x; y \\<in> F;\n         (0::'b) < f y\\<rbrakk>\n        \\<Longrightarrow> (0::'b) < sum f F;\n        \\<forall>x\\<in>insert x F. (0::'b) \\<le> f x; y \\<in> insert x F;\n        (0::'b) < f y\\<rbrakk>\n       \\<Longrightarrow> (0::'b) < sum f (insert x F)", "case empty"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{}. (0::'b) \\<le> f x\n  y \\<in> {}\n  (0::'b) < f y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>{}. (0::'b) \\<le> f x; y \\<in> {};\n     (0::'b) < f y\\<rbrakk>\n    \\<Longrightarrow> (0::'b) < sum f {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>x\\<in>F. (0::'b) \\<le> f x; y \\<in> F;\n         (0::'b) < f y\\<rbrakk>\n        \\<Longrightarrow> (0::'b) < sum f F;\n        \\<forall>x\\<in>insert x F. (0::'b) \\<le> f x; y \\<in> insert x F;\n        (0::'b) < f y\\<rbrakk>\n       \\<Longrightarrow> (0::'b) < sum f (insert x F)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{}. (0::'b) \\<le> f x\n  y \\<in> {}\n  (0::'b) < f y", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{}. (0::'b) \\<le> f x\n  y \\<in> {}\n  (0::'b) < f y\n\ngoal (1 subgoal):\n 1. (0::'b) < sum f {}", "by simp"], ["proof (state)\nthis:\n  (0::'b) < sum f {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>x\\<in>F. (0::'b) \\<le> f x; y \\<in> F;\n         (0::'b) < f y\\<rbrakk>\n        \\<Longrightarrow> (0::'b) < sum f F;\n        \\<forall>x\\<in>insert x F. (0::'b) \\<le> f x; y \\<in> insert x F;\n        (0::'b) < f y\\<rbrakk>\n       \\<Longrightarrow> (0::'b) < sum f (insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>x\\<in>F. (0::'b) \\<le> f x; y \\<in> F;\n         (0::'b) < f y\\<rbrakk>\n        \\<Longrightarrow> (0::'b) < sum f F;\n        \\<forall>x\\<in>insert x F. (0::'b) \\<le> f x; y \\<in> insert x F;\n        (0::'b) < f y\\<rbrakk>\n       \\<Longrightarrow> (0::'b) < sum f (insert x F)", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<forall>x\\<in>F. (0::'b) \\<le> f x; y \\<in> F;\n   (0::'b) < f y\\<rbrakk>\n  \\<Longrightarrow> (0::'b) < sum f F\n  \\<forall>x\\<in>insert x F. (0::'b) \\<le> f x\n  y \\<in> insert x F\n  (0::'b) < f y\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>x\\<in>F. (0::'b) \\<le> f x; y \\<in> F;\n         (0::'b) < f y\\<rbrakk>\n        \\<Longrightarrow> (0::'b) < sum f F;\n        \\<forall>x\\<in>insert x F. (0::'b) \\<le> f x; y \\<in> insert x F;\n        (0::'b) < f y\\<rbrakk>\n       \\<Longrightarrow> (0::'b) < sum f (insert x F)", "then"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<forall>x\\<in>F. (0::'b) \\<le> f x; y \\<in> F;\n   (0::'b) < f y\\<rbrakk>\n  \\<Longrightarrow> (0::'b) < sum f F\n  \\<forall>x\\<in>insert x F. (0::'b) \\<le> f x\n  y \\<in> insert x F\n  (0::'b) < f y", "show ?case"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<forall>x\\<in>F. (0::'b) \\<le> f x; y \\<in> F;\n   (0::'b) < f y\\<rbrakk>\n  \\<Longrightarrow> (0::'b) < sum f F\n  \\<forall>x\\<in>insert x F. (0::'b) \\<le> f x\n  y \\<in> insert x F\n  (0::'b) < f y\n\ngoal (1 subgoal):\n 1. (0::'b) < sum f (insert x F)", "by (cases \"0 < f x\") (auto intro: sum_nonneg add_pos_nonneg add_nonneg_pos)"], ["proof (state)\nthis:\n  (0::'b) < sum f (insert x F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma loc_imps_fw_M_in_implications:\n  assumes \"loc_imps_fw c loc1 loc2 M xs\"\n    and   \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"\\<And>loc. c_work c loc = {#}\\<^sub>z\"\n    and   \"0 < zcount M t\"\n  shows   \"\\<exists>s. s \\<le> t \\<and> s \\<in>\\<^sub>A frontier (c_imp c loc2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2)", "using assms(1,5)"], ["proof (prove)\nusing this:\n  loc_imps_fw c loc1 loc2 M xs\n  0 < zcount M t\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2)", "proof (induct arbitrary: t rule: loc_imps_fw.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>loc t.\n       0 < zcount (c_imp c loc) t \\<Longrightarrow>\n       \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc)\n 2. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           0 < zcount M t \\<Longrightarrow>\n           \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "note iiws = assms(2)[unfolded inv_imps_work_sum_def assms(4), simplified, rule_format]"], ["proof (state)\nthis:\n  c_imp c ?loc =\n  zmset_of (mset_set (set_antichain (frontier (c_pts c ?loc)))) +\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n      (summary loc' ?loc))\n\ngoal (2 subgoals):\n 1. \\<And>loc t.\n       0 < zcount (c_imp c loc) t \\<Longrightarrow>\n       \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc)\n 2. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           0 < zcount M t \\<Longrightarrow>\n           \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "case (1 loc t)"], ["proof (state)\nthis:\n  0 < zcount (c_imp c loc) t\n\ngoal (2 subgoals):\n 1. \\<And>loc t.\n       0 < zcount (c_imp c loc) t \\<Longrightarrow>\n       \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc)\n 2. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           0 < zcount M t \\<Longrightarrow>\n           \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "then"], ["proof (chain)\npicking this:\n  0 < zcount (c_imp c loc) t", "show ?case"], ["proof (prove)\nusing this:\n  0 < zcount (c_imp c loc) t\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc)", "by (auto elim: obtain_elem_frontier)"], ["proof (state)\nthis:\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc)\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           0 < zcount M t \\<Longrightarrow>\n           \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           0 < zcount M t \\<Longrightarrow>\n           \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "note iiws = assms(2)[unfolded inv_imps_work_sum_def assms(4), simplified, rule_format]"], ["proof (state)\nthis:\n  c_imp c ?loc =\n  zmset_of (mset_set (set_antichain (frontier (c_pts c ?loc)))) +\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n      (summary loc' ?loc))\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           0 < zcount M t \\<Longrightarrow>\n           \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "case (2 loc1 loc2 M xs s loc3 t)"], ["proof (state)\nthis:\n  loc_imps_fw c loc1 loc2 M xs\n  0 < zcount M ?t3 \\<Longrightarrow>\n  \\<exists>s\\<le>?t3. s \\<in>\\<^sub>A frontier (c_imp c loc2)\n  s \\<in>\\<^sub>A summary loc2 loc3\n  distinct (xs @ [(loc2, s, loc3)])\n  0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3) t\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           0 < zcount M t \\<Longrightarrow>\n           \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "from 2(5)"], ["proof (chain)\npicking this:\n  0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3) t", "have disj: \"0 < zcount {# results_in t s. t \\<in>#\\<^sub>z M #} t \\<or> 0 < zcount (c_imp c loc3) t\""], ["proof (prove)\nusing this:\n  0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3) t\n\ngoal (1 subgoal):\n 1. 0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<or>\n    0 < zcount (c_imp c loc3) t", "by auto"], ["proof (state)\nthis:\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<or>\n  0 < zcount (c_imp c loc3) t\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           0 < zcount M t \\<Longrightarrow>\n           \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "assume \"0 < zcount {# results_in t s. t \\<in>#\\<^sub>z M #} t\""], ["proof (state)\nthis:\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "then"], ["proof (chain)\npicking this:\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t", "obtain t' where t': \"results_in t' s = t\" \"0 < zcount M t'\""], ["proof (prove)\nusing this:\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>results_in t' s = t; 0 < zcount M t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n    \\<exists>t'. results_in t' s = t \\<and> 0 < zcount M t'", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t;\n     \\<nexists>t'. results_in t' s = t \\<and> 0 < zcount M t'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (subst (asm) zcount_image_zmset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < sum (zcount M)\n                  ((\\<lambda>t. results_in t s) -` {t} \\<inter>\n                   set_zmset M);\n     \\<nexists>t'. results_in t' s = t \\<and> 0 < zcount M t'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (clarsimp simp: vimage_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < sum (zcount M)\n                  ({x. results_in x s = t} \\<inter> set_zmset M);\n     \\<forall>t'.\n        results_in t' s = t \\<longrightarrow>\n        \\<not> 0 < zcount M t'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis (mono_tags, lifting) Int_iff mem_Collect_eq sum_pos_ex_elem_pos)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  results_in t' s = t\n  0 < zcount M t'\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "obtain u where u: \"u \\<le> t'\" \"u \\<in>\\<^sub>A frontier (c_imp c loc2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<le> t';\n         u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (rule 2(2)[OF t'(2)])"], ["proof (state)\nthis:\n  u \\<le> t'\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "then"], ["proof (chain)\npicking this:\n  u \\<le> t'\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)", "have riu_le_rit': \"results_in u s \\<le> t\""], ["proof (prove)\nusing this:\n  u \\<le> t'\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (1 subgoal):\n 1. results_in u s \\<le> t", "by (simp add: t'(1)[symmetric] results_in_mono)"], ["proof (state)\nthis:\n  results_in u s \\<le> t\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "from u"], ["proof (chain)\npicking this:\n  u \\<le> t'\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)", "have \"0 < zcount (union_frontiers c loc3) (results_in u s)\""], ["proof (prove)\nusing this:\n  u \\<le> t'\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (1 subgoal):\n 1. 0 < zcount\n         (\\<Sum>loc'\\<in>UNIV.\n            after_summary\n             (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n             (summary loc' loc3))\n         (results_in u s)", "apply (subst zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < (\\<Sum>M\\<in>UNIV.\n                             zcount\n                              (after_summary\n                                (zmset_of\n                                  (mset_set\n                                    (set_antichain (frontier (c_imp c M)))))\n                                (summary M loc3))\n                              (results_in u s))", "apply (rule sum_pos[where y=loc2])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> finite UNIV\n 2. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>M\\<in>UNIV.\n                         0 \\<le> zcount\n                                  (after_summary\n                                    (zmset_of\n(mset_set (set_antichain (frontier (c_imp c M)))))\n                                    (summary M loc3))\n                                  (results_in u s)\n 3. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> loc2 \\<in> UNIV\n 4. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount\n                           (after_summary\n                             (zmset_of\n                               (mset_set\n                                 (set_antichain (frontier (c_imp c loc2)))))\n                             (summary loc2 loc3))\n                           (results_in u s)", "apply simp_all [3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount\n                           (after_summary\n                             (zmset_of\n                               (mset_set\n                                 (set_antichain (frontier (c_imp c loc2)))))\n                             (summary loc2 loc3))\n                           (results_in u s)", "apply (clarsimp simp: after_summary_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount\n                           (\\<Sum>s\\<in>set_antichain (summary loc2 loc3).\n                              {#results_in t s\n                              . t \\<in>#\\<^sub>z zmset_of\n            (mset_set (set_antichain (frontier (c_imp c loc2))))#})\n                           (results_in u s)", "apply (subst zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < (\\<Sum>M\\<in>set_antichain (summary loc2 loc3).\n                             zcount\n                              {#results_in t M\n                              . t \\<in>#\\<^sub>z zmset_of\n            (mset_set (set_antichain (frontier (c_imp c loc2))))#}\n                              (results_in u s))", "apply (rule sum_pos[where y=s])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> finite (set_antichain (summary loc2 loc3))\n 2. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>M\\<in>set_antichain (summary loc2 loc3).\n                         0 \\<le> zcount\n                                  {#results_in t M\n                                  . t \\<in>#\\<^sub>z zmset_of\n                (mset_set (set_antichain (frontier (c_imp c loc2))))#}\n                                  (results_in u s)\n 3. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> s \\<in> set_antichain (summary loc2 loc3)\n 4. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount\n                           {#results_in t s\n                           . t \\<in>#\\<^sub>z zmset_of\n         (mset_set (set_antichain (frontier (c_imp c loc2))))#}\n                           (results_in u s)", "using 2(3)"], ["proof (prove)\nusing this:\n  s \\<in>\\<^sub>A summary loc2 loc3\n\ngoal (4 subgoals):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> finite (set_antichain (summary loc2 loc3))\n 2. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>M\\<in>set_antichain (summary loc2 loc3).\n                         0 \\<le> zcount\n                                  {#results_in t M\n                                  . t \\<in>#\\<^sub>z zmset_of\n                (mset_set (set_antichain (frontier (c_imp c loc2))))#}\n                                  (results_in u s)\n 3. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> s \\<in> set_antichain (summary loc2 loc3)\n 4. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount\n                           {#results_in t s\n                           . t \\<in>#\\<^sub>z zmset_of\n         (mset_set (set_antichain (frontier (c_imp c loc2))))#}\n                           (results_in u s)", "apply simp_all [3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount\n                           {#results_in t s\n                           . t \\<in>#\\<^sub>z zmset_of\n         (mset_set (set_antichain (frontier (c_imp c loc2))))#}\n                           (results_in u s)", "apply (subst zcount_image_zmset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < sum (zcount\n                                (zmset_of\n                                  (mset_set\n                                    (set_antichain\n(frontier (c_imp c loc2))))))\n                           ((\\<lambda>t. results_in t s) -`\n                            {results_in u s} \\<inter>\n                            set_zmset\n                             (zmset_of\n                               (mset_set\n                                 (set_antichain\n                                   (frontier (c_imp c loc2))))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < card\n                           ((\\<lambda>t. results_in t s) -`\n                            {results_in u s} \\<inter>\n                            set_zmset\n                             (zmset_of\n                               (mset_set\n                                 (set_antichain\n                                   (frontier (c_imp c loc2))))))", "apply (subst card_eq_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < (\\<Sum>x\\<in>(\\<lambda>t. results_in t s) -`\n {results_in u s} \\<inter>\n set_zmset (zmset_of (mset_set (set_antichain (frontier (c_imp c loc2))))).\n                             1)", "apply (rule sum_pos[where y=u])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>t. results_in t s) -`\n                        {results_in u s} \\<inter>\n                        set_zmset\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c loc2))))))\n 2. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>(\\<lambda>t. results_in t s) -`\n                                     {results_in u s} \\<inter>\n                                     set_zmset\n(zmset_of (mset_set (set_antichain (frontier (c_imp c loc2))))).\n                         0 \\<le> 1\n 3. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> u \\<in> (\\<lambda>t. results_in t s) -`\n                              {results_in u s} \\<inter>\n                              set_zmset\n                               (zmset_of\n                                 (mset_set\n                                   (set_antichain\n                                     (frontier (c_imp c loc2)))))\n 4. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < 1", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc3))\n       (results_in u s)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "then"], ["proof (chain)\npicking this:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc3))\n       (results_in u s)", "have \"0 < zcount (zmset_frontier (c_pts c loc3)) (results_in u s) + zcount (union_frontiers c loc3) (results_in u s)\""], ["proof (prove)\nusing this:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc3))\n       (results_in u s)\n\ngoal (1 subgoal):\n 1. 0 < zcount\n         (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))))\n         (results_in u s) +\n        zcount\n         (\\<Sum>loc'\\<in>UNIV.\n            after_summary\n             (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n             (summary loc' loc3))\n         (results_in u s)", "by (auto intro: add_nonneg_pos)"], ["proof (state)\nthis:\n  0 < zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))))\n       (results_in u s) +\n      zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc3))\n       (results_in u s)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "with riu_le_rit'"], ["proof (chain)\npicking this:\n  results_in u s \\<le> t\n  0 < zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))))\n       (results_in u s) +\n      zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc3))\n       (results_in u s)", "have ?thesis"], ["proof (prove)\nusing this:\n  results_in u s \\<le> t\n  0 < zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))))\n       (results_in u s) +\n      zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc3))\n       (results_in u s)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "apply (subst (asm) zcount_union[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>results_in u s \\<le> t;\n     0 < zcount\n          (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n           (\\<Sum>loc'\\<in>UNIV.\n              after_summary\n               (zmset_of\n                 (mset_set (set_antichain (frontier (c_imp c loc')))))\n               (summary loc' loc3)))\n          (results_in u s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<le>t.\n                         s \\<in>\\<^sub>A frontier (c_imp c loc3)", "apply (subst iiws)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>results_in u s \\<le> t;\n     0 < zcount\n          (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n           (\\<Sum>loc'\\<in>UNIV.\n              after_summary\n               (zmset_of\n                 (mset_set (set_antichain (frontier (c_imp c loc')))))\n               (summary loc' loc3)))\n          (results_in u s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<le>t.\n                         s \\<in>\\<^sub>A frontier\n    (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n     (\\<Sum>loc'\\<in>UNIV.\n        after_summary\n         (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n         (summary loc' loc3)))", "apply (erule obtain_elem_frontier)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>results_in u s \\<le> t;\n        sa \\<le> results_in u s \\<and>\n        sa \\<in>\\<^sub>A frontier\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_pts c loc3)))) +\n                           (\\<Sum>loc'\\<in>UNIV.\n                              after_summary\n                               (zmset_of\n                                 (mset_set\n                                   (set_antichain\n                                     (frontier (c_imp c loc')))))\n                               (summary loc' loc3)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier\n       (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n        (\\<Sum>loc'\\<in>UNIV.\n           after_summary\n            (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n            (summary loc' loc3)))", "subgoal for u'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>results_in u s \\<le> t;\n     u' \\<le> results_in u s \\<and>\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<le>t.\n                         s \\<in>\\<^sub>A frontier\n    (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n     (\\<Sum>loc'\\<in>UNIV.\n        after_summary\n         (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n         (summary loc' loc3)))", "by (auto intro!: exI[of _ u'])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "}"], ["proof (state)\nthis:\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "moreover"], ["proof (state)\nthis:\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "{ \\<comment> \\<open>Same as induction base case\\<close>"], ["proof (state)\nthis:\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "assume \"0 < zcount (c_imp c loc3) t\""], ["proof (state)\nthis:\n  0 < zcount (c_imp c loc3) t\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "then"], ["proof (chain)\npicking this:\n  0 < zcount (c_imp c loc3) t", "have ?thesis"], ["proof (prove)\nusing this:\n  0 < zcount (c_imp c loc3) t\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "by (auto elim: obtain_elem_frontier)"], ["proof (state)\nthis:\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "}"], ["proof (state)\nthis:\n  0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "moreover"], ["proof (state)\nthis:\n  0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "note disj"], ["proof (state)\nthis:\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<or>\n  0 < zcount (c_imp c loc3) t\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "ultimately"], ["proof (chain)\npicking this:\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n  0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<or>\n  0 < zcount (c_imp c loc3) t", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n  0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<or>\n  0 < zcount (c_imp c loc3) t\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma loc_imps_fw_M_nonneg[simp]:\n  assumes \"loc_imps_fw c loc1 loc2 M xs\"\n    and   \"inv_implications_nonneg c\"\n  shows \"0 \\<le> zcount M t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> zcount M t", "using assms"], ["proof (prove)\nusing this:\n  loc_imps_fw c loc1 loc2 M xs\n  inv_implications_nonneg c\n\ngoal (1 subgoal):\n 1. 0 \\<le> zcount M t", "by (induct arbitrary: t rule: loc_imps_fw.induct)\n    (auto intro!: add_nonneg_nonneg sum_nonneg simp: zcount_image_zmset assms(2)[unfolded inv_implications_nonneg_def])"], ["", "lemma loc_imps_fw_implication_in_M:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"loc_imps_fw c loc1 loc2 M xs\"\n    and   \"0 < zcount (c_imp c loc1) t\"\n  shows   \"0 < zcount M (results_in t (sum_path_weights xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount M\n         (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))", "using assms(3,4)"], ["proof (prove)\nusing this:\n  loc_imps_fw c loc1 loc2 M xs\n  0 < zcount (c_imp c loc1) t\n\ngoal (1 subgoal):\n 1. 0 < zcount M\n         (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))", "proof (induct rule: loc_imps_fw.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>loc.\n       0 < zcount (c_imp c loc) t \\<Longrightarrow>\n       0 < zcount (c_imp c loc)\n            (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) [])))\n 2. \\<And>loc1 loc2 M xs s loc3.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        0 < zcount (c_imp c loc1) t \\<Longrightarrow>\n        0 < zcount M\n             (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)));\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount (c_imp c loc1) t\\<rbrakk>\n       \\<Longrightarrow> 0 < zcount\n                              ({#results_in t s. t \\<in>#\\<^sub>z M#} +\n                               c_imp c loc3)\n                              (results_in t\n                                (sum_weights\n                                  (map (\\<lambda>(s, l, t). l)\n                                    (xs @ [(loc2, s, loc3)]))))", "note iiws = assms(1)[unfolded inv_imps_work_sum_def assms(3), simplified, rule_format]"], ["proof (state)\nthis:\n  c_imp c ?loc + c_work c ?loc =\n  zmset_of (mset_set (set_antichain (frontier (c_pts c ?loc)))) +\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n      (summary loc' ?loc))\n\ngoal (2 subgoals):\n 1. \\<And>loc.\n       0 < zcount (c_imp c loc) t \\<Longrightarrow>\n       0 < zcount (c_imp c loc)\n            (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) [])))\n 2. \\<And>loc1 loc2 M xs s loc3.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        0 < zcount (c_imp c loc1) t \\<Longrightarrow>\n        0 < zcount M\n             (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)));\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount (c_imp c loc1) t\\<rbrakk>\n       \\<Longrightarrow> 0 < zcount\n                              ({#results_in t s. t \\<in>#\\<^sub>z M#} +\n                               c_imp c loc3)\n                              (results_in t\n                                (sum_weights\n                                  (map (\\<lambda>(s, l, t). l)\n                                    (xs @ [(loc2, s, loc3)]))))", "case (1 loc)"], ["proof (state)\nthis:\n  0 < zcount (c_imp c loc) t\n\ngoal (2 subgoals):\n 1. \\<And>loc.\n       0 < zcount (c_imp c loc) t \\<Longrightarrow>\n       0 < zcount (c_imp c loc)\n            (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) [])))\n 2. \\<And>loc1 loc2 M xs s loc3.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        0 < zcount (c_imp c loc1) t \\<Longrightarrow>\n        0 < zcount M\n             (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)));\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount (c_imp c loc1) t\\<rbrakk>\n       \\<Longrightarrow> 0 < zcount\n                              ({#results_in t s. t \\<in>#\\<^sub>z M#} +\n                               c_imp c loc3)\n                              (results_in t\n                                (sum_weights\n                                  (map (\\<lambda>(s, l, t). l)\n                                    (xs @ [(loc2, s, loc3)]))))", "then"], ["proof (chain)\npicking this:\n  0 < zcount (c_imp c loc) t", "show ?case"], ["proof (prove)\nusing this:\n  0 < zcount (c_imp c loc) t\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc)\n         (results_in t\n           (sum_weights\n             (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) [])))", "by (simp add: results_in_zero)"], ["proof (state)\nthis:\n  0 < zcount (c_imp c loc)\n       (results_in t\n         (sum_weights\n           (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) [])))\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        0 < zcount (c_imp c loc1) t \\<Longrightarrow>\n        0 < zcount M\n             (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)));\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount (c_imp c loc1) t\\<rbrakk>\n       \\<Longrightarrow> 0 < zcount\n                              ({#results_in t s. t \\<in>#\\<^sub>z M#} +\n                               c_imp c loc3)\n                              (results_in t\n                                (sum_weights\n                                  (map (\\<lambda>(s, l, t). l)\n                                    (xs @ [(loc2, s, loc3)]))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        0 < zcount (c_imp c loc1) t \\<Longrightarrow>\n        0 < zcount M\n             (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)));\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount (c_imp c loc1) t\\<rbrakk>\n       \\<Longrightarrow> 0 < zcount\n                              ({#results_in t s. t \\<in>#\\<^sub>z M#} +\n                               c_imp c loc3)\n                              (results_in t\n                                (sum_weights\n                                  (map (\\<lambda>(s, l, t). l)\n                                    (xs @ [(loc2, s, loc3)]))))", "case (2 loc1 loc2 M xs s loc3)"], ["proof (state)\nthis:\n  loc_imps_fw c loc1 loc2 M xs\n  0 < zcount (c_imp c loc1) t \\<Longrightarrow>\n  0 < zcount M\n       (results_in t\n         (sum_weights\n           (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l) xs)))\n  s \\<in>\\<^sub>A summary loc2 loc3\n  distinct (xs @ [(loc2, s, loc3)])\n  0 < zcount (c_imp c loc1) t\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        0 < zcount (c_imp c loc1) t \\<Longrightarrow>\n        0 < zcount M\n             (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)));\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount (c_imp c loc1) t\\<rbrakk>\n       \\<Longrightarrow> 0 < zcount\n                              ({#results_in t s. t \\<in>#\\<^sub>z M#} +\n                               c_imp c loc3)\n                              (results_in t\n                                (sum_weights\n                                  (map (\\<lambda>(s, l, t). l)\n                                    (xs @ [(loc2, s, loc3)]))))", "have \"0 < zcount M (results_in t (sum_path_weights xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount M\n         (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))", "by (rule 2(2)[OF 2(5)])"], ["proof (state)\nthis:\n  0 < zcount M (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        0 < zcount (c_imp c loc1) t \\<Longrightarrow>\n        0 < zcount M\n             (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)));\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]);\n        0 < zcount (c_imp c loc1) t\\<rbrakk>\n       \\<Longrightarrow> 0 < zcount\n                              ({#results_in t s. t \\<in>#\\<^sub>z M#} +\n                               c_imp c loc3)\n                              (results_in t\n                                (sum_weights\n                                  (map (\\<lambda>(s, l, t). l)\n                                    (xs @ [(loc2, s, loc3)]))))", "then"], ["proof (chain)\npicking this:\n  0 < zcount M (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))", "show ?case"], ["proof (prove)\nusing this:\n  0 < zcount M (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n\ngoal (1 subgoal):\n 1. 0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n         (results_in t\n           (sum_weights\n             (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n               (xs @ [(loc2, s, loc3)]))))", "apply (subst results_in_sum_path_weights_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n         (results_in\n           (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs))) s)", "apply (subst zcount_union)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#}\n         (results_in\n           (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n           s) +\n        zcount (c_imp c loc3)\n         (results_in\n           (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs))) s)", "apply (rule add_pos_nonneg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#}\n         (results_in\n           (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs))) s)\n 2. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    0 \\<le> zcount (c_imp c loc3)\n             (results_in\n               (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n               s)", "apply (subst zcount_image_zmset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    0 < sum (zcount M)\n         ((\\<lambda>t. results_in t s) -`\n          {results_in\n            (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n            s} \\<inter>\n          set_zmset M)\n 2. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    0 \\<le> zcount (c_imp c loc3)\n             (results_in\n               (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n               s)", "apply (rule sum_pos[where y = \"results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs))\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    finite\n     ((\\<lambda>t. results_in t s) -`\n      {results_in\n        (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n        s} \\<inter>\n      set_zmset M)\n 2. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    \\<forall>x\\<in>(\\<lambda>t. results_in t s) -`\n                   {results_in\n                     (results_in t\n                       (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n                     s} \\<inter>\n                   set_zmset M.\n       0 \\<le> zcount M x\n 3. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n    \\<in> (\\<lambda>t. results_in t s) -`\n          {results_in\n            (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n            s} \\<inter>\n          set_zmset M\n 4. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    0 < zcount M\n         (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n 5. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    0 \\<le> zcount (c_imp c loc3)\n             (results_in\n               (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n               s)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    \\<forall>x\\<in>(\\<lambda>t. results_in t s) -`\n                   {results_in\n                     (results_in t\n                       (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n                     s} \\<inter>\n                   set_zmset M.\n       0 \\<le> zcount M x\n 2. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n    \\<in> (\\<lambda>t. results_in t s) -`\n          {results_in\n            (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n            s} \\<inter>\n          set_zmset M\n 3. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    0 < zcount M\n         (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n 4. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    0 \\<le> zcount (c_imp c loc3)\n             (results_in\n               (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n               s)", "apply (auto simp: loc_imps_fw_M_nonneg[OF 2(1) assms(2)] zcount_inI) [3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount M\n         (results_in t\n           (sum_weights (map (\\<lambda>(s, l, t). l) xs))) \\<Longrightarrow>\n    0 \\<le> zcount (c_imp c loc3)\n             (results_in\n               (results_in t (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n               s)", "apply (auto simp: assms(2)[unfolded inv_implications_nonneg_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n       (results_in t\n         (sum_weights\n           (map (\\<lambda>a. case a of (s, l, t) \\<Rightarrow> l)\n             (xs @ [(loc2, s, loc3)]))))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition impl_safe :: \"('loc, 't) configuration \\<Rightarrow> bool\" where\n  \"impl_safe c \\<equiv> \\<forall>loc1 loc2 t s. zcount (c_imp c loc1) t > 0 \\<and> s \\<in>\\<^sub>A path_summary loc1 loc2\n                   \\<longrightarrow> (\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and> t' \\<le> results_in t s)\""], ["", "lemma impl_safe:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"\\<And>loc. c_work c loc = {#}\\<^sub>z\"\n  shows   \"impl_safe c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_safe c", "unfolding impl_safe_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>loc1 loc2 t s.\n       0 < zcount (c_imp c loc1) t \\<and>\n       s \\<in>\\<^sub>A path_summary loc1 loc2 \\<longrightarrow>\n       (\\<exists>t'.\n           t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n           t' \\<le> results_in t s)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_imp c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n                            t' \\<le> results_in t s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_imp c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n                            t' \\<le> results_in t s", "note iiws = assms(1)[unfolded inv_imps_work_sum_def assms(3), simplified, rule_format]"], ["proof (state)\nthis:\n  c_imp c ?loc =\n  zmset_of (mset_set (set_antichain (frontier (c_pts c ?loc)))) +\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n      (summary loc' ?loc))\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_imp c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n                            t' \\<le> results_in t s", "fix loc1 loc2 t s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_imp c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n                            t' \\<le> results_in t s", "assume \"0 < zcount (c_imp c loc1) t\""], ["proof (state)\nthis:\n  0 < zcount (c_imp c loc1) t\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_imp c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n                            t' \\<le> results_in t s", "then"], ["proof (chain)\npicking this:\n  0 < zcount (c_imp c loc1) t", "obtain t' where t': \"t' \\<in>\\<^sub>A frontier (c_imp c loc1)\" \"t' \\<le> t\""], ["proof (prove)\nusing this:\n  0 < zcount (c_imp c loc1) t\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in>\\<^sub>A frontier (c_imp c loc1);\n         t' \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: obtain_elem_frontier)"], ["proof (state)\nthis:\n  t' \\<in>\\<^sub>A frontier (c_imp c loc1)\n  t' \\<le> t\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_imp c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n                            t' \\<le> results_in t s", "then"], ["proof (chain)\npicking this:\n  t' \\<in>\\<^sub>A frontier (c_imp c loc1)\n  t' \\<le> t", "have t'_zcount: \"0 < zcount (c_imp c loc1) t'\""], ["proof (prove)\nusing this:\n  t' \\<in>\\<^sub>A frontier (c_imp c loc1)\n  t' \\<le> t\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc1) t'", "by (simp add: member_frontier_pos_zmset)"], ["proof (state)\nthis:\n  0 < zcount (c_imp c loc1) t'\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_imp c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n                            t' \\<le> results_in t s", "assume path_sum: \"s \\<in>\\<^sub>A path_summary loc1 loc2\""], ["proof (state)\nthis:\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_imp c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n                            t' \\<le> results_in t s", "obtain M xs where Mxs: \"loc_imps_fw c loc1 loc2 M xs\" \"sum_path_weights xs = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M xs.\n        \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n         sum_weights (map (\\<lambda>(s, l, t). l) xs) = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (rule path_summary_conv_loc_imps_fw[OF path_sum])"], ["proof (state)\nthis:\n  loc_imps_fw c loc1 loc2 M xs\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) = s\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_imp c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n                            t' \\<le> results_in t s", "have inM: \"0 < zcount M (results_in t' (sum_path_weights xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount M\n         (results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)))", "by (rule loc_imps_fw_implication_in_M[OF assms(1,2) Mxs(1) t'_zcount])"], ["proof (state)\nthis:\n  0 < zcount M\n       (results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_imp c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n                            t' \\<le> results_in t s", "obtain u where u: \"u \\<le> results_in t' (sum_path_weights xs)\" \"u \\<in>\\<^sub>A frontier (c_imp c loc2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<le> results_in t'\n                          (sum_weights (map (\\<lambda>(s, l, t). l) xs));\n         u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (rule loc_imps_fw_M_in_implications[OF Mxs(1) assms(1,2,3) inM])"], ["proof (state)\nthis:\n  u \\<le> results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_imp c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n                            t' \\<le> results_in t s", "then"], ["proof (chain)\npicking this:\n  u \\<le> results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)", "show \"\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and> t' \\<le> results_in t s\""], ["proof (prove)\nusing this:\n  u \\<le> results_in t' (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (1 subgoal):\n 1. \\<exists>t'.\n       t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n       t' \\<le> results_in t s", "apply (intro exI[of _ u])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> results_in t'\n                      (sum_weights (map (\\<lambda>(s, l, t). l) xs));\n     u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> u \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and>\n                      u \\<le> results_in t s", "apply (simp add: Mxs(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> results_in t' s;\n     u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> u \\<le> results_in t s", "using t'(2)"], ["proof (prove)\nusing this:\n  t' \\<le> t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> results_in t' s;\n     u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> u \\<le> results_in t s", "apply (meson order.trans results_in_mono(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>t'.\n     t' \\<in>\\<^sub>A frontier (c_imp c loc2) \\<and> t' \\<le> results_in t s\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>Safety for states where worklist is non-empty\\<close>"], ["", "lemma cm_preserves_impl_safe:\n  assumes \"impl_safe c0\"\n    and   \"next_change_multiplicity' c0 c1 loc t n\"\n  shows   \"impl_safe c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_safe c1", "using assms"], ["proof (prove)\nusing this:\n  impl_safe c0\n  next_change_multiplicity' c0 c1 loc t n\n\ngoal (1 subgoal):\n 1. impl_safe c1", "by (auto simp: impl_safe_def next_change_multiplicity'_def)"], ["", "lemma cm_preserves_safe:\n  assumes \"safe c0\"\n    and   \"impl_safe c0\"\n    and   \"next_change_multiplicity' c0 c1 loc t n\"\n  shows   \"safe c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe c1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. safe c1", "from assms(1)"], ["proof (chain)\npicking this:\n  safe c0", "have safe: \"0 < zcount (c_pts c0 loc1) t \\<Longrightarrow> s \\<in>\\<^sub>A path_summary loc1 loc2\n        \\<Longrightarrow> \\<exists>t'\\<le>results_in t s. t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\" for loc1 loc2 t s"], ["proof (prove)\nusing this:\n  safe c0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < zcount (c_pts c0 loc1) t;\n     s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "by (auto simp: safe_def)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < zcount (c_pts c0 ?loc1.3) ?t3;\n   ?s3 \\<in>\\<^sub>A path_summary ?loc1.3 ?loc2.3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t'\\<le>results_in ?t3 ?s3.\n                       t' \\<in>\\<^sub>A frontier (c_imp c0 ?loc2.3)\n\ngoal (1 subgoal):\n 1. safe c1", "from assms(2)"], ["proof (chain)\npicking this:\n  impl_safe c0", "have impl_safe: \"0 < zcount (c_imp c0 loc1) t \\<Longrightarrow> s \\<in>\\<^sub>A path_summary loc1 loc2\n        \\<Longrightarrow> \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc2) \\<and> t' \\<le> results_in t s\" for loc1 loc2 t s"], ["proof (prove)\nusing this:\n  impl_safe c0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < zcount (c_imp c0 loc1) t;\n     s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2) \\<and>\n                         t' \\<le> results_in t s", "by (auto simp: impl_safe_def)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < zcount (c_imp c0 ?loc1.3) ?t3;\n   ?s3 \\<in>\\<^sub>A path_summary ?loc1.3 ?loc2.3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t'.\n                       t' \\<in>\\<^sub>A frontier (c_imp c0 ?loc2.3) \\<and>\n                       t' \\<le> results_in ?t3 ?s3\n\ngoal (1 subgoal):\n 1. safe c1", "from assms(3)"], ["proof (chain)\npicking this:\n  next_change_multiplicity' c0 c1 loc t n", "have imps: \"c_imp c1 = c_imp c0\""], ["proof (prove)\nusing this:\n  next_change_multiplicity' c0 c1 loc t n\n\ngoal (1 subgoal):\n 1. c_imp c1 = c_imp c0", "unfolding next_change_multiplicity'_def"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>\n\ngoal (1 subgoal):\n 1. c_imp c1 = c_imp c0", "by auto"], ["proof (state)\nthis:\n  c_imp c1 = c_imp c0\n\ngoal (1 subgoal):\n 1. safe c1", "{"], ["proof (state)\nthis:\n  c_imp c1 = c_imp c0\n\ngoal (1 subgoal):\n 1. safe c1", "fix loc1 loc2 u s \\<comment> \\<open>`safe c1` variables\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. safe c1", "assume u: \"0 < zcount (c_pts c1 loc1) u\""], ["proof (state)\nthis:\n  0 < zcount (c_pts c1 loc1) u\n\ngoal (1 subgoal):\n 1. safe c1", "then"], ["proof (chain)\npicking this:\n  0 < zcount (c_pts c1 loc1) u", "obtain u' where u': \"u' \\<in>\\<^sub>A frontier (c_pts c1 loc1)\" \"u' \\<le> u\""], ["proof (prove)\nusing this:\n  0 < zcount (c_pts c1 loc1) u\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>u' \\<in>\\<^sub>A frontier (c_pts c1 loc1);\n         u' \\<le> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using obtain_frontier_elem"], ["proof (prove)\nusing this:\n  0 < zcount (c_pts c1 loc1) u\n  \\<lbrakk>0 < zcount ?M ?t;\n   \\<And>u.\n      \\<lbrakk>u \\<in>\\<^sub>A frontier ?M; u \\<le> ?t\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>u' \\<in>\\<^sub>A frontier (c_pts c1 loc1);\n         u' \\<le> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u' \\<in>\\<^sub>A frontier (c_pts c1 loc1)\n  u' \\<le> u\n\ngoal (1 subgoal):\n 1. safe c1", "assume path_sum: \"s \\<in>\\<^sub>A path_summary loc1 loc2\"\n      \\<comment> \\<open>CM state changes:\\<close>"], ["proof (state)\nthis:\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n\ngoal (1 subgoal):\n 1. safe c1", "assume n_neq_zero: \"n \\<noteq> 0\""], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. safe c1", "assume impl: \"\\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\""], ["proof (state)\nthis:\n  \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\n\ngoal (1 subgoal):\n 1. safe c1", "assume pointstamps:\n      \"\\<forall>loc'. c_pts c1 loc' =\n                    (if loc' = loc then update_zmultiset (c_pts c0 loc') t n\n                                   else c_pts c0 loc')\""], ["proof (state)\nthis:\n  \\<forall>loc'.\n     c_pts c1 loc' =\n     (if loc' = loc then update_zmultiset (c_pts c0 loc') t n\n      else c_pts c0 loc')\n\ngoal (1 subgoal):\n 1. safe c1", "have \"\\<exists>t'\\<le>results_in u s. t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)", "proof (cases \"n < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n < 0 \\<Longrightarrow>\n    \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)\n 2. \\<not> n < 0 \\<Longrightarrow>\n    \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)", "case True \\<comment> \\<open>Trivial, because no new pointstamp could have appeared\\<close>"], ["proof (state)\nthis:\n  n < 0\n\ngoal (2 subgoals):\n 1. n < 0 \\<Longrightarrow>\n    \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)\n 2. \\<not> n < 0 \\<Longrightarrow>\n    \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)", "with u"], ["proof (chain)\npicking this:\n  0 < zcount (c_pts c1 loc1) u\n  n < 0", "have u_c0: \"0 < zcount (c_pts c0 loc1) u\""], ["proof (prove)\nusing this:\n  0 < zcount (c_pts c1 loc1) u\n  n < 0\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_pts c0 loc1) u", "unfolding pointstamps[rule_format]"], ["proof (prove)\nusing this:\n  0 < zcount\n       (if loc1 = loc then update_zmultiset (c_pts c0 loc1) t n\n        else c_pts c0 loc1)\n       u\n  n < 0\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_pts c0 loc1) u", "by (cases \"loc1=loc\"; cases \"t=u\") (auto simp: zcount_update_zmultiset)"], ["proof (state)\nthis:\n  0 < zcount (c_pts c0 loc1) u\n\ngoal (2 subgoals):\n 1. n < 0 \\<Longrightarrow>\n    \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)\n 2. \\<not> n < 0 \\<Longrightarrow>\n    \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)", "unfolding imps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "by (rule safe[OF u_c0 path_sum])"], ["proof (state)\nthis:\n  \\<exists>t'\\<le>results_in u s. t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)\n\ngoal (1 subgoal):\n 1. \\<not> n < 0 \\<Longrightarrow>\n    \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < 0 \\<Longrightarrow>\n    \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)", "case False"], ["proof (state)\nthis:\n  \\<not> n < 0\n\ngoal (1 subgoal):\n 1. \\<not> n < 0 \\<Longrightarrow>\n    \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)", "with n_neq_zero"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  \\<not> n < 0", "have \"n > 0\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  \\<not> n < 0\n\ngoal (1 subgoal):\n 1. 0 < n", "by linarith"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<not> n < 0 \\<Longrightarrow>\n    \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)", "then"], ["proof (chain)\npicking this:\n  0 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)", "unfolding imps"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>t'\\<le>results_in u s.\n       t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "apply (cases \"loc=loc1\"; cases \"t=u\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < n; loc = loc1; 0 < n; t = u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\n 2. \\<lbrakk>0 < n; loc = loc1; 0 < n; t \\<noteq> u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\n 3. \\<lbrakk>0 < n; loc \\<noteq> loc1; 0 < n; t = u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\n 4. \\<lbrakk>0 < n; loc \\<noteq> loc1; 0 < n; t \\<noteq> u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "using impl"], ["proof (prove)\nusing this:\n  \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t\n\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < n; loc = loc1; 0 < n; t = u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\n 2. \\<lbrakk>0 < n; loc = loc1; 0 < n; t \\<noteq> u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\n 3. \\<lbrakk>0 < n; loc \\<noteq> loc1; 0 < n; t = u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\n 4. \\<lbrakk>0 < n; loc \\<noteq> loc1; 0 < n; t \\<noteq> u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "apply (elim exE conjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>0 < n; loc = loc1; 0 < n; t = u;\n        t' \\<in>\\<^sub>A frontier (c_imp c0 loc); t' \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\n 2. \\<lbrakk>0 < n; loc = loc1; 0 < n; t \\<noteq> u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\n 3. \\<lbrakk>0 < n; loc \\<noteq> loc1; 0 < n; t = u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\n 4. \\<lbrakk>0 < n; loc \\<noteq> loc1; 0 < n; t \\<noteq> u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "subgoal for t'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; loc = loc1; 0 < n; t = u;\n     t' \\<in>\\<^sub>A frontier (c_imp c0 loc); t' \\<le> t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>loc = loc1; 0 < n; t = u;\n     t' \\<in>\\<^sub>A frontier (c_imp c0 loc1); t' \\<le> u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "apply (drule member_frontier_pos_zmset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>loc = loc1; 0 < n; t = u; t' \\<le> u;\n     0 < zcount (c_imp c0 loc1) t'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "apply (drule impl_safe[rotated, OF path_sum])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>loc = loc1; 0 < n; t = u; t' \\<le> u;\n     \\<exists>t'a.\n        t'a \\<in>\\<^sub>A frontier (c_imp c0 loc2) \\<and>\n        t'a \\<le> results_in t' s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "apply (elim exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t'a.\n       \\<lbrakk>loc = loc1; 0 < n; t = u; t' \\<le> u;\n        t'a \\<in>\\<^sub>A frontier (c_imp c0 loc2) \\<and>\n        t'a \\<le> results_in t' s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "subgoal for t''"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>loc = loc1; 0 < n; t = u; t' \\<le> u;\n     t'' \\<in>\\<^sub>A frontier (c_imp c0 loc2) \\<and>\n     t'' \\<le> results_in t' s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "apply (rule exI[of _ t''])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>loc = loc1; 0 < n; t = u; t' \\<le> u;\n     t'' \\<in>\\<^sub>A frontier (c_imp c0 loc2) \\<and>\n     t'' \\<le> results_in t' s\\<rbrakk>\n    \\<Longrightarrow> t'' \\<le> results_in u s \\<and>\n                      t'' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "using results_in_mono(1) order_trans"], ["proof (prove)\nusing this:\n  ?t1.0 \\<le> ?t2.0 \\<Longrightarrow>\n  results_in ?t1.0 ?s \\<le> results_in ?t2.0 ?s\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>loc = loc1; 0 < n; t = u; t' \\<le> u;\n     t'' \\<in>\\<^sub>A frontier (c_imp c0 loc2) \\<and>\n     t'' \\<le> results_in t' s\\<rbrakk>\n    \\<Longrightarrow> t'' \\<le> results_in u s \\<and>\n                      t'' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < n; loc = loc1; 0 < n; t \\<noteq> u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\n 2. \\<lbrakk>0 < n; loc \\<noteq> loc1; 0 < n; t = u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\n 3. \\<lbrakk>0 < n; loc \\<noteq> loc1; 0 < n; t \\<noteq> u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "using u path_sum"], ["proof (prove)\nusing this:\n  0 < zcount (c_pts c1 loc1) u\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < n; loc = loc1; 0 < n; t \\<noteq> u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\n 2. \\<lbrakk>0 < n; loc \\<noteq> loc1; 0 < n; t = u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)\n 3. \\<lbrakk>0 < n; loc \\<noteq> loc1; 0 < n; t \\<noteq> u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in u s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c0 loc2)", "apply (auto simp: zcount_update_zmultiset pointstamps[rule_format] intro: safe)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>t'\\<le>results_in u s. t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t'\\<le>results_in u s. t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)\n\ngoal (1 subgoal):\n 1. safe c1", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < zcount (c_pts c1 ?loc1.5) ?u5;\n   ?s5 \\<in>\\<^sub>A path_summary ?loc1.5 ?loc2.5; n \\<noteq> 0;\n   \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t;\n   \\<forall>loc'.\n      c_pts c1 loc' =\n      (if loc' = loc then update_zmultiset (c_pts c0 loc') t n\n       else c_pts c0 loc')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t'\\<le>results_in ?u5 ?s5.\n                       t' \\<in>\\<^sub>A frontier (c_imp c1 ?loc2.5)\n\ngoal (1 subgoal):\n 1. safe c1", "note r = this"], ["proof (state)\nthis:\n  \\<lbrakk>0 < zcount (c_pts c1 ?loc1.5) ?u5;\n   ?s5 \\<in>\\<^sub>A path_summary ?loc1.5 ?loc2.5; n \\<noteq> 0;\n   \\<exists>t'. t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t;\n   \\<forall>loc'.\n      c_pts c1 loc' =\n      (if loc' = loc then update_zmultiset (c_pts c0 loc') t n\n       else c_pts c0 loc')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t'\\<le>results_in ?u5 ?s5.\n                       t' \\<in>\\<^sub>A frontier (c_imp c1 ?loc2.5)\n\ngoal (1 subgoal):\n 1. safe c1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. safe c1", "unfolding safe_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>loc1 loc2 t s.\n       0 < zcount (c_pts c1 loc1) t \\<and>\n       s \\<in>\\<^sub>A path_summary loc1 loc2 \\<longrightarrow>\n       (\\<exists>t'\\<le>results_in t s.\n           t' \\<in>\\<^sub>A frontier (c_imp c1 loc2))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c1 loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)", "subgoal for loc1 loc2 t s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < zcount (c_pts c1 loc1) t;\n     s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)", "using assms(3)[unfolded next_change_multiplicity'_def]"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<and>\n  (\\<exists>t'.\n      t' \\<in>\\<^sub>A frontier (c_imp c0 loc) \\<and> t' \\<le> t) \\<and>\n  c1 = c0\n  \\<lparr>c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),\n     c_work := (c_work c0)\n       (loc :=\n          c_work c0 loc +\n          frontier_changes (update_zmultiset (c_pts c0 loc) t n)\n           (c_pts c0 loc))\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < zcount (c_pts c1 loc1) t;\n     s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c1 loc2)", "by (intro r[of loc1 t s loc2]) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  safe c1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>A Better (More Invariant) Safety\\<close>"], ["", "definition worklists_vacant_to :: \"('loc, 't) configuration \\<Rightarrow> 't \\<Rightarrow> bool\" where\n  \"worklists_vacant_to c t =\n    (\\<forall>loc1 loc2 s t'. s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and> t' \\<in>#\\<^sub>z c_work c loc1 \\<longrightarrow> \\<not> results_in t' s \\<le> t)\""], ["", "definition inv_safe :: \"('loc, 't) configuration \\<Rightarrow> bool\" where\n  \"inv_safe c = (\\<forall>loc1 loc2 t s. 0 < zcount (c_pts c loc1) t\n                            \\<and> s \\<in>\\<^sub>A path_summary loc1 loc2\n                            \\<and> worklists_vacant_to c (results_in t s)\n                \\<longrightarrow> (\\<exists>t' \\<le> results_in t s. t' \\<in>\\<^sub>A frontier (c_imp c loc2)))\""], ["", "text\\<open>Intuition: Unlike safe, @{term inv_safe} is an invariant because it only claims the safety property\n@{term \"t' \\<in>\\<^sub>A frontier (c_imp c loc2)\"} for pointstamps that can't be modified by future propagated\nupdates anymore (i.e. there are no upstream worklist entries which can result in a less or equal pointstamp).\\<close>"], ["", "lemma in_frontier_diff: \"\\<forall>y\\<in>#\\<^sub>zN. \\<not> y \\<le> x \\<Longrightarrow> x \\<in>\\<^sub>A frontier (M - N) \\<longleftrightarrow> x \\<in>\\<^sub>A frontier M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>#\\<^sub>zN. \\<not> y \\<le> x \\<Longrightarrow>\n    (x \\<in>\\<^sub>A frontier (M - N)) = (x \\<in>\\<^sub>A frontier M)", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N x M.\n       \\<forall>y\\<in>#\\<^sub>zN. \\<not> y \\<le> x \\<Longrightarrow>\n       (x \\<in> minimal_antichain {t. 0 < zcount (M - N) t}) =\n       (x \\<in> minimal_antichain {t. 0 < zcount M t})", "unfolding in_minimal_antichain"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N x M.\n       \\<forall>y\\<in>#\\<^sub>zN. \\<not> y \\<le> x \\<Longrightarrow>\n       (x \\<in> {t. 0 < zcount (M - N) t} \\<and>\n        \\<not> (\\<exists>y\\<in>{t. 0 < zcount (M - N) t}. y < x)) =\n       (x \\<in> {t. 0 < zcount M t} \\<and>\n        \\<not> (\\<exists>y\\<in>{t. 0 < zcount M t}. y < x))", "apply (metis (mono_tags, lifting) diff_zero le_less mem_Collect_eq set_zmset_def zcount_diff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma worklists_vacant_to_trans:\n  \"worklists_vacant_to c t \\<Longrightarrow> t' \\<le> t \\<Longrightarrow> worklists_vacant_to c t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>worklists_vacant_to c t; t' \\<le> t\\<rbrakk>\n    \\<Longrightarrow> worklists_vacant_to c t'", "unfolding worklists_vacant_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>loc1 loc2 s t'.\n                s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                t' \\<in>#\\<^sub>z c_work c loc1 \\<longrightarrow>\n                \\<not> results_in t' s \\<le> t;\n     t' \\<le> t\\<rbrakk>\n    \\<Longrightarrow> \\<forall>loc1 loc2 s t'a.\n                         s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                         t'a \\<in>#\\<^sub>z c_work c loc1 \\<longrightarrow>\n                         \\<not> results_in t'a s \\<le> t'", "using order.trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>loc1 loc2 s t'.\n                s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                t' \\<in>#\\<^sub>z c_work c loc1 \\<longrightarrow>\n                \\<not> results_in t' s \\<le> t;\n     t' \\<le> t\\<rbrakk>\n    \\<Longrightarrow> \\<forall>loc1 loc2 s t'a.\n                         s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                         t'a \\<in>#\\<^sub>z c_work c loc1 \\<longrightarrow>\n                         \\<not> results_in t'a s \\<le> t'", "by blast"], ["", "lemma loc_imps_fw_M_in_implications':\n  assumes \"loc_imps_fw c loc1 loc2 M xs\"\n    and   \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"worklists_vacant_to c t\"\n    and   \"0 < zcount M t\"\n  shows   \"\\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2)", "using assms(1,4,5)"], ["proof (prove)\nusing this:\n  loc_imps_fw c loc1 loc2 M xs\n  worklists_vacant_to c t\n  0 < zcount M t\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc2)", "proof (induct arbitrary: t rule: loc_imps_fw.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>loc t.\n       \\<lbrakk>worklists_vacant_to c t; 0 < zcount (c_imp c loc) t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc)\n 2. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           \\<lbrakk>worklists_vacant_to c t; 0 < zcount M t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s\\<le>t.\n                                s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]); worklists_vacant_to c t;\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "note iiws = assms(2)[unfolded inv_imps_work_sum_def, rule_format]"], ["proof (state)\nthis:\n  c_imp c ?loc + c_work c ?loc =\n  zmset_of (mset_set (set_antichain (frontier (c_pts c ?loc)))) +\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n      (summary loc' ?loc))\n\ngoal (2 subgoals):\n 1. \\<And>loc t.\n       \\<lbrakk>worklists_vacant_to c t; 0 < zcount (c_imp c loc) t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc)\n 2. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           \\<lbrakk>worklists_vacant_to c t; 0 < zcount M t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s\\<le>t.\n                                s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]); worklists_vacant_to c t;\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "case (1 loc t)"], ["proof (state)\nthis:\n  worklists_vacant_to c t\n  0 < zcount (c_imp c loc) t\n\ngoal (2 subgoals):\n 1. \\<And>loc t.\n       \\<lbrakk>worklists_vacant_to c t; 0 < zcount (c_imp c loc) t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc)\n 2. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           \\<lbrakk>worklists_vacant_to c t; 0 < zcount M t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s\\<le>t.\n                                s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]); worklists_vacant_to c t;\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "then"], ["proof (chain)\npicking this:\n  worklists_vacant_to c t\n  0 < zcount (c_imp c loc) t", "show ?case"], ["proof (prove)\nusing this:\n  worklists_vacant_to c t\n  0 < zcount (c_imp c loc) t\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc)", "by (auto elim: obtain_elem_frontier)"], ["proof (state)\nthis:\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc)\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           \\<lbrakk>worklists_vacant_to c t; 0 < zcount M t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s\\<le>t.\n                                s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]); worklists_vacant_to c t;\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           \\<lbrakk>worklists_vacant_to c t; 0 < zcount M t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s\\<le>t.\n                                s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]); worklists_vacant_to c t;\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "note iiws = assms(2)[unfolded inv_imps_work_sum_def eq_diff_eq[symmetric], rule_format]"], ["proof (state)\nthis:\n  c_imp c ?loc =\n  zmset_of (mset_set (set_antichain (frontier (c_pts c ?loc)))) +\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n      (summary loc' ?loc)) -\n  c_work c ?loc\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           \\<lbrakk>worklists_vacant_to c t; 0 < zcount M t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s\\<le>t.\n                                s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]); worklists_vacant_to c t;\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "case (2 loc1 loc2 M xs s loc3 t)"], ["proof (state)\nthis:\n  loc_imps_fw c loc1 loc2 M xs\n  \\<lbrakk>worklists_vacant_to c ?t3; 0 < zcount M ?t3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s\\<le>?t3.\n                       s \\<in>\\<^sub>A frontier (c_imp c loc2)\n  s \\<in>\\<^sub>A summary loc2 loc3\n  distinct (xs @ [(loc2, s, loc3)])\n  worklists_vacant_to c t\n  0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3) t\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           \\<lbrakk>worklists_vacant_to c t; 0 < zcount M t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s\\<le>t.\n                                s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]); worklists_vacant_to c t;\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "from 2(6)"], ["proof (chain)\npicking this:\n  0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3) t", "consider \"0 < zcount {# results_in t s. t \\<in>#\\<^sub>z M #} t\" | \"0 < zcount (c_imp c loc3) t\""], ["proof (prove)\nusing this:\n  0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3) t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#}\n                  t \\<Longrightarrow>\n             thesis;\n     0 < zcount (c_imp c loc3) t \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by atomize_elim auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#}\n                t \\<Longrightarrow>\n           ?thesis3;\n   0 < zcount (c_imp c loc3) t \\<Longrightarrow> ?thesis3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 M xs s loc3 t.\n       \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n        \\<And>t.\n           \\<lbrakk>worklists_vacant_to c t; 0 < zcount M t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s\\<le>t.\n                                s \\<in>\\<^sub>A frontier (c_imp c loc2);\n        s \\<in>\\<^sub>A summary loc2 loc3;\n        distinct (xs @ [(loc2, s, loc3)]); worklists_vacant_to c t;\n        0 < zcount ({#results_in t s. t \\<in>#\\<^sub>z M#} + c_imp c loc3)\n             t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier (c_imp c loc3)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#}\n                t \\<Longrightarrow>\n           ?thesis3;\n   0 < zcount (c_imp c loc3) t \\<Longrightarrow> ?thesis3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#}\n                t \\<Longrightarrow>\n           ?thesis3;\n   0 < zcount (c_imp c loc3) t \\<Longrightarrow> ?thesis3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n 2. 0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "case 1"], ["proof (state)\nthis:\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t\n\ngoal (2 subgoals):\n 1. 0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n 2. 0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "then"], ["proof (chain)\npicking this:\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t", "obtain t' where t': \"results_in t' s = t\" \"0 < zcount M t'\""], ["proof (prove)\nusing this:\n  0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>results_in t' s = t; 0 < zcount M t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n    \\<exists>t'. results_in t' s = t \\<and> 0 < zcount M t'", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t;\n     \\<nexists>t'. results_in t' s = t \\<and> 0 < zcount M t'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (subst (asm) zcount_image_zmset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < sum (zcount M)\n                  ((\\<lambda>t. results_in t s) -` {t} \\<inter>\n                   set_zmset M);\n     \\<nexists>t'. results_in t' s = t \\<and> 0 < zcount M t'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (clarsimp simp: vimage_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < sum (zcount M)\n                  ({x. results_in x s = t} \\<inter> set_zmset M);\n     \\<forall>t'.\n        results_in t' s = t \\<longrightarrow>\n        \\<not> 0 < zcount M t'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis (mono_tags, lifting) Int_iff mem_Collect_eq sum_pos_ex_elem_pos)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  results_in t' s = t\n  0 < zcount M t'\n\ngoal (2 subgoals):\n 1. 0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n 2. 0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "have vacant_to: \"worklists_vacant_to c t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. worklists_vacant_to c t'", "apply (rule worklists_vacant_to_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. worklists_vacant_to c ?t\n 2. t' \\<le> ?t", "apply (rule 2(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<le> t", "using zero_le results_in_mono(2) results_in_zero t'(1)"], ["proof (prove)\nusing this:\n  (0::'sum) \\<le> ?s\n  ?s1.0 \\<le> ?s2.0 \\<Longrightarrow>\n  results_in ?t ?s1.0 \\<le> results_in ?t ?s2.0\n  results_in ?t (0::'sum) = ?t\n  results_in t' s = t\n\ngoal (1 subgoal):\n 1. t' \\<le> t", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  worklists_vacant_to c t'\n\ngoal (2 subgoals):\n 1. 0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n 2. 0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "obtain u where u: \"u \\<le> t'\" \"u \\<in>\\<^sub>A frontier (c_imp c loc2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<le> t';\n         u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2(2)[OF vacant_to t'(2)]"], ["proof (prove)\nusing this:\n  \\<exists>s\\<le>t'. s \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<le> t';\n         u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  u \\<le> t'\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (2 subgoals):\n 1. 0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n 2. 0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "then"], ["proof (chain)\npicking this:\n  u \\<le> t'\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)", "have riu_le_rit': \"results_in u s \\<le> t\""], ["proof (prove)\nusing this:\n  u \\<le> t'\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (1 subgoal):\n 1. results_in u s \\<le> t", "by (simp add: t'(1)[symmetric] results_in_mono)"], ["proof (state)\nthis:\n  results_in u s \\<le> t\n\ngoal (2 subgoals):\n 1. 0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n 2. 0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "from u"], ["proof (chain)\npicking this:\n  u \\<le> t'\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)", "have \"0 < zcount (union_frontiers c loc3) (results_in u s)\""], ["proof (prove)\nusing this:\n  u \\<le> t'\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (1 subgoal):\n 1. 0 < zcount\n         (\\<Sum>loc'\\<in>UNIV.\n            after_summary\n             (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n             (summary loc' loc3))\n         (results_in u s)", "apply (subst zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < (\\<Sum>M\\<in>UNIV.\n                             zcount\n                              (after_summary\n                                (zmset_of\n                                  (mset_set\n                                    (set_antichain (frontier (c_imp c M)))))\n                                (summary M loc3))\n                              (results_in u s))", "apply (rule sum_pos[where y=loc2])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> finite UNIV\n 2. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>M\\<in>UNIV.\n                         0 \\<le> zcount\n                                  (after_summary\n                                    (zmset_of\n(mset_set (set_antichain (frontier (c_imp c M)))))\n                                    (summary M loc3))\n                                  (results_in u s)\n 3. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> loc2 \\<in> UNIV\n 4. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount\n                           (after_summary\n                             (zmset_of\n                               (mset_set\n                                 (set_antichain (frontier (c_imp c loc2)))))\n                             (summary loc2 loc3))\n                           (results_in u s)", "apply simp_all [3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount\n                           (after_summary\n                             (zmset_of\n                               (mset_set\n                                 (set_antichain (frontier (c_imp c loc2)))))\n                             (summary loc2 loc3))\n                           (results_in u s)", "apply (clarsimp simp: after_summary_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount\n                           (\\<Sum>s\\<in>set_antichain (summary loc2 loc3).\n                              {#results_in t s\n                              . t \\<in>#\\<^sub>z zmset_of\n            (mset_set (set_antichain (frontier (c_imp c loc2))))#})\n                           (results_in u s)", "apply (subst zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < (\\<Sum>M\\<in>set_antichain (summary loc2 loc3).\n                             zcount\n                              {#results_in t M\n                              . t \\<in>#\\<^sub>z zmset_of\n            (mset_set (set_antichain (frontier (c_imp c loc2))))#}\n                              (results_in u s))", "apply (rule sum_pos[where y=s])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> finite (set_antichain (summary loc2 loc3))\n 2. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>M\\<in>set_antichain (summary loc2 loc3).\n                         0 \\<le> zcount\n                                  {#results_in t M\n                                  . t \\<in>#\\<^sub>z zmset_of\n                (mset_set (set_antichain (frontier (c_imp c loc2))))#}\n                                  (results_in u s)\n 3. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> s \\<in> set_antichain (summary loc2 loc3)\n 4. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount\n                           {#results_in t s\n                           . t \\<in>#\\<^sub>z zmset_of\n         (mset_set (set_antichain (frontier (c_imp c loc2))))#}\n                           (results_in u s)", "using 2(3)"], ["proof (prove)\nusing this:\n  s \\<in>\\<^sub>A summary loc2 loc3\n\ngoal (4 subgoals):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> finite (set_antichain (summary loc2 loc3))\n 2. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>M\\<in>set_antichain (summary loc2 loc3).\n                         0 \\<le> zcount\n                                  {#results_in t M\n                                  . t \\<in>#\\<^sub>z zmset_of\n                (mset_set (set_antichain (frontier (c_imp c loc2))))#}\n                                  (results_in u s)\n 3. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> s \\<in> set_antichain (summary loc2 loc3)\n 4. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount\n                           {#results_in t s\n                           . t \\<in>#\\<^sub>z zmset_of\n         (mset_set (set_antichain (frontier (c_imp c loc2))))#}\n                           (results_in u s)", "apply simp_all [3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount\n                           {#results_in t s\n                           . t \\<in>#\\<^sub>z zmset_of\n         (mset_set (set_antichain (frontier (c_imp c loc2))))#}\n                           (results_in u s)", "apply (subst zcount_image_zmset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < sum (zcount\n                                (zmset_of\n                                  (mset_set\n                                    (set_antichain\n(frontier (c_imp c loc2))))))\n                           ((\\<lambda>t. results_in t s) -`\n                            {results_in u s} \\<inter>\n                            set_zmset\n                             (zmset_of\n                               (mset_set\n                                 (set_antichain\n                                   (frontier (c_imp c loc2))))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < card\n                           ((\\<lambda>t. results_in t s) -`\n                            {results_in u s} \\<inter>\n                            set_zmset\n                             (zmset_of\n                               (mset_set\n                                 (set_antichain\n                                   (frontier (c_imp c loc2))))))", "apply (subst card_eq_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < (\\<Sum>x\\<in>(\\<lambda>t. results_in t s) -`\n {results_in u s} \\<inter>\n set_zmset (zmset_of (mset_set (set_antichain (frontier (c_imp c loc2))))).\n                             1)", "apply (rule sum_pos[where y=u])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>t. results_in t s) -`\n                        {results_in u s} \\<inter>\n                        set_zmset\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_imp c loc2))))))\n 2. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>(\\<lambda>t. results_in t s) -`\n                                     {results_in u s} \\<inter>\n                                     set_zmset\n(zmset_of (mset_set (set_antichain (frontier (c_imp c loc2))))).\n                         0 \\<le> 1\n 3. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> u \\<in> (\\<lambda>t. results_in t s) -`\n                              {results_in u s} \\<inter>\n                              set_zmset\n                               (zmset_of\n                                 (mset_set\n                                   (set_antichain\n                                     (frontier (c_imp c loc2)))))\n 4. \\<lbrakk>u \\<le> t'; u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> 0 < 1", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc3))\n       (results_in u s)\n\ngoal (2 subgoals):\n 1. 0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n 2. 0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "then"], ["proof (chain)\npicking this:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc3))\n       (results_in u s)", "have \"0 < zcount (zmset_frontier (c_pts c loc3)) (results_in u s) + zcount (union_frontiers c loc3) (results_in u s)\""], ["proof (prove)\nusing this:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc3))\n       (results_in u s)\n\ngoal (1 subgoal):\n 1. 0 < zcount\n         (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))))\n         (results_in u s) +\n        zcount\n         (\\<Sum>loc'\\<in>UNIV.\n            after_summary\n             (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n             (summary loc' loc3))\n         (results_in u s)", "by (auto intro: add_nonneg_pos)"], ["proof (state)\nthis:\n  0 < zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))))\n       (results_in u s) +\n      zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc3))\n       (results_in u s)\n\ngoal (2 subgoals):\n 1. 0 < zcount {#results_in t s. t \\<in>#\\<^sub>z M#} t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n 2. 0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "with riu_le_rit'"], ["proof (chain)\npicking this:\n  results_in u s \\<le> t\n  0 < zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))))\n       (results_in u s) +\n      zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc3))\n       (results_in u s)", "show ?thesis"], ["proof (prove)\nusing this:\n  results_in u s \\<le> t\n  0 < zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))))\n       (results_in u s) +\n      zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc3))\n       (results_in u s)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "apply (subst (asm) zcount_union[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>results_in u s \\<le> t;\n     0 < zcount\n          (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n           (\\<Sum>loc'\\<in>UNIV.\n              after_summary\n               (zmset_of\n                 (mset_set (set_antichain (frontier (c_imp c loc')))))\n               (summary loc' loc3)))\n          (results_in u s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<le>t.\n                         s \\<in>\\<^sub>A frontier (c_imp c loc3)", "apply (subst iiws)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>results_in u s \\<le> t;\n     0 < zcount\n          (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n           (\\<Sum>loc'\\<in>UNIV.\n              after_summary\n               (zmset_of\n                 (mset_set (set_antichain (frontier (c_imp c loc')))))\n               (summary loc' loc3)))\n          (results_in u s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<le>t.\n                         s \\<in>\\<^sub>A frontier\n    (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n     (\\<Sum>loc'\\<in>UNIV.\n        after_summary\n         (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n         (summary loc' loc3)) -\n     c_work c loc3)", "apply (erule obtain_elem_frontier)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>results_in u s \\<le> t;\n        sa \\<le> results_in u s \\<and>\n        sa \\<in>\\<^sub>A frontier\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_pts c loc3)))) +\n                           (\\<Sum>loc'\\<in>UNIV.\n                              after_summary\n                               (zmset_of\n                                 (mset_set\n                                   (set_antichain\n                                     (frontier (c_imp c loc')))))\n                               (summary loc' loc3)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<le>t.\n                            s \\<in>\\<^sub>A frontier\n       (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n        (\\<Sum>loc'\\<in>UNIV.\n           after_summary\n            (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n            (summary loc' loc3)) -\n        c_work c loc3)", "subgoal for u'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>results_in u s \\<le> t;\n     u' \\<le> results_in u s \\<and>\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<le>t.\n                         s \\<in>\\<^sub>A frontier\n    (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n     (\\<Sum>loc'\\<in>UNIV.\n        after_summary\n         (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n         (summary loc' loc3)) -\n     c_work c loc3)", "apply (rule exI[of _ u'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>results_in u s \\<le> t;\n     u' \\<le> results_in u s \\<and>\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)))\\<rbrakk>\n    \\<Longrightarrow> u' \\<le> t \\<and>\n                      u' \\<in>\\<^sub>A frontier\n  (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n   (\\<Sum>loc'\\<in>UNIV.\n      after_summary\n       (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n       (summary loc' loc3)) -\n   c_work c loc3)", "apply (subst in_frontier_diff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>results_in u s \\<le> t;\n     u' \\<le> results_in u s \\<and>\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>#\\<^sub>zc_work c loc3.\n                         \\<not> y \\<le> u'\n 2. \\<lbrakk>results_in u s \\<le> t;\n     u' \\<le> results_in u s \\<and>\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)))\\<rbrakk>\n    \\<Longrightarrow> u' \\<le> t \\<and>\n                      u' \\<in>\\<^sub>A frontier\n  (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n   (\\<Sum>loc'\\<in>UNIV.\n      after_summary\n       (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n       (summary loc' loc3)))", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>results_in u s \\<le> t; y \\<in>#\\<^sub>z c_work c loc3;\n        u' \\<le> results_in u s;\n        u' \\<in>\\<^sub>A frontier\n                          (zmset_of\n                            (mset_set\n                              (set_antichain (frontier (c_pts c loc3)))) +\n                           (\\<Sum>loc'\\<in>UNIV.\n                              after_summary\n                               (zmset_of\n                                 (mset_set\n                                   (set_antichain\n                                     (frontier (c_imp c loc')))))\n                               (summary loc' loc3)));\n        y \\<le> u'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>results_in u s \\<le> t;\n     u' \\<le> results_in u s \\<and>\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)))\\<rbrakk>\n    \\<Longrightarrow> u' \\<le> t \\<and>\n                      u' \\<in>\\<^sub>A frontier\n  (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n   (\\<Sum>loc'\\<in>UNIV.\n      after_summary\n       (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n       (summary loc' loc3)))", "subgoal for t'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>results_in u s \\<le> t; t' \\<in>#\\<^sub>z c_work c loc3;\n     u' \\<le> results_in u s;\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)));\n     t' \\<le> u'\\<rbrakk>\n    \\<Longrightarrow> False", "using 2(5)[unfolded worklists_vacant_to_def, rule_format, of 0 loc3 loc3 t']"], ["proof (prove)\nusing this:\n  (0::'sum) \\<in>\\<^sub>A path_summary loc3 loc3 \\<and>\n  t' \\<in>#\\<^sub>z c_work c loc3 \\<Longrightarrow>\n  \\<not> results_in t' (0::'sum) \\<le> t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>results_in u s \\<le> t; t' \\<in>#\\<^sub>z c_work c loc3;\n     u' \\<le> results_in u s;\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)));\n     t' \\<le> u'\\<rbrakk>\n    \\<Longrightarrow> False", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>results_in u s \\<le> t; t' \\<in>#\\<^sub>z c_work c loc3;\n     u' \\<le> results_in u s;\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)));\n     t' \\<le> u';\n     (0::'sum) \\<in>\\<^sub>A path_summary loc3 loc3 \\<and>\n     t' \\<in>#\\<^sub>z c_work c loc3 \\<Longrightarrow>\n     \\<not> results_in t' (0::'sum) \\<le> t\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>results_in u s \\<le> t; t' \\<in>#\\<^sub>z c_work c loc3;\n     u' \\<le> results_in u s;\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)));\n     t' \\<le> u'\\<rbrakk>\n    \\<Longrightarrow> (0::'sum) \\<in>\\<^sub>A path_summary loc3 loc3 \\<and>\n                      t' \\<in>#\\<^sub>z c_work c loc3\n 2. \\<lbrakk>results_in u s \\<le> t; t' \\<in>#\\<^sub>z c_work c loc3;\n     u' \\<le> results_in u s;\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)));\n     t' \\<le> u'; \\<not> results_in t' (0::'sum) \\<le> t\\<rbrakk>\n    \\<Longrightarrow> False", "apply (intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>results_in u s \\<le> t; t' \\<in>#\\<^sub>z c_work c loc3;\n     u' \\<le> results_in u s;\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)));\n     t' \\<le> u'\\<rbrakk>\n    \\<Longrightarrow> (0::'sum) \\<in>\\<^sub>A path_summary loc3 loc3\n 2. \\<lbrakk>results_in u s \\<le> t; t' \\<in>#\\<^sub>z c_work c loc3;\n     u' \\<le> results_in u s;\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)));\n     t' \\<le> u'\\<rbrakk>\n    \\<Longrightarrow> t' \\<in>#\\<^sub>z c_work c loc3\n 3. \\<lbrakk>results_in u s \\<le> t; t' \\<in>#\\<^sub>z c_work c loc3;\n     u' \\<le> results_in u s;\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)));\n     t' \\<le> u'; \\<not> results_in t' (0::'sum) \\<le> t\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>results_in u s \\<le> t; t' \\<in>#\\<^sub>z c_work c loc3;\n     u' \\<le> results_in u s;\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)));\n     t' \\<le> u'\\<rbrakk>\n    \\<Longrightarrow> t' \\<in>#\\<^sub>z c_work c loc3\n 2. \\<lbrakk>results_in u s \\<le> t; t' \\<in>#\\<^sub>z c_work c loc3;\n     u' \\<le> results_in u s;\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)));\n     t' \\<le> u'; \\<not> results_in t' (0::'sum) \\<le> t\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>results_in u s \\<le> t; t' \\<in>#\\<^sub>z c_work c loc3;\n     u' \\<le> results_in u s;\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)));\n     t' \\<le> u'; \\<not> results_in t' (0::'sum) \\<le> t\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis order_trans results_in_zero)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>results_in u s \\<le> t;\n     u' \\<le> results_in u s \\<and>\n     u' \\<in>\\<^sub>A frontier\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc3)))) +\n                        (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of\n                              (mset_set\n                                (set_antichain (frontier (c_imp c loc')))))\n                            (summary loc' loc3)))\\<rbrakk>\n    \\<Longrightarrow> u' \\<le> t \\<and>\n                      u' \\<in>\\<^sub>A frontier\n  (zmset_of (mset_set (set_antichain (frontier (c_pts c loc3)))) +\n   (\\<Sum>loc'\\<in>UNIV.\n      after_summary\n       (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n       (summary loc' loc3)))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "case 2"], ["proof (state)\nthis:\n  0 < zcount (c_imp c loc3) t\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc3) t \\<Longrightarrow>\n    \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "then"], ["proof (chain)\npicking this:\n  0 < zcount (c_imp c loc3) t", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < zcount (c_imp c loc3) t\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)", "by (auto elim: obtain_elem_frontier)"], ["proof (state)\nthis:\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s\\<le>t. s \\<in>\\<^sub>A frontier (c_imp c loc3)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inv_safe:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n  shows   \"inv_safe c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_safe c", "unfolding inv_safe_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>loc1 loc2 t s.\n       0 < zcount (c_pts c loc1) t \\<and>\n       s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n       worklists_vacant_to c (results_in t s) \\<longrightarrow>\n       (\\<exists>t'\\<le>results_in t s.\n           t' \\<in>\\<^sub>A frontier (c_imp c loc2))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "note iiws = assms(1)[unfolded inv_imps_work_sum_def, rule_format]"], ["proof (state)\nthis:\n  c_imp c ?loc + c_work c ?loc =\n  zmset_of (mset_set (set_antichain (frontier (c_pts c ?loc)))) +\n  (\\<Sum>loc'\\<in>UNIV.\n     after_summary\n      (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n      (summary loc' ?loc))\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "fix loc1 loc2 t s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "assume vacant: \"worklists_vacant_to c (results_in t s)\""], ["proof (state)\nthis:\n  worklists_vacant_to c (results_in t s)\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "assume \"0 < zcount (c_pts c loc1) t\""], ["proof (state)\nthis:\n  0 < zcount (c_pts c loc1) t\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "then"], ["proof (chain)\npicking this:\n  0 < zcount (c_pts c loc1) t", "obtain t' where t': \"t' \\<in>\\<^sub>A frontier (c_pts c loc1)\" \"t' \\<le> t\""], ["proof (prove)\nusing this:\n  0 < zcount (c_pts c loc1) t\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in>\\<^sub>A frontier (c_pts c loc1);\n         t' \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using obtain_frontier_elem"], ["proof (prove)\nusing this:\n  0 < zcount (c_pts c loc1) t\n  \\<lbrakk>0 < zcount ?M ?t;\n   \\<And>u.\n      \\<lbrakk>u \\<in>\\<^sub>A frontier ?M; u \\<le> ?t\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in>\\<^sub>A frontier (c_pts c loc1);\n         t' \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t' \\<in>\\<^sub>A frontier (c_pts c loc1)\n  t' \\<le> t\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "have zcount_wl: \"zcount (c_work c loc1) t' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (c_work c loc1) t' = 0", "using vacant[unfolded worklists_vacant_to_def, rule_format, of 0 loc1 loc1 t', simplified]"], ["proof (prove)\nusing this:\n  t' \\<in>#\\<^sub>z c_work c loc1 \\<Longrightarrow>\n  \\<not> results_in t' (0::'sum) \\<le> results_in t s\n\ngoal (1 subgoal):\n 1. zcount (c_work c loc1) t' = 0", "by (metis add.left_neutral order.trans le_plus(1) results_in_mono(2) results_in_zero t'(2) zcount_ne_zero_iff)"], ["proof (state)\nthis:\n  zcount (c_work c loc1) t' = 0\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "obtain t'' where t'': \"t'' \\<in>\\<^sub>A frontier (c_imp c loc1)\" \"t'' \\<le> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t''.\n        \\<lbrakk>t'' \\<in>\\<^sub>A frontier (c_imp c loc1);\n         t'' \\<le> t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof atomize_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t''.\n       t'' \\<in>\\<^sub>A frontier (c_imp c loc1) \\<and> t'' \\<le> t'", "from t'(1)"], ["proof (chain)\npicking this:\n  t' \\<in>\\<^sub>A frontier (c_pts c loc1)", "have \"0 < zcount (zmset_frontier (c_pts c loc1)) t' + zcount (union_frontiers c loc1) t'\""], ["proof (prove)\nusing this:\n  t' \\<in>\\<^sub>A frontier (c_pts c loc1)\n\ngoal (1 subgoal):\n 1. 0 < zcount\n         (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1)))))\n         t' +\n        zcount\n         (\\<Sum>loc'\\<in>UNIV.\n            after_summary\n             (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n             (summary loc' loc1))\n         t'", "by (auto intro: add_pos_nonneg simp: union_frontiers_nonneg)"], ["proof (state)\nthis:\n  0 < zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1)))))\n       t' +\n      zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc1))\n       t'\n\ngoal (1 subgoal):\n 1. \\<exists>t''.\n       t'' \\<in>\\<^sub>A frontier (c_imp c loc1) \\<and> t'' \\<le> t'", "then"], ["proof (chain)\npicking this:\n  0 < zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1)))))\n       t' +\n      zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc1))\n       t'", "show \"\\<exists>t''. t'' \\<in>\\<^sub>A frontier (c_imp c loc1) \\<and> t'' \\<le> t'\""], ["proof (prove)\nusing this:\n  0 < zcount (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1)))))\n       t' +\n      zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_imp c loc')))))\n           (summary loc' loc1))\n       t'\n\ngoal (1 subgoal):\n 1. \\<exists>t''.\n       t'' \\<in>\\<^sub>A frontier (c_imp c loc1) \\<and> t'' \\<le> t'", "apply (subst (asm) zcount_union[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount\n         (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1)))) +\n          (\\<Sum>loc'\\<in>UNIV.\n             after_summary\n              (zmset_of\n                (mset_set (set_antichain (frontier (c_imp c loc')))))\n              (summary loc' loc1)))\n         t' \\<Longrightarrow>\n    \\<exists>t''.\n       t'' \\<in>\\<^sub>A frontier (c_imp c loc1) \\<and> t'' \\<le> t'", "apply (subst (asm) iiws[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc1 + c_work c loc1) t' \\<Longrightarrow>\n    \\<exists>t''.\n       t'' \\<in>\\<^sub>A frontier (c_imp c loc1) \\<and> t'' \\<le> t'", "using zcount_wl"], ["proof (prove)\nusing this:\n  zcount (c_work c loc1) t' = 0\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc1 + c_work c loc1) t' \\<Longrightarrow>\n    \\<exists>t''.\n       t'' \\<in>\\<^sub>A frontier (c_imp c loc1) \\<and> t'' \\<le> t'", "apply (auto elim: obtain_frontier_elem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>t''.\n     t'' \\<in>\\<^sub>A frontier (c_imp c loc1) \\<and> t'' \\<le> t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t'' \\<in>\\<^sub>A frontier (c_imp c loc1)\n  t'' \\<le> t'\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "then"], ["proof (chain)\npicking this:\n  t'' \\<in>\\<^sub>A frontier (c_imp c loc1)\n  t'' \\<le> t'", "have t''_zcount: \"0 < zcount (c_imp c loc1) t''\""], ["proof (prove)\nusing this:\n  t'' \\<in>\\<^sub>A frontier (c_imp c loc1)\n  t'' \\<le> t'\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_imp c loc1) t''", "by (simp add: member_frontier_pos_zmset)"], ["proof (state)\nthis:\n  0 < zcount (c_imp c loc1) t''\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "assume path_sum: \"s \\<in>\\<^sub>A path_summary loc1 loc2\""], ["proof (state)\nthis:\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "obtain M xs where Mxs: \"loc_imps_fw c loc1 loc2 M xs\" \"sum_path_weights xs = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M xs.\n        \\<lbrakk>loc_imps_fw c loc1 loc2 M xs;\n         sum_weights (map (\\<lambda>(s, l, t). l) xs) = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (rule path_summary_conv_loc_imps_fw[OF path_sum])"], ["proof (state)\nthis:\n  loc_imps_fw c loc1 loc2 M xs\n  sum_weights (map (\\<lambda>(s, l, t). l) xs) = s\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "have inM: \"0 < zcount M (results_in t'' (sum_path_weights xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount M\n         (results_in t'' (sum_weights (map (\\<lambda>(s, l, t). l) xs)))", "by (rule loc_imps_fw_implication_in_M[OF assms(1,2) Mxs(1) t''_zcount])"], ["proof (state)\nthis:\n  0 < zcount M\n       (results_in t'' (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "have vacant2: \"worklists_vacant_to c (results_in t'' (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. worklists_vacant_to c\n     (results_in t'' (sum_weights (map (\\<lambda>(s, l, t). l) xs)))", "apply (subst Mxs(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. worklists_vacant_to c (results_in t'' s)", "apply (meson results_in_mono(1) worklists_vacant_to_trans t''(2) t'(2) vacant)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  worklists_vacant_to c\n   (results_in t'' (sum_weights (map (\\<lambda>(s, l, t). l) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "obtain u where u: \"u \\<le> results_in t'' (sum_path_weights xs)\" \"u \\<in>\\<^sub>A frontier (c_imp c loc2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<le> results_in t''\n                          (sum_weights (map (\\<lambda>(s, l, t). l) xs));\n         u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (rule loc_imps_fw_M_in_implications'[OF Mxs(1) assms(1,2) vacant2 inM])"], ["proof (state)\nthis:\n  u \\<le> results_in t'' (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (1 subgoal):\n 1. \\<And>loc1 loc2 t s.\n       \\<lbrakk>0 < zcount (c_pts c loc1) t;\n        s \\<in>\\<^sub>A path_summary loc1 loc2;\n        worklists_vacant_to c (results_in t s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                            t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "then"], ["proof (chain)\npicking this:\n  u \\<le> results_in t'' (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)", "show \"\\<exists>t'\\<le>results_in t s. t' \\<in>\\<^sub>A frontier (c_imp c loc2)\""], ["proof (prove)\nusing this:\n  u \\<le> results_in t'' (sum_weights (map (\\<lambda>(s, l, t). l) xs))\n  u \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (1 subgoal):\n 1. \\<exists>t'\\<le>results_in t s. t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "apply (intro exI[of _ u])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> results_in t''\n                      (sum_weights (map (\\<lambda>(s, l, t). l) xs));\n     u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> u \\<le> results_in t s \\<and>\n                      u \\<in>\\<^sub>A frontier (c_imp c loc2)", "apply (simp add: Mxs(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> results_in t'' s;\n     u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> u \\<le> results_in t s", "using t''(2) t'(2)"], ["proof (prove)\nusing this:\n  t'' \\<le> t'\n  t' \\<le> t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> results_in t'' s;\n     u \\<in>\\<^sub>A frontier (c_imp c loc2)\\<rbrakk>\n    \\<Longrightarrow> u \\<le> results_in t s", "apply (meson order.trans results_in_mono(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>t'\\<le>results_in t s. t' \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alw_conjI: \"alw P s \\<Longrightarrow> alw Q s \\<Longrightarrow> alw (\\<lambda>s. P s \\<and> Q s) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw P s; alw Q s\\<rbrakk>\n    \\<Longrightarrow> alw (\\<lambda>s. P s \\<and> Q s) s", "by (coinduction arbitrary: s) auto"], ["", "lemma alw_inv_safe: \"spec s \\<Longrightarrow> alw (holds inv_safe) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow> alw (holds inv_safe) s", "apply (frule spec_imp_iiws)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>spec s; alw (holds inv_imps_work_sum) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds inv_safe) s", "apply (drule alw_inv_implications_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (holds inv_imps_work_sum) s;\n     alw (holds inv_implications_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds inv_safe) s", "apply (rule alw_mp[where \\<phi> = \"\\<lambda>s. holds inv_imps_work_sum s \\<and> holds inv_implications_nonneg s\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>alw (holds inv_imps_work_sum) s;\n     alw (holds inv_implications_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (\\<lambda>s.\n                              holds inv_imps_work_sum s \\<and>\n                              holds inv_implications_nonneg s)\n                       s\n 2. \\<lbrakk>alw (holds inv_imps_work_sum) s;\n     alw (holds inv_implications_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (\\<lambda>xs.\n                              holds inv_imps_work_sum xs \\<and>\n                              holds inv_implications_nonneg\n                               xs \\<longrightarrow>\n                              holds inv_safe xs)\n                       s", "apply (rule alw_conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>alw (holds inv_imps_work_sum) s;\n     alw (holds inv_implications_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds inv_imps_work_sum) s\n 2. \\<lbrakk>alw (holds inv_imps_work_sum) s;\n     alw (holds inv_implications_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds inv_implications_nonneg) s\n 3. \\<lbrakk>alw (holds inv_imps_work_sum) s;\n     alw (holds inv_implications_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (\\<lambda>xs.\n                              holds inv_imps_work_sum xs \\<and>\n                              holds inv_implications_nonneg\n                               xs \\<longrightarrow>\n                              holds inv_safe xs)\n                       s", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (holds inv_imps_work_sum) s;\n     alw (holds inv_implications_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (\\<lambda>xs.\n                              holds inv_imps_work_sum xs \\<and>\n                              holds inv_implications_nonneg\n                               xs \\<longrightarrow>\n                              holds inv_safe xs)\n                       s", "apply (simp add: alw_mono inv_safe)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma empty_worklists_vacant_to: \"\\<forall>loc. c_work c loc = {#}\\<^sub>z \\<Longrightarrow> worklists_vacant_to c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>loc. c_work c loc = {#}\\<^sub>z \\<Longrightarrow>\n    worklists_vacant_to c t", "unfolding worklists_vacant_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>loc. c_work c loc = {#}\\<^sub>z \\<Longrightarrow>\n    \\<forall>loc1 loc2 s t'.\n       s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n       t' \\<in>#\\<^sub>z c_work c loc1 \\<longrightarrow>\n       \\<not> results_in t' s \\<le> t", "by auto"], ["", "lemma inv_safe_safe: \"(\\<And>loc. c_work c loc = {#}\\<^sub>z) \\<Longrightarrow> inv_safe c \\<Longrightarrow> safe c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>loc. c_work c loc = {#}\\<^sub>z; inv_safe c\\<rbrakk>\n    \\<Longrightarrow> safe c", "unfolding inv_safe_def safe_def worklists_vacant_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>loc. c_work c loc = {#}\\<^sub>z;\n     \\<forall>loc1 loc2 t s.\n        0 < zcount (c_pts c loc1) t \\<and>\n        s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n        (\\<forall>loc1 loc2 sa t'.\n            sa \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n            t' \\<in>#\\<^sub>z c_work c loc1 \\<longrightarrow>\n            \\<not> results_in t' sa \\<le> results_in t s) \\<longrightarrow>\n        (\\<exists>t'\\<le>results_in t s.\n            t' \\<in>\\<^sub>A frontier (c_imp c loc2))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>loc1 loc2 t s.\n                         0 < zcount (c_pts c loc1) t \\<and>\n                         s \\<in>\\<^sub>A path_summary loc1\n    loc2 \\<longrightarrow>\n                         (\\<exists>t'\\<le>results_in t s.\n                             t' \\<in>\\<^sub>A frontier (c_imp c loc2))", "by auto"], ["", "lemma safe:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"\\<And>loc. c_work c loc = {#}\\<^sub>z\"\n  shows   \"safe c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe c", "by (rule inv_safe_safe[OF assms(3) inv_safe[OF assms(1,2)]])"], ["", "subsection \\<open>Implied Frontier\\<close>"], ["", "abbreviation zmset_pos where \"zmset_pos M \\<equiv> zmset_of (mset_pos M)\""], ["", "definition implied_frontier where\n  \"implied_frontier P loc = frontier (\\<Sum>loc'\\<in>UNIV. after_summary (zmset_pos (P loc')) (path_summary loc' loc))\""], ["", "definition implied_frontier_alt where\n  \"implied_frontier_alt c loc = frontier (\\<Sum>loc'\\<in>UNIV. after_summary (zmset_frontier (c_pts c loc')) (path_summary loc' loc))\""], ["", "lemma in_frontier_least: \"x \\<in>\\<^sub>A frontier M \\<Longrightarrow> \\<forall>y. 0 < zcount M y \\<longrightarrow> \\<not> y < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in>\\<^sub>A frontier M \\<Longrightarrow>\n    \\<forall>y. 0 < zcount M y \\<longrightarrow> \\<not> y < x", "by transfer' (auto simp: minimal_antichain_def)"], ["", "lemma in_frontier_trans: \"0 < zcount M y \\<Longrightarrow> x \\<in>\\<^sub>A frontier M \\<Longrightarrow> y \\<le> x \\<Longrightarrow> y \\<in>\\<^sub>A frontier M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < zcount M y; x \\<in>\\<^sub>A frontier M; y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> y \\<in>\\<^sub>A frontier M", "by transfer (simp add: le_less minimal_antichain_def)"], ["", "lemma implied_frontier_alt_least:\n  assumes \"b \\<in>\\<^sub>A implied_frontier_alt c loc2\"\n  shows \"\\<forall>loc a' s'. a' \\<in>\\<^sub>A frontier (c_pts c loc) \\<longrightarrow> s' \\<in>\\<^sub>A path_summary loc loc2 \\<longrightarrow> \\<not> results_in a' s' < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>loc a' s'.\n       a' \\<in>\\<^sub>A frontier (c_pts c loc) \\<longrightarrow>\n       s' \\<in>\\<^sub>A path_summary loc loc2 \\<longrightarrow>\n       \\<not> results_in a' s' < b", "proof (intro allI impI notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>loc a' s'.\n       \\<lbrakk>a' \\<in>\\<^sub>A frontier (c_pts c loc);\n        s' \\<in>\\<^sub>A path_summary loc loc2;\n        results_in a' s' < b\\<rbrakk>\n       \\<Longrightarrow> False", "fix loc a' s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>loc a' s'.\n       \\<lbrakk>a' \\<in>\\<^sub>A frontier (c_pts c loc);\n        s' \\<in>\\<^sub>A path_summary loc loc2;\n        results_in a' s' < b\\<rbrakk>\n       \\<Longrightarrow> False", "assume a': \"a' \\<in>\\<^sub>A frontier (c_pts c loc)\""], ["proof (state)\nthis:\n  a' \\<in>\\<^sub>A frontier (c_pts c loc)\n\ngoal (1 subgoal):\n 1. \\<And>loc a' s'.\n       \\<lbrakk>a' \\<in>\\<^sub>A frontier (c_pts c loc);\n        s' \\<in>\\<^sub>A path_summary loc loc2;\n        results_in a' s' < b\\<rbrakk>\n       \\<Longrightarrow> False", "assume s': \"s' \\<in>\\<^sub>A path_summary loc loc2\""], ["proof (state)\nthis:\n  s' \\<in>\\<^sub>A path_summary loc loc2\n\ngoal (1 subgoal):\n 1. \\<And>loc a' s'.\n       \\<lbrakk>a' \\<in>\\<^sub>A frontier (c_pts c loc);\n        s' \\<in>\\<^sub>A path_summary loc loc2;\n        results_in a' s' < b\\<rbrakk>\n       \\<Longrightarrow> False", "assume lt: \"results_in a' s' < b\""], ["proof (state)\nthis:\n  results_in a' s' < b\n\ngoal (1 subgoal):\n 1. \\<And>loc a' s'.\n       \\<lbrakk>a' \\<in>\\<^sub>A frontier (c_pts c loc);\n        s' \\<in>\\<^sub>A path_summary loc loc2;\n        results_in a' s' < b\\<rbrakk>\n       \\<Longrightarrow> False", "have \"0 < zcount (after_summary (zmset_frontier (c_pts c loc)) (path_summary loc loc2)) (results_in a' s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount\n         (after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_pts c loc)))))\n           (path_summary loc loc2))\n         (results_in a' s')", "using a' s'"], ["proof (prove)\nusing this:\n  a' \\<in>\\<^sub>A frontier (c_pts c loc)\n  s' \\<in>\\<^sub>A path_summary loc loc2\n\ngoal (1 subgoal):\n 1. 0 < zcount\n         (after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_pts c loc)))))\n           (path_summary loc loc2))\n         (results_in a' s')", "by (auto intro!: pos_zcount_after_summary)"], ["proof (state)\nthis:\n  0 < zcount\n       (after_summary\n         (zmset_of (mset_set (set_antichain (frontier (c_pts c loc)))))\n         (path_summary loc loc2))\n       (results_in a' s')\n\ngoal (1 subgoal):\n 1. \\<And>loc a' s'.\n       \\<lbrakk>a' \\<in>\\<^sub>A frontier (c_pts c loc);\n        s' \\<in>\\<^sub>A path_summary loc loc2;\n        results_in a' s' < b\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < zcount\n       (after_summary\n         (zmset_of (mset_set (set_antichain (frontier (c_pts c loc)))))\n         (path_summary loc loc2))\n       (results_in a' s')", "have \"0 < zcount (\\<Sum>loc'\\<in>UNIV. after_summary (zmset_frontier (c_pts c loc')) (path_summary loc' loc2)) (results_in a' s')\""], ["proof (prove)\nusing this:\n  0 < zcount\n       (after_summary\n         (zmset_of (mset_set (set_antichain (frontier (c_pts c loc)))))\n         (path_summary loc loc2))\n       (results_in a' s')\n\ngoal (1 subgoal):\n 1. 0 < zcount\n         (\\<Sum>loc'\\<in>UNIV.\n            after_summary\n             (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n             (path_summary loc' loc2))\n         (results_in a' s')", "by (auto intro!: sum_pos[where y = loc] simp: zcount_sum)"], ["proof (state)\nthis:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n           (path_summary loc' loc2))\n       (results_in a' s')\n\ngoal (1 subgoal):\n 1. \\<And>loc a' s'.\n       \\<lbrakk>a' \\<in>\\<^sub>A frontier (c_pts c loc);\n        s' \\<in>\\<^sub>A path_summary loc loc2;\n        results_in a' s' < b\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n           (path_summary loc' loc2))\n       (results_in a' s')", "have \"results_in a' s' \\<in>\\<^sub>A implied_frontier_alt c loc2\""], ["proof (prove)\nusing this:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n           (path_summary loc' loc2))\n       (results_in a' s')\n\ngoal (1 subgoal):\n 1. results_in a' s' \\<in>\\<^sub>A implied_frontier_alt c loc2", "using assms lt"], ["proof (prove)\nusing this:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n           (path_summary loc' loc2))\n       (results_in a' s')\n  b \\<in>\\<^sub>A implied_frontier_alt c loc2\n  results_in a' s' < b\n\ngoal (1 subgoal):\n 1. results_in a' s' \\<in>\\<^sub>A implied_frontier_alt c loc2", "unfolding implied_frontier_alt_def"], ["proof (prove)\nusing this:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n           (path_summary loc' loc2))\n       (results_in a' s')\n  b \\<in>\\<^sub>A frontier\n                   (\\<Sum>loc'\\<in>UNIV.\n                      after_summary\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc')))))\n                       (path_summary loc' loc2))\n  results_in a' s' < b\n\ngoal (1 subgoal):\n 1. results_in a' s'\n    \\<in>\\<^sub>A frontier\n                   (\\<Sum>loc'\\<in>UNIV.\n                      after_summary\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc')))))\n                       (path_summary loc' loc2))", "by (auto dest!: in_frontier_trans[where y = \"results_in a' s'\" and x = b])"], ["proof (state)\nthis:\n  results_in a' s' \\<in>\\<^sub>A implied_frontier_alt c loc2\n\ngoal (1 subgoal):\n 1. \\<And>loc a' s'.\n       \\<lbrakk>a' \\<in>\\<^sub>A frontier (c_pts c loc);\n        s' \\<in>\\<^sub>A path_summary loc loc2;\n        results_in a' s' < b\\<rbrakk>\n       \\<Longrightarrow> False", "with lt assms"], ["proof (chain)\npicking this:\n  results_in a' s' < b\n  b \\<in>\\<^sub>A implied_frontier_alt c loc2\n  results_in a' s' \\<in>\\<^sub>A implied_frontier_alt c loc2", "show \"False\""], ["proof (prove)\nusing this:\n  results_in a' s' < b\n  b \\<in>\\<^sub>A implied_frontier_alt c loc2\n  results_in a' s' \\<in>\\<^sub>A implied_frontier_alt c loc2\n\ngoal (1 subgoal):\n 1. False", "unfolding implied_frontier_alt_def"], ["proof (prove)\nusing this:\n  results_in a' s' < b\n  b \\<in>\\<^sub>A frontier\n                   (\\<Sum>loc'\\<in>UNIV.\n                      after_summary\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc')))))\n                       (path_summary loc' loc2))\n  results_in a' s'\n  \\<in>\\<^sub>A frontier\n                 (\\<Sum>loc'\\<in>UNIV.\n                    after_summary\n                     (zmset_of\n                       (mset_set (set_antichain (frontier (c_pts c loc')))))\n                     (path_summary loc' loc2))\n\ngoal (1 subgoal):\n 1. False", "using frontier_comparable_False"], ["proof (prove)\nusing this:\n  results_in a' s' < b\n  b \\<in>\\<^sub>A frontier\n                   (\\<Sum>loc'\\<in>UNIV.\n                      after_summary\n                       (zmset_of\n                         (mset_set\n                           (set_antichain (frontier (c_pts c loc')))))\n                       (path_summary loc' loc2))\n  results_in a' s'\n  \\<in>\\<^sub>A frontier\n                 (\\<Sum>loc'\\<in>UNIV.\n                    after_summary\n                     (zmset_of\n                       (mset_set (set_antichain (frontier (c_pts c loc')))))\n                     (path_summary loc' loc2))\n  \\<lbrakk>?x \\<in>\\<^sub>A frontier ?M; ?y \\<in>\\<^sub>A frontier ?M;\n   ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma implied_frontier_alt_in_pointstamps:\n  assumes \"b \\<in>\\<^sub>A implied_frontier_alt c loc2\"\n  obtains a s loc1 where\n    \"a \\<in>\\<^sub>A frontier (c_pts c loc1)\" \"s \\<in>\\<^sub>A path_summary loc1 loc2\" \"results_in a s = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a loc1 s.\n        \\<lbrakk>a \\<in>\\<^sub>A frontier (c_pts c loc1);\n         s \\<in>\\<^sub>A path_summary loc1 loc2; results_in a s = b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  b \\<in>\\<^sub>A implied_frontier_alt c loc2\n\ngoal (1 subgoal):\n 1. (\\<And>a loc1 s.\n        \\<lbrakk>a \\<in>\\<^sub>A frontier (c_pts c loc1);\n         s \\<in>\\<^sub>A path_summary loc1 loc2; results_in a s = b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2 \\<Longrightarrow>\n    \\<exists>a loc1 s.\n       a \\<in>\\<^sub>A frontier (c_pts c loc1) \\<and>\n       s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and> results_in a s = b", "unfolding implied_frontier_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A frontier\n                     (\\<Sum>loc'\\<in>UNIV.\n                        after_summary\n                         (zmset_of\n                           (mset_set\n                             (set_antichain (frontier (c_pts c loc')))))\n                         (path_summary loc' loc2)) \\<Longrightarrow>\n    \\<exists>a loc1 s.\n       a \\<in>\\<^sub>A frontier (c_pts c loc1) \\<and>\n       s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and> results_in a s = b", "apply (drule member_frontier_pos_zmset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount\n         (\\<Sum>loc'\\<in>UNIV.\n            after_summary\n             (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n             (path_summary loc' loc2))\n         b \\<Longrightarrow>\n    \\<exists>a loc1 s.\n       a \\<in>\\<^sub>A frontier (c_pts c loc1) \\<and>\n       s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and> results_in a s = b", "apply (subst (asm) zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (\\<Sum>M\\<in>UNIV.\n           zcount\n            (after_summary\n              (zmset_of (mset_set (set_antichain (frontier (c_pts c M)))))\n              (path_summary M loc2))\n            b) \\<Longrightarrow>\n    \\<exists>a loc1 s.\n       a \\<in>\\<^sub>A frontier (c_pts c loc1) \\<and>\n       s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and> results_in a s = b", "apply (drule sum_pos_ex_elem_pos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>UNIV.\n       0 < zcount\n            (after_summary\n              (zmset_of (mset_set (set_antichain (frontier (c_pts c M)))))\n              (path_summary M loc2))\n            b \\<Longrightarrow>\n    \\<exists>a loc1 s.\n       a \\<in>\\<^sub>A frontier (c_pts c loc1) \\<and>\n       s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and> results_in a s = b", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>M \\<in> UNIV;\n        0 < zcount\n             (after_summary\n               (zmset_of (mset_set (set_antichain (frontier (c_pts c M)))))\n               (path_summary M loc2))\n             b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a loc1 s.\n                            a \\<in>\\<^sub>A frontier (c_pts c loc1) \\<and>\n                            s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                            results_in a s = b", "apply (rule after_summary_obtain_pre[rotated])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>M \\<in> UNIV;\n        0 < zcount\n             (after_summary\n               (zmset_of (mset_set (set_antichain (frontier (c_pts c M)))))\n               (path_summary M loc2))\n             b\\<rbrakk>\n       \\<Longrightarrow> 0 < zcount (after_summary (?M13 M) (?S13 M))\n                              (?t13 M)\n 2. \\<And>M t' s.\n       \\<lbrakk>M \\<in> UNIV;\n        0 < zcount\n             (after_summary\n               (zmset_of (mset_set (set_antichain (frontier (c_pts c M)))))\n               (path_summary M loc2))\n             b;\n        0 < zcount (?M13 M) t'; results_in t' s = ?t13 M;\n        s \\<in>\\<^sub>A ?S13 M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a loc1 s.\n                            a \\<in>\\<^sub>A frontier (c_pts c loc1) \\<and>\n                            s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                            results_in a s = b\n 3. \\<And>M t.\n       \\<lbrakk>M \\<in> UNIV;\n        0 < zcount\n             (after_summary\n               (zmset_of (mset_set (set_antichain (frontier (c_pts c M)))))\n               (path_summary M loc2))\n             b\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount (?M13 M) t", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M t' s.\n       \\<lbrakk>M \\<in> UNIV;\n        0 < zcount\n             (after_summary\n               (zmset_of (mset_set (set_antichain (frontier (c_pts c M)))))\n               (path_summary M loc2))\n             b;\n        0 < zcount\n             (zmset_of (mset_set (set_antichain (frontier (c_pts c M)))))\n             t';\n        results_in t' s = b; s \\<in>\\<^sub>A path_summary M loc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a loc1 s.\n                            a \\<in>\\<^sub>A frontier (c_pts c loc1) \\<and>\n                            s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                            results_in a s = b\n 2. \\<And>M t.\n       \\<lbrakk>M \\<in> UNIV;\n        0 < zcount\n             (after_summary\n               (zmset_of (mset_set (set_antichain (frontier (c_pts c M)))))\n               (path_summary M loc2))\n             b\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount\n                                  (zmset_of\n                                    (mset_set\n(set_antichain (frontier (c_pts c M)))))\n                                  t", "subgoal for loc1 a s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>loc1 \\<in> UNIV;\n     0 < zcount\n          (after_summary\n            (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1)))))\n            (path_summary loc1 loc2))\n          b;\n     0 < zcount\n          (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1))))) a;\n     results_in a s = b; s \\<in>\\<^sub>A path_summary loc1 loc2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a loc1 s.\n                         a \\<in>\\<^sub>A frontier (c_pts c loc1) \\<and>\n                         s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                         results_in a s = b", "by (auto intro!: exI[of _ loc1] exI[of _ a] exI[of _ s])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M t.\n       \\<lbrakk>M \\<in> UNIV;\n        0 < zcount\n             (after_summary\n               (zmset_of (mset_set (set_antichain (frontier (c_pts c M)))))\n               (path_summary M loc2))\n             b\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount\n                                  (zmset_of\n                                    (mset_set\n(set_antichain (frontier (c_pts c M)))))\n                                  t", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma in_implied_frontier_alt_in_implication_frontier:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"worklists_vacant_to c b\"\n    and   \"b \\<in>\\<^sub>A implied_frontier_alt c loc2\"\n  shows   \"b \\<in>\\<^sub>A frontier (c_imp c loc2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A frontier (c_imp c loc2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A frontier (c_imp c loc2)", "have safe: \"0 < zcount (c_pts c loc1) t \\<Longrightarrow> s \\<in>\\<^sub>A path_summary loc1 loc2 \\<Longrightarrow> results_in t s \\<le> b\n        \\<Longrightarrow> \\<exists>t'\\<le>results_in t s. t' \\<in>\\<^sub>A frontier (c_imp c loc2)\" for loc1 loc2 t s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < zcount (c_pts c loc1) t;\n     s \\<in>\\<^sub>A path_summary loc1 loc2; results_in t s \\<le> b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "by (rule inv_safe[OF assms(1,2), unfolded inv_safe_def, rule_format])\n      (auto elim: worklists_vacant_to_trans[OF assms(3)])\n      \\<comment> \\<open>Pointstamp @{term b} in the @{term implied_frontier_alt} is caused by a pointstamp @{term a} and summary @{term s}\n          and @{term \"results_in a s\"} is least among such pointstamps\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>0 < zcount (c_pts c ?loc1.4) ?t4;\n   ?s4 \\<in>\\<^sub>A path_summary ?loc1.4 ?loc2.4;\n   results_in ?t4 ?s4 \\<le> b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t'\\<le>results_in ?t4 ?s4.\n                       t' \\<in>\\<^sub>A frontier (c_imp c ?loc2.4)\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A frontier (c_imp c loc2)", "from assms(4)"], ["proof (chain)\npicking this:\n  b \\<in>\\<^sub>A implied_frontier_alt c loc2", "obtain loc1 a s where loc1_a_s:\n    \"a \\<in>\\<^sub>A frontier (c_pts c loc1)\" \"s \\<in>\\<^sub>A path_summary loc1 loc2\" \"results_in a s = b\"\n    \"\\<forall>loc a' s'. a' \\<in>\\<^sub>A frontier (c_pts c loc) \\<longrightarrow> s' \\<in>\\<^sub>A path_summary loc loc2 \\<longrightarrow> \\<not> results_in a' s' < b\""], ["proof (prove)\nusing this:\n  b \\<in>\\<^sub>A implied_frontier_alt c loc2\n\ngoal (1 subgoal):\n 1. (\\<And>a loc1 s.\n        \\<lbrakk>a \\<in>\\<^sub>A frontier (c_pts c loc1);\n         s \\<in>\\<^sub>A path_summary loc1 loc2; results_in a s = b;\n         \\<forall>loc a' s'.\n            a' \\<in>\\<^sub>A frontier (c_pts c loc) \\<longrightarrow>\n            s' \\<in>\\<^sub>A path_summary loc loc2 \\<longrightarrow>\n            \\<not> results_in a' s' < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2 \\<Longrightarrow>\n    \\<exists>a loc1 s.\n       a \\<in>\\<^sub>A frontier (c_pts c loc1) \\<and>\n       s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n       results_in a s = b \\<and>\n       (\\<forall>loc a' s'.\n           a' \\<in>\\<^sub>A frontier (c_pts c loc) \\<longrightarrow>\n           s' \\<in>\\<^sub>A path_summary loc loc2 \\<longrightarrow>\n           \\<not> results_in a' s' < b)", "apply (rule implied_frontier_alt_in_pointstamps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2 \\<Longrightarrow>\n    ?b7 \\<in>\\<^sub>A implied_frontier_alt ?c7 ?loc2.7\n 2. \\<And>a s loc1.\n       \\<lbrakk>b \\<in>\\<^sub>A implied_frontier_alt c loc2;\n        a \\<in>\\<^sub>A frontier (c_pts ?c7 loc1);\n        s \\<in>\\<^sub>A path_summary loc1 ?loc2.7;\n        results_in a s = ?b7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a loc1 s.\n                            a \\<in>\\<^sub>A frontier (c_pts c loc1) \\<and>\n                            s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                            results_in a s = b \\<and>\n                            (\\<forall>loc a' s'.\n                                a' \\<in>\\<^sub>A frontier\n            (c_pts c loc) \\<longrightarrow>\n                                s' \\<in>\\<^sub>A path_summary loc\n            loc2 \\<longrightarrow>\n                                \\<not> results_in a' s' < b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a s loc1.\n       \\<lbrakk>b \\<in>\\<^sub>A implied_frontier_alt c loc2;\n        a \\<in>\\<^sub>A frontier (c_pts c loc1);\n        s \\<in>\\<^sub>A path_summary loc1 loc2; results_in a s = b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a loc1 s.\n                            a \\<in>\\<^sub>A frontier (c_pts c loc1) \\<and>\n                            s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                            results_in a s = b \\<and>\n                            (\\<forall>loc a' s'.\n                                a' \\<in>\\<^sub>A frontier\n            (c_pts c loc) \\<longrightarrow>\n                                s' \\<in>\\<^sub>A path_summary loc\n            loc2 \\<longrightarrow>\n                                \\<not> results_in a' s' < b)", "apply (drule implied_frontier_alt_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a s loc1.\n       \\<lbrakk>a \\<in>\\<^sub>A frontier (c_pts c loc1);\n        s \\<in>\\<^sub>A path_summary loc1 loc2; results_in a s = b;\n        \\<forall>loc a' s'.\n           a' \\<in>\\<^sub>A frontier (c_pts c loc) \\<longrightarrow>\n           s' \\<in>\\<^sub>A path_summary loc loc2 \\<longrightarrow>\n           \\<not> results_in a' s' < b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a loc1 s.\n                            a \\<in>\\<^sub>A frontier (c_pts c loc1) \\<and>\n                            s \\<in>\\<^sub>A path_summary loc1 loc2 \\<and>\n                            results_in a s = b \\<and>\n                            (\\<forall>loc a' s'.\n                                a' \\<in>\\<^sub>A frontier\n            (c_pts c loc) \\<longrightarrow>\n                                s' \\<in>\\<^sub>A path_summary loc\n            loc2 \\<longrightarrow>\n                                \\<not> results_in a' s' < b)", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a \\<in>\\<^sub>A frontier (c_pts c loc1)\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  results_in a s = b\n  \\<forall>loc a' s'.\n     a' \\<in>\\<^sub>A frontier (c_pts c loc) \\<longrightarrow>\n     s' \\<in>\\<^sub>A path_summary loc loc2 \\<longrightarrow>\n     \\<not> results_in a' s' < b\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A frontier (c_imp c loc2)", "then"], ["proof (chain)\npicking this:\n  a \\<in>\\<^sub>A frontier (c_pts c loc1)\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  results_in a s = b\n  \\<forall>loc a' s'.\n     a' \\<in>\\<^sub>A frontier (c_pts c loc) \\<longrightarrow>\n     s' \\<in>\\<^sub>A path_summary loc loc2 \\<longrightarrow>\n     \\<not> results_in a' s' < b", "have zcount_ps: \"0 < zcount (c_pts c loc1) a\""], ["proof (prove)\nusing this:\n  a \\<in>\\<^sub>A frontier (c_pts c loc1)\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  results_in a s = b\n  \\<forall>loc a' s'.\n     a' \\<in>\\<^sub>A frontier (c_pts c loc) \\<longrightarrow>\n     s' \\<in>\\<^sub>A path_summary loc loc2 \\<longrightarrow>\n     \\<not> results_in a' s' < b\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_pts c loc1) a", "using member_frontier_pos_zmset"], ["proof (prove)\nusing this:\n  a \\<in>\\<^sub>A frontier (c_pts c loc1)\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  results_in a s = b\n  \\<forall>loc a' s'.\n     a' \\<in>\\<^sub>A frontier (c_pts c loc) \\<longrightarrow>\n     s' \\<in>\\<^sub>A path_summary loc loc2 \\<longrightarrow>\n     \\<not> results_in a' s' < b\n  ?t \\<in>\\<^sub>A frontier ?M \\<Longrightarrow> 0 < zcount ?M ?t\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_pts c loc1) a", "by blast\n      \\<comment> \\<open>From `safe` we know that pointstamp @{term a} is reflected in the implications by some\n      poinstamp @{term \"b' \\<le> b\"}\\<close>"], ["proof (state)\nthis:\n  0 < zcount (c_pts c loc1) a\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A frontier (c_imp c loc2)", "obtain b' where b': \"b' \\<in>\\<^sub>A frontier (c_imp c loc2)\" \"b' \\<le> results_in a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' \\<in>\\<^sub>A frontier (c_imp c loc2);\n         b' \\<le> results_in a s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using safe[OF zcount_ps loc1_a_s(2)] loc1_a_s(3)"], ["proof (prove)\nusing this:\n  results_in a s \\<le> b \\<Longrightarrow>\n  \\<exists>t'\\<le>results_in a s. t' \\<in>\\<^sub>A frontier (c_imp c loc2)\n  results_in a s = b\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' \\<in>\\<^sub>A frontier (c_imp c loc2);\n         b' \\<le> results_in a s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  b' \\<in>\\<^sub>A frontier (c_imp c loc2)\n  b' \\<le> results_in a s\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A frontier (c_imp c loc2)", "have \"b' = results_in a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' = results_in a s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b' = results_in a s", "have \"zcount (c_work c loc) t = 0\" if \"results_in t s \\<le> b'\" for t s loc"], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (c_work c loc) t = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zcount (c_work c loc) t = 0", "have \"results_in t s \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. results_in t s \\<le> b", "using b'(2) loc1_a_s(3) that"], ["proof (prove)\nusing this:\n  b' \\<le> results_in a s__\n  results_in a s__ = b\n  results_in t s \\<le> b'\n\ngoal (1 subgoal):\n 1. results_in t s \\<le> b", "by force"], ["proof (state)\nthis:\n  results_in t s \\<le> b\n\ngoal (1 subgoal):\n 1. zcount (c_work c loc) t = 0", "then"], ["proof (chain)\npicking this:\n  results_in t s \\<le> b", "show ?thesis"], ["proof (prove)\nusing this:\n  results_in t s \\<le> b\n\ngoal (1 subgoal):\n 1. zcount (c_work c loc) t = 0", "by (meson assms(3) results_in_mono(2) worklists_vacant_to_def flow.zero_le order_trans\n            path_weight_refl zcount_inI)"], ["proof (state)\nthis:\n  zcount (c_work c loc) t = 0\n\ngoal:\nNo subgoals!", "qed\n      \\<comment> \\<open>but the pointstamp can't be strictly less, because we know that @{term \"results_in a s\"} is least\\<close>"], ["proof (state)\nthis:\n  results_in ?t4 ?s4 \\<le> b' \\<Longrightarrow>\n  zcount (c_work c ?loc4) ?t4 = 0\n\ngoal (1 subgoal):\n 1. b' = results_in a s", "then"], ["proof (chain)\npicking this:\n  results_in ?t4 ?s4 \\<le> b' \\<Longrightarrow>\n  zcount (c_work c ?loc4) ?t4 = 0", "obtain a' loc1' s' where a':\n      \"s' \\<in>\\<^sub>A path_summary loc1' loc2\" \"results_in a' s' \\<le> b'\" \"a' \\<in>\\<^sub>A frontier (c_pts c loc1')\""], ["proof (prove)\nusing this:\n  results_in ?t4 ?s4 \\<le> b' \\<Longrightarrow>\n  zcount (c_work c ?loc4) ?t4 = 0\n\ngoal (1 subgoal):\n 1. (\\<And>s' loc1' a'.\n        \\<lbrakk>s' \\<in>\\<^sub>A path_summary loc1' loc2;\n         results_in a' s' \\<le> b';\n         a' \\<in>\\<^sub>A frontier (c_pts c loc1')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using implication_implies_pointstamp[OF b'(1) assms(1), simplified]"], ["proof (prove)\nusing this:\n  results_in ?t4 ?s4 \\<le> b' \\<Longrightarrow>\n  zcount (c_work c ?loc4) ?t4 = 0\n  \\<exists>t' loc' s.\n     s \\<in>\\<^sub>A path_summary loc' loc2 \\<and>\n     results_in t' s \\<le> b' \\<and>\n     (t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n      zcount (c_work c loc') t' < 0)\n\ngoal (1 subgoal):\n 1. (\\<And>s' loc1' a'.\n        \\<lbrakk>s' \\<in>\\<^sub>A path_summary loc1' loc2;\n         results_in a' s' \\<le> b';\n         a' \\<in>\\<^sub>A frontier (c_pts c loc1')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  s' \\<in>\\<^sub>A path_summary loc1' loc2\n  results_in a' s' \\<le> b'\n  a' \\<in>\\<^sub>A frontier (c_pts c loc1')\n\ngoal (1 subgoal):\n 1. b' = results_in a s", "{"], ["proof (state)\nthis:\n  s' \\<in>\\<^sub>A path_summary loc1' loc2\n  results_in a' s' \\<le> b'\n  a' \\<in>\\<^sub>A frontier (c_pts c loc1')\n\ngoal (1 subgoal):\n 1. b' = results_in a s", "assume \"b' \\<noteq> results_in a s\""], ["proof (state)\nthis:\n  b' \\<noteq> results_in a s\n\ngoal (1 subgoal):\n 1. b' = results_in a s", "with b'(2)"], ["proof (chain)\npicking this:\n  b' \\<le> results_in a s\n  b' \\<noteq> results_in a s", "have b'_lt: \"b' < results_in a s\""], ["proof (prove)\nusing this:\n  b' \\<le> results_in a s\n  b' \\<noteq> results_in a s\n\ngoal (1 subgoal):\n 1. b' < results_in a s", "by simp"], ["proof (state)\nthis:\n  b' < results_in a s\n\ngoal (1 subgoal):\n 1. b' = results_in a s", "note loc1_a_s(4)[rule_format, unfolded loc1_a_s(3)[symmetric], OF a'(3,1)]"], ["proof (state)\nthis:\n  \\<not> results_in a' s' < results_in a s\n\ngoal (1 subgoal):\n 1. b' = results_in a s", "with b'_lt a'(2)"], ["proof (chain)\npicking this:\n  b' < results_in a s\n  results_in a' s' \\<le> b'\n  \\<not> results_in a' s' < results_in a s", "have False"], ["proof (prove)\nusing this:\n  b' < results_in a s\n  results_in a' s' \\<le> b'\n  \\<not> results_in a' s' < results_in a s\n\ngoal (1 subgoal):\n 1. False", "by (simp add: leD less_le order_trans)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. b' = results_in a s", "}"], ["proof (state)\nthis:\n  b' \\<noteq> results_in a s \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. b' = results_in a s", "then"], ["proof (chain)\npicking this:\n  b' \\<noteq> results_in a s \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  b' \\<noteq> results_in a s \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. b' = results_in a s", "by (rule ccontr)"], ["proof (state)\nthis:\n  b' = results_in a s\n\ngoal:\nNo subgoals!", "qed\n    \\<comment> \\<open>Hence, the @{term implied_frontier_alt} pointstamp @{term b} is reflected in the implications\\<close>"], ["proof (state)\nthis:\n  b' = results_in a s\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A frontier (c_imp c loc2)", "with b'"], ["proof (chain)\npicking this:\n  b' \\<in>\\<^sub>A frontier (c_imp c loc2)\n  b' \\<le> results_in a s\n  b' = results_in a s", "show \"b \\<in>\\<^sub>A frontier (c_imp c loc2)\""], ["proof (prove)\nusing this:\n  b' \\<in>\\<^sub>A frontier (c_imp c loc2)\n  b' \\<le> results_in a s\n  b' = results_in a s\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A frontier (c_imp c loc2)", "by (auto simp: loc1_a_s(3))"], ["proof (state)\nthis:\n  b \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_implication_frontier_in_implied_frontier_alt:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"worklists_vacant_to c b\"\n    and   \"b \\<in>\\<^sub>A frontier (c_imp c loc2)\"\n  shows   \"b \\<in>\\<^sub>A implied_frontier_alt c loc2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2", "have safe: \"0 < zcount (c_pts c loc1) t \\<Longrightarrow> s \\<in>\\<^sub>A path_summary loc1 loc2 \\<Longrightarrow> results_in t s \\<le> b\n        \\<Longrightarrow> \\<exists>t'\\<le>results_in t s. t' \\<in>\\<^sub>A frontier (c_imp c loc2)\" for loc1 loc2 t s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < zcount (c_pts c loc1) t;\n     s \\<in>\\<^sub>A path_summary loc1 loc2; results_in t s \\<le> b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t'\\<le>results_in t s.\n                         t' \\<in>\\<^sub>A frontier (c_imp c loc2)", "by (rule inv_safe[OF assms(1,2), unfolded inv_safe_def, rule_format])\n      (auto elim: worklists_vacant_to_trans[OF assms(3)])"], ["proof (state)\nthis:\n  \\<lbrakk>0 < zcount (c_pts c ?loc1.4) ?t4;\n   ?s4 \\<in>\\<^sub>A path_summary ?loc1.4 ?loc2.4;\n   results_in ?t4 ?s4 \\<le> b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t'\\<le>results_in ?t4 ?s4.\n                       t' \\<in>\\<^sub>A frontier (c_imp c ?loc2.4)\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2", "have \"zcount (c_work c loc) t = 0\" if \"results_in t s \\<le> b\" for t s loc"], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (c_work c loc) t = 0", "using that"], ["proof (prove)\nusing this:\n  results_in t s \\<le> b\n\ngoal (1 subgoal):\n 1. zcount (c_work c loc) t = 0", "by (meson assms(3) results_in_mono(2) worklists_vacant_to_def flow.zero_le\n        order_trans path_weight_refl zcount_inI)\n      \\<comment> \\<open>Pointstamp @{term b} in the implications is caused by a pointstamp @{term a} and a summary @{term s}\\<close>"], ["proof (state)\nthis:\n  results_in ?t4 ?s4 \\<le> b \\<Longrightarrow>\n  zcount (c_work c ?loc4) ?t4 = 0\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2", "then"], ["proof (chain)\npicking this:\n  results_in ?t4 ?s4 \\<le> b \\<Longrightarrow>\n  zcount (c_work c ?loc4) ?t4 = 0", "obtain loc1 a s where loc1_a_s:\n    \"s \\<in>\\<^sub>A path_summary loc1 loc2\" \"results_in a s \\<le> b\" \"a \\<in>\\<^sub>A frontier (c_pts c loc1)\""], ["proof (prove)\nusing this:\n  results_in ?t4 ?s4 \\<le> b \\<Longrightarrow>\n  zcount (c_work c ?loc4) ?t4 = 0\n\ngoal (1 subgoal):\n 1. (\\<And>s loc1 a.\n        \\<lbrakk>s \\<in>\\<^sub>A path_summary loc1 loc2;\n         results_in a s \\<le> b;\n         a \\<in>\\<^sub>A frontier (c_pts c loc1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using implication_implies_pointstamp[OF assms(4) assms(1), simplified]"], ["proof (prove)\nusing this:\n  results_in ?t4 ?s4 \\<le> b \\<Longrightarrow>\n  zcount (c_work c ?loc4) ?t4 = 0\n  \\<exists>t' loc' s.\n     s \\<in>\\<^sub>A path_summary loc' loc2 \\<and>\n     results_in t' s \\<le> b \\<and>\n     (t' \\<in>\\<^sub>A frontier (c_pts c loc') \\<or>\n      zcount (c_work c loc') t' < 0)\n\ngoal (1 subgoal):\n 1. (\\<And>s loc1 a.\n        \\<lbrakk>s \\<in>\\<^sub>A path_summary loc1 loc2;\n         results_in a s \\<le> b;\n         a \\<in>\\<^sub>A frontier (c_pts c loc1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  results_in a s \\<le> b\n  a \\<in>\\<^sub>A frontier (c_pts c loc1)\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2", "then"], ["proof (chain)\npicking this:\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  results_in a s \\<le> b\n  a \\<in>\\<^sub>A frontier (c_pts c loc1)", "have zcount_a: \"0 < zcount (c_pts c loc1) a\""], ["proof (prove)\nusing this:\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  results_in a s \\<le> b\n  a \\<in>\\<^sub>A frontier (c_pts c loc1)\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_pts c loc1) a", "using member_frontier_pos_zmset"], ["proof (prove)\nusing this:\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n  results_in a s \\<le> b\n  a \\<in>\\<^sub>A frontier (c_pts c loc1)\n  ?t \\<in>\\<^sub>A frontier ?M \\<Longrightarrow> 0 < zcount ?M ?t\n\ngoal (1 subgoal):\n 1. 0 < zcount (c_pts c loc1) a", "by blast"], ["proof (state)\nthis:\n  0 < zcount (c_pts c loc1) a\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2", "have b_ria: \"results_in a s = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. results_in a s = b", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. results_in a s \\<noteq> b \\<Longrightarrow> False", "assume \"results_in a s \\<noteq> b\""], ["proof (state)\nthis:\n  results_in a s \\<noteq> b\n\ngoal (1 subgoal):\n 1. results_in a s \\<noteq> b \\<Longrightarrow> False", "with loc1_a_s(2)"], ["proof (chain)\npicking this:\n  results_in a s \\<le> b\n  results_in a s \\<noteq> b", "have \"results_in a s < b\""], ["proof (prove)\nusing this:\n  results_in a s \\<le> b\n  results_in a s \\<noteq> b\n\ngoal (1 subgoal):\n 1. results_in a s < b", "by simp"], ["proof (state)\nthis:\n  results_in a s < b\n\ngoal (1 subgoal):\n 1. results_in a s \\<noteq> b \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  results_in a s < b", "show False"], ["proof (prove)\nusing this:\n  results_in a s < b\n\ngoal (1 subgoal):\n 1. False", "using safe[OF zcount_a loc1_a_s(1)] assms(4) loc1_a_s(2)"], ["proof (prove)\nusing this:\n  results_in a s < b\n  results_in a s \\<le> b \\<Longrightarrow>\n  \\<exists>t'\\<le>results_in a s. t' \\<in>\\<^sub>A frontier (c_imp c loc2)\n  b \\<in>\\<^sub>A frontier (c_imp c loc2)\n  results_in a s \\<le> b\n\ngoal (1 subgoal):\n 1. False", "using order.strict_trans1 frontier_comparable_False"], ["proof (prove)\nusing this:\n  results_in a s < b\n  results_in a s \\<le> b \\<Longrightarrow>\n  \\<exists>t'\\<le>results_in a s. t' \\<in>\\<^sub>A frontier (c_imp c loc2)\n  b \\<in>\\<^sub>A frontier (c_imp c loc2)\n  results_in a s \\<le> b\n  \\<lbrakk>?a \\<le> ?b; ?b < ?c\\<rbrakk> \\<Longrightarrow> ?a < ?c\n  \\<lbrakk>?x \\<in>\\<^sub>A frontier ?M; ?y \\<in>\\<^sub>A frontier ?M;\n   ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed\n    \\<comment> \\<open>@{term \"results_in a s\"} is a candidate for inclusion in the @{term implied_frontier_alt}..\\<close>"], ["proof (state)\nthis:\n  results_in a s = b\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2", "have \"0 < zcount (\\<Sum>loc'\\<in>UNIV. after_summary (zmset_frontier (c_pts c loc')) (path_summary loc' loc2)) (results_in a s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount\n         (\\<Sum>loc'\\<in>UNIV.\n            after_summary\n             (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n             (path_summary loc' loc2))\n         (results_in a s)", "unfolding after_summary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount\n         (\\<Sum>loc'\\<in>UNIV.\n            \\<Sum>s\\<in>set_antichain (path_summary loc' loc2).\n              {#results_in t s\n              . t \\<in>#\\<^sub>z zmset_of\n                                  (mset_set\n                                    (set_antichain\n(frontier (c_pts c loc'))))#})\n         (results_in a s)", "apply (subst zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (\\<Sum>M\\<in>UNIV.\n           zcount\n            (\\<Sum>s\\<in>set_antichain (path_summary M loc2).\n               {#results_in t s\n               . t \\<in>#\\<^sub>z zmset_of\n                                   (mset_set\n                                     (set_antichain\n (frontier (c_pts c M))))#})\n            (results_in a s))", "apply (rule sum_pos[of _ _ loc1])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite UNIV\n 2. \\<forall>M\\<in>UNIV.\n       0 \\<le> zcount\n                (\\<Sum>s\\<in>set_antichain (path_summary M loc2).\n                   {#results_in t s\n                   . t \\<in>#\\<^sub>z zmset_of\n (mset_set (set_antichain (frontier (c_pts c M))))#})\n                (results_in a s)\n 3. loc1 \\<in> UNIV\n 4. 0 < zcount\n         (\\<Sum>s\\<in>set_antichain (path_summary loc1 loc2).\n            {#results_in t s\n            . t \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1))))#})\n         (results_in a s)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>M\\<in>UNIV.\n       0 \\<le> zcount\n                (\\<Sum>s\\<in>set_antichain (path_summary M loc2).\n                   {#results_in t s\n                   . t \\<in>#\\<^sub>z zmset_of\n (mset_set (set_antichain (frontier (c_pts c M))))#})\n                (results_in a s)\n 2. loc1 \\<in> UNIV\n 3. 0 < zcount\n         (\\<Sum>s\\<in>set_antichain (path_summary loc1 loc2).\n            {#results_in t s\n            . t \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1))))#})\n         (results_in a s)", "apply (clarsimp simp: zcount_sum)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M.\n       0 \\<le> (\\<Sum>sa\\<in>set_antichain (path_summary M loc2).\n                  zcount\n                   {#results_in t sa\n                   . t \\<in>#\\<^sub>z zmset_of\n (mset_set (set_antichain (frontier (c_pts c M))))#}\n                   (results_in a s))\n 2. loc1 \\<in> UNIV\n 3. 0 < zcount\n         (\\<Sum>s\\<in>set_antichain (path_summary loc1 loc2).\n            {#results_in t s\n            . t \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1))))#})\n         (results_in a s)", "apply (rule sum_nonneg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M x.\n       x \\<in> set_antichain (path_summary M loc2) \\<Longrightarrow>\n       0 \\<le> zcount\n                {#results_in t x\n                . t \\<in>#\\<^sub>z zmset_of\n                                    (mset_set\n(set_antichain (frontier (c_pts c M))))#}\n                (results_in a s)\n 2. loc1 \\<in> UNIV\n 3. 0 < zcount\n         (\\<Sum>s\\<in>set_antichain (path_summary loc1 loc2).\n            {#results_in t s\n            . t \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1))))#})\n         (results_in a s)", "apply (subst zcount_image_zmset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M x.\n       x \\<in> set_antichain (path_summary M loc2) \\<Longrightarrow>\n       0 \\<le> sum (zcount\n                     (zmset_of\n                       (mset_set (set_antichain (frontier (c_pts c M))))))\n                ((\\<lambda>t. results_in t x) -` {results_in a s} \\<inter>\n                 set_zmset\n                  (zmset_of\n                    (mset_set (set_antichain (frontier (c_pts c M))))))\n 2. loc1 \\<in> UNIV\n 3. 0 < zcount\n         (\\<Sum>s\\<in>set_antichain (path_summary loc1 loc2).\n            {#results_in t s\n            . t \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1))))#})\n         (results_in a s)", "apply auto [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount\n         (\\<Sum>s\\<in>set_antichain (path_summary loc1 loc2).\n            {#results_in t s\n            . t \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1))))#})\n         (results_in a s)", "apply (subst zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (\\<Sum>M\\<in>set_antichain (path_summary loc1 loc2).\n           zcount\n            {#results_in t M\n            . t \\<in>#\\<^sub>z zmset_of\n                                (mset_set\n                                  (set_antichain\n                                    (frontier (c_pts c loc1))))#}\n            (results_in a s))", "apply (rule sum_pos[of _ _ s])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (set_antichain (path_summary loc1 loc2))\n 2. \\<forall>M\\<in>set_antichain (path_summary loc1 loc2).\n       0 \\<le> zcount\n                {#results_in t M\n                . t \\<in>#\\<^sub>z zmset_of\n                                    (mset_set\n(set_antichain (frontier (c_pts c loc1))))#}\n                (results_in a s)\n 3. s \\<in> set_antichain (path_summary loc1 loc2)\n 4. 0 < zcount\n         {#results_in t s\n         . t \\<in>#\\<^sub>z zmset_of\n                             (mset_set\n                               (set_antichain (frontier (c_pts c loc1))))#}\n         (results_in a s)", "using loc1_a_s(1)"], ["proof (prove)\nusing this:\n  s \\<in>\\<^sub>A path_summary loc1 loc2\n\ngoal (4 subgoals):\n 1. finite (set_antichain (path_summary loc1 loc2))\n 2. \\<forall>M\\<in>set_antichain (path_summary loc1 loc2).\n       0 \\<le> zcount\n                {#results_in t M\n                . t \\<in>#\\<^sub>z zmset_of\n                                    (mset_set\n(set_antichain (frontier (c_pts c loc1))))#}\n                (results_in a s)\n 3. s \\<in> set_antichain (path_summary loc1 loc2)\n 4. 0 < zcount\n         {#results_in t s\n         . t \\<in>#\\<^sub>z zmset_of\n                             (mset_set\n                               (set_antichain (frontier (c_pts c loc1))))#}\n         (results_in a s)", "apply simp_all [3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < zcount\n         {#results_in t s\n         . t \\<in>#\\<^sub>z zmset_of\n                             (mset_set\n                               (set_antichain (frontier (c_pts c loc1))))#}\n         (results_in a s)", "apply (subst zcount_image_zmset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sum (zcount\n              (zmset_of\n                (mset_set (set_antichain (frontier (c_pts c loc1))))))\n         ((\\<lambda>t. results_in t s) -` {results_in a s} \\<inter>\n          set_zmset\n           (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1))))))", "apply (rule sum_pos[of _ _ a])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite\n     ((\\<lambda>t. results_in t s) -` {results_in a s} \\<inter>\n      set_zmset\n       (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1))))))\n 2. \\<forall>x\\<in>(\\<lambda>t. results_in t s) -` {results_in a s} \\<inter>\n                   set_zmset\n                    (zmset_of\n                      (mset_set (set_antichain (frontier (c_pts c loc1))))).\n       0 \\<le> zcount\n                (zmset_of\n                  (mset_set (set_antichain (frontier (c_pts c loc1)))))\n                x\n 3. a \\<in> (\\<lambda>t. results_in t s) -` {results_in a s} \\<inter>\n            set_zmset\n             (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1)))))\n 4. 0 < zcount\n         (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1))))) a", "using loc1_a_s(3)"], ["proof (prove)\nusing this:\n  a \\<in>\\<^sub>A frontier (c_pts c loc1)\n\ngoal (4 subgoals):\n 1. finite\n     ((\\<lambda>t. results_in t s) -` {results_in a s} \\<inter>\n      set_zmset\n       (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1))))))\n 2. \\<forall>x\\<in>(\\<lambda>t. results_in t s) -` {results_in a s} \\<inter>\n                   set_zmset\n                    (zmset_of\n                      (mset_set (set_antichain (frontier (c_pts c loc1))))).\n       0 \\<le> zcount\n                (zmset_of\n                  (mset_set (set_antichain (frontier (c_pts c loc1)))))\n                x\n 3. a \\<in> (\\<lambda>t. results_in t s) -` {results_in a s} \\<inter>\n            set_zmset\n             (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1)))))\n 4. 0 < zcount\n         (zmset_of (mset_set (set_antichain (frontier (c_pts c loc1))))) a", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n      \\<comment> \\<open>..which means a pointstamp @{term \"b' \\<le> results_in a s\"} must exist in the @{term implied_frontier_alt}..\\<close>"], ["proof (state)\nthis:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n           (path_summary loc' loc2))\n       (results_in a s)\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2", "then"], ["proof (chain)\npicking this:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n           (path_summary loc' loc2))\n       (results_in a s)", "obtain b' where b': \"b' \\<in>\\<^sub>A implied_frontier_alt c loc2\" \"b' \\<le> results_in a s\""], ["proof (prove)\nusing this:\n  0 < zcount\n       (\\<Sum>loc'\\<in>UNIV.\n          after_summary\n           (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n           (path_summary loc' loc2))\n       (results_in a s)\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' \\<in>\\<^sub>A implied_frontier_alt c loc2;\n         b' \\<le> results_in a s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: implied_frontier_alt_def elim: obtain_frontier_elem)"], ["proof (state)\nthis:\n  b' \\<in>\\<^sub>A implied_frontier_alt c loc2\n  b' \\<le> results_in a s\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2", "then"], ["proof (chain)\npicking this:\n  b' \\<in>\\<^sub>A implied_frontier_alt c loc2\n  b' \\<le> results_in a s", "have \"worklists_vacant_to c b'\""], ["proof (prove)\nusing this:\n  b' \\<in>\\<^sub>A implied_frontier_alt c loc2\n  b' \\<le> results_in a s\n\ngoal (1 subgoal):\n 1. worklists_vacant_to c b'", "using loc1_a_s(2)"], ["proof (prove)\nusing this:\n  b' \\<in>\\<^sub>A implied_frontier_alt c loc2\n  b' \\<le> results_in a s\n  results_in a s \\<le> b\n\ngoal (1 subgoal):\n 1. worklists_vacant_to c b'", "by (auto intro: worklists_vacant_to_trans[OF assms(3)])"], ["proof (state)\nthis:\n  worklists_vacant_to c b'\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2", "with b'"], ["proof (chain)\npicking this:\n  b' \\<in>\\<^sub>A implied_frontier_alt c loc2\n  b' \\<le> results_in a s\n  worklists_vacant_to c b'", "have b'_frontier: \"b' \\<in>\\<^sub>A frontier (c_imp c loc2)\""], ["proof (prove)\nusing this:\n  b' \\<in>\\<^sub>A implied_frontier_alt c loc2\n  b' \\<le> results_in a s\n  worklists_vacant_to c b'\n\ngoal (1 subgoal):\n 1. b' \\<in>\\<^sub>A frontier (c_imp c loc2)", "using in_implied_frontier_alt_in_implication_frontier assms"], ["proof (prove)\nusing this:\n  b' \\<in>\\<^sub>A implied_frontier_alt c loc2\n  b' \\<le> results_in a s\n  worklists_vacant_to c b'\n  \\<lbrakk>inv_imps_work_sum ?c; inv_implications_nonneg ?c;\n   worklists_vacant_to ?c ?b;\n   ?b \\<in>\\<^sub>A implied_frontier_alt ?c ?loc2.0\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in>\\<^sub>A frontier (c_imp ?c ?loc2.0)\n  inv_imps_work_sum c\n  inv_implications_nonneg c\n  worklists_vacant_to c b\n  b \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (1 subgoal):\n 1. b' \\<in>\\<^sub>A frontier (c_imp c loc2)", "by blast\n      \\<comment> \\<open>..and this pointstamp must be equal to @{term b'}\\<close>"], ["proof (state)\nthis:\n  b' \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2", "have b'_ria: \"b' = results_in a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' = results_in a s", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. b' \\<noteq> results_in a s \\<Longrightarrow> False", "assume \"b' \\<noteq> results_in a s\""], ["proof (state)\nthis:\n  b' \\<noteq> results_in a s\n\ngoal (1 subgoal):\n 1. b' \\<noteq> results_in a s \\<Longrightarrow> False", "with b'(2)"], ["proof (chain)\npicking this:\n  b' \\<le> results_in a s\n  b' \\<noteq> results_in a s", "have b'_lt: \"b' < results_in a s\""], ["proof (prove)\nusing this:\n  b' \\<le> results_in a s\n  b' \\<noteq> results_in a s\n\ngoal (1 subgoal):\n 1. b' < results_in a s", "by simp"], ["proof (state)\nthis:\n  b' < results_in a s\n\ngoal (1 subgoal):\n 1. b' \\<noteq> results_in a s \\<Longrightarrow> False", "from b'_frontier b'_lt b_ria assms(4)"], ["proof (chain)\npicking this:\n  b' \\<in>\\<^sub>A frontier (c_imp c loc2)\n  b' < results_in a s\n  results_in a s = b\n  b \\<in>\\<^sub>A frontier (c_imp c loc2)", "show False"], ["proof (prove)\nusing this:\n  b' \\<in>\\<^sub>A frontier (c_imp c loc2)\n  b' < results_in a s\n  results_in a s = b\n  b \\<in>\\<^sub>A frontier (c_imp c loc2)\n\ngoal (1 subgoal):\n 1. False", "using frontier_comparable_False"], ["proof (prove)\nusing this:\n  b' \\<in>\\<^sub>A frontier (c_imp c loc2)\n  b' < results_in a s\n  results_in a s = b\n  b \\<in>\\<^sub>A frontier (c_imp c loc2)\n  \\<lbrakk>?x \\<in>\\<^sub>A frontier ?M; ?y \\<in>\\<^sub>A frontier ?M;\n   ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed\n    \\<comment> \\<open>Hence, the implication frontier pointstamp @{term b} is reflected in the @{term implied_frontier_alt}\\<close>"], ["proof (state)\nthis:\n  b' = results_in a s\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2", "from b' b'_ria b_ria"], ["proof (chain)\npicking this:\n  b' \\<in>\\<^sub>A implied_frontier_alt c loc2\n  b' \\<le> results_in a s\n  b' = results_in a s\n  results_in a s = b", "show \"b \\<in>\\<^sub>A implied_frontier_alt c loc2\""], ["proof (prove)\nusing this:\n  b' \\<in>\\<^sub>A implied_frontier_alt c loc2\n  b' \\<le> results_in a s\n  b' = results_in a s\n  results_in a s = b\n\ngoal (1 subgoal):\n 1. b \\<in>\\<^sub>A implied_frontier_alt c loc2", "by (auto simp: implied_frontier_alt_def)"], ["proof (state)\nthis:\n  b \\<in>\\<^sub>A implied_frontier_alt c loc2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma implication_frontier_iff_implied_frontier_alt_vacant:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"worklists_vacant_to c b\"\n  shows   \"b \\<in>\\<^sub>A frontier (c_imp c loc) \\<longleftrightarrow> b \\<in>\\<^sub>A implied_frontier_alt c loc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<in>\\<^sub>A frontier (c_imp c loc)) =\n    (b \\<in>\\<^sub>A implied_frontier_alt c loc)", "using\n    ac_eq_iff\n    in_implication_frontier_in_implied_frontier_alt[OF assms]\n    in_implied_frontier_alt_in_implication_frontier[OF assms]"], ["proof (prove)\nusing this:\n  (?A = ?B) = (\\<forall>x. (x \\<in>\\<^sub>A ?A) = (x \\<in>\\<^sub>A ?B))\n  b \\<in>\\<^sub>A frontier (c_imp c ?loc2.0) \\<Longrightarrow>\n  b \\<in>\\<^sub>A implied_frontier_alt c ?loc2.0\n  b \\<in>\\<^sub>A implied_frontier_alt c ?loc2.0 \\<Longrightarrow>\n  b \\<in>\\<^sub>A frontier (c_imp c ?loc2.0)\n\ngoal (1 subgoal):\n 1. (b \\<in>\\<^sub>A frontier (c_imp c loc)) =\n    (b \\<in>\\<^sub>A implied_frontier_alt c loc)", "by blast"], ["", "lemma next_propagate_implied_frontier_alt_def:\n  \"next_propagate c c' \\<Longrightarrow> implied_frontier_alt c loc = implied_frontier_alt c' loc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next_propagate c c' \\<Longrightarrow>\n    implied_frontier_alt c loc = implied_frontier_alt c' loc", "by (auto simp: next_propagate'_def implied_frontier_alt_def)"], ["", "lemma implication_frontier_eq_implied_frontier_alt:\n  assumes \"inv_imps_work_sum c\"\n    and   \"inv_implications_nonneg c\"\n    and   \"\\<And>loc. c_work c loc = {#}\\<^sub>z\"\n  shows   \"frontier (c_imp c loc) = implied_frontier_alt c loc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frontier (c_imp c loc) = implied_frontier_alt c loc", "using ac_eq_iff implication_frontier_iff_implied_frontier_alt_vacant empty_worklists_vacant_to assms"], ["proof (prove)\nusing this:\n  (?A = ?B) = (\\<forall>x. (x \\<in>\\<^sub>A ?A) = (x \\<in>\\<^sub>A ?B))\n  \\<lbrakk>inv_imps_work_sum ?c; inv_implications_nonneg ?c;\n   worklists_vacant_to ?c ?b\\<rbrakk>\n  \\<Longrightarrow> (?b \\<in>\\<^sub>A frontier (c_imp ?c ?loc)) =\n                    (?b \\<in>\\<^sub>A implied_frontier_alt ?c ?loc)\n  \\<forall>loc. c_work ?c loc = {#}\\<^sub>z \\<Longrightarrow>\n  worklists_vacant_to ?c ?t\n  inv_imps_work_sum c\n  inv_implications_nonneg c\n  c_work c ?loc4 = {#}\\<^sub>z\n\ngoal (1 subgoal):\n 1. frontier (c_imp c loc) = implied_frontier_alt c loc", "by blast"], ["", "lemma alw_implication_frontier_eq_implied_frontier_alt_empty: \"spec s \\<Longrightarrow>\n  alw (holds (\\<lambda>c. (\\<forall>loc. c_work c loc = {#}\\<^sub>z) \\<longrightarrow> frontier (c_imp c loc) = implied_frontier_alt c loc)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow>\n    alw (holds\n          (\\<lambda>c.\n              (\\<forall>loc. c_work c loc = {#}\\<^sub>z) \\<longrightarrow>\n              frontier (c_imp c loc) = implied_frontier_alt c loc))\n     s", "apply (frule spec_imp_iiws)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>spec s; alw (holds inv_imps_work_sum) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds\n                            (\\<lambda>c.\n                                (\\<forall>loc.\n                                    c_work c loc =\n                                    {#}\\<^sub>z) \\<longrightarrow>\n                                frontier (c_imp c loc) =\n                                implied_frontier_alt c loc))\n                       s", "apply (drule alw_inv_implications_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (holds inv_imps_work_sum) s;\n     alw (holds inv_implications_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds\n                            (\\<lambda>c.\n                                (\\<forall>loc.\n                                    c_work c loc =\n                                    {#}\\<^sub>z) \\<longrightarrow>\n                                frontier (c_imp c loc) =\n                                implied_frontier_alt c loc))\n                       s", "apply (drule (1) alw_conjI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (holds inv_implications_nonneg) s;\n     alw (\\<lambda>s.\n             holds inv_imps_work_sum s \\<and>\n             holds inv_implications_nonneg s)\n      s\\<rbrakk>\n    \\<Longrightarrow> alw (holds\n                            (\\<lambda>c.\n                                (\\<forall>loc.\n                                    c_work c loc =\n                                    {#}\\<^sub>z) \\<longrightarrow>\n                                frontier (c_imp c loc) =\n                                implied_frontier_alt c loc))\n                       s", "apply (erule thin_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>s.\n            holds inv_imps_work_sum s \\<and>\n            holds inv_implications_nonneg s)\n     s \\<Longrightarrow>\n    alw (holds\n          (\\<lambda>c.\n              (\\<forall>loc. c_work c loc = {#}\\<^sub>z) \\<longrightarrow>\n              frontier (c_imp c loc) = implied_frontier_alt c loc))\n     s", "apply (auto elim!: alw_mono simp: implication_frontier_eq_implied_frontier_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma alw_implication_frontier_eq_implied_frontier_alt_vacant: \"spec s \\<Longrightarrow>\n  alw (holds (\\<lambda>c. worklists_vacant_to c b \\<longrightarrow> b \\<in>\\<^sub>A frontier (c_imp c loc) \\<longleftrightarrow> b \\<in>\\<^sub>A implied_frontier_alt c loc)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec s \\<Longrightarrow>\n    alw (holds\n          (\\<lambda>c.\n              worklists_vacant_to c b \\<longrightarrow>\n              (b \\<in>\\<^sub>A frontier (c_imp c loc)) =\n              (b \\<in>\\<^sub>A implied_frontier_alt c loc)))\n     s", "apply (frule spec_imp_iiws)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>spec s; alw (holds inv_imps_work_sum) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds\n                            (\\<lambda>c.\n                                worklists_vacant_to c b \\<longrightarrow>\n                                (b \\<in>\\<^sub>A frontier (c_imp c loc)) =\n                                (b \\<in>\\<^sub>A implied_frontier_alt c\n            loc)))\n                       s", "apply (drule alw_inv_implications_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (holds inv_imps_work_sum) s;\n     alw (holds inv_implications_nonneg) s\\<rbrakk>\n    \\<Longrightarrow> alw (holds\n                            (\\<lambda>c.\n                                worklists_vacant_to c b \\<longrightarrow>\n                                (b \\<in>\\<^sub>A frontier (c_imp c loc)) =\n                                (b \\<in>\\<^sub>A implied_frontier_alt c\n            loc)))\n                       s", "apply (drule (1) alw_conjI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alw (holds inv_implications_nonneg) s;\n     alw (\\<lambda>s.\n             holds inv_imps_work_sum s \\<and>\n             holds inv_implications_nonneg s)\n      s\\<rbrakk>\n    \\<Longrightarrow> alw (holds\n                            (\\<lambda>c.\n                                worklists_vacant_to c b \\<longrightarrow>\n                                (b \\<in>\\<^sub>A frontier (c_imp c loc)) =\n                                (b \\<in>\\<^sub>A implied_frontier_alt c\n            loc)))\n                       s", "apply (erule thin_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>s.\n            holds inv_imps_work_sum s \\<and>\n            holds inv_implications_nonneg s)\n     s \\<Longrightarrow>\n    alw (holds\n          (\\<lambda>c.\n              worklists_vacant_to c b \\<longrightarrow>\n              (b \\<in>\\<^sub>A frontier (c_imp c loc)) =\n              (b \\<in>\\<^sub>A implied_frontier_alt c loc)))\n     s", "apply (auto elim!: alw_mono simp: implication_frontier_iff_implied_frontier_alt_vacant)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma antichain_eqI: \"(\\<And>b. b \\<in>\\<^sub>A A \\<longleftrightarrow> b \\<in>\\<^sub>A B) \\<Longrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b. (b \\<in>\\<^sub>A A) = (b \\<in>\\<^sub>A B)) \\<Longrightarrow>\n    A = B", "by transfer auto"], ["", "lemma zmset_frontier_zmset_pos: \"zmset_frontier A \\<subseteq>#\\<^sub>z zmset_pos A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zmset_of (mset_set (set_antichain (frontier A))) \\<subseteq>#\\<^sub>z\n    zmset_of (mset_pos A)", "unfolding subseteq_zmset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       zcount (zmset_of (mset_set (set_antichain (frontier A)))) a\n       \\<le> zcount (zmset_of (mset_pos A)) a", "by transfer' (auto simp: count_mset_set_if minimal_antichain_def)"], ["", "lemma image_mset_mono_pos: \n  \"\\<forall>b. 0 \\<le> zcount A b \\<Longrightarrow> \\<forall>b. 0 \\<le> zcount B b \\<Longrightarrow> A \\<subseteq>#\\<^sub>z B \\<Longrightarrow> image_zmset f A \\<subseteq>#\\<^sub>z image_zmset f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b; \\<forall>b. 0 \\<le> zcount B b;\n     A \\<subseteq>#\\<^sub>z B\\<rbrakk>\n    \\<Longrightarrow> Auxiliary.image_zmset f A \\<subseteq>#\\<^sub>z\n                      Auxiliary.image_zmset f B", "unfolding subseteq_zmset_def zcount_image_zmset"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b; \\<forall>b. 0 \\<le> zcount B b;\n     \\<forall>a. zcount A a \\<le> zcount B a\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a.\n                         sum (zcount A) (f -` {a} \\<inter> set_zmset A)\n                         \\<le> sum (zcount B)\n                                (f -` {a} \\<inter> set_zmset B)", "apply (intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a\\<rbrakk>\n       \\<Longrightarrow> sum (zcount A) (f -` {a} \\<inter> set_zmset A)\n                         \\<le> sum (zcount B)\n                                (f -` {a} \\<inter> set_zmset B)", "apply (rule order_trans[OF sum_mono sum_mono2])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a i.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a;\n        i \\<in> f -` {a} \\<inter> set_zmset A\\<rbrakk>\n       \\<Longrightarrow> zcount A i \\<le> zcount B i\n 2. \\<And>a.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a\\<rbrakk>\n       \\<Longrightarrow> finite (f -` {a} \\<inter> set_zmset B)\n 3. \\<And>a.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a\\<rbrakk>\n       \\<Longrightarrow> f -` {a} \\<inter> set_zmset A\n                         \\<subseteq> f -` {a} \\<inter> set_zmset B\n 4. \\<And>a b.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a;\n        b \\<in> f -` {a} \\<inter> set_zmset B -\n                f -` {a} \\<inter> set_zmset A\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> zcount B b", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a\\<rbrakk>\n       \\<Longrightarrow> f -` {a} \\<inter> set_zmset A\n                         \\<subseteq> set_zmset B", "by (metis Int_subset_iff antisym subsetI zcount_ne_zero_iff)"], ["", "lemma sum_mono_subseteq:\n  \"(\\<And>i. i\\<in>K \\<Longrightarrow> f i \\<subseteq>#\\<^sub>z g i) \\<Longrightarrow> (\\<Sum>i\\<in>K. f i) \\<subseteq>#\\<^sub>z (\\<Sum>i\\<in>K. g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> K \\<Longrightarrow>\n        f i \\<subseteq>#\\<^sub>z g i) \\<Longrightarrow>\n    sum f K \\<subseteq>#\\<^sub>z sum g K", "by (simp add: subseteq_zmset_def sum_mono zcount_sum)"], ["", "lemma after_summary_zmset_frontier: \n  \"after_summary (zmset_frontier A) S \\<subseteq>#\\<^sub>z after_summary (zmset_pos A) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. after_summary (zmset_of (mset_set (set_antichain (frontier A))))\n     S \\<subseteq>#\\<^sub>z\n    after_summary (zmset_of (mset_pos A)) S", "unfolding after_summary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set_antichain S.\n       {#results_in t s\n       . t \\<in>#\\<^sub>z zmset_of\n                           (mset_set\n                             (set_antichain\n                               (frontier A)))#}) \\<subseteq>#\\<^sub>z\n    (\\<Sum>s\\<in>set_antichain S.\n       {#results_in t s. t \\<in>#\\<^sub>z zmset_of (mset_pos A)#})", "apply (rule sum_mono_subseteq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> set_antichain S \\<Longrightarrow>\n       {#results_in t s\n       . t \\<in>#\\<^sub>z zmset_of\n                           (mset_set\n                             (set_antichain\n                               (frontier A)))#} \\<subseteq>#\\<^sub>z\n       {#results_in t s. t \\<in>#\\<^sub>z zmset_of (mset_pos A)#}", "apply (rule image_mset_mono_pos[OF _ _ zmset_frontier_zmset_pos])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> set_antichain S \\<Longrightarrow>\n       \\<forall>b.\n          0 \\<le> zcount (zmset_of (mset_set (set_antichain (frontier A))))\n                   b\n 2. \\<And>s.\n       s \\<in> set_antichain S \\<Longrightarrow>\n       \\<forall>b. 0 \\<le> zcount (zmset_of (mset_pos A)) b", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma frontier_eqI: \"\\<forall>b. 0 \\<le> zcount A b \\<Longrightarrow> \\<forall>b. 0 \\<le> zcount B b \\<Longrightarrow>\n  A \\<subseteq>#\\<^sub>z B \\<Longrightarrow> (\\<And>b. b \\<in>#\\<^sub>z B \\<Longrightarrow> \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b) \\<Longrightarrow> frontier A = frontier B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b; \\<forall>b. 0 \\<le> zcount B b;\n     A \\<subseteq>#\\<^sub>z B;\n     \\<And>b.\n        b \\<in>#\\<^sub>z B \\<Longrightarrow>\n        \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> frontier A = frontier B", "apply (transfer fixing: A B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b; \\<forall>b. 0 \\<le> zcount B b;\n     A \\<subseteq>#\\<^sub>z B;\n     \\<And>b.\n        b \\<in>#\\<^sub>z B \\<Longrightarrow>\n        \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> minimal_antichain {t. 0 < zcount A t} =\n                      minimal_antichain {t. 0 < zcount B t}", "apply (clarsimp simp: minimal_antichain_def subseteq_zmset_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b; \\<forall>b. 0 \\<le> zcount B b;\n     \\<forall>a. zcount A a \\<le> zcount B a;\n     \\<And>b.\n        b \\<in>#\\<^sub>z B \\<Longrightarrow>\n        \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> {x. 0 < zcount A x \\<and>\n                          (\\<forall>y.\n                              0 < zcount A y \\<longrightarrow>\n                              \\<not> y < x)} =\n                      {x. 0 < zcount B x \\<and>\n                          (\\<forall>y.\n                              0 < zcount B y \\<longrightarrow>\n                              \\<not> y < x)}", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a;\n        \\<And>b.\n           b \\<in>#\\<^sub>z B \\<Longrightarrow>\n           \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b;\n        0 < zcount A x;\n        \\<forall>y. 0 < zcount A y \\<longrightarrow> \\<not> y < x\\<rbrakk>\n       \\<Longrightarrow> 0 < zcount B x\n 2. \\<And>x y.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a;\n        \\<And>b.\n           b \\<in>#\\<^sub>z B \\<Longrightarrow>\n           \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b;\n        0 < zcount A x;\n        \\<forall>y. 0 < zcount A y \\<longrightarrow> \\<not> y < x;\n        0 < zcount B y; y < x\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a;\n        \\<And>b.\n           b \\<in>#\\<^sub>z B \\<Longrightarrow>\n           \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b;\n        0 < zcount B x;\n        \\<forall>y. 0 < zcount B y \\<longrightarrow> \\<not> y < x\\<rbrakk>\n       \\<Longrightarrow> 0 < zcount A x\n 4. \\<And>x y.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a;\n        \\<And>b.\n           b \\<in>#\\<^sub>z B \\<Longrightarrow>\n           \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b;\n        0 < zcount B x;\n        \\<forall>y. 0 < zcount B y \\<longrightarrow> \\<not> y < x;\n        0 < zcount A y; y < x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis less_le_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a;\n        \\<And>b.\n           b \\<in>#\\<^sub>z B \\<Longrightarrow>\n           \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b;\n        0 < zcount A x;\n        \\<forall>y. 0 < zcount A y \\<longrightarrow> \\<not> y < x;\n        0 < zcount B y; y < x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a;\n        \\<And>b.\n           b \\<in>#\\<^sub>z B \\<Longrightarrow>\n           \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b;\n        0 < zcount B x;\n        \\<forall>y. 0 < zcount B y \\<longrightarrow> \\<not> y < x\\<rbrakk>\n       \\<Longrightarrow> 0 < zcount A x\n 3. \\<And>x y.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a;\n        \\<And>b.\n           b \\<in>#\\<^sub>z B \\<Longrightarrow>\n           \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b;\n        0 < zcount B x;\n        \\<forall>y. 0 < zcount B y \\<longrightarrow> \\<not> y < x;\n        0 < zcount A y; y < x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis less_le less_le_trans zcount_ne_zero_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a;\n        \\<And>b.\n           b \\<in>#\\<^sub>z B \\<Longrightarrow>\n           \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b;\n        0 < zcount B x;\n        \\<forall>y. 0 < zcount B y \\<longrightarrow> \\<not> y < x\\<rbrakk>\n       \\<Longrightarrow> 0 < zcount A x\n 2. \\<And>x y.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a;\n        \\<And>b.\n           b \\<in>#\\<^sub>z B \\<Longrightarrow>\n           \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b;\n        0 < zcount B x;\n        \\<forall>y. 0 < zcount B y \\<longrightarrow> \\<not> y < x;\n        0 < zcount A y; y < x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis antisym less_le zcount_ne_zero_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>b. 0 \\<le> zcount A b;\n        \\<forall>b. 0 \\<le> zcount B b;\n        \\<forall>a. zcount A a \\<le> zcount B a;\n        \\<And>b.\n           b \\<in>#\\<^sub>z B \\<Longrightarrow>\n           \\<exists>a. a \\<in>#\\<^sub>z A \\<and> a \\<le> b;\n        0 < zcount B x;\n        \\<forall>y. 0 < zcount B y \\<longrightarrow> \\<not> y < x;\n        0 < zcount A y; y < x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (meson less_le_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma implied_frontier_implied_frontier_alt: \"implied_frontier (c_pts c) loc = implied_frontier_alt c loc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implied_frontier (c_pts c) loc = implied_frontier_alt c loc", "unfolding implied_frontier_alt_def implied_frontier_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frontier\n     (\\<Sum>loc'\\<in>UNIV.\n        after_summary (zmset_of (mset_pos (c_pts c loc')))\n         (path_summary loc' loc)) =\n    frontier\n     (\\<Sum>loc'\\<in>UNIV.\n        after_summary\n         (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n         (path_summary loc' loc))", "apply (rule frontier_eqI[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>b.\n       0 \\<le> zcount\n                (\\<Sum>loc'\\<in>UNIV.\n                   after_summary\n                    (zmset_of\n                      (mset_set (set_antichain (frontier (c_pts c loc')))))\n                    (path_summary loc' loc))\n                b\n 2. \\<forall>b.\n       0 \\<le> zcount\n                (\\<Sum>loc'\\<in>UNIV.\n                   after_summary (zmset_of (mset_pos (c_pts c loc')))\n                    (path_summary loc' loc))\n                b\n 3. (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n        (path_summary loc' loc)) \\<subseteq>#\\<^sub>z\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary (zmset_of (mset_pos (c_pts c loc')))\n        (path_summary loc' loc))\n 4. \\<And>b.\n       b \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of (mset_pos (c_pts c loc')))\n                            (path_summary loc' loc)) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                              after_summary\n                               (zmset_of\n                                 (mset_set\n                                   (set_antichain\n                                     (frontier (c_pts c loc')))))\n                               (path_summary loc' loc)) \\<and>\n          a \\<le> b", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b.\n       0 \\<le> zcount\n                (\\<Sum>loc'\\<in>UNIV.\n                   after_summary\n                    (zmset_of\n                      (mset_set (set_antichain (frontier (c_pts c loc')))))\n                    (path_summary loc' loc))\n                b", "by (auto simp: zcount_sum sum_nonneg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>b.\n       0 \\<le> zcount\n                (\\<Sum>loc'\\<in>UNIV.\n                   after_summary (zmset_of (mset_pos (c_pts c loc')))\n                    (path_summary loc' loc))\n                b\n 2. (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n        (path_summary loc' loc)) \\<subseteq>#\\<^sub>z\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary (zmset_of (mset_pos (c_pts c loc')))\n        (path_summary loc' loc))\n 3. \\<And>b.\n       b \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of (mset_pos (c_pts c loc')))\n                            (path_summary loc' loc)) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                              after_summary\n                               (zmset_of\n                                 (mset_set\n                                   (set_antichain\n                                     (frontier (c_pts c loc')))))\n                               (path_summary loc' loc)) \\<and>\n          a \\<le> b", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b.\n       0 \\<le> zcount\n                (\\<Sum>loc'\\<in>UNIV.\n                   after_summary (zmset_of (mset_pos (c_pts c loc')))\n                    (path_summary loc' loc))\n                b", "by (auto simp: zcount_sum sum_nonneg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n        (path_summary loc' loc)) \\<subseteq>#\\<^sub>z\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary (zmset_of (mset_pos (c_pts c loc')))\n        (path_summary loc' loc))\n 2. \\<And>b.\n       b \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of (mset_pos (c_pts c loc')))\n                            (path_summary loc' loc)) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                              after_summary\n                               (zmset_of\n                                 (mset_set\n                                   (set_antichain\n                                     (frontier (c_pts c loc')))))\n                               (path_summary loc' loc)) \\<and>\n          a \\<le> b", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>loc'\\<in>UNIV.\n       after_summary\n        (zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))\n        (path_summary loc' loc)) \\<subseteq>#\\<^sub>z\n    (\\<Sum>loc'\\<in>UNIV.\n       after_summary (zmset_of (mset_pos (c_pts c loc')))\n        (path_summary loc' loc))", "by (rule sum_mono_subseteq[OF after_summary_zmset_frontier])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                           after_summary\n                            (zmset_of (mset_pos (c_pts c loc')))\n                            (path_summary loc' loc)) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in>#\\<^sub>z (\\<Sum>loc'\\<in>UNIV.\n                              after_summary\n                               (zmset_of\n                                 (mset_set\n                                   (set_antichain\n                                     (frontier (c_pts c loc')))))\n                               (path_summary loc' loc)) \\<and>\n          a \\<le> b", "apply (simp flip: zcount_ne_zero_iff add: zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       (\\<Sum>loc'\\<in>UNIV.\n          zcount\n           (after_summary (zmset_of (mset_pos (c_pts c loc')))\n             (path_summary loc' loc))\n           b) \\<noteq>\n       0 \\<Longrightarrow>\n       \\<exists>a.\n          (\\<Sum>loc'\\<in>UNIV.\n             zcount\n              (after_summary\n                (zmset_of\n                  (mset_set (set_antichain (frontier (c_pts c loc')))))\n                (path_summary loc' loc))\n              a) \\<noteq>\n          0 \\<and>\n          a \\<le> b", "apply (erule sum.not_neutral_contains_not_neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a.\n       \\<lbrakk>a \\<in> UNIV;\n        zcount\n         (after_summary (zmset_of (mset_pos (c_pts c a)))\n           (path_summary a loc))\n         b \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<Sum>loc'\\<in>UNIV.\n                               zcount\n                                (after_summary\n                                  (zmset_of\n                                    (mset_set\n(set_antichain (frontier (c_pts c loc')))))\n                                  (path_summary loc' loc))\n                                a) \\<noteq>\n                            0 \\<and>\n                            a \\<le> b", "apply (simp flip: zcount_ne_zero_iff add: after_summary_def zcount_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a.\n       (\\<Sum>s\\<in>set_antichain (path_summary a loc).\n          zcount\n           {#results_in t s\n           . t \\<in>#\\<^sub>z zmset_of (mset_pos (c_pts c a))#}\n           b) \\<noteq>\n       0 \\<Longrightarrow>\n       \\<exists>a.\n          (\\<Sum>loc'\\<in>UNIV.\n             \\<Sum>s\\<in>set_antichain (path_summary loc' loc).\n               zcount\n                {#results_in t s\n                . t \\<in>#\\<^sub>z zmset_of\n                                    (mset_set\n(set_antichain (frontier (c_pts c loc'))))#}\n                a) \\<noteq>\n          0 \\<and>\n          a \\<le> b", "apply (erule sum.not_neutral_contains_not_neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a aa.\n       \\<lbrakk>aa \\<in> set_antichain (path_summary a loc);\n        zcount\n         {#results_in t aa\n         . t \\<in>#\\<^sub>z zmset_of (mset_pos (c_pts c a))#}\n         b \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<Sum>loc'\\<in>UNIV.\n                               \\<Sum>s\\<in>set_antichain\n      (path_summary loc' loc).\n                                 zcount\n                                  {#results_in t s\n                                  . t \\<in>#\\<^sub>z zmset_of\n                (mset_set (set_antichain (frontier (c_pts c loc'))))#}\n                                  a) \\<noteq>\n                            0 \\<and>\n                            a \\<le> b", "apply (simp flip: zcount_ne_zero_iff add: zcount_image_zmset split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a aa.\n       \\<lbrakk>aa \\<in> set_antichain (path_summary a loc);\n        (\\<Sum>y\\<in>(\\<lambda>t. results_in t aa) -` {b} \\<inter>\n                     set_zmset (zmset_of (mset_pos (c_pts c a))).\n           if 0 \\<le> zcount (c_pts c a) y then zcount (c_pts c a) y\n           else 0) \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<Sum>loc'\\<in>UNIV.\n                               \\<Sum>s\\<in>set_antichain\n      (path_summary loc' loc).\n                                 int (card\n ((\\<lambda>t. results_in t s) -` {a} \\<inter>\n  set_zmset\n   (zmset_of\n     (mset_set (set_antichain (frontier (c_pts c loc')))))))) \\<noteq>\n                            0 \\<and>\n                            a \\<le> b", "apply (erule sum.not_neutral_contains_not_neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a aa ab.\n       \\<lbrakk>aa \\<in> set_antichain (path_summary a loc);\n        ab \\<in> (\\<lambda>t. results_in t aa) -` {b} \\<inter>\n                 set_zmset (zmset_of (mset_pos (c_pts c a)));\n        (if 0 \\<le> zcount (c_pts c a) ab then zcount (c_pts c a) ab\n         else 0) \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<Sum>loc'\\<in>UNIV.\n                               \\<Sum>s\\<in>set_antichain\n      (path_summary loc' loc).\n                                 int (card\n ((\\<lambda>t. results_in t s) -` {a} \\<inter>\n  set_zmset\n   (zmset_of\n     (mset_set (set_antichain (frontier (c_pts c loc')))))))) \\<noteq>\n                            0 \\<and>\n                            a \\<le> b", "apply (simp flip: zcount_ne_zero_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a aa ab.\n       \\<lbrakk>aa \\<in> set_antichain (path_summary a loc);\n        results_in ab aa = b;\n        (if 0 \\<le> zcount (c_pts c a) ab then zcount (c_pts c a) ab\n         else 0) \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<Sum>loc'\\<in>UNIV.\n                               \\<Sum>s\\<in>set_antichain\n      (path_summary loc' loc).\n                                 int (card\n ((\\<lambda>t. results_in t s) -` {a} \\<inter>\n  set_zmset\n   (zmset_of\n     (mset_set (set_antichain (frontier (c_pts c loc')))))))) \\<noteq>\n                            0 \\<and>\n                            a \\<le> b", "subgoal for u loc s t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a.\n                         (\\<Sum>loc'\\<in>UNIV.\n                            \\<Sum>s\\<in>set_antichain\n   (path_summary loc' loc).\n                              int (card\n                                    ((\\<lambda>t. results_in t s) -`\n                                     {a} \\<inter>\n                                     set_zmset\n(zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))))) \\<noteq>\n                         0 \\<and>\n                         a \\<le> u", "apply (rule obtain_elem_frontier[of \"c_pts c loc\" t])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> 0 < zcount (c_pts c loc) t\n 2. \\<And>sa.\n       \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n        results_in t s = u;\n        (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n         else 0) \\<noteq>\n        0;\n        sa \\<le> t \\<and> sa \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<Sum>loc'\\<in>UNIV.\n                               \\<Sum>s\\<in>set_antichain\n      (path_summary loc' loc).\n                                 int (card\n ((\\<lambda>t. results_in t s) -` {a} \\<inter>\n  set_zmset\n   (zmset_of\n     (mset_set (set_antichain (frontier (c_pts c loc')))))))) \\<noteq>\n                            0 \\<and>\n                            a \\<le> u", "apply (metis le_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n        results_in t s = u;\n        (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n         else 0) \\<noteq>\n        0;\n        sa \\<le> t \\<and> sa \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<Sum>loc'\\<in>UNIV.\n                               \\<Sum>s\\<in>set_antichain\n      (path_summary loc' loc).\n                                 int (card\n ((\\<lambda>t. results_in t s) -` {a} \\<inter>\n  set_zmset\n   (zmset_of\n     (mset_set (set_antichain (frontier (c_pts c loc')))))))) \\<noteq>\n                            0 \\<and>\n                            a \\<le> u", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0;\n     a \\<le> t \\<and> a \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a.\n                         (\\<Sum>loc'\\<in>UNIV.\n                            \\<Sum>s\\<in>set_antichain\n   (path_summary loc' loc).\n                              int (card\n                                    ((\\<lambda>t. results_in t s) -`\n                                     {a} \\<inter>\n                                     set_zmset\n(zmset_of (mset_set (set_antichain (frontier (c_pts c loc')))))))) \\<noteq>\n                         0 \\<and>\n                         a \\<le> u", "apply (rule exI[of _ \"results_in a s\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0;\n     a \\<le> t \\<and> a \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>loc'\\<in>UNIV.\n                         \\<Sum>sa\\<in>set_antichain (path_summary loc' loc).\n                           int (card\n                                 ((\\<lambda>t. results_in t sa) -`\n                                  {results_in a s} \\<inter>\n                                  set_zmset\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_pts c loc')))))))) \\<noteq>\n                      0 \\<and>\n                      results_in a s \\<le> u", "apply (rule conjI[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0;\n     a \\<le> t \\<and> a \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> results_in a s \\<le> u\n 2. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0;\n     a \\<le> t \\<and> a \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>loc'\\<in>UNIV.\n                         \\<Sum>sa\\<in>set_antichain (path_summary loc' loc).\n                           int (card\n                                 ((\\<lambda>t. results_in t sa) -`\n                                  {results_in a s} \\<inter>\n                                  set_zmset\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_pts c loc')))))))) \\<noteq>\n                      0", "using results_in_mono(1)"], ["proof (prove)\nusing this:\n  ?t1.0 \\<le> ?t2.0 \\<Longrightarrow>\n  results_in ?t1.0 ?s \\<le> results_in ?t2.0 ?s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0;\n     a \\<le> t \\<and> a \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> results_in a s \\<le> u\n 2. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0;\n     a \\<le> t \\<and> a \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>loc'\\<in>UNIV.\n                         \\<Sum>sa\\<in>set_antichain (path_summary loc' loc).\n                           int (card\n                                 ((\\<lambda>t. results_in t sa) -`\n                                  {results_in a s} \\<inter>\n                                  set_zmset\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_pts c loc')))))))) \\<noteq>\n                      0", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0;\n     a \\<le> t \\<and> a \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>loc'\\<in>UNIV.\n                         \\<Sum>sa\\<in>set_antichain (path_summary loc' loc).\n                           int (card\n                                 ((\\<lambda>t. results_in t sa) -`\n                                  {results_in a s} \\<inter>\n                                  set_zmset\n                                   (zmset_of\n                                     (mset_set\n (set_antichain (frontier (c_pts c loc')))))))) \\<noteq>\n                      0", "apply (subst sum_nonneg_eq_0_iff; simp add: sum_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0;\n     a \\<le> t \\<and> a \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (\\<Sum>sa\\<in>set_antichain (path_summary x loc).\n                            int (card\n                                  ((\\<lambda>t. results_in t sa) -`\n                                   {results_in a s} \\<inter>\n                                   set_zmset\n                                    (zmset_of\n(mset_set (set_antichain (frontier (c_pts c x)))))))) \\<noteq>\n                         0", "apply (rule exI[of _ loc])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0;\n     a \\<le> t \\<and> a \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>sa\\<in>set_antichain (path_summary loc loc).\n                         int (card\n                               ((\\<lambda>t. results_in t sa) -`\n                                {results_in a s} \\<inter>\n                                set_zmset\n                                 (zmset_of\n                                   (mset_set\n                                     (set_antichain\n (frontier (c_pts c loc)))))))) \\<noteq>\n                      0", "apply (subst sum_nonneg_eq_0_iff; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0;\n     a \\<le> t \\<and> a \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>set_antichain (path_summary loc loc).\n                         (\\<lambda>t. results_in t x) -`\n                         {results_in a s} \\<inter>\n                         set_zmset\n                          (zmset_of\n                            (mset_set\n                              (set_antichain\n                                (frontier (c_pts c loc))))) \\<noteq>\n                         {}", "apply (rule bexI[of _ s])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0;\n     a \\<le> t \\<and> a \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>t. results_in t s) -`\n                      {results_in a s} \\<inter>\n                      set_zmset\n                       (zmset_of\n                         (mset_set\n                           (set_antichain\n                             (frontier (c_pts c loc))))) \\<noteq>\n                      {}\n 2. \\<lbrakk>s \\<in> set_antichain (path_summary loc loc);\n     results_in t s = u;\n     (if 0 \\<le> zcount (c_pts c loc) t then zcount (c_pts c loc) t\n      else 0) \\<noteq>\n     0;\n     a \\<le> t \\<and> a \\<in>\\<^sub>A frontier (c_pts c loc)\\<rbrakk>\n    \\<Longrightarrow> s \\<in> set_antichain (path_summary loc loc)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas alw_implication_frontier_eq_implied_frontier_vacant =\n  alw_implication_frontier_eq_implied_frontier_alt_vacant[folded implied_frontier_implied_frontier_alt]"], ["", "lemmas implication_frontier_iff_implied_frontier_vacant =\n  implication_frontier_iff_implied_frontier_alt_vacant[folded implied_frontier_implied_frontier_alt]"], ["", "end"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}