{"file_name": "/home/qj213/afp-2021-10-22/thys/Isabelle_Marries_Dirac/Complex_Vectors.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Isabelle_Marries_Dirac", "problem_names": ["lemma cpx_cring_is_field [simp]:\n  \"field cpx_rng\"", "lemma cpx_abelian_monoid [simp]:\n  \"abelian_monoid cpx_rng\"", "lemma vecspace_cpx_vec [simp]:\n  \"vectorspace cpx_rng (module_cpx_vec n)\"", "lemma module_cpx_vec [simp]:\n  \"Module.module cpx_rng (module_cpx_vec n)\"", "lemma unit_vectors_carrier_vec [simp]:\n  \"unit_vectors n \\<subseteq> carrier_vec n\"", "lemma (in Module.module) finsum_over_singleton [simp]:\n  assumes \"f x \\<in> carrier M\"\n  shows \"finsum M f {x} = f x\"", "lemma lincomb_over_singleton [simp]:\n  assumes \"x \\<in> carrier_vec n\" and \"f \\<in> {x} \\<rightarrow> UNIV\"\n  shows \"module.lincomb (module_cpx_vec n) f {x} = f x \\<cdot>\\<^sub>v x\"", "lemma dim_vec_lincomb [simp]:\n  assumes \"finite F\" and \"f: F \\<rightarrow> UNIV\" and \"F \\<subseteq> carrier_vec n\"\n  shows \"dim_vec (module.lincomb (module_cpx_vec n) f F) = n\"", "lemma lincomb_vec_index [simp]:\n  assumes \"finite F\" and a2:\"i < n\" and \"F \\<subseteq> carrier_vec n\" and \"f: F \\<rightarrow> UNIV\"\n  shows \"module.lincomb (module_cpx_vec n) f F $ i = (\\<Sum>v\\<in>F. f v * (v $ i))\"", "lemma unit_vectors_is_lin_indpt [simp]:\n  \"module.lin_indpt cpx_rng (module_cpx_vec n) (unit_vectors n)\"", "lemma unit_vectors_is_genset [simp]:\n  \"module.gen_set cpx_rng (module_cpx_vec n) (unit_vectors n)\"", "lemma unit_vectors_is_basis [simp]:\n  \"vectorspace.basis cpx_rng (module_cpx_vec n) (unit_vectors n)\"", "lemma state_qbit_is_lincomb [simp]:\n  \"state_qbit n = \n  {module.lincomb (module_cpx_vec (2^n)) a A|a A. \n    finite A \\<and> A\\<subseteq>(unit_vectors (2^n)) \\<and> a\\<in> A \\<rightarrow> UNIV \\<and> \\<parallel>module.lincomb (module_cpx_vec (2^n)) a A\\<parallel> = 1}\""], "translations": [["", "lemma cpx_cring_is_field [simp]:\n  \"field cpx_rng\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field cpx_rng", "apply unfold_locales"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid cpx_rng);\n        y \\<in> carrier (add_monoid cpx_rng)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub> y\n                         \\<in> carrier (add_monoid cpx_rng)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (add_monoid cpx_rng);\n        y \\<in> carrier (add_monoid cpx_rng);\n        z \\<in> carrier (add_monoid cpx_rng)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub> z)\n 3. \\<one>\\<^bsub>add_monoid cpx_rng\\<^esub>\n    \\<in> carrier (add_monoid cpx_rng)\n 4. \\<And>x.\n       x \\<in> carrier (add_monoid cpx_rng) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid cpx_rng\\<^esub> \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier (add_monoid cpx_rng) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub>\n       \\<one>\\<^bsub>add_monoid cpx_rng\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid cpx_rng);\n        y \\<in> carrier (add_monoid cpx_rng)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub> y =\n                         y \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub> x\n 7. carrier (add_monoid cpx_rng) \\<subseteq> Units (add_monoid cpx_rng)\n 8. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier cpx_rng; y \\<in> carrier cpx_rng\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>cpx_rng\\<^esub> y\n                         \\<in> carrier cpx_rng\n 9. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier cpx_rng; y \\<in> carrier cpx_rng;\n        z \\<in> carrier cpx_rng\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>cpx_rng\\<^esub>\n                         y \\<otimes>\\<^bsub>cpx_rng\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>cpx_rng\\<^esub>\n                         (y \\<otimes>\\<^bsub>cpx_rng\\<^esub> z)\n 10. \\<one>\\<^bsub>cpx_rng\\<^esub> \\<in> carrier cpx_rng\nA total of 18 subgoals...", "apply (auto intro: right_inverse simp: cpx_rng_def Units_def field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>xa. x + xa = 0", "by (metis add.right_neutral add_diff_cancel_left' add_uminus_conv_diff)"], ["", "lemma cpx_abelian_monoid [simp]:\n  \"abelian_monoid cpx_rng\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abelian_monoid cpx_rng", "using cpx_cring_is_field"], ["proof (prove)\nusing this:\n  field cpx_rng\n\ngoal (1 subgoal):\n 1. abelian_monoid cpx_rng", "by (simp add: field_def abelian_group_def cring_def domain_def ring_def)"], ["", "lemma vecspace_cpx_vec [simp]:\n  \"vectorspace cpx_rng (module_cpx_vec n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace cpx_rng (module_cpx_vec n)", "apply unfold_locales"], ["proof (prove)\ngoal (30 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid cpx_rng);\n        y \\<in> carrier (add_monoid cpx_rng)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub> y\n                         \\<in> carrier (add_monoid cpx_rng)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (add_monoid cpx_rng);\n        y \\<in> carrier (add_monoid cpx_rng);\n        z \\<in> carrier (add_monoid cpx_rng)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub> z)\n 3. \\<one>\\<^bsub>add_monoid cpx_rng\\<^esub>\n    \\<in> carrier (add_monoid cpx_rng)\n 4. \\<And>x.\n       x \\<in> carrier (add_monoid cpx_rng) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid cpx_rng\\<^esub> \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier (add_monoid cpx_rng) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub>\n       \\<one>\\<^bsub>add_monoid cpx_rng\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid cpx_rng);\n        y \\<in> carrier (add_monoid cpx_rng)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub> y =\n                         y \\<otimes>\\<^bsub>add_monoid cpx_rng\\<^esub> x\n 7. carrier (add_monoid cpx_rng) \\<subseteq> Units (add_monoid cpx_rng)\n 8. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier cpx_rng; y \\<in> carrier cpx_rng\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>cpx_rng\\<^esub> y\n                         \\<in> carrier cpx_rng\n 9. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier cpx_rng; y \\<in> carrier cpx_rng;\n        z \\<in> carrier cpx_rng\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>cpx_rng\\<^esub>\n                         y \\<otimes>\\<^bsub>cpx_rng\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>cpx_rng\\<^esub>\n                         (y \\<otimes>\\<^bsub>cpx_rng\\<^esub> z)\n 10. \\<one>\\<^bsub>cpx_rng\\<^esub> \\<in> carrier cpx_rng\nA total of 30 subgoals...", "apply (auto simp: cpx_rng_def module_cpx_vec_def module_vec_def Units_def field_simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. \\<exists>xa. x + xa = 0\n 2. \\<And>x.\n       x \\<in> carrier_vec n \\<Longrightarrow>\n       \\<exists>xa\\<in>carrier_vec n.\n          xa + x = 0\\<^sub>v n \\<and> x + xa = 0\\<^sub>v n\n 3. \\<And>x. x \\<noteq> 0 \\<Longrightarrow> \\<exists>xa. x * xa = 1", "apply (auto intro: right_inverse add_inv_exists_vec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>xa. x + xa = 0", "by (metis add.right_neutral add_diff_cancel_left' add_uminus_conv_diff)"], ["", "lemma module_cpx_vec [simp]:\n  \"Module.module cpx_rng (module_cpx_vec n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Module.module cpx_rng (module_cpx_vec n)", "using vecspace_cpx_vec"], ["proof (prove)\nusing this:\n  vectorspace cpx_rng (module_cpx_vec ?n)\n\ngoal (1 subgoal):\n 1. Module.module cpx_rng (module_cpx_vec n)", "by (simp add: vectorspace_def)"], ["", "definition state_basis:: \"nat \\<Rightarrow> nat \\<Rightarrow> complex vec\" where\n\"state_basis n i \\<equiv> unit_vec (2^n) i\""], ["", "definition unit_vectors:: \"nat \\<Rightarrow> (complex vec) set\" where\n\"unit_vectors n \\<equiv> {unit_vec n i | i::nat. 0 \\<le> i \\<and> i < n}\""], ["", "lemma unit_vectors_carrier_vec [simp]:\n  \"unit_vectors n \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_vectors n \\<subseteq> carrier_vec n", "using unit_vectors_def"], ["proof (prove)\nusing this:\n  unit_vectors ?n \\<equiv> {unit_vec ?n i |i. 0 \\<le> i \\<and> i < ?n}\n\ngoal (1 subgoal):\n 1. unit_vectors n \\<subseteq> carrier_vec n", "by auto"], ["", "lemma (in Module.module) finsum_over_singleton [simp]:\n  assumes \"f x \\<in> carrier M\"\n  shows \"finsum M f {x} = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum M f {x} = f x", "using assms"], ["proof (prove)\nusing this:\n  f x \\<in> carrier M\n\ngoal (1 subgoal):\n 1. finsum M f {x} = f x", "by simp"], ["", "lemma lincomb_over_singleton [simp]:\n  assumes \"x \\<in> carrier_vec n\" and \"f \\<in> {x} \\<rightarrow> UNIV\"\n  shows \"module.lincomb (module_cpx_vec n) f {x} = f x \\<cdot>\\<^sub>v x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f {x} = f x \\<cdot>\\<^sub>v x", "using assms module.lincomb_def module_cpx_vec module_cpx_vec_def module.finsum_over_singleton"], ["proof (prove)\nusing this:\n  x \\<in> carrier_vec n\n  f \\<in> {x} \\<rightarrow> UNIV\n  Module.module ?R ?M \\<Longrightarrow>\n  module.lincomb ?M ?a ?A =\n  (\\<Oplus>\\<^bsub>?M\\<^esub>v\\<in>?A. ?a v \\<odot>\\<^bsub>?M\\<^esub> v)\n  Module.module cpx_rng (module_cpx_vec ?n)\n  module_cpx_vec ?n \\<equiv> module_vec TYPE(complex) ?n\n  \\<lbrakk>Module.module ?R ?M; ?f ?x \\<in> carrier ?M\\<rbrakk>\n  \\<Longrightarrow> finsum ?M ?f {?x} = ?f ?x\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f {x} = f x \\<cdot>\\<^sub>v x", "by (smt module_vec_simps(3) module_vec_simps(4) smult_carrier_vec)"], ["", "lemma dim_vec_lincomb [simp]:\n  assumes \"finite F\" and \"f: F \\<rightarrow> UNIV\" and \"F \\<subseteq> carrier_vec n\"\n  shows \"dim_vec (module.lincomb (module_cpx_vec n) f F) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (module.lincomb (module_cpx_vec n) f F) = n", "using assms"], ["proof (prove)\nusing this:\n  finite F\n  f \\<in> F \\<rightarrow> UNIV\n  F \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec (module.lincomb (module_cpx_vec n) f F) = n", "proof(induct F)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> {} \\<rightarrow> UNIV;\n     {} \\<subseteq> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec n) f {}) = n\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>f \\<in> F \\<rightarrow> UNIV;\n         F \\<subseteq> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec n) f F) =\n                          n;\n        f \\<in> insert x F \\<rightarrow> UNIV;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> dim_vec\n                          (module.lincomb (module_cpx_vec n) f\n                            (insert x F)) =\n                         n", "case empty"], ["proof (state)\nthis:\n  f \\<in> {} \\<rightarrow> UNIV\n  {} \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> {} \\<rightarrow> UNIV;\n     {} \\<subseteq> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec n) f {}) = n\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>f \\<in> F \\<rightarrow> UNIV;\n         F \\<subseteq> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec n) f F) =\n                          n;\n        f \\<in> insert x F \\<rightarrow> UNIV;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> dim_vec\n                          (module.lincomb (module_cpx_vec n) f\n                            (insert x F)) =\n                         n", "show \"dim_vec (module.lincomb (module_cpx_vec n) f {}) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (module.lincomb (module_cpx_vec n) f {}) = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dim_vec (module.lincomb (module_cpx_vec n) f {}) = n", "have \"module.lincomb (module_cpx_vec n) f {} = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f {} = 0\\<^sub>v n", "using module.lincomb_def abelian_monoid.finsum_empty module_cpx_vec_def vecspace_cpx_vec vectorspace_def"], ["proof (prove)\nusing this:\n  Module.module ?R ?M \\<Longrightarrow>\n  module.lincomb ?M ?a ?A =\n  (\\<Oplus>\\<^bsub>?M\\<^esub>v\\<in>?A. ?a v \\<odot>\\<^bsub>?M\\<^esub> v)\n  abelian_monoid ?G \\<Longrightarrow>\n  finsum ?G ?f {} = \\<zero>\\<^bsub>?G\\<^esub>\n  module_cpx_vec ?n \\<equiv> module_vec TYPE(complex) ?n\n  vectorspace cpx_rng (module_cpx_vec ?n)\n  vectorspace ?K ?V \\<equiv> Module.module ?K ?V \\<and> field ?K\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f {} = 0\\<^sub>v n", "by (smt abelian_group_def Module.module_def module_vec_simps(2))"], ["proof (state)\nthis:\n  module.lincomb (module_cpx_vec n) f {} = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. dim_vec (module.lincomb (module_cpx_vec n) f {}) = n", "thus ?thesis"], ["proof (prove)\nusing this:\n  module.lincomb (module_cpx_vec n) f {} = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. dim_vec (module.lincomb (module_cpx_vec n) f {}) = n", "by simp"], ["proof (state)\nthis:\n  dim_vec (module.lincomb (module_cpx_vec n) f {}) = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dim_vec (module.lincomb (module_cpx_vec n) f {}) = n\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>f \\<in> F \\<rightarrow> UNIV;\n         F \\<subseteq> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec n) f F) =\n                          n;\n        f \\<in> insert x F \\<rightarrow> UNIV;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> dim_vec\n                          (module.lincomb (module_cpx_vec n) f\n                            (insert x F)) =\n                         n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>f \\<in> F \\<rightarrow> UNIV;\n         F \\<subseteq> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec n) f F) =\n                          n;\n        f \\<in> insert x F \\<rightarrow> UNIV;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> dim_vec\n                          (module.lincomb (module_cpx_vec n) f\n                            (insert x F)) =\n                         n", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>f \\<in> F \\<rightarrow> UNIV;\n   F \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec n) f F) = n\n  f \\<in> insert x F \\<rightarrow> UNIV\n  insert x F \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>f \\<in> F \\<rightarrow> UNIV;\n         F \\<subseteq> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec n) f F) =\n                          n;\n        f \\<in> insert x F \\<rightarrow> UNIV;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> dim_vec\n                          (module.lincomb (module_cpx_vec n) f\n                            (insert x F)) =\n                         n", "hence \"module.lincomb (module_cpx_vec n) f (insert x F) = \n    (f x \\<cdot>\\<^sub>v x) \\<oplus>\\<^bsub>module_cpx_vec n\\<^esub> module.lincomb (module_cpx_vec n) f F\""], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>f \\<in> F \\<rightarrow> UNIV;\n   F \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec n) f F) = n\n  f \\<in> insert x F \\<rightarrow> UNIV\n  insert x F \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f (insert x F) =\n    f x \\<cdot>\\<^sub>v x \\<oplus>\\<^bsub>module_cpx_vec n\\<^esub>\n    module.lincomb (module_cpx_vec n) f F", "using module_cpx_vec_def module_vec_def module_cpx_vec module.lincomb_insert cpx_rng_def insert_subset"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>f \\<in> F \\<rightarrow> UNIV;\n   F \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec n) f F) = n\n  f \\<in> insert x F \\<rightarrow> UNIV\n  insert x F \\<subseteq> carrier_vec n\n  module_cpx_vec ?n \\<equiv> module_vec TYPE(complex) ?n\n  module_vec ?ty ?n \\<equiv>\n  \\<lparr>carrier = carrier_vec ?n, monoid.mult = undefined,\n     one = undefined, zero = 0\\<^sub>v ?n, add = (+),\n     module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\n  Module.module cpx_rng (module_cpx_vec ?n)\n  \\<lbrakk>Module.module ?R ?M; finite ?S; ?S \\<subseteq> carrier ?M;\n   ?a \\<in> ?S \\<union> {?v} \\<rightarrow> carrier ?R; ?v \\<notin> ?S;\n   ?v \\<in> carrier ?M\\<rbrakk>\n  \\<Longrightarrow> module.lincomb ?M ?a (?S \\<union> {?v}) =\n                    ?a ?v \\<odot>\\<^bsub>?M\\<^esub>\n                    ?v \\<oplus>\\<^bsub>?M\\<^esub>\n                    module.lincomb ?M ?a ?S\n  cpx_rng \\<equiv>\n  \\<lparr>carrier = UNIV, monoid.mult = (*), one = 1, zero = 0,\n     add = (+)\\<rparr>\n  (insert ?x ?A \\<subseteq> ?B) = (?x \\<in> ?B \\<and> ?A \\<subseteq> ?B)\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f (insert x F) =\n    f x \\<cdot>\\<^sub>v x \\<oplus>\\<^bsub>module_cpx_vec n\\<^esub>\n    module.lincomb (module_cpx_vec n) f F", "by (smt Pi_I' UNIV_I Un_insert_right module_vec_simps(4) partial_object.select_convs(1) sup_bot.comm_neutral)"], ["proof (state)\nthis:\n  module.lincomb (module_cpx_vec n) f (insert x F) =\n  f x \\<cdot>\\<^sub>v x \\<oplus>\\<^bsub>module_cpx_vec n\\<^esub>\n  module.lincomb (module_cpx_vec n) f F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>f \\<in> F \\<rightarrow> UNIV;\n         F \\<subseteq> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec n) f F) =\n                          n;\n        f \\<in> insert x F \\<rightarrow> UNIV;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> dim_vec\n                          (module.lincomb (module_cpx_vec n) f\n                            (insert x F)) =\n                         n", "hence \"dim_vec (module.lincomb (module_cpx_vec n) f (insert x F)) = \n    dim_vec (module.lincomb (module_cpx_vec n) f F)\""], ["proof (prove)\nusing this:\n  module.lincomb (module_cpx_vec n) f (insert x F) =\n  f x \\<cdot>\\<^sub>v x \\<oplus>\\<^bsub>module_cpx_vec n\\<^esub>\n  module.lincomb (module_cpx_vec n) f F\n\ngoal (1 subgoal):\n 1. dim_vec (module.lincomb (module_cpx_vec n) f (insert x F)) =\n    dim_vec (module.lincomb (module_cpx_vec n) f F)", "using index_add_vec"], ["proof (prove)\nusing this:\n  module.lincomb (module_cpx_vec n) f (insert x F) =\n  f x \\<cdot>\\<^sub>v x \\<oplus>\\<^bsub>module_cpx_vec n\\<^esub>\n  module.lincomb (module_cpx_vec n) f F\n  ?i < dim_vec ?v\\<^sub>2 \\<Longrightarrow>\n  (?v\\<^sub>1 + ?v\\<^sub>2) $ ?i = ?v\\<^sub>1 $ ?i + ?v\\<^sub>2 $ ?i\n  dim_vec (?v\\<^sub>1 + ?v\\<^sub>2) = dim_vec ?v\\<^sub>2\n\ngoal (1 subgoal):\n 1. dim_vec (module.lincomb (module_cpx_vec n) f (insert x F)) =\n    dim_vec (module.lincomb (module_cpx_vec n) f F)", "by (simp add: module_cpx_vec_def module_vec_simps(1))"], ["proof (state)\nthis:\n  dim_vec (module.lincomb (module_cpx_vec n) f (insert x F)) =\n  dim_vec (module.lincomb (module_cpx_vec n) f F)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>f \\<in> F \\<rightarrow> UNIV;\n         F \\<subseteq> carrier_vec n\\<rbrakk>\n        \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec n) f F) =\n                          n;\n        f \\<in> insert x F \\<rightarrow> UNIV;\n        insert x F \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> dim_vec\n                          (module.lincomb (module_cpx_vec n) f\n                            (insert x F)) =\n                         n", "thus \"dim_vec (module.lincomb (module_cpx_vec n) f (insert x F)) = n\""], ["proof (prove)\nusing this:\n  dim_vec (module.lincomb (module_cpx_vec n) f (insert x F)) =\n  dim_vec (module.lincomb (module_cpx_vec n) f F)\n\ngoal (1 subgoal):\n 1. dim_vec (module.lincomb (module_cpx_vec n) f (insert x F)) = n", "using insert.hyps(3) insert.prems(2)"], ["proof (prove)\nusing this:\n  dim_vec (module.lincomb (module_cpx_vec n) f (insert x F)) =\n  dim_vec (module.lincomb (module_cpx_vec n) f F)\n  \\<lbrakk>f \\<in> F \\<rightarrow> UNIV;\n   F \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec n) f F) = n\n  insert x F \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec (module.lincomb (module_cpx_vec n) f (insert x F)) = n", "by simp"], ["proof (state)\nthis:\n  dim_vec (module.lincomb (module_cpx_vec n) f (insert x F)) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lincomb_vec_index [simp]:\n  assumes \"finite F\" and a2:\"i < n\" and \"F \\<subseteq> carrier_vec n\" and \"f: F \\<rightarrow> UNIV\"\n  shows \"module.lincomb (module_cpx_vec n) f F $ i = (\\<Sum>v\\<in>F. f v * (v $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f F $ i = (\\<Sum>v\\<in>F. f v * v $ i)", "using assms"], ["proof (prove)\nusing this:\n  finite F\n  i < n\n  F \\<subseteq> carrier_vec n\n  f \\<in> F \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f F $ i = (\\<Sum>v\\<in>F. f v * v $ i)", "proof(induct F)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < n; {} \\<subseteq> carrier_vec n;\n     f \\<in> {} \\<rightarrow> UNIV\\<rbrakk>\n    \\<Longrightarrow> module.lincomb (module_cpx_vec n) f {} $ i =\n                      (\\<Sum>v\\<in>{}. f v * v $ i)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>i < n; F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> UNIV\\<rbrakk>\n        \\<Longrightarrow> module.lincomb (module_cpx_vec n) f F $ i =\n                          (\\<Sum>v\\<in>F. f v * v $ i);\n        i < n; insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> UNIV\\<rbrakk>\n       \\<Longrightarrow> module.lincomb (module_cpx_vec n) f (insert x F) $\n                         i =\n                         (\\<Sum>v\\<in>insert x F. f v * v $ i)", "case empty"], ["proof (state)\nthis:\n  i < n\n  {} \\<subseteq> carrier_vec n\n  f \\<in> {} \\<rightarrow> UNIV\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < n; {} \\<subseteq> carrier_vec n;\n     f \\<in> {} \\<rightarrow> UNIV\\<rbrakk>\n    \\<Longrightarrow> module.lincomb (module_cpx_vec n) f {} $ i =\n                      (\\<Sum>v\\<in>{}. f v * v $ i)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>i < n; F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> UNIV\\<rbrakk>\n        \\<Longrightarrow> module.lincomb (module_cpx_vec n) f F $ i =\n                          (\\<Sum>v\\<in>F. f v * v $ i);\n        i < n; insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> UNIV\\<rbrakk>\n       \\<Longrightarrow> module.lincomb (module_cpx_vec n) f (insert x F) $\n                         i =\n                         (\\<Sum>v\\<in>insert x F. f v * v $ i)", "then"], ["proof (chain)\npicking this:\n  i < n\n  {} \\<subseteq> carrier_vec n\n  f \\<in> {} \\<rightarrow> UNIV", "show \"module.lincomb (module_cpx_vec n) f {} $ i = (\\<Sum>v\\<in>{}. f v * v $ i)\""], ["proof (prove)\nusing this:\n  i < n\n  {} \\<subseteq> carrier_vec n\n  f \\<in> {} \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f {} $ i =\n    (\\<Sum>v\\<in>{}. f v * v $ i)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> module.lincomb (module_cpx_vec n) f {} $ i = 0", "using a2 module.lincomb_def abelian_monoid.finsum_empty module_cpx_vec_def"], ["proof (prove)\nusing this:\n  i < n\n  Module.module ?R ?M \\<Longrightarrow>\n  module.lincomb ?M ?a ?A =\n  (\\<Oplus>\\<^bsub>?M\\<^esub>v\\<in>?A. ?a v \\<odot>\\<^bsub>?M\\<^esub> v)\n  abelian_monoid ?G \\<Longrightarrow>\n  finsum ?G ?f {} = \\<zero>\\<^bsub>?G\\<^esub>\n  module_cpx_vec ?n \\<equiv> module_vec TYPE(complex) ?n\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> module.lincomb (module_cpx_vec n) f {} $ i = 0", "by (metis (mono_tags) abelian_group_def index_zero_vec(1) module_cpx_vec Module.module_def module_vec_simps(2))"], ["proof (state)\nthis:\n  module.lincomb (module_cpx_vec n) f {} $ i = (\\<Sum>v\\<in>{}. f v * v $ i)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>i < n; F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> UNIV\\<rbrakk>\n        \\<Longrightarrow> module.lincomb (module_cpx_vec n) f F $ i =\n                          (\\<Sum>v\\<in>F. f v * v $ i);\n        i < n; insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> UNIV\\<rbrakk>\n       \\<Longrightarrow> module.lincomb (module_cpx_vec n) f (insert x F) $\n                         i =\n                         (\\<Sum>v\\<in>insert x F. f v * v $ i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>i < n; F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> UNIV\\<rbrakk>\n        \\<Longrightarrow> module.lincomb (module_cpx_vec n) f F $ i =\n                          (\\<Sum>v\\<in>F. f v * v $ i);\n        i < n; insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> UNIV\\<rbrakk>\n       \\<Longrightarrow> module.lincomb (module_cpx_vec n) f (insert x F) $\n                         i =\n                         (\\<Sum>v\\<in>insert x F. f v * v $ i)", "case(insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>i < n; F \\<subseteq> carrier_vec n;\n   f \\<in> F \\<rightarrow> UNIV\\<rbrakk>\n  \\<Longrightarrow> module.lincomb (module_cpx_vec n) f F $ i =\n                    (\\<Sum>v\\<in>F. f v * v $ i)\n  i < n\n  insert x F \\<subseteq> carrier_vec n\n  f \\<in> insert x F \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>i < n; F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> UNIV\\<rbrakk>\n        \\<Longrightarrow> module.lincomb (module_cpx_vec n) f F $ i =\n                          (\\<Sum>v\\<in>F. f v * v $ i);\n        i < n; insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> UNIV\\<rbrakk>\n       \\<Longrightarrow> module.lincomb (module_cpx_vec n) f (insert x F) $\n                         i =\n                         (\\<Sum>v\\<in>insert x F. f v * v $ i)", "have \"module.lincomb (module_cpx_vec n) f (insert x F) = \n      f x \\<cdot>\\<^sub>v x \\<oplus>\\<^bsub>module_cpx_vec n\\<^esub> module.lincomb (module_cpx_vec n) f F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f (insert x F) =\n    f x \\<cdot>\\<^sub>v x \\<oplus>\\<^bsub>module_cpx_vec n\\<^esub>\n    module.lincomb (module_cpx_vec n) f F", "using module.lincomb_insert module_cpx_vec insert.hyps(1) module_cpx_vec_def module_vec_def\n      insert.prems(2) insert.hyps(2) insert.prems(3) insert_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>Module.module ?R ?M; finite ?S; ?S \\<subseteq> carrier ?M;\n   ?a \\<in> ?S \\<union> {?v} \\<rightarrow> carrier ?R; ?v \\<notin> ?S;\n   ?v \\<in> carrier ?M\\<rbrakk>\n  \\<Longrightarrow> module.lincomb ?M ?a (?S \\<union> {?v}) =\n                    ?a ?v \\<odot>\\<^bsub>?M\\<^esub>\n                    ?v \\<oplus>\\<^bsub>?M\\<^esub>\n                    module.lincomb ?M ?a ?S\n  Module.module cpx_rng (module_cpx_vec ?n)\n  finite F\n  module_cpx_vec ?n \\<equiv> module_vec TYPE(complex) ?n\n  module_vec ?ty ?n \\<equiv>\n  \\<lparr>carrier = carrier_vec ?n, monoid.mult = undefined,\n     one = undefined, zero = 0\\<^sub>v ?n, add = (+),\n     module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\n  insert x F \\<subseteq> carrier_vec n\n  x \\<notin> F\n  f \\<in> insert x F \\<rightarrow> UNIV\n  insert ?a ?B = {x. x = ?a} \\<union> ?B\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f (insert x F) =\n    f x \\<cdot>\\<^sub>v x \\<oplus>\\<^bsub>module_cpx_vec n\\<^esub>\n    module.lincomb (module_cpx_vec n) f F", "by (smt Pi_I' UNIV_I Un_insert_right cpx_rng_def insert_subset module_vec_simps(4) \n        partial_object.select_convs(1) sup_bot.comm_neutral)"], ["proof (state)\nthis:\n  module.lincomb (module_cpx_vec n) f (insert x F) =\n  f x \\<cdot>\\<^sub>v x \\<oplus>\\<^bsub>module_cpx_vec n\\<^esub>\n  module.lincomb (module_cpx_vec n) f F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>i < n; F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> UNIV\\<rbrakk>\n        \\<Longrightarrow> module.lincomb (module_cpx_vec n) f F $ i =\n                          (\\<Sum>v\\<in>F. f v * v $ i);\n        i < n; insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> UNIV\\<rbrakk>\n       \\<Longrightarrow> module.lincomb (module_cpx_vec n) f (insert x F) $\n                         i =\n                         (\\<Sum>v\\<in>insert x F. f v * v $ i)", "then"], ["proof (chain)\npicking this:\n  module.lincomb (module_cpx_vec n) f (insert x F) =\n  f x \\<cdot>\\<^sub>v x \\<oplus>\\<^bsub>module_cpx_vec n\\<^esub>\n  module.lincomb (module_cpx_vec n) f F", "have \"module.lincomb (module_cpx_vec n) f (insert x F) $ i = \n      (f x \\<cdot>\\<^sub>v x) $ i + module.lincomb (module_cpx_vec n) f F $ i\""], ["proof (prove)\nusing this:\n  module.lincomb (module_cpx_vec n) f (insert x F) =\n  f x \\<cdot>\\<^sub>v x \\<oplus>\\<^bsub>module_cpx_vec n\\<^esub>\n  module.lincomb (module_cpx_vec n) f F\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f (insert x F) $ i =\n    (f x \\<cdot>\\<^sub>v x) $ i + module.lincomb (module_cpx_vec n) f F $ i", "using index_add_vec(1) a2 dim_vec_lincomb"], ["proof (prove)\nusing this:\n  module.lincomb (module_cpx_vec n) f (insert x F) =\n  f x \\<cdot>\\<^sub>v x \\<oplus>\\<^bsub>module_cpx_vec n\\<^esub>\n  module.lincomb (module_cpx_vec n) f F\n  ?i < dim_vec ?v\\<^sub>2 \\<Longrightarrow>\n  (?v\\<^sub>1 + ?v\\<^sub>2) $ ?i = ?v\\<^sub>1 $ ?i + ?v\\<^sub>2 $ ?i\n  i < n\n  \\<lbrakk>finite ?F; ?f \\<in> ?F \\<rightarrow> UNIV;\n   ?F \\<subseteq> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec ?n) ?f ?F) = ?n\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f (insert x F) $ i =\n    (f x \\<cdot>\\<^sub>v x) $ i + module.lincomb (module_cpx_vec n) f F $ i", "by (metis Pi_split_insert_domain  insert.hyps(1) insert.prems(2) insert.prems(3) insert_subset \n        module_cpx_vec_def module_vec_simps(1))"], ["proof (state)\nthis:\n  module.lincomb (module_cpx_vec n) f (insert x F) $ i =\n  (f x \\<cdot>\\<^sub>v x) $ i + module.lincomb (module_cpx_vec n) f F $ i\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>i < n; F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> UNIV\\<rbrakk>\n        \\<Longrightarrow> module.lincomb (module_cpx_vec n) f F $ i =\n                          (\\<Sum>v\\<in>F. f v * v $ i);\n        i < n; insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> UNIV\\<rbrakk>\n       \\<Longrightarrow> module.lincomb (module_cpx_vec n) f (insert x F) $\n                         i =\n                         (\\<Sum>v\\<in>insert x F. f v * v $ i)", "hence \"module.lincomb (module_cpx_vec n) f (insert x F) $ i = f x * x $ i + (\\<Sum>v\\<in>F. f v * v $ i)\""], ["proof (prove)\nusing this:\n  module.lincomb (module_cpx_vec n) f (insert x F) $ i =\n  (f x \\<cdot>\\<^sub>v x) $ i + module.lincomb (module_cpx_vec n) f F $ i\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f (insert x F) $ i =\n    f x * x $ i + (\\<Sum>v\\<in>F. f v * v $ i)", "using index_smult_vec a2 insert.prems(2) insert_def insert.hyps(3)"], ["proof (prove)\nusing this:\n  module.lincomb (module_cpx_vec n) f (insert x F) $ i =\n  (f x \\<cdot>\\<^sub>v x) $ i + module.lincomb (module_cpx_vec n) f F $ i\n  ?i < dim_vec ?v \\<Longrightarrow>\n  (?a \\<cdot>\\<^sub>v ?v) $ ?i = ?a * ?v $ ?i\n  dim_vec (?a \\<cdot>\\<^sub>v ?v) = dim_vec ?v\n  i < n\n  insert x F \\<subseteq> carrier_vec n\n  insert ?a ?B = {x. x = ?a} \\<union> ?B\n  \\<lbrakk>i < n; F \\<subseteq> carrier_vec n;\n   f \\<in> F \\<rightarrow> UNIV\\<rbrakk>\n  \\<Longrightarrow> module.lincomb (module_cpx_vec n) f F $ i =\n                    (\\<Sum>v\\<in>F. f v * v $ i)\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f (insert x F) $ i =\n    f x * x $ i + (\\<Sum>v\\<in>F. f v * v $ i)", "by auto"], ["proof (state)\nthis:\n  module.lincomb (module_cpx_vec n) f (insert x F) $ i =\n  f x * x $ i + (\\<Sum>v\\<in>F. f v * v $ i)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>i < n; F \\<subseteq> carrier_vec n;\n         f \\<in> F \\<rightarrow> UNIV\\<rbrakk>\n        \\<Longrightarrow> module.lincomb (module_cpx_vec n) f F $ i =\n                          (\\<Sum>v\\<in>F. f v * v $ i);\n        i < n; insert x F \\<subseteq> carrier_vec n;\n        f \\<in> insert x F \\<rightarrow> UNIV\\<rbrakk>\n       \\<Longrightarrow> module.lincomb (module_cpx_vec n) f (insert x F) $\n                         i =\n                         (\\<Sum>v\\<in>insert x F. f v * v $ i)", "with insert"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>i < n; F \\<subseteq> carrier_vec n;\n   f \\<in> F \\<rightarrow> UNIV\\<rbrakk>\n  \\<Longrightarrow> module.lincomb (module_cpx_vec n) f F $ i =\n                    (\\<Sum>v\\<in>F. f v * v $ i)\n  i < n\n  insert x F \\<subseteq> carrier_vec n\n  f \\<in> insert x F \\<rightarrow> UNIV\n  module.lincomb (module_cpx_vec n) f (insert x F) $ i =\n  f x * x $ i + (\\<Sum>v\\<in>F. f v * v $ i)", "show \"module.lincomb (module_cpx_vec n) f (insert x F) $ i = (\\<Sum>v\\<in>insert x F. f v * v $ i)\""], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>i < n; F \\<subseteq> carrier_vec n;\n   f \\<in> F \\<rightarrow> UNIV\\<rbrakk>\n  \\<Longrightarrow> module.lincomb (module_cpx_vec n) f F $ i =\n                    (\\<Sum>v\\<in>F. f v * v $ i)\n  i < n\n  insert x F \\<subseteq> carrier_vec n\n  f \\<in> insert x F \\<rightarrow> UNIV\n  module.lincomb (module_cpx_vec n) f (insert x F) $ i =\n  f x * x $ i + (\\<Sum>v\\<in>F. f v * v $ i)\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) f (insert x F) $ i =\n    (\\<Sum>v\\<in>insert x F. f v * v $ i)", "by auto"], ["proof (state)\nthis:\n  module.lincomb (module_cpx_vec n) f (insert x F) $ i =\n  (\\<Sum>v\\<in>insert x F. f v * v $ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unit_vectors_is_lin_indpt [simp]:\n  \"module.lin_indpt cpx_rng (module_cpx_vec n) (unit_vectors n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> module.lin_dep cpx_rng (module_cpx_vec n) (unit_vectors n)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "assume \"module.lin_dep cpx_rng (module_cpx_vec n) (unit_vectors n)\""], ["proof (state)\nthis:\n  module.lin_dep cpx_rng (module_cpx_vec n) (unit_vectors n)\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "hence \"\\<exists>A a v. (finite A \\<and> A \\<subseteq> (unit_vectors n) \\<and> (a \\<in> A \\<rightarrow> UNIV) \\<and> \n    (module.lincomb (module_cpx_vec n) a A = \\<zero>\\<^bsub>module_cpx_vec n\\<^esub>) \\<and> (v \\<in> A) \\<and> (a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>))\""], ["proof (prove)\nusing this:\n  module.lin_dep cpx_rng (module_cpx_vec n) (unit_vectors n)\n\ngoal (1 subgoal):\n 1. \\<exists>A a v.\n       finite A \\<and>\n       A \\<subseteq> unit_vectors n \\<and>\n       a \\<in> A \\<rightarrow> UNIV \\<and>\n       module.lincomb (module_cpx_vec n) a A =\n       \\<zero>\\<^bsub>module_cpx_vec n\\<^esub> \\<and>\n       v \\<in> A \\<and> a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>", "using module.lin_dep_def cpx_rng_def module_cpx_vec"], ["proof (prove)\nusing this:\n  module.lin_dep cpx_rng (module_cpx_vec n) (unit_vectors n)\n  Module.module ?R ?M \\<Longrightarrow>\n  module.lin_dep ?R ?M ?S =\n  (\\<exists>A a v.\n      finite A \\<and>\n      A \\<subseteq> ?S \\<and>\n      a \\<in> A \\<rightarrow> carrier ?R \\<and>\n      module.lincomb ?M a A = \\<zero>\\<^bsub>?M\\<^esub> \\<and>\n      v \\<in> A \\<and> a v \\<noteq> \\<zero>\\<^bsub>?R\\<^esub>)\n  cpx_rng \\<equiv>\n  \\<lparr>carrier = UNIV, monoid.mult = (*), one = 1, zero = 0,\n     add = (+)\\<rparr>\n  Module.module cpx_rng (module_cpx_vec ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>A a v.\n       finite A \\<and>\n       A \\<subseteq> unit_vectors n \\<and>\n       a \\<in> A \\<rightarrow> UNIV \\<and>\n       module.lincomb (module_cpx_vec n) a A =\n       \\<zero>\\<^bsub>module_cpx_vec n\\<^esub> \\<and>\n       v \\<in> A \\<and> a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>", "by (smt Pi_UNIV UNIV_I)"], ["proof (state)\nthis:\n  \\<exists>A a v.\n     finite A \\<and>\n     A \\<subseteq> unit_vectors n \\<and>\n     a \\<in> A \\<rightarrow> UNIV \\<and>\n     module.lincomb (module_cpx_vec n) a A =\n     \\<zero>\\<^bsub>module_cpx_vec n\\<^esub> \\<and>\n     v \\<in> A \\<and> a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<exists>A a v.\n     finite A \\<and>\n     A \\<subseteq> unit_vectors n \\<and>\n     a \\<in> A \\<rightarrow> UNIV \\<and>\n     module.lincomb (module_cpx_vec n) a A =\n     \\<zero>\\<^bsub>module_cpx_vec n\\<^esub> \\<and>\n     v \\<in> A \\<and> a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "obtain A and a and v where f1:\"finite A\" and f2:\"A \\<subseteq> (unit_vectors n)\" and \"a \\<in> A \\<rightarrow> UNIV\" \n    and f4:\"module.lincomb (module_cpx_vec n) a A = \\<zero>\\<^bsub>module_cpx_vec n\\<^esub>\" and f5:\"v \\<in> A\" and \n    f6:\"a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A a v.\n        \\<lbrakk>finite A; A \\<subseteq> unit_vectors n;\n         a \\<in> A \\<rightarrow> UNIV;\n         module.lincomb (module_cpx_vec n) a A =\n         \\<zero>\\<^bsub>module_cpx_vec n\\<^esub>;\n         v \\<in> A; a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation"], ["proof (prove)\nusing this:\n  \\<exists>A a v.\n     finite A \\<and>\n     A \\<subseteq> unit_vectors n \\<and>\n     a \\<in> A \\<rightarrow> UNIV \\<and>\n     module.lincomb (module_cpx_vec n) a A =\n     \\<zero>\\<^bsub>module_cpx_vec n\\<^esub> \\<and>\n     v \\<in> A \\<and> a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>A a v.\n        \\<lbrakk>finite A; A \\<subseteq> unit_vectors n;\n         a \\<in> A \\<rightarrow> UNIV;\n         module.lincomb (module_cpx_vec n) a A =\n         \\<zero>\\<^bsub>module_cpx_vec n\\<^esub>;\n         v \\<in> A; a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite A\n  A \\<subseteq> unit_vectors n\n  a \\<in> A \\<rightarrow> UNIV\n  module.lincomb (module_cpx_vec n) a A =\n  \\<zero>\\<^bsub>module_cpx_vec n\\<^esub>\n  v \\<in> A\n  a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  finite A\n  A \\<subseteq> unit_vectors n\n  a \\<in> A \\<rightarrow> UNIV\n  module.lincomb (module_cpx_vec n) a A =\n  \\<zero>\\<^bsub>module_cpx_vec n\\<^esub>\n  v \\<in> A\n  a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "obtain i where f7:\"v = unit_vec n i\" and f8:\"i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>v = unit_vec n i; i < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using unit_vectors_def calculation"], ["proof (prove)\nusing this:\n  unit_vectors ?n \\<equiv> {unit_vec ?n i |i. 0 \\<le> i \\<and> i < ?n}\n  \\<exists>A a v.\n     finite A \\<and>\n     A \\<subseteq> unit_vectors n \\<and>\n     a \\<in> A \\<rightarrow> UNIV \\<and>\n     module.lincomb (module_cpx_vec n) a A =\n     \\<zero>\\<^bsub>module_cpx_vec n\\<^esub> \\<and>\n     v \\<in> A \\<and> a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n  finite A\n  A \\<subseteq> unit_vectors n\n  a \\<in> A \\<rightarrow> UNIV\n  module.lincomb (module_cpx_vec n) a A =\n  \\<zero>\\<^bsub>module_cpx_vec n\\<^esub>\n  v \\<in> A\n  a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>v = unit_vec n i; i < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v = unit_vec n i\n  i < n\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>A a v.\n     finite A \\<and>\n     A \\<subseteq> unit_vectors n \\<and>\n     a \\<in> A \\<rightarrow> UNIV \\<and>\n     module.lincomb (module_cpx_vec n) a A =\n     \\<zero>\\<^bsub>module_cpx_vec n\\<^esub> \\<and>\n     v \\<in> A \\<and> a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n  finite A\n  A \\<subseteq> unit_vectors n\n  a \\<in> A \\<rightarrow> UNIV\n  module.lincomb (module_cpx_vec n) a A =\n  \\<zero>\\<^bsub>module_cpx_vec n\\<^esub>\n  v \\<in> A\n  a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n  v = unit_vec n i\n  i < n", "have f9:\"module.lincomb (module_cpx_vec n) a A $ i = (\\<Sum>u\\<in>A. a u * (u $ i))\""], ["proof (prove)\nusing this:\n  \\<exists>A a v.\n     finite A \\<and>\n     A \\<subseteq> unit_vectors n \\<and>\n     a \\<in> A \\<rightarrow> UNIV \\<and>\n     module.lincomb (module_cpx_vec n) a A =\n     \\<zero>\\<^bsub>module_cpx_vec n\\<^esub> \\<and>\n     v \\<in> A \\<and> a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n  finite A\n  A \\<subseteq> unit_vectors n\n  a \\<in> A \\<rightarrow> UNIV\n  module.lincomb (module_cpx_vec n) a A =\n  \\<zero>\\<^bsub>module_cpx_vec n\\<^esub>\n  v \\<in> A\n  a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n  v = unit_vec n i\n  i < n\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) a A $ i = (\\<Sum>u\\<in>A. a u * u $ i)", "using lincomb_vec_index"], ["proof (prove)\nusing this:\n  \\<exists>A a v.\n     finite A \\<and>\n     A \\<subseteq> unit_vectors n \\<and>\n     a \\<in> A \\<rightarrow> UNIV \\<and>\n     module.lincomb (module_cpx_vec n) a A =\n     \\<zero>\\<^bsub>module_cpx_vec n\\<^esub> \\<and>\n     v \\<in> A \\<and> a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n  finite A\n  A \\<subseteq> unit_vectors n\n  a \\<in> A \\<rightarrow> UNIV\n  module.lincomb (module_cpx_vec n) a A =\n  \\<zero>\\<^bsub>module_cpx_vec n\\<^esub>\n  v \\<in> A\n  a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n  v = unit_vec n i\n  i < n\n  \\<lbrakk>finite ?F; ?i < ?n; ?F \\<subseteq> carrier_vec ?n;\n   ?f \\<in> ?F \\<rightarrow> UNIV\\<rbrakk>\n  \\<Longrightarrow> module.lincomb (module_cpx_vec ?n) ?f ?F $ ?i =\n                    (\\<Sum>v\\<in>?F. ?f v * v $ ?i)\n\ngoal (1 subgoal):\n 1. module.lincomb (module_cpx_vec n) a A $ i = (\\<Sum>u\\<in>A. a u * u $ i)", "by (smt carrier_dim_vec index_unit_vec(3) mem_Collect_eq subset_iff sum.cong unit_vectors_def)"], ["proof (state)\nthis:\n  module.lincomb (module_cpx_vec n) a A $ i = (\\<Sum>u\\<in>A. a u * u $ i)\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  module.lincomb (module_cpx_vec n) a A $ i = (\\<Sum>u\\<in>A. a u * u $ i)\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "have \"\\<forall>u\\<in>A.\\<forall>j<n. u = unit_vec n j \\<longrightarrow> j \\<noteq> i \\<longrightarrow> a u * (u $ i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>A.\n       \\<forall>j<n.\n          u = unit_vec n j \\<longrightarrow>\n          j \\<noteq> i \\<longrightarrow> a u * u $ i = 0", "using unit_vectors_def index_unit_vec"], ["proof (prove)\nusing this:\n  unit_vectors ?n \\<equiv> {unit_vec ?n i |i. 0 \\<le> i \\<and> i < ?n}\n  \\<lbrakk>?i < ?n; ?j < ?n\\<rbrakk>\n  \\<Longrightarrow> unit_vec ?n ?i $ ?j =\n                    (if ?j = ?i then 1::?'a else (0::?'a))\n  ?i < ?n \\<Longrightarrow> unit_vec ?n ?i $ ?i = (1::?'b)\n  dim_vec (unit_vec ?n ?i) = ?n\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>A.\n       \\<forall>j<n.\n          u = unit_vec n j \\<longrightarrow>\n          j \\<noteq> i \\<longrightarrow> a u * u $ i = 0", "by (simp add: f8)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>A.\n     \\<forall>j<n.\n        u = unit_vec n j \\<longrightarrow>\n        j \\<noteq> i \\<longrightarrow> a u * u $ i = 0\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>A.\n     \\<forall>j<n.\n        u = unit_vec n j \\<longrightarrow>\n        j \\<noteq> i \\<longrightarrow> a u * u $ i = 0", "have \"(\\<Sum>u\\<in>A. a u * (u $ i)) = (\\<Sum>u\\<in>A. if u=v then a v * v $ i else 0)\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>A.\n     \\<forall>j<n.\n        u = unit_vec n j \\<longrightarrow>\n        j \\<noteq> i \\<longrightarrow> a u * u $ i = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A. a u * u $ i) =\n    (\\<Sum>u\\<in>A. if u = v then a v * v $ i else 0)", "using f2 unit_vectors_def f7"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>A.\n     \\<forall>j<n.\n        u = unit_vec n j \\<longrightarrow>\n        j \\<noteq> i \\<longrightarrow> a u * u $ i = 0\n  A \\<subseteq> unit_vectors n\n  unit_vectors ?n \\<equiv> {unit_vec ?n i |i. 0 \\<le> i \\<and> i < ?n}\n  v = unit_vec n i\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A. a u * u $ i) =\n    (\\<Sum>u\\<in>A. if u = v then a v * v $ i else 0)", "by (smt mem_Collect_eq subsetCE sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A. a u * u $ i) =\n  (\\<Sum>u\\<in>A. if u = v then a v * v $ i else 0)\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A. a u * u $ i) =\n  (\\<Sum>u\\<in>A. if u = v then a v * v $ i else 0)\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "have \"\\<dots> = a v * (v $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A. if u = v then a v * v $ i else 0) = a v * v $ i", "using abelian_monoid.finsum_singleton[of cpx_rng v A \"\\<lambda>u\\<in>A. a u * (u $ i)\"] cpx_abelian_monoid\n      f5 f1 cpx_rng_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>abelian_monoid cpx_rng; v \\<in> A; finite A;\n   (\\<lambda>u\\<in>A. a u * u $ i)\n   \\<in> A \\<rightarrow> carrier cpx_rng\\<rbrakk>\n  \\<Longrightarrow> (\\<Oplus>\\<^bsub>cpx_rng\\<^esub>j\\<in>A. if v = j\n                       then (\\<lambda>u\\<in>A. a u * u $ i) j\n                       else \\<zero>\\<^bsub>cpx_rng\\<^esub>) =\n                    (\\<lambda>u\\<in>A. a u * u $ i) v\n  abelian_monoid cpx_rng\n  v \\<in> A\n  finite A\n  cpx_rng \\<equiv>\n  \\<lparr>carrier = UNIV, monoid.mult = (*), one = 1, zero = 0,\n     add = (+)\\<rparr>\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A. if u = v then a v * v $ i else 0) = a v * v $ i", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A. if u = v then a v * v $ i else 0) = a v * v $ i\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A. if u = v then a v * v $ i else 0) = a v * v $ i\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "have \"\\<dots> = a v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a v * v $ i = a v", "using f7 index_unit_vec f8"], ["proof (prove)\nusing this:\n  v = unit_vec n i\n  \\<lbrakk>?i < ?n; ?j < ?n\\<rbrakk>\n  \\<Longrightarrow> unit_vec ?n ?i $ ?j =\n                    (if ?j = ?i then 1::?'a else (0::?'a))\n  ?i < ?n \\<Longrightarrow> unit_vec ?n ?i $ ?i = (1::?'b)\n  dim_vec (unit_vec ?n ?i) = ?n\n  i < n\n\ngoal (1 subgoal):\n 1. a v * v $ i = a v", "by simp"], ["proof (state)\nthis:\n  a v * v $ i = a v\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  a v * v $ i = a v\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "have \"\\<dots> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a v \\<noteq> 0", "using f6"], ["proof (prove)\nusing this:\n  a v \\<noteq> \\<zero>\\<^bsub>cpx_rng\\<^esub>\n\ngoal (1 subgoal):\n 1. a v \\<noteq> 0", "by (simp add: cpx_rng_def)"], ["proof (state)\nthis:\n  a v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. module.lin_dep cpx_rng (module_cpx_vec n)\n     (unit_vectors n) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  module.lincomb (module_cpx_vec n) a A $ i \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  module.lincomb (module_cpx_vec n) a A $ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using f4 module_cpx_vec_def module_vec_def index_zero_vec f8 f9"], ["proof (prove)\nusing this:\n  module.lincomb (module_cpx_vec n) a A $ i \\<noteq> 0\n  module.lincomb (module_cpx_vec n) a A =\n  \\<zero>\\<^bsub>module_cpx_vec n\\<^esub>\n  module_cpx_vec ?n \\<equiv> module_vec TYPE(complex) ?n\n  module_vec ?ty ?n \\<equiv>\n  \\<lparr>carrier = carrier_vec ?n, monoid.mult = undefined,\n     one = undefined, zero = 0\\<^sub>v ?n, add = (+),\n     module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\n  ?i < ?n \\<Longrightarrow> 0\\<^sub>v ?n $ ?i = (0::?'a)\n  dim_vec (0\\<^sub>v ?n) = ?n\n  i < n\n  module.lincomb (module_cpx_vec n) a A $ i = (\\<Sum>u\\<in>A. a u * u $ i)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: module_vec_simps(2))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unit_vectors_is_genset [simp]:\n  \"module.gen_set cpx_rng (module_cpx_vec n) (unit_vectors n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n     (unit_vectors n) =\n    carrier (module_cpx_vec n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n     (unit_vectors n)\n    \\<subseteq> carrier (module_cpx_vec n)\n 2. carrier (module_cpx_vec n)\n    \\<subseteq> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                 (unit_vectors n)", "show \"module.span cpx_rng (module_cpx_vec n) (unit_vectors n) \\<subseteq> carrier (module_cpx_vec n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n     (unit_vectors n)\n    \\<subseteq> carrier (module_cpx_vec n)", "using module.span_def dim_vec_lincomb carrier_vec_def cpx_rng_def"], ["proof (prove)\nusing this:\n  Module.module ?R ?M \\<Longrightarrow>\n  LinearCombinations.module.span ?R ?M ?S =\n  {module.lincomb ?M a A |a A.\n   finite A \\<and>\n   A \\<subseteq> ?S \\<and> a \\<in> A \\<rightarrow> carrier ?R}\n  \\<lbrakk>finite ?F; ?f \\<in> ?F \\<rightarrow> UNIV;\n   ?F \\<subseteq> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec ?n) ?f ?F) = ?n\n  carrier_vec ?n = {v. dim_vec v = ?n}\n  cpx_rng \\<equiv>\n  \\<lparr>carrier = UNIV, monoid.mult = (*), one = 1, zero = 0,\n     add = (+)\\<rparr>\n\ngoal (1 subgoal):\n 1. LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n     (unit_vectors n)\n    \\<subseteq> carrier (module_cpx_vec n)", "by (smt Collect_mono index_unit_vec(3) module.span_is_subset2 module_cpx_vec module_cpx_vec_def \n        module_vec_simps(3) unit_vectors_def)"], ["proof (state)\nthis:\n  LinearCombinations.module.span cpx_rng (module_cpx_vec n) (unit_vectors n)\n  \\<subseteq> carrier (module_cpx_vec n)\n\ngoal (1 subgoal):\n 1. carrier (module_cpx_vec n)\n    \\<subseteq> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                 (unit_vectors n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. carrier (module_cpx_vec n)\n    \\<subseteq> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                 (unit_vectors n)", "show \"carrier (module_cpx_vec n) \\<subseteq> module.span cpx_rng (module_cpx_vec n) (unit_vectors n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier (module_cpx_vec n)\n    \\<subseteq> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                 (unit_vectors n)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "assume a1:\"v \\<in> carrier (module_cpx_vec n)\""], ["proof (state)\nthis:\n  v \\<in> carrier (module_cpx_vec n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "define A a lc where \"A = {unit_vec n i ::complex vec| i::nat. i < n \\<and> v $ i \\<noteq> 0}\" and \n      \"a = (\\<lambda>u\\<in>A. u \\<bullet> v)\" and \"lc = module.lincomb (module_cpx_vec n) a A\""], ["proof (state)\nthis:\n  A = {unit_vec n i |i. i < n \\<and> v $ i \\<noteq> 0}\n  a = (\\<lambda>u\\<in>A. u \\<bullet> v)\n  lc = module.lincomb (module_cpx_vec n) a A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "then"], ["proof (chain)\npicking this:\n  A = {unit_vec n i |i. i < n \\<and> v $ i \\<noteq> 0}\n  a = (\\<lambda>u\\<in>A. u \\<bullet> v)\n  lc = module.lincomb (module_cpx_vec n) a A", "have f1:\"finite A\""], ["proof (prove)\nusing this:\n  A = {unit_vec n i |i. i < n \\<and> v $ i \\<noteq> 0}\n  a = (\\<lambda>u\\<in>A. u \\<bullet> v)\n  lc = module.lincomb (module_cpx_vec n) a A\n\ngoal (1 subgoal):\n 1. finite A", "by simp"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "have f2:\"A \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> carrier_vec n", "using carrier_vec_def A_def"], ["proof (prove)\nusing this:\n  carrier_vec ?n = {v. dim_vec v = ?n}\n  A = {unit_vec n i |i. i < n \\<and> v $ i \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. A \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  A \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "have f3:\"a \\<in> A \\<rightarrow> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> A \\<rightarrow> UNIV", "using a_def"], ["proof (prove)\nusing this:\n  a = (\\<lambda>u\\<in>A. u \\<bullet> v)\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<rightarrow> UNIV", "by simp"], ["proof (state)\nthis:\n  a \\<in> A \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "then"], ["proof (chain)\npicking this:\n  a \\<in> A \\<rightarrow> UNIV", "have f4:\"dim_vec v = dim_vec lc\""], ["proof (prove)\nusing this:\n  a \\<in> A \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. dim_vec v = dim_vec lc", "using f1 f2 f3 a1 module_cpx_vec_def dim_vec_lincomb lc_def"], ["proof (prove)\nusing this:\n  a \\<in> A \\<rightarrow> UNIV\n  finite A\n  A \\<subseteq> carrier_vec n\n  a \\<in> A \\<rightarrow> UNIV\n  v \\<in> carrier (module_cpx_vec n)\n  module_cpx_vec ?n \\<equiv> module_vec TYPE(complex) ?n\n  \\<lbrakk>finite ?F; ?f \\<in> ?F \\<rightarrow> UNIV;\n   ?F \\<subseteq> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec ?n) ?f ?F) = ?n\n  lc = module.lincomb (module_cpx_vec n) a A\n\ngoal (1 subgoal):\n 1. dim_vec v = dim_vec lc", "by (simp add: module_vec_simps(3))"], ["proof (state)\nthis:\n  dim_vec v = dim_vec lc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "then"], ["proof (chain)\npicking this:\n  dim_vec v = dim_vec lc", "have f5:\"i < n \\<Longrightarrow> lc $ i = (\\<Sum>u\\<in>A. u \\<bullet> v * u $ i)\" for i"], ["proof (prove)\nusing this:\n  dim_vec v = dim_vec lc\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> lc $ i = (\\<Sum>u\\<in>A. u \\<bullet> v * u $ i)", "using lincomb_vec_index lc_def a_def f1 f2 f3"], ["proof (prove)\nusing this:\n  dim_vec v = dim_vec lc\n  \\<lbrakk>finite ?F; ?i < ?n; ?F \\<subseteq> carrier_vec ?n;\n   ?f \\<in> ?F \\<rightarrow> UNIV\\<rbrakk>\n  \\<Longrightarrow> module.lincomb (module_cpx_vec ?n) ?f ?F $ ?i =\n                    (\\<Sum>v\\<in>?F. ?f v * v $ ?i)\n  lc = module.lincomb (module_cpx_vec n) a A\n  a = (\\<lambda>u\\<in>A. u \\<bullet> v)\n  finite A\n  A \\<subseteq> carrier_vec n\n  a \\<in> A \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> lc $ i = (\\<Sum>u\\<in>A. u \\<bullet> v * u $ i)", "by simp"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> lc $ ?i = (\\<Sum>u\\<in>A. u \\<bullet> v * u $ ?i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "then"], ["proof (chain)\npicking this:\n  ?i < n \\<Longrightarrow> lc $ ?i = (\\<Sum>u\\<in>A. u \\<bullet> v * u $ ?i)", "have \"i < n \\<Longrightarrow> j < n \\<Longrightarrow> j \\<noteq> i \\<Longrightarrow> unit_vec n j \\<bullet> v * unit_vec n j $ i = 0\" for i j"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> lc $ ?i = (\\<Sum>u\\<in>A. u \\<bullet> v * u $ ?i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n; j < n; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> unit_vec n j \\<bullet> v * unit_vec n j $ i = 0", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?i < n; ?j < n; ?j \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> unit_vec n ?j \\<bullet> v * unit_vec n ?j $ ?i = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < n; ?j < n; ?j \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> unit_vec n ?j \\<bullet> v * unit_vec n ?j $ ?i = 0", "have \"i < n \\<Longrightarrow> lc $ i = (\\<Sum>u\\<in>A. if u = unit_vec n i then v $ i else 0)\" for i"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < n; ?j < n; ?j \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> unit_vec n ?j \\<bullet> v * unit_vec n ?j $ ?i = 0\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow>\n    lc $ i = (\\<Sum>u\\<in>A. if u = unit_vec n i then v $ i else 0)", "using a1 A_def f5 scalar_prod_left_unit"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < n; ?j < n; ?j \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> unit_vec n ?j \\<bullet> v * unit_vec n ?j $ ?i = 0\n  v \\<in> carrier (module_cpx_vec n)\n  A = {unit_vec n i |i. i < n \\<and> v $ i \\<noteq> 0}\n  ?i < n \\<Longrightarrow> lc $ ?i = (\\<Sum>u\\<in>A. u \\<bullet> v * u $ ?i)\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?i < ?n\\<rbrakk>\n  \\<Longrightarrow> unit_vec ?n ?i \\<bullet> ?v = ?v $ ?i\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow>\n    lc $ i = (\\<Sum>u\\<in>A. if u = unit_vec n i then v $ i else 0)", "by (smt f4 carrier_vecI dim_vec_lincomb f1 f2 f3 index_unit_vec(2) lc_def \n          mem_Collect_eq mult.right_neutral sum.cong)"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow>\n  lc $ ?i = (\\<Sum>u\\<in>A. if u = unit_vec n ?i then v $ ?i else 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "then"], ["proof (chain)\npicking this:\n  ?i < n \\<Longrightarrow>\n  lc $ ?i = (\\<Sum>u\\<in>A. if u = unit_vec n ?i then v $ ?i else 0)", "have \"i < n \\<Longrightarrow> lc $ i = v $ i\" for i"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow>\n  lc $ ?i = (\\<Sum>u\\<in>A. if u = unit_vec n ?i then v $ ?i else 0)\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> lc $ i = v $ i", "using abelian_monoid.finsum_singleton[of cpx_rng i] A_def cpx_rng_def"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow>\n  lc $ ?i = (\\<Sum>u\\<in>A. if u = unit_vec n ?i then v $ ?i else 0)\n  \\<lbrakk>abelian_monoid cpx_rng; i \\<in> ?A; finite ?A;\n   ?f \\<in> ?A \\<rightarrow> carrier cpx_rng\\<rbrakk>\n  \\<Longrightarrow> (\\<Oplus>\\<^bsub>cpx_rng\\<^esub>j\\<in>?A. if i = j\n                        then ?f j else \\<zero>\\<^bsub>cpx_rng\\<^esub>) =\n                    ?f i\n  A = {unit_vec n i |i. i < n \\<and> v $ i \\<noteq> 0}\n  cpx_rng \\<equiv>\n  \\<lparr>carrier = UNIV, monoid.mult = (*), one = 1, zero = 0,\n     add = (+)\\<rparr>\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> lc $ i = v $ i", "by simp"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> lc $ ?i = v $ ?i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "then"], ["proof (chain)\npicking this:\n  ?i < n \\<Longrightarrow> lc $ ?i = v $ ?i", "have f6:\"v = lc\""], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> lc $ ?i = v $ ?i\n\ngoal (1 subgoal):\n 1. v = lc", "using eq_vecI f4 dim_vec_lincomb f1 f2 lc_def"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> lc $ ?i = v $ ?i\n  \\<lbrakk>\\<And>i. i < dim_vec ?w \\<Longrightarrow> ?v $ i = ?w $ i;\n   dim_vec ?v = dim_vec ?w\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  dim_vec v = dim_vec lc\n  \\<lbrakk>finite ?F; ?f \\<in> ?F \\<rightarrow> UNIV;\n   ?F \\<subseteq> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec ?n) ?f ?F) = ?n\n  finite A\n  A \\<subseteq> carrier_vec n\n  lc = module.lincomb (module_cpx_vec n) a A\n\ngoal (1 subgoal):\n 1. v = lc", "by auto"], ["proof (state)\nthis:\n  v = lc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "have \"A \\<subseteq> unit_vectors n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> unit_vectors n", "using A_def unit_vectors_def"], ["proof (prove)\nusing this:\n  A = {unit_vec n i |i. i < n \\<and> v $ i \\<noteq> 0}\n  unit_vectors ?n \\<equiv> {unit_vec ?n i |i. 0 \\<le> i \\<and> i < ?n}\n\ngoal (1 subgoal):\n 1. A \\<subseteq> unit_vectors n", "by auto"], ["proof (state)\nthis:\n  A \\<subseteq> unit_vectors n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (module_cpx_vec n) \\<Longrightarrow>\n       x \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n                (unit_vectors n)", "thus \"v \\<in> module.span cpx_rng (module_cpx_vec n) (unit_vectors n)\""], ["proof (prove)\nusing this:\n  A \\<subseteq> unit_vectors n\n\ngoal (1 subgoal):\n 1. v \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n             (unit_vectors n)", "using f6 module.span_def[of cpx_rng \"module_cpx_vec n\"] lc_def f1 f2 cpx_rng_def module_cpx_vec"], ["proof (prove)\nusing this:\n  A \\<subseteq> unit_vectors n\n  v = lc\n  Module.module cpx_rng (module_cpx_vec n) \\<Longrightarrow>\n  LinearCombinations.module.span cpx_rng (module_cpx_vec n) ?S =\n  {module.lincomb (module_cpx_vec n) a A |a A.\n   finite A \\<and>\n   A \\<subseteq> ?S \\<and> a \\<in> A \\<rightarrow> carrier cpx_rng}\n  lc = module.lincomb (module_cpx_vec n) a A\n  finite A\n  A \\<subseteq> carrier_vec n\n  cpx_rng \\<equiv>\n  \\<lparr>carrier = UNIV, monoid.mult = (*), one = 1, zero = 0,\n     add = (+)\\<rparr>\n  Module.module cpx_rng (module_cpx_vec ?n)\n\ngoal (1 subgoal):\n 1. v \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n             (unit_vectors n)", "by (smt Pi_I' UNIV_I mem_Collect_eq partial_object.select_convs(1))"], ["proof (state)\nthis:\n  v \\<in> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n           (unit_vectors n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  carrier (module_cpx_vec n)\n  \\<subseteq> LinearCombinations.module.span cpx_rng (module_cpx_vec n)\n               (unit_vectors n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unit_vectors_is_basis [simp]:\n  \"vectorspace.basis cpx_rng (module_cpx_vec n) (unit_vectors n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.basis cpx_rng (module_cpx_vec n) (unit_vectors n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace.basis cpx_rng (module_cpx_vec n) (unit_vectors n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace.basis cpx_rng (module_cpx_vec n) (unit_vectors n)", "have \"unit_vectors n \\<subseteq> carrier (module_cpx_vec n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_vectors n \\<subseteq> carrier (module_cpx_vec n)", "using unit_vectors_def module_cpx_vec_def module_vec_simps(3)"], ["proof (prove)\nusing this:\n  unit_vectors ?n \\<equiv> {unit_vec ?n i |i. 0 \\<le> i \\<and> i < ?n}\n  module_cpx_vec ?n \\<equiv> module_vec TYPE(complex) ?n\n  carrier (module_vec ?ty ?n) = carrier_vec ?n\n\ngoal (1 subgoal):\n 1. unit_vectors n \\<subseteq> carrier (module_cpx_vec n)", "by fastforce"], ["proof (state)\nthis:\n  unit_vectors n \\<subseteq> carrier (module_cpx_vec n)\n\ngoal (1 subgoal):\n 1. vectorspace.basis cpx_rng (module_cpx_vec n) (unit_vectors n)", "then"], ["proof (chain)\npicking this:\n  unit_vectors n \\<subseteq> carrier (module_cpx_vec n)", "show ?thesis"], ["proof (prove)\nusing this:\n  unit_vectors n \\<subseteq> carrier (module_cpx_vec n)\n\ngoal (1 subgoal):\n 1. vectorspace.basis cpx_rng (module_cpx_vec n) (unit_vectors n)", "using vectorspace.basis_def unit_vectors_is_lin_indpt unit_vectors_is_genset vecspace_cpx_vec"], ["proof (prove)\nusing this:\n  unit_vectors n \\<subseteq> carrier (module_cpx_vec n)\n  vectorspace ?K ?V \\<Longrightarrow>\n  vectorspace.basis ?K ?V ?A =\n  (\\<not> module.lin_dep ?K ?V ?A \\<and>\n   LinearCombinations.module.span ?K ?V ?A = carrier ?V \\<and>\n   ?A \\<subseteq> carrier ?V)\n  \\<not> module.lin_dep cpx_rng (module_cpx_vec ?n) (unit_vectors ?n)\n  LinearCombinations.module.span cpx_rng (module_cpx_vec ?n)\n   (unit_vectors ?n) =\n  carrier (module_cpx_vec ?n)\n  vectorspace cpx_rng (module_cpx_vec ?n)\n\ngoal (1 subgoal):\n 1. vectorspace.basis cpx_rng (module_cpx_vec n) (unit_vectors n)", "by(smt carrier_dim_vec index_unit_vec(3) mem_Collect_eq module_cpx_vec_def module_vec_simps(3) \n        subsetI unit_vectors_def)"], ["proof (state)\nthis:\n  vectorspace.basis cpx_rng (module_cpx_vec n) (unit_vectors n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma state_qbit_is_lincomb [simp]:\n  \"state_qbit n = \n  {module.lincomb (module_cpx_vec (2^n)) a A|a A. \n    finite A \\<and> A\\<subseteq>(unit_vectors (2^n)) \\<and> a\\<in> A \\<rightarrow> UNIV \\<and> \\<parallel>module.lincomb (module_cpx_vec (2^n)) a A\\<parallel> = 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_qbit n =\n    {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n     finite A \\<and>\n     A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n     a \\<in> A \\<rightarrow> UNIV \\<and>\n     \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a A\\<parallel> = 1}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. state_qbit n\n    \\<subseteq> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n                 finite A \\<and>\n                 A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n                 a \\<in> A \\<rightarrow> UNIV \\<and>\n                 \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                             A\\<parallel> =\n                 1}\n 2. {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n     finite A \\<and>\n     A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n     a \\<in> A \\<rightarrow> UNIV \\<and>\n     \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a A\\<parallel> = 1}\n    \\<subseteq> state_qbit n", "show \"state_qbit n\n    \\<subseteq> {module.lincomb (module_cpx_vec (2^n)) a A |a A.\n        finite A \\<and> A \\<subseteq> unit_vectors (2^n) \\<and> a \\<in> A \\<rightarrow> UNIV \\<and> \\<parallel>module.lincomb (module_cpx_vec (2^n)) a A\\<parallel> = 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_qbit n\n    \\<subseteq> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n                 finite A \\<and>\n                 A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n                 a \\<in> A \\<rightarrow> UNIV \\<and>\n                 \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                             A\\<parallel> =\n                 1}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> state_qbit n \\<Longrightarrow>\n       x \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n                finite A \\<and>\n                A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n                a \\<in> A \\<rightarrow> UNIV \\<and>\n                \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                            A\\<parallel> =\n                1}", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> state_qbit n \\<Longrightarrow>\n       x \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n                finite A \\<and>\n                A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n                a \\<in> A \\<rightarrow> UNIV \\<and>\n                \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                            A\\<parallel> =\n                1}", "assume a1:\"v \\<in> state_qbit n\""], ["proof (state)\nthis:\n  v \\<in> state_qbit n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> state_qbit n \\<Longrightarrow>\n       x \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n                finite A \\<and>\n                A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n                a \\<in> A \\<rightarrow> UNIV \\<and>\n                \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                            A\\<parallel> =\n                1}", "then"], ["proof (chain)\npicking this:\n  v \\<in> state_qbit n", "show \"v \\<in> {module.lincomb (module_cpx_vec (2^n)) a A |a A.\n               finite A \\<and> A \\<subseteq> unit_vectors (2^n) \\<and> a \\<in> A \\<rightarrow> UNIV \\<and> \\<parallel>module.lincomb (module_cpx_vec (2^n)) a A\\<parallel> = 1}\""], ["proof (prove)\nusing this:\n  v \\<in> state_qbit n\n\ngoal (1 subgoal):\n 1. v \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n             finite A \\<and>\n             A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n             a \\<in> A \\<rightarrow> UNIV \\<and>\n             \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                         A\\<parallel> =\n             1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> state_qbit n \\<Longrightarrow>\n    v \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n             finite A \\<and>\n             A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n             a \\<in> A \\<rightarrow> UNIV \\<and>\n             \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                         A\\<parallel> =\n             1}", "obtain a and A where \"finite A\" and \"a\\<in> A \\<rightarrow> UNIV\" and \"A \\<subseteq> unit_vectors (2^n)\" and \n        \"v = module.lincomb (module_cpx_vec (2^n)) a A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A a.\n        \\<lbrakk>finite A; a \\<in> A \\<rightarrow> UNIV;\n         A \\<subseteq> unit_vectors (2 ^ n);\n         v = module.lincomb (module_cpx_vec (2 ^ n)) a A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using a1 state_qbit_def unit_vectors_is_basis vectorspace.basis_def module.span_def \n        vecspace_cpx_vec module_cpx_vec module_cpx_vec_def module_vec_def carrier_vec_def"], ["proof (prove)\nusing this:\n  v \\<in> state_qbit n\n  state_qbit ?n \\<equiv>\n  {v |v. dim_vec v = 2 ^ ?n \\<and> \\<parallel>v\\<parallel> = 1}\n  vectorspace.basis cpx_rng (module_cpx_vec ?n) (unit_vectors ?n)\n  vectorspace ?K ?V \\<Longrightarrow>\n  vectorspace.basis ?K ?V ?A =\n  (\\<not> module.lin_dep ?K ?V ?A \\<and>\n   LinearCombinations.module.span ?K ?V ?A = carrier ?V \\<and>\n   ?A \\<subseteq> carrier ?V)\n  Module.module ?R ?M \\<Longrightarrow>\n  LinearCombinations.module.span ?R ?M ?S =\n  {module.lincomb ?M a A |a A.\n   finite A \\<and>\n   A \\<subseteq> ?S \\<and> a \\<in> A \\<rightarrow> carrier ?R}\n  vectorspace cpx_rng (module_cpx_vec ?n)\n  Module.module cpx_rng (module_cpx_vec ?n)\n  module_cpx_vec ?n \\<equiv> module_vec TYPE(complex) ?n\n  module_vec ?ty ?n \\<equiv>\n  \\<lparr>carrier = carrier_vec ?n, monoid.mult = undefined,\n     one = undefined, zero = 0\\<^sub>v ?n, add = (+),\n     module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\n  carrier_vec ?n = {v. dim_vec v = ?n}\n\ngoal (1 subgoal):\n 1. (\\<And>A a.\n        \\<lbrakk>finite A; a \\<in> A \\<rightarrow> UNIV;\n         A \\<subseteq> unit_vectors (2 ^ n);\n         v = module.lincomb (module_cpx_vec (2 ^ n)) a A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(smt Pi_UNIV UNIV_I mem_Collect_eq module_vec_simps(3))"], ["proof (state)\nthis:\n  finite A\n  a \\<in> A \\<rightarrow> UNIV\n  A \\<subseteq> unit_vectors (2 ^ n)\n  v = module.lincomb (module_cpx_vec (2 ^ n)) a A\n\ngoal (1 subgoal):\n 1. v \\<in> state_qbit n \\<Longrightarrow>\n    v \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n             finite A \\<and>\n             A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n             a \\<in> A \\<rightarrow> UNIV \\<and>\n             \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                         A\\<parallel> =\n             1}", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite A\n  a \\<in> A \\<rightarrow> UNIV\n  A \\<subseteq> unit_vectors (2 ^ n)\n  v = module.lincomb (module_cpx_vec (2 ^ n)) a A\n\ngoal (1 subgoal):\n 1. v \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n             finite A \\<and>\n             A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n             a \\<in> A \\<rightarrow> UNIV \\<and>\n             \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                         A\\<parallel> =\n             1}", "using a1 state_qbit_def"], ["proof (prove)\nusing this:\n  finite A\n  a \\<in> A \\<rightarrow> UNIV\n  A \\<subseteq> unit_vectors (2 ^ n)\n  v = module.lincomb (module_cpx_vec (2 ^ n)) a A\n  v \\<in> state_qbit n\n  state_qbit ?n \\<equiv>\n  {v |v. dim_vec v = 2 ^ ?n \\<and> \\<parallel>v\\<parallel> = 1}\n\ngoal (1 subgoal):\n 1. v \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n             finite A \\<and>\n             A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n             a \\<in> A \\<rightarrow> UNIV \\<and>\n             \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                         A\\<parallel> =\n             1}", "by auto"], ["proof (state)\nthis:\n  v \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n           finite A \\<and>\n           A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n           a \\<in> A \\<rightarrow> UNIV \\<and>\n           \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                       A\\<parallel> =\n           1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n           finite A \\<and>\n           A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n           a \\<in> A \\<rightarrow> UNIV \\<and>\n           \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                       A\\<parallel> =\n           1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_qbit n\n  \\<subseteq> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n               finite A \\<and>\n               A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n               a \\<in> A \\<rightarrow> UNIV \\<and>\n               \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                           A\\<parallel> =\n               1}\n\ngoal (1 subgoal):\n 1. {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n     finite A \\<and>\n     A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n     a \\<in> A \\<rightarrow> UNIV \\<and>\n     \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a A\\<parallel> = 1}\n    \\<subseteq> state_qbit n", "show \"{module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n     finite A \\<and> A \\<subseteq> unit_vectors (2 ^ n) \\<and> a \\<in> A \\<rightarrow> UNIV \\<and> \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a A\\<parallel> = 1}\n    \\<subseteq> state_qbit n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n     finite A \\<and>\n     A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n     a \\<in> A \\<rightarrow> UNIV \\<and>\n     \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a A\\<parallel> = 1}\n    \\<subseteq> state_qbit n", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n                finite A \\<and>\n                A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n                a \\<in> A \\<rightarrow> UNIV \\<and>\n                \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                            A\\<parallel> =\n                1} \\<Longrightarrow>\n       x \\<in> state_qbit n", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n                finite A \\<and>\n                A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n                a \\<in> A \\<rightarrow> UNIV \\<and>\n                \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                            A\\<parallel> =\n                1} \\<Longrightarrow>\n       x \\<in> state_qbit n", "assume \"v \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n              finite A \\<and> A \\<subseteq> unit_vectors (2 ^ n) \\<and> a \\<in> A \\<rightarrow> UNIV \\<and> \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a A\\<parallel> = 1}\""], ["proof (state)\nthis:\n  v \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n           finite A \\<and>\n           A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n           a \\<in> A \\<rightarrow> UNIV \\<and>\n           \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                       A\\<parallel> =\n           1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n                finite A \\<and>\n                A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n                a \\<in> A \\<rightarrow> UNIV \\<and>\n                \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                            A\\<parallel> =\n                1} \\<Longrightarrow>\n       x \\<in> state_qbit n", "then"], ["proof (chain)\npicking this:\n  v \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n           finite A \\<and>\n           A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n           a \\<in> A \\<rightarrow> UNIV \\<and>\n           \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                       A\\<parallel> =\n           1}", "show \"v \\<in> state_qbit n\""], ["proof (prove)\nusing this:\n  v \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n           finite A \\<and>\n           A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n           a \\<in> A \\<rightarrow> UNIV \\<and>\n           \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                       A\\<parallel> =\n           1}\n\ngoal (1 subgoal):\n 1. v \\<in> state_qbit n", "using state_qbit_def dim_vec_lincomb unit_vectors_carrier_vec"], ["proof (prove)\nusing this:\n  v \\<in> {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n           finite A \\<and>\n           A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n           a \\<in> A \\<rightarrow> UNIV \\<and>\n           \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a\n                       A\\<parallel> =\n           1}\n  state_qbit ?n \\<equiv>\n  {v |v. dim_vec v = 2 ^ ?n \\<and> \\<parallel>v\\<parallel> = 1}\n  \\<lbrakk>finite ?F; ?f \\<in> ?F \\<rightarrow> UNIV;\n   ?F \\<subseteq> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> dim_vec (module.lincomb (module_cpx_vec ?n) ?f ?F) = ?n\n  unit_vectors ?n \\<subseteq> carrier_vec ?n\n\ngoal (1 subgoal):\n 1. v \\<in> state_qbit n", "by(smt mem_Collect_eq order_trans)"], ["proof (state)\nthis:\n  v \\<in> state_qbit n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {module.lincomb (module_cpx_vec (2 ^ n)) a A |a A.\n   finite A \\<and>\n   A \\<subseteq> unit_vectors (2 ^ n) \\<and>\n   a \\<in> A \\<rightarrow> UNIV \\<and>\n   \\<parallel>module.lincomb (module_cpx_vec (2 ^ n)) a A\\<parallel> = 1}\n  \\<subseteq> state_qbit n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}