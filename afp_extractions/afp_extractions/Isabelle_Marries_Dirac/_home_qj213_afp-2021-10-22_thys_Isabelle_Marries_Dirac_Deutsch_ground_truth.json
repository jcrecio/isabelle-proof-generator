{"file_name": "/home/qj213/afp-2021-10-22/thys/Isabelle_Marries_Dirac/Deutsch.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Isabelle_Marries_Dirac", "problem_names": ["lemma is_swap_values:\n  assumes \"is_swap\"\n  shows \"f 0 = 1\" and \"f 1 = 0\"", "lemma is_swap_sum_mod_2:\n  assumes \"is_swap\"\n  shows \"(f 0 + f 1) mod 2 = 1\"", "lemma f_values: \"(f 0 = 0 \\<or> f 0 = 1) \\<and> (f 1 = 0 \\<or> f 1 = 1)\"", "lemma f_cases:\n  shows \"is_const \\<or> is_balanced\"", "lemma const_0_sum_mod_2:\n  assumes \"const 0\"\n  shows \"(f 0 + f 1) mod 2 = 0\"", "lemma const_1_sum_mod_2:\n  assumes \"const 1\"\n  shows \"(f 0 + f 1) mod 2 = 0\"", "lemma is_const_sum_mod_2:\n  assumes \"is_const\"\n  shows \"(f 0 + f 1) mod 2 = 0\"", "lemma id_sum_mod_2:\n  assumes \"f = id\"\n  shows \"(f 0 + f 1) mod 2 = 1\"", "lemma is_balanced_sum_mod_2:\n  assumes \"is_balanced\"\n  shows \"(f 0 + f 1) mod 2 = 1\"", "lemma f_ge_0: \"\\<forall> x. (f x \\<ge> 0)\"", "lemma (in deutsch) deutsch_transform_dim [simp]: \n  shows \"dim_row U\\<^sub>f = 4\" and \"dim_col U\\<^sub>f = 4\"", "lemma (in deutsch) deutsch_transform_coeff_is_zero [simp]: \n  shows \"U\\<^sub>f $$ (0,2) = 0\" and \"U\\<^sub>f $$ (0,3) = 0\"\n    and \"U\\<^sub>f $$ (1,2) = 0\" and \"U\\<^sub>f $$(1,3) = 0\"\n    and \"U\\<^sub>f $$ (2,0) = 0\" and \"U\\<^sub>f $$(2,1) = 0\"\n    and \"U\\<^sub>f $$ (3,0) = 0\" and \"U\\<^sub>f $$ (3,1) = 0\"", "lemma (in deutsch) deutsch_transform_coeff [simp]: \n  shows \"U\\<^sub>f $$ (0,1) = f(0)\" and \"U\\<^sub>f $$ (1,0) = f(0)\"\n    and \"U\\<^sub>f $$(2,3) = f(1)\" and \"U\\<^sub>f $$ (3,2) = f(1)\"\n    and \"U\\<^sub>f $$ (0,0) = 1 - f(0)\" and \"U\\<^sub>f $$(1,1) = 1 - f(0)\"\n    and \"U\\<^sub>f $$ (2,2) = 1 - f(1)\" and \"U\\<^sub>f $$ (3,3) = 1 - f(1)\"", "lemma (in deutsch) deutsch_transform_alt_rep_coeff_is_zero [simp]:\n  shows \"V\\<^sub>f $$ (0,2) = 0\" and \"V\\<^sub>f $$ (0,3) = 0\"\n    and \"V\\<^sub>f $$ (1,2) = 0\" and \"V\\<^sub>f $$(1,3) = 0\"\n    and \"V\\<^sub>f $$ (2,0) = 0\" and \"V\\<^sub>f $$(2,1) = 0\"\n    and \"V\\<^sub>f $$ (3,0) = 0\" and \"V\\<^sub>f $$ (3,1) = 0\"", "lemma (in deutsch) deutsch_transform_alt_rep_coeff [simp]:\n  shows \"V\\<^sub>f $$ (0,1) = f(0)\" and \"V\\<^sub>f $$ (1,0) = f(0)\"\n    and \"V\\<^sub>f $$(2,3) = f(1)\" and \"V\\<^sub>f $$ (3,2) = f(1)\"\n    and \"V\\<^sub>f $$ (0,0) = 1 - f(0)\" and \"V\\<^sub>f $$(1,1) = 1 - f(0)\"\n    and \"V\\<^sub>f $$ (2,2) = 1 - f(1)\" and \"V\\<^sub>f $$ (3,3) = 1 - f(1)\"", "lemma (in deutsch) deutsch_transform_alt_rep:\n  shows \"U\\<^sub>f = V\\<^sub>f\"", "lemma (in deutsch) transpose_of_deutsch_transform:\n  shows \"(U\\<^sub>f)\\<^sup>t = U\\<^sub>f\"", "lemma (in deutsch) adjoint_of_deutsch_transform: \n  shows \"(U\\<^sub>f)\\<^sup>\\<dagger> = U\\<^sub>f\"", "lemma (in deutsch) deutsch_transform_is_gate:\n  shows \"gate 2 U\\<^sub>f\"", "lemma ket_zero_is_state: \n  shows \"state 1 |zero\\<rangle>\"", "lemma ket_one_is_state:\n  shows \"state 1 |one\\<rangle>\"", "lemma ket_zero_to_mat_of_cols_list [simp]: \"|zero\\<rangle> = mat_of_cols_list 2 [[1, 0]]\"", "lemma ket_one_to_mat_of_cols_list [simp]: \"|one\\<rangle> = mat_of_cols_list 2 [[0, 1]]\"", "lemma H_on_ket_zero: \n  shows \"(H * |zero\\<rangle>) = \\<psi>\\<^sub>0\\<^sub>0\"", "lemma H_on_ket_zero_is_state: \n  shows \"state 1 (H * |zero\\<rangle>)\"", "lemma H_on_ket_one: \n  shows \"(H * |one\\<rangle>) = \\<psi>\\<^sub>0\\<^sub>1\"", "lemma H_on_ket_one_is_state: \n  shows \"state 1 (H * |one\\<rangle>)\"", "lemma \\<psi>\\<^sub>0_to_\\<psi>\\<^sub>1: \n  shows \"(\\<psi>\\<^sub>0\\<^sub>0 \\<Otimes> \\<psi>\\<^sub>0\\<^sub>1) = \\<psi>\\<^sub>1\"", "lemma \\<psi>\\<^sub>1_is_state: \n  shows \"state 2 \\<psi>\\<^sub>1\"", "lemma (in deutsch) \\<psi>\\<^sub>1_to_\\<psi>\\<^sub>2: \n  shows \"U\\<^sub>f * \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2\"", "lemma (in deutsch) \\<psi>\\<^sub>2_is_state:\n  shows \"state 2 \\<psi>\\<^sub>2\"", "lemma H_tensor_Id_1: \n  defines d:\"v \\<equiv>  mat_of_cols_list 4 [[1/sqrt(2), 0, 1/sqrt(2), 0],\n                                  [0, 1/sqrt(2), 0, 1/sqrt(2)],\n                                  [1/sqrt(2), 0, -1/sqrt(2), 0],\n                                  [0, 1/sqrt(2), 0, -1/sqrt(2)]]\"\n  shows \"(H \\<Otimes> Id 1) = v\"", "lemma H_tensor_Id_1_is_gate: \n  shows \"gate 2 (H \\<Otimes> Id 1)\"", "lemma (in deutsch) \\<psi>\\<^sub>2_to_\\<psi>\\<^sub>3: \n shows \"(H \\<Otimes> Id 1) * \\<psi>\\<^sub>2 = \\<psi>\\<^sub>3\"", "lemma (in deutsch) \\<psi>\\<^sub>3_is_state: \n  shows \"state 2 \\<psi>\\<^sub>3\"", "lemma (in deutsch) deutsch_algo_result [simp]: \n  shows \"deutsch_algo = \\<psi>\\<^sub>3\"", "lemma (in deutsch) deutsch_algo_result_is_state: \n  shows \"state 2 deutsch_algo\"", "lemma (in deutsch) prob0_deutsch_algo_const:\n  assumes \"is_const\" \n  shows \"prob0 2 deutsch_algo 0 = 1\"", "lemma (in deutsch) prob1_deutsch_algo_const: \n  assumes \"is_const\" \n  shows \"prob1 2 deutsch_algo 0 = 0\"", "lemma (in deutsch) prob0_deutsch_algo_balanced:  \n  assumes \"is_balanced\" \n  shows \"prob0 2 deutsch_algo 0 = 0\"", "lemma (in deutsch) prob1_deutsch_algo_balanced:\n  assumes \"is_balanced\" \n  shows \"prob1 2 deutsch_algo 0 = 1\"", "lemma (in deutsch) sum_mod_2_cases:\n  shows \"(f 0 + f 1) mod 2 = 0 \\<longrightarrow> is_const\" \n  and \"(f 0 + f 1) mod 2 = 1 \\<longrightarrow> is_balanced\"", "lemma (in deutsch) deutsch_algo_eval_is_sum_mod_2:\n  shows \"deutsch_algo_eval = (f 0 + f 1) mod 2\"", "theorem (in deutsch) deutsch_algo_is_correct:\n  shows \"deutsch_algo_eval = 0 \\<longrightarrow> is_const\" and \"deutsch_algo_eval = 1 \\<longrightarrow> is_balanced\""], "translations": [["", "lemma is_swap_values:\n  assumes \"is_swap\"\n  shows \"f 0 = 1\" and \"f 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 0 = 1 &&& f 1 = 0", "using assms is_swap_def"], ["proof (prove)\nusing this:\n  is_swap\n  is_swap = (\\<forall>x\\<in>{0, 1}. f x = 1 - x)\n\ngoal (1 subgoal):\n 1. f 0 = 1 &&& f 1 = 0", "by auto"], ["", "lemma is_swap_sum_mod_2:\n  assumes \"is_swap\"\n  shows \"(f 0 + f 1) mod 2 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 1", "using assms is_swap_def"], ["proof (prove)\nusing this:\n  is_swap\n  is_swap = (\\<forall>x\\<in>{0, 1}. f x = 1 - x)\n\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 1", "by simp"], ["", "definition const:: \"nat \\<Rightarrow> bool\" where \n\"const n = (\\<forall>x \\<in> {0,1}.(f x = n))\""], ["", "definition is_const:: \"bool\" where \n\"is_const \\<equiv> const 0 \\<or> const 1\""], ["", "definition is_balanced:: \"bool\" where\n\"is_balanced \\<equiv> (\\<forall>x \\<in> {0,1}.(f x = x)) \\<or> is_swap\""], ["", "lemma f_values: \"(f 0 = 0 \\<or> f 0 = 1) \\<and> (f 1 = 0 \\<or> f 1 = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f 0 = 0 \\<or> f 0 = 1) \\<and> (f 1 = 0 \\<or> f 1 = 1)", "using dom"], ["proof (prove)\nusing this:\n  f \\<in> {0, 1} \\<rightarrow>\\<^sub>E {0, 1}\n\ngoal (1 subgoal):\n 1. (f 0 = 0 \\<or> f 0 = 1) \\<and> (f 1 = 0 \\<or> f 1 = 1)", "by auto"], ["", "lemma f_cases:\n  shows \"is_const \\<or> is_balanced\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_const \\<or> is_balanced", "using dom is_balanced_def const_def is_const_def is_swap_def f_values"], ["proof (prove)\nusing this:\n  f \\<in> {0, 1} \\<rightarrow>\\<^sub>E {0, 1}\n  is_balanced \\<equiv> (\\<forall>x\\<in>{0, 1}. f x = x) \\<or> is_swap\n  const ?n = (\\<forall>x\\<in>{0, 1}. f x = ?n)\n  is_const \\<equiv> const 0 \\<or> const 1\n  is_swap = (\\<forall>x\\<in>{0, 1}. f x = 1 - x)\n  (f 0 = 0 \\<or> f 0 = 1) \\<and> (f 1 = 0 \\<or> f 1 = 1)\n\ngoal (1 subgoal):\n 1. is_const \\<or> is_balanced", "by auto"], ["", "lemma const_0_sum_mod_2:\n  assumes \"const 0\"\n  shows \"(f 0 + f 1) mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 0", "using assms const_def"], ["proof (prove)\nusing this:\n  const 0\n  const ?n = (\\<forall>x\\<in>{0, 1}. f x = ?n)\n\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 0", "by simp"], ["", "lemma const_1_sum_mod_2:\n  assumes \"const 1\"\n  shows \"(f 0 + f 1) mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 0", "using assms const_def"], ["proof (prove)\nusing this:\n  const 1\n  const ?n = (\\<forall>x\\<in>{0, 1}. f x = ?n)\n\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 0", "by simp"], ["", "lemma is_const_sum_mod_2:\n  assumes \"is_const\"\n  shows \"(f 0 + f 1) mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 0", "using assms is_const_def const_0_sum_mod_2 const_1_sum_mod_2"], ["proof (prove)\nusing this:\n  is_const\n  is_const \\<equiv> const 0 \\<or> const 1\n  const 0 \\<Longrightarrow> (f 0 + f 1) mod 2 = 0\n  const 1 \\<Longrightarrow> (f 0 + f 1) mod 2 = 0\n\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 0", "by auto"], ["", "lemma id_sum_mod_2:\n  assumes \"f = id\"\n  shows \"(f 0 + f 1) mod 2 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 1", "using assms"], ["proof (prove)\nusing this:\n  f = id\n\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 1", "by simp"], ["", "lemma is_balanced_sum_mod_2:\n  assumes \"is_balanced\"\n  shows \"(f 0 + f 1) mod 2 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 1", "using assms is_balanced_def id_sum_mod_2 is_swap_sum_mod_2"], ["proof (prove)\nusing this:\n  is_balanced\n  is_balanced \\<equiv> (\\<forall>x\\<in>{0, 1}. f x = x) \\<or> is_swap\n  f = id \\<Longrightarrow> (f 0 + f 1) mod 2 = 1\n  is_swap \\<Longrightarrow> (f 0 + f 1) mod 2 = 1\n\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 1", "by auto"], ["", "lemma f_ge_0: \"\\<forall> x. (f x \\<ge> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. 0 \\<le> f x", "by simp"], ["", "end"], ["", "(* context deutsch *)"], ["", "text \\<open>The Deutsch's Transform @{text U\\<^sub>f}.\\<close>"], ["", "definition (in deutsch) deutsch_transform:: \"complex Matrix.mat\" (\"U\\<^sub>f\") where \n\"U\\<^sub>f \\<equiv> mat_of_cols_list 4 [[1 - f(0), f(0), 0, 0],\n                          [f(0), 1 - f(0), 0, 0],\n                          [0, 0, 1 - f(1), f(1)],\n                          [0, 0, f(1), 1 - f(1)]]\""], ["", "lemma (in deutsch) deutsch_transform_dim [simp]: \n  shows \"dim_row U\\<^sub>f = 4\" and \"dim_col U\\<^sub>f = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row U\\<^sub>f = 4 &&& dim_col U\\<^sub>f = 4", "by (auto simp add: deutsch_transform_def mat_of_cols_list_def)"], ["", "lemma (in deutsch) deutsch_transform_coeff_is_zero [simp]: \n  shows \"U\\<^sub>f $$ (0,2) = 0\" and \"U\\<^sub>f $$ (0,3) = 0\"\n    and \"U\\<^sub>f $$ (1,2) = 0\" and \"U\\<^sub>f $$(1,3) = 0\"\n    and \"U\\<^sub>f $$ (2,0) = 0\" and \"U\\<^sub>f $$(2,1) = 0\"\n    and \"U\\<^sub>f $$ (3,0) = 0\" and \"U\\<^sub>f $$ (3,1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((U\\<^sub>f $$ (0, 2) = 0 &&& U\\<^sub>f $$ (0, 3) = 0) &&&\n     U\\<^sub>f $$ (1, 2) = 0 &&& U\\<^sub>f $$ (1, 3) = 0) &&&\n    (U\\<^sub>f $$ (2, 0) = 0 &&& U\\<^sub>f $$ (2, 1) = 0) &&&\n    U\\<^sub>f $$ (3, 0) = 0 &&& U\\<^sub>f $$ (3, 1) = 0", "using deutsch_transform_def"], ["proof (prove)\nusing this:\n  U\\<^sub>f \\<equiv>\n  Tensor.mat_of_cols_list 4\n   (map (map of_nat)\n     [[1 - f 0, f 0, 0, 0], [f 0, 1 - f 0, 0, 0], [0, 0, 1 - f 1, f 1],\n      [0, 0, f 1, 1 - f 1]])\n\ngoal (1 subgoal):\n 1. ((U\\<^sub>f $$ (0, 2) = 0 &&& U\\<^sub>f $$ (0, 3) = 0) &&&\n     U\\<^sub>f $$ (1, 2) = 0 &&& U\\<^sub>f $$ (1, 3) = 0) &&&\n    (U\\<^sub>f $$ (2, 0) = 0 &&& U\\<^sub>f $$ (2, 1) = 0) &&&\n    U\\<^sub>f $$ (3, 0) = 0 &&& U\\<^sub>f $$ (3, 1) = 0", "by auto"], ["", "lemma (in deutsch) deutsch_transform_coeff [simp]: \n  shows \"U\\<^sub>f $$ (0,1) = f(0)\" and \"U\\<^sub>f $$ (1,0) = f(0)\"\n    and \"U\\<^sub>f $$(2,3) = f(1)\" and \"U\\<^sub>f $$ (3,2) = f(1)\"\n    and \"U\\<^sub>f $$ (0,0) = 1 - f(0)\" and \"U\\<^sub>f $$(1,1) = 1 - f(0)\"\n    and \"U\\<^sub>f $$ (2,2) = 1 - f(1)\" and \"U\\<^sub>f $$ (3,3) = 1 - f(1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((U\\<^sub>f $$ (0, 1) = of_nat (f 0) &&&\n      U\\<^sub>f $$ (1, 0) = of_nat (f 0)) &&&\n     U\\<^sub>f $$ (2, 3) = of_nat (f 1) &&&\n     U\\<^sub>f $$ (3, 2) = of_nat (f 1)) &&&\n    (U\\<^sub>f $$ (0, 0) = of_nat (1 - f 0) &&&\n     U\\<^sub>f $$ (1, 1) = of_nat (1 - f 0)) &&&\n    U\\<^sub>f $$ (2, 2) = of_nat (1 - f 1) &&&\n    U\\<^sub>f $$ (3, 3) = of_nat (1 - f 1)", "using deutsch_transform_def"], ["proof (prove)\nusing this:\n  U\\<^sub>f \\<equiv>\n  Tensor.mat_of_cols_list 4\n   (map (map of_nat)\n     [[1 - f 0, f 0, 0, 0], [f 0, 1 - f 0, 0, 0], [0, 0, 1 - f 1, f 1],\n      [0, 0, f 1, 1 - f 1]])\n\ngoal (1 subgoal):\n 1. ((U\\<^sub>f $$ (0, 1) = of_nat (f 0) &&&\n      U\\<^sub>f $$ (1, 0) = of_nat (f 0)) &&&\n     U\\<^sub>f $$ (2, 3) = of_nat (f 1) &&&\n     U\\<^sub>f $$ (3, 2) = of_nat (f 1)) &&&\n    (U\\<^sub>f $$ (0, 0) = of_nat (1 - f 0) &&&\n     U\\<^sub>f $$ (1, 1) = of_nat (1 - f 0)) &&&\n    U\\<^sub>f $$ (2, 2) = of_nat (1 - f 1) &&&\n    U\\<^sub>f $$ (3, 3) = of_nat (1 - f 1)", "by auto"], ["", "abbreviation (in deutsch) V\\<^sub>f:: \"complex Matrix.mat\" where\n\"V\\<^sub>f \\<equiv> Matrix.mat 4 4 (\\<lambda>(i,j). \n                if i=0 \\<and> j=0 then 1 - f(0) else\n                  (if i=0 \\<and> j=1 then f(0) else\n                    (if i=1 \\<and> j=0 then f(0) else\n                      (if i=1 \\<and> j=1 then 1 - f(0) else\n                        (if i=2 \\<and> j=2 then 1 - f(1) else\n                          (if i=2 \\<and> j=3 then f(1) else\n                            (if i=3 \\<and> j=2 then f(1) else\n                              (if i=3 \\<and> j=3 then 1 - f(1) else 0))))))))\""], ["", "lemma (in deutsch) deutsch_transform_alt_rep_coeff_is_zero [simp]:\n  shows \"V\\<^sub>f $$ (0,2) = 0\" and \"V\\<^sub>f $$ (0,3) = 0\"\n    and \"V\\<^sub>f $$ (1,2) = 0\" and \"V\\<^sub>f $$(1,3) = 0\"\n    and \"V\\<^sub>f $$ (2,0) = 0\" and \"V\\<^sub>f $$(2,1) = 0\"\n    and \"V\\<^sub>f $$ (3,0) = 0\" and \"V\\<^sub>f $$ (3,1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((V\\<^sub>f $$ (0, 2) = 0 &&& V\\<^sub>f $$ (0, 3) = 0) &&&\n     V\\<^sub>f $$ (1, 2) = 0 &&& V\\<^sub>f $$ (1, 3) = 0) &&&\n    (V\\<^sub>f $$ (2, 0) = 0 &&& V\\<^sub>f $$ (2, 1) = 0) &&&\n    V\\<^sub>f $$ (3, 0) = 0 &&& V\\<^sub>f $$ (3, 1) = 0", "by auto"], ["", "lemma (in deutsch) deutsch_transform_alt_rep_coeff [simp]:\n  shows \"V\\<^sub>f $$ (0,1) = f(0)\" and \"V\\<^sub>f $$ (1,0) = f(0)\"\n    and \"V\\<^sub>f $$(2,3) = f(1)\" and \"V\\<^sub>f $$ (3,2) = f(1)\"\n    and \"V\\<^sub>f $$ (0,0) = 1 - f(0)\" and \"V\\<^sub>f $$(1,1) = 1 - f(0)\"\n    and \"V\\<^sub>f $$ (2,2) = 1 - f(1)\" and \"V\\<^sub>f $$ (3,3) = 1 - f(1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((V\\<^sub>f $$ (0, 1) = of_nat (f 0) &&&\n      V\\<^sub>f $$ (1, 0) = of_nat (f 0)) &&&\n     V\\<^sub>f $$ (2, 3) = of_nat (f 1) &&&\n     V\\<^sub>f $$ (3, 2) = of_nat (f 1)) &&&\n    (V\\<^sub>f $$ (0, 0) = of_nat (1 - f 0) &&&\n     V\\<^sub>f $$ (1, 1) = of_nat (1 - f 0)) &&&\n    V\\<^sub>f $$ (2, 2) = of_nat (1 - f 1) &&&\n    V\\<^sub>f $$ (3, 3) = of_nat (1 - f 1)", "by auto"], ["", "lemma (in deutsch) deutsch_transform_alt_rep:\n  shows \"U\\<^sub>f = V\\<^sub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U\\<^sub>f = V\\<^sub>f", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row V\\<^sub>f; j < dim_col V\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f $$ (i, j) = V\\<^sub>f $$ (i, j)\n 2. dim_row U\\<^sub>f = dim_row V\\<^sub>f\n 3. dim_col U\\<^sub>f = dim_col V\\<^sub>f", "show c0:\"dim_row U\\<^sub>f = dim_row V\\<^sub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row U\\<^sub>f = dim_row V\\<^sub>f", "by simp"], ["proof (state)\nthis:\n  dim_row U\\<^sub>f = dim_row V\\<^sub>f\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row V\\<^sub>f; j < dim_col V\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f $$ (i, j) = V\\<^sub>f $$ (i, j)\n 2. dim_col U\\<^sub>f = dim_col V\\<^sub>f", "show c1:\"dim_col U\\<^sub>f = dim_col V\\<^sub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col U\\<^sub>f = dim_col V\\<^sub>f", "by simp"], ["proof (state)\nthis:\n  dim_col U\\<^sub>f = dim_col V\\<^sub>f\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row V\\<^sub>f; j < dim_col V\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f $$ (i, j) = V\\<^sub>f $$ (i, j)", "fix i j:: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row V\\<^sub>f; j < dim_col V\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f $$ (i, j) = V\\<^sub>f $$ (i, j)", "assume \"i < dim_row V\\<^sub>f\" and \"j < dim_col V\\<^sub>f\""], ["proof (state)\nthis:\n  i < dim_row V\\<^sub>f\n  j < dim_col V\\<^sub>f\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row V\\<^sub>f; j < dim_col V\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f $$ (i, j) = V\\<^sub>f $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  i < dim_row V\\<^sub>f\n  j < dim_col V\\<^sub>f", "have \"i < 4\" and \"j < 4\""], ["proof (prove)\nusing this:\n  i < dim_row V\\<^sub>f\n  j < dim_col V\\<^sub>f\n\ngoal (1 subgoal):\n 1. i < 4 &&& j < 4", "by auto"], ["proof (state)\nthis:\n  i < 4\n  j < 4\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row V\\<^sub>f; j < dim_col V\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f $$ (i, j) = V\\<^sub>f $$ (i, j)", "thus \"U\\<^sub>f $$ (i,j) = V\\<^sub>f $$ (i,j)\""], ["proof (prove)\nusing this:\n  i < 4\n  j < 4\n\ngoal (1 subgoal):\n 1. U\\<^sub>f $$ (i, j) = V\\<^sub>f $$ (i, j)", "by (smt deutsch_transform_alt_rep_coeff deutsch_transform_alt_rep_coeff_is_zero deutsch_transform_coeff\n deutsch_transform_coeff_is_zero set_4_disj)"], ["proof (state)\nthis:\n  U\\<^sub>f $$ (i, j) = V\\<^sub>f $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{text U\\<^sub>f} is a gate.\\<close>"], ["", "lemma (in deutsch) transpose_of_deutsch_transform:\n  shows \"(U\\<^sub>f)\\<^sup>t = U\\<^sub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U\\<^sub>f\\<^sup>t = U\\<^sub>f", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row U\\<^sub>f; j < dim_col U\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f\\<^sup>t $$ (i, j) = U\\<^sub>f $$ (i, j)\n 2. dim_row U\\<^sub>f\\<^sup>t = dim_row U\\<^sub>f\n 3. dim_col U\\<^sub>f\\<^sup>t = dim_col U\\<^sub>f", "show \"dim_row (U\\<^sub>f\\<^sup>t) = dim_row U\\<^sub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row U\\<^sub>f\\<^sup>t = dim_row U\\<^sub>f", "by simp"], ["proof (state)\nthis:\n  dim_row U\\<^sub>f\\<^sup>t = dim_row U\\<^sub>f\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row U\\<^sub>f; j < dim_col U\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f\\<^sup>t $$ (i, j) = U\\<^sub>f $$ (i, j)\n 2. dim_col U\\<^sub>f\\<^sup>t = dim_col U\\<^sub>f", "show \"dim_col (U\\<^sub>f\\<^sup>t) = dim_col U\\<^sub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col U\\<^sub>f\\<^sup>t = dim_col U\\<^sub>f", "by simp"], ["proof (state)\nthis:\n  dim_col U\\<^sub>f\\<^sup>t = dim_col U\\<^sub>f\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row U\\<^sub>f; j < dim_col U\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f\\<^sup>t $$ (i, j) = U\\<^sub>f $$ (i, j)", "fix i j:: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row U\\<^sub>f; j < dim_col U\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f\\<^sup>t $$ (i, j) = U\\<^sub>f $$ (i, j)", "assume \"i < dim_row U\\<^sub>f\" and \"j < dim_col U\\<^sub>f\""], ["proof (state)\nthis:\n  i < dim_row U\\<^sub>f\n  j < dim_col U\\<^sub>f\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row U\\<^sub>f; j < dim_col U\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f\\<^sup>t $$ (i, j) = U\\<^sub>f $$ (i, j)", "thus \"U\\<^sub>f\\<^sup>t $$ (i, j) = U\\<^sub>f $$ (i, j)\""], ["proof (prove)\nusing this:\n  i < dim_row U\\<^sub>f\n  j < dim_col U\\<^sub>f\n\ngoal (1 subgoal):\n 1. U\\<^sub>f\\<^sup>t $$ (i, j) = U\\<^sub>f $$ (i, j)", "by (auto simp add: transpose_mat_def)\n      (metis deutsch_transform_coeff(1-4) deutsch_transform_coeff_is_zero set_4_disj)"], ["proof (state)\nthis:\n  U\\<^sub>f\\<^sup>t $$ (i, j) = U\\<^sub>f $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in deutsch) adjoint_of_deutsch_transform: \n  shows \"(U\\<^sub>f)\\<^sup>\\<dagger> = U\\<^sub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U\\<^sub>f\\<^sup>\\<dagger> = U\\<^sub>f", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row U\\<^sub>f; j < dim_col U\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f\\<^sup>\\<dagger> $$ (i, j) =\n                         U\\<^sub>f $$ (i, j)\n 2. dim_row U\\<^sub>f\\<^sup>\\<dagger> = dim_row U\\<^sub>f\n 3. dim_col U\\<^sub>f\\<^sup>\\<dagger> = dim_col U\\<^sub>f", "show \"dim_row (U\\<^sub>f\\<^sup>\\<dagger>) = dim_row U\\<^sub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row U\\<^sub>f\\<^sup>\\<dagger> = dim_row U\\<^sub>f", "by simp"], ["proof (state)\nthis:\n  dim_row U\\<^sub>f\\<^sup>\\<dagger> = dim_row U\\<^sub>f\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row U\\<^sub>f; j < dim_col U\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f\\<^sup>\\<dagger> $$ (i, j) =\n                         U\\<^sub>f $$ (i, j)\n 2. dim_col U\\<^sub>f\\<^sup>\\<dagger> = dim_col U\\<^sub>f", "show \"dim_col (U\\<^sub>f\\<^sup>\\<dagger>) = dim_col U\\<^sub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col U\\<^sub>f\\<^sup>\\<dagger> = dim_col U\\<^sub>f", "by simp"], ["proof (state)\nthis:\n  dim_col U\\<^sub>f\\<^sup>\\<dagger> = dim_col U\\<^sub>f\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row U\\<^sub>f; j < dim_col U\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f\\<^sup>\\<dagger> $$ (i, j) =\n                         U\\<^sub>f $$ (i, j)", "fix i j:: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row U\\<^sub>f; j < dim_col U\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f\\<^sup>\\<dagger> $$ (i, j) =\n                         U\\<^sub>f $$ (i, j)", "assume \"i < dim_row U\\<^sub>f\" and \"j < dim_col U\\<^sub>f\""], ["proof (state)\nthis:\n  i < dim_row U\\<^sub>f\n  j < dim_col U\\<^sub>f\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row U\\<^sub>f; j < dim_col U\\<^sub>f\\<rbrakk>\n       \\<Longrightarrow> U\\<^sub>f\\<^sup>\\<dagger> $$ (i, j) =\n                         U\\<^sub>f $$ (i, j)", "thus \"U\\<^sub>f\\<^sup>\\<dagger> $$ (i, j) = U\\<^sub>f $$ (i, j)\""], ["proof (prove)\nusing this:\n  i < dim_row U\\<^sub>f\n  j < dim_col U\\<^sub>f\n\ngoal (1 subgoal):\n 1. U\\<^sub>f\\<^sup>\\<dagger> $$ (i, j) = U\\<^sub>f $$ (i, j)", "by (auto simp add: dagger_def)\n      (metis complex_cnj_of_nat complex_cnj_zero deutsch_transform_coeff \n        deutsch_transform_coeff_is_zero set_4_disj)"], ["proof (state)\nthis:\n  U\\<^sub>f\\<^sup>\\<dagger> $$ (i, j) = U\\<^sub>f $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in deutsch) deutsch_transform_is_gate:\n  shows \"gate 2 U\\<^sub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gate 2 U\\<^sub>f", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. dim_row U\\<^sub>f = 2\\<^sup>2\n 2. square_mat U\\<^sub>f\n 3. unitary U\\<^sub>f", "show \"dim_row U\\<^sub>f = 2\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row U\\<^sub>f = 2\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  dim_row U\\<^sub>f = 2\\<^sup>2\n\ngoal (2 subgoals):\n 1. square_mat U\\<^sub>f\n 2. unitary U\\<^sub>f", "show \"square_mat U\\<^sub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_mat U\\<^sub>f", "by simp"], ["proof (state)\nthis:\n  square_mat U\\<^sub>f\n\ngoal (1 subgoal):\n 1. unitary U\\<^sub>f", "show \"unitary U\\<^sub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary U\\<^sub>f", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. unitary U\\<^sub>f", "have \"U\\<^sub>f * U\\<^sub>f = 1\\<^sub>m (dim_col U\\<^sub>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U\\<^sub>f * U\\<^sub>f = 1\\<^sub>m (dim_col U\\<^sub>f)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m (dim_col U\\<^sub>f));\n        j < dim_col (1\\<^sub>m (dim_col U\\<^sub>f))\\<rbrakk>\n       \\<Longrightarrow> (U\\<^sub>f * U\\<^sub>f) $$ (i, j) =\n                         1\\<^sub>m (dim_col U\\<^sub>f) $$ (i, j)\n 2. dim_row (U\\<^sub>f * U\\<^sub>f) =\n    dim_row (1\\<^sub>m (dim_col U\\<^sub>f))\n 3. dim_col (U\\<^sub>f * U\\<^sub>f) =\n    dim_col (1\\<^sub>m (dim_col U\\<^sub>f))", "show \"dim_row (U\\<^sub>f * U\\<^sub>f) = dim_row (1\\<^sub>m (dim_col U\\<^sub>f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (U\\<^sub>f * U\\<^sub>f) =\n    dim_row (1\\<^sub>m (dim_col U\\<^sub>f))", "by simp"], ["proof (state)\nthis:\n  dim_row (U\\<^sub>f * U\\<^sub>f) = dim_row (1\\<^sub>m (dim_col U\\<^sub>f))\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m (dim_col U\\<^sub>f));\n        j < dim_col (1\\<^sub>m (dim_col U\\<^sub>f))\\<rbrakk>\n       \\<Longrightarrow> (U\\<^sub>f * U\\<^sub>f) $$ (i, j) =\n                         1\\<^sub>m (dim_col U\\<^sub>f) $$ (i, j)\n 2. dim_col (U\\<^sub>f * U\\<^sub>f) =\n    dim_col (1\\<^sub>m (dim_col U\\<^sub>f))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m (dim_col U\\<^sub>f));\n        j < dim_col (1\\<^sub>m (dim_col U\\<^sub>f))\\<rbrakk>\n       \\<Longrightarrow> (U\\<^sub>f * U\\<^sub>f) $$ (i, j) =\n                         1\\<^sub>m (dim_col U\\<^sub>f) $$ (i, j)\n 2. dim_col (U\\<^sub>f * U\\<^sub>f) =\n    dim_col (1\\<^sub>m (dim_col U\\<^sub>f))", "show \"dim_col (U\\<^sub>f * U\\<^sub>f) = dim_col (1\\<^sub>m (dim_col U\\<^sub>f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (U\\<^sub>f * U\\<^sub>f) =\n    dim_col (1\\<^sub>m (dim_col U\\<^sub>f))", "by simp"], ["proof (state)\nthis:\n  dim_col (U\\<^sub>f * U\\<^sub>f) = dim_col (1\\<^sub>m (dim_col U\\<^sub>f))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m (dim_col U\\<^sub>f));\n        j < dim_col (1\\<^sub>m (dim_col U\\<^sub>f))\\<rbrakk>\n       \\<Longrightarrow> (U\\<^sub>f * U\\<^sub>f) $$ (i, j) =\n                         1\\<^sub>m (dim_col U\\<^sub>f) $$ (i, j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m (dim_col U\\<^sub>f));\n        j < dim_col (1\\<^sub>m (dim_col U\\<^sub>f))\\<rbrakk>\n       \\<Longrightarrow> (U\\<^sub>f * U\\<^sub>f) $$ (i, j) =\n                         1\\<^sub>m (dim_col U\\<^sub>f) $$ (i, j)", "fix i j:: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m (dim_col U\\<^sub>f));\n        j < dim_col (1\\<^sub>m (dim_col U\\<^sub>f))\\<rbrakk>\n       \\<Longrightarrow> (U\\<^sub>f * U\\<^sub>f) $$ (i, j) =\n                         1\\<^sub>m (dim_col U\\<^sub>f) $$ (i, j)", "assume \"i < dim_row (1\\<^sub>m (dim_col U\\<^sub>f))\" and \"j < dim_col (1\\<^sub>m (dim_col U\\<^sub>f))\""], ["proof (state)\nthis:\n  i < dim_row (1\\<^sub>m (dim_col U\\<^sub>f))\n  j < dim_col (1\\<^sub>m (dim_col U\\<^sub>f))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m (dim_col U\\<^sub>f));\n        j < dim_col (1\\<^sub>m (dim_col U\\<^sub>f))\\<rbrakk>\n       \\<Longrightarrow> (U\\<^sub>f * U\\<^sub>f) $$ (i, j) =\n                         1\\<^sub>m (dim_col U\\<^sub>f) $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  i < dim_row (1\\<^sub>m (dim_col U\\<^sub>f))\n  j < dim_col (1\\<^sub>m (dim_col U\\<^sub>f))", "show \"(U\\<^sub>f * U\\<^sub>f) $$ (i,j) = 1\\<^sub>m (dim_col U\\<^sub>f) $$ (i, j)\""], ["proof (prove)\nusing this:\n  i < dim_row (1\\<^sub>m (dim_col U\\<^sub>f))\n  j < dim_col (1\\<^sub>m (dim_col U\\<^sub>f))\n\ngoal (1 subgoal):\n 1. (U\\<^sub>f * U\\<^sub>f) $$ (i, j) =\n    1\\<^sub>m (dim_col U\\<^sub>f) $$ (i, j)", "apply (auto simp add: deutsch_transform_alt_rep one_mat_def times_mat_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>j < 4; i = j\\<rbrakk>\n    \\<Longrightarrow> Matrix.vec 4\n                       (\\<lambda>ja.\n                           of_nat\n                            (if j = 0 \\<and> ja = 0 then 1 - f 0\n                             else if j = 0 \\<and> ja = 1 then f 0\n                                  else if j = 1 \\<and> ja = 0 then f 0\n else if j = 1 \\<and> ja = 1 then 1 - f 0\n      else if j = 2 \\<and> ja = 2 then 1 - f 1\n           else if j = 2 \\<and> ja = 3 then f 1\n                else if j = 3 \\<and> ja = 2 then f 1\n                     else if j = 3 \\<and> ja = 3 then 1 - f 1\n                          else 0)) \\<bullet>\n                      Matrix.vec 4\n                       (\\<lambda>i.\n                           of_nat\n                            (if i = 0 \\<and> j = 0 then 1 - f 0\n                             else if i = 0 \\<and> j = 1 then f 0\n                                  else if i = 1 \\<and> j = 0 then f 0\n else if i = 1 \\<and> j = 1 then 1 - f 0\n      else if i = 2 \\<and> j = 2 then 1 - f 1\n           else if i = 2 \\<and> j = 3 then f 1\n                else if i = 3 \\<and> j = 2 then f 1\n                     else if i = 3 \\<and> j = 3 then 1 - f 1 else 0)) =\n                      1\n 2. \\<lbrakk>i < 4; j < 4; i \\<noteq> j\\<rbrakk>\n    \\<Longrightarrow> Matrix.vec 4\n                       (\\<lambda>j.\n                           of_nat\n                            (if i = 0 \\<and> j = 0 then 1 - f 0\n                             else if i = 0 \\<and> j = 1 then f 0\n                                  else if i = 1 \\<and> j = 0 then f 0\n else if i = 1 \\<and> j = 1 then 1 - f 0\n      else if i = 2 \\<and> j = 2 then 1 - f 1\n           else if i = 2 \\<and> j = 3 then f 1\n                else if i = 3 \\<and> j = 2 then f 1\n                     else if i = 3 \\<and> j = 3 then 1 - f 1\n                          else 0)) \\<bullet>\n                      Matrix.vec 4\n                       (\\<lambda>i.\n                           of_nat\n                            (if i = 0 \\<and> j = 0 then 1 - f 0\n                             else if i = 0 \\<and> j = 1 then f 0\n                                  else if i = 1 \\<and> j = 0 then f 0\n else if i = 1 \\<and> j = 1 then 1 - f 0\n      else if i = 2 \\<and> j = 2 then 1 - f 1\n           else if i = 2 \\<and> j = 3 then f 1\n                else if i = 3 \\<and> j = 2 then f 1\n                     else if i = 3 \\<and> j = 3 then 1 - f 1 else 0)) =\n                      0", "apply (auto simp: scalar_prod_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>i = 2; j = 2\\<rbrakk>\n    \\<Longrightarrow> of_nat (Suc 0 - f (Suc 0)) *\n                      of_nat (Suc 0 - f (Suc 0)) +\n                      of_nat (f (Suc 0)) * of_nat (f (Suc 0)) =\n                      1\n 2. \\<lbrakk>i = Suc 0; j = Suc 0\\<rbrakk>\n    \\<Longrightarrow> of_nat (f 0) * of_nat (f 0) +\n                      of_nat (Suc 0 - f 0) * of_nat (Suc 0 - f 0) =\n                      1\n 3. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> of_nat (Suc 0 - f 0) * of_nat (Suc 0 - f 0) +\n                      of_nat (f 0) * of_nat (f 0) =\n                      1\n 4. \\<lbrakk>j < 4; i = j; j \\<noteq> 2; j \\<noteq> Suc 0; 0 < j\\<rbrakk>\n    \\<Longrightarrow> of_nat (f (Suc 0)) * of_nat (f (Suc 0)) +\n                      of_nat (Suc 0 - f (Suc 0)) *\n                      of_nat (Suc 0 - f (Suc 0)) =\n                      1", "using f_values"], ["proof (prove)\nusing this:\n  (f 0 = 0 \\<or> f 0 = 1) \\<and> (f 1 = 0 \\<or> f 1 = 1)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i = 2; j = 2\\<rbrakk>\n    \\<Longrightarrow> of_nat (Suc 0 - f (Suc 0)) *\n                      of_nat (Suc 0 - f (Suc 0)) +\n                      of_nat (f (Suc 0)) * of_nat (f (Suc 0)) =\n                      1\n 2. \\<lbrakk>i = Suc 0; j = Suc 0\\<rbrakk>\n    \\<Longrightarrow> of_nat (f 0) * of_nat (f 0) +\n                      of_nat (Suc 0 - f 0) * of_nat (Suc 0 - f 0) =\n                      1\n 3. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> of_nat (Suc 0 - f 0) * of_nat (Suc 0 - f 0) +\n                      of_nat (f 0) * of_nat (f 0) =\n                      1\n 4. \\<lbrakk>j < 4; i = j; j \\<noteq> 2; j \\<noteq> Suc 0; 0 < j\\<rbrakk>\n    \\<Longrightarrow> of_nat (f (Suc 0)) * of_nat (f (Suc 0)) +\n                      of_nat (Suc 0 - f (Suc 0)) *\n                      of_nat (Suc 0 - f (Suc 0)) =\n                      1", "by auto"], ["proof (state)\nthis:\n  (U\\<^sub>f * U\\<^sub>f) $$ (i, j) =\n  1\\<^sub>m (dim_col U\\<^sub>f) $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U\\<^sub>f * U\\<^sub>f = 1\\<^sub>m (dim_col U\\<^sub>f)\n\ngoal (1 subgoal):\n 1. unitary U\\<^sub>f", "thus ?thesis"], ["proof (prove)\nusing this:\n  U\\<^sub>f * U\\<^sub>f = 1\\<^sub>m (dim_col U\\<^sub>f)\n\ngoal (1 subgoal):\n 1. unitary U\\<^sub>f", "by (simp add: adjoint_of_deutsch_transform unitary_def)"], ["proof (state)\nthis:\n  unitary U\\<^sub>f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unitary U\\<^sub>f\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nTwo qubits are prepared. \nThe first one in the state $|0\\rangle$, the second one in the state $|1\\rangle$.\n\\<close>"], ["", "abbreviation zero where \"zero \\<equiv> unit_vec 2 0\""], ["", "abbreviation one where \"one \\<equiv> unit_vec 2 1\""], ["", "lemma ket_zero_is_state: \n  shows \"state 1 |zero\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state 1 |Deutsch.zero\\<rangle>", "by (simp add: state_def ket_vec_def cpx_vec_length_def numerals(2))"], ["", "lemma ket_one_is_state:\n  shows \"state 1 |one\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state 1 |Deutsch.one\\<rangle>", "by (simp add: state_def ket_vec_def cpx_vec_length_def numerals(2))"], ["", "lemma ket_zero_to_mat_of_cols_list [simp]: \"|zero\\<rangle> = mat_of_cols_list 2 [[1, 0]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |Deutsch.zero\\<rangle> = Tensor.mat_of_cols_list 2 [[1, 0]]", "by (auto simp add: ket_vec_def mat_of_cols_list_def)"], ["", "lemma ket_one_to_mat_of_cols_list [simp]: \"|one\\<rangle> = mat_of_cols_list 2 [[0, 1]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |Deutsch.one\\<rangle> = Tensor.mat_of_cols_list 2 [[0, 1]]", "apply (auto simp add: ket_vec_def unit_vec_def mat_of_cols_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat 2 (Suc 0)\n     (\\<lambda>(i, j).\n         Matrix.vec 2 (\\<lambda>j. if j = Suc 0 then 1 else 0) $ i) =\n    Matrix.mat 2 (Suc 0) (\\<lambda>(i, j). [[0, 1]] ! j ! i)", "using less_2_cases"], ["proof (prove)\nusing this:\n  ?n < 2 \\<Longrightarrow> ?n = 0 \\<or> ?n = Suc 0\n\ngoal (1 subgoal):\n 1. Matrix.mat 2 (Suc 0)\n     (\\<lambda>(i, j).\n         Matrix.vec 2 (\\<lambda>j. if j = Suc 0 then 1 else 0) $ i) =\n    Matrix.mat 2 (Suc 0) (\\<lambda>(i, j). [[0, 1]] ! j ! i)", "by fastforce"], ["", "text \\<open>\nApplying the Hadamard gate to the state $|0\\rangle$ results in the new state \n@{term \"\\<psi>\\<^sub>0\\<^sub>0\"} = $\\dfrac {(|0\\rangle + |1\\rangle)} {\\sqrt 2 }$\n\\<close>"], ["", "abbreviation \\<psi>\\<^sub>0\\<^sub>0:: \"complex Matrix.mat\" where\n\"\\<psi>\\<^sub>0\\<^sub>0 \\<equiv> mat_of_cols_list 2 [[1/sqrt(2), 1/sqrt(2)]]\""], ["", "lemma H_on_ket_zero: \n  shows \"(H * |zero\\<rangle>) = \\<psi>\\<^sub>0\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H * |Deutsch.zero\\<rangle> =\n    Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]])", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 2\n                       (map (map complex_of_real)\n                         [[1 / sqrt 2, 1 / sqrt 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 2\n               (map (map complex_of_real)\n                 [[1 / sqrt 2, 1 / sqrt 2]]))\\<rbrakk>\n       \\<Longrightarrow> (H * |Deutsch.zero\\<rangle>) $$ (i, j) =\n                         Tensor.mat_of_cols_list 2\n                          (map (map complex_of_real)\n                            [[1 / sqrt 2, 1 / sqrt 2]]) $$\n                         (i, j)\n 2. dim_row (H * |Deutsch.zero\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))\n 3. dim_col (H * |Deutsch.zero\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))", "fix i j:: nat"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 2\n                       (map (map complex_of_real)\n                         [[1 / sqrt 2, 1 / sqrt 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 2\n               (map (map complex_of_real)\n                 [[1 / sqrt 2, 1 / sqrt 2]]))\\<rbrakk>\n       \\<Longrightarrow> (H * |Deutsch.zero\\<rangle>) $$ (i, j) =\n                         Tensor.mat_of_cols_list 2\n                          (map (map complex_of_real)\n                            [[1 / sqrt 2, 1 / sqrt 2]]) $$\n                         (i, j)\n 2. dim_row (H * |Deutsch.zero\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))\n 3. dim_col (H * |Deutsch.zero\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))", "assume \"i < dim_row \\<psi>\\<^sub>0\\<^sub>0\" and \"j < dim_col \\<psi>\\<^sub>0\\<^sub>0\""], ["proof (state)\nthis:\n  i < dim_row\n       (Tensor.mat_of_cols_list 2\n         (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))\n  j < dim_col\n       (Tensor.mat_of_cols_list 2\n         (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 2\n                       (map (map complex_of_real)\n                         [[1 / sqrt 2, 1 / sqrt 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 2\n               (map (map complex_of_real)\n                 [[1 / sqrt 2, 1 / sqrt 2]]))\\<rbrakk>\n       \\<Longrightarrow> (H * |Deutsch.zero\\<rangle>) $$ (i, j) =\n                         Tensor.mat_of_cols_list 2\n                          (map (map complex_of_real)\n                            [[1 / sqrt 2, 1 / sqrt 2]]) $$\n                         (i, j)\n 2. dim_row (H * |Deutsch.zero\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))\n 3. dim_col (H * |Deutsch.zero\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))", "then"], ["proof (chain)\npicking this:\n  i < dim_row\n       (Tensor.mat_of_cols_list 2\n         (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))\n  j < dim_col\n       (Tensor.mat_of_cols_list 2\n         (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))", "have \"i \\<in> {0,1} \\<and> j = 0\""], ["proof (prove)\nusing this:\n  i < dim_row\n       (Tensor.mat_of_cols_list 2\n         (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))\n  j < dim_col\n       (Tensor.mat_of_cols_list 2\n         (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))\n\ngoal (1 subgoal):\n 1. i \\<in> {0, 1} \\<and> j = 0", "by (simp add: mat_of_cols_list_def less_2_cases)"], ["proof (state)\nthis:\n  i \\<in> {0, 1} \\<and> j = 0\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 2\n                       (map (map complex_of_real)\n                         [[1 / sqrt 2, 1 / sqrt 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 2\n               (map (map complex_of_real)\n                 [[1 / sqrt 2, 1 / sqrt 2]]))\\<rbrakk>\n       \\<Longrightarrow> (H * |Deutsch.zero\\<rangle>) $$ (i, j) =\n                         Tensor.mat_of_cols_list 2\n                          (map (map complex_of_real)\n                            [[1 / sqrt 2, 1 / sqrt 2]]) $$\n                         (i, j)\n 2. dim_row (H * |Deutsch.zero\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))\n 3. dim_col (H * |Deutsch.zero\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))", "then"], ["proof (chain)\npicking this:\n  i \\<in> {0, 1} \\<and> j = 0", "show \"(H * |zero\\<rangle>) $$ (i,j) = \\<psi>\\<^sub>0\\<^sub>0 $$ (i,j)\""], ["proof (prove)\nusing this:\n  i \\<in> {0, 1} \\<and> j = 0\n\ngoal (1 subgoal):\n 1. (H * |Deutsch.zero\\<rangle>) $$ (i, j) =\n    Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) $$\n    (i, j)", "by (auto simp add: mat_of_cols_list_def times_mat_def scalar_prod_def H_def)"], ["proof (state)\nthis:\n  (H * |Deutsch.zero\\<rangle>) $$ (i, j) =\n  Tensor.mat_of_cols_list 2\n   (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) $$\n  (i, j)\n\ngoal (2 subgoals):\n 1. dim_row (H * |Deutsch.zero\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))\n 2. dim_col (H * |Deutsch.zero\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. dim_row (H * |Deutsch.zero\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))\n 2. dim_col (H * |Deutsch.zero\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))", "show \"dim_row (H * |zero\\<rangle>) = dim_row \\<psi>\\<^sub>0\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (H * |Deutsch.zero\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))", "by (simp add: H_def mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_row (H * |Deutsch.zero\\<rangle>) =\n  dim_row\n   (Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))\n\ngoal (1 subgoal):\n 1. dim_col (H * |Deutsch.zero\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))", "show \"dim_col (H * |zero\\<rangle>) = dim_col \\<psi>\\<^sub>0\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (H * |Deutsch.zero\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))", "by (simp add: H_def mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_col (H * |Deutsch.zero\\<rangle>) =\n  dim_col\n   (Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma H_on_ket_zero_is_state: \n  shows \"state 1 (H * |zero\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state 1 (H * |Deutsch.zero\\<rangle>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. gate 1 H\n 2. state 1 |Deutsch.zero\\<rangle>", "show \"gate 1 H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gate 1 H", "using H_is_gate"], ["proof (prove)\nusing this:\n  gate 1 H\n\ngoal (1 subgoal):\n 1. gate 1 H", "by simp"], ["proof (state)\nthis:\n  gate 1 H\n\ngoal (1 subgoal):\n 1. state 1 |Deutsch.zero\\<rangle>", "show \"state 1 |zero\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state 1 |Deutsch.zero\\<rangle>", "using ket_zero_is_state"], ["proof (prove)\nusing this:\n  state 1 |Deutsch.zero\\<rangle>\n\ngoal (1 subgoal):\n 1. state 1 |Deutsch.zero\\<rangle>", "by simp"], ["proof (state)\nthis:\n  state 1 |Deutsch.zero\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nApplying the Hadamard gate to the state $|0\\rangle$ results in the new state \n@{text \\<psi>\\<^sub>0\\<^sub>1} = $\\dfrac {(|0\\rangle - |1\\rangle)} {\\sqrt 2}$.\n\\<close>"], ["", "abbreviation \\<psi>\\<^sub>0\\<^sub>1:: \"complex Matrix.mat\" where\n\"\\<psi>\\<^sub>0\\<^sub>1 \\<equiv> mat_of_cols_list 2 [[1/sqrt(2), -1/sqrt(2)]]\""], ["", "lemma H_on_ket_one: \n  shows \"(H * |one\\<rangle>) = \\<psi>\\<^sub>0\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H * |Deutsch.one\\<rangle> =\n    Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 2\n                       (map (map complex_of_real)\n                         [[1 / sqrt 2, - 1 / sqrt 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 2\n               (map (map complex_of_real)\n                 [[1 / sqrt 2, - 1 / sqrt 2]]))\\<rbrakk>\n       \\<Longrightarrow> (H * |Deutsch.one\\<rangle>) $$ (i, j) =\n                         Tensor.mat_of_cols_list 2\n                          (map (map complex_of_real)\n                            [[1 / sqrt 2, - 1 / sqrt 2]]) $$\n                         (i, j)\n 2. dim_row (H * |Deutsch.one\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))\n 3. dim_col (H * |Deutsch.one\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))", "fix i j:: nat"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 2\n                       (map (map complex_of_real)\n                         [[1 / sqrt 2, - 1 / sqrt 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 2\n               (map (map complex_of_real)\n                 [[1 / sqrt 2, - 1 / sqrt 2]]))\\<rbrakk>\n       \\<Longrightarrow> (H * |Deutsch.one\\<rangle>) $$ (i, j) =\n                         Tensor.mat_of_cols_list 2\n                          (map (map complex_of_real)\n                            [[1 / sqrt 2, - 1 / sqrt 2]]) $$\n                         (i, j)\n 2. dim_row (H * |Deutsch.one\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))\n 3. dim_col (H * |Deutsch.one\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))", "assume \"i < dim_row \\<psi>\\<^sub>0\\<^sub>1\" and \"j < dim_col \\<psi>\\<^sub>0\\<^sub>1\""], ["proof (state)\nthis:\n  i < dim_row\n       (Tensor.mat_of_cols_list 2\n         (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))\n  j < dim_col\n       (Tensor.mat_of_cols_list 2\n         (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 2\n                       (map (map complex_of_real)\n                         [[1 / sqrt 2, - 1 / sqrt 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 2\n               (map (map complex_of_real)\n                 [[1 / sqrt 2, - 1 / sqrt 2]]))\\<rbrakk>\n       \\<Longrightarrow> (H * |Deutsch.one\\<rangle>) $$ (i, j) =\n                         Tensor.mat_of_cols_list 2\n                          (map (map complex_of_real)\n                            [[1 / sqrt 2, - 1 / sqrt 2]]) $$\n                         (i, j)\n 2. dim_row (H * |Deutsch.one\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))\n 3. dim_col (H * |Deutsch.one\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))", "then"], ["proof (chain)\npicking this:\n  i < dim_row\n       (Tensor.mat_of_cols_list 2\n         (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))\n  j < dim_col\n       (Tensor.mat_of_cols_list 2\n         (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))", "have \"i \\<in> {0,1} \\<and> j = 0\""], ["proof (prove)\nusing this:\n  i < dim_row\n       (Tensor.mat_of_cols_list 2\n         (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))\n  j < dim_col\n       (Tensor.mat_of_cols_list 2\n         (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))\n\ngoal (1 subgoal):\n 1. i \\<in> {0, 1} \\<and> j = 0", "by (simp add: mat_of_cols_list_def less_2_cases)"], ["proof (state)\nthis:\n  i \\<in> {0, 1} \\<and> j = 0\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 2\n                       (map (map complex_of_real)\n                         [[1 / sqrt 2, - 1 / sqrt 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 2\n               (map (map complex_of_real)\n                 [[1 / sqrt 2, - 1 / sqrt 2]]))\\<rbrakk>\n       \\<Longrightarrow> (H * |Deutsch.one\\<rangle>) $$ (i, j) =\n                         Tensor.mat_of_cols_list 2\n                          (map (map complex_of_real)\n                            [[1 / sqrt 2, - 1 / sqrt 2]]) $$\n                         (i, j)\n 2. dim_row (H * |Deutsch.one\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))\n 3. dim_col (H * |Deutsch.one\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))", "then"], ["proof (chain)\npicking this:\n  i \\<in> {0, 1} \\<and> j = 0", "show \"(H * |one\\<rangle>) $$ (i,j) = \\<psi>\\<^sub>0\\<^sub>1 $$ (i,j)\""], ["proof (prove)\nusing this:\n  i \\<in> {0, 1} \\<and> j = 0\n\ngoal (1 subgoal):\n 1. (H * |Deutsch.one\\<rangle>) $$ (i, j) =\n    Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]) $$\n    (i, j)", "by (auto simp add: mat_of_cols_list_def times_mat_def scalar_prod_def H_def ket_vec_def)"], ["proof (state)\nthis:\n  (H * |Deutsch.one\\<rangle>) $$ (i, j) =\n  Tensor.mat_of_cols_list 2\n   (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]) $$\n  (i, j)\n\ngoal (2 subgoals):\n 1. dim_row (H * |Deutsch.one\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))\n 2. dim_col (H * |Deutsch.one\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. dim_row (H * |Deutsch.one\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))\n 2. dim_col (H * |Deutsch.one\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))", "show \"dim_row (H * |one\\<rangle>) = dim_row \\<psi>\\<^sub>0\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (H * |Deutsch.one\\<rangle>) =\n    dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))", "by (simp add: H_def mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_row (H * |Deutsch.one\\<rangle>) =\n  dim_row\n   (Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))\n\ngoal (1 subgoal):\n 1. dim_col (H * |Deutsch.one\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))", "show \"dim_col (H * |one\\<rangle>) = dim_col \\<psi>\\<^sub>0\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (H * |Deutsch.one\\<rangle>) =\n    dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))", "by (simp add: H_def mat_of_cols_list_def ket_vec_def)"], ["proof (state)\nthis:\n  dim_col (H * |Deutsch.one\\<rangle>) =\n  dim_col\n   (Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma H_on_ket_one_is_state: \n  shows \"state 1 (H * |one\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state 1 (H * |Deutsch.one\\<rangle>)", "using H_is_gate ket_one_is_state"], ["proof (prove)\nusing this:\n  gate 1 H\n  state 1 |Deutsch.one\\<rangle>\n\ngoal (1 subgoal):\n 1. state 1 (H * |Deutsch.one\\<rangle>)", "by simp"], ["", "text\\<open>\nThen, the state @{text \\<psi>\\<^sub>1} = $\\dfrac {(|00\\rangle - |01\\rangle + |10\\rangle - |11\\rangle)} {2} $\nis obtained by taking the tensor product of the states \n@{text \\<psi>\\<^sub>0\\<^sub>0} = $\\dfrac {(|0\\rangle + |1\\rangle)} {\\sqrt 2} $  and  \n@{text \\<psi>\\<^sub>0\\<^sub>1} = $\\dfrac {(|0\\rangle - |1\\rangle)} {\\sqrt 2} $.\n\\<close>"], ["", "abbreviation \\<psi>\\<^sub>1:: \"complex Matrix.mat\" where\n\"\\<psi>\\<^sub>1 \\<equiv> mat_of_cols_list 4 [[1/2, -1/2, 1/2, -1/2]]\""], ["", "lemma \\<psi>\\<^sub>0_to_\\<psi>\\<^sub>1: \n  shows \"(\\<psi>\\<^sub>0\\<^sub>0 \\<Otimes> \\<psi>\\<^sub>0\\<^sub>1) = \\<psi>\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n    Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]) =\n    \\<psi>\\<^sub>1", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row \\<psi>\\<^sub>1;\n        j < dim_col \\<psi>\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Tensor.mat_of_cols_list 2\n                           (map (map complex_of_real)\n                             [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n                          Tensor.mat_of_cols_list 2\n                           (map (map complex_of_real)\n                             [[1 / sqrt 2, - 1 / sqrt 2]])) $$\n                         (i, j) =\n                         \\<psi>\\<^sub>1 $$ (i, j)\n 2. dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_row \\<psi>\\<^sub>1\n 3. dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_col \\<psi>\\<^sub>1", "fix i j:: nat"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row \\<psi>\\<^sub>1;\n        j < dim_col \\<psi>\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Tensor.mat_of_cols_list 2\n                           (map (map complex_of_real)\n                             [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n                          Tensor.mat_of_cols_list 2\n                           (map (map complex_of_real)\n                             [[1 / sqrt 2, - 1 / sqrt 2]])) $$\n                         (i, j) =\n                         \\<psi>\\<^sub>1 $$ (i, j)\n 2. dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_row \\<psi>\\<^sub>1\n 3. dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_col \\<psi>\\<^sub>1", "assume \"i < dim_row \\<psi>\\<^sub>1\" and \"j < dim_col \\<psi>\\<^sub>1\""], ["proof (state)\nthis:\n  i < dim_row \\<psi>\\<^sub>1\n  j < dim_col \\<psi>\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row \\<psi>\\<^sub>1;\n        j < dim_col \\<psi>\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Tensor.mat_of_cols_list 2\n                           (map (map complex_of_real)\n                             [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n                          Tensor.mat_of_cols_list 2\n                           (map (map complex_of_real)\n                             [[1 / sqrt 2, - 1 / sqrt 2]])) $$\n                         (i, j) =\n                         \\<psi>\\<^sub>1 $$ (i, j)\n 2. dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_row \\<psi>\\<^sub>1\n 3. dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_col \\<psi>\\<^sub>1", "then"], ["proof (chain)\npicking this:\n  i < dim_row \\<psi>\\<^sub>1\n  j < dim_col \\<psi>\\<^sub>1", "have \"i \\<in> {0,1,2,3}\" and \"j = 0\""], ["proof (prove)\nusing this:\n  i < dim_row \\<psi>\\<^sub>1\n  j < dim_col \\<psi>\\<^sub>1\n\ngoal (1 subgoal):\n 1. i \\<in> {0, 1, 2, 3} &&& j = 0", "using mat_of_cols_list_def"], ["proof (prove)\nusing this:\n  i < dim_row \\<psi>\\<^sub>1\n  j < dim_col \\<psi>\\<^sub>1\n  Tensor.mat_of_cols_list ?nr ?cs =\n  Matrix.mat ?nr (length ?cs) (\\<lambda>(i, j). ?cs ! j ! i)\n\ngoal (1 subgoal):\n 1. i \\<in> {0, 1, 2, 3} &&& j = 0", "by auto"], ["proof (state)\nthis:\n  i \\<in> {0, 1, 2, 3}\n  j = 0\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row \\<psi>\\<^sub>1;\n        j < dim_col \\<psi>\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Tensor.mat_of_cols_list 2\n                           (map (map complex_of_real)\n                             [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n                          Tensor.mat_of_cols_list 2\n                           (map (map complex_of_real)\n                             [[1 / sqrt 2, - 1 / sqrt 2]])) $$\n                         (i, j) =\n                         \\<psi>\\<^sub>1 $$ (i, j)\n 2. dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_row \\<psi>\\<^sub>1\n 3. dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_col \\<psi>\\<^sub>1", "moreover"], ["proof (state)\nthis:\n  i \\<in> {0, 1, 2, 3}\n  j = 0\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row \\<psi>\\<^sub>1;\n        j < dim_col \\<psi>\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Tensor.mat_of_cols_list 2\n                           (map (map complex_of_real)\n                             [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n                          Tensor.mat_of_cols_list 2\n                           (map (map complex_of_real)\n                             [[1 / sqrt 2, - 1 / sqrt 2]])) $$\n                         (i, j) =\n                         \\<psi>\\<^sub>1 $$ (i, j)\n 2. dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_row \\<psi>\\<^sub>1\n 3. dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_col \\<psi>\\<^sub>1", "have \"complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2", "by (metis mult_2_right numeral_Bit0 of_real_mult of_real_numeral real_sqrt_four real_sqrt_mult)"], ["proof (state)\nthis:\n  complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row \\<psi>\\<^sub>1;\n        j < dim_col \\<psi>\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (Tensor.mat_of_cols_list 2\n                           (map (map complex_of_real)\n                             [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n                          Tensor.mat_of_cols_list 2\n                           (map (map complex_of_real)\n                             [[1 / sqrt 2, - 1 / sqrt 2]])) $$\n                         (i, j) =\n                         \\<psi>\\<^sub>1 $$ (i, j)\n 2. dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_row \\<psi>\\<^sub>1\n 3. dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_col \\<psi>\\<^sub>1", "ultimately"], ["proof (chain)\npicking this:\n  i \\<in> {0, 1, 2, 3}\n  j = 0\n  complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2", "show \"(\\<psi>\\<^sub>0\\<^sub>0 \\<Otimes> \\<psi>\\<^sub>0\\<^sub>1) $$ (i,j) = \\<psi>\\<^sub>1 $$ (i,j)\""], ["proof (prove)\nusing this:\n  i \\<in> {0, 1, 2, 3}\n  j = 0\n  complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2\n\ngoal (1 subgoal):\n 1. (Tensor.mat_of_cols_list 2\n      (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n     Tensor.mat_of_cols_list 2\n      (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) $$\n    (i, j) =\n    \\<psi>\\<^sub>1 $$ (i, j)", "using mat_of_cols_list_def"], ["proof (prove)\nusing this:\n  i \\<in> {0, 1, 2, 3}\n  j = 0\n  complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2\n  Tensor.mat_of_cols_list ?nr ?cs =\n  Matrix.mat ?nr (length ?cs) (\\<lambda>(i, j). ?cs ! j ! i)\n\ngoal (1 subgoal):\n 1. (Tensor.mat_of_cols_list 2\n      (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n     Tensor.mat_of_cols_list 2\n      (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) $$\n    (i, j) =\n    \\<psi>\\<^sub>1 $$ (i, j)", "by auto"], ["proof (state)\nthis:\n  (Tensor.mat_of_cols_list 2\n    (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n   Tensor.mat_of_cols_list 2\n    (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) $$\n  (i, j) =\n  \\<psi>\\<^sub>1 $$ (i, j)\n\ngoal (2 subgoals):\n 1. dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_row \\<psi>\\<^sub>1\n 2. dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_col \\<psi>\\<^sub>1", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_row \\<psi>\\<^sub>1\n 2. dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_col \\<psi>\\<^sub>1", "show \"dim_row (\\<psi>\\<^sub>0\\<^sub>0 \\<Otimes> \\<psi>\\<^sub>0\\<^sub>1) = dim_row \\<psi>\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_row \\<psi>\\<^sub>1", "by (simp add: mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_row\n   (Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n    Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n  dim_row \\<psi>\\<^sub>1\n\ngoal (1 subgoal):\n 1. dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_col \\<psi>\\<^sub>1", "show \"dim_col (\\<psi>\\<^sub>0\\<^sub>0 \\<Otimes> \\<psi>\\<^sub>0\\<^sub>1) = dim_col \\<psi>\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col\n     (Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n      Tensor.mat_of_cols_list 2\n       (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n    dim_col \\<psi>\\<^sub>1", "by (simp add: mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_col\n   (Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n    Tensor.mat_of_cols_list 2\n     (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])) =\n  dim_col \\<psi>\\<^sub>1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<psi>\\<^sub>1_is_state: \n  shows \"state 2 \\<psi>\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state 2 \\<psi>\\<^sub>1", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. dim_col \\<psi>\\<^sub>1 = 1\n 2. dim_row \\<psi>\\<^sub>1 = 2\\<^sup>2\n 3. \\<parallel>Matrix.col \\<psi>\\<^sub>1 0\\<parallel> = 1", "show  \"dim_col \\<psi>\\<^sub>1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col \\<psi>\\<^sub>1 = 1", "by (simp add: Tensor.mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_col \\<psi>\\<^sub>1 = 1\n\ngoal (2 subgoals):\n 1. dim_row \\<psi>\\<^sub>1 = 2\\<^sup>2\n 2. \\<parallel>Matrix.col \\<psi>\\<^sub>1 0\\<parallel> = 1", "show \"dim_row \\<psi>\\<^sub>1 = 2\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row \\<psi>\\<^sub>1 = 2\\<^sup>2", "by (simp add: Tensor.mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_row \\<psi>\\<^sub>1 = 2\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>Matrix.col \\<psi>\\<^sub>1 0\\<parallel> = 1", "show \"\\<parallel>Matrix.col \\<psi>\\<^sub>1 0\\<parallel> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>Matrix.col \\<psi>\\<^sub>1 0\\<parallel> = 1", "using H_on_ket_one_is_state H_on_ket_zero_is_state state.is_normal tensor_state2 \\<psi>\\<^sub>0_to_\\<psi>\\<^sub>1\n    H_on_ket_one H_on_ket_zero"], ["proof (prove)\nusing this:\n  state 1 (H * |Deutsch.one\\<rangle>)\n  state 1 (H * |Deutsch.zero\\<rangle>)\n  state ?n ?v \\<Longrightarrow> \\<parallel>Matrix.col ?v 0\\<parallel> = 1\n  \\<lbrakk>state 1 ?u; state 1 ?v\\<rbrakk>\n  \\<Longrightarrow> state 2 (?u \\<Otimes> ?v)\n  Tensor.mat_of_cols_list 2\n   (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n  Tensor.mat_of_cols_list 2\n   (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]) =\n  \\<psi>\\<^sub>1\n  H * |Deutsch.one\\<rangle> =\n  Tensor.mat_of_cols_list 2\n   (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])\n  H * |Deutsch.zero\\<rangle> =\n  Tensor.mat_of_cols_list 2\n   (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]])\n\ngoal (1 subgoal):\n 1. \\<parallel>Matrix.col \\<psi>\\<^sub>1 0\\<parallel> = 1", "by force"], ["proof (state)\nthis:\n  \\<parallel>Matrix.col \\<psi>\\<^sub>1 0\\<parallel> = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nNext, the gate @{text U\\<^sub>f} is applied to the state \n@{text \\<psi>\\<^sub>1} = $\\dfrac {(|00\\rangle - |01\\rangle + |10\\rangle - |11\\rangle)} {2}$ and \n@{text \\<psi>\\<^sub>2}= $\\dfrac {(|0f(0)\\oplus 0\\rangle - |0 f(0) \\oplus 1\\rangle + |1 f(1)\\oplus 0\\rangle - |1f(1)\\oplus 1\\rangle)} {2}$ \nis obtained. This simplifies to \n@{text \\<psi>\\<^sub>2}= $\\dfrac {(|0f(0)\\rangle - |0 \\overline{f(0)} \\rangle + |1 f(1)\\rangle - |1\\overline{f(1)}\\rangle)} {2}$ \n\\<close>"], ["", "abbreviation (in deutsch) \\<psi>\\<^sub>2:: \"complex Matrix.mat\" where\n\"\\<psi>\\<^sub>2 \\<equiv>  mat_of_cols_list 4 [[(1 - f(0))/2 - f(0)/2,\n                            f(0)/2 - (1 - f(0))/2,\n                            (1 - f(1))/2 - f(1)/2,\n                            f(1)/2 - (1- f(1))/2]]\""], ["", "lemma (in deutsch) \\<psi>\\<^sub>1_to_\\<psi>\\<^sub>2: \n  shows \"U\\<^sub>f * \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U\\<^sub>f * \\<psi>\\<^sub>1 =\n    Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / 2 - real (f 0) / 2,\n         real (f 0) / 2 - real (1 - f 0) / 2,\n         real (1 - f 1) / 2 - real (f 1) / 2,\n         real (f 1) / 2 - real (1 - f 1) / 2]])", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 4\n                       (map (map complex_of_real)\n                         [[real (1 - f 0) / 2 - real (f 0) / 2,\n                           real (f 0) / 2 - real (1 - f 0) / 2,\n                           real (1 - f 1) / 2 - real (f 1) / 2,\n                           real (f 1) / 2 - real (1 - f 1) / 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 4\n               (map (map complex_of_real)\n                 [[real (1 - f 0) / 2 - real (f 0) / 2,\n                   real (f 0) / 2 - real (1 - f 0) / 2,\n                   real (1 - f 1) / 2 - real (f 1) / 2,\n                   real (f 1) / 2 - real (1 - f 1) / 2]]))\\<rbrakk>\n       \\<Longrightarrow> (U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) =\n                         Tensor.mat_of_cols_list 4\n                          (map (map complex_of_real)\n                            [[real (1 - f 0) / 2 - real (f 0) / 2,\n                              real (f 0) / 2 - real (1 - f 0) / 2,\n                              real (1 - f 1) / 2 - real (f 1) / 2,\n                              real (f 1) / 2 - real (1 - f 1) / 2]]) $$\n                         (i, j)\n 2. dim_row (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))\n 3. dim_col (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))", "fix i j:: nat"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 4\n                       (map (map complex_of_real)\n                         [[real (1 - f 0) / 2 - real (f 0) / 2,\n                           real (f 0) / 2 - real (1 - f 0) / 2,\n                           real (1 - f 1) / 2 - real (f 1) / 2,\n                           real (f 1) / 2 - real (1 - f 1) / 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 4\n               (map (map complex_of_real)\n                 [[real (1 - f 0) / 2 - real (f 0) / 2,\n                   real (f 0) / 2 - real (1 - f 0) / 2,\n                   real (1 - f 1) / 2 - real (f 1) / 2,\n                   real (f 1) / 2 - real (1 - f 1) / 2]]))\\<rbrakk>\n       \\<Longrightarrow> (U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) =\n                         Tensor.mat_of_cols_list 4\n                          (map (map complex_of_real)\n                            [[real (1 - f 0) / 2 - real (f 0) / 2,\n                              real (f 0) / 2 - real (1 - f 0) / 2,\n                              real (1 - f 1) / 2 - real (f 1) / 2,\n                              real (f 1) / 2 - real (1 - f 1) / 2]]) $$\n                         (i, j)\n 2. dim_row (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))\n 3. dim_col (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))", "assume \"i < dim_row \\<psi>\\<^sub>2 \" and \"j < dim_col \\<psi>\\<^sub>2\""], ["proof (state)\nthis:\n  i < dim_row\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / 2 - real (f 0) / 2,\n             real (f 0) / 2 - real (1 - f 0) / 2,\n             real (1 - f 1) / 2 - real (f 1) / 2,\n             real (f 1) / 2 - real (1 - f 1) / 2]]))\n  j < dim_col\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / 2 - real (f 0) / 2,\n             real (f 0) / 2 - real (1 - f 0) / 2,\n             real (1 - f 1) / 2 - real (f 1) / 2,\n             real (f 1) / 2 - real (1 - f 1) / 2]]))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 4\n                       (map (map complex_of_real)\n                         [[real (1 - f 0) / 2 - real (f 0) / 2,\n                           real (f 0) / 2 - real (1 - f 0) / 2,\n                           real (1 - f 1) / 2 - real (f 1) / 2,\n                           real (f 1) / 2 - real (1 - f 1) / 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 4\n               (map (map complex_of_real)\n                 [[real (1 - f 0) / 2 - real (f 0) / 2,\n                   real (f 0) / 2 - real (1 - f 0) / 2,\n                   real (1 - f 1) / 2 - real (f 1) / 2,\n                   real (f 1) / 2 - real (1 - f 1) / 2]]))\\<rbrakk>\n       \\<Longrightarrow> (U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) =\n                         Tensor.mat_of_cols_list 4\n                          (map (map complex_of_real)\n                            [[real (1 - f 0) / 2 - real (f 0) / 2,\n                              real (f 0) / 2 - real (1 - f 0) / 2,\n                              real (1 - f 1) / 2 - real (f 1) / 2,\n                              real (f 1) / 2 - real (1 - f 1) / 2]]) $$\n                         (i, j)\n 2. dim_row (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))\n 3. dim_col (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))", "then"], ["proof (chain)\npicking this:\n  i < dim_row\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / 2 - real (f 0) / 2,\n             real (f 0) / 2 - real (1 - f 0) / 2,\n             real (1 - f 1) / 2 - real (f 1) / 2,\n             real (f 1) / 2 - real (1 - f 1) / 2]]))\n  j < dim_col\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / 2 - real (f 0) / 2,\n             real (f 0) / 2 - real (1 - f 0) / 2,\n             real (1 - f 1) / 2 - real (f 1) / 2,\n             real (f 1) / 2 - real (1 - f 1) / 2]]))", "have asm:\"i \\<in> {0,1,2,3} \\<and> j = 0 \""], ["proof (prove)\nusing this:\n  i < dim_row\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / 2 - real (f 0) / 2,\n             real (f 0) / 2 - real (1 - f 0) / 2,\n             real (1 - f 1) / 2 - real (f 1) / 2,\n             real (f 1) / 2 - real (1 - f 1) / 2]]))\n  j < dim_col\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / 2 - real (f 0) / 2,\n             real (f 0) / 2 - real (1 - f 0) / 2,\n             real (1 - f 1) / 2 - real (f 1) / 2,\n             real (f 1) / 2 - real (1 - f 1) / 2]]))\n\ngoal (1 subgoal):\n 1. i \\<in> {0, 1, 2, 3} \\<and> j = 0", "by (auto simp add: mat_of_cols_list_def)"], ["proof (state)\nthis:\n  i \\<in> {0, 1, 2, 3} \\<and> j = 0\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 4\n                       (map (map complex_of_real)\n                         [[real (1 - f 0) / 2 - real (f 0) / 2,\n                           real (f 0) / 2 - real (1 - f 0) / 2,\n                           real (1 - f 1) / 2 - real (f 1) / 2,\n                           real (f 1) / 2 - real (1 - f 1) / 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 4\n               (map (map complex_of_real)\n                 [[real (1 - f 0) / 2 - real (f 0) / 2,\n                   real (f 0) / 2 - real (1 - f 0) / 2,\n                   real (1 - f 1) / 2 - real (f 1) / 2,\n                   real (f 1) / 2 - real (1 - f 1) / 2]]))\\<rbrakk>\n       \\<Longrightarrow> (U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) =\n                         Tensor.mat_of_cols_list 4\n                          (map (map complex_of_real)\n                            [[real (1 - f 0) / 2 - real (f 0) / 2,\n                              real (f 0) / 2 - real (1 - f 0) / 2,\n                              real (1 - f 1) / 2 - real (f 1) / 2,\n                              real (f 1) / 2 - real (1 - f 1) / 2]]) $$\n                         (i, j)\n 2. dim_row (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))\n 3. dim_col (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))", "then"], ["proof (chain)\npicking this:\n  i \\<in> {0, 1, 2, 3} \\<and> j = 0", "have \"i < dim_row U\\<^sub>f \\<and> j < dim_col \\<psi>\\<^sub>1\""], ["proof (prove)\nusing this:\n  i \\<in> {0, 1, 2, 3} \\<and> j = 0\n\ngoal (1 subgoal):\n 1. i < dim_row U\\<^sub>f \\<and> j < dim_col \\<psi>\\<^sub>1", "using deutsch_transform_def mat_of_cols_list_def"], ["proof (prove)\nusing this:\n  i \\<in> {0, 1, 2, 3} \\<and> j = 0\n  U\\<^sub>f \\<equiv>\n  Tensor.mat_of_cols_list 4\n   (map (map of_nat)\n     [[1 - f 0, f 0, 0, 0], [f 0, 1 - f 0, 0, 0], [0, 0, 1 - f 1, f 1],\n      [0, 0, f 1, 1 - f 1]])\n  Tensor.mat_of_cols_list ?nr ?cs =\n  Matrix.mat ?nr (length ?cs) (\\<lambda>(i, j). ?cs ! j ! i)\n\ngoal (1 subgoal):\n 1. i < dim_row U\\<^sub>f \\<and> j < dim_col \\<psi>\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  i < dim_row U\\<^sub>f \\<and> j < dim_col \\<psi>\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 4\n                       (map (map complex_of_real)\n                         [[real (1 - f 0) / 2 - real (f 0) / 2,\n                           real (f 0) / 2 - real (1 - f 0) / 2,\n                           real (1 - f 1) / 2 - real (f 1) / 2,\n                           real (f 1) / 2 - real (1 - f 1) / 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 4\n               (map (map complex_of_real)\n                 [[real (1 - f 0) / 2 - real (f 0) / 2,\n                   real (f 0) / 2 - real (1 - f 0) / 2,\n                   real (1 - f 1) / 2 - real (f 1) / 2,\n                   real (f 1) / 2 - real (1 - f 1) / 2]]))\\<rbrakk>\n       \\<Longrightarrow> (U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) =\n                         Tensor.mat_of_cols_list 4\n                          (map (map complex_of_real)\n                            [[real (1 - f 0) / 2 - real (f 0) / 2,\n                              real (f 0) / 2 - real (1 - f 0) / 2,\n                              real (1 - f 1) / 2 - real (f 1) / 2,\n                              real (f 1) / 2 - real (1 - f 1) / 2]]) $$\n                         (i, j)\n 2. dim_row (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))\n 3. dim_col (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))", "then"], ["proof (chain)\npicking this:\n  i < dim_row U\\<^sub>f \\<and> j < dim_col \\<psi>\\<^sub>1", "have \"(U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) \n        = (\\<Sum> k \\<in> {0 ..< dim_vec \\<psi>\\<^sub>1}. (Matrix.row U\\<^sub>f i) $ k * (Matrix.col \\<psi>\\<^sub>1 j) $ k)\""], ["proof (prove)\nusing this:\n  i < dim_row U\\<^sub>f \\<and> j < dim_col \\<psi>\\<^sub>1\n\ngoal (1 subgoal):\n 1. (U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) =\n    (\\<Sum>k = 0..<dim_vec (col_fst \\<psi>\\<^sub>1).\n        Matrix.row U\\<^sub>f i $ k * Matrix.col \\<psi>\\<^sub>1 j $ k)", "apply (auto simp add: times_mat_def scalar_prod_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\nthis:\n  (U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) =\n  (\\<Sum>k = 0..<dim_vec (col_fst \\<psi>\\<^sub>1).\n      Matrix.row U\\<^sub>f i $ k * Matrix.col \\<psi>\\<^sub>1 j $ k)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 4\n                       (map (map complex_of_real)\n                         [[real (1 - f 0) / 2 - real (f 0) / 2,\n                           real (f 0) / 2 - real (1 - f 0) / 2,\n                           real (1 - f 1) / 2 - real (f 1) / 2,\n                           real (f 1) / 2 - real (1 - f 1) / 2]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 4\n               (map (map complex_of_real)\n                 [[real (1 - f 0) / 2 - real (f 0) / 2,\n                   real (f 0) / 2 - real (1 - f 0) / 2,\n                   real (1 - f 1) / 2 - real (f 1) / 2,\n                   real (f 1) / 2 - real (1 - f 1) / 2]]))\\<rbrakk>\n       \\<Longrightarrow> (U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) =\n                         Tensor.mat_of_cols_list 4\n                          (map (map complex_of_real)\n                            [[real (1 - f 0) / 2 - real (f 0) / 2,\n                              real (f 0) / 2 - real (1 - f 0) / 2,\n                              real (1 - f 1) / 2 - real (f 1) / 2,\n                              real (f 1) / 2 - real (1 - f 1) / 2]]) $$\n                         (i, j)\n 2. dim_row (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))\n 3. dim_col (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))", "thus \"(U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) = \\<psi>\\<^sub>2 $$ (i, j)\""], ["proof (prove)\nusing this:\n  (U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) =\n  (\\<Sum>k = 0..<dim_vec (col_fst \\<psi>\\<^sub>1).\n      Matrix.row U\\<^sub>f i $ k * Matrix.col \\<psi>\\<^sub>1 j $ k)\n\ngoal (1 subgoal):\n 1. (U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) =\n    Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / 2 - real (f 0) / 2,\n         real (f 0) / 2 - real (1 - f 0) / 2,\n         real (1 - f 1) / 2 - real (f 1) / 2,\n         real (f 1) / 2 - real (1 - f 1) / 2]]) $$\n    (i, j)", "using  mat_of_cols_list_def deutsch_transform_def asm"], ["proof (prove)\nusing this:\n  (U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) =\n  (\\<Sum>k = 0..<dim_vec (col_fst \\<psi>\\<^sub>1).\n      Matrix.row U\\<^sub>f i $ k * Matrix.col \\<psi>\\<^sub>1 j $ k)\n  Tensor.mat_of_cols_list ?nr ?cs =\n  Matrix.mat ?nr (length ?cs) (\\<lambda>(i, j). ?cs ! j ! i)\n  U\\<^sub>f \\<equiv>\n  Tensor.mat_of_cols_list 4\n   (map (map of_nat)\n     [[1 - f 0, f 0, 0, 0], [f 0, 1 - f 0, 0, 0], [0, 0, 1 - f 1, f 1],\n      [0, 0, f 1, 1 - f 1]])\n  i \\<in> {0, 1, 2, 3} \\<and> j = 0\n\ngoal (1 subgoal):\n 1. (U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) =\n    Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / 2 - real (f 0) / 2,\n         real (f 0) / 2 - real (1 - f 0) / 2,\n         real (1 - f 1) / 2 - real (f 1) / 2,\n         real (f 1) / 2 - real (1 - f 1) / 2]]) $$\n    (i, j)", "by auto"], ["proof (state)\nthis:\n  (U\\<^sub>f * \\<psi>\\<^sub>1) $$ (i, j) =\n  Tensor.mat_of_cols_list 4\n   (map (map complex_of_real)\n     [[real (1 - f 0) / 2 - real (f 0) / 2,\n       real (f 0) / 2 - real (1 - f 0) / 2,\n       real (1 - f 1) / 2 - real (f 1) / 2,\n       real (f 1) / 2 - real (1 - f 1) / 2]]) $$\n  (i, j)\n\ngoal (2 subgoals):\n 1. dim_row (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))\n 2. dim_col (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. dim_row (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))\n 2. dim_col (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))", "show \"dim_row (U\\<^sub>f * \\<psi>\\<^sub>1) = dim_row \\<psi>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))", "by (simp add: mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_row (U\\<^sub>f * \\<psi>\\<^sub>1) =\n  dim_row\n   (Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / 2 - real (f 0) / 2,\n         real (f 0) / 2 - real (1 - f 0) / 2,\n         real (1 - f 1) / 2 - real (f 1) / 2,\n         real (f 1) / 2 - real (1 - f 1) / 2]]))\n\ngoal (1 subgoal):\n 1. dim_col (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))", "show \"dim_col (U\\<^sub>f * \\<psi>\\<^sub>1) = dim_col \\<psi>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (U\\<^sub>f * \\<psi>\\<^sub>1) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))", "by (simp add: mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_col (U\\<^sub>f * \\<psi>\\<^sub>1) =\n  dim_col\n   (Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / 2 - real (f 0) / 2,\n         real (f 0) / 2 - real (1 - f 0) / 2,\n         real (1 - f 1) / 2 - real (f 1) / 2,\n         real (f 1) / 2 - real (1 - f 1) / 2]]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in deutsch) \\<psi>\\<^sub>2_is_state:\n  shows \"state 2 \\<psi>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state 2\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]]))", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    1\n 2. dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    2\\<^sup>2\n 3. \\<parallel>Matrix.col\n                (Tensor.mat_of_cols_list 4\n                  (map (map complex_of_real)\n                    [[real (1 - f 0) / 2 - real (f 0) / 2,\n                      real (f 0) / 2 - real (1 - f 0) / 2,\n                      real (1 - f 1) / 2 - real (f 1) / 2,\n                      real (f 1) / 2 - real (1 - f 1) / 2]]))\n                0\\<parallel> =\n    1", "show  \"dim_col \\<psi>\\<^sub>2 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    1", "by (simp add: Tensor.mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_col\n   (Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / 2 - real (f 0) / 2,\n         real (f 0) / 2 - real (1 - f 0) / 2,\n         real (1 - f 1) / 2 - real (f 1) / 2,\n         real (f 1) / 2 - real (1 - f 1) / 2]])) =\n  1\n\ngoal (2 subgoals):\n 1. dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    2\\<^sup>2\n 2. \\<parallel>Matrix.col\n                (Tensor.mat_of_cols_list 4\n                  (map (map complex_of_real)\n                    [[real (1 - f 0) / 2 - real (f 0) / 2,\n                      real (f 0) / 2 - real (1 - f 0) / 2,\n                      real (1 - f 1) / 2 - real (f 1) / 2,\n                      real (f 1) / 2 - real (1 - f 1) / 2]]))\n                0\\<parallel> =\n    1", "show \"dim_row \\<psi>\\<^sub>2 = 2\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    2\\<^sup>2", "by (simp add: Tensor.mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_row\n   (Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / 2 - real (f 0) / 2,\n         real (f 0) / 2 - real (1 - f 0) / 2,\n         real (1 - f 1) / 2 - real (f 1) / 2,\n         real (f 1) / 2 - real (1 - f 1) / 2]])) =\n  2\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>Matrix.col\n                (Tensor.mat_of_cols_list 4\n                  (map (map complex_of_real)\n                    [[real (1 - f 0) / 2 - real (f 0) / 2,\n                      real (f 0) / 2 - real (1 - f 0) / 2,\n                      real (1 - f 1) / 2 - real (f 1) / 2,\n                      real (f 1) / 2 - real (1 - f 1) / 2]]))\n                0\\<parallel> =\n    1", "show \"\\<parallel>Matrix.col \\<psi>\\<^sub>2 0\\<parallel> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>Matrix.col\n                (Tensor.mat_of_cols_list 4\n                  (map (map complex_of_real)\n                    [[real (1 - f 0) / 2 - real (f 0) / 2,\n                      real (f 0) / 2 - real (1 - f 0) / 2,\n                      real (1 - f 1) / 2 - real (f 1) / 2,\n                      real (f 1) / 2 - real (1 - f 1) / 2]]))\n                0\\<parallel> =\n    1", "using gate_on_state_is_state \\<psi>\\<^sub>1_is_state deutsch_transform_is_gate \\<psi>\\<^sub>1_to_\\<psi>\\<^sub>2 state_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>gate ?n ?A; state ?n ?v\\<rbrakk>\n  \\<Longrightarrow> state ?n (?A * ?v)\n  state 2 \\<psi>\\<^sub>1\n  gate 2 U\\<^sub>f\n  U\\<^sub>f * \\<psi>\\<^sub>1 =\n  Tensor.mat_of_cols_list 4\n   (map (map complex_of_real)\n     [[real (1 - f 0) / 2 - real (f 0) / 2,\n       real (f 0) / 2 - real (1 - f 0) / 2,\n       real (1 - f 1) / 2 - real (f 1) / 2,\n       real (f 1) / 2 - real (1 - f 1) / 2]])\n  state ?n ?v \\<equiv>\n  dim_col ?v = 1 \\<and>\n  dim_row ?v = 2 ^ ?n \\<and> \\<parallel>Matrix.col ?v 0\\<parallel> = 1\n\ngoal (1 subgoal):\n 1. \\<parallel>Matrix.col\n                (Tensor.mat_of_cols_list 4\n                  (map (map complex_of_real)\n                    [[real (1 - f 0) / 2 - real (f 0) / 2,\n                      real (f 0) / 2 - real (1 - f 0) / 2,\n                      real (1 - f 1) / 2 - real (f 1) / 2,\n                      real (f 1) / 2 - real (1 - f 1) / 2]]))\n                0\\<parallel> =\n    1", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  \\<parallel>Matrix.col\n              (Tensor.mat_of_cols_list 4\n                (map (map complex_of_real)\n                  [[real (1 - f 0) / 2 - real (f 0) / 2,\n                    real (f 0) / 2 - real (1 - f 0) / 2,\n                    real (1 - f 1) / 2 - real (f 1) / 2,\n                    real (f 1) / 2 - real (1 - f 1) / 2]]))\n              0\\<parallel> =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma H_tensor_Id_1: \n  defines d:\"v \\<equiv>  mat_of_cols_list 4 [[1/sqrt(2), 0, 1/sqrt(2), 0],\n                                  [0, 1/sqrt(2), 0, 1/sqrt(2)],\n                                  [1/sqrt(2), 0, -1/sqrt(2), 0],\n                                  [0, 1/sqrt(2), 0, -1/sqrt(2)]]\"\n  shows \"(H \\<Otimes> Id 1) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<Otimes> Quantum.Id 1 = v", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row v; j < dim_col v\\<rbrakk>\n       \\<Longrightarrow> (H \\<Otimes> Quantum.Id 1) $$ (i, j) = v $$ (i, j)\n 2. dim_row (H \\<Otimes> Quantum.Id 1) = dim_row v\n 3. dim_col (H \\<Otimes> Quantum.Id 1) = dim_col v", "show \"dim_col (H \\<Otimes> Id 1) = dim_col v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (H \\<Otimes> Quantum.Id 1) = dim_col v", "by (simp add: d H_def Id_def mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_col (H \\<Otimes> Quantum.Id 1) = dim_col v\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row v; j < dim_col v\\<rbrakk>\n       \\<Longrightarrow> (H \\<Otimes> Quantum.Id 1) $$ (i, j) = v $$ (i, j)\n 2. dim_row (H \\<Otimes> Quantum.Id 1) = dim_row v", "show \"dim_row (H \\<Otimes> Id 1) = dim_row v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (H \\<Otimes> Quantum.Id 1) = dim_row v", "by (simp add: d H_def Id_def mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_row (H \\<Otimes> Quantum.Id 1) = dim_row v\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row v; j < dim_col v\\<rbrakk>\n       \\<Longrightarrow> (H \\<Otimes> Quantum.Id 1) $$ (i, j) = v $$ (i, j)", "fix i j:: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row v; j < dim_col v\\<rbrakk>\n       \\<Longrightarrow> (H \\<Otimes> Quantum.Id 1) $$ (i, j) = v $$ (i, j)", "assume \"i < dim_row v\" and \"j < dim_col v\""], ["proof (state)\nthis:\n  i < dim_row v\n  j < dim_col v\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row v; j < dim_col v\\<rbrakk>\n       \\<Longrightarrow> (H \\<Otimes> Quantum.Id 1) $$ (i, j) = v $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  i < dim_row v\n  j < dim_col v", "have \"i \\<in> {0..<4} \\<and> j \\<in> {0..<4}\""], ["proof (prove)\nusing this:\n  i < dim_row v\n  j < dim_col v\n\ngoal (1 subgoal):\n 1. i \\<in> {0..<4} \\<and> j \\<in> {0..<4}", "by (auto simp add: d mat_of_cols_list_def)"], ["proof (state)\nthis:\n  i \\<in> {0..<4} \\<and> j \\<in> {0..<4}\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row v; j < dim_col v\\<rbrakk>\n       \\<Longrightarrow> (H \\<Otimes> Quantum.Id 1) $$ (i, j) = v $$ (i, j)", "thus \"(H \\<Otimes> Id 1) $$ (i, j) = v $$ (i, j)\""], ["proof (prove)\nusing this:\n  i \\<in> {0..<4} \\<and> j \\<in> {0..<4}\n\ngoal (1 subgoal):\n 1. (H \\<Otimes> Quantum.Id 1) $$ (i, j) = v $$ (i, j)", "by (auto simp add: d Id_def H_def mat_of_cols_list_def)"], ["proof (state)\nthis:\n  (H \\<Otimes> Quantum.Id 1) $$ (i, j) = v $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma H_tensor_Id_1_is_gate: \n  shows \"gate 2 (H \\<Otimes> Id 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gate 2 (H \\<Otimes> Quantum.Id 1)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. dim_row (H \\<Otimes> Quantum.Id 1) = 2\\<^sup>2\n 2. square_mat (H \\<Otimes> Quantum.Id 1)\n 3. unitary (H \\<Otimes> Quantum.Id 1)", "show \"dim_row (H \\<Otimes> Quantum.Id 1) = 2\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (H \\<Otimes> Quantum.Id 1) = 2\\<^sup>2", "using H_tensor_Id_1"], ["proof (prove)\nusing this:\n  H \\<Otimes> Quantum.Id 1 =\n  Tensor.mat_of_cols_list 4\n   (map (map complex_of_real)\n     [[1 / sqrt 2, 0, 1 / sqrt 2, 0], [0, 1 / sqrt 2, 0, 1 / sqrt 2],\n      [1 / sqrt 2, 0, - 1 / sqrt 2, 0], [0, 1 / sqrt 2, 0, - 1 / sqrt 2]])\n\ngoal (1 subgoal):\n 1. dim_row (H \\<Otimes> Quantum.Id 1) = 2\\<^sup>2", "by (simp add: mat_of_cols_list_def)"], ["proof (state)\nthis:\n  dim_row (H \\<Otimes> Quantum.Id 1) = 2\\<^sup>2\n\ngoal (2 subgoals):\n 1. square_mat (H \\<Otimes> Quantum.Id 1)\n 2. unitary (H \\<Otimes> Quantum.Id 1)", "show \"square_mat (H \\<Otimes> Quantum.Id 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_mat (H \\<Otimes> Quantum.Id 1)", "using H_is_gate id_is_gate tensor_gate_sqr_mat"], ["proof (prove)\nusing this:\n  gate 1 H\n  gate ?n (Quantum.Id ?n)\n  \\<lbrakk>gate ?m ?G1.0; gate ?n ?G2.0\\<rbrakk>\n  \\<Longrightarrow> square_mat (?G1.0 \\<Otimes> ?G2.0)\n\ngoal (1 subgoal):\n 1. square_mat (H \\<Otimes> Quantum.Id 1)", "by blast"], ["proof (state)\nthis:\n  square_mat (H \\<Otimes> Quantum.Id 1)\n\ngoal (1 subgoal):\n 1. unitary (H \\<Otimes> Quantum.Id 1)", "show \"unitary (H \\<Otimes> Quantum.Id 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (H \\<Otimes> Quantum.Id 1)", "using H_is_gate gate_def id_is_gate tensor_gate"], ["proof (prove)\nusing this:\n  gate 1 H\n  gate ?n ?A \\<equiv>\n  dim_row ?A = 2 ^ ?n \\<and> square_mat ?A \\<and> unitary ?A\n  gate ?n (Quantum.Id ?n)\n  \\<lbrakk>gate ?m ?G1.0; gate ?n ?G2.0\\<rbrakk>\n  \\<Longrightarrow> gate (?m + ?n) (?G1.0 \\<Otimes> ?G2.0)\n\ngoal (1 subgoal):\n 1. unitary (H \\<Otimes> Quantum.Id 1)", "by blast"], ["proof (state)\nthis:\n  unitary (H \\<Otimes> Quantum.Id 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nApplying the Hadamard gate to the first qubit of @{text \\<psi>\\<^sub>2} results in @{text \\<psi>\\<^sub>3} = \n$\\pm |f(0)\\oplus f(1)\\rangle \\left[ \\dfrac {(|0\\rangle - |1\\rangle)} {\\sqrt 2}\\right]$ \n\\<close>"], ["", "abbreviation (in deutsch) \\<psi>\\<^sub>3:: \"complex Matrix.mat\" where\n\"\\<psi>\\<^sub>3 \\<equiv> mat_of_cols_list 4 \n[[(1-f(0))/(2*sqrt(2)) - f(0)/(2*sqrt(2)) + (1-f(1))/(2*sqrt(2)) - f(1)/(2*sqrt(2)),\n  f(0)/(2*sqrt(2)) - (1-f(0))/(2*sqrt(2)) + (f(1)/(2*sqrt(2)) - (1-f(1))/(2*sqrt(2))),\n  (1-f(0))/(2*sqrt(2)) - f(0)/(2*sqrt(2)) - (1-f(1))/(2*sqrt(2)) + f(1)/(2*sqrt(2)),\n  f(0)/(2*sqrt(2)) - (1-f(0))/(2*sqrt(2)) - f(1)/(2*sqrt(2)) + (1-f(1))/(2*sqrt(2))]]\""], ["", "lemma (in deutsch) \\<psi>\\<^sub>2_to_\\<psi>\\<^sub>3: \n shows \"(H \\<Otimes> Id 1) * \\<psi>\\<^sub>2 = \\<psi>\\<^sub>3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (H \\<Otimes> Quantum.Id 1) *\n    Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / 2 - real (f 0) / 2,\n         real (f 0) / 2 - real (1 - f 0) / 2,\n         real (1 - f 1) / 2 - real (f 1) / 2,\n         real (f 1) / 2 - real (1 - f 1) / 2]]) =\n    Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n         (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n         real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n         real (1 - f 1) / (2 * sqrt 2) +\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2)]])", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 4\n                       (map (map complex_of_real)\n                         [[real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 0) / (2 * sqrt 2) +\n                           real (1 - f 1) / (2 * sqrt 2) -\n                           real (f 1) / (2 * sqrt 2),\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 0) / (2 * sqrt 2) +\n                           (real (f 1) / (2 * sqrt 2) -\n                            real (1 - f 1) / (2 * sqrt 2)),\n                           real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 1) / (2 * sqrt 2) +\n                           real (f 1) / (2 * sqrt 2),\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 1) / (2 * sqrt 2) +\n                           real (1 - f 1) / (2 * sqrt 2)]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 4\n               (map (map complex_of_real)\n                 [[real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 0) / (2 * sqrt 2) +\n                   real (1 - f 1) / (2 * sqrt 2) -\n                   real (f 1) / (2 * sqrt 2),\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 0) / (2 * sqrt 2) +\n                   (real (f 1) / (2 * sqrt 2) -\n                    real (1 - f 1) / (2 * sqrt 2)),\n                   real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 1) / (2 * sqrt 2) +\n                   real (f 1) / (2 * sqrt 2),\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 1) / (2 * sqrt 2) +\n                   real (1 - f 1) / (2 * sqrt 2)]]))\\<rbrakk>\n       \\<Longrightarrow> ((H \\<Otimes> Quantum.Id 1) *\n                          Tensor.mat_of_cols_list 4\n                           (map (map complex_of_real)\n                             [[real (1 - f 0) / 2 - real (f 0) / 2,\n                               real (f 0) / 2 - real (1 - f 0) / 2,\n                               real (1 - f 1) / 2 - real (f 1) / 2,\n                               real (f 1) / 2 - real (1 - f 1) / 2]])) $$\n                         (i, j) =\n                         Tensor.mat_of_cols_list 4\n                          (map (map complex_of_real)\n                            [[real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 0) / (2 * sqrt 2) +\n                              real (1 - f 1) / (2 * sqrt 2) -\n                              real (f 1) / (2 * sqrt 2),\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 0) / (2 * sqrt 2) +\n                              (real (f 1) / (2 * sqrt 2) -\n                               real (1 - f 1) / (2 * sqrt 2)),\n                              real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 1) / (2 * sqrt 2) +\n                              real (f 1) / (2 * sqrt 2),\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 1) / (2 * sqrt 2) +\n                              real (1 - f 1) / (2 * sqrt 2)]]) $$\n                         (i, j)\n 2. dim_row\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))\n 3. dim_col\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "fix i j:: nat"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 4\n                       (map (map complex_of_real)\n                         [[real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 0) / (2 * sqrt 2) +\n                           real (1 - f 1) / (2 * sqrt 2) -\n                           real (f 1) / (2 * sqrt 2),\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 0) / (2 * sqrt 2) +\n                           (real (f 1) / (2 * sqrt 2) -\n                            real (1 - f 1) / (2 * sqrt 2)),\n                           real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 1) / (2 * sqrt 2) +\n                           real (f 1) / (2 * sqrt 2),\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 1) / (2 * sqrt 2) +\n                           real (1 - f 1) / (2 * sqrt 2)]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 4\n               (map (map complex_of_real)\n                 [[real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 0) / (2 * sqrt 2) +\n                   real (1 - f 1) / (2 * sqrt 2) -\n                   real (f 1) / (2 * sqrt 2),\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 0) / (2 * sqrt 2) +\n                   (real (f 1) / (2 * sqrt 2) -\n                    real (1 - f 1) / (2 * sqrt 2)),\n                   real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 1) / (2 * sqrt 2) +\n                   real (f 1) / (2 * sqrt 2),\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 1) / (2 * sqrt 2) +\n                   real (1 - f 1) / (2 * sqrt 2)]]))\\<rbrakk>\n       \\<Longrightarrow> ((H \\<Otimes> Quantum.Id 1) *\n                          Tensor.mat_of_cols_list 4\n                           (map (map complex_of_real)\n                             [[real (1 - f 0) / 2 - real (f 0) / 2,\n                               real (f 0) / 2 - real (1 - f 0) / 2,\n                               real (1 - f 1) / 2 - real (f 1) / 2,\n                               real (f 1) / 2 - real (1 - f 1) / 2]])) $$\n                         (i, j) =\n                         Tensor.mat_of_cols_list 4\n                          (map (map complex_of_real)\n                            [[real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 0) / (2 * sqrt 2) +\n                              real (1 - f 1) / (2 * sqrt 2) -\n                              real (f 1) / (2 * sqrt 2),\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 0) / (2 * sqrt 2) +\n                              (real (f 1) / (2 * sqrt 2) -\n                               real (1 - f 1) / (2 * sqrt 2)),\n                              real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 1) / (2 * sqrt 2) +\n                              real (f 1) / (2 * sqrt 2),\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 1) / (2 * sqrt 2) +\n                              real (1 - f 1) / (2 * sqrt 2)]]) $$\n                         (i, j)\n 2. dim_row\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))\n 3. dim_col\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "assume \"i < dim_row \\<psi>\\<^sub>3\" and \"j < dim_col \\<psi>\\<^sub>3\""], ["proof (state)\nthis:\n  i < dim_row\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n             real (1 - f 1) / (2 * sqrt 2) -\n             real (f 1) / (2 * sqrt 2),\n             real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n             (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n             real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n             real (1 - f 1) / (2 * sqrt 2) +\n             real (f 1) / (2 * sqrt 2),\n             real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n             real (f 1) / (2 * sqrt 2) +\n             real (1 - f 1) / (2 * sqrt 2)]]))\n  j < dim_col\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n             real (1 - f 1) / (2 * sqrt 2) -\n             real (f 1) / (2 * sqrt 2),\n             real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n             (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n             real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n             real (1 - f 1) / (2 * sqrt 2) +\n             real (f 1) / (2 * sqrt 2),\n             real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n             real (f 1) / (2 * sqrt 2) +\n             real (1 - f 1) / (2 * sqrt 2)]]))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 4\n                       (map (map complex_of_real)\n                         [[real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 0) / (2 * sqrt 2) +\n                           real (1 - f 1) / (2 * sqrt 2) -\n                           real (f 1) / (2 * sqrt 2),\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 0) / (2 * sqrt 2) +\n                           (real (f 1) / (2 * sqrt 2) -\n                            real (1 - f 1) / (2 * sqrt 2)),\n                           real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 1) / (2 * sqrt 2) +\n                           real (f 1) / (2 * sqrt 2),\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 1) / (2 * sqrt 2) +\n                           real (1 - f 1) / (2 * sqrt 2)]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 4\n               (map (map complex_of_real)\n                 [[real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 0) / (2 * sqrt 2) +\n                   real (1 - f 1) / (2 * sqrt 2) -\n                   real (f 1) / (2 * sqrt 2),\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 0) / (2 * sqrt 2) +\n                   (real (f 1) / (2 * sqrt 2) -\n                    real (1 - f 1) / (2 * sqrt 2)),\n                   real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 1) / (2 * sqrt 2) +\n                   real (f 1) / (2 * sqrt 2),\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 1) / (2 * sqrt 2) +\n                   real (1 - f 1) / (2 * sqrt 2)]]))\\<rbrakk>\n       \\<Longrightarrow> ((H \\<Otimes> Quantum.Id 1) *\n                          Tensor.mat_of_cols_list 4\n                           (map (map complex_of_real)\n                             [[real (1 - f 0) / 2 - real (f 0) / 2,\n                               real (f 0) / 2 - real (1 - f 0) / 2,\n                               real (1 - f 1) / 2 - real (f 1) / 2,\n                               real (f 1) / 2 - real (1 - f 1) / 2]])) $$\n                         (i, j) =\n                         Tensor.mat_of_cols_list 4\n                          (map (map complex_of_real)\n                            [[real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 0) / (2 * sqrt 2) +\n                              real (1 - f 1) / (2 * sqrt 2) -\n                              real (f 1) / (2 * sqrt 2),\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 0) / (2 * sqrt 2) +\n                              (real (f 1) / (2 * sqrt 2) -\n                               real (1 - f 1) / (2 * sqrt 2)),\n                              real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 1) / (2 * sqrt 2) +\n                              real (f 1) / (2 * sqrt 2),\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 1) / (2 * sqrt 2) +\n                              real (1 - f 1) / (2 * sqrt 2)]]) $$\n                         (i, j)\n 2. dim_row\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))\n 3. dim_col\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "then"], ["proof (chain)\npicking this:\n  i < dim_row\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n             real (1 - f 1) / (2 * sqrt 2) -\n             real (f 1) / (2 * sqrt 2),\n             real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n             (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n             real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n             real (1 - f 1) / (2 * sqrt 2) +\n             real (f 1) / (2 * sqrt 2),\n             real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n             real (f 1) / (2 * sqrt 2) +\n             real (1 - f 1) / (2 * sqrt 2)]]))\n  j < dim_col\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n             real (1 - f 1) / (2 * sqrt 2) -\n             real (f 1) / (2 * sqrt 2),\n             real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n             (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n             real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n             real (1 - f 1) / (2 * sqrt 2) +\n             real (f 1) / (2 * sqrt 2),\n             real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n             real (f 1) / (2 * sqrt 2) +\n             real (1 - f 1) / (2 * sqrt 2)]]))", "have a0:\"i \\<in> {0,1,2,3} \\<and> j = 0\""], ["proof (prove)\nusing this:\n  i < dim_row\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n             real (1 - f 1) / (2 * sqrt 2) -\n             real (f 1) / (2 * sqrt 2),\n             real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n             (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n             real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n             real (1 - f 1) / (2 * sqrt 2) +\n             real (f 1) / (2 * sqrt 2),\n             real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n             real (f 1) / (2 * sqrt 2) +\n             real (1 - f 1) / (2 * sqrt 2)]]))\n  j < dim_col\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n             real (1 - f 1) / (2 * sqrt 2) -\n             real (f 1) / (2 * sqrt 2),\n             real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n             (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n             real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n             real (1 - f 1) / (2 * sqrt 2) +\n             real (f 1) / (2 * sqrt 2),\n             real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n             real (f 1) / (2 * sqrt 2) +\n             real (1 - f 1) / (2 * sqrt 2)]]))\n\ngoal (1 subgoal):\n 1. i \\<in> {0, 1, 2, 3} \\<and> j = 0", "by (auto simp add: mat_of_cols_list_def)"], ["proof (state)\nthis:\n  i \\<in> {0, 1, 2, 3} \\<and> j = 0\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 4\n                       (map (map complex_of_real)\n                         [[real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 0) / (2 * sqrt 2) +\n                           real (1 - f 1) / (2 * sqrt 2) -\n                           real (f 1) / (2 * sqrt 2),\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 0) / (2 * sqrt 2) +\n                           (real (f 1) / (2 * sqrt 2) -\n                            real (1 - f 1) / (2 * sqrt 2)),\n                           real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 1) / (2 * sqrt 2) +\n                           real (f 1) / (2 * sqrt 2),\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 1) / (2 * sqrt 2) +\n                           real (1 - f 1) / (2 * sqrt 2)]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 4\n               (map (map complex_of_real)\n                 [[real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 0) / (2 * sqrt 2) +\n                   real (1 - f 1) / (2 * sqrt 2) -\n                   real (f 1) / (2 * sqrt 2),\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 0) / (2 * sqrt 2) +\n                   (real (f 1) / (2 * sqrt 2) -\n                    real (1 - f 1) / (2 * sqrt 2)),\n                   real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 1) / (2 * sqrt 2) +\n                   real (f 1) / (2 * sqrt 2),\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 1) / (2 * sqrt 2) +\n                   real (1 - f 1) / (2 * sqrt 2)]]))\\<rbrakk>\n       \\<Longrightarrow> ((H \\<Otimes> Quantum.Id 1) *\n                          Tensor.mat_of_cols_list 4\n                           (map (map complex_of_real)\n                             [[real (1 - f 0) / 2 - real (f 0) / 2,\n                               real (f 0) / 2 - real (1 - f 0) / 2,\n                               real (1 - f 1) / 2 - real (f 1) / 2,\n                               real (f 1) / 2 - real (1 - f 1) / 2]])) $$\n                         (i, j) =\n                         Tensor.mat_of_cols_list 4\n                          (map (map complex_of_real)\n                            [[real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 0) / (2 * sqrt 2) +\n                              real (1 - f 1) / (2 * sqrt 2) -\n                              real (f 1) / (2 * sqrt 2),\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 0) / (2 * sqrt 2) +\n                              (real (f 1) / (2 * sqrt 2) -\n                               real (1 - f 1) / (2 * sqrt 2)),\n                              real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 1) / (2 * sqrt 2) +\n                              real (f 1) / (2 * sqrt 2),\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 1) / (2 * sqrt 2) +\n                              real (1 - f 1) / (2 * sqrt 2)]]) $$\n                         (i, j)\n 2. dim_row\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))\n 3. dim_col\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "then"], ["proof (chain)\npicking this:\n  i \\<in> {0, 1, 2, 3} \\<and> j = 0", "have \"i < dim_row (H \\<Otimes> Id 1) \\<and> j < dim_col \\<psi>\\<^sub>2\""], ["proof (prove)\nusing this:\n  i \\<in> {0, 1, 2, 3} \\<and> j = 0\n\ngoal (1 subgoal):\n 1. i < dim_row (H \\<Otimes> Quantum.Id 1) \\<and>\n    j < dim_col\n         (Tensor.mat_of_cols_list 4\n           (map (map complex_of_real)\n             [[real (1 - f 0) / 2 - real (f 0) / 2,\n               real (f 0) / 2 - real (1 - f 0) / 2,\n               real (1 - f 1) / 2 - real (f 1) / 2,\n               real (f 1) / 2 - real (1 - f 1) / 2]]))", "using mat_of_cols_list_def H_tensor_Id_1"], ["proof (prove)\nusing this:\n  i \\<in> {0, 1, 2, 3} \\<and> j = 0\n  Tensor.mat_of_cols_list ?nr ?cs =\n  Matrix.mat ?nr (length ?cs) (\\<lambda>(i, j). ?cs ! j ! i)\n  H \\<Otimes> Quantum.Id 1 =\n  Tensor.mat_of_cols_list 4\n   (map (map complex_of_real)\n     [[1 / sqrt 2, 0, 1 / sqrt 2, 0], [0, 1 / sqrt 2, 0, 1 / sqrt 2],\n      [1 / sqrt 2, 0, - 1 / sqrt 2, 0], [0, 1 / sqrt 2, 0, - 1 / sqrt 2]])\n\ngoal (1 subgoal):\n 1. i < dim_row (H \\<Otimes> Quantum.Id 1) \\<and>\n    j < dim_col\n         (Tensor.mat_of_cols_list 4\n           (map (map complex_of_real)\n             [[real (1 - f 0) / 2 - real (f 0) / 2,\n               real (f 0) / 2 - real (1 - f 0) / 2,\n               real (1 - f 1) / 2 - real (f 1) / 2,\n               real (f 1) / 2 - real (1 - f 1) / 2]]))", "by auto"], ["proof (state)\nthis:\n  i < dim_row (H \\<Otimes> Quantum.Id 1) \\<and>\n  j < dim_col\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / 2 - real (f 0) / 2,\n             real (f 0) / 2 - real (1 - f 0) / 2,\n             real (1 - f 1) / 2 - real (f 1) / 2,\n             real (f 1) / 2 - real (1 - f 1) / 2]]))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 4\n                       (map (map complex_of_real)\n                         [[real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 0) / (2 * sqrt 2) +\n                           real (1 - f 1) / (2 * sqrt 2) -\n                           real (f 1) / (2 * sqrt 2),\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 0) / (2 * sqrt 2) +\n                           (real (f 1) / (2 * sqrt 2) -\n                            real (1 - f 1) / (2 * sqrt 2)),\n                           real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 1) / (2 * sqrt 2) +\n                           real (f 1) / (2 * sqrt 2),\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 1) / (2 * sqrt 2) +\n                           real (1 - f 1) / (2 * sqrt 2)]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 4\n               (map (map complex_of_real)\n                 [[real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 0) / (2 * sqrt 2) +\n                   real (1 - f 1) / (2 * sqrt 2) -\n                   real (f 1) / (2 * sqrt 2),\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 0) / (2 * sqrt 2) +\n                   (real (f 1) / (2 * sqrt 2) -\n                    real (1 - f 1) / (2 * sqrt 2)),\n                   real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 1) / (2 * sqrt 2) +\n                   real (f 1) / (2 * sqrt 2),\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 1) / (2 * sqrt 2) +\n                   real (1 - f 1) / (2 * sqrt 2)]]))\\<rbrakk>\n       \\<Longrightarrow> ((H \\<Otimes> Quantum.Id 1) *\n                          Tensor.mat_of_cols_list 4\n                           (map (map complex_of_real)\n                             [[real (1 - f 0) / 2 - real (f 0) / 2,\n                               real (f 0) / 2 - real (1 - f 0) / 2,\n                               real (1 - f 1) / 2 - real (f 1) / 2,\n                               real (f 1) / 2 - real (1 - f 1) / 2]])) $$\n                         (i, j) =\n                         Tensor.mat_of_cols_list 4\n                          (map (map complex_of_real)\n                            [[real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 0) / (2 * sqrt 2) +\n                              real (1 - f 1) / (2 * sqrt 2) -\n                              real (f 1) / (2 * sqrt 2),\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 0) / (2 * sqrt 2) +\n                              (real (f 1) / (2 * sqrt 2) -\n                               real (1 - f 1) / (2 * sqrt 2)),\n                              real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 1) / (2 * sqrt 2) +\n                              real (f 1) / (2 * sqrt 2),\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 1) / (2 * sqrt 2) +\n                              real (1 - f 1) / (2 * sqrt 2)]]) $$\n                         (i, j)\n 2. dim_row\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))\n 3. dim_col\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "then"], ["proof (chain)\npicking this:\n  i < dim_row (H \\<Otimes> Quantum.Id 1) \\<and>\n  j < dim_col\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / 2 - real (f 0) / 2,\n             real (f 0) / 2 - real (1 - f 0) / 2,\n             real (1 - f 1) / 2 - real (f 1) / 2,\n             real (f 1) / 2 - real (1 - f 1) / 2]]))", "have \"((H \\<Otimes> Id 1)*\\<psi>\\<^sub>2) $$ (i,j)\n        = (\\<Sum> k \\<in> {0 ..< dim_vec \\<psi>\\<^sub>2}. (Matrix.row (H \\<Otimes> Id 1) i) $ k * (Matrix.col \\<psi>\\<^sub>2 j) $ k)\""], ["proof (prove)\nusing this:\n  i < dim_row (H \\<Otimes> Quantum.Id 1) \\<and>\n  j < dim_col\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / 2 - real (f 0) / 2,\n             real (f 0) / 2 - real (1 - f 0) / 2,\n             real (1 - f 1) / 2 - real (f 1) / 2,\n             real (f 1) / 2 - real (1 - f 1) / 2]]))\n\ngoal (1 subgoal):\n 1. ((H \\<Otimes> Quantum.Id 1) *\n     Tensor.mat_of_cols_list 4\n      (map (map complex_of_real)\n        [[real (1 - f 0) / 2 - real (f 0) / 2,\n          real (f 0) / 2 - real (1 - f 0) / 2,\n          real (1 - f 1) / 2 - real (f 1) / 2,\n          real (f 1) / 2 - real (1 - f 1) / 2]])) $$\n    (i, j) =\n    (\\<Sum>k = 0..<dim_vec\n                    (col_fst\n                      (Tensor.mat_of_cols_list 4\n                        (map (map complex_of_real)\n                          [[real (1 - f 0) / 2 - real (f 0) / 2,\n                            real (f 0) / 2 - real (1 - f 0) / 2,\n                            real (1 - f 1) / 2 - real (f 1) / 2,\n                            real (f 1) / 2 - real (1 - f 1) / 2]]))).\n        Matrix.row (H \\<Otimes> Quantum.Id 1) i $ k *\n        Matrix.col\n         (Tensor.mat_of_cols_list 4\n           (map (map complex_of_real)\n             [[real (1 - f 0) / 2 - real (f 0) / 2,\n               real (f 0) / 2 - real (1 - f 0) / 2,\n               real (1 - f 1) / 2 - real (f 1) / 2,\n               real (f 1) / 2 - real (1 - f 1) / 2]]))\n         j $\n        k)", "by (auto simp: times_mat_def scalar_prod_def)"], ["proof (state)\nthis:\n  ((H \\<Otimes> Quantum.Id 1) *\n   Tensor.mat_of_cols_list 4\n    (map (map complex_of_real)\n      [[real (1 - f 0) / 2 - real (f 0) / 2,\n        real (f 0) / 2 - real (1 - f 0) / 2,\n        real (1 - f 1) / 2 - real (f 1) / 2,\n        real (f 1) / 2 - real (1 - f 1) / 2]])) $$\n  (i, j) =\n  (\\<Sum>k = 0..<dim_vec\n                  (col_fst\n                    (Tensor.mat_of_cols_list 4\n                      (map (map complex_of_real)\n                        [[real (1 - f 0) / 2 - real (f 0) / 2,\n                          real (f 0) / 2 - real (1 - f 0) / 2,\n                          real (1 - f 1) / 2 - real (f 1) / 2,\n                          real (f 1) / 2 - real (1 - f 1) / 2]]))).\n      Matrix.row (H \\<Otimes> Quantum.Id 1) i $ k *\n      Matrix.col\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / 2 - real (f 0) / 2,\n             real (f 0) / 2 - real (1 - f 0) / 2,\n             real (1 - f 1) / 2 - real (f 1) / 2,\n             real (f 1) / 2 - real (1 - f 1) / 2]]))\n       j $\n      k)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (Tensor.mat_of_cols_list 4\n                       (map (map complex_of_real)\n                         [[real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 0) / (2 * sqrt 2) +\n                           real (1 - f 1) / (2 * sqrt 2) -\n                           real (f 1) / (2 * sqrt 2),\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 0) / (2 * sqrt 2) +\n                           (real (f 1) / (2 * sqrt 2) -\n                            real (1 - f 1) / (2 * sqrt 2)),\n                           real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 1) / (2 * sqrt 2) +\n                           real (f 1) / (2 * sqrt 2),\n                           real (f 0) / (2 * sqrt 2) -\n                           real (1 - f 0) / (2 * sqrt 2) -\n                           real (f 1) / (2 * sqrt 2) +\n                           real (1 - f 1) / (2 * sqrt 2)]]));\n        j < dim_col\n             (Tensor.mat_of_cols_list 4\n               (map (map complex_of_real)\n                 [[real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 0) / (2 * sqrt 2) +\n                   real (1 - f 1) / (2 * sqrt 2) -\n                   real (f 1) / (2 * sqrt 2),\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 0) / (2 * sqrt 2) +\n                   (real (f 1) / (2 * sqrt 2) -\n                    real (1 - f 1) / (2 * sqrt 2)),\n                   real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 1) / (2 * sqrt 2) +\n                   real (f 1) / (2 * sqrt 2),\n                   real (f 0) / (2 * sqrt 2) -\n                   real (1 - f 0) / (2 * sqrt 2) -\n                   real (f 1) / (2 * sqrt 2) +\n                   real (1 - f 1) / (2 * sqrt 2)]]))\\<rbrakk>\n       \\<Longrightarrow> ((H \\<Otimes> Quantum.Id 1) *\n                          Tensor.mat_of_cols_list 4\n                           (map (map complex_of_real)\n                             [[real (1 - f 0) / 2 - real (f 0) / 2,\n                               real (f 0) / 2 - real (1 - f 0) / 2,\n                               real (1 - f 1) / 2 - real (f 1) / 2,\n                               real (f 1) / 2 - real (1 - f 1) / 2]])) $$\n                         (i, j) =\n                         Tensor.mat_of_cols_list 4\n                          (map (map complex_of_real)\n                            [[real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 0) / (2 * sqrt 2) +\n                              real (1 - f 1) / (2 * sqrt 2) -\n                              real (f 1) / (2 * sqrt 2),\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 0) / (2 * sqrt 2) +\n                              (real (f 1) / (2 * sqrt 2) -\n                               real (1 - f 1) / (2 * sqrt 2)),\n                              real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 1) / (2 * sqrt 2) +\n                              real (f 1) / (2 * sqrt 2),\n                              real (f 0) / (2 * sqrt 2) -\n                              real (1 - f 0) / (2 * sqrt 2) -\n                              real (f 1) / (2 * sqrt 2) +\n                              real (1 - f 1) / (2 * sqrt 2)]]) $$\n                         (i, j)\n 2. dim_row\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))\n 3. dim_col\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "thus \"((H \\<Otimes> Id 1) * \\<psi>\\<^sub>2) $$ (i, j) = \\<psi>\\<^sub>3 $$ (i, j)\""], ["proof (prove)\nusing this:\n  ((H \\<Otimes> Quantum.Id 1) *\n   Tensor.mat_of_cols_list 4\n    (map (map complex_of_real)\n      [[real (1 - f 0) / 2 - real (f 0) / 2,\n        real (f 0) / 2 - real (1 - f 0) / 2,\n        real (1 - f 1) / 2 - real (f 1) / 2,\n        real (f 1) / 2 - real (1 - f 1) / 2]])) $$\n  (i, j) =\n  (\\<Sum>k = 0..<dim_vec\n                  (col_fst\n                    (Tensor.mat_of_cols_list 4\n                      (map (map complex_of_real)\n                        [[real (1 - f 0) / 2 - real (f 0) / 2,\n                          real (f 0) / 2 - real (1 - f 0) / 2,\n                          real (1 - f 1) / 2 - real (f 1) / 2,\n                          real (f 1) / 2 - real (1 - f 1) / 2]]))).\n      Matrix.row (H \\<Otimes> Quantum.Id 1) i $ k *\n      Matrix.col\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / 2 - real (f 0) / 2,\n             real (f 0) / 2 - real (1 - f 0) / 2,\n             real (1 - f 1) / 2 - real (f 1) / 2,\n             real (f 1) / 2 - real (1 - f 1) / 2]]))\n       j $\n      k)\n\ngoal (1 subgoal):\n 1. ((H \\<Otimes> Quantum.Id 1) *\n     Tensor.mat_of_cols_list 4\n      (map (map complex_of_real)\n        [[real (1 - f 0) / 2 - real (f 0) / 2,\n          real (f 0) / 2 - real (1 - f 0) / 2,\n          real (1 - f 1) / 2 - real (f 1) / 2,\n          real (f 1) / 2 - real (1 - f 1) / 2]])) $$\n    (i, j) =\n    Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n         (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n         real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n         real (1 - f 1) / (2 * sqrt 2) +\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2)]]) $$\n    (i, j)", "using  mat_of_cols_list_def H_tensor_Id_1 a0 f_ge_0"], ["proof (prove)\nusing this:\n  ((H \\<Otimes> Quantum.Id 1) *\n   Tensor.mat_of_cols_list 4\n    (map (map complex_of_real)\n      [[real (1 - f 0) / 2 - real (f 0) / 2,\n        real (f 0) / 2 - real (1 - f 0) / 2,\n        real (1 - f 1) / 2 - real (f 1) / 2,\n        real (f 1) / 2 - real (1 - f 1) / 2]])) $$\n  (i, j) =\n  (\\<Sum>k = 0..<dim_vec\n                  (col_fst\n                    (Tensor.mat_of_cols_list 4\n                      (map (map complex_of_real)\n                        [[real (1 - f 0) / 2 - real (f 0) / 2,\n                          real (f 0) / 2 - real (1 - f 0) / 2,\n                          real (1 - f 1) / 2 - real (f 1) / 2,\n                          real (f 1) / 2 - real (1 - f 1) / 2]]))).\n      Matrix.row (H \\<Otimes> Quantum.Id 1) i $ k *\n      Matrix.col\n       (Tensor.mat_of_cols_list 4\n         (map (map complex_of_real)\n           [[real (1 - f 0) / 2 - real (f 0) / 2,\n             real (f 0) / 2 - real (1 - f 0) / 2,\n             real (1 - f 1) / 2 - real (f 1) / 2,\n             real (f 1) / 2 - real (1 - f 1) / 2]]))\n       j $\n      k)\n  Tensor.mat_of_cols_list ?nr ?cs =\n  Matrix.mat ?nr (length ?cs) (\\<lambda>(i, j). ?cs ! j ! i)\n  H \\<Otimes> Quantum.Id 1 =\n  Tensor.mat_of_cols_list 4\n   (map (map complex_of_real)\n     [[1 / sqrt 2, 0, 1 / sqrt 2, 0], [0, 1 / sqrt 2, 0, 1 / sqrt 2],\n      [1 / sqrt 2, 0, - 1 / sqrt 2, 0], [0, 1 / sqrt 2, 0, - 1 / sqrt 2]])\n  i \\<in> {0, 1, 2, 3} \\<and> j = 0\n  \\<forall>x. 0 \\<le> f x\n\ngoal (1 subgoal):\n 1. ((H \\<Otimes> Quantum.Id 1) *\n     Tensor.mat_of_cols_list 4\n      (map (map complex_of_real)\n        [[real (1 - f 0) / 2 - real (f 0) / 2,\n          real (f 0) / 2 - real (1 - f 0) / 2,\n          real (1 - f 1) / 2 - real (f 1) / 2,\n          real (f 1) / 2 - real (1 - f 1) / 2]])) $$\n    (i, j) =\n    Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n         (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n         real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n         real (1 - f 1) / (2 * sqrt 2) +\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2)]]) $$\n    (i, j)", "by (auto simp: diff_divide_distrib)"], ["proof (state)\nthis:\n  ((H \\<Otimes> Quantum.Id 1) *\n   Tensor.mat_of_cols_list 4\n    (map (map complex_of_real)\n      [[real (1 - f 0) / 2 - real (f 0) / 2,\n        real (f 0) / 2 - real (1 - f 0) / 2,\n        real (1 - f 1) / 2 - real (f 1) / 2,\n        real (f 1) / 2 - real (1 - f 1) / 2]])) $$\n  (i, j) =\n  Tensor.mat_of_cols_list 4\n   (map (map complex_of_real)\n     [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n       real (1 - f 1) / (2 * sqrt 2) -\n       real (f 1) / (2 * sqrt 2),\n       real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n       (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n       real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n       real (1 - f 1) / (2 * sqrt 2) +\n       real (f 1) / (2 * sqrt 2),\n       real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n       real (f 1) / (2 * sqrt 2) +\n       real (1 - f 1) / (2 * sqrt 2)]]) $$\n  (i, j)\n\ngoal (2 subgoals):\n 1. dim_row\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))\n 2. dim_col\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. dim_row\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))\n 2. dim_col\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "show \"dim_row ((H \\<Otimes> Id 1) * \\<psi>\\<^sub>2) = dim_row \\<psi>\\<^sub>3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "using H_tensor_Id_1 mat_of_cols_list_def"], ["proof (prove)\nusing this:\n  H \\<Otimes> Quantum.Id 1 =\n  Tensor.mat_of_cols_list 4\n   (map (map complex_of_real)\n     [[1 / sqrt 2, 0, 1 / sqrt 2, 0], [0, 1 / sqrt 2, 0, 1 / sqrt 2],\n      [1 / sqrt 2, 0, - 1 / sqrt 2, 0], [0, 1 / sqrt 2, 0, - 1 / sqrt 2]])\n  Tensor.mat_of_cols_list ?nr ?cs =\n  Matrix.mat ?nr (length ?cs) (\\<lambda>(i, j). ?cs ! j ! i)\n\ngoal (1 subgoal):\n 1. dim_row\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_row\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "by simp"], ["proof (state)\nthis:\n  dim_row\n   ((H \\<Otimes> Quantum.Id 1) *\n    Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / 2 - real (f 0) / 2,\n         real (f 0) / 2 - real (1 - f 0) / 2,\n         real (1 - f 1) / 2 - real (f 1) / 2,\n         real (f 1) / 2 - real (1 - f 1) / 2]])) =\n  dim_row\n   (Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n         (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n         real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n         real (1 - f 1) / (2 * sqrt 2) +\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2)]]))\n\ngoal (1 subgoal):\n 1. dim_col\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "show \"dim_col ((H \\<Otimes> Id 1) * \\<psi>\\<^sub>2) = dim_col \\<psi>\\<^sub>3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "using H_tensor_Id_1 mat_of_cols_list_def"], ["proof (prove)\nusing this:\n  H \\<Otimes> Quantum.Id 1 =\n  Tensor.mat_of_cols_list 4\n   (map (map complex_of_real)\n     [[1 / sqrt 2, 0, 1 / sqrt 2, 0], [0, 1 / sqrt 2, 0, 1 / sqrt 2],\n      [1 / sqrt 2, 0, - 1 / sqrt 2, 0], [0, 1 / sqrt 2, 0, - 1 / sqrt 2]])\n  Tensor.mat_of_cols_list ?nr ?cs =\n  Matrix.mat ?nr (length ?cs) (\\<lambda>(i, j). ?cs ! j ! i)\n\ngoal (1 subgoal):\n 1. dim_col\n     ((H \\<Otimes> Quantum.Id 1) *\n      Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / 2 - real (f 0) / 2,\n           real (f 0) / 2 - real (1 - f 0) / 2,\n           real (1 - f 1) / 2 - real (f 1) / 2,\n           real (f 1) / 2 - real (1 - f 1) / 2]])) =\n    dim_col\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "by simp"], ["proof (state)\nthis:\n  dim_col\n   ((H \\<Otimes> Quantum.Id 1) *\n    Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / 2 - real (f 0) / 2,\n         real (f 0) / 2 - real (1 - f 0) / 2,\n         real (1 - f 1) / 2 - real (f 1) / 2,\n         real (f 1) / 2 - real (1 - f 1) / 2]])) =\n  dim_col\n   (Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n         (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n         real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n         real (1 - f 1) / (2 * sqrt 2) +\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2)]]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in deutsch) \\<psi>\\<^sub>3_is_state: \n  shows \"state 2 \\<psi>\\<^sub>3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state 2\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. state 2\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "have \"gate 2 (H \\<Otimes> Id 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gate 2 (H \\<Otimes> Quantum.Id 1)", "using H_tensor_Id_1_is_gate"], ["proof (prove)\nusing this:\n  gate 2 (H \\<Otimes> Quantum.Id 1)\n\ngoal (1 subgoal):\n 1. gate 2 (H \\<Otimes> Quantum.Id 1)", "by simp"], ["proof (state)\nthis:\n  gate 2 (H \\<Otimes> Quantum.Id 1)\n\ngoal (1 subgoal):\n 1. state 2\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "thus \"state 2 \\<psi>\\<^sub>3\""], ["proof (prove)\nusing this:\n  gate 2 (H \\<Otimes> Quantum.Id 1)\n\ngoal (1 subgoal):\n 1. state 2\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "using \\<psi>\\<^sub>2_is_state \\<psi>\\<^sub>2_to_\\<psi>\\<^sub>3"], ["proof (prove)\nusing this:\n  gate 2 (H \\<Otimes> Quantum.Id 1)\n  state 2\n   (Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / 2 - real (f 0) / 2,\n         real (f 0) / 2 - real (1 - f 0) / 2,\n         real (1 - f 1) / 2 - real (f 1) / 2,\n         real (f 1) / 2 - real (1 - f 1) / 2]]))\n  (H \\<Otimes> Quantum.Id 1) *\n  Tensor.mat_of_cols_list 4\n   (map (map complex_of_real)\n     [[real (1 - f 0) / 2 - real (f 0) / 2,\n       real (f 0) / 2 - real (1 - f 0) / 2,\n       real (1 - f 1) / 2 - real (f 1) / 2,\n       real (f 1) / 2 - real (1 - f 1) / 2]]) =\n  Tensor.mat_of_cols_list 4\n   (map (map complex_of_real)\n     [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n       real (1 - f 1) / (2 * sqrt 2) -\n       real (f 1) / (2 * sqrt 2),\n       real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n       (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n       real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n       real (1 - f 1) / (2 * sqrt 2) +\n       real (f 1) / (2 * sqrt 2),\n       real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n       real (f 1) / (2 * sqrt 2) +\n       real (1 - f 1) / (2 * sqrt 2)]])\n\ngoal (1 subgoal):\n 1. state 2\n     (Tensor.mat_of_cols_list 4\n       (map (map complex_of_real)\n         [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n           (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n           real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n           real (1 - f 1) / (2 * sqrt 2) +\n           real (f 1) / (2 * sqrt 2),\n           real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n           real (f 1) / (2 * sqrt 2) +\n           real (1 - f 1) / (2 * sqrt 2)]]))", "by (metis gate_on_state_is_state)"], ["proof (state)\nthis:\n  state 2\n   (Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n         (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n         real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n         real (1 - f 1) / (2 * sqrt 2) +\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2)]]))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nFinally, all steps are put together. The result depends on the function f. If f is constant\nthe first qubit of $\\pm |f(0)\\oplus f(1)\\rangle \\left[ \\dfrac {(|0\\rangle - |1\\rangle)} {\\sqrt 2}\\right]$\nis 0, if it is is\\_balanced it is 1. \nThe algorithm only uses one evaluation of f(x) and will always succeed. \n\\<close>"], ["", "definition (in deutsch) deutsch_algo:: \"complex Matrix.mat\" where \n\"deutsch_algo \\<equiv> (H \\<Otimes> Id 1) * (U\\<^sub>f * ((H * |zero\\<rangle>) \\<Otimes> (H * |one\\<rangle>)))\""], ["", "lemma (in deutsch) deutsch_algo_result [simp]: \n  shows \"deutsch_algo = \\<psi>\\<^sub>3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deutsch_algo =\n    Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n         (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n         real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n         real (1 - f 1) / (2 * sqrt 2) +\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2)]])", "using deutsch_algo_def H_on_ket_zero H_on_ket_one \\<psi>\\<^sub>0_to_\\<psi>\\<^sub>1 \\<psi>\\<^sub>1_to_\\<psi>\\<^sub>2 \\<psi>\\<^sub>2_to_\\<psi>\\<^sub>3"], ["proof (prove)\nusing this:\n  deutsch_algo \\<equiv>\n  (H \\<Otimes> Quantum.Id 1) *\n  (U\\<^sub>f *\n   (H * |Deutsch.zero\\<rangle> \\<Otimes> H * |Deutsch.one\\<rangle>))\n  H * |Deutsch.zero\\<rangle> =\n  Tensor.mat_of_cols_list 2\n   (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]])\n  H * |Deutsch.one\\<rangle> =\n  Tensor.mat_of_cols_list 2\n   (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]])\n  Tensor.mat_of_cols_list 2\n   (map (map complex_of_real) [[1 / sqrt 2, 1 / sqrt 2]]) \\<Otimes>\n  Tensor.mat_of_cols_list 2\n   (map (map complex_of_real) [[1 / sqrt 2, - 1 / sqrt 2]]) =\n  \\<psi>\\<^sub>1\n  U\\<^sub>f * \\<psi>\\<^sub>1 =\n  Tensor.mat_of_cols_list 4\n   (map (map complex_of_real)\n     [[real (1 - f 0) / 2 - real (f 0) / 2,\n       real (f 0) / 2 - real (1 - f 0) / 2,\n       real (1 - f 1) / 2 - real (f 1) / 2,\n       real (f 1) / 2 - real (1 - f 1) / 2]])\n  (H \\<Otimes> Quantum.Id 1) *\n  Tensor.mat_of_cols_list 4\n   (map (map complex_of_real)\n     [[real (1 - f 0) / 2 - real (f 0) / 2,\n       real (f 0) / 2 - real (1 - f 0) / 2,\n       real (1 - f 1) / 2 - real (f 1) / 2,\n       real (f 1) / 2 - real (1 - f 1) / 2]]) =\n  Tensor.mat_of_cols_list 4\n   (map (map complex_of_real)\n     [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n       real (1 - f 1) / (2 * sqrt 2) -\n       real (f 1) / (2 * sqrt 2),\n       real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n       (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n       real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n       real (1 - f 1) / (2 * sqrt 2) +\n       real (f 1) / (2 * sqrt 2),\n       real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n       real (f 1) / (2 * sqrt 2) +\n       real (1 - f 1) / (2 * sqrt 2)]])\n\ngoal (1 subgoal):\n 1. deutsch_algo =\n    Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n         (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n         real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n         real (1 - f 1) / (2 * sqrt 2) +\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2)]])", "by simp"], ["", "lemma (in deutsch) deutsch_algo_result_is_state: \n  shows \"state 2 deutsch_algo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state 2 deutsch_algo", "using \\<psi>\\<^sub>3_is_state"], ["proof (prove)\nusing this:\n  state 2\n   (Tensor.mat_of_cols_list 4\n     (map (map complex_of_real)\n       [[real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) +\n         (real (f 1) / (2 * sqrt 2) - real (1 - f 1) / (2 * sqrt 2)),\n         real (1 - f 0) / (2 * sqrt 2) - real (f 0) / (2 * sqrt 2) -\n         real (1 - f 1) / (2 * sqrt 2) +\n         real (f 1) / (2 * sqrt 2),\n         real (f 0) / (2 * sqrt 2) - real (1 - f 0) / (2 * sqrt 2) -\n         real (f 1) / (2 * sqrt 2) +\n         real (1 - f 1) / (2 * sqrt 2)]]))\n\ngoal (1 subgoal):\n 1. state 2 deutsch_algo", "by simp"], ["", "text \\<open>\nIf the function is constant then the measurement of the first qubit should result in the state \n$|0\\rangle$ with probability 1. \n\\<close>"], ["", "lemma (in deutsch) prob0_deutsch_algo_const:\n  assumes \"is_const\" \n  shows \"prob0 2 deutsch_algo 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 = 1", "have \"{k| k::nat. (k < 4) \\<and> \\<not> select_index 2 0 k} = {0,1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k |k. k < 4 \\<and> \\<not> select_index 2 0 k} = {0, 1}", "using select_index_def"], ["proof (prove)\nusing this:\n  select_index ?n ?i ?j \\<equiv>\n  ?i \\<le> ?n - 1 \\<and>\n  ?j \\<le> 2 ^ ?n - 1 \\<and> 2 ^ (?n - 1 - ?i) \\<le> ?j mod 2 ^ (?n - ?i)\n\ngoal (1 subgoal):\n 1. {k |k. k < 4 \\<and> \\<not> select_index 2 0 k} = {0, 1}", "by auto"], ["proof (state)\nthis:\n  {k |k. k < 4 \\<and> \\<not> select_index 2 0 k} = {0, 1}\n\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 = 1", "then"], ["proof (chain)\npicking this:\n  {k |k. k < 4 \\<and> \\<not> select_index 2 0 k} = {0, 1}", "have \"prob0 2 deutsch_algo 0 = (\\<Sum>j\\<in>{0,1}. (cmod(deutsch_algo $$ (j,0)))\\<^sup>2)\""], ["proof (prove)\nusing this:\n  {k |k. k < 4 \\<and> \\<not> select_index 2 0 k} = {0, 1}\n\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 =\n    (\\<Sum>j\\<in>{0, 1}. (cmod (deutsch_algo $$ (j, 0)))\\<^sup>2)", "using deutsch_algo_result_is_state prob0_def"], ["proof (prove)\nusing this:\n  {k |k. k < 4 \\<and> \\<not> select_index 2 0 k} = {0, 1}\n  state 2 deutsch_algo\n  prob0 ?n ?v ?i \\<equiv>\n  \\<Sum>j\\<in>{k |k. k < 2 ^ ?n \\<and> \\<not> select_index ?n ?i k}.\n    (cmod (?v $$ (j, 0)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 =\n    (\\<Sum>j\\<in>{0, 1}. (cmod (deutsch_algo $$ (j, 0)))\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  prob0 2 deutsch_algo 0 =\n  (\\<Sum>j\\<in>{0, 1}. (cmod (deutsch_algo $$ (j, 0)))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 = 1", "thus \"prob0 2 deutsch_algo 0 = 1\""], ["proof (prove)\nusing this:\n  prob0 2 deutsch_algo 0 =\n  (\\<Sum>j\\<in>{0, 1}. (cmod (deutsch_algo $$ (j, 0)))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 = 1", "using assms is_const_def const_def"], ["proof (prove)\nusing this:\n  prob0 2 deutsch_algo 0 =\n  (\\<Sum>j\\<in>{0, 1}. (cmod (deutsch_algo $$ (j, 0)))\\<^sup>2)\n  is_const\n  is_const \\<equiv> const 0 \\<or> const 1\n  const ?n = (\\<forall>x\\<in>{0, 1}. f x = ?n)\n\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 = 1", "by auto"], ["proof (state)\nthis:\n  prob0 2 deutsch_algo 0 = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in deutsch) prob1_deutsch_algo_const: \n  assumes \"is_const\" \n  shows \"prob1 2 deutsch_algo 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob1 2 deutsch_algo 0 = 0", "using assms prob0_deutsch_algo_const prob_sum_is_one[of \"2\" \"deutsch_algo\" \"0\"] \ndeutsch_algo_result_is_state"], ["proof (prove)\nusing this:\n  is_const\n  is_const \\<Longrightarrow> prob0 2 deutsch_algo 0 = 1\n  state 2 deutsch_algo \\<Longrightarrow>\n  prob1 2 deutsch_algo 0 + prob0 2 deutsch_algo 0 = 1\n  state 2 deutsch_algo\n\ngoal (1 subgoal):\n 1. prob1 2 deutsch_algo 0 = 0", "by simp"], ["", "text \\<open>\nIf the function is balanced the measurement of the first qubit should result in the state $|1\\rangle$ \nwith probability 1. \n\\<close>"], ["", "lemma (in deutsch) prob0_deutsch_algo_balanced:  \n  assumes \"is_balanced\" \n  shows \"prob0 2 deutsch_algo 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 = 0", "have \"{k| k::nat. (k < 4) \\<and> \\<not> select_index 2 0 k} = {0,1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k |k. k < 4 \\<and> \\<not> select_index 2 0 k} = {0, 1}", "using select_index_def"], ["proof (prove)\nusing this:\n  select_index ?n ?i ?j \\<equiv>\n  ?i \\<le> ?n - 1 \\<and>\n  ?j \\<le> 2 ^ ?n - 1 \\<and> 2 ^ (?n - 1 - ?i) \\<le> ?j mod 2 ^ (?n - ?i)\n\ngoal (1 subgoal):\n 1. {k |k. k < 4 \\<and> \\<not> select_index 2 0 k} = {0, 1}", "by auto"], ["proof (state)\nthis:\n  {k |k. k < 4 \\<and> \\<not> select_index 2 0 k} = {0, 1}\n\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 = 0", "then"], ["proof (chain)\npicking this:\n  {k |k. k < 4 \\<and> \\<not> select_index 2 0 k} = {0, 1}", "have \"prob0 2 deutsch_algo 0 = (\\<Sum>j \\<in> {0,1}. (cmod(deutsch_algo $$ (j,0)))\\<^sup>2)\""], ["proof (prove)\nusing this:\n  {k |k. k < 4 \\<and> \\<not> select_index 2 0 k} = {0, 1}\n\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 =\n    (\\<Sum>j\\<in>{0, 1}. (cmod (deutsch_algo $$ (j, 0)))\\<^sup>2)", "using deutsch_algo_result_is_state prob0_def"], ["proof (prove)\nusing this:\n  {k |k. k < 4 \\<and> \\<not> select_index 2 0 k} = {0, 1}\n  state 2 deutsch_algo\n  prob0 ?n ?v ?i \\<equiv>\n  \\<Sum>j\\<in>{k |k. k < 2 ^ ?n \\<and> \\<not> select_index ?n ?i k}.\n    (cmod (?v $$ (j, 0)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 =\n    (\\<Sum>j\\<in>{0, 1}. (cmod (deutsch_algo $$ (j, 0)))\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  prob0 2 deutsch_algo 0 =\n  (\\<Sum>j\\<in>{0, 1}. (cmod (deutsch_algo $$ (j, 0)))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 = 0", "thus \"prob0 2 deutsch_algo 0 = 0\""], ["proof (prove)\nusing this:\n  prob0 2 deutsch_algo 0 =\n  (\\<Sum>j\\<in>{0, 1}. (cmod (deutsch_algo $$ (j, 0)))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 = 0", "using is_swap_values assms is_balanced_def"], ["proof (prove)\nusing this:\n  prob0 2 deutsch_algo 0 =\n  (\\<Sum>j\\<in>{0, 1}. (cmod (deutsch_algo $$ (j, 0)))\\<^sup>2)\n  is_swap \\<Longrightarrow> f 0 = 1\n  is_swap \\<Longrightarrow> f 1 = 0\n  is_balanced\n  is_balanced \\<equiv> (\\<forall>x\\<in>{0, 1}. f x = x) \\<or> is_swap\n\ngoal (1 subgoal):\n 1. prob0 2 deutsch_algo 0 = 0", "by auto"], ["proof (state)\nthis:\n  prob0 2 deutsch_algo 0 = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in deutsch) prob1_deutsch_algo_balanced:\n  assumes \"is_balanced\" \n  shows \"prob1 2 deutsch_algo 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob1 2 deutsch_algo 0 = 1", "using assms prob0_deutsch_algo_balanced prob_sum_is_one[of \"2\" \"deutsch_algo\" \"0\"] \ndeutsch_algo_result_is_state"], ["proof (prove)\nusing this:\n  is_balanced\n  is_balanced \\<Longrightarrow> prob0 2 deutsch_algo 0 = 0\n  state 2 deutsch_algo \\<Longrightarrow>\n  prob1 2 deutsch_algo 0 + prob0 2 deutsch_algo 0 = 1\n  state 2 deutsch_algo\n\ngoal (1 subgoal):\n 1. prob1 2 deutsch_algo 0 = 1", "by simp"], ["", "text \\<open>Eventually, the measurement of the first qubit results in $f(0)\\oplus f(1)$. \\<close>"], ["", "definition (in deutsch) deutsch_algo_eval:: \"real\" where \n\"deutsch_algo_eval \\<equiv> prob1 2 deutsch_algo 0\""], ["", "lemma (in deutsch) sum_mod_2_cases:\n  shows \"(f 0 + f 1) mod 2 = 0 \\<longrightarrow> is_const\" \n  and \"(f 0 + f 1) mod 2 = 1 \\<longrightarrow> is_balanced\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 0 \\<longrightarrow> is_const &&&\n    (f 0 + f 1) mod 2 = 1 \\<longrightarrow> is_balanced", "using f_cases is_balanced_sum_mod_2 is_const_sum_mod_2"], ["proof (prove)\nusing this:\n  is_const \\<or> is_balanced\n  is_balanced \\<Longrightarrow> (f 0 + f 1) mod 2 = 1\n  is_const \\<Longrightarrow> (f 0 + f 1) mod 2 = 0\n\ngoal (1 subgoal):\n 1. (f 0 + f 1) mod 2 = 0 \\<longrightarrow> is_const &&&\n    (f 0 + f 1) mod 2 = 1 \\<longrightarrow> is_balanced", "by auto"], ["", "lemma (in deutsch) deutsch_algo_eval_is_sum_mod_2:\n  shows \"deutsch_algo_eval = (f 0 + f 1) mod 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deutsch_algo_eval = real ((f 0 + f 1) mod 2)", "using deutsch_algo_eval_def f_cases is_const_sum_mod_2 is_balanced_sum_mod_2 \nprob1_deutsch_algo_const prob1_deutsch_algo_balanced"], ["proof (prove)\nusing this:\n  deutsch_algo_eval \\<equiv> prob1 2 deutsch_algo 0\n  is_const \\<or> is_balanced\n  is_const \\<Longrightarrow> (f 0 + f 1) mod 2 = 0\n  is_balanced \\<Longrightarrow> (f 0 + f 1) mod 2 = 1\n  is_const \\<Longrightarrow> prob1 2 deutsch_algo 0 = 0\n  is_balanced \\<Longrightarrow> prob1 2 deutsch_algo 0 = 1\n\ngoal (1 subgoal):\n 1. deutsch_algo_eval = real ((f 0 + f 1) mod 2)", "by auto"], ["", "text \\<open>\nIf the algorithm returns 0 then one concludes that the input function is constant and\nif it returns 1 then the function is balanced.\n\\<close>"], ["", "theorem (in deutsch) deutsch_algo_is_correct:\n  shows \"deutsch_algo_eval = 0 \\<longrightarrow> is_const\" and \"deutsch_algo_eval = 1 \\<longrightarrow> is_balanced\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deutsch_algo_eval = 0 \\<longrightarrow> is_const &&&\n    deutsch_algo_eval = 1 \\<longrightarrow> is_balanced", "using deutsch_algo_eval_is_sum_mod_2 sum_mod_2_cases"], ["proof (prove)\nusing this:\n  deutsch_algo_eval = real ((f 0 + f 1) mod 2)\n  (f 0 + f 1) mod 2 = 0 \\<longrightarrow> is_const\n  (f 0 + f 1) mod 2 = 1 \\<longrightarrow> is_balanced\n\ngoal (1 subgoal):\n 1. deutsch_algo_eval = 0 \\<longrightarrow> is_const &&&\n    deutsch_algo_eval = 1 \\<longrightarrow> is_balanced", "by auto"], ["", "end"]]}