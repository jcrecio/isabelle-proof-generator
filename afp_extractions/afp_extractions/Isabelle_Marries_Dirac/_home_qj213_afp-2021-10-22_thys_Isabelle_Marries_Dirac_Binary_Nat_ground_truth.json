{"file_name": "/home/qj213/afp-2021-10-22/thys/Isabelle_Marries_Dirac/Binary_Nat.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Isabelle_Marries_Dirac", "problem_names": ["lemma length_of_bin_rep_aux:\n  fixes n m:: nat\n  assumes \"m < 2^n\"\n  shows \"length (bin_rep_aux n m) = n+1\"", "lemma bin_rep_aux_neq_nil:\n  fixes n m:: nat\n  shows \"bin_rep_aux n m \\<noteq> []\"", "lemma last_of_bin_rep_aux:\n  fixes n m:: nat \n  assumes \"m < 2^n\" and \"m \\<ge> 0\"\n  shows \"last (bin_rep_aux n m) = 0\"", "lemma mod_mod_power_cancel:\n  fixes m n p:: nat\n  assumes \"m \\<le> n\"\n  shows \"p mod 2^n mod 2^m = p mod 2^m\"", "lemma bin_rep_aux_index:\n  fixes n m i:: nat\n  assumes \"n \\<ge> 1\" and \"m < 2^n\" and \"m \\<ge> 0\" and \"i \\<le> n\"\n  shows \"bin_rep_aux n m ! i = (m mod 2^(n-i)) div 2^(n-1-i)\"", "lemma bin_rep_aux_coeff:\n  fixes n m i:: nat\n  assumes \"m < 2^n\" and \"i \\<le> n\" and \"m \\<ge> 0\"\n  shows \"bin_rep_aux n m ! i = 0 \\<or> bin_rep_aux n m ! i = 1\"", "lemma length_of_bin_rep:\n  fixes n m:: nat\n  assumes \"m < 2^n\"\n  shows \"length (bin_rep n m) = n\"", "lemma bin_rep_coeff:\n  fixes n m i:: nat\n  assumes \"m < 2^n\" and \"i < n\" and \"m \\<ge> 0\"\n  shows \"bin_rep n m ! i = 0 \\<or> bin_rep n m ! i = 1\"", "lemma bin_rep_index:\n  fixes n m i:: nat\n  assumes \"n \\<ge> 1\" and \"m < 2^n\" and \"i < n\" and \"m \\<ge> 0\"\n  shows \"bin_rep n m ! i = (m mod 2^(n-i)) div 2^(n-1-i)\"", "lemma bin_rep_eq:\n  fixes n m:: nat \n  assumes \"n \\<ge> 1\" and \"m \\<ge> 0\" and \"m < 2^n\" and \"m \\<ge> 0\"\n  shows \"m = (\\<Sum>i<n. bin_rep n m ! i * 2^(n-1-i))\"", "lemma bin_rep_index_0:\n  fixes n m:: nat\n  assumes \"m < 2^n\" and \"k > n\"\n  shows \"(bin_rep k m) ! 0 = 0\"", "lemma bin_rep_index_0_geq:\n  fixes n m:: nat\n  assumes \"m \\<ge> 2^n\" and \"m < 2^(n+1)\"\n  shows \"bin_rep (n+1) m ! 0 = 1\""], "translations": [["", "lemma length_of_bin_rep_aux:\n  fixes n m:: nat\n  assumes \"m < 2^n\"\n  shows \"length (bin_rep_aux n m) = n+1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bin_rep_aux n m) = n + 1", "using assms"], ["proof (prove)\nusing this:\n  m < 2 ^ n\n\ngoal (1 subgoal):\n 1. length (bin_rep_aux n m) = n + 1", "proof(induction n arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. m < 2 ^ 0 \\<Longrightarrow> length (bin_rep_aux 0 m) = 0 + 1\n 2. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m < 2 ^ n \\<Longrightarrow>\n                   length (bin_rep_aux n m) = n + 1;\n        m < 2 ^ Suc n\\<rbrakk>\n       \\<Longrightarrow> length (bin_rep_aux (Suc n) m) = Suc n + 1", "case 0"], ["proof (state)\nthis:\n  m < 2 ^ 0\n\ngoal (2 subgoals):\n 1. \\<And>m. m < 2 ^ 0 \\<Longrightarrow> length (bin_rep_aux 0 m) = 0 + 1\n 2. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m < 2 ^ n \\<Longrightarrow>\n                   length (bin_rep_aux n m) = n + 1;\n        m < 2 ^ Suc n\\<rbrakk>\n       \\<Longrightarrow> length (bin_rep_aux (Suc n) m) = Suc n + 1", "then"], ["proof (chain)\npicking this:\n  m < 2 ^ 0", "show \"length (bin_rep_aux 0 m) = 0 + 1\""], ["proof (prove)\nusing this:\n  m < 2 ^ 0\n\ngoal (1 subgoal):\n 1. length (bin_rep_aux 0 m) = 0 + 1", "by simp"], ["proof (state)\nthis:\n  length (bin_rep_aux 0 m) = 0 + 1\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m < 2 ^ n \\<Longrightarrow>\n                   length (bin_rep_aux n m) = n + 1;\n        m < 2 ^ Suc n\\<rbrakk>\n       \\<Longrightarrow> length (bin_rep_aux (Suc n) m) = Suc n + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m < 2 ^ n \\<Longrightarrow>\n                   length (bin_rep_aux n m) = n + 1;\n        m < 2 ^ Suc n\\<rbrakk>\n       \\<Longrightarrow> length (bin_rep_aux (Suc n) m) = Suc n + 1", "case (Suc n)"], ["proof (state)\nthis:\n  ?m < 2 ^ n \\<Longrightarrow> length (bin_rep_aux n ?m) = n + 1\n  m < 2 ^ Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m < 2 ^ n \\<Longrightarrow>\n                   length (bin_rep_aux n m) = n + 1;\n        m < 2 ^ Suc n\\<rbrakk>\n       \\<Longrightarrow> length (bin_rep_aux (Suc n) m) = Suc n + 1", "assume a0:\"\\<And>m. m < 2^n \\<Longrightarrow> length (bin_rep_aux n m) = n + 1\" and \"m < 2^(Suc n)\""], ["proof (state)\nthis:\n  ?m < 2 ^ n \\<Longrightarrow> length (bin_rep_aux n ?m) = n + 1\n  m < 2 ^ Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m < 2 ^ n \\<Longrightarrow>\n                   length (bin_rep_aux n m) = n + 1;\n        m < 2 ^ Suc n\\<rbrakk>\n       \\<Longrightarrow> length (bin_rep_aux (Suc n) m) = Suc n + 1", "then"], ["proof (chain)\npicking this:\n  ?m < 2 ^ n \\<Longrightarrow> length (bin_rep_aux n ?m) = n + 1\n  m < 2 ^ Suc n", "show \"length (bin_rep_aux (Suc n) m) = Suc n + 1\""], ["proof (prove)\nusing this:\n  ?m < 2 ^ n \\<Longrightarrow> length (bin_rep_aux n ?m) = n + 1\n  m < 2 ^ Suc n\n\ngoal (1 subgoal):\n 1. length (bin_rep_aux (Suc n) m) = Suc n + 1", "using a0"], ["proof (prove)\nusing this:\n  ?m < 2 ^ n \\<Longrightarrow> length (bin_rep_aux n ?m) = n + 1\n  m < 2 ^ Suc n\n  ?m < 2 ^ n \\<Longrightarrow> length (bin_rep_aux n ?m) = n + 1\n\ngoal (1 subgoal):\n 1. length (bin_rep_aux (Suc n) m) = Suc n + 1", "by simp"], ["proof (state)\nthis:\n  length (bin_rep_aux (Suc n) m) = Suc n + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_rep_aux_neq_nil:\n  fixes n m:: nat\n  shows \"bin_rep_aux n m \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rep_aux n m \\<noteq> []", "using bin_rep_aux.simps"], ["proof (prove)\nusing this:\n  bin_rep_aux 0 ?m = [?m]\n  bin_rep_aux (Suc ?n) ?m = ?m div 2 ^ ?n # bin_rep_aux ?n (?m mod 2 ^ ?n)\n\ngoal (1 subgoal):\n 1. bin_rep_aux n m \\<noteq> []", "by (metis list.distinct(1) old.nat.exhaust)"], ["", "lemma last_of_bin_rep_aux:\n  fixes n m:: nat \n  assumes \"m < 2^n\" and \"m \\<ge> 0\"\n  shows \"last (bin_rep_aux n m) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (bin_rep_aux n m) = 0", "using assms"], ["proof (prove)\nusing this:\n  m < 2 ^ n\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. last (bin_rep_aux n m) = 0", "proof(induction n arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>m < 2 ^ 0; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> last (bin_rep_aux 0 m) = 0\n 2. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < 2 ^ n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> last (bin_rep_aux n m) = 0;\n        m < 2 ^ Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> last (bin_rep_aux (Suc n) m) = 0", "case 0"], ["proof (state)\nthis:\n  m < 2 ^ 0\n  0 \\<le> m\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>m < 2 ^ 0; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> last (bin_rep_aux 0 m) = 0\n 2. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < 2 ^ n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> last (bin_rep_aux n m) = 0;\n        m < 2 ^ Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> last (bin_rep_aux (Suc n) m) = 0", "assume \"m < 2^0\" and \"m \\<ge> 0\""], ["proof (state)\nthis:\n  m < 2 ^ 0\n  0 \\<le> m\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>m < 2 ^ 0; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> last (bin_rep_aux 0 m) = 0\n 2. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < 2 ^ n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> last (bin_rep_aux n m) = 0;\n        m < 2 ^ Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> last (bin_rep_aux (Suc n) m) = 0", "then"], ["proof (chain)\npicking this:\n  m < 2 ^ 0\n  0 \\<le> m", "show \"last (bin_rep_aux 0 m) = 0\""], ["proof (prove)\nusing this:\n  m < 2 ^ 0\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. last (bin_rep_aux 0 m) = 0", "by simp"], ["proof (state)\nthis:\n  last (bin_rep_aux 0 m) = 0\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < 2 ^ n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> last (bin_rep_aux n m) = 0;\n        m < 2 ^ Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> last (bin_rep_aux (Suc n) m) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < 2 ^ n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> last (bin_rep_aux n m) = 0;\n        m < 2 ^ Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> last (bin_rep_aux (Suc n) m) = 0", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>?m < 2 ^ n; 0 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> last (bin_rep_aux n ?m) = 0\n  m < 2 ^ Suc n\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < 2 ^ n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> last (bin_rep_aux n m) = 0;\n        m < 2 ^ Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> last (bin_rep_aux (Suc n) m) = 0", "assume a0:\"\\<And>m. m < 2^n \\<Longrightarrow> m \\<ge> 0 \\<Longrightarrow> last (bin_rep_aux n m) = 0\" and \"m < 2^(Suc n)\"\nand \"m \\<ge> 0\""], ["proof (state)\nthis:\n  \\<lbrakk>?m < 2 ^ n; 0 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> last (bin_rep_aux n ?m) = 0\n  m < 2 ^ Suc n\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < 2 ^ n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> last (bin_rep_aux n m) = 0;\n        m < 2 ^ Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> last (bin_rep_aux (Suc n) m) = 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?m < 2 ^ n; 0 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> last (bin_rep_aux n ?m) = 0\n  m < 2 ^ Suc n\n  0 \\<le> m", "show \"last (bin_rep_aux (Suc n) m) = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?m < 2 ^ n; 0 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> last (bin_rep_aux n ?m) = 0\n  m < 2 ^ Suc n\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. last (bin_rep_aux (Suc n) m) = 0", "using bin_rep_aux_neq_nil"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m < 2 ^ n; 0 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> last (bin_rep_aux n ?m) = 0\n  m < 2 ^ Suc n\n  0 \\<le> m\n  bin_rep_aux ?n ?m \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (bin_rep_aux (Suc n) m) = 0", "by simp"], ["proof (state)\nthis:\n  last (bin_rep_aux (Suc n) m) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_mod_power_cancel:\n  fixes m n p:: nat\n  assumes \"m \\<le> n\"\n  shows \"p mod 2^n mod 2^m = p mod 2^m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p mod 2 ^ n mod 2 ^ m = p mod 2 ^ m", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. p mod 2 ^ n mod 2 ^ m = p mod 2 ^ m", "by (simp add: dvd_power_le mod_mod_cancel)"], ["", "lemma bin_rep_aux_index:\n  fixes n m i:: nat\n  assumes \"n \\<ge> 1\" and \"m < 2^n\" and \"m \\<ge> 0\" and \"i \\<le> n\"\n  shows \"bin_rep_aux n m ! i = (m mod 2^(n-i)) div 2^(n-1-i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rep_aux n m ! i = m mod 2 ^ (n - i) div 2 ^ (n - 1 - i)", "using assms"], ["proof (prove)\nusing this:\n  1 \\<le> n\n  m < 2 ^ n\n  0 \\<le> m\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. bin_rep_aux n m ! i = m mod 2 ^ (n - i) div 2 ^ (n - 1 - i)", "proof(induction n arbitrary: m i rule: nat_induct_at_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m i.\n       \\<lbrakk>m < 2 ^ 1; 0 \\<le> m; i \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux 1 m ! i =\n                         m mod 2 ^ (1 - i) div 2 ^ (1 - 1 - i)\n 2. \\<And>n m i.\n       \\<lbrakk>1 \\<le> n;\n        \\<And>m i.\n           \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> bin_rep_aux n m ! i =\n                             m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n        m < 2 ^ Suc n; 0 \\<le> m; i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                         m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "case base"], ["proof (state)\nthis:\n  m < 2 ^ 1\n  0 \\<le> m\n  i \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<And>m i.\n       \\<lbrakk>m < 2 ^ 1; 0 \\<le> m; i \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux 1 m ! i =\n                         m mod 2 ^ (1 - i) div 2 ^ (1 - 1 - i)\n 2. \\<And>n m i.\n       \\<lbrakk>1 \\<le> n;\n        \\<And>m i.\n           \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> bin_rep_aux n m ! i =\n                             m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n        m < 2 ^ Suc n; 0 \\<le> m; i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                         m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "assume \"m < 2^1\" and \"i \\<le> 1\""], ["proof (state)\nthis:\n  m < 2 ^ 1\n  i \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<And>m i.\n       \\<lbrakk>m < 2 ^ 1; 0 \\<le> m; i \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux 1 m ! i =\n                         m mod 2 ^ (1 - i) div 2 ^ (1 - 1 - i)\n 2. \\<And>n m i.\n       \\<lbrakk>1 \\<le> n;\n        \\<And>m i.\n           \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> bin_rep_aux n m ! i =\n                             m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n        m < 2 ^ Suc n; 0 \\<le> m; i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                         m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "then"], ["proof (chain)\npicking this:\n  m < 2 ^ 1\n  i \\<le> 1", "show \"bin_rep_aux 1 m ! i = m mod 2^(1-i) div 2^(1-1-i)\""], ["proof (prove)\nusing this:\n  m < 2 ^ 1\n  i \\<le> 1\n\ngoal (1 subgoal):\n 1. bin_rep_aux 1 m ! i = m mod 2 ^ (1 - i) div 2 ^ (1 - 1 - i)", "using bin_rep_aux.simps"], ["proof (prove)\nusing this:\n  m < 2 ^ 1\n  i \\<le> 1\n  bin_rep_aux 0 ?m = [?m]\n  bin_rep_aux (Suc ?n) ?m = ?m div 2 ^ ?n # bin_rep_aux ?n (?m mod 2 ^ ?n)\n\ngoal (1 subgoal):\n 1. bin_rep_aux 1 m ! i = m mod 2 ^ (1 - i) div 2 ^ (1 - 1 - i)", "by (metis One_nat_def base.prems(2) diff_is_0_eq' diff_zero div_by_1 le_Suc_eq le_numeral_extra(3) \nnth_Cons' power_0 unique_euclidean_semiring_numeral_class.mod_less)"], ["proof (state)\nthis:\n  bin_rep_aux 1 m ! i = m mod 2 ^ (1 - i) div 2 ^ (1 - 1 - i)\n\ngoal (1 subgoal):\n 1. \\<And>n m i.\n       \\<lbrakk>1 \\<le> n;\n        \\<And>m i.\n           \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> bin_rep_aux n m ! i =\n                             m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n        m < 2 ^ Suc n; 0 \\<le> m; i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                         m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m i.\n       \\<lbrakk>1 \\<le> n;\n        \\<And>m i.\n           \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> bin_rep_aux n m ! i =\n                             m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n        m < 2 ^ Suc n; 0 \\<le> m; i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                         m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "case (Suc n)"], ["proof (state)\nthis:\n  1 \\<le> n\n  \\<lbrakk>?m < 2 ^ n; 0 \\<le> ?m; ?i \\<le> n\\<rbrakk>\n  \\<Longrightarrow> bin_rep_aux n ?m ! ?i =\n                    ?m mod 2 ^ (n - ?i) div 2 ^ (n - 1 - ?i)\n  m < 2 ^ Suc n\n  0 \\<le> m\n  i \\<le> Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n m i.\n       \\<lbrakk>1 \\<le> n;\n        \\<And>m i.\n           \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> bin_rep_aux n m ! i =\n                             m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n        m < 2 ^ Suc n; 0 \\<le> m; i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                         m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "assume a0:\"\\<And>m i. m < 2^n \\<Longrightarrow> m \\<ge> 0 \\<Longrightarrow> i \\<le> n \\<Longrightarrow> bin_rep_aux n m ! i = m mod 2 ^ (n-i) div 2^(n-1-i)\"\nand a1:\"m < 2^(Suc n)\" and a2:\"i \\<le> Suc n\" and a3:\"m \\<ge> 0\""], ["proof (state)\nthis:\n  \\<lbrakk>?m < 2 ^ n; 0 \\<le> ?m; ?i \\<le> n\\<rbrakk>\n  \\<Longrightarrow> bin_rep_aux n ?m ! ?i =\n                    ?m mod 2 ^ (n - ?i) div 2 ^ (n - 1 - ?i)\n  m < 2 ^ Suc n\n  i \\<le> Suc n\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>n m i.\n       \\<lbrakk>1 \\<le> n;\n        \\<And>m i.\n           \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n           \\<Longrightarrow> bin_rep_aux n m ! i =\n                             m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n        m < 2 ^ Suc n; 0 \\<le> m; i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                         m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?m < 2 ^ n; 0 \\<le> ?m; ?i \\<le> n\\<rbrakk>\n  \\<Longrightarrow> bin_rep_aux n ?m ! ?i =\n                    ?m mod 2 ^ (n - ?i) div 2 ^ (n - 1 - ?i)\n  m < 2 ^ Suc n\n  i \\<le> Suc n\n  0 \\<le> m", "show \"bin_rep_aux (Suc n) m ! i = m mod 2^(Suc n - i) div 2^(Suc n - 1 - i)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?m < 2 ^ n; 0 \\<le> ?m; ?i \\<le> n\\<rbrakk>\n  \\<Longrightarrow> bin_rep_aux n ?m ! ?i =\n                    ?m mod 2 ^ (n - ?i) div 2 ^ (n - 1 - ?i)\n  m < 2 ^ Suc n\n  i \\<le> Suc n\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i =\n                                  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                      m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "have \"bin_rep_aux (Suc n) m = m div 2^n # bin_rep_aux n (m mod 2^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m = m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)", "by simp"], ["proof (state)\nthis:\n  bin_rep_aux (Suc n) m = m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i =\n                                  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                      m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "then"], ["proof (chain)\npicking this:\n  bin_rep_aux (Suc n) m = m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)", "have f0:\"bin_rep_aux (Suc n) m ! i = (m div 2^n # bin_rep_aux n (m mod 2^n)) ! i\""], ["proof (prove)\nusing this:\n  bin_rep_aux (Suc n) m = m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i", "by simp"], ["proof (state)\nthis:\n  bin_rep_aux (Suc n) m ! i =\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i =\n                                  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                      m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "then"], ["proof (chain)\npicking this:\n  bin_rep_aux (Suc n) m ! i =\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i", "have \"bin_rep_aux (Suc n) m ! i = m div 2^n\" if \"i = 0\""], ["proof (prove)\nusing this:\n  bin_rep_aux (Suc n) m ! i =\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i = m div 2 ^ n", "using that"], ["proof (prove)\nusing this:\n  bin_rep_aux (Suc n) m ! i =\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i\n  i = 0\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i = m div 2 ^ n", "by simp"], ["proof (state)\nthis:\n  i = 0 \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = m div 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i =\n                                  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                      m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "then"], ["proof (chain)\npicking this:\n  i = 0 \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = m div 2 ^ n", "have f1:\"bin_rep_aux (Suc n) m ! i = m mod 2^(Suc n - i) div 2^(Suc n - 1 - i)\" if \"i = 0\""], ["proof (prove)\nusing this:\n  i = 0 \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = m div 2 ^ n\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (i = 0 \\<Longrightarrow>\n     bin_rep_aux (Suc n) m ! i = m div 2 ^ n) \\<Longrightarrow>\n    bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "have \"m mod 2^(Suc n - i) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m mod 2 ^ (Suc n - i) = m", "using that a1"], ["proof (prove)\nusing this:\n  i = 0\n  m < 2 ^ Suc n\n\ngoal (1 subgoal):\n 1. m mod 2 ^ (Suc n - i) = m", "by (simp add: Suc.prems(2))"], ["proof (state)\nthis:\n  m mod 2 ^ (Suc n - i) = m\n\ngoal (1 subgoal):\n 1. (i = 0 \\<Longrightarrow>\n     bin_rep_aux (Suc n) m ! i = m div 2 ^ n) \\<Longrightarrow>\n    bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "then"], ["proof (chain)\npicking this:\n  m mod 2 ^ (Suc n - i) = m", "have \"m mod 2^(Suc n - i) div 2^(Suc n - 1 - i) = m div 2^n\""], ["proof (prove)\nusing this:\n  m mod 2 ^ (Suc n - i) = m\n\ngoal (1 subgoal):\n 1. m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i) = m div 2 ^ n", "using that"], ["proof (prove)\nusing this:\n  m mod 2 ^ (Suc n - i) = m\n  i = 0\n\ngoal (1 subgoal):\n 1. m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i) = m div 2 ^ n", "by simp"], ["proof (state)\nthis:\n  m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i) = m div 2 ^ n\n\ngoal (1 subgoal):\n 1. (i = 0 \\<Longrightarrow>\n     bin_rep_aux (Suc n) m ! i = m div 2 ^ n) \\<Longrightarrow>\n    bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i) = m div 2 ^ n\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "by (simp add: that)"], ["proof (state)\nthis:\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i = 0 \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i =\n                                  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                      m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "then"], ["proof (chain)\npicking this:\n  i = 0 \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "have \"bin_rep_aux (Suc n) m ! i = bin_rep_aux n (m mod 2^n) ! (i-1)\" if \"i \\<ge> 1\""], ["proof (prove)\nusing this:\n  i = 0 \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i = bin_rep_aux n (m mod 2 ^ n) ! (i - 1)", "using that f0"], ["proof (prove)\nusing this:\n  i = 0 \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n  1 \\<le> i\n  bin_rep_aux (Suc n) m ! i =\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i = bin_rep_aux n (m mod 2 ^ n) ! (i - 1)", "by simp"], ["proof (state)\nthis:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = bin_rep_aux n (m mod 2 ^ n) ! (i - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i =\n                                  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                      m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "then"], ["proof (chain)\npicking this:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = bin_rep_aux n (m mod 2 ^ n) ! (i - 1)", "have f2:\"bin_rep_aux (Suc n) m ! i = ((m mod 2^n) mod 2^(n - (i - 1))) div 2^(n - 1 - (i - 1))\" if \"i \\<ge> 1\""], ["proof (prove)\nusing this:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = bin_rep_aux n (m mod 2 ^ n) ! (i - 1)\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ n mod 2 ^ (n - (i - 1)) div 2 ^ (n - 1 - (i - 1))", "using that a0 a1 a2 a3 Suc.prems(2)"], ["proof (prove)\nusing this:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = bin_rep_aux n (m mod 2 ^ n) ! (i - 1)\n  1 \\<le> i\n  \\<lbrakk>?m < 2 ^ n; 0 \\<le> ?m; ?i \\<le> n\\<rbrakk>\n  \\<Longrightarrow> bin_rep_aux n ?m ! ?i =\n                    ?m mod 2 ^ (n - ?i) div 2 ^ (n - 1 - ?i)\n  m < 2 ^ Suc n\n  i \\<le> Suc n\n  0 \\<le> m\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ n mod 2 ^ (n - (i - 1)) div 2 ^ (n - 1 - (i - 1))", "by simp"], ["proof (state)\nthis:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i =\n  m mod 2 ^ n mod 2 ^ (n - (i - 1)) div 2 ^ (n - 1 - (i - 1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i =\n                                  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                      m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "then"], ["proof (chain)\npicking this:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i =\n  m mod 2 ^ n mod 2 ^ (n - (i - 1)) div 2 ^ (n - 1 - (i - 1))", "have f3:\"bin_rep_aux (Suc n) m ! i = ((m mod 2^n) mod 2^(Suc n - i)) div 2^(Suc n - 1 - i)\" if \"i \\<ge> 1\""], ["proof (prove)\nusing this:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i =\n  m mod 2 ^ n mod 2 ^ (n - (i - 1)) div 2 ^ (n - 1 - (i - 1))\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ n mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "using that"], ["proof (prove)\nusing this:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i =\n  m mod 2 ^ n mod 2 ^ (n - (i - 1)) div 2 ^ (n - 1 - (i - 1))\n  1 \\<le> i\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ n mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "by simp"], ["proof (state)\nthis:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i =\n  m mod 2 ^ n mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i =\n                                  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                      m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "then"], ["proof (chain)\npicking this:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i =\n  m mod 2 ^ n mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "have \"bin_rep_aux (Suc n) m ! i = m mod 2^(Suc n - i) div 2^(Suc n - 1 - i)\" if \"i \\<ge> 1\""], ["proof (prove)\nusing this:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i =\n  m mod 2 ^ n mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (1 \\<le> i \\<Longrightarrow>\n     bin_rep_aux (Suc n) m ! i =\n     m mod 2 ^ n mod 2 ^ (Suc n - i) div\n     2 ^ (Suc n - 1 - i)) \\<Longrightarrow>\n    bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "have \"Suc n - i \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n - i \\<le> n", "using that"], ["proof (prove)\nusing this:\n  1 \\<le> i\n\ngoal (1 subgoal):\n 1. Suc n - i \\<le> n", "by simp"], ["proof (state)\nthis:\n  Suc n - i \\<le> n\n\ngoal (1 subgoal):\n 1. (1 \\<le> i \\<Longrightarrow>\n     bin_rep_aux (Suc n) m ! i =\n     m mod 2 ^ n mod 2 ^ (Suc n - i) div\n     2 ^ (Suc n - 1 - i)) \\<Longrightarrow>\n    bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "then"], ["proof (chain)\npicking this:\n  Suc n - i \\<le> n", "have \"m mod 2^n mod 2^(Suc n - i) = m mod 2^(Suc n - i)\""], ["proof (prove)\nusing this:\n  Suc n - i \\<le> n\n\ngoal (1 subgoal):\n 1. m mod 2 ^ n mod 2 ^ (Suc n - i) = m mod 2 ^ (Suc n - i)", "using mod_mod_power_cancel[of \"Suc n - i\" \"n\" \"m\"]"], ["proof (prove)\nusing this:\n  Suc n - i \\<le> n\n  Suc n - i \\<le> n \\<Longrightarrow>\n  m mod 2 ^ n mod 2 ^ (Suc n - i) = m mod 2 ^ (Suc n - i)\n\ngoal (1 subgoal):\n 1. m mod 2 ^ n mod 2 ^ (Suc n - i) = m mod 2 ^ (Suc n - i)", "by simp"], ["proof (state)\nthis:\n  m mod 2 ^ n mod 2 ^ (Suc n - i) = m mod 2 ^ (Suc n - i)\n\ngoal (1 subgoal):\n 1. (1 \\<le> i \\<Longrightarrow>\n     bin_rep_aux (Suc n) m ! i =\n     m mod 2 ^ n mod 2 ^ (Suc n - i) div\n     2 ^ (Suc n - 1 - i)) \\<Longrightarrow>\n    bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  m mod 2 ^ n mod 2 ^ (Suc n - i) = m mod 2 ^ (Suc n - i)\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "using that f3"], ["proof (prove)\nusing this:\n  m mod 2 ^ n mod 2 ^ (Suc n - i) = m mod 2 ^ (Suc n - i)\n  1 \\<le> i\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i =\n  m mod 2 ^ n mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "by simp"], ["proof (state)\nthis:\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; 0 \\<le> m; i \\<le> n\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i =\n                                  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i);\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i =\n                      m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "using f1 f2"], ["proof (prove)\nusing this:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n  i = 0 \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i =\n  m mod 2 ^ n mod 2 ^ (n - (i - 1)) div 2 ^ (n - 1 - (i - 1))\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "using linorder_not_less"], ["proof (prove)\nusing this:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n  i = 0 \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i =\n  m mod 2 ^ n mod 2 ^ (n - (i - 1)) div 2 ^ (n - 1 - (i - 1))\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)", "by blast"], ["proof (state)\nthis:\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bin_rep_aux (Suc n) m ! i = m mod 2 ^ (Suc n - i) div 2 ^ (Suc n - 1 - i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_rep_aux_coeff:\n  fixes n m i:: nat\n  assumes \"m < 2^n\" and \"i \\<le> n\" and \"m \\<ge> 0\"\n  shows \"bin_rep_aux n m ! i = 0 \\<or> bin_rep_aux n m ! i = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rep_aux n m ! i = 0 \\<or> bin_rep_aux n m ! i = 1", "using assms"], ["proof (prove)\nusing this:\n  m < 2 ^ n\n  i \\<le> n\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. bin_rep_aux n m ! i = 0 \\<or> bin_rep_aux n m ! i = 1", "proof(induction n arbitrary: m i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m i.\n       \\<lbrakk>m < 2 ^ 0; i \\<le> 0; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux 0 m ! i = 0 \\<or>\n                         bin_rep_aux 0 m ! i = 1\n 2. \\<And>n m i.\n       \\<lbrakk>\\<And>m i.\n                   \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                     bin_rep_aux n m ! i = 1;\n        m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                         bin_rep_aux (Suc n) m ! i = 1", "case 0"], ["proof (state)\nthis:\n  m < 2 ^ 0\n  i \\<le> 0\n  0 \\<le> m\n\ngoal (2 subgoals):\n 1. \\<And>m i.\n       \\<lbrakk>m < 2 ^ 0; i \\<le> 0; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux 0 m ! i = 0 \\<or>\n                         bin_rep_aux 0 m ! i = 1\n 2. \\<And>n m i.\n       \\<lbrakk>\\<And>m i.\n                   \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                     bin_rep_aux n m ! i = 1;\n        m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                         bin_rep_aux (Suc n) m ! i = 1", "assume \"m < 2^0\" and \"i \\<le> 0\" and \"m \\<ge> 0\""], ["proof (state)\nthis:\n  m < 2 ^ 0\n  i \\<le> 0\n  0 \\<le> m\n\ngoal (2 subgoals):\n 1. \\<And>m i.\n       \\<lbrakk>m < 2 ^ 0; i \\<le> 0; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux 0 m ! i = 0 \\<or>\n                         bin_rep_aux 0 m ! i = 1\n 2. \\<And>n m i.\n       \\<lbrakk>\\<And>m i.\n                   \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                     bin_rep_aux n m ! i = 1;\n        m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                         bin_rep_aux (Suc n) m ! i = 1", "then"], ["proof (chain)\npicking this:\n  m < 2 ^ 0\n  i \\<le> 0\n  0 \\<le> m", "show \"bin_rep_aux 0 m ! i = 0 \\<or> bin_rep_aux 0 m ! i = 1\""], ["proof (prove)\nusing this:\n  m < 2 ^ 0\n  i \\<le> 0\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. bin_rep_aux 0 m ! i = 0 \\<or> bin_rep_aux 0 m ! i = 1", "by simp"], ["proof (state)\nthis:\n  bin_rep_aux 0 m ! i = 0 \\<or> bin_rep_aux 0 m ! i = 1\n\ngoal (1 subgoal):\n 1. \\<And>n m i.\n       \\<lbrakk>\\<And>m i.\n                   \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                     bin_rep_aux n m ! i = 1;\n        m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                         bin_rep_aux (Suc n) m ! i = 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m i.\n       \\<lbrakk>\\<And>m i.\n                   \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                     bin_rep_aux n m ! i = 1;\n        m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                         bin_rep_aux (Suc n) m ! i = 1", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>?m < 2 ^ n; ?i \\<le> n; 0 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> bin_rep_aux n ?m ! ?i = 0 \\<or>\n                    bin_rep_aux n ?m ! ?i = 1\n  m < 2 ^ Suc n\n  i \\<le> Suc n\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>n m i.\n       \\<lbrakk>\\<And>m i.\n                   \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                     bin_rep_aux n m ! i = 1;\n        m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                         bin_rep_aux (Suc n) m ! i = 1", "assume a0:\"\\<And>m i. m < 2 ^ n \\<Longrightarrow> i \\<le> n \\<Longrightarrow> m \\<ge> 0 \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or> bin_rep_aux n m ! i = 1\" \nand a1:\"m < 2^Suc n\" and a2:\"i \\<le> Suc n\" and a3:\"m \\<ge> 0\""], ["proof (state)\nthis:\n  \\<lbrakk>?m < 2 ^ n; ?i \\<le> n; 0 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> bin_rep_aux n ?m ! ?i = 0 \\<or>\n                    bin_rep_aux n ?m ! ?i = 1\n  m < 2 ^ Suc n\n  i \\<le> Suc n\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>n m i.\n       \\<lbrakk>\\<And>m i.\n                   \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                     bin_rep_aux n m ! i = 1;\n        m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                         bin_rep_aux (Suc n) m ! i = 1", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?m < 2 ^ n; ?i \\<le> n; 0 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> bin_rep_aux n ?m ! ?i = 0 \\<or>\n                    bin_rep_aux n ?m ! ?i = 1\n  m < 2 ^ Suc n\n  i \\<le> Suc n\n  0 \\<le> m", "show \"bin_rep_aux (Suc n) m ! i = 0 \\<or> bin_rep_aux (Suc n) m ! i = 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?m < 2 ^ n; ?i \\<le> n; 0 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> bin_rep_aux n ?m ! ?i = 0 \\<or>\n                    bin_rep_aux n ?m ! ?i = 1\n  m < 2 ^ Suc n\n  i \\<le> Suc n\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i = 0 \\<or> bin_rep_aux (Suc n) m ! i = 1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                  bin_rep_aux n m ! i = 1;\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                      bin_rep_aux (Suc n) m ! i = 1", "have \"bin_rep_aux (Suc n) m ! i = (m div 2^n # bin_rep_aux n (m mod 2^n)) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i =\n    (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i", "by simp"], ["proof (state)\nthis:\n  bin_rep_aux (Suc n) m ! i =\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                  bin_rep_aux n m ! i = 1;\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                      bin_rep_aux (Suc n) m ! i = 1", "moreover"], ["proof (state)\nthis:\n  bin_rep_aux (Suc n) m ! i =\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                  bin_rep_aux n m ! i = 1;\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                      bin_rep_aux (Suc n) m ! i = 1", "have \"\\<dots> = bin_rep_aux n (m mod 2^n) ! (i - 1)\" if \"i \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i =\n    bin_rep_aux n (m mod 2 ^ n) ! (i - 1)", "using that"], ["proof (prove)\nusing this:\n  1 \\<le> i\n\ngoal (1 subgoal):\n 1. (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i =\n    bin_rep_aux n (m mod 2 ^ n) ! (i - 1)", "by simp"], ["proof (state)\nthis:\n  1 \\<le> i \\<Longrightarrow>\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i =\n  bin_rep_aux n (m mod 2 ^ n) ! (i - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                  bin_rep_aux n m ! i = 1;\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                      bin_rep_aux (Suc n) m ! i = 1", "moreover"], ["proof (state)\nthis:\n  1 \\<le> i \\<Longrightarrow>\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i =\n  bin_rep_aux n (m mod 2 ^ n) ! (i - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                  bin_rep_aux n m ! i = 1;\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                      bin_rep_aux (Suc n) m ! i = 1", "have \"m mod 2^n < 2^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m mod 2 ^ n < 2 ^ n", "by simp"], ["proof (state)\nthis:\n  m mod 2 ^ n < 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                  bin_rep_aux n m ! i = 1;\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                      bin_rep_aux (Suc n) m ! i = 1", "ultimately"], ["proof (chain)\npicking this:\n  bin_rep_aux (Suc n) m ! i =\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i\n  1 \\<le> i \\<Longrightarrow>\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i =\n  bin_rep_aux n (m mod 2 ^ n) ! (i - 1)\n  m mod 2 ^ n < 2 ^ n", "have \"bin_rep_aux (Suc n) m ! i = 0 \\<or> bin_rep_aux (Suc n) m ! i = 1\" if \"i\\<ge>1\""], ["proof (prove)\nusing this:\n  bin_rep_aux (Suc n) m ! i =\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i\n  1 \\<le> i \\<Longrightarrow>\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i =\n  bin_rep_aux n (m mod 2 ^ n) ! (i - 1)\n  m mod 2 ^ n < 2 ^ n\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i = 0 \\<or> bin_rep_aux (Suc n) m ! i = 1", "using that a0[of \"m mod 2^n\" \"i-1\"] a2"], ["proof (prove)\nusing this:\n  bin_rep_aux (Suc n) m ! i =\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i\n  1 \\<le> i \\<Longrightarrow>\n  (m div 2 ^ n # bin_rep_aux n (m mod 2 ^ n)) ! i =\n  bin_rep_aux n (m mod 2 ^ n) ! (i - 1)\n  m mod 2 ^ n < 2 ^ n\n  1 \\<le> i\n  \\<lbrakk>m mod 2 ^ n < 2 ^ n; i - 1 \\<le> n; 0 \\<le> m mod 2 ^ n\\<rbrakk>\n  \\<Longrightarrow> bin_rep_aux n (m mod 2 ^ n) ! (i - 1) = 0 \\<or>\n                    bin_rep_aux n (m mod 2 ^ n) ! (i - 1) = 1\n  i \\<le> Suc n\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i = 0 \\<or> bin_rep_aux (Suc n) m ! i = 1", "by simp"], ["proof (state)\nthis:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = 0 \\<or> bin_rep_aux (Suc n) m ! i = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                  bin_rep_aux n m ! i = 1;\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                      bin_rep_aux (Suc n) m ! i = 1", "moreover"], ["proof (state)\nthis:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = 0 \\<or> bin_rep_aux (Suc n) m ! i = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                  bin_rep_aux n m ! i = 1;\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                      bin_rep_aux (Suc n) m ! i = 1", "have \"m div 2^n = 0 \\<or> m div 2^n = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m div 2 ^ n = 0 \\<or> m div 2 ^ n = 1", "using a1 a3 less_mult_imp_div_less"], ["proof (prove)\nusing this:\n  m < 2 ^ Suc n\n  0 \\<le> m\n  ?m < ?i * ?n \\<Longrightarrow> ?m div ?n < ?i\n\ngoal (1 subgoal):\n 1. m div 2 ^ n = 0 \\<or> m div 2 ^ n = 1", "by(simp add: less_2_cases)"], ["proof (state)\nthis:\n  m div 2 ^ n = 0 \\<or> m div 2 ^ n = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m i.\n                \\<lbrakk>m < 2 ^ n; i \\<le> n; 0 \\<le> m\\<rbrakk>\n                \\<Longrightarrow> bin_rep_aux n m ! i = 0 \\<or>\n                                  bin_rep_aux n m ! i = 1;\n     m < 2 ^ Suc n; i \\<le> Suc n; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> bin_rep_aux (Suc n) m ! i = 0 \\<or>\n                      bin_rep_aux (Suc n) m ! i = 1", "ultimately"], ["proof (chain)\npicking this:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = 0 \\<or> bin_rep_aux (Suc n) m ! i = 1\n  m div 2 ^ n = 0 \\<or> m div 2 ^ n = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> i \\<Longrightarrow>\n  bin_rep_aux (Suc n) m ! i = 0 \\<or> bin_rep_aux (Suc n) m ! i = 1\n  m div 2 ^ n = 0 \\<or> m div 2 ^ n = 1\n\ngoal (1 subgoal):\n 1. bin_rep_aux (Suc n) m ! i = 0 \\<or> bin_rep_aux (Suc n) m ! i = 1", "by (simp add: nth_Cons')"], ["proof (state)\nthis:\n  bin_rep_aux (Suc n) m ! i = 0 \\<or> bin_rep_aux (Suc n) m ! i = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bin_rep_aux (Suc n) m ! i = 0 \\<or> bin_rep_aux (Suc n) m ! i = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "definition bin_rep:: \"nat \\<Rightarrow> nat \\<Rightarrow> nat list\" where\n\"bin_rep n m = butlast (bin_rep_aux n m)\""], ["", "lemma length_of_bin_rep:\n  fixes n m:: nat\n  assumes \"m < 2^n\"\n  shows \"length (bin_rep n m) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bin_rep n m) = n", "using assms length_of_bin_rep_aux bin_rep_def"], ["proof (prove)\nusing this:\n  m < 2 ^ n\n  ?m < 2 ^ ?n \\<Longrightarrow> length (bin_rep_aux ?n ?m) = ?n + 1\n  bin_rep ?n ?m = butlast (bin_rep_aux ?n ?m)\n\ngoal (1 subgoal):\n 1. length (bin_rep n m) = n", "by simp"], ["", "lemma bin_rep_coeff:\n  fixes n m i:: nat\n  assumes \"m < 2^n\" and \"i < n\" and \"m \\<ge> 0\"\n  shows \"bin_rep n m ! i = 0 \\<or> bin_rep n m ! i = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rep n m ! i = 0 \\<or> bin_rep n m ! i = 1", "using assms bin_rep_def bin_rep_aux_coeff length_of_bin_rep"], ["proof (prove)\nusing this:\n  m < 2 ^ n\n  i < n\n  0 \\<le> m\n  bin_rep ?n ?m = butlast (bin_rep_aux ?n ?m)\n  \\<lbrakk>?m < 2 ^ ?n; ?i \\<le> ?n; 0 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> bin_rep_aux ?n ?m ! ?i = 0 \\<or>\n                    bin_rep_aux ?n ?m ! ?i = 1\n  ?m < 2 ^ ?n \\<Longrightarrow> length (bin_rep ?n ?m) = ?n\n\ngoal (1 subgoal):\n 1. bin_rep n m ! i = 0 \\<or> bin_rep n m ! i = 1", "by(simp add: nth_butlast)"], ["", "lemma bin_rep_index:\n  fixes n m i:: nat\n  assumes \"n \\<ge> 1\" and \"m < 2^n\" and \"i < n\" and \"m \\<ge> 0\"\n  shows \"bin_rep n m ! i = (m mod 2^(n-i)) div 2^(n-1-i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rep n m ! i = m mod 2 ^ (n - i) div 2 ^ (n - 1 - i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. bin_rep n m ! i = m mod 2 ^ (n - i) div 2 ^ (n - 1 - i)", "have \"bin_rep n m ! i = bin_rep_aux n m ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rep n m ! i = bin_rep_aux n m ! i", "using bin_rep_def length_of_bin_rep nth_butlast assms(3)"], ["proof (prove)\nusing this:\n  bin_rep ?n ?m = butlast (bin_rep_aux ?n ?m)\n  ?m < 2 ^ ?n \\<Longrightarrow> length (bin_rep ?n ?m) = ?n\n  ?n < length (butlast ?xs) \\<Longrightarrow> butlast ?xs ! ?n = ?xs ! ?n\n  i < n\n\ngoal (1 subgoal):\n 1. bin_rep n m ! i = bin_rep_aux n m ! i", "by (simp add: nth_butlast assms(2))"], ["proof (state)\nthis:\n  bin_rep n m ! i = bin_rep_aux n m ! i\n\ngoal (1 subgoal):\n 1. bin_rep n m ! i = m mod 2 ^ (n - i) div 2 ^ (n - 1 - i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  bin_rep n m ! i = bin_rep_aux n m ! i\n\ngoal (1 subgoal):\n 1. bin_rep n m ! i = m mod 2 ^ (n - i) div 2 ^ (n - 1 - i)", "using assms bin_rep_aux_index"], ["proof (prove)\nusing this:\n  bin_rep n m ! i = bin_rep_aux n m ! i\n  1 \\<le> n\n  m < 2 ^ n\n  i < n\n  0 \\<le> m\n  \\<lbrakk>1 \\<le> ?n; ?m < 2 ^ ?n; 0 \\<le> ?m; ?i \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> bin_rep_aux ?n ?m ! ?i =\n                    ?m mod 2 ^ (?n - ?i) div 2 ^ (?n - 1 - ?i)\n\ngoal (1 subgoal):\n 1. bin_rep n m ! i = m mod 2 ^ (n - i) div 2 ^ (n - 1 - i)", "by simp"], ["proof (state)\nthis:\n  bin_rep n m ! i = m mod 2 ^ (n - i) div 2 ^ (n - 1 - i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_rep_eq:\n  fixes n m:: nat \n  assumes \"n \\<ge> 1\" and \"m \\<ge> 0\" and \"m < 2^n\" and \"m \\<ge> 0\"\n  shows \"m = (\\<Sum>i<n. bin_rep n m ! i * 2^(n-1-i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "fix i:: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "assume \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "then"], ["proof (chain)\npicking this:\n  i < n", "have \"bin_rep n m ! i * 2^(n-1-i) = (m mod 2^(n-i)) div 2^(n-1-i) * 2^(n-1-i)\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. bin_rep n m ! i * 2 ^ (n - 1 - i) =\n    m mod 2 ^ (n - i) div 2 ^ (n - 1 - i) * 2 ^ (n - 1 - i)", "using assms bin_rep_index"], ["proof (prove)\nusing this:\n  i < n\n  1 \\<le> n\n  0 \\<le> m\n  m < 2 ^ n\n  0 \\<le> m\n  \\<lbrakk>1 \\<le> ?n; ?m < 2 ^ ?n; ?i < ?n; 0 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> bin_rep ?n ?m ! ?i =\n                    ?m mod 2 ^ (?n - ?i) div 2 ^ (?n - 1 - ?i)\n\ngoal (1 subgoal):\n 1. bin_rep n m ! i * 2 ^ (n - 1 - i) =\n    m mod 2 ^ (n - i) div 2 ^ (n - 1 - i) * 2 ^ (n - 1 - i)", "by simp"], ["proof (state)\nthis:\n  bin_rep n m ! i * 2 ^ (n - 1 - i) =\n  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i) * 2 ^ (n - 1 - i)\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "moreover"], ["proof (state)\nthis:\n  bin_rep n m ! i * 2 ^ (n - 1 - i) =\n  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i) * 2 ^ (n - 1 - i)\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "have \"\\<dots> = m mod 2^(n-i) - m mod 2^(n-i) mod 2^(n-1-i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m mod 2 ^ (n - i) div 2 ^ (n - 1 - i) * 2 ^ (n - 1 - i) =\n    m mod 2 ^ (n - i) - m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)", "by (simp add: minus_mod_eq_div_mult)"], ["proof (state)\nthis:\n  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i) * 2 ^ (n - 1 - i) =\n  m mod 2 ^ (n - i) - m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "moreover"], ["proof (state)\nthis:\n  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i) * 2 ^ (n - 1 - i) =\n  m mod 2 ^ (n - i) - m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "have \"\\<dots> = int(m mod 2^(n-i)) - m mod 2^(n-i) mod 2^(n-1-i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (m mod 2 ^ (n - i) - m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)) =\n    int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i))", "using mod_less_eq_dividend of_nat_diff"], ["proof (prove)\nusing this:\n  ?m mod ?n \\<le> ?m\n  ?n \\<le> ?m \\<Longrightarrow> of_nat (?m - ?n) = of_nat ?m - of_nat ?n\n\ngoal (1 subgoal):\n 1. int (m mod 2 ^ (n - i) - m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)) =\n    int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i))", "by blast"], ["proof (state)\nthis:\n  int (m mod 2 ^ (n - i) - m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)) =\n  int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i))\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "moreover"], ["proof (state)\nthis:\n  int (m mod 2 ^ (n - i) - m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)) =\n  int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i))\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "have \"\\<dots> = int(m mod 2^(n-i)) - m mod 2^(n-1-i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)) =\n    int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))", "using mod_mod_power_cancel[of \"n-1-i\" \"n-i\"]"], ["proof (prove)\nusing this:\n  n - 1 - i \\<le> n - i \\<Longrightarrow>\n  ?p mod 2 ^ (n - i) mod 2 ^ (n - 1 - i) = ?p mod 2 ^ (n - 1 - i)\n\ngoal (1 subgoal):\n 1. int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)) =\n    int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))", "by (simp add: dvd_power_le mod_mod_cancel)"], ["proof (state)\nthis:\n  int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)) =\n  int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "ultimately"], ["proof (chain)\npicking this:\n  bin_rep n m ! i * 2 ^ (n - 1 - i) =\n  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i) * 2 ^ (n - 1 - i)\n  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i) * 2 ^ (n - 1 - i) =\n  m mod 2 ^ (n - i) - m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)\n  int (m mod 2 ^ (n - i) - m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)) =\n  int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i))\n  int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)) =\n  int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))", "have \"bin_rep n m ! i * 2^(n-1-i) = int (m mod 2^(n-i)) - m mod 2^(n-1-i)\""], ["proof (prove)\nusing this:\n  bin_rep n m ! i * 2 ^ (n - 1 - i) =\n  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i) * 2 ^ (n - 1 - i)\n  m mod 2 ^ (n - i) div 2 ^ (n - 1 - i) * 2 ^ (n - 1 - i) =\n  m mod 2 ^ (n - i) - m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)\n  int (m mod 2 ^ (n - i) - m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)) =\n  int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i))\n  int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - i) mod 2 ^ (n - 1 - i)) =\n  int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))\n\ngoal (1 subgoal):\n 1. int (bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n    int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))", "by presburger"], ["proof (state)\nthis:\n  int (bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n  int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "}"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow>\n  int (bin_rep n m ! ?i2 * 2 ^ (n - 1 - ?i2)) =\n  int (m mod 2 ^ (n - ?i2)) - int (m mod 2 ^ (n - 1 - ?i2))\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "then"], ["proof (chain)\npicking this:\n  ?i2 < n \\<Longrightarrow>\n  int (bin_rep n m ! ?i2 * 2 ^ (n - 1 - ?i2)) =\n  int (m mod 2 ^ (n - ?i2)) - int (m mod 2 ^ (n - 1 - ?i2))", "have f0:\"(\\<Sum>i<n. bin_rep n m ! i * 2^(n-1-i)) = (\\<Sum>i<n. int (m mod 2^(n-i)) - m mod 2^(n-1-i))\""], ["proof (prove)\nusing this:\n  ?i2 < n \\<Longrightarrow>\n  int (bin_rep n m ! ?i2 * 2 ^ (n - 1 - ?i2)) =\n  int (m mod 2 ^ (n - ?i2)) - int (m mod 2 ^ (n - 1 - ?i2))\n\ngoal (1 subgoal):\n 1. int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n    (\\<Sum>i<n. int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i)))", "by auto"], ["proof (state)\nthis:\n  int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n  (\\<Sum>i<n. int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i)))\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n  (\\<Sum>i<n. int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i)))\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n    (\\<Sum>i<n.\n        int (m mod 2 ^ (n - i)) -\n        int (m mod 2 ^ (n - 1 - i))) \\<Longrightarrow>\n    m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "have \"(\\<Sum>i<n. int ((m::nat) mod 2^(n - i)) - (m mod 2^(n - 1 - i))) = \n          (\\<Sum>i<n. ( m mod 2^(n - i))) -  (\\<Sum>i<n. int (m mod 2^(n - 1 - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))) =\n    int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n    (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i)))", "using sum_subtractf[of \"(\\<lambda>i. (m mod 2^(n-i)))::nat\\<Rightarrow>nat\" \"(\\<lambda>i. (m mod 2^(n-1-i)))::nat\\<Rightarrow>nat\" \"{..<(n::nat)}\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>x<n. int (m mod 2 ^ (n - x)) - int (m mod 2 ^ (n - 1 - x))) =\n  (\\<Sum>x<n. int (m mod 2 ^ (n - x))) -\n  (\\<Sum>x<n. int (m mod 2 ^ (n - 1 - x)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))) =\n    int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n    (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i)))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n. int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))) =\n  int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n  (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i)))\n\ngoal (1 subgoal):\n 1. int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n    (\\<Sum>i<n.\n        int (m mod 2 ^ (n - i)) -\n        int (m mod 2 ^ (n - 1 - i))) \\<Longrightarrow>\n    m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>i<n. int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))) =\n  int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n  (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i)))\n\ngoal (1 subgoal):\n 1. int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n    (\\<Sum>i<n.\n        int (m mod 2 ^ (n - i)) -\n        int (m mod 2 ^ (n - 1 - i))) \\<Longrightarrow>\n    m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "have \"\\<dots> = m mod 2^n + (\\<Sum>i\\<in>{1..<n}. (m mod 2^(n-i))) - (\\<Sum>i<n-1. int (m mod 2^(n-1-i)))- m mod 2^0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n    (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i))) =\n    int (m mod 2 ^ n + (\\<Sum>i = 1..<n. m mod 2 ^ (n - i))) -\n    (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n    int (m mod 2 ^ 0)", "using sum.atLeast_Suc_atMost sum.lessThan_Suc assms(1)"], ["proof (prove)\nusing this:\n  ?m \\<le> ?n \\<Longrightarrow>\n  sum ?g {?m..?n} = ?g ?m + sum ?g {Suc ?m..?n}\n  sum ?g {..<Suc ?n} = sum ?g {..<?n} + ?g ?n\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n    (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i))) =\n    int (m mod 2 ^ n + (\\<Sum>i = 1..<n. m mod 2 ^ (n - i))) -\n    (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n    int (m mod 2 ^ 0)", "by (smt One_nat_def Suc_le_eq diff_self_eq_0 le_add_diff_inverse lessThan_atLeast0 minus_nat.diff_0 \n          plus_1_eq_Suc sum.atLeast_Suc_lessThan)"], ["proof (state)\nthis:\n  int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n  (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i))) =\n  int (m mod 2 ^ n + (\\<Sum>i = 1..<n. m mod 2 ^ (n - i))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n    (\\<Sum>i<n.\n        int (m mod 2 ^ (n - i)) -\n        int (m mod 2 ^ (n - 1 - i))) \\<Longrightarrow>\n    m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "moreover"], ["proof (state)\nthis:\n  int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n  (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i))) =\n  int (m mod 2 ^ n + (\\<Sum>i = 1..<n. m mod 2 ^ (n - i))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n    (\\<Sum>i<n.\n        int (m mod 2 ^ (n - i)) -\n        int (m mod 2 ^ (n - 1 - i))) \\<Longrightarrow>\n    m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "have \"\\<dots> = m mod 2^n + (\\<Sum>i<n-1. m mod 2^(n-i-1)) - (\\<Sum>i<n-1. int ( m mod 2^(n-1-i))) - m mod 2^0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (m mod 2 ^ n + (\\<Sum>i = 1..<n. m mod 2 ^ (n - i))) -\n    (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n    int (m mod 2 ^ 0) =\n    int (m mod 2 ^ n + (\\<Sum>i<n - 1. m mod 2 ^ (n - i - 1))) -\n    (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n    int (m mod 2 ^ 0)", "apply (auto simp add: sum_of_index_diff[of \"\\<lambda>i. m mod 2 ^ (n - 1 - i)\" \"1\" \"n-1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = Suc 0..<n. int (m mod 2 ^ (n - x))) =\n    (\\<Sum>i<n - Suc 0. int (m mod 2 ^ (n - Suc i)))", "by (smt One_nat_def assms(1) le_add_diff_inverse lessThan_atLeast0 plus_1_eq_Suc sum.cong sum.shift_bounds_Suc_ivl)"], ["proof (state)\nthis:\n  int (m mod 2 ^ n + (\\<Sum>i = 1..<n. m mod 2 ^ (n - i))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0) =\n  int (m mod 2 ^ n + (\\<Sum>i<n - 1. m mod 2 ^ (n - i - 1))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n    (\\<Sum>i<n.\n        int (m mod 2 ^ (n - i)) -\n        int (m mod 2 ^ (n - 1 - i))) \\<Longrightarrow>\n    m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "moreover"], ["proof (state)\nthis:\n  int (m mod 2 ^ n + (\\<Sum>i = 1..<n. m mod 2 ^ (n - i))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0) =\n  int (m mod 2 ^ n + (\\<Sum>i<n - 1. m mod 2 ^ (n - i - 1))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n    (\\<Sum>i<n.\n        int (m mod 2 ^ (n - i)) -\n        int (m mod 2 ^ (n - 1 - i))) \\<Longrightarrow>\n    m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "have \"\\<dots> = m mod 2^n - m mod 2^0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (m mod 2 ^ n + (\\<Sum>i<n - 1. m mod 2 ^ (n - i - 1))) -\n    (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n    int (m mod 2 ^ 0) =\n    int (m mod 2 ^ n - m mod 2 ^ 0)", "by simp"], ["proof (state)\nthis:\n  int (m mod 2 ^ n + (\\<Sum>i<n - 1. m mod 2 ^ (n - i - 1))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0) =\n  int (m mod 2 ^ n - m mod 2 ^ 0)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n    (\\<Sum>i<n.\n        int (m mod 2 ^ (n - i)) -\n        int (m mod 2 ^ (n - 1 - i))) \\<Longrightarrow>\n    m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "moreover"], ["proof (state)\nthis:\n  int (m mod 2 ^ n + (\\<Sum>i<n - 1. m mod 2 ^ (n - i - 1))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0) =\n  int (m mod 2 ^ n - m mod 2 ^ 0)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n    (\\<Sum>i<n.\n        int (m mod 2 ^ (n - i)) -\n        int (m mod 2 ^ (n - 1 - i))) \\<Longrightarrow>\n    m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "have \"\\<dots> = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (m mod 2 ^ n - m mod 2 ^ 0) = int m", "using assms"], ["proof (prove)\nusing this:\n  1 \\<le> n\n  0 \\<le> m\n  m < 2 ^ n\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. int (m mod 2 ^ n - m mod 2 ^ 0) = int m", "by auto"], ["proof (state)\nthis:\n  int (m mod 2 ^ n - m mod 2 ^ 0) = int m\n\ngoal (1 subgoal):\n 1. int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n    (\\<Sum>i<n.\n        int (m mod 2 ^ (n - i)) -\n        int (m mod 2 ^ (n - 1 - i))) \\<Longrightarrow>\n    m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>i<n. int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))) =\n  int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n  (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i)))\n  int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n  (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i))) =\n  int (m mod 2 ^ n + (\\<Sum>i = 1..<n. m mod 2 ^ (n - i))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0)\n  int (m mod 2 ^ n + (\\<Sum>i = 1..<n. m mod 2 ^ (n - i))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0) =\n  int (m mod 2 ^ n + (\\<Sum>i<n - 1. m mod 2 ^ (n - i - 1))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0)\n  int (m mod 2 ^ n + (\\<Sum>i<n - 1. m mod 2 ^ (n - i - 1))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0) =\n  int (m mod 2 ^ n - m mod 2 ^ 0)\n  int (m mod 2 ^ n - m mod 2 ^ 0) = int m", "show \"m = (\\<Sum>i<n. bin_rep n m ! i * 2^(n-1-i))\""], ["proof (prove)\nusing this:\n  (\\<Sum>i<n. int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))) =\n  int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n  (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i)))\n  int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n  (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i))) =\n  int (m mod 2 ^ n + (\\<Sum>i = 1..<n. m mod 2 ^ (n - i))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0)\n  int (m mod 2 ^ n + (\\<Sum>i = 1..<n. m mod 2 ^ (n - i))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0) =\n  int (m mod 2 ^ n + (\\<Sum>i<n - 1. m mod 2 ^ (n - i - 1))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0)\n  int (m mod 2 ^ n + (\\<Sum>i<n - 1. m mod 2 ^ (n - i - 1))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0) =\n  int (m mod 2 ^ n - m mod 2 ^ 0)\n  int (m mod 2 ^ n - m mod 2 ^ 0) = int m\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "using assms f0"], ["proof (prove)\nusing this:\n  (\\<Sum>i<n. int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i))) =\n  int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n  (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i)))\n  int (\\<Sum>i<n. m mod 2 ^ (n - i)) -\n  (\\<Sum>i<n. int (m mod 2 ^ (n - 1 - i))) =\n  int (m mod 2 ^ n + (\\<Sum>i = 1..<n. m mod 2 ^ (n - i))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0)\n  int (m mod 2 ^ n + (\\<Sum>i = 1..<n. m mod 2 ^ (n - i))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0) =\n  int (m mod 2 ^ n + (\\<Sum>i<n - 1. m mod 2 ^ (n - i - 1))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0)\n  int (m mod 2 ^ n + (\\<Sum>i<n - 1. m mod 2 ^ (n - i - 1))) -\n  (\\<Sum>i<n - 1. int (m mod 2 ^ (n - 1 - i))) -\n  int (m mod 2 ^ 0) =\n  int (m mod 2 ^ n - m mod 2 ^ 0)\n  int (m mod 2 ^ n - m mod 2 ^ 0) = int m\n  1 \\<le> n\n  0 \\<le> m\n  m < 2 ^ n\n  0 \\<le> m\n  int (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i)) =\n  (\\<Sum>i<n. int (m mod 2 ^ (n - i)) - int (m mod 2 ^ (n - 1 - i)))\n\ngoal (1 subgoal):\n 1. m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))", "by linarith"], ["proof (state)\nthis:\n  m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m = (\\<Sum>i<n. bin_rep n m ! i * 2 ^ (n - 1 - i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_rep_index_0:\n  fixes n m:: nat\n  assumes \"m < 2^n\" and \"k > n\"\n  shows \"(bin_rep k m) ! 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "have \"m < 2^(k-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < 2 ^ (k - 1)", "using assms"], ["proof (prove)\nusing this:\n  m < 2 ^ n\n  n < k\n\ngoal (1 subgoal):\n 1. m < 2 ^ (k - 1)", "by(smt Suc_diff_1 Suc_leI gr0I le_trans less_or_eq_imp_le linorder_neqE_nat not_less \none_less_numeral_iff power_strict_increasing semiring_norm(76))"], ["proof (state)\nthis:\n  m < 2 ^ (k - 1)\n\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "then"], ["proof (chain)\npicking this:\n  m < 2 ^ (k - 1)", "have f:\"m div 2^(k-1) = 0\""], ["proof (prove)\nusing this:\n  m < 2 ^ (k - 1)\n\ngoal (1 subgoal):\n 1. m div 2 ^ (k - 1) = 0", "by auto"], ["proof (state)\nthis:\n  m div 2 ^ (k - 1) = 0\n\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "have \"k \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> k", "using assms(2)"], ["proof (prove)\nusing this:\n  n < k\n\ngoal (1 subgoal):\n 1. 1 \\<le> k", "by simp"], ["proof (state)\nthis:\n  1 \\<le> k\n\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "moreover"], ["proof (state)\nthis:\n  1 \\<le> k\n\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "have \"bin_rep_aux k m = (m div 2^(k-1)) # (bin_rep_aux (k-1) (m mod 2^(k-1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rep_aux k m =\n    m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))", "using bin_rep_aux.simps(2)"], ["proof (prove)\nusing this:\n  bin_rep_aux (Suc ?n) ?m = ?m div 2 ^ ?n # bin_rep_aux ?n (?m mod 2 ^ ?n)\n\ngoal (1 subgoal):\n 1. bin_rep_aux k m =\n    m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))", "by(metis Suc_diff_1 assms(2) diff_0_eq_0 neq0_conv zero_less_diff)"], ["proof (state)\nthis:\n  bin_rep_aux k m =\n  m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))\n\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "moreover"], ["proof (state)\nthis:\n  bin_rep_aux k m =\n  m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))\n\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "have \"bin_rep k m = butlast ((m div 2^(k-1)) # (bin_rep_aux (k-1) (m mod 2^(k-1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rep k m =\n    butlast (m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))", "using bin_rep_def"], ["proof (prove)\nusing this:\n  bin_rep ?n ?m = butlast (bin_rep_aux ?n ?m)\n\ngoal (1 subgoal):\n 1. bin_rep k m =\n    butlast (m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))", "by (simp add: calculation(2))"], ["proof (state)\nthis:\n  bin_rep k m =\n  butlast (m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))\n\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "moreover"], ["proof (state)\nthis:\n  bin_rep k m =\n  butlast (m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))\n\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "have \"\\<dots> = butlast (0 # (bin_rep_aux (k-1) (m mod 2^(k-1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))) =\n    butlast (0 # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))", "using f"], ["proof (prove)\nusing this:\n  m div 2 ^ (k - 1) = 0\n\ngoal (1 subgoal):\n 1. butlast (m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))) =\n    butlast (0 # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))", "by simp"], ["proof (state)\nthis:\n  butlast (m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))) =\n  butlast (0 # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))\n\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "moreover"], ["proof (state)\nthis:\n  butlast (m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))) =\n  butlast (0 # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))\n\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "have \"\\<dots> = 0 # butlast (bin_rep_aux (k-1) (m mod 2^(k-1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (0 # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))) =\n    0 # butlast (bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))", "by(simp add: bin_rep_aux_neq_nil)"], ["proof (state)\nthis:\n  butlast (0 # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))) =\n  0 # butlast (bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))\n\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "ultimately"], ["proof (chain)\npicking this:\n  1 \\<le> k\n  bin_rep_aux k m =\n  m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))\n  bin_rep k m =\n  butlast (m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))\n  butlast (m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))) =\n  butlast (0 # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))\n  butlast (0 # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))) =\n  0 # butlast (bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> k\n  bin_rep_aux k m =\n  m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))\n  bin_rep k m =\n  butlast (m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))\n  butlast (m div 2 ^ (k - 1) # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))) =\n  butlast (0 # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))\n  butlast (0 # bin_rep_aux (k - 1) (m mod 2 ^ (k - 1))) =\n  0 # butlast (bin_rep_aux (k - 1) (m mod 2 ^ (k - 1)))\n\ngoal (1 subgoal):\n 1. bin_rep k m ! 0 = 0", "by simp"], ["proof (state)\nthis:\n  bin_rep k m ! 0 = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_rep_index_0_geq:\n  fixes n m:: nat\n  assumes \"m \\<ge> 2^n\" and \"m < 2^(n+1)\"\n  shows \"bin_rep (n+1) m ! 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rep (n + 1) m ! 0 = 1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. bin_rep (n + 1) m ! 0 = 1", "have \"bin_rep (Suc n) m =  butlast (bin_rep_aux (Suc n) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rep (Suc n) m = butlast (bin_rep_aux (Suc n) m)", "using bin_rep_def"], ["proof (prove)\nusing this:\n  bin_rep ?n ?m = butlast (bin_rep_aux ?n ?m)\n\ngoal (1 subgoal):\n 1. bin_rep (Suc n) m = butlast (bin_rep_aux (Suc n) m)", "by simp"], ["proof (state)\nthis:\n  bin_rep (Suc n) m = butlast (bin_rep_aux (Suc n) m)\n\ngoal (1 subgoal):\n 1. bin_rep (n + 1) m ! 0 = 1", "moreover"], ["proof (state)\nthis:\n  bin_rep (Suc n) m = butlast (bin_rep_aux (Suc n) m)\n\ngoal (1 subgoal):\n 1. bin_rep (n + 1) m ! 0 = 1", "have \"\\<dots> = butlast (1 # (bin_rep_aux n (m mod 2^n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (bin_rep_aux (Suc n) m) =\n    butlast (1 # bin_rep_aux n (m mod 2 ^ n))", "using assms bin_rep_aux_def"], ["proof (prove)\nusing this:\n  2 ^ n \\<le> m\n  m < 2 ^ (n + 1)\n  bin_rep_aux \\<equiv>\n  rec_nat (\\<lambda>m. [m])\n   (\\<lambda>n na m. m div 2 ^ n # na (m mod 2 ^ n))\n\ngoal (1 subgoal):\n 1. butlast (bin_rep_aux (Suc n) m) =\n    butlast (1 # bin_rep_aux n (m mod 2 ^ n))", "by simp"], ["proof (state)\nthis:\n  butlast (bin_rep_aux (Suc n) m) =\n  butlast (1 # bin_rep_aux n (m mod 2 ^ n))\n\ngoal (1 subgoal):\n 1. bin_rep (n + 1) m ! 0 = 1", "moreover"], ["proof (state)\nthis:\n  butlast (bin_rep_aux (Suc n) m) =\n  butlast (1 # bin_rep_aux n (m mod 2 ^ n))\n\ngoal (1 subgoal):\n 1. bin_rep (n + 1) m ! 0 = 1", "have \"\\<dots> = 1 # butlast (bin_rep_aux n (m mod 2^n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (1 # bin_rep_aux n (m mod 2 ^ n)) =\n    1 # butlast (bin_rep_aux n (m mod 2 ^ n))", "by (simp add: bin_rep_aux_neq_nil)"], ["proof (state)\nthis:\n  butlast (1 # bin_rep_aux n (m mod 2 ^ n)) =\n  1 # butlast (bin_rep_aux n (m mod 2 ^ n))\n\ngoal (1 subgoal):\n 1. bin_rep (n + 1) m ! 0 = 1", "ultimately"], ["proof (chain)\npicking this:\n  bin_rep (Suc n) m = butlast (bin_rep_aux (Suc n) m)\n  butlast (bin_rep_aux (Suc n) m) =\n  butlast (1 # bin_rep_aux n (m mod 2 ^ n))\n  butlast (1 # bin_rep_aux n (m mod 2 ^ n)) =\n  1 # butlast (bin_rep_aux n (m mod 2 ^ n))", "show ?thesis"], ["proof (prove)\nusing this:\n  bin_rep (Suc n) m = butlast (bin_rep_aux (Suc n) m)\n  butlast (bin_rep_aux (Suc n) m) =\n  butlast (1 # bin_rep_aux n (m mod 2 ^ n))\n  butlast (1 # bin_rep_aux n (m mod 2 ^ n)) =\n  1 # butlast (bin_rep_aux n (m mod 2 ^ n))\n\ngoal (1 subgoal):\n 1. bin_rep (n + 1) m ! 0 = 1", "by (simp add: bin_rep_aux_neq_nil)"], ["proof (state)\nthis:\n  bin_rep (n + 1) m ! 0 = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}