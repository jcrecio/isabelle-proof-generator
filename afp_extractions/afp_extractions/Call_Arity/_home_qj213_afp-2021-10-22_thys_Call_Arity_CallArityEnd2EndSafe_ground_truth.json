{"file_name": "/home/qj213/afp-2021-10-22/thys/Call_Arity/CallArityEnd2EndSafe.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Call_Arity", "problem_names": ["lemma end2end:\n  \"c \\<Rightarrow>\\<^sup>* c' \\<Longrightarrow>\n  \\<not> boring_step c' \\<Longrightarrow>\n  heap_upds_ok_conf c \\<Longrightarrow>\n  consistent (ae, ce, a, as, r) c \\<Longrightarrow>\n  \\<exists>ae' ce' a' as' r'. consistent  (ae', ce', a', as', r') c' \\<and> conf_transform  (ae, ce, a, as, r) c \\<Rightarrow>\\<^sub>G\\<^sup>* conf_transform  (ae', ce', a', as', r') c'\"", "theorem end2end_closed:\n  assumes closed: \"fv e = ({} :: var set)\"\n  assumes \"([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>,v,[])\" and \"isVal v\"\n  obtains \\<Gamma>' and v'\n  where \"([], \\<T>\\<^bsub>0\\<^esub> e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>',v',[])\" and \"isVal v'\"\n    and \"card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\"", "lemma fresh_var_eqE[elim_format]: \"fresh_var e = x \\<Longrightarrow> x \\<notin>  fv e\"", "lemma example1:\n  fixes e :: exp\n  fixes f g x y z :: var\n  assumes Aexp_e: \"\\<And>a. Aexp e\\<cdot>a = esing x\\<cdot>(up\\<cdot>a) \\<squnion> esing y\\<cdot>(up\\<cdot>a)\"\n  assumes ccExp_e: \"\\<And>a. CCexp e\\<cdot>a = \\<bottom>\"\n  assumes [simp]: \"transform 1 e = e\"\n  assumes \"isVal e\"\n  assumes disj: \"y \\<noteq> f\" \"y \\<noteq> g\" \"x \\<noteq> y\" \"z \\<noteq> f\" \"z \\<noteq> g\" \"y \\<noteq> x\"\n  assumes fresh: \"atom z \\<sharp> e\"\n  shows \"transform 1 (let y be  App (Var f) g in (let x be e in (Var x))) = \n         let y be (Lam [z]. App (App (Var f) g) z) in (let x be (Lam [z]. App e z) in (Var x))\""], "translations": [["", "lemma end2end:\n  \"c \\<Rightarrow>\\<^sup>* c' \\<Longrightarrow>\n  \\<not> boring_step c' \\<Longrightarrow>\n  heap_upds_ok_conf c \\<Longrightarrow>\n  consistent (ae, ce, a, as, r) c \\<Longrightarrow>\n  \\<exists>ae' ce' a' as' r'. consistent  (ae', ce', a', as', r') c' \\<and> conf_transform  (ae, ce, a, as, r) c \\<Rightarrow>\\<^sub>G\\<^sup>* conf_transform  (ae', ce', a', as', r') c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<Rightarrow>\\<^sup>* c'; \\<not> boring_step c';\n     heap_upds_ok_conf c; consistent (ae, ce, a, as, r) c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ae' ce' a' as' r'.\n                         consistent (ae', ce', a', as', r') c' \\<and>\n                         conf_transform (ae, ce, a, as, r)\n                          c \\<Rightarrow>\\<^sub>G\\<^sup>*\n                         conf_transform (ae', ce', a', as', r') c'", "by (rule card_arity_transform_safe)"], ["", "theorem end2end_closed:\n  assumes closed: \"fv e = ({} :: var set)\"\n  assumes \"([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>,v,[])\" and \"isVal v\"\n  obtains \\<Gamma>' and v'\n  where \"([], \\<T>\\<^bsub>0\\<^esub> e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>',v',[])\" and \"isVal v'\"\n    and \"card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note assms(2)"], ["proof (state)\nthis:\n  ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>, v, [])\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>, v, [])\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<not> boring_step (\\<Gamma>,v,[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> boring_step (\\<Gamma>, v, [])", "by (simp add: boring_step.simps)"], ["proof (state)\nthis:\n  \\<not> boring_step (\\<Gamma>, v, [])\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<not> boring_step (\\<Gamma>, v, [])\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"heap_upds_ok_conf ([], e, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok_conf ([], e, [])", "by simp"], ["proof (state)\nthis:\n  heap_upds_ok_conf ([], e, [])\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  heap_upds_ok_conf ([], e, [])\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"consistent (\\<bottom>,\\<bottom>,0,[],[]) ([], e, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (\\<bottom>, \\<bottom>, 0, [], []) ([], e, [])", "using closed"], ["proof (prove)\nusing this:\n  fv e = {}\n\ngoal (1 subgoal):\n 1. consistent (\\<bottom>, \\<bottom>, 0, [], []) ([], e, [])", "by (rule closed_consistent)"], ["proof (state)\nthis:\n  consistent (\\<bottom>, \\<bottom>, 0, [], []) ([], e, [])\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>, v, [])\n  \\<not> boring_step (\\<Gamma>, v, [])\n  heap_upds_ok_conf ([], e, [])\n  consistent (\\<bottom>, \\<bottom>, 0, [], []) ([], e, [])", "obtain ae ce a as r where\n    *: \"consistent  (ae, ce, a, as, r) (\\<Gamma>,v,[])\" and\n    **: \"conf_transform  (\\<bottom>, \\<bottom>, 0, [], []) ([],e,[]) \\<Rightarrow>\\<^sub>G\\<^sup>* conf_transform (ae, ce, a, as, r) (\\<Gamma>,v,[])\""], ["proof (prove)\nusing this:\n  ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>, v, [])\n  \\<not> boring_step (\\<Gamma>, v, [])\n  heap_upds_ok_conf ([], e, [])\n  consistent (\\<bottom>, \\<bottom>, 0, [], []) ([], e, [])\n\ngoal (1 subgoal):\n 1. (\\<And>ae ce a as r.\n        \\<lbrakk>consistent (ae, ce, a, as, r) (\\<Gamma>, v, []);\n         conf_transform (\\<bottom>, \\<bottom>, 0, [], [])\n          ([], e, []) \\<Rightarrow>\\<^sub>G\\<^sup>*\n         conf_transform (ae, ce, a, as, r) (\\<Gamma>, v, [])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis end2end)"], ["proof (state)\nthis:\n  consistent (ae, ce, a, as, r) (\\<Gamma>, v, [])\n  conf_transform (\\<bottom>, \\<bottom>, 0, [], [])\n   ([], e, []) \\<Rightarrow>\\<^sub>G\\<^sup>*\n  conf_transform (ae, ce, a, as, r) (\\<Gamma>, v, [])\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?\\<Gamma> = \"map_transform Aeta_expand ae (map_transform transform ae (restrictA (-set r) \\<Gamma>))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?v = \"transform a v\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from *"], ["proof (chain)\npicking this:\n  consistent (ae, ce, a, as, r) (\\<Gamma>, v, [])", "have \"set r \\<subseteq> domA \\<Gamma>\""], ["proof (prove)\nusing this:\n  consistent (ae, ce, a, as, r) (\\<Gamma>, v, [])\n\ngoal (1 subgoal):\n 1. set r \\<subseteq> domA \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  set r \\<subseteq> domA \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"conf_transform  (\\<bottom>, \\<bottom>, 0, [], []) ([],e,[]) = ([],transform 0 e,[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_transform (\\<bottom>, \\<bottom>, 0, [], []) ([], e, []) =\n    ([], ccTransform 0 e, [])", "by simp"], ["proof (state)\nthis:\n  conf_transform (\\<bottom>, \\<bottom>, 0, [], []) ([], e, []) =\n  ([], ccTransform 0 e, [])\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with **"], ["proof (chain)\npicking this:\n  conf_transform (\\<bottom>, \\<bottom>, 0, [], [])\n   ([], e, []) \\<Rightarrow>\\<^sub>G\\<^sup>*\n  conf_transform (ae, ce, a, as, r) (\\<Gamma>, v, [])\n  conf_transform (\\<bottom>, \\<bottom>, 0, [], []) ([], e, []) =\n  ([], ccTransform 0 e, [])", "have \"([], transform 0 e, []) \\<Rightarrow>\\<^sub>G\\<^sup>* (?\\<Gamma>, ?v, map Dummy (rev r))\""], ["proof (prove)\nusing this:\n  conf_transform (\\<bottom>, \\<bottom>, 0, [], [])\n   ([], e, []) \\<Rightarrow>\\<^sub>G\\<^sup>*\n  conf_transform (ae, ce, a, as, r) (\\<Gamma>, v, [])\n  conf_transform (\\<bottom>, \\<bottom>, 0, [], []) ([], e, []) =\n  ([], ccTransform 0 e, [])\n\ngoal (1 subgoal):\n 1. ([], ccTransform 0 e, []) \\<Rightarrow>\\<^sub>G\\<^sup>*\n    (map_transform Aeta_expand ae\n      (map_transform ccTransform ae (restrictA (- set r) \\<Gamma>)),\n     ccTransform a v, map Dummy (rev r))", "by simp"], ["proof (state)\nthis:\n  ([], ccTransform 0 e, []) \\<Rightarrow>\\<^sub>G\\<^sup>*\n  (map_transform Aeta_expand ae\n    (map_transform ccTransform ae (restrictA (- set r) \\<Gamma>)),\n   ccTransform a v, map Dummy (rev r))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"isVal ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isVal (ccTransform a v)", "using \\<open>isVal v\\<close>"], ["proof (prove)\nusing this:\n  isVal v\n\ngoal (1 subgoal):\n 1. isVal (ccTransform a v)", "by simp"], ["proof (state)\nthis:\n  isVal (ccTransform a v)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"fv (transform 0 e) = ({} :: var set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (ccTransform 0 e) = {}", "using closed"], ["proof (prove)\nusing this:\n  fv e = {}\n\ngoal (1 subgoal):\n 1. fv (ccTransform 0 e) = {}", "by (auto dest: subsetD[OF fv_transform])"], ["proof (state)\nthis:\n  fv (ccTransform 0 e) = {}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note sestoftUnGC'[OF \\<open>([], transform 0 e, []) \\<Rightarrow>\\<^sub>G\\<^sup>* (?\\<Gamma>, ?v, map Dummy (rev r))\\<close> \\<open>isVal ?v\\<close> \\<open>fv (transform 0 e) = {}\\<close>]"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>''.\n     ([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n     (\\<Gamma>'', ccTransform a v, []) \\<and>\n     map_transform Aeta_expand ae\n      (map_transform ccTransform ae (restrictA (- set r) \\<Gamma>)) =\n     restrictA (- set (rev r)) \\<Gamma>'' \\<and>\n     set (rev r) \\<subseteq> domA \\<Gamma>''\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<Gamma>''.\n     ([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n     (\\<Gamma>'', ccTransform a v, []) \\<and>\n     map_transform Aeta_expand ae\n      (map_transform ccTransform ae (restrictA (- set r) \\<Gamma>)) =\n     restrictA (- set (rev r)) \\<Gamma>'' \\<and>\n     set (rev r) \\<subseteq> domA \\<Gamma>''", "obtain \\<Gamma>'\n    where \"([], transform 0 e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>', ?v, [])\"\n    and \"?\\<Gamma> = restrictA (- set r) \\<Gamma>'\"\n    and \"set r \\<subseteq> domA \\<Gamma>'\""], ["proof (prove)\nusing this:\n  \\<exists>\\<Gamma>''.\n     ([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n     (\\<Gamma>'', ccTransform a v, []) \\<and>\n     map_transform Aeta_expand ae\n      (map_transform ccTransform ae (restrictA (- set r) \\<Gamma>)) =\n     restrictA (- set (rev r)) \\<Gamma>'' \\<and>\n     set (rev r) \\<subseteq> domA \\<Gamma>''\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', ccTransform a v, []);\n         map_transform Aeta_expand ae\n          (map_transform ccTransform ae (restrictA (- set r) \\<Gamma>)) =\n         restrictA (- set r) \\<Gamma>';\n         set r \\<subseteq> domA \\<Gamma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n  (\\<Gamma>', ccTransform a v, [])\n  map_transform Aeta_expand ae\n   (map_transform ccTransform ae (restrictA (- set r) \\<Gamma>)) =\n  restrictA (- set r) \\<Gamma>'\n  set r \\<subseteq> domA \\<Gamma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"card (domA \\<Gamma>) = card (domA ?\\<Gamma> \\<union> (set r \\<inter> domA \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (domA \\<Gamma>) =\n    card\n     (domA\n       (map_transform Aeta_expand ae\n         (map_transform ccTransform ae\n           (restrictA (- set r) \\<Gamma>))) \\<union>\n      set r \\<inter> domA \\<Gamma>)", "by (rule arg_cong[where f = card]) auto"], ["proof (state)\nthis:\n  card (domA \\<Gamma>) =\n  card\n   (domA\n     (map_transform Aeta_expand ae\n       (map_transform ccTransform ae\n         (restrictA (- set r) \\<Gamma>))) \\<union>\n    set r \\<inter> domA \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  card (domA \\<Gamma>) =\n  card\n   (domA\n     (map_transform Aeta_expand ae\n       (map_transform ccTransform ae\n         (restrictA (- set r) \\<Gamma>))) \\<union>\n    set r \\<inter> domA \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = card (domA ?\\<Gamma>) + card (set r \\<inter> domA \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (domA\n       (map_transform Aeta_expand ae\n         (map_transform ccTransform ae\n           (restrictA (- set r) \\<Gamma>))) \\<union>\n      set r \\<inter> domA \\<Gamma>) =\n    card\n     (domA\n       (map_transform Aeta_expand ae\n         (map_transform ccTransform ae (restrictA (- set r) \\<Gamma>)))) +\n    card (set r \\<inter> domA \\<Gamma>)", "by (rule card_Un_disjoint) auto"], ["proof (state)\nthis:\n  card\n   (domA\n     (map_transform Aeta_expand ae\n       (map_transform ccTransform ae\n         (restrictA (- set r) \\<Gamma>))) \\<union>\n    set r \\<inter> domA \\<Gamma>) =\n  card\n   (domA\n     (map_transform Aeta_expand ae\n       (map_transform ccTransform ae (restrictA (- set r) \\<Gamma>)))) +\n  card (set r \\<inter> domA \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  card\n   (domA\n     (map_transform Aeta_expand ae\n       (map_transform ccTransform ae\n         (restrictA (- set r) \\<Gamma>))) \\<union>\n    set r \\<inter> domA \\<Gamma>) =\n  card\n   (domA\n     (map_transform Aeta_expand ae\n       (map_transform ccTransform ae (restrictA (- set r) \\<Gamma>)))) +\n  card (set r \\<inter> domA \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note \\<open>?\\<Gamma> = restrictA (- set r) \\<Gamma>'\\<close>"], ["proof (state)\nthis:\n  map_transform Aeta_expand ae\n   (map_transform ccTransform ae (restrictA (- set r) \\<Gamma>)) =\n  restrictA (- set r) \\<Gamma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  map_transform Aeta_expand ae\n   (map_transform ccTransform ae (restrictA (- set r) \\<Gamma>)) =\n  restrictA (- set r) \\<Gamma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"set r \\<inter> domA \\<Gamma> = set r \\<inter> domA \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set r \\<inter> domA \\<Gamma> = set r \\<inter> domA \\<Gamma>'", "using \\<open>set r \\<subseteq> domA \\<Gamma>\\<close>  \\<open>set r \\<subseteq> domA \\<Gamma>'\\<close>"], ["proof (prove)\nusing this:\n  set r \\<subseteq> domA \\<Gamma>\n  set r \\<subseteq> domA \\<Gamma>'\n\ngoal (1 subgoal):\n 1. set r \\<inter> domA \\<Gamma> = set r \\<inter> domA \\<Gamma>'", "by auto"], ["proof (state)\nthis:\n  set r \\<inter> domA \\<Gamma> = set r \\<inter> domA \\<Gamma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  set r \\<inter> domA \\<Gamma> = set r \\<inter> domA \\<Gamma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"card (domA (restrictA (- set r) \\<Gamma>')) + card (set r \\<inter> domA \\<Gamma>') = card (domA \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (domA (restrictA (- set r) \\<Gamma>')) +\n    card (set r \\<inter> domA \\<Gamma>') =\n    card (domA \\<Gamma>')", "by (subst card_Un_disjoint[symmetric]) (auto intro: arg_cong[where f = card])"], ["proof (state)\nthis:\n  card (domA (restrictA (- set r) \\<Gamma>')) +\n  card (set r \\<inter> domA \\<Gamma>') =\n  card (domA \\<Gamma>')\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  card (domA \\<Gamma>) = card (domA \\<Gamma>')", "have \"card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\""], ["proof (prove)\nusing this:\n  card (domA \\<Gamma>) = card (domA \\<Gamma>')\n\ngoal (1 subgoal):\n 1. card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)", "by simp"], ["proof (state)\nthis:\n  card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' v'.\n        \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>', v', []);\n         isVal v'; card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>([], transform 0 e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>', ?v, [])\\<close>  \\<open>isVal ?v\\<close>"], ["proof (chain)\npicking this:\n  ([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n  (\\<Gamma>', ccTransform a v, [])\n  isVal (ccTransform a v)\n  card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)", "show thesis"], ["proof (prove)\nusing this:\n  ([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n  (\\<Gamma>', ccTransform a v, [])\n  isVal (ccTransform a v)\n  card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  ([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n  (\\<Gamma>', ccTransform a v, [])\n  isVal (ccTransform a v)\n  card (domA \\<Gamma>') \\<le> card (domA \\<Gamma>)\n  \\<lbrakk>([], ccTransform 0 e, []) \\<Rightarrow>\\<^sup>*\n           (?\\<Gamma>', ?v', []);\n   isVal ?v'; card (domA ?\\<Gamma>') \\<le> card (domA \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fresh_var_eqE[elim_format]: \"fresh_var e = x \\<Longrightarrow> x \\<notin>  fv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh_var e = x \\<Longrightarrow> x \\<notin> fv e", "by (metis fresh_var_not_free)"], ["", "lemma example1:\n  fixes e :: exp\n  fixes f g x y z :: var\n  assumes Aexp_e: \"\\<And>a. Aexp e\\<cdot>a = esing x\\<cdot>(up\\<cdot>a) \\<squnion> esing y\\<cdot>(up\\<cdot>a)\"\n  assumes ccExp_e: \"\\<And>a. CCexp e\\<cdot>a = \\<bottom>\"\n  assumes [simp]: \"transform 1 e = e\"\n  assumes \"isVal e\"\n  assumes disj: \"y \\<noteq> f\" \"y \\<noteq> g\" \"x \\<noteq> y\" \"z \\<noteq> f\" \"z \\<noteq> g\" \"y \\<noteq> x\"\n  assumes fresh: \"atom z \\<sharp> e\"\n  shows \"transform 1 (let y be  App (Var f) g in (let x be e in (Var x))) = \n         let y be (Lam [z]. App (App (Var f) g) z) in (let x be (Lam [z]. App e z) in (Var x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n    let y be Lam [z]. App (App (Var f) g)\n                       z in let x be Lam [z]. App e z in Var x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n    let y be Lam [z]. App (App (Var f) g)\n                       z in let x be Lam [z]. App e z in Var x", "from arg_cong[where f = edom, OF Aexp_e]"], ["proof (chain)\npicking this:\n  edom (Aexp_syn' ?a2 e) =\n  edom\n   (esing x\\<cdot>(up\\<cdot>?a2) \\<squnion> esing y\\<cdot>(up\\<cdot>?a2))", "have \"x \\<in> fv e\""], ["proof (prove)\nusing this:\n  edom (Aexp_syn' ?a2 e) =\n  edom\n   (esing x\\<cdot>(up\\<cdot>?a2) \\<squnion> esing y\\<cdot>(up\\<cdot>?a2))\n\ngoal (1 subgoal):\n 1. x \\<in> fv e", "by simp (metis Aexp_edom' insert_subset)"], ["proof (state)\nthis:\n  x \\<in> fv e\n\ngoal (1 subgoal):\n 1. ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n    let y be Lam [z]. App (App (Var f) g)\n                       z in let x be Lam [z]. App e z in Var x", "hence [simp]: \"\\<not> nonrec [(x,e)]\""], ["proof (prove)\nusing this:\n  x \\<in> fv e\n\ngoal (1 subgoal):\n 1. \\<not> nonrec [(x, e)]", "by (simp add: nonrec_def)"], ["proof (state)\nthis:\n  \\<not> nonrec [(x, e)]\n\ngoal (1 subgoal):\n 1. ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n    let y be Lam [z]. App (App (Var f) g)\n                       z in let x be Lam [z]. App e z in Var x", "from \\<open>isVal e\\<close>"], ["proof (chain)\npicking this:\n  isVal e", "have [simp]: \"thunks [(x, e)] = {}\""], ["proof (prove)\nusing this:\n  isVal e\n\ngoal (1 subgoal):\n 1. thunks [(x, e)] = {}", "by (simp add: thunks_Cons)"], ["proof (state)\nthis:\n  thunks [(x, e)] = {}\n\ngoal (1 subgoal):\n 1. ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n    let y be Lam [z]. App (App (Var f) g)\n                       z in let x be Lam [z]. App e z in Var x", "have [simp]: \"CCfix [(x, e)]\\<cdot>(esing x\\<cdot>(up\\<cdot>1) \\<squnion> esing y\\<cdot>(up\\<cdot>1), \\<bottom>) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CCfix [(x, e)]\\<cdot>\n    (esing x\\<cdot>(up\\<cdot>1) \\<squnion> esing y\\<cdot>(up\\<cdot>1),\n     \\<bottom>) =\n    \\<bottom>", "unfolding CCfix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> aeG.\n        \\<mu> xa.\n           ccBindsExtra [(x, e)]\\<cdot>(fst aeG, xa) \\<squnion>\n           snd aeG)\\<cdot>\n    (esing x\\<cdot>(up\\<cdot>1) \\<squnion> esing y\\<cdot>(up\\<cdot>1),\n     \\<bottom>) =\n    \\<bottom>", "apply (simp add: fix_bottom_iff ccBindsExtra_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccBind x e\\<cdot>\n    (esing x\\<cdot>(up\\<cdot>1) \\<squnion> esing y\\<cdot>(up\\<cdot>1),\n     \\<bottom>) =\n    \\<bottom>", "apply (simp add: ccBind_eq disj ccExp_e)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  CCfix [(x, e)]\\<cdot>\n  (esing x\\<cdot>(up\\<cdot>1) \\<squnion> esing y\\<cdot>(up\\<cdot>1),\n   \\<bottom>) =\n  \\<bottom>\n\ngoal (1 subgoal):\n 1. ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n    let y be Lam [z]. App (App (Var f) g)\n                       z in let x be Lam [z]. App e z in Var x", "have [simp]: \"Afix [(x, e)]\\<cdot>(esing x\\<cdot>(up\\<cdot>1)) = esing x\\<cdot>(up\\<cdot>1) \\<squnion> esing y\\<cdot>(up\\<cdot>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Afix [(x, e)]\\<cdot>(esing x\\<cdot>(up\\<cdot>1)) =\n    esing x\\<cdot>(up\\<cdot>1) \\<squnion> esing y\\<cdot>(up\\<cdot>1)", "unfolding Afix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> ae. \\<mu> xa. ABinds [(x, e)]\\<cdot>xa \\<squnion> ae)\\<cdot>\n    (esing x\\<cdot>(up\\<cdot>1)) =\n    esing x\\<cdot>(up\\<cdot>1) \\<squnion> esing y\\<cdot>(up\\<cdot>1)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> xa.\n        esing x\\<cdot>(up\\<cdot>1) \\<squnion> Aexp_bot_syn' (xa x) e) =\n    esing x\\<cdot>(up\\<cdot>1) \\<squnion> esing y\\<cdot>(up\\<cdot>1)", "apply (rule fix_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Lambda> xa.\n        esing x\\<cdot>(up\\<cdot>1) \\<squnion> Aexp_bot_syn' (xa x) e)\\<cdot>\n    (esing x\\<cdot>(up\\<cdot>1) \\<squnion> esing y\\<cdot>(up\\<cdot>1)) =\n    esing x\\<cdot>(up\\<cdot>1) \\<squnion> esing y\\<cdot>(up\\<cdot>1)\n 2. \\<And>z.\n       (\\<Lambda> xa.\n           esing x\\<cdot>(up\\<cdot>1) \\<squnion>\n           Aexp_bot_syn' (xa x) e)\\<cdot>\n       z =\n       z \\<Longrightarrow>\n       esing x\\<cdot>(up\\<cdot>1) \\<squnion>\n       esing y\\<cdot>(up\\<cdot>1) \\<sqsubseteq>\n       z", "apply (simp add: disj Aexp_e)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       (\\<Lambda> xa.\n           esing x\\<cdot>(up\\<cdot>1) \\<squnion>\n           Aexp_bot_syn' (xa x) e)\\<cdot>\n       z =\n       z \\<Longrightarrow>\n       esing x\\<cdot>(up\\<cdot>1) \\<squnion>\n       esing y\\<cdot>(up\\<cdot>1) \\<sqsubseteq>\n       z", "apply (case_tac \"z x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z.\n       \\<lbrakk>(\\<Lambda> xa.\n                    esing x\\<cdot>(up\\<cdot>1) \\<squnion>\n                    Aexp_bot_syn' (xa x) e)\\<cdot>\n                z =\n                z;\n        z x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> esing x\\<cdot>(up\\<cdot>1) \\<squnion>\n                         esing y\\<cdot>(up\\<cdot>1) \\<sqsubseteq>\n                         z\n 2. \\<And>z xa.\n       \\<lbrakk>(\\<Lambda> xa.\n                    esing x\\<cdot>(up\\<cdot>1) \\<squnion>\n                    Aexp_bot_syn' (xa x) e)\\<cdot>\n                z =\n                z;\n        z x = up\\<cdot>xa\\<rbrakk>\n       \\<Longrightarrow> esing x\\<cdot>(up\\<cdot>1) \\<squnion>\n                         esing y\\<cdot>(up\\<cdot>1) \\<sqsubseteq>\n                         z", "apply (auto simp add: disj Aexp_e)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Afix [(x, e)]\\<cdot>(esing x\\<cdot>(up\\<cdot>1)) =\n  esing x\\<cdot>(up\\<cdot>1) \\<squnion> esing y\\<cdot>(up\\<cdot>1)\n\ngoal (1 subgoal):\n 1. ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n    let y be Lam [z]. App (App (Var f) g)\n                       z in let x be Lam [z]. App e z in Var x", "have [simp]: \"Aheap [(y, App (Var f) g)] (let x be e in Var x)\\<cdot>1 = esing y\\<cdot>((Aexp (let x be e in Var x )\\<cdot>1) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Aheap [(y, App (Var f) g)] (let x be e in Var x )\\<cdot>1 =\n    esing y\\<cdot>(Aexp_syn' 1 (let x be e in Var x ) y)", "by (auto simp add:  Aheap_nonrec_simp ABind_nonrec_eq pure_fresh fresh_at_base disj)"], ["proof (state)\nthis:\n  Aheap [(y, App (Var f) g)] (let x be e in Var x )\\<cdot>1 =\n  esing y\\<cdot>(Aexp_syn' 1 (let x be e in Var x ) y)\n\ngoal (1 subgoal):\n 1. ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n    let y be Lam [z]. App (App (Var f) g)\n                       z in let x be Lam [z]. App e z in Var x", "have [simp]: \"(Aexp (let x be e in Var x)\\<cdot>1) = esing y\\<cdot>(up\\<cdot>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Aexp_syn' 1 (let x be e in Var x ) = esing y\\<cdot>(up\\<cdot>1)", "by (simp add: env_restr_join disj)"], ["proof (state)\nthis:\n  Aexp_syn' 1 (let x be e in Var x ) = esing y\\<cdot>(up\\<cdot>1)\n\ngoal (1 subgoal):\n 1. ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n    let y be Lam [z]. App (App (Var f) g)\n                       z in let x be Lam [z]. App e z in Var x", "have [simp]: \"Aheap [(x, e)] (Var x)\\<cdot>1 = esing x\\<cdot>(up\\<cdot>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Aheap [(x, e)] (Var x)\\<cdot>1 = esing x\\<cdot>(up\\<cdot>1)", "by (simp add: env_restr_join disj)"], ["proof (state)\nthis:\n  Aheap [(x, e)] (Var x)\\<cdot>1 = esing x\\<cdot>(up\\<cdot>1)\n\ngoal (1 subgoal):\n 1. ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n    let y be Lam [z]. App (App (Var f) g)\n                       z in let x be Lam [z]. App e z in Var x", "have [simp]: \"Aeta_expand 1 (App (Var f) g) = (Lam [z]. App (App (Var f) g) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Aeta_expand 1 (App (Var f) g) = Lam [z]. App (App (Var f) g) z", "apply (simp add: one_is_inc_zero del: exp_assn.eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lam [fresh_var\n          (App (Var f)\n            g)]. App (App (Var f) g) (fresh_var (App (Var f) g)) =\n    Lam [z]. App (App (Var f) g) z", "apply (subst change_Lam_Variable[of z \"fresh_var (App (Var f) g)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. z \\<noteq> fresh_var (App (Var f) g) \\<Longrightarrow>\n    atom\n     z \\<sharp> (App (App (Var f) g) (fresh_var (App (Var f) g)),\n                 fresh_var (App (Var f) g))\n 2. Lam [z]. ((fresh_var\n                (App (Var f)\n                  g) \\<leftrightarrow> z) \\<bullet> App (App (Var f) g)\n               (fresh_var (App (Var f) g))) =\n    Lam [z]. App (App (Var f) g) z", "apply (auto simp add: fresh_Pair fresh_at_base pure_fresh disj intro!: flip_fresh_fresh  elim!: fresh_var_eqE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Aeta_expand 1 (App (Var f) g) = Lam [z]. App (App (Var f) g) z\n\ngoal (1 subgoal):\n 1. ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n    let y be Lam [z]. App (App (Var f) g)\n                       z in let x be Lam [z]. App e z in Var x", "have [simp]: \"Aeta_expand 1 e = (Lam [z]. App e z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Aeta_expand 1 e = Lam [z]. App e z", "apply (simp add: one_is_inc_zero del: exp_assn.eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lam [fresh_var e]. App e (fresh_var e) = Lam [z]. App e z", "apply (subst change_Lam_Variable[of z \"fresh_var e\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. z \\<noteq> fresh_var e \\<Longrightarrow>\n    atom z \\<sharp> (App e (fresh_var e), fresh_var e)\n 2. Lam [z]. ((fresh_var\n                e \\<leftrightarrow> z) \\<bullet> App e (fresh_var e)) =\n    Lam [z]. App e z", "apply (auto simp add: fresh_Pair fresh_at_base pure_fresh disj fresh intro!: flip_fresh_fresh  elim!: fresh_var_eqE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Aeta_expand 1 e = Lam [z]. App e z\n\ngoal (1 subgoal):\n 1. ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n    let y be Lam [z]. App (App (Var f) g)\n                       z in let x be Lam [z]. App e z in Var x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n    let y be Lam [z]. App (App (Var f) g)\n                       z in let x be Lam [z]. App e z in Var x", "by (simp del: Let_eq_iff add: map_transform_Cons disj[symmetric])"], ["proof (state)\nthis:\n  ccTransform 1 (let y be App (Var f) g in let x be e in Var x  ) =\n  let y be Lam [z]. App (App (Var f) g)\n                     z in let x be Lam [z]. App e z in Var x  \n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}