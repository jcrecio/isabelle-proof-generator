{"file_name": "/home/qj213/afp-2021-10-22/thys/Call_Arity/TTree-HOLCF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Call_Arity", "problem_names": ["lemma paths_mono: \"t \\<sqsubseteq> t' \\<Longrightarrow> paths t \\<sqsubseteq> paths t'\"", "lemma paths_mono_iff: \"paths t \\<sqsubseteq> paths t' \\<longleftrightarrow> t \\<sqsubseteq> t'\"", "lemma ttree_belowI: \"(\\<And> xs. xs \\<in> paths t \\<Longrightarrow> xs \\<in> paths t') \\<Longrightarrow> t \\<sqsubseteq> t'\"", "lemma paths_belowI: \"(\\<And> x xs. x#xs \\<in> paths t \\<Longrightarrow> x#xs \\<in> paths t') \\<Longrightarrow> t \\<sqsubseteq> t'\"", "lemma is_lub_ttree:\n  \"S <<| Either S\"", "lemma lub_is_either: \"lub S = Either S\"", "lemma minimal_ttree[simp, intro!]: \"empty \\<sqsubseteq> S\"", "lemma empty_is_bottom: \"empty = \\<bottom>\"", "lemma carrier_bottom[simp]: \"carrier \\<bottom> = {}\"", "lemma below_anything[simp]:\n  \"t \\<sqsubseteq> anything\"", "lemma carrier_mono: \"t \\<sqsubseteq> t' \\<Longrightarrow> carrier t \\<subseteq> carrier t'\"", "lemma nxt_mono: \"t \\<sqsubseteq> t' \\<Longrightarrow> nxt t x \\<sqsubseteq> nxt t' x\"", "lemma either_above_arg1: \"t \\<sqsubseteq> t \\<oplus>\\<oplus> t'\"", "lemma either_above_arg2: \"t' \\<sqsubseteq> t \\<oplus>\\<oplus> t'\"", "lemma either_belowI: \"t \\<sqsubseteq> t'' \\<Longrightarrow> t' \\<sqsubseteq> t'' \\<Longrightarrow> t \\<oplus>\\<oplus> t' \\<sqsubseteq> t''\"", "lemma both_above_arg1: \"t \\<sqsubseteq> t \\<otimes>\\<otimes> t'\"", "lemma both_above_arg2: \"t' \\<sqsubseteq> t \\<otimes>\\<otimes> t'\"", "lemma both_mono1':\n  \"t \\<sqsubseteq> t' \\<Longrightarrow> t \\<otimes>\\<otimes> t'' \\<sqsubseteq> t' \\<otimes>\\<otimes> t''\"", "lemma both_mono2':\n  \"t \\<sqsubseteq> t' \\<Longrightarrow> t'' \\<otimes>\\<otimes> t \\<sqsubseteq> t'' \\<otimes>\\<otimes> t'\"", "lemma nxt_both_left:\n  \"possible t x \\<Longrightarrow> nxt t x \\<otimes>\\<otimes> t' \\<sqsubseteq> nxt (t \\<otimes>\\<otimes> t') x\"", "lemma nxt_both_right:\n  \"possible t' x \\<Longrightarrow> t \\<otimes>\\<otimes> nxt t' x \\<sqsubseteq> nxt (t \\<otimes>\\<otimes> t') x\"", "lemma substitute_mono1': \"f \\<sqsubseteq> f'\\<Longrightarrow> substitute f T t \\<sqsubseteq> substitute f' T t\"", "lemma substitute_mono2': \"t \\<sqsubseteq> t'\\<Longrightarrow> substitute f T t \\<sqsubseteq> substitute f T t'\"", "lemma substitute_above_arg: \"t \\<sqsubseteq> substitute f T t\"", "lemma ttree_contI:\n  assumes  \"\\<And> S. f (Either S) = Either (f ` S)\"\n  shows \"cont f\"", "lemma ttree_contI2:\n  assumes  \"\\<And> x. paths (f x) = \\<Union>(t ` paths x)\"\n  assumes \"[] \\<in> t []\"\n  shows \"cont f\"", "lemma cont_paths[THEN cont_compose, cont2cont, simp]:\n  \"cont paths\"", "lemma ttree_contI3:\n  assumes \"cont (\\<lambda> x. paths (f x))\"\n  shows \"cont f\"", "lemma cont_substitute[THEN cont_compose, cont2cont, simp]:\n  \"cont (substitute f T)\"", "lemma cont_both1:\n  \"cont (\\<lambda> x. both x y)\"", "lemma cont_both2:\n  \"cont (\\<lambda> x. both y x)\"", "lemma cont_both[cont2cont,simp]: \"cont f \\<Longrightarrow> cont g \\<Longrightarrow> cont (\\<lambda> x. f x \\<otimes>\\<otimes> g x)\"", "lemma cont_intersect1:\n  \"cont (\\<lambda> x. intersect x y)\"", "lemma cont_intersect2:\n  \"cont (\\<lambda> x. intersect y x)\"", "lemma cont_intersect[cont2cont,simp]: \"cont f \\<Longrightarrow> cont g \\<Longrightarrow> cont (\\<lambda> x. f x \\<inter>\\<inter> g x)\"", "lemma cont_without[THEN cont_compose, cont2cont,simp]: \"cont (without x)\"", "lemma paths_many_calls_subset:\n  \"t \\<sqsubseteq> many_calls x \\<otimes>\\<otimes> without x t\"", "lemma single_below:\n  \"[x] \\<in> paths t \\<Longrightarrow> single x \\<sqsubseteq> t\"", "lemma cont_ttree_restr[THEN cont_compose, cont2cont,simp]: \"cont (ttree_restr S)\"", "lemmas ttree_restr_mono = cont2monofunE[OF cont_ttree_restr[OF cont_id]]", "lemma range_filter[simp]: \"range (filter P) = {xs. set xs \\<subseteq> Collect P}\"", "lemma ttree_restr_anything_cont[THEN cont_compose, simp, cont2cont]:\n  \"cont (\\<lambda> S. ttree_restr S anything)\"", "lemma ttree_join_is_either:\n   \"t \\<squnion> t' = t \\<oplus>\\<oplus> t'\"", "lemma ttree_join_transfer[transfer_rule]: \"rel_fun (pcr_ttree (=)) (rel_fun (pcr_ttree (=)) (pcr_ttree (=))) (\\<union>) (\\<squnion>)\"", "lemma ttree_restr_join[simp]:\n  \"ttree_restr S (t \\<squnion> t') = ttree_restr S t \\<squnion> ttree_restr S t'\"", "lemma nxt_singles_below_singles:\n  \"nxt (singles S) x \\<sqsubseteq> singles S\"", "lemma in_carrier_fup[simp]:\n  \"x' \\<in> carrier (fup\\<cdot>f\\<cdot>u) \\<longleftrightarrow> (\\<exists> u'. u = up\\<cdot>u' \\<and> x' \\<in> carrier (f\\<cdot>u'))\""], "translations": [["", "lemma paths_mono: \"t \\<sqsubseteq> t' \\<Longrightarrow> paths t \\<sqsubseteq> paths t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> t' \\<Longrightarrow> paths t \\<sqsubseteq> paths t'", "by transfer (auto simp add: below_set_def)"], ["", "lemma paths_mono_iff: \"paths t \\<sqsubseteq> paths t' \\<longleftrightarrow> t \\<sqsubseteq> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (paths t \\<sqsubseteq> paths t') = (t \\<sqsubseteq> t')", "by transfer (auto simp add: below_set_def)"], ["", "lemma ttree_belowI: \"(\\<And> xs. xs \\<in> paths t \\<Longrightarrow> xs \\<in> paths t') \\<Longrightarrow> t \\<sqsubseteq> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        xs \\<in> paths t \\<Longrightarrow>\n        xs \\<in> paths t') \\<Longrightarrow>\n    t \\<sqsubseteq> t'", "by transfer auto"], ["", "lemma paths_belowI: \"(\\<And> x xs. x#xs \\<in> paths t \\<Longrightarrow> x#xs \\<in> paths t') \\<Longrightarrow> t \\<sqsubseteq> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        x # xs \\<in> paths t \\<Longrightarrow>\n        x # xs \\<in> paths t') \\<Longrightarrow>\n    t \\<sqsubseteq> t'", "apply (rule ttree_belowI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>x xs.\n                   x # xs \\<in> paths t \\<Longrightarrow>\n                   x # xs \\<in> paths t';\n        xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> paths t'", "apply (case_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>x xs.\n                   x # xs \\<in> paths t \\<Longrightarrow>\n                   x # xs \\<in> paths t';\n        xs \\<in> paths t; xs = []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> paths t'\n 2. \\<And>xs a list.\n       \\<lbrakk>\\<And>x xs.\n                   x # xs \\<in> paths t \\<Longrightarrow>\n                   x # xs \\<in> paths t';\n        xs \\<in> paths t; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> paths t'", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instance ttree :: (type) po"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ttree, po_class)", "by standard (transfer, simp)+"], ["", "lemma is_lub_ttree:\n  \"S <<| Either S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S <<| Either S", "unfolding is_lub_def is_ub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y\\<in>S. y \\<sqsubseteq> Either S) \\<and>\n    (\\<forall>u.\n        (\\<forall>y\\<in>S. y \\<sqsubseteq> u) \\<longrightarrow>\n        Either S \\<sqsubseteq> u)", "by transfer auto"], ["", "lemma lub_is_either: \"lub S = Either S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lub S = Either S", "using is_lub_ttree"], ["proof (prove)\nusing this:\n  ?S <<| Either ?S\n\ngoal (1 subgoal):\n 1. lub S = Either S", "by (rule lub_eqI)"], ["", "instance ttree :: (type) cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ttree, cpo_class)", "by standard (rule exI, rule is_lub_ttree)"], ["", "lemma minimal_ttree[simp, intro!]: \"empty \\<sqsubseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TTree.empty \\<sqsubseteq> S", "by transfer simp"], ["", "instance ttree :: (type) pcpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ttree, pcpo_class)", "by standard (rule+)"], ["", "lemma empty_is_bottom: \"empty = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TTree.empty = \\<bottom>", "by (metis below_bottom_iff minimal_ttree)"], ["", "lemma carrier_bottom[simp]: \"carrier \\<bottom> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier \\<bottom> = {}", "unfolding empty_is_bottom[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier TTree.empty = {}", "by simp"], ["", "lemma below_anything[simp]:\n  \"t \\<sqsubseteq> anything\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> anything", "by transfer auto"], ["", "lemma carrier_mono: \"t \\<sqsubseteq> t' \\<Longrightarrow> carrier t \\<subseteq> carrier t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> t' \\<Longrightarrow> carrier t \\<subseteq> carrier t'", "by transfer auto"], ["", "lemma nxt_mono: \"t \\<sqsubseteq> t' \\<Longrightarrow> nxt t x \\<sqsubseteq> nxt t' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> t' \\<Longrightarrow> nxt t x \\<sqsubseteq> nxt t' x", "by transfer auto"], ["", "lemma either_above_arg1: \"t \\<sqsubseteq> t \\<oplus>\\<oplus> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> t \\<oplus>\\<oplus> t'", "by transfer fastforce"], ["", "lemma either_above_arg2: \"t' \\<sqsubseteq> t \\<oplus>\\<oplus> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<sqsubseteq> t \\<oplus>\\<oplus> t'", "by transfer fastforce"], ["", "lemma either_belowI: \"t \\<sqsubseteq> t'' \\<Longrightarrow> t' \\<sqsubseteq> t'' \\<Longrightarrow> t \\<oplus>\\<oplus> t' \\<sqsubseteq> t''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<sqsubseteq> t''; t' \\<sqsubseteq> t''\\<rbrakk>\n    \\<Longrightarrow> t \\<oplus>\\<oplus> t' \\<sqsubseteq> t''", "by transfer auto"], ["", "lemma both_above_arg1: \"t \\<sqsubseteq> t \\<otimes>\\<otimes> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> t \\<otimes>\\<otimes> t'", "by transfer fastforce"], ["", "lemma both_above_arg2: \"t' \\<sqsubseteq> t \\<otimes>\\<otimes> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<sqsubseteq> t \\<otimes>\\<otimes> t'", "by transfer fastforce"], ["", "lemma both_mono1':\n  \"t \\<sqsubseteq> t' \\<Longrightarrow> t \\<otimes>\\<otimes> t'' \\<sqsubseteq> t' \\<otimes>\\<otimes> t''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> t' \\<Longrightarrow>\n    t \\<otimes>\\<otimes> t'' \\<sqsubseteq> t' \\<otimes>\\<otimes> t''", "using  both_mono1[folded below_set_def, unfolded paths_mono_iff]"], ["proof (prove)\nusing this:\n  ?t \\<sqsubseteq> ?t' \\<Longrightarrow>\n  ?t \\<otimes>\\<otimes> ?t'' \\<sqsubseteq> ?t' \\<otimes>\\<otimes> ?t''\n\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> t' \\<Longrightarrow>\n    t \\<otimes>\\<otimes> t'' \\<sqsubseteq> t' \\<otimes>\\<otimes> t''", "."], ["", "lemma both_mono2':\n  \"t \\<sqsubseteq> t' \\<Longrightarrow> t'' \\<otimes>\\<otimes> t \\<sqsubseteq> t'' \\<otimes>\\<otimes> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> t' \\<Longrightarrow>\n    t'' \\<otimes>\\<otimes> t \\<sqsubseteq> t'' \\<otimes>\\<otimes> t'", "using  both_mono2[folded below_set_def, unfolded paths_mono_iff]"], ["proof (prove)\nusing this:\n  ?t \\<sqsubseteq> ?t' \\<Longrightarrow>\n  ?t'' \\<otimes>\\<otimes> ?t \\<sqsubseteq> ?t'' \\<otimes>\\<otimes> ?t'\n\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> t' \\<Longrightarrow>\n    t'' \\<otimes>\\<otimes> t \\<sqsubseteq> t'' \\<otimes>\\<otimes> t'", "."], ["", "lemma nxt_both_left:\n  \"possible t x \\<Longrightarrow> nxt t x \\<otimes>\\<otimes> t' \\<sqsubseteq> nxt (t \\<otimes>\\<otimes> t') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible t x \\<Longrightarrow>\n    nxt t x \\<otimes>\\<otimes> t' \\<sqsubseteq>\n    nxt (t \\<otimes>\\<otimes> t') x", "by (auto simp add: nxt_both either_above_arg2)"], ["", "lemma nxt_both_right:\n  \"possible t' x \\<Longrightarrow> t \\<otimes>\\<otimes> nxt t' x \\<sqsubseteq> nxt (t \\<otimes>\\<otimes> t') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. possible t' x \\<Longrightarrow>\n    t \\<otimes>\\<otimes> nxt t' x \\<sqsubseteq>\n    nxt (t \\<otimes>\\<otimes> t') x", "by (auto simp add: nxt_both either_above_arg1)"], ["", "lemma substitute_mono1': \"f \\<sqsubseteq> f'\\<Longrightarrow> substitute f T t \\<sqsubseteq> substitute f' T t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sqsubseteq> f' \\<Longrightarrow>\n    substitute f T t \\<sqsubseteq> substitute f' T t", "using  substitute_mono1[folded below_set_def, unfolded paths_mono_iff] fun_belowD"], ["proof (prove)\nusing this:\n  (\\<And>x. ?f x \\<sqsubseteq> ?f' x) \\<Longrightarrow>\n  substitute ?f ?T ?t \\<sqsubseteq> substitute ?f' ?T ?t\n  ?f \\<sqsubseteq> ?g \\<Longrightarrow> ?f ?x \\<sqsubseteq> ?g ?x\n\ngoal (1 subgoal):\n 1. f \\<sqsubseteq> f' \\<Longrightarrow>\n    substitute f T t \\<sqsubseteq> substitute f' T t", "by metis"], ["", "lemma substitute_mono2': \"t \\<sqsubseteq> t'\\<Longrightarrow> substitute f T t \\<sqsubseteq> substitute f T t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> t' \\<Longrightarrow>\n    substitute f T t \\<sqsubseteq> substitute f T t'", "using  substitute_mono2[folded below_set_def, unfolded paths_mono_iff]"], ["proof (prove)\nusing this:\n  ?t \\<sqsubseteq> ?t' \\<Longrightarrow>\n  substitute ?f ?T ?t \\<sqsubseteq> substitute ?f ?T ?t'\n\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> t' \\<Longrightarrow>\n    substitute f T t \\<sqsubseteq> substitute f T t'", "."], ["", "lemma substitute_above_arg: \"t \\<sqsubseteq> substitute f T t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> substitute f T t", "using  substitute_contains_arg[folded below_set_def, unfolded paths_mono_iff]"], ["proof (prove)\nusing this:\n  ?t \\<sqsubseteq> substitute ?f ?T ?t\n\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> substitute f T t", "."], ["", "lemma ttree_contI:\n  assumes  \"\\<And> S. f (Either S) = Either (f ` S)\"\n  shows \"cont f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont f", "proof(rule contI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "fix Y :: \"nat \\<Rightarrow> 'a ttree\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "have \"range (\\<lambda>i. f (Y i)) = f ` range Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>i. f (Y i)) = f ` range Y", "by auto"], ["proof (state)\nthis:\n  range (\\<lambda>i. f (Y i)) = f ` range Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "also"], ["proof (state)\nthis:\n  range (\\<lambda>i. f (Y i)) = f ` range Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "have \"Either \\<dots> = f (Either (range Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Either (f ` range Y) = f (Either (range Y))", "unfolding assms(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Either (f ` range Y) = Either (f ` range Y)", ".."], ["proof (state)\nthis:\n  Either (f ` range Y) = f (Either (range Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "also"], ["proof (state)\nthis:\n  Either (f ` range Y) = f (Either (range Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "have \"Either (range Y) = lub (range Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Either (range Y) = Lub Y", "unfolding lub_is_either"], ["proof (prove)\ngoal (1 subgoal):\n 1. Either (range Y) = Either (range Y)", "by simp"], ["proof (state)\nthis:\n  Either (range Y) = Lub Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "finally"], ["proof (chain)\npicking this:\n  Either (range (\\<lambda>i. f (Y i))) = f (Lub Y)", "show \"range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion> i. Y i)\""], ["proof (prove)\nusing this:\n  Either (range (\\<lambda>i. f (Y i))) = f (Lub Y)\n\ngoal (1 subgoal):\n 1. range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "by (metis is_lub_ttree)"], ["proof (state)\nthis:\n  range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ttree_contI2:\n  assumes  \"\\<And> x. paths (f x) = \\<Union>(t ` paths x)\"\n  assumes \"[] \\<in> t []\"\n  shows \"cont f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont f", "proof(rule contI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "fix Y :: \"nat \\<Rightarrow> 'a ttree\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "have \"paths (Either (range (\\<lambda>i. f (Y i)))) = insert [] (\\<Union>x. paths (f (Y x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. paths (Either (range (\\<lambda>i. f (Y i)))) =\n    insert [] (\\<Union>x. paths (f (Y x)))", "by (simp add: paths_Either)"], ["proof (state)\nthis:\n  paths (Either (range (\\<lambda>i. f (Y i)))) =\n  insert [] (\\<Union>x. paths (f (Y x)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "also"], ["proof (state)\nthis:\n  paths (Either (range (\\<lambda>i. f (Y i)))) =\n  insert [] (\\<Union>x. paths (f (Y x)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "have \"\\<dots> = insert [] (\\<Union>x. \\<Union>(t ` paths (Y x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert [] (\\<Union>x. paths (f (Y x))) =\n    insert [] (\\<Union>x. \\<Union> (t ` paths (Y x)))", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  insert [] (\\<Union>x. paths (f (Y x))) =\n  insert [] (\\<Union>x. \\<Union> (t ` paths (Y x)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "also"], ["proof (state)\nthis:\n  insert [] (\\<Union>x. paths (f (Y x))) =\n  insert [] (\\<Union>x. \\<Union> (t ` paths (Y x)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "have \"\\<dots> = \\<Union>(t ` insert [] (\\<Union>x. paths (Y x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert [] (\\<Union>x. \\<Union> (t ` paths (Y x))) =\n    \\<Union> (t ` insert [] (\\<Union>x. paths (Y x)))", "using assms(2)"], ["proof (prove)\nusing this:\n  [] \\<in> t []\n\ngoal (1 subgoal):\n 1. insert [] (\\<Union>x. \\<Union> (t ` paths (Y x))) =\n    \\<Union> (t ` insert [] (\\<Union>x. paths (Y x)))", "by (auto cong add: SUP_cong_simp)"], ["proof (state)\nthis:\n  insert [] (\\<Union>x. \\<Union> (t ` paths (Y x))) =\n  \\<Union> (t ` insert [] (\\<Union>x. paths (Y x)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "also"], ["proof (state)\nthis:\n  insert [] (\\<Union>x. \\<Union> (t ` paths (Y x))) =\n  \\<Union> (t ` insert [] (\\<Union>x. paths (Y x)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "have \"\\<dots> = \\<Union>(t ` paths (Either (range Y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (t ` insert [] (\\<Union>x. paths (Y x))) =\n    \\<Union> (t ` paths (Either (range Y)))", "by (auto simp add: paths_Either)"], ["proof (state)\nthis:\n  \\<Union> (t ` insert [] (\\<Union>x. paths (Y x))) =\n  \\<Union> (t ` paths (Either (range Y)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "also"], ["proof (state)\nthis:\n  \\<Union> (t ` insert [] (\\<Union>x. paths (Y x))) =\n  \\<Union> (t ` paths (Either (range Y)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "have \"\\<dots> = paths (f (Either (range Y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (t ` paths (Either (range Y))) = paths (f (Either (range Y)))", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  \\<Union> (t ` paths (Either (range Y))) = paths (f (Either (range Y)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "also"], ["proof (state)\nthis:\n  \\<Union> (t ` paths (Either (range Y))) = paths (f (Either (range Y)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "have \"\\<dots> = paths (f (lub (range Y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. paths (f (Either (range Y))) = paths (f (Lub Y))", "unfolding lub_is_either"], ["proof (prove)\ngoal (1 subgoal):\n 1. paths (f (Either (range Y))) = paths (f (Either (range Y)))", "by simp"], ["proof (state)\nthis:\n  paths (f (Either (range Y))) = paths (f (Lub Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "finally"], ["proof (chain)\npicking this:\n  paths (Either (range (\\<lambda>i. f (Y i)))) = paths (f (Lub Y))", "show \"range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion> i. Y i)\""], ["proof (prove)\nusing this:\n  paths (Either (range (\\<lambda>i. f (Y i)))) = paths (f (Lub Y))\n\ngoal (1 subgoal):\n 1. range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)", "by (metis is_lub_ttree paths_inj)"], ["proof (state)\nthis:\n  range (\\<lambda>i. f (Y i)) <<| f (\\<Squnion>i. Y i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cont_paths[THEN cont_compose, cont2cont, simp]:\n  \"cont paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont paths", "apply (rule set_contI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       paths (\\<Squnion>i. Y i) = \\<Union> (paths ` range Y)", "apply (thin_tac _)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y. paths (\\<Squnion>i. Y i) = \\<Union> (paths ` range Y)", "unfolding lub_is_either"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y. paths (Either (range Y)) = \\<Union> (paths ` range Y)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       pred_fun top (\\<lambda>xss. [] \\<in> xss \\<and> downset xss)\n        Y \\<Longrightarrow>\n       insert [] (\\<Union> (range Y)) = (\\<Union>x\\<in>range Y. x)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ttree_contI3:\n  assumes \"cont (\\<lambda> x. paths (f x))\"\n  shows \"cont f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont f", "apply (rule contI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. monofun f\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. f (Y i))\\<rbrakk>\n       \\<Longrightarrow> f (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. f (Y i))", "apply (rule monofunI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<sqsubseteq> y \\<Longrightarrow> f x \\<sqsubseteq> f y\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. f (Y i))\\<rbrakk>\n       \\<Longrightarrow> f (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. f (Y i))", "apply (subst paths_mono_iff[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       paths (f x) \\<sqsubseteq> paths (f y)\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. f (Y i))\\<rbrakk>\n       \\<Longrightarrow> f (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. f (Y i))", "apply (erule cont2monofunE[OF assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. f (Y i))\\<rbrakk>\n       \\<Longrightarrow> f (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. f (Y i))", "apply (subst paths_mono_iff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. f (Y i))\\<rbrakk>\n       \\<Longrightarrow> paths (f (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         paths (\\<Squnion>i. f (Y i))", "apply (subst cont2contlubE[OF cont_paths[OF cont_id]], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. f (Y i))\\<rbrakk>\n       \\<Longrightarrow> paths (f (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. paths (f (Y i)))", "apply (subst cont2contlubE[OF assms], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. f (Y i))\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. paths (f (Y i))) \\<sqsubseteq>\n                         (\\<Squnion>i. paths (f (Y i)))", "apply rule"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cont_substitute[THEN cont_compose, cont2cont, simp]:\n  \"cont (substitute f T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (substitute f T)", "apply (rule ttree_contI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. paths (substitute f T x) = \\<Union> (?t ` paths x)\n 2. [] \\<in> ?t []", "apply (rule paths_substitute_substitute'')"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> Collect (substitute'' f T [])", "apply (auto intro: substitute''.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cont_both1:\n  \"cont (\\<lambda> x. both x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. x \\<otimes>\\<otimes> y)", "apply (rule ttree_contI2[where t = \"\\<lambda>xs . {zs . \\<exists>ys\\<in>paths y. zs \\<in> xs \\<otimes> ys}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       paths (x \\<otimes>\\<otimes> y) =\n       (\\<Union>xs\\<in>paths x.\n           {zs. \\<exists>ys\\<in>paths y. zs \\<in> xs \\<otimes> ys})\n 2. [] \\<in> {zs. \\<exists>ys\\<in>paths y. zs \\<in> [] \\<otimes> ys}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       (xa \\<in> paths (x \\<otimes>\\<otimes> y)) =\n       (xa \\<in> (\\<Union>xs\\<in>paths x.\n                     {zs.\n                      \\<exists>ys\\<in>paths y. zs \\<in> xs \\<otimes> ys}))\n 2. [] \\<in> {zs. \\<exists>ys\\<in>paths y. zs \\<in> [] \\<otimes> ys}", "by (auto intro:  simp add: paths_both)"], ["", "lemma cont_both2:\n  \"cont (\\<lambda> x. both y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont ((\\<otimes>\\<otimes>) y)", "apply (rule ttree_contI2[where t = \"\\<lambda>ys . {zs . \\<exists>xs\\<in>paths y. zs \\<in> xs \\<otimes> ys}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       paths (y \\<otimes>\\<otimes> x) =\n       (\\<Union>ys\\<in>paths x.\n           {zs. \\<exists>xs\\<in>paths y. zs \\<in> xs \\<otimes> ys})\n 2. [] \\<in> {zs. \\<exists>xs\\<in>paths y. zs \\<in> xs \\<otimes> []}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       (xa \\<in> paths (y \\<otimes>\\<otimes> x)) =\n       (xa \\<in> (\\<Union>ys\\<in>paths x.\n                     {zs.\n                      \\<exists>xs\\<in>paths y. zs \\<in> xs \\<otimes> ys}))\n 2. [] \\<in> {zs. \\<exists>xs\\<in>paths y. zs \\<in> xs \\<otimes> []}", "by (auto intro:  simp add: paths_both)"], ["", "lemma cont_both[cont2cont,simp]: \"cont f \\<Longrightarrow> cont g \\<Longrightarrow> cont (\\<lambda> x. f x \\<otimes>\\<otimes> g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont f; cont g\\<rbrakk>\n    \\<Longrightarrow> cont (\\<lambda>x. f x \\<otimes>\\<otimes> g x)", "by (rule cont_compose2[OF cont_both1 cont_both2])"], ["", "lemma cont_intersect1:\n  \"cont (\\<lambda> x. intersect x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. x \\<inter>\\<inter> y)", "by (rule ttree_contI2 [where t = \"\\<lambda>xs . (if xs \\<in> paths y then {xs} else {})\"])\n    (auto split: if_splits)"], ["", "lemma cont_intersect2:\n  \"cont (\\<lambda> x. intersect y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont ((\\<inter>\\<inter>) y)", "by (rule ttree_contI2 [where t = \"\\<lambda>xs . (if xs \\<in> paths y then {xs} else {})\"])\n    (auto split: if_splits)"], ["", "lemma cont_intersect[cont2cont,simp]: \"cont f \\<Longrightarrow> cont g \\<Longrightarrow> cont (\\<lambda> x. f x \\<inter>\\<inter> g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont f; cont g\\<rbrakk>\n    \\<Longrightarrow> cont (\\<lambda>x. f x \\<inter>\\<inter> g x)", "by (rule cont_compose2[OF cont_intersect1 cont_intersect2])"], ["", "lemma cont_without[THEN cont_compose, cont2cont,simp]: \"cont (without x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (without x)", "by (rule ttree_contI2[where t = \"\\<lambda> xs.{filter (\\<lambda> x'. x' \\<noteq> x) xs}\"])\n     (transfer, auto)"], ["", "lemma paths_many_calls_subset:\n  \"t \\<sqsubseteq> many_calls x \\<otimes>\\<otimes> without x t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> many_calls x \\<otimes>\\<otimes> without x t", "by (metis (full_types) below_set_def paths_many_calls_subset paths_mono_iff)"], ["", "lemma single_below:\n  \"[x] \\<in> paths t \\<Longrightarrow> single x \\<sqsubseteq> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x] \\<in> paths t \\<Longrightarrow> single x \\<sqsubseteq> t", "by transfer auto"], ["", "lemma cont_ttree_restr[THEN cont_compose, cont2cont,simp]: \"cont (ttree_restr S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (ttree_restr S)", "by (rule ttree_contI2[where t = \"\\<lambda> xs.{filter (\\<lambda> x'. x' \\<in> S) xs}\"])\n     (transfer, auto)"], ["", "lemmas ttree_restr_mono = cont2monofunE[OF cont_ttree_restr[OF cont_id]]"], ["", "lemma range_filter[simp]: \"range (filter P) = {xs. set xs \\<subseteq> Collect P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (filter P) = {xs. set xs \\<subseteq> Collect P}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       set x \\<subseteq> Collect P \\<Longrightarrow>\n       x \\<in> range (filter P)", "apply (rule_tac x = x in rev_image_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. set x \\<subseteq> Collect P \\<Longrightarrow> x \\<in> UNIV\n 2. \\<And>x. set x \\<subseteq> Collect P \\<Longrightarrow> x = filter P x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. set x \\<subseteq> Collect P \\<Longrightarrow> x = filter P x", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. set x \\<subseteq> Collect P \\<Longrightarrow> filter P x = x", "apply (auto simp add: filter_id_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ttree_restr_anything_cont[THEN cont_compose, simp, cont2cont]:\n  \"cont (\\<lambda> S. ttree_restr S anything)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>S. ttree_restr S anything)", "apply (rule ttree_contI3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. paths (ttree_restr x anything))", "apply (rule set_contI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       paths (ttree_restr (\\<Squnion>i. Y i) anything) =\n       (\\<Union>x\\<in>range Y. paths (ttree_restr x anything))", "apply (auto simp add: filter_paths_conv_free_restr[symmetric] lub_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y x.\n       \\<lbrakk>chain Y;\n        set x \\<subseteq> {x'. \\<exists>x. x' \\<in> Y x}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. set x \\<subseteq> Y xa", "apply (rule finite_subset_chain)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Y x.\n       \\<lbrakk>chain Y;\n        set x \\<subseteq> {x'. \\<exists>x. x' \\<in> Y x}\\<rbrakk>\n       \\<Longrightarrow> chain Y\n 2. \\<And>Y x.\n       \\<lbrakk>chain Y;\n        set x \\<subseteq> {x'. \\<exists>x. x' \\<in> Y x}\\<rbrakk>\n       \\<Longrightarrow> set x \\<subseteq> \\<Union> (range Y)\n 3. \\<And>Y x.\n       \\<lbrakk>chain Y;\n        set x \\<subseteq> {x'. \\<exists>x. x' \\<in> Y x}\\<rbrakk>\n       \\<Longrightarrow> finite (set x)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instance ttree :: (type) Finite_Join_cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ttree, Finite_Join_cpo_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. compatible x y", "fix x y :: \"'a ttree\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. compatible x y", "show \"compatible x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y", "unfolding compatible_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex ((<<|) {x, y})", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} <<| ?x", "apply (rule is_lub_ttree)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  compatible x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ttree_join_is_either:\n   \"t \\<squnion> t' = t \\<oplus>\\<oplus> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<squnion> t' = t \\<oplus>\\<oplus> t'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<squnion> t' = t \\<oplus>\\<oplus> t'", "have \"t \\<oplus>\\<oplus> t' = Either {t, t'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<oplus>\\<oplus> t' = Either {t, t'}", "by transfer auto"], ["proof (state)\nthis:\n  t \\<oplus>\\<oplus> t' = Either {t, t'}\n\ngoal (1 subgoal):\n 1. t \\<squnion> t' = t \\<oplus>\\<oplus> t'", "thus \"t \\<squnion> t' = t \\<oplus>\\<oplus> t'\""], ["proof (prove)\nusing this:\n  t \\<oplus>\\<oplus> t' = Either {t, t'}\n\ngoal (1 subgoal):\n 1. t \\<squnion> t' = t \\<oplus>\\<oplus> t'", "by (metis lub_is_join is_lub_ttree)"], ["proof (state)\nthis:\n  t \\<squnion> t' = t \\<oplus>\\<oplus> t'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ttree_join_transfer[transfer_rule]: \"rel_fun (pcr_ttree (=)) (rel_fun (pcr_ttree (=)) (pcr_ttree (=))) (\\<union>) (\\<squnion>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (pcr_ttree (=)) (rel_fun (pcr_ttree (=)) (pcr_ttree (=)))\n     (\\<union>) (\\<squnion>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_fun (pcr_ttree (=)) (rel_fun (pcr_ttree (=)) (pcr_ttree (=)))\n     (\\<union>) (\\<squnion>)", "have \"(\\<squnion>) = ((\\<oplus>\\<oplus>) :: 'a ttree \\<Rightarrow> 'a ttree \\<Rightarrow> 'a ttree)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<squnion>) = (\\<oplus>\\<oplus>)", "using ttree_join_is_either"], ["proof (prove)\nusing this:\n  ?t \\<squnion> ?t' = ?t \\<oplus>\\<oplus> ?t'\n\ngoal (1 subgoal):\n 1. (\\<squnion>) = (\\<oplus>\\<oplus>)", "by blast"], ["proof (state)\nthis:\n  (\\<squnion>) = (\\<oplus>\\<oplus>)\n\ngoal (1 subgoal):\n 1. rel_fun (pcr_ttree (=)) (rel_fun (pcr_ttree (=)) (pcr_ttree (=)))\n     (\\<union>) (\\<squnion>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<squnion>) = (\\<oplus>\\<oplus>)\n\ngoal (1 subgoal):\n 1. rel_fun (pcr_ttree (=)) (rel_fun (pcr_ttree (=)) (pcr_ttree (=)))\n     (\\<union>) (\\<squnion>)", "using either.transfer"], ["proof (prove)\nusing this:\n  (\\<squnion>) = (\\<oplus>\\<oplus>)\n  rel_fun (pcr_ttree (=)) (rel_fun (pcr_ttree (=)) (pcr_ttree (=)))\n   (\\<union>) (\\<oplus>\\<oplus>)\n\ngoal (1 subgoal):\n 1. rel_fun (pcr_ttree (=)) (rel_fun (pcr_ttree (=)) (pcr_ttree (=)))\n     (\\<union>) (\\<squnion>)", "by metis"], ["proof (state)\nthis:\n  rel_fun (pcr_ttree (=)) (rel_fun (pcr_ttree (=)) (pcr_ttree (=)))\n   (\\<union>) (\\<squnion>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ttree_restr_join[simp]:\n  \"ttree_restr S (t \\<squnion> t') = ttree_restr S t \\<squnion> ttree_restr S t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ttree_restr S (t \\<squnion> t') =\n    ttree_restr S t \\<squnion> ttree_restr S t'", "by transfer auto"], ["", "lemma nxt_singles_below_singles:\n  \"nxt (singles S) x \\<sqsubseteq> singles S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nxt (singles S) x \\<sqsubseteq> singles S", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow>\n    without x (singles S) \\<sqsubseteq> singles S", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x S.\n       x \\<in> S \\<Longrightarrow>\n       filter (\\<lambda>x'. x' \\<noteq> x) `\n       {xs.\n        \\<forall>x\\<in>S. length (filter (\\<lambda>x'. x' = x) xs) \\<le> 1}\n       \\<subseteq> {xs.\n                    \\<forall>x\\<in>S.\n                       length (filter (\\<lambda>x'. x' = x) xs) \\<le> 1}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x S xb xc.\n       \\<lbrakk>x \\<in> S;\n        \\<forall>x\\<in>S.\n           length (filter (\\<lambda>x'. x' = x) xb) \\<le> Suc 0;\n        xc \\<in> S\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>xa. xa \\<noteq> x \\<and> xa = xc) xb)\n                         \\<le> Suc 0", "apply (erule_tac x = xc in  ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x S xb xc.\n       \\<lbrakk>x \\<in> S; xc \\<in> S;\n        length (filter (\\<lambda>x'. x' = xc) xb) \\<le> Suc 0\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>xa. xa \\<noteq> x \\<and> xa = xc) xb)\n                         \\<le> Suc 0\n 2. \\<And>x S xb xc.\n       \\<lbrakk>x \\<in> S; xc \\<in> S; xc \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>xa. xa \\<noteq> x \\<and> xa = xc) xb)\n                         \\<le> Suc 0", "apply (erule order_trans[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x S xb xc.\n       \\<lbrakk>x \\<in> S; xc \\<in> S\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>xa. xa \\<noteq> x \\<and> xa = xc) xb)\n                         \\<le> length (filter (\\<lambda>x'. x' = xc) xb)\n 2. \\<And>x S xb xc.\n       \\<lbrakk>x \\<in> S; xc \\<in> S; xc \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>xa. xa \\<noteq> x \\<and> xa = xc) xb)\n                         \\<le> Suc 0", "apply (rule length_filter_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x S xb xc xa.\n       \\<lbrakk>x \\<in> S; xc \\<in> S; xa \\<noteq> x \\<and> xa = xc\\<rbrakk>\n       \\<Longrightarrow> xa = xc\n 2. \\<And>x S xb xc.\n       \\<lbrakk>x \\<in> S; xc \\<in> S; xc \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>xa. xa \\<noteq> x \\<and> xa = xc) xb)\n                         \\<le> Suc 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x S xb xc.\n       \\<lbrakk>x \\<in> S; xc \\<in> S; xc \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>xa. xa \\<noteq> x \\<and> xa = xc) xb)\n                         \\<le> Suc 0", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma in_carrier_fup[simp]:\n  \"x' \\<in> carrier (fup\\<cdot>f\\<cdot>u) \\<longleftrightarrow> (\\<exists> u'. u = up\\<cdot>u' \\<and> x' \\<in> carrier (f\\<cdot>u'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x' \\<in> carrier (fup\\<cdot>f\\<cdot>u)) =\n    (\\<exists>u'. u = up\\<cdot>u' \\<and> x' \\<in> carrier (f\\<cdot>u'))", "by (cases u) auto"], ["", "end"]]}