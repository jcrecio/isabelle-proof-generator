{"file_name": "/home/qj213/afp-2021-10-22/thys/Call_Arity/CoCallGraph.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Call_Arity", "problem_names": ["lemma coCallsLub_is_lub: \"S <<| coCallsLub S\"", "lemma ccLubTransfer[transfer_rule]: \"(rel_set pcr_CoCalls ===> pcr_CoCalls) Union lub\"", "lemma ccis_lubTransfer[transfer_rule]: \"(rel_set pcr_CoCalls  ===> pcr_CoCalls ===> (=)) (\\<lambda> S x . x = Union S) (<<|)\"", "lemma ccJoinTransfer[transfer_rule]: \"(pcr_CoCalls ===> pcr_CoCalls ===> pcr_CoCalls) (\\<union>) (\\<squnion>)\"", "lemma ccEmpty_below[simp]: \"ccEmpty \\<sqsubseteq> G\"", "lemma ccBotTransfer[transfer_rule]: \"pcr_CoCalls {} \\<bottom>\"", "lemma cc_lub_below_iff:\n  fixes G :: CoCalls\n  shows \"lub X \\<sqsubseteq> G \\<longleftrightarrow> (\\<forall> G'\\<in>X. G' \\<sqsubseteq> G)\"", "lemma ccField_nil[simp]: \"ccField \\<bottom> = {}\"", "lemma notInCC_bot[simp]: \"x--y\\<in>\\<bottom> \\<longleftrightarrow> False\"", "lemma below_CoCallsI:\n   \"(\\<And> x y. x--y\\<in>G \\<Longrightarrow> x--y\\<in>G') \\<Longrightarrow> G \\<sqsubseteq> G'\"", "lemma CoCalls_eqI:\n   \"(\\<And> x y. x--y\\<in>G \\<longleftrightarrow> x--y\\<in>G') \\<Longrightarrow> G = G'\"", "lemma in_join[simp]:\n  \"x--y \\<in> (G\\<squnion>G') \\<longleftrightarrow> x--y\\<in>G \\<or> x--y\\<in>G'\"", "lemma in_lub[simp]: \"x--y\\<in>(lub S) \\<longleftrightarrow> (\\<exists> G\\<in>S. x--y\\<in>G)\"", "lemma in_CoCallsLubI:\n  \"x--y\\<in>G \\<Longrightarrow> G \\<in> S \\<Longrightarrow> x--y\\<in>lub S\"", "lemma adm_not_in[simp]:\n  assumes \"cont t\"\n  shows \"adm (\\<lambda>a. x--y\\<notin>t a)\"", "lemma ccField_cc_delete: \"ccField (cc_delete x S) \\<subseteq> ccField S - {x}\"", "lemma ccProd_empty[simp]: \"{} G\\<times> S = \\<bottom>\"", "lemma ccProd_empty'[simp]: \"S G\\<times> {} = \\<bottom>\"", "lemma ccProd_union2[simp]: \"S G\\<times> (S' \\<union> S'') = S G\\<times> S' \\<squnion> S G\\<times> S''\"", "lemma ccProd_Union2[simp]: \"S G\\<times> \\<Union>S' = (\\<Squnion> X\\<in>S'. ccProd S X)\"", "lemma ccProd_Union2'[simp]: \"S G\\<times> (\\<Union>X\\<in>S'. f X) = (\\<Squnion> X\\<in>S'. ccProd S (f X))\"", "lemma in_ccProd[simp]: \"x--y\\<in>(S G\\<times> S') = (x \\<in> S \\<and> y \\<in> S' \\<or> x \\<in> S' \\<and> y \\<in> S)\"", "lemma ccProd_union1[simp]: \"(S' \\<union> S'') G\\<times> S = S' G\\<times> S \\<squnion> S'' G\\<times> S\"", "lemma ccProd_insert2: \"S G\\<times> insert x S' = S G\\<times> {x} \\<squnion> S G\\<times> S'\"", "lemma ccProd_insert1: \"insert x S' G\\<times> S = {x} G\\<times> S \\<squnion> S' G\\<times> S\"", "lemma ccProd_mono1: \"S' \\<subseteq> S'' \\<Longrightarrow> S' G\\<times> S \\<sqsubseteq> S'' G\\<times> S\"", "lemma ccProd_mono2: \"S' \\<subseteq> S'' \\<Longrightarrow> S G\\<times> S' \\<sqsubseteq> S G\\<times> S''\"", "lemma ccProd_mono: \"S \\<subseteq> S' \\<Longrightarrow> T \\<subseteq> T' \\<Longrightarrow> S G\\<times> T \\<sqsubseteq> S' G\\<times> T'\"", "lemma ccProd_comm: \"S G\\<times> S' = S' G\\<times> S\"", "lemma ccProd_belowI:\n   \"(\\<And> x y. x \\<in> S \\<Longrightarrow> y \\<in> S' \\<Longrightarrow> x--y\\<in>G) \\<Longrightarrow> S G\\<times> S' \\<sqsubseteq> G\"", "lemma elem_cc_restr[simp]: \"x--y\\<in>(G G|` S) = (x--y\\<in>G \\<and> x \\<in> S \\<and> y \\<in> S)\"", "lemma ccField_cc_restr: \"ccField (G G|` S) \\<subseteq> ccField G \\<inter> S\"", "lemma cc_restr_empty: \"ccField G \\<subseteq> - S \\<Longrightarrow> G G|` S = \\<bottom>\"", "lemma cc_restr_empty_set[simp]: \"cc_restr {} G = \\<bottom>\"", "lemma cc_restr_noop[simp]: \"ccField G \\<subseteq> S \\<Longrightarrow> cc_restr S G = G\"", "lemma cc_restr_bot[simp]: \"cc_restr S \\<bottom> = \\<bottom>\"", "lemma ccRestr_ccDelete[simp]: \"cc_restr (-{x}) G = cc_delete x G\"", "lemma cc_restr_join[simp]:\n  \"cc_restr S (G \\<squnion> G') = cc_restr S G \\<squnion> cc_restr S G'\"", "lemma cont_cc_restr: \"cont (cc_restr S)\"", "lemmas cont_compose[OF cont_cc_restr, cont2cont, simp]", "lemma cc_restr_mono1:\n  \"S \\<subseteq> S' \\<Longrightarrow> cc_restr S G \\<sqsubseteq> cc_restr S' G\"", "lemma cc_restr_mono2:\n  \"G \\<sqsubseteq> G' \\<Longrightarrow> cc_restr S G \\<sqsubseteq> cc_restr S G'\"", "lemma cc_restr_below_arg:\n  \"cc_restr S G \\<sqsubseteq> G\"", "lemma cc_restr_lub[simp]:\n  \"cc_restr S (lub X) = (\\<Squnion> G\\<in>X. cc_restr S G)\"", "lemma elem_to_ccField: \"x--y\\<in>G \\<Longrightarrow> x \\<in> ccField G \\<and> y \\<in> ccField G\"", "lemma ccField_to_elem: \"x \\<in> ccField G \\<Longrightarrow> \\<exists> y. x--y\\<in>G\"", "lemma cc_restr_intersect: \"ccField G \\<inter> ((S - S') \\<union> (S' - S)) = {} \\<Longrightarrow> cc_restr S G = cc_restr S' G\"", "lemma cc_restr_cc_restr[simp]: \"cc_restr S (cc_restr S' G) = cc_restr (S \\<inter> S') G\"", "lemma cc_restr_twist: \"cc_restr S (cc_restr S' G) = cc_restr S' (cc_restr S G) \"", "lemma cc_restr_cc_delete_twist: \"cc_restr x (cc_delete S G) = cc_delete S (cc_restr x G)\"", "lemma cc_restr_ccProd[simp]:\n  \"cc_restr S (ccProd S\\<^sub>1 S\\<^sub>2) = ccProd (S\\<^sub>1 \\<inter> S) (S\\<^sub>2 \\<inter> S)\"", "lemma ccProd_below_cc_restr:\n  \"ccProd S S' \\<sqsubseteq> cc_restr S'' G \\<longleftrightarrow> ccProd S S' \\<sqsubseteq> G \\<and> (S = {} \\<or> S' = {} \\<or> S \\<subseteq> S'' \\<and> S' \\<subseteq> S'')\"", "lemma cc_restr_eq_subset: \"S \\<subseteq> S' \\<Longrightarrow> cc_restr S' G = cc_restr S' G2 \\<Longrightarrow> cc_restr S G = cc_restr S G2\"", "lemma ccField_ccSquare[simp]: \"ccField (S\\<^sup>2) = S\"", "lemma below_ccSquare[iff]: \"(G \\<sqsubseteq> S\\<^sup>2) = (ccField G \\<subseteq> S)\"", "lemma cc_restr_ccSquare[simp]: \"(S'\\<^sup>2) G|` S = (S' \\<inter> S)\\<^sup>2\"", "lemma ccSquare_empty[simp]: \"{}\\<^sup>2 = \\<bottom>\"", "lemma ccNeighbors_bot[simp]: \"ccNeighbors x \\<bottom> = {}\"", "lemma cont_ccProd1:\n  \"cont (\\<lambda> S. ccProd S S')\"", "lemma cont_ccProd2:\n  \"cont (\\<lambda> S'. ccProd S S')\"", "lemmas cont_compose2[OF cont_ccProd1 cont_ccProd2, simp, cont2cont]", "lemma cont_ccNeighbors[THEN cont_compose, cont2cont, simp]:\n  \"cont (\\<lambda>y. ccNeighbors x y)\"", "lemma ccNeighbors_join[simp]: \"ccNeighbors x (G \\<squnion> G') = ccNeighbors x G \\<union> ccNeighbors x G'\"", "lemma ccNeighbors_ccProd:\n  \"ccNeighbors x (ccProd S S') = (if x \\<in> S then S' else {}) \\<union> (if x \\<in> S' then S else {})\"", "lemma ccNeighbors_ccSquare: \n  \"ccNeighbors x (ccSquare S) = (if x \\<in> S then S else {})\"", "lemma ccNeighbors_cc_restr[simp]:\n  \"ccNeighbors x (cc_restr S G) = (if x \\<in> S then ccNeighbors x G \\<inter> S else {})\"", "lemma ccNeighbors_mono:\n  \"G \\<sqsubseteq> G' \\<Longrightarrow> ccNeighbors x G \\<subseteq> ccNeighbors x G'\"", "lemma subset_ccNeighbors:\n  \"S \\<subseteq> ccNeighbors x G \\<longleftrightarrow> ccProd {x} S \\<sqsubseteq> G\"", "lemma elem_ccNeighbors[simp]:\n  \"y \\<in> ccNeighbors x G \\<longleftrightarrow> (y--x\\<in>G)\"", "lemma ccNeighbors_ccField:\n  \"ccNeighbors x G \\<subseteq> ccField G\"", "lemma ccNeighbors_disjoint_empty[simp]:\n  \"ccNeighbors x G = {} \\<longleftrightarrow> x \\<notin> ccField G\"", "lemma ccNeighbors_lub[simp]: \"ccNeighbors x (lub Gs) = lub (ccNeighbors x ` Gs)\"", "lemma ccFromList_Nil[simp]: \"ccFromList [] = \\<bottom>\"", "lemma ccFromList_Cons[simp]: \"ccFromList (x#xs) = ccProd {x} (set xs) \\<squnion> ccFromList xs\"", "lemma ccFromList_append[simp]: \"ccFromList (xs@ys) = ccFromList xs \\<squnion> ccFromList ys \\<squnion> ccProd (set xs) (set ys)\"", "lemma ccFromList_filter[simp]:\n  \"ccFromList (filter P xs) = cc_restr {x. P x} (ccFromList xs)\"", "lemma ccFromList_replicate[simp]: \"ccFromList (replicate n x) = (if n \\<le> 1 then \\<bottom>  else ccProd {x} {x})\"", "lemma ccLinear_bottom[simp]:\n  \"ccLinear S \\<bottom>\"", "lemma ccLinear_empty[simp]:\n  \"ccLinear {} G\"", "lemma ccLinear_lub[simp]:\n  \"ccLinear S (lub X) = (\\<forall> G\\<in>X. ccLinear S G)\"", "lemma ccLinear_cc_restr[intro]:\n  \"ccLinear S G \\<Longrightarrow> ccLinear S (cc_restr S' G)\"", "lemma ccLinear_join[simp]:\n  \"ccLinear S (G \\<squnion> G') \\<longleftrightarrow> ccLinear S G \\<and> ccLinear S G'\"", "lemma ccLinear_ccProd[simp]:\n  \"ccLinear S (ccProd S\\<^sub>1 S\\<^sub>2) \\<longleftrightarrow> S\\<^sub>1 \\<inter> S = {} \\<or> S\\<^sub>2 \\<inter> S = {}\"", "lemma ccLinear_mono1: \"ccLinear S' G \\<Longrightarrow> S \\<subseteq> S' \\<Longrightarrow> ccLinear S G\"", "lemma ccLinear_mono2: \"ccLinear S G' \\<Longrightarrow> G \\<sqsubseteq> G' \\<Longrightarrow> ccLinear S G\"", "lemma ccField_join[simp]:\n  \"ccField (G \\<squnion> G') = ccField G \\<union> ccField G'\"", "lemma ccField_lub[simp]:\n  \"ccField (lub S) = \\<Union>(ccField ` S)\"", "lemma ccField_ccProd:\n  \"ccField (ccProd S S') = (if S = {} then {} else if S' = {} then {} else  S \\<union> S')\"", "lemma ccField_ccProd_subset:\n  \"ccField (ccProd S S') \\<subseteq>  S \\<union> S'\"", "lemma cont_ccField[THEN cont_compose, simp, cont2cont]:\n  \"cont ccField\""], "translations": [["", "lemma coCallsLub_is_lub: \"S <<| coCallsLub S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S <<| coCallsLub S", "proof (rule is_lubI)"], ["proof (state)\ngoal (2 subgoals):\n 1. S <| coCallsLub S\n 2. \\<And>u. S <| u \\<Longrightarrow> coCallsLub S \\<sqsubseteq> u", "show \"S <| coCallsLub S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S <| coCallsLub S", "by (rule is_ubI, transfer, auto)"], ["proof (state)\nthis:\n  S <| coCallsLub S\n\ngoal (1 subgoal):\n 1. \\<And>u. S <| u \\<Longrightarrow> coCallsLub S \\<sqsubseteq> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u. S <| u \\<Longrightarrow> coCallsLub S \\<sqsubseteq> u", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u. S <| u \\<Longrightarrow> coCallsLub S \\<sqsubseteq> u", "assume \"S <| u\""], ["proof (state)\nthis:\n  S <| u\n\ngoal (1 subgoal):\n 1. \\<And>u. S <| u \\<Longrightarrow> coCallsLub S \\<sqsubseteq> u", "hence \"\\<forall>x \\<in> S. x \\<sqsubseteq> u\""], ["proof (prove)\nusing this:\n  S <| u\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S. x \\<sqsubseteq> u", "by (auto dest: is_ubD)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S. x \\<sqsubseteq> u\n\ngoal (1 subgoal):\n 1. \\<And>u. S <| u \\<Longrightarrow> coCallsLub S \\<sqsubseteq> u", "thus \"coCallsLub S \\<sqsubseteq> u\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. x \\<sqsubseteq> u\n\ngoal (1 subgoal):\n 1. coCallsLub S \\<sqsubseteq> u", "by transfer auto"], ["proof (state)\nthis:\n  coCallsLub S \\<sqsubseteq> u\n\ngoal:\nNo subgoals!", "qed"], ["", "instance CoCalls :: cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(CoCalls, cpo_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S. chain S \\<Longrightarrow> \\<exists>x. range S <<| x", "fix S :: \"nat \\<Rightarrow> CoCalls\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S. chain S \\<Longrightarrow> \\<exists>x. range S <<| x", "show \"\\<exists>x. range S <<| x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. range S <<| x", "using coCallsLub_is_lub"], ["proof (prove)\nusing this:\n  ?S <<| coCallsLub ?S\n\ngoal (1 subgoal):\n 1. \\<exists>x. range S <<| x", ".."], ["proof (state)\nthis:\n  \\<exists>x. range S <<| x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccLubTransfer[transfer_rule]: \"(rel_set pcr_CoCalls ===> pcr_CoCalls) Union lub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set pcr_CoCalls ===> pcr_CoCalls) \\<Union> lub", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (rel_set pcr_CoCalls ===> pcr_CoCalls) \\<Union> lub", "have \"lub = coCallsLub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lub = coCallsLub", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. lub x = coCallsLub x", "apply (rule lub_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x <<| coCallsLub x", "apply (rule coCallsLub_is_lub)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lub = coCallsLub\n\ngoal (1 subgoal):\n 1. (rel_set pcr_CoCalls ===> pcr_CoCalls) \\<Union> lub", "with coCallsLub.transfer"], ["proof (chain)\npicking this:\n  (rel_set pcr_CoCalls ===> pcr_CoCalls) \\<Union> coCallsLub\n  lub = coCallsLub", "show ?thesis"], ["proof (prove)\nusing this:\n  (rel_set pcr_CoCalls ===> pcr_CoCalls) \\<Union> coCallsLub\n  lub = coCallsLub\n\ngoal (1 subgoal):\n 1. (rel_set pcr_CoCalls ===> pcr_CoCalls) \\<Union> lub", "by metis"], ["proof (state)\nthis:\n  (rel_set pcr_CoCalls ===> pcr_CoCalls) \\<Union> lub\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition is_cc_lub :: \"CoCalls set \\<Rightarrow> CoCalls \\<Rightarrow> bool\" is \"(\\<lambda> S x . x = Union S)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma ccis_lubTransfer[transfer_rule]: \"(rel_set pcr_CoCalls  ===> pcr_CoCalls ===> (=)) (\\<lambda> S x . x = Union S) (<<|)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set pcr_CoCalls ===> pcr_CoCalls ===> (=))\n     (\\<lambda>S x. x = \\<Union> S) (<<|)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (rel_set pcr_CoCalls ===> pcr_CoCalls ===> (=))\n     (\\<lambda>S x. x = \\<Union> S) (<<|)", "have \"\\<And> x xa . is_cc_lub x xa \\<longleftrightarrow> xa = coCallsLub x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. is_cc_lub x xa = (xa = coCallsLub x)", "by transfer auto"], ["proof (state)\nthis:\n  is_cc_lub ?x ?xa = (?xa = coCallsLub ?x)\n\ngoal (1 subgoal):\n 1. (rel_set pcr_CoCalls ===> pcr_CoCalls ===> (=))\n     (\\<lambda>S x. x = \\<Union> S) (<<|)", "hence \"is_cc_lub = (<<|)\""], ["proof (prove)\nusing this:\n  is_cc_lub ?x ?xa = (?xa = coCallsLub ?x)\n\ngoal (1 subgoal):\n 1. is_cc_lub = (<<|)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x xa. is_cc_lub x xa = (xa = coCallsLub x)) \\<Longrightarrow>\n    is_cc_lub = (<<|)", "apply (rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<And>x xa. is_cc_lub x xa = (xa = coCallsLub x)) \\<Longrightarrow>\n       is_cc_lub x xa = x <<| xa", "by (metis coCallsLub_is_lub is_lub_unique)"], ["proof (state)\nthis:\n  is_cc_lub = (<<|)\n\ngoal (1 subgoal):\n 1. (rel_set pcr_CoCalls ===> pcr_CoCalls ===> (=))\n     (\\<lambda>S x. x = \\<Union> S) (<<|)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_cc_lub = (<<|)\n\ngoal (1 subgoal):\n 1. (rel_set pcr_CoCalls ===> pcr_CoCalls ===> (=))\n     (\\<lambda>S x. x = \\<Union> S) (<<|)", "using is_cc_lub.transfer"], ["proof (prove)\nusing this:\n  is_cc_lub = (<<|)\n  (rel_set pcr_CoCalls ===> pcr_CoCalls ===> (=))\n   (\\<lambda>S x. x = \\<Union> S) is_cc_lub\n\ngoal (1 subgoal):\n 1. (rel_set pcr_CoCalls ===> pcr_CoCalls ===> (=))\n     (\\<lambda>S x. x = \\<Union> S) (<<|)", "by simp"], ["proof (state)\nthis:\n  (rel_set pcr_CoCalls ===> pcr_CoCalls ===> (=))\n   (\\<lambda>S x. x = \\<Union> S) (<<|)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition coCallsJoin :: \"CoCalls \\<Rightarrow> CoCalls  \\<Rightarrow> CoCalls\" is \"(\\<union>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       \\<lbrakk>sym set1; sym set2\\<rbrakk>\n       \\<Longrightarrow> sym (set1 \\<union> set2)", "by (rule sym_Un)"], ["", "lemma ccJoinTransfer[transfer_rule]: \"(pcr_CoCalls ===> pcr_CoCalls ===> pcr_CoCalls) (\\<union>) (\\<squnion>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_CoCalls ===> pcr_CoCalls ===> pcr_CoCalls) (\\<union>) (\\<squnion>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (pcr_CoCalls ===> pcr_CoCalls ===> pcr_CoCalls) (\\<union>) (\\<squnion>)", "have \"(\\<squnion>) = coCallsJoin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<squnion>) = coCallsJoin", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<squnion>) x = coCallsJoin x", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. x \\<squnion> xa = coCallsJoin x xa", "apply (rule lub_is_join)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. {x, xa} <<| coCallsJoin x xa", "unfolding is_lub_def is_ub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<forall>y\\<in>{x, xa}. y \\<sqsubseteq> coCallsJoin x xa) \\<and>\n       (\\<forall>u.\n           (\\<forall>y\\<in>{x, xa}. y \\<sqsubseteq> u) \\<longrightarrow>\n           coCallsJoin x xa \\<sqsubseteq> u)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>sym x; sym xa\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>y\\<in>{x, xa}.\n                             y \\<subseteq> x \\<union> xa) \\<and>\n                         (\\<forall>u\\<in>Collect sym.\n                             (\\<forall>y\\<in>{x, xa}.\n                                 y \\<subseteq> u) \\<longrightarrow>\n                             x \\<union> xa \\<subseteq> u)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<squnion>) = coCallsJoin\n\ngoal (1 subgoal):\n 1. (pcr_CoCalls ===> pcr_CoCalls ===> pcr_CoCalls) (\\<union>) (\\<squnion>)", "with coCallsJoin.transfer"], ["proof (chain)\npicking this:\n  (pcr_CoCalls ===> pcr_CoCalls ===> pcr_CoCalls) (\\<union>) coCallsJoin\n  (\\<squnion>) = coCallsJoin", "show ?thesis"], ["proof (prove)\nusing this:\n  (pcr_CoCalls ===> pcr_CoCalls ===> pcr_CoCalls) (\\<union>) coCallsJoin\n  (\\<squnion>) = coCallsJoin\n\ngoal (1 subgoal):\n 1. (pcr_CoCalls ===> pcr_CoCalls ===> pcr_CoCalls) (\\<union>) (\\<squnion>)", "by metis"], ["proof (state)\nthis:\n  (pcr_CoCalls ===> pcr_CoCalls ===> pcr_CoCalls) (\\<union>) (\\<squnion>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition ccEmpty :: \"CoCalls\" is \"{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym {}", "by (auto intro: symI)"], ["", "lemma ccEmpty_below[simp]: \"ccEmpty \\<sqsubseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccEmpty \\<sqsubseteq> G", "by transfer auto"], ["", "instance CoCalls :: pcpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(CoCalls, pcpo_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y. x \\<sqsubseteq> y", "have \"\\<forall>y . ccEmpty \\<sqsubseteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. ccEmpty \\<sqsubseteq> y", "by transfer simp"], ["proof (state)\nthis:\n  \\<forall>y. ccEmpty \\<sqsubseteq> y\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y. x \\<sqsubseteq> y", "thus \"\\<exists>x. \\<forall>y. (x::CoCalls) \\<sqsubseteq> y\""], ["proof (prove)\nusing this:\n  \\<forall>y. ccEmpty \\<sqsubseteq> y\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y. x \\<sqsubseteq> y", ".."], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>y. x \\<sqsubseteq> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccBotTransfer[transfer_rule]: \"pcr_CoCalls {} \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pcr_CoCalls {} \\<bottom>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. pcr_CoCalls {} \\<bottom>", "have \"\\<And>x. ccEmpty \\<sqsubseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. ccEmpty \\<sqsubseteq> x", "by transfer simp"], ["proof (state)\nthis:\n  ccEmpty \\<sqsubseteq> ?x\n\ngoal (1 subgoal):\n 1. pcr_CoCalls {} \\<bottom>", "hence \"ccEmpty = \\<bottom>\""], ["proof (prove)\nusing this:\n  ccEmpty \\<sqsubseteq> ?x\n\ngoal (1 subgoal):\n 1. ccEmpty = \\<bottom>", "by (rule bottomI)"], ["proof (state)\nthis:\n  ccEmpty = \\<bottom>\n\ngoal (1 subgoal):\n 1. pcr_CoCalls {} \\<bottom>", "thus ?thesis"], ["proof (prove)\nusing this:\n  ccEmpty = \\<bottom>\n\ngoal (1 subgoal):\n 1. pcr_CoCalls {} \\<bottom>", "using ccEmpty.transfer"], ["proof (prove)\nusing this:\n  ccEmpty = \\<bottom>\n  pcr_CoCalls {} ccEmpty\n\ngoal (1 subgoal):\n 1. pcr_CoCalls {} \\<bottom>", "by simp"], ["proof (state)\nthis:\n  pcr_CoCalls {} \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cc_lub_below_iff:\n  fixes G :: CoCalls\n  shows \"lub X \\<sqsubseteq> G \\<longleftrightarrow> (\\<forall> G'\\<in>X. G' \\<sqsubseteq> G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lub X \\<sqsubseteq> G) = (\\<forall>G'\\<in>X. G' \\<sqsubseteq> G)", "by transfer auto"], ["", "lift_definition ccField :: \"CoCalls \\<Rightarrow> var set\" is Field"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma ccField_nil[simp]: \"ccField \\<bottom> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField \\<bottom> = {}", "by transfer auto"], ["", "lift_definition\n  inCC :: \"var \\<Rightarrow> var \\<Rightarrow> CoCalls \\<Rightarrow> bool\" (\"_--_\\<in>_\" [1000, 1000, 900] 900)\n  is \"\\<lambda> x y s. (x,y) \\<in> s\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation\n  notInCC :: \"var \\<Rightarrow> var \\<Rightarrow> CoCalls \\<Rightarrow> bool\" (\"_--_\\<notin>_\" [1000, 1000, 900] 900)\n  where \"x--y\\<notin>S \\<equiv> \\<not> x--y\\<in>S\""], ["", "lemma notInCC_bot[simp]: \"x--y\\<in>\\<bottom> \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x--y\\<in>\\<bottom> = False", "by transfer auto"], ["", "lemma below_CoCallsI:\n   \"(\\<And> x y. x--y\\<in>G \\<Longrightarrow> x--y\\<in>G') \\<Longrightarrow> G \\<sqsubseteq> G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. x--y\\<in>G \\<Longrightarrow> x--y\\<in>G') \\<Longrightarrow>\n    G \\<sqsubseteq> G'", "by transfer auto"], ["", "lemma CoCalls_eqI:\n   \"(\\<And> x y. x--y\\<in>G \\<longleftrightarrow> x--y\\<in>G') \\<Longrightarrow> G = G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. x--y\\<in>G = x--y\\<in>G') \\<Longrightarrow> G = G'", "by transfer auto"], ["", "lemma in_join[simp]:\n  \"x--y \\<in> (G\\<squnion>G') \\<longleftrightarrow> x--y\\<in>G \\<or> x--y\\<in>G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x--y\\<in>(G \\<squnion> G') = (x--y\\<in>G \\<or> x--y\\<in>G')", "by transfer auto"], ["", "lemma in_lub[simp]: \"x--y\\<in>(lub S) \\<longleftrightarrow> (\\<exists> G\\<in>S. x--y\\<in>G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x--y\\<in>lub S = (\\<exists>G\\<in>S. x--y\\<in>G)", "by transfer auto"], ["", "lemma in_CoCallsLubI:\n  \"x--y\\<in>G \\<Longrightarrow> G \\<in> S \\<Longrightarrow> x--y\\<in>lub S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x--y\\<in>G; G \\<in> S\\<rbrakk> \\<Longrightarrow> x--y\\<in>lub S", "by transfer auto"], ["", "lemma adm_not_in[simp]:\n  assumes \"cont t\"\n  shows \"adm (\\<lambda>a. x--y\\<notin>t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>a. x--y\\<notin>t a)", "by (rule admI) (auto simp add: cont2contlubE[OF assms])"], ["", "lift_definition cc_delete :: \"var \\<Rightarrow> CoCalls \\<Rightarrow> CoCalls\"\n  is \"\\<lambda> z. Set.filter (\\<lambda> (x,y) . x \\<noteq> z \\<and> y \\<noteq> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var set.\n       sym set \\<Longrightarrow>\n       sym (Set.filter\n             (\\<lambda>(x, y). x \\<noteq> var \\<and> y \\<noteq> var) set)", "by (auto intro!: symI elim: symE)"], ["", "lemma ccField_cc_delete: \"ccField (cc_delete x S) \\<subseteq> ccField S - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField (cc_delete x S) \\<subseteq> ccField S - {x}", "by transfer (auto simp add: Field_def )"], ["", "lift_definition ccProd :: \"var set \\<Rightarrow> var set \\<Rightarrow> CoCalls\" (infixr \"G\\<times>\" 90)\n  is \"\\<lambda> S1 S2. S1 \\<times> S2 \\<union> S2 \\<times> S1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2. sym (set1 \\<times> set2 \\<union> set2 \\<times> set1)", "by (auto intro!: symI elim: symE)"], ["", "lemma ccProd_empty[simp]: \"{} G\\<times> S = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} G\\<times> S = \\<bottom>", "by transfer auto"], ["", "lemma ccProd_empty'[simp]: \"S G\\<times> {} = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S G\\<times> {} = \\<bottom>", "by transfer auto"], ["", "lemma ccProd_union2[simp]: \"S G\\<times> (S' \\<union> S'') = S G\\<times> S' \\<squnion> S G\\<times> S''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S G\\<times> (S' \\<union> S'') =\n    S G\\<times> S' \\<squnion> S G\\<times> S''", "by transfer auto"], ["", "lemma ccProd_Union2[simp]: \"S G\\<times> \\<Union>S' = (\\<Squnion> X\\<in>S'. ccProd S X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S G\\<times> \\<Union> S' = lub ((G\\<times>) S ` S')", "by transfer auto"], ["", "lemma ccProd_Union2'[simp]: \"S G\\<times> (\\<Union>X\\<in>S'. f X) = (\\<Squnion> X\\<in>S'. ccProd S (f X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S G\\<times> \\<Union> (f ` S') = (\\<Squnion>X\\<in>S'. S G\\<times> f X)", "by transfer auto"], ["", "lemma in_ccProd[simp]: \"x--y\\<in>(S G\\<times> S') = (x \\<in> S \\<and> y \\<in> S' \\<or> x \\<in> S' \\<and> y \\<in> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x--y\\<in>(S G\\<times> S') =\n    (x \\<in> S \\<and> y \\<in> S' \\<or> x \\<in> S' \\<and> y \\<in> S)", "by transfer auto"], ["", "lemma ccProd_union1[simp]: \"(S' \\<union> S'') G\\<times> S = S' G\\<times> S \\<squnion> S'' G\\<times> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S' \\<union> S'') G\\<times> S =\n    S' G\\<times> S \\<squnion> S'' G\\<times> S", "by transfer auto"], ["", "lemma ccProd_insert2: \"S G\\<times> insert x S' = S G\\<times> {x} \\<squnion> S G\\<times> S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S G\\<times> insert x S' = S G\\<times> {x} \\<squnion> S G\\<times> S'", "by transfer auto"], ["", "lemma ccProd_insert1: \"insert x S' G\\<times> S = {x} G\\<times> S \\<squnion> S' G\\<times> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x S' G\\<times> S = {x} G\\<times> S \\<squnion> S' G\\<times> S", "by transfer auto"], ["", "lemma ccProd_mono1: \"S' \\<subseteq> S'' \\<Longrightarrow> S' G\\<times> S \\<sqsubseteq> S'' G\\<times> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S' \\<subseteq> S'' \\<Longrightarrow>\n    S' G\\<times> S \\<sqsubseteq> S'' G\\<times> S", "by transfer auto"], ["", "lemma ccProd_mono2: \"S' \\<subseteq> S'' \\<Longrightarrow> S G\\<times> S' \\<sqsubseteq> S G\\<times> S''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S' \\<subseteq> S'' \\<Longrightarrow>\n    S G\\<times> S' \\<sqsubseteq> S G\\<times> S''", "by transfer auto"], ["", "lemma ccProd_mono: \"S \\<subseteq> S' \\<Longrightarrow> T \\<subseteq> T' \\<Longrightarrow> S G\\<times> T \\<sqsubseteq> S' G\\<times> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<subseteq> S'; T \\<subseteq> T'\\<rbrakk>\n    \\<Longrightarrow> S G\\<times> T \\<sqsubseteq> S' G\\<times> T'", "by transfer auto"], ["", "lemma ccProd_comm: \"S G\\<times> S' = S' G\\<times> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S G\\<times> S' = S' G\\<times> S", "by transfer auto"], ["", "lemma ccProd_belowI:\n   \"(\\<And> x y. x \\<in> S \\<Longrightarrow> y \\<in> S' \\<Longrightarrow> x--y\\<in>G) \\<Longrightarrow> S G\\<times> S' \\<sqsubseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> S; y \\<in> S'\\<rbrakk>\n        \\<Longrightarrow> x--y\\<in>G) \\<Longrightarrow>\n    S G\\<times> S' \\<sqsubseteq> G", "by transfer (auto elim: symE)"], ["", "lift_definition cc_restr :: \"var set \\<Rightarrow> CoCalls \\<Rightarrow> CoCalls\"\n  is \"\\<lambda> S. Set.filter (\\<lambda> (x,y) . x \\<in> S \\<and> y \\<in> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       sym set2 \\<Longrightarrow>\n       sym (Set.filter (\\<lambda>(x, y). x \\<in> set1 \\<and> y \\<in> set1)\n             set2)", "by (auto intro!: symI elim: symE)"], ["", "abbreviation cc_restr_sym (infixl \"G|`\"  110) where \"G G|` S \\<equiv> cc_restr S G\""], ["", "lemma elem_cc_restr[simp]: \"x--y\\<in>(G G|` S) = (x--y\\<in>G \\<and> x \\<in> S \\<and> y \\<in> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x--y\\<in>(G G|` S) = (x--y\\<in>G \\<and> x \\<in> S \\<and> y \\<in> S)", "by transfer auto"], ["", "lemma ccField_cc_restr: \"ccField (G G|` S) \\<subseteq> ccField G \\<inter> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField (G G|` S) \\<subseteq> ccField G \\<inter> S", "by transfer (auto simp add: Field_def)"], ["", "lemma cc_restr_empty: \"ccField G \\<subseteq> - S \\<Longrightarrow> G G|` S = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField G \\<subseteq> - S \\<Longrightarrow> G G|` S = \\<bottom>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G S.\n       \\<lbrakk>sym G; Field G \\<subseteq> - S\\<rbrakk>\n       \\<Longrightarrow> Set.filter\n                          (\\<lambda>(x, y). x \\<in> S \\<and> y \\<in> S) G =\n                         {}", "apply (auto simp add: Field_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G S a b.\n       \\<lbrakk>sym G; Domain G \\<subseteq> - S; Range G \\<subseteq> - S;\n        (a, b) \\<in> G; a \\<in> S; b \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule DomainI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G S a b.\n       \\<lbrakk>sym G; Domain G \\<subseteq> - S; Range G \\<subseteq> - S;\n        a \\<in> S; b \\<in> S; a \\<in> Domain G\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (1) subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G S a b.\n       \\<lbrakk>sym G; Range G \\<subseteq> - S; a \\<in> S; b \\<in> S;\n        a \\<in> Domain G; a \\<in> - S\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cc_restr_empty_set[simp]: \"cc_restr {} G = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G G|` {} = \\<bottom>", "by transfer auto"], ["", "lemma cc_restr_noop[simp]: \"ccField G \\<subseteq> S \\<Longrightarrow> cc_restr S G = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField G \\<subseteq> S \\<Longrightarrow> G G|` S = G", "by transfer (force simp add: Field_def dest: DomainI RangeI elim: subsetD)"], ["", "lemma cc_restr_bot[simp]: \"cc_restr S \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> G|` S = \\<bottom>", "by simp"], ["", "lemma ccRestr_ccDelete[simp]: \"cc_restr (-{x}) G = cc_delete x G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G G|` (- {x}) = cc_delete x G", "by transfer auto"], ["", "lemma cc_restr_join[simp]:\n  \"cc_restr S (G \\<squnion> G') = cc_restr S G \\<squnion> cc_restr S G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G \\<squnion> G') G|` S = G G|` S \\<squnion> G' G|` S", "by transfer auto"], ["", "lemma cont_cc_restr: \"cont (cc_restr S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (cc_restr S)", "apply (rule contI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. Y i G|` S) <<| (\\<Squnion>i. Y i) G|` S", "apply (thin_tac \"chain _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y. range (\\<lambda>i. Y i G|` S) <<| (\\<Squnion>i. Y i) G|` S", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y S.\n       pred_fun top sym Y \\<Longrightarrow>\n       Set.filter (\\<lambda>(x, y). x \\<in> S \\<and> y \\<in> S)\n        (\\<Union> (range Y)) =\n       (\\<Union>i.\n           Set.filter (\\<lambda>(x, y). x \\<in> S \\<and> y \\<in> S) (Y i))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas cont_compose[OF cont_cc_restr, cont2cont, simp]"], ["", "lemma cc_restr_mono1:\n  \"S \\<subseteq> S' \\<Longrightarrow> cc_restr S G \\<sqsubseteq> cc_restr S' G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> S' \\<Longrightarrow> G G|` S \\<sqsubseteq> G G|` S'", "by transfer auto"], ["", "lemma cc_restr_mono2:\n  \"G \\<sqsubseteq> G' \\<Longrightarrow> cc_restr S G \\<sqsubseteq> cc_restr S G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<sqsubseteq> G' \\<Longrightarrow> G G|` S \\<sqsubseteq> G' G|` S", "by transfer auto"], ["", "lemma cc_restr_below_arg:\n  \"cc_restr S G \\<sqsubseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G G|` S \\<sqsubseteq> G", "by transfer auto"], ["", "lemma cc_restr_lub[simp]:\n  \"cc_restr S (lub X) = (\\<Squnion> G\\<in>X. cc_restr S G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lub X G|` S = (\\<Squnion>G\\<in>X. G G|` S)", "by transfer auto"], ["", "lemma elem_to_ccField: \"x--y\\<in>G \\<Longrightarrow> x \\<in> ccField G \\<and> y \\<in> ccField G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x--y\\<in>G \\<Longrightarrow> x \\<in> ccField G \\<and> y \\<in> ccField G", "by transfer (auto simp add: Field_def)"], ["", "lemma ccField_to_elem: \"x \\<in> ccField G \\<Longrightarrow> \\<exists> y. x--y\\<in>G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> ccField G \\<Longrightarrow> \\<exists>y. x--y\\<in>G", "by transfer (auto simp add: Field_def dest: symD)"], ["", "lemma cc_restr_intersect: \"ccField G \\<inter> ((S - S') \\<union> (S' - S)) = {} \\<Longrightarrow> cc_restr S G = cc_restr S' G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField G \\<inter> (S - S' \\<union> (S' - S)) = {} \\<Longrightarrow>\n    G G|` S = G G|` S'", "by (rule CoCalls_eqI) (auto dest: elem_to_ccField)"], ["", "lemma cc_restr_cc_restr[simp]: \"cc_restr S (cc_restr S' G) = cc_restr (S \\<inter> S') G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G G|` S' G|` S = G G|` (S \\<inter> S')", "by transfer auto"], ["", "lemma cc_restr_twist: \"cc_restr S (cc_restr S' G) = cc_restr S' (cc_restr S G) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. G G|` S' G|` S = G G|` S G|` S'", "by transfer auto"], ["", "lemma cc_restr_cc_delete_twist: \"cc_restr x (cc_delete S G) = cc_delete S (cc_restr x G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cc_delete S G G|` x = cc_delete S (G G|` x)", "by transfer auto"], ["", "lemma cc_restr_ccProd[simp]:\n  \"cc_restr S (ccProd S\\<^sub>1 S\\<^sub>2) = ccProd (S\\<^sub>1 \\<inter> S) (S\\<^sub>2 \\<inter> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S\\<^sub>1 G\\<times> S\\<^sub>2) G|` S =\n    (S\\<^sub>1 \\<inter> S) G\\<times> (S\\<^sub>2 \\<inter> S)", "by transfer auto"], ["", "lemma ccProd_below_cc_restr:\n  \"ccProd S S' \\<sqsubseteq> cc_restr S'' G \\<longleftrightarrow> ccProd S S' \\<sqsubseteq> G \\<and> (S = {} \\<or> S' = {} \\<or> S \\<subseteq> S'' \\<and> S' \\<subseteq> S'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S G\\<times> S' \\<sqsubseteq> G G|` S'') =\n    (S G\\<times> S' \\<sqsubseteq> G \\<and>\n     (S = {} \\<or>\n      S' = {} \\<or> S \\<subseteq> S'' \\<and> S' \\<subseteq> S''))", "by transfer auto"], ["", "lemma cc_restr_eq_subset: \"S \\<subseteq> S' \\<Longrightarrow> cc_restr S' G = cc_restr S' G2 \\<Longrightarrow> cc_restr S G = cc_restr S G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<subseteq> S'; G G|` S' = G2 G|` S'\\<rbrakk>\n    \\<Longrightarrow> G G|` S = G2 G|` S", "by transfer' (auto simp add: Set.filter_def)"], ["", "definition ccSquare (\"_\\<^sup>2\" [80] 80)\n  where \"S\\<^sup>2 = ccProd S S\""], ["", "lemma ccField_ccSquare[simp]: \"ccField (S\\<^sup>2) = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField (S\\<^sup>2) = S", "unfolding ccSquare_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField (S G\\<times> S) = S", "by transfer (auto simp add: Field_def)"], ["", "lemma below_ccSquare[iff]: \"(G \\<sqsubseteq> S\\<^sup>2) = (ccField G \\<subseteq> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G \\<sqsubseteq> S\\<^sup>2) = (ccField G \\<subseteq> S)", "unfolding ccSquare_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G \\<sqsubseteq> S G\\<times> S) = (ccField G \\<subseteq> S)", "by transfer (auto simp add: Field_def)"], ["", "lemma cc_restr_ccSquare[simp]: \"(S'\\<^sup>2) G|` S = (S' \\<inter> S)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S'\\<^sup>2) G|` S = (S' \\<inter> S)\\<^sup>2", "unfolding ccSquare_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (S' G\\<times> S') G|` S = (S' \\<inter> S) G\\<times> (S' \\<inter> S)", "by auto"], ["", "lemma ccSquare_empty[simp]: \"{}\\<^sup>2 = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {}\\<^sup>2 = \\<bottom>", "unfolding ccSquare_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} G\\<times> {} = \\<bottom>", "by simp"], ["", "lift_definition ccNeighbors :: \"var \\<Rightarrow> CoCalls \\<Rightarrow> var set\" \n  is \"\\<lambda> x G. {y .(y,x) \\<in> G \\<or> (x,y) \\<in> G}\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma ccNeighbors_bot[simp]: \"ccNeighbors x \\<bottom> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccNeighbors x \\<bottom> = {}", "by transfer auto"], ["", "lemma cont_ccProd1:\n  \"cont (\\<lambda> S. ccProd S S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>S. S G\\<times> S')", "apply (rule contI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. Y i G\\<times> S') <<|\n       (\\<Squnion>i. Y i) G\\<times> S'", "apply (thin_tac \"chain _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       range (\\<lambda>i. Y i G\\<times> S') <<|\n       (\\<Squnion>i. Y i) G\\<times> S'", "apply (subst lub_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       range (\\<lambda>i. Y i G\\<times> S') <<|\n       \\<Union> (range Y) G\\<times> S'", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y S'.\n       \\<Union> (range Y) \\<times> S' \\<union>\n       S' \\<times> \\<Union> (range Y) =\n       (\\<Union>i. Y i \\<times> S' \\<union> S' \\<times> Y i)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cont_ccProd2:\n  \"cont (\\<lambda> S'. ccProd S S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont ((G\\<times>) S)", "apply (rule contI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       range (\\<lambda>i. S G\\<times> Y i) <<|\n       S G\\<times> (\\<Squnion>i. Y i)", "apply (thin_tac \"chain _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       range (\\<lambda>i. S G\\<times> Y i) <<|\n       S G\\<times> (\\<Squnion>i. Y i)", "apply (subst lub_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       range (\\<lambda>i. S G\\<times> Y i) <<|\n       S G\\<times> \\<Union> (range Y)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y S.\n       S \\<times> \\<Union> (range Y) \\<union>\n       \\<Union> (range Y) \\<times> S =\n       (\\<Union>i. S \\<times> Y i \\<union> Y i \\<times> S)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas cont_compose2[OF cont_ccProd1 cont_ccProd2, simp, cont2cont]"], ["", "lemma cont_ccNeighbors[THEN cont_compose, cont2cont, simp]:\n  \"cont (\\<lambda>y. ccNeighbors x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (ccNeighbors x)", "apply (rule set_contI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       chain Y \\<Longrightarrow>\n       ccNeighbors x (\\<Squnion>i. Y i) = \\<Union> (ccNeighbors x ` range Y)", "apply (thin_tac \"chain _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       ccNeighbors x (\\<Squnion>i. Y i) = \\<Union> (ccNeighbors x ` range Y)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y x.\n       pred_fun top sym Y \\<Longrightarrow>\n       {y. (y, x) \\<in> \\<Union> (range Y) \\<or>\n           (x, y) \\<in> \\<Union> (range Y)} =\n       (\\<Union>G\\<in>range Y. {y. (y, x) \\<in> G \\<or> (x, y) \\<in> G})", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ccNeighbors_join[simp]: \"ccNeighbors x (G \\<squnion> G') = ccNeighbors x G \\<union> ccNeighbors x G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccNeighbors x (G \\<squnion> G') =\n    ccNeighbors x G \\<union> ccNeighbors x G'", "by transfer auto"], ["", "lemma ccNeighbors_ccProd:\n  \"ccNeighbors x (ccProd S S') = (if x \\<in> S then S' else {}) \\<union> (if x \\<in> S' then S else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccNeighbors x (S G\\<times> S') =\n    (if x \\<in> S then S' else {}) \\<union> (if x \\<in> S' then S else {})", "by transfer auto"], ["", "lemma ccNeighbors_ccSquare: \n  \"ccNeighbors x (ccSquare S) = (if x \\<in> S then S else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccNeighbors x (S\\<^sup>2) = (if x \\<in> S then S else {})", "unfolding ccSquare_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccNeighbors x (S G\\<times> S) = (if x \\<in> S then S else {})", "by (auto simp add: ccNeighbors_ccProd)"], ["", "lemma ccNeighbors_cc_restr[simp]:\n  \"ccNeighbors x (cc_restr S G) = (if x \\<in> S then ccNeighbors x G \\<inter> S else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccNeighbors x (G G|` S) =\n    (if x \\<in> S then ccNeighbors x G \\<inter> S else {})", "by transfer auto"], ["", "lemma ccNeighbors_mono:\n  \"G \\<sqsubseteq> G' \\<Longrightarrow> ccNeighbors x G \\<subseteq> ccNeighbors x G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<sqsubseteq> G' \\<Longrightarrow>\n    ccNeighbors x G \\<subseteq> ccNeighbors x G'", "by transfer auto"], ["", "lemma subset_ccNeighbors:\n  \"S \\<subseteq> ccNeighbors x G \\<longleftrightarrow> ccProd {x} S \\<sqsubseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S \\<subseteq> ccNeighbors x G) = ({x} G\\<times> S \\<sqsubseteq> G)", "by transfer (auto simp add: sym_def)"], ["", "lemma elem_ccNeighbors[simp]:\n  \"y \\<in> ccNeighbors x G \\<longleftrightarrow> (y--x\\<in>G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> ccNeighbors x G) = y--x\\<in>G", "by transfer (auto simp add: sym_def)"], ["", "lemma ccNeighbors_ccField:\n  \"ccNeighbors x G \\<subseteq> ccField G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccNeighbors x G \\<subseteq> ccField G", "by transfer (auto simp add: Field_def)"], ["", "lemma ccNeighbors_disjoint_empty[simp]:\n  \"ccNeighbors x G = {} \\<longleftrightarrow> x \\<notin> ccField G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ccNeighbors x G = {}) = (x \\<notin> ccField G)", "by transfer (auto simp add: Field_def)"], ["", "instance CoCalls :: Join_cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(CoCalls, Join_cpo_class)", "by standard (metis coCallsLub_is_lub)"], ["", "lemma ccNeighbors_lub[simp]: \"ccNeighbors x (lub Gs) = lub (ccNeighbors x ` Gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccNeighbors x (lub Gs) = lub (ccNeighbors x ` Gs)", "by transfer (auto simp add: lub_set)"], ["", "inductive list_pairs :: \"'a list \\<Rightarrow> ('a \\<times> 'a) \\<Rightarrow> bool\"\n  where \"list_pairs xs p \\<Longrightarrow> list_pairs (x#xs) p\"\n      | \"y \\<in> set xs \\<Longrightarrow> list_pairs (x#xs) (x,y)\""], ["", "lift_definition ccFromList :: \"var list \\<Rightarrow> CoCalls\" is \"\\<lambda> xs. {(x,y). list_pairs xs (x,y) \\<or> list_pairs xs (y,x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       sym {(x, y). list_pairs list (x, y) \\<or> list_pairs list (y, x)}", "by (auto intro: symI)"], ["", "lemma ccFromList_Nil[simp]: \"ccFromList [] = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccFromList [] = \\<bottom>", "by transfer (auto elim: list_pairs.cases)"], ["", "lemma ccFromList_Cons[simp]: \"ccFromList (x#xs) = ccProd {x} (set xs) \\<squnion> ccFromList xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccFromList (x # xs) = {x} G\\<times> set xs \\<squnion> ccFromList xs", "by transfer (auto elim: list_pairs.cases intro: list_pairs.intros)"], ["", "lemma ccFromList_append[simp]: \"ccFromList (xs@ys) = ccFromList xs \\<squnion> ccFromList ys \\<squnion> ccProd (set xs) (set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccFromList (xs @ ys) =\n    ccFromList xs \\<squnion> ccFromList ys \\<squnion>\n    set xs G\\<times> set ys", "by (induction xs) (auto simp add: ccProd_insert1[where S' = \"set xs\" for xs])"], ["", "lemma ccFromList_filter[simp]:\n  \"ccFromList (filter P xs) = cc_restr {x. P x} (ccFromList xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccFromList (filter P xs) = ccFromList xs G|` {x. P x}", "by (induction xs) (auto simp add: Collect_conj_eq)"], ["", "lemma ccFromList_replicate[simp]: \"ccFromList (replicate n x) = (if n \\<le> 1 then \\<bottom>  else ccProd {x} {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccFromList (replicate n x) =\n    (if n \\<le> 1 then \\<bottom> else {x} G\\<times> {x})", "by (induction n) auto"], ["", "definition ccLinear :: \"var set \\<Rightarrow> CoCalls \\<Rightarrow> bool\"\n  where \"ccLinear S G = (\\<forall> x\\<in>S. \\<forall> y\\<in>S. x--y\\<notin>G)\""], ["", "lemma ccLinear_bottom[simp]:\n  \"ccLinear S \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccLinear S \\<bottom>", "unfolding ccLinear_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S. \\<forall>y\\<in>S. x--y\\<notin>\\<bottom>", "by simp"], ["", "lemma ccLinear_empty[simp]:\n  \"ccLinear {} G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccLinear {} G", "unfolding ccLinear_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{}. \\<forall>y\\<in>{}. x--y\\<notin>G", "by simp"], ["", "lemma ccLinear_lub[simp]:\n  \"ccLinear S (lub X) = (\\<forall> G\\<in>X. ccLinear S G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccLinear S (lub X) = (\\<forall>G\\<in>X. ccLinear S G)", "unfolding ccLinear_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>S. \\<forall>y\\<in>S. x--y\\<notin>lub X) =\n    (\\<forall>G\\<in>X. \\<forall>x\\<in>S. \\<forall>y\\<in>S. x--y\\<notin>G)", "by auto"], ["", "(*\nlemma ccLinear_ccNeighbors:\n  \"ccLinear S G \\<Longrightarrow> ccNeighbors S G \\<inter> S = {}\"\n unfolding ccLinear_def by transfer auto\n*)"], ["", "lemma ccLinear_cc_restr[intro]:\n  \"ccLinear S G \\<Longrightarrow> ccLinear S (cc_restr S' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccLinear S G \\<Longrightarrow> ccLinear S (G G|` S')", "unfolding ccLinear_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S. \\<forall>y\\<in>S. x--y\\<notin>G \\<Longrightarrow>\n    \\<forall>x\\<in>S. \\<forall>y\\<in>S. x--y\\<notin>(G G|` S')", "by transfer auto"], ["", "(* TODO: Sort *)"], ["", "lemma ccLinear_join[simp]:\n  \"ccLinear S (G \\<squnion> G') \\<longleftrightarrow> ccLinear S G \\<and> ccLinear S G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccLinear S (G \\<squnion> G') = (ccLinear S G \\<and> ccLinear S G')", "unfolding ccLinear_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>S. \\<forall>y\\<in>S. x--y\\<notin>(G \\<squnion> G')) =\n    ((\\<forall>x\\<in>S. \\<forall>y\\<in>S. x--y\\<notin>G) \\<and>\n     (\\<forall>x\\<in>S. \\<forall>y\\<in>S. x--y\\<notin>G'))", "by transfer auto"], ["", "lemma ccLinear_ccProd[simp]:\n  \"ccLinear S (ccProd S\\<^sub>1 S\\<^sub>2) \\<longleftrightarrow> S\\<^sub>1 \\<inter> S = {} \\<or> S\\<^sub>2 \\<inter> S = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccLinear S (S\\<^sub>1 G\\<times> S\\<^sub>2) =\n    (S\\<^sub>1 \\<inter> S = {} \\<or> S\\<^sub>2 \\<inter> S = {})", "unfolding ccLinear_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>S.\n        \\<forall>y\\<in>S. x--y\\<notin>(S\\<^sub>1 G\\<times> S\\<^sub>2)) =\n    (S\\<^sub>1 \\<inter> S = {} \\<or> S\\<^sub>2 \\<inter> S = {})", "by transfer auto"], ["", "lemma ccLinear_mono1: \"ccLinear S' G \\<Longrightarrow> S \\<subseteq> S' \\<Longrightarrow> ccLinear S G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ccLinear S' G; S \\<subseteq> S'\\<rbrakk>\n    \\<Longrightarrow> ccLinear S G", "unfolding ccLinear_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>S'. \\<forall>y\\<in>S'. x--y\\<notin>G;\n     S \\<subseteq> S'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>S. \\<forall>y\\<in>S. x--y\\<notin>G", "by transfer auto"], ["", "lemma ccLinear_mono2: \"ccLinear S G' \\<Longrightarrow> G \\<sqsubseteq> G' \\<Longrightarrow> ccLinear S G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ccLinear S G'; G \\<sqsubseteq> G'\\<rbrakk>\n    \\<Longrightarrow> ccLinear S G", "unfolding ccLinear_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>S. \\<forall>y\\<in>S. x--y\\<notin>G';\n     G \\<sqsubseteq> G'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>S. \\<forall>y\\<in>S. x--y\\<notin>G", "by transfer auto"], ["", "lemma ccField_join[simp]:\n  \"ccField (G \\<squnion> G') = ccField G \\<union> ccField G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField (G \\<squnion> G') = ccField G \\<union> ccField G'", "by transfer auto"], ["", "lemma ccField_lub[simp]:\n  \"ccField (lub S) = \\<Union>(ccField ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField (lub S) = \\<Union> (ccField ` S)", "by transfer auto"], ["", "lemma ccField_ccProd:\n  \"ccField (ccProd S S') = (if S = {} then {} else if S' = {} then {} else  S \\<union> S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField (S G\\<times> S') =\n    (if S = {} then {} else if S' = {} then {} else S \\<union> S')", "by transfer (auto simp add: Field_def)"], ["", "lemma ccField_ccProd_subset:\n  \"ccField (ccProd S S') \\<subseteq>  S \\<union> S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField (S G\\<times> S') \\<subseteq> S \\<union> S'", "by (simp add: ccField_ccProd)"], ["", "lemma cont_ccField[THEN cont_compose, simp, cont2cont]:\n  \"cont ccField\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont ccField", "by (rule set_contI) auto"], ["", "end"]]}