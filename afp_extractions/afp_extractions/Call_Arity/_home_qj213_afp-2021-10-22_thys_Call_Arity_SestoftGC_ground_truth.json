{"file_name": "/home/qj213/afp-2021-10-22/thys/Call_Arity/SestoftGC.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Call_Arity", "problem_names": ["lemmas gc_step_intros[intro] =\n  normal[OF step.intros(1)] normal[OF step.intros(2)] normal[OF step.intros(3)]\n  normal[OF step.intros(4)] normal[OF step.intros(5)]  dropUpd", "lemmas converse_rtranclp_into_rtranclp[of gc_step, OF _ r_into_rtranclp, trans]", "lemma var_onceI:\n  assumes \"map_of \\<Gamma> x = Some e\"\n  shows \"(\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\\<^sup>* (delete x \\<Gamma>, e , S@[Dummy x])\"", "lemma normal_trans:  \"c \\<Rightarrow>\\<^sup>* c' \\<Longrightarrow> c \\<Rightarrow>\\<^sub>G\\<^sup>* c'\"", "lemma restr_stack_map_Dummy[simp]: \"restr_stack V (map Dummy l) = map Dummy l\"", "lemma restr_stack_append[simp]: \"restr_stack V (l@l') = restr_stack V l @ restr_stack V l'\"", "lemma to_gc_conf_append[simp]:\n  \"to_gc_conf (r@r') c = to_gc_conf r (to_gc_conf r' c)\"", "lemma to_gc_conf_eqE[elim!]:\n  assumes  \"to_gc_conf r c = (\\<Gamma>, e, S)\"\n  obtains \\<Gamma>' S' where \"c = (\\<Gamma>', e, S')\" and \"\\<Gamma> = restrictA (- set r) \\<Gamma>'\" and \"S = restr_stack (- set r) S' @ map Dummy (rev r)\"", "lemma safe_hd_None[simp]: \"safe_hd xs = None \\<longleftrightarrow> xs = []\"", "lemma subset_bound_invariant:\n  \"invariant step (r_ok r)\"", "lemma safe_hd_restr_stack[simp]:\n  \"Some a = safe_hd (restr_stack V (a # S)) \\<longleftrightarrow> restr_stack V (a # S) = a # restr_stack V S\"", "lemma sestoftUnGCStack:\n  assumes \"heap_upds_ok (\\<Gamma>, S)\"\n  obtains \\<Gamma>' S' where\n    \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\"\n    \"to_gc_conf r (\\<Gamma>, e, S) = to_gc_conf r (\\<Gamma>', e, S')\"\n    \"\\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S')\"", "lemma perm_exI_trivial:\n  \"P x x \\<Longrightarrow> \\<exists> \\<pi>. P (\\<pi> \\<bullet> x) x\"", "lemma upds_list_restr_stack[simp]:\n  \"upds_list (restr_stack V S) = filter (\\<lambda> x. x\\<in>V) (upds_list S)\"", "lemma heap_upd_ok_to_gc_conf:\n  \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> to_gc_conf r (\\<Gamma>, e, S) = (\\<Gamma>'', e'', S'') \\<Longrightarrow> heap_upds_ok (\\<Gamma>'', S'')\"", "lemma delete_restrictA_conv:\n  \"delete x \\<Gamma> = restrictA (-{x}) \\<Gamma>\"", "lemma sestoftUnGCstep:\n  assumes \"to_gc_conf r c \\<Rightarrow>\\<^sub>G d\"\n  assumes \"heap_upds_ok_conf c\"\n  assumes \"closed c\"\n  and \"r_ok r c\"\n  shows   \"\\<exists> r' c'. c \\<Rightarrow>\\<^sup>* c' \\<and> d = to_gc_conf r' c' \\<and> r_ok r' c'\"", "lemma sestoftUnGC:\n  assumes \"(to_gc_conf r c) \\<Rightarrow>\\<^sub>G\\<^sup>* d\" and \"heap_upds_ok_conf c\" and \"closed c\" and \"r_ok r c\"\n  shows   \"\\<exists> r' c'. c \\<Rightarrow>\\<^sup>* c' \\<and> d = to_gc_conf r' c' \\<and> r_ok r' c'\"", "lemma dummies_unchanged_invariant:\n  \"invariant step (\\<lambda> (\\<Gamma>, e, S) . dummies S = V)\" (is \"invariant _ ?I\")", "lemma sestoftUnGC':\n  assumes \"([], e, []) \\<Rightarrow>\\<^sub>G\\<^sup>* (\\<Gamma>, e', map Dummy r)\"\n  assumes \"isVal e'\"\n  assumes \"fv e = ({}::var set)\"\n  shows   \"\\<exists> \\<Gamma>''. ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and> \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and> set r \\<subseteq> domA \\<Gamma>''\""], "translations": [["", "lemmas gc_step_intros[intro] =\n  normal[OF step.intros(1)] normal[OF step.intros(2)] normal[OF step.intros(3)]\n  normal[OF step.intros(4)] normal[OF step.intros(5)]  dropUpd"], ["", "abbreviation gc_steps (infix \"\\<Rightarrow>\\<^sub>G\\<^sup>*\" 50) where \"gc_steps \\<equiv> gc_step\\<^sup>*\\<^sup>*\""], ["", "lemmas converse_rtranclp_into_rtranclp[of gc_step, OF _ r_into_rtranclp, trans]"], ["", "lemma var_onceI:\n  assumes \"map_of \\<Gamma> x = Some e\"\n  shows \"(\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\\<^sup>* (delete x \\<Gamma>, e , S@[Dummy x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\\<^sup>*\n    (delete x \\<Gamma>, e, S @ [Dummy x])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\\<^sup>*\n    (delete x \\<Gamma>, e, S @ [Dummy x])", "from assms"], ["proof (chain)\npicking this:\n  map_of \\<Gamma> x = Some e", "have \"(\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G (delete x \\<Gamma>, e , Upd x # S)\""], ["proof (prove)\nusing this:\n  map_of \\<Gamma> x = Some e\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\n    (delete x \\<Gamma>, e, Upd x # S)", ".."], ["proof (state)\nthis:\n  (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\n  (delete x \\<Gamma>, e, Upd x # S)\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\\<^sup>*\n    (delete x \\<Gamma>, e, S @ [Dummy x])", "moreover"], ["proof (state)\nthis:\n  (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\n  (delete x \\<Gamma>, e, Upd x # S)\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\\<^sup>*\n    (delete x \\<Gamma>, e, S @ [Dummy x])", "have \"\\<dots> \\<Rightarrow>\\<^sub>G  (delete x \\<Gamma>, e, S@[Dummy x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (delete x \\<Gamma>, e, Upd x # S) \\<Rightarrow>\\<^sub>G\n    (delete x \\<Gamma>, e, S @ [Dummy x])", ".."], ["proof (state)\nthis:\n  (delete x \\<Gamma>, e, Upd x # S) \\<Rightarrow>\\<^sub>G\n  (delete x \\<Gamma>, e, S @ [Dummy x])\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\\<^sup>*\n    (delete x \\<Gamma>, e, S @ [Dummy x])", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\n  (delete x \\<Gamma>, e, Upd x # S)\n  (delete x \\<Gamma>, e, Upd x # S) \\<Rightarrow>\\<^sub>G\n  (delete x \\<Gamma>, e, S @ [Dummy x])", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\n  (delete x \\<Gamma>, e, Upd x # S)\n  (delete x \\<Gamma>, e, Upd x # S) \\<Rightarrow>\\<^sub>G\n  (delete x \\<Gamma>, e, S @ [Dummy x])\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\\<^sup>*\n    (delete x \\<Gamma>, e, S @ [Dummy x])", "by (rule converse_rtranclp_into_rtranclp[OF _ r_into_rtranclp])"], ["proof (state)\nthis:\n  (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sub>G\\<^sup>*\n  (delete x \\<Gamma>, e, S @ [Dummy x])\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma lam_and_restrict:\n  assumes \"atom ` domA \\<Delta> \\<sharp>* \\<Gamma>\" and \"atom ` domA \\<Delta> \\<sharp>* S\"\n  assumes \"V \\<subseteq> domA \\<Delta>\"\n  shows \"(\\<Gamma>, Let \\<Delta> e, S) \\<Rightarrow>\\<^sub>G\\<^sup>* (restrictA V \\<Delta> @ \\<Gamma>, e, S)\"\nproof-\n  from assms(1,2) have \"(\\<Gamma>, Let \\<Delta> e, S) \\<Rightarrow>\\<^sub>G (\\<Delta> @ \\<Gamma>, e, S)\"..\n  also\n  have \"\\<dots> \\<Rightarrow>\\<^sub>G (restrictA (V \\<union> domA \\<Gamma>) (\\<Delta> @ \\<Gamma>), e, S)\"..\n  also\n  from fresh_distinct[OF assms(1)]\n  have \"restrictA (V \\<union> domA \\<Gamma>) \\<Delta> = restrictA V \\<Delta>\" by (induction \\<Delta>) auto\n  hence \"restrictA (V \\<union> domA \\<Gamma>) (\\<Delta> @ \\<Gamma>) = restrictA V \\<Delta> @ \\<Gamma>\"\n    by (simp add: restrictA_append restrictA_noop)\n  finally show ?thesis.\nqed\n*)"], ["", "lemma normal_trans:  \"c \\<Rightarrow>\\<^sup>* c' \\<Longrightarrow> c \\<Rightarrow>\\<^sub>G\\<^sup>* c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<Rightarrow>\\<^sup>* c' \\<Longrightarrow>\n    c \\<Rightarrow>\\<^sub>G\\<^sup>* c'", "by (induction rule:rtranclp_induct)\n     (simp, metis normal rtranclp.rtrancl_into_rtrancl)"], ["", "fun to_gc_conf :: \"var list \\<Rightarrow> conf \\<Rightarrow> conf\"\n  where \"to_gc_conf r (\\<Gamma>, e, S) = (restrictA (- set r) \\<Gamma>, e, restr_stack (- set r) S @ (map Dummy (rev r)))\""], ["", "lemma restr_stack_map_Dummy[simp]: \"restr_stack V (map Dummy l) = map Dummy l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restr_stack V (map Dummy l) = map Dummy l", "by (induction l) auto"], ["", "lemma restr_stack_append[simp]: \"restr_stack V (l@l') = restr_stack V l @ restr_stack V l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restr_stack V (l @ l') = restr_stack V l @ restr_stack V l'", "by (induction l rule: restr_stack.induct) auto"], ["", "lemma to_gc_conf_append[simp]:\n  \"to_gc_conf (r@r') c = to_gc_conf r (to_gc_conf r' c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_gc_conf (r @ r') c = to_gc_conf r (to_gc_conf r' c)", "by (cases c) auto"], ["", "lemma to_gc_conf_eqE[elim!]:\n  assumes  \"to_gc_conf r c = (\\<Gamma>, e, S)\"\n  obtains \\<Gamma>' S' where \"c = (\\<Gamma>', e, S')\" and \"\\<Gamma> = restrictA (- set r) \\<Gamma>'\" and \"S = restr_stack (- set r) S' @ map Dummy (rev r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' S'.\n        \\<lbrakk>c = (\\<Gamma>', e, S');\n         \\<Gamma> = restrictA (- set r) \\<Gamma>';\n         S = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  to_gc_conf r c = (\\<Gamma>, e, S)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' S'.\n        \\<lbrakk>c = (\\<Gamma>', e, S');\n         \\<Gamma> = restrictA (- set r) \\<Gamma>';\n         S = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases c) auto"], ["", "fun safe_hd :: \"'a list \\<Rightarrow> 'a option\"\n where  \"safe_hd (x#_) = Some x\"\n     |  \"safe_hd [] = None\""], ["", "lemma safe_hd_None[simp]: \"safe_hd xs = None \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (safe_hd xs = None) = (xs = [])", "by (cases xs) auto"], ["", "abbreviation r_ok :: \"var list \\<Rightarrow> conf \\<Rightarrow> bool\"\n  where \"r_ok r c \\<equiv> set r \\<subseteq> domA (fst c) \\<union> upds (snd (snd c))\""], ["", "lemma subset_bound_invariant:\n  \"invariant step (r_ok r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant (\\<Rightarrow>) (r_ok r)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<Rightarrow> y; r_ok r x\\<rbrakk>\n       \\<Longrightarrow> r_ok r y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<Rightarrow> y; r_ok r x\\<rbrakk>\n       \\<Longrightarrow> r_ok r y", "assume \"x \\<Rightarrow> y\" and \"r_ok r x\""], ["proof (state)\nthis:\n  x \\<Rightarrow> y\n  r_ok r x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<Rightarrow> y; r_ok r x\\<rbrakk>\n       \\<Longrightarrow> r_ok r y", "thus \"r_ok r y\""], ["proof (prove)\nusing this:\n  x \\<Rightarrow> y\n  r_ok r x\n\ngoal (1 subgoal):\n 1. r_ok r y", "by (induction) auto"], ["proof (state)\nthis:\n  r_ok r y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma safe_hd_restr_stack[simp]:\n  \"Some a = safe_hd (restr_stack V (a # S)) \\<longleftrightarrow> restr_stack V (a # S) = a # restr_stack V S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Some a = safe_hd (restr_stack V (a # S))) =\n    (restr_stack V (a # S) = a # restr_stack V S)", "apply (cases a)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       a = Alts x11 x12 \\<Longrightarrow>\n       (Some a = safe_hd (restr_stack V (a # S))) =\n       (restr_stack V (a # S) = a # restr_stack V S)\n 2. \\<And>x2.\n       a = Arg x2 \\<Longrightarrow>\n       (Some a = safe_hd (restr_stack V (a # S))) =\n       (restr_stack V (a # S) = a # restr_stack V S)\n 3. \\<And>x3.\n       a = Upd x3 \\<Longrightarrow>\n       (Some a = safe_hd (restr_stack V (a # S))) =\n       (restr_stack V (a # S) = a # restr_stack V S)\n 4. \\<And>x4.\n       a = Dummy x4 \\<Longrightarrow>\n       (Some a = safe_hd (restr_stack V (a # S))) =\n       (restr_stack V (a # S) = a # restr_stack V S)", "apply (auto split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>a = Upd x3; x3 \\<notin> V;\n        Some (Upd x3) = safe_hd (restr_stack V S)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (thin_tac \"P a\" for P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>x3 \\<notin> V;\n        Some (Upd x3) = safe_hd (restr_stack V S)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (induction S rule: restr_stack.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>V x3.\n       \\<lbrakk>x3 \\<notin> V;\n        Some (Upd x3) = safe_hd (restr_stack V [])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>V e1 e2 S x3.\n       \\<lbrakk>\\<And>x3.\n                   \\<lbrakk>x3 \\<notin> V;\n                    Some (Upd x3) = safe_hd (restr_stack V S)\\<rbrakk>\n                   \\<Longrightarrow> False;\n        x3 \\<notin> V;\n        Some (Upd x3) = safe_hd (restr_stack V (Alts e1 e2 # S))\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>V x S x3.\n       \\<lbrakk>\\<And>x3.\n                   \\<lbrakk>x3 \\<notin> V;\n                    Some (Upd x3) = safe_hd (restr_stack V S)\\<rbrakk>\n                   \\<Longrightarrow> False;\n        x3 \\<notin> V;\n        Some (Upd x3) = safe_hd (restr_stack V (Arg x # S))\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>V x S x3.\n       \\<lbrakk>\\<And>x3.\n                   \\<lbrakk>x \\<in> V; x3 \\<notin> V;\n                    Some (Upd x3) = safe_hd (restr_stack V S)\\<rbrakk>\n                   \\<Longrightarrow> False;\n        \\<And>x3.\n           \\<lbrakk>x \\<notin> V; x3 \\<notin> V;\n            Some (Upd x3) = safe_hd (restr_stack V S)\\<rbrakk>\n           \\<Longrightarrow> False;\n        x3 \\<notin> V;\n        Some (Upd x3) = safe_hd (restr_stack V (Upd x # S))\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>V x S x3.\n       \\<lbrakk>\\<And>x3.\n                   \\<lbrakk>x3 \\<notin> V;\n                    Some (Upd x3) = safe_hd (restr_stack V S)\\<rbrakk>\n                   \\<Longrightarrow> False;\n        x3 \\<notin> V;\n        Some (Upd x3) = safe_hd (restr_stack V (Dummy x # S))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sestoftUnGCStack:\n  assumes \"heap_upds_ok (\\<Gamma>, S)\"\n  obtains \\<Gamma>' S' where\n    \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\"\n    \"to_gc_conf r (\\<Gamma>, e, S) = to_gc_conf r (\\<Gamma>', e, S')\"\n    \"\\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' S'.\n        \\<lbrakk>(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S');\n         to_gc_conf r (\\<Gamma>, e, S) = to_gc_conf r (\\<Gamma>', e, S');\n         \\<not> isVal e \\<or>\n         safe_hd S' = safe_hd (restr_stack (- set r) S')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' S'.\n        \\<lbrakk>(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S');\n         to_gc_conf r (\\<Gamma>, e, S) = to_gc_conf r (\\<Gamma>', e, S');\n         \\<not> isVal e \\<or>\n         safe_hd S' = safe_hd (restr_stack (- set r) S')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof(cases \"isVal e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. isVal e \\<Longrightarrow> thesis\n 2. \\<not> isVal e \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> isVal e\n\ngoal (2 subgoals):\n 1. isVal e \\<Longrightarrow> thesis\n 2. \\<not> isVal e \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> isVal e\n\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<not> isVal e\n  heap_upds_ok (\\<Gamma>, S)\n\ngoal (1 subgoal):\n 1. thesis", "by -(rule that, auto)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. isVal e \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. isVal e \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  isVal e\n\ngoal (1 subgoal):\n 1. isVal e \\<Longrightarrow> thesis", "from that assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (?\\<Gamma>', e, ?S');\n   to_gc_conf r (\\<Gamma>, e, S) = to_gc_conf r (?\\<Gamma>', e, ?S');\n   \\<not> isVal e \\<or>\n   safe_hd ?S' = safe_hd (restr_stack (- set r) ?S')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  heap_upds_ok (\\<Gamma>, S)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (?\\<Gamma>', e, ?S');\n   to_gc_conf r (\\<Gamma>, e, S) = to_gc_conf r (?\\<Gamma>', e, ?S');\n   \\<not> isVal e \\<or>\n   safe_hd ?S' = safe_hd (restr_stack (- set r) ?S')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  heap_upds_ok (\\<Gamma>, S)\n\ngoal (1 subgoal):\n 1. thesis", "apply (atomize_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow>\n    \\<exists>\\<Gamma>' S'.\n       (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, S) =\n       to_gc_conf r (\\<Gamma>', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "proof(induction S arbitrary: \\<Gamma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma>.\n       heap_upds_ok (\\<Gamma>, []) \\<Longrightarrow>\n       \\<exists>\\<Gamma>' S'.\n          (\\<Gamma>, e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S') \\<and>\n          to_gc_conf r (\\<Gamma>, e, []) =\n          to_gc_conf r (\\<Gamma>', e, S') \\<and>\n          (\\<not> isVal e \\<or>\n           safe_hd S' = safe_hd (restr_stack (- set r) S'))\n 2. \\<And>a S \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow>\n                   \\<exists>\\<Gamma>' S'.\n                      (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n                      (\\<Gamma>', e, S') \\<and>\n                      to_gc_conf r (\\<Gamma>, e, S) =\n                      to_gc_conf r (\\<Gamma>', e, S') \\<and>\n                      (\\<not> isVal e \\<or>\n                       safe_hd S' = safe_hd (restr_stack (- set r) S'));\n        heap_upds_ok (\\<Gamma>, a # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>' S'.\n                            (\\<Gamma>, e, a # S) \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>', e, S') \\<and>\n                            to_gc_conf r (\\<Gamma>, e, a # S) =\n                            to_gc_conf r (\\<Gamma>', e, S') \\<and>\n                            (\\<not> isVal e \\<or>\n                             safe_hd S' =\n                             safe_hd (restr_stack (- set r) S'))", "case Nil"], ["proof (state)\nthis:\n  heap_upds_ok (\\<Gamma>, [])\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma>.\n       heap_upds_ok (\\<Gamma>, []) \\<Longrightarrow>\n       \\<exists>\\<Gamma>' S'.\n          (\\<Gamma>, e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S') \\<and>\n          to_gc_conf r (\\<Gamma>, e, []) =\n          to_gc_conf r (\\<Gamma>', e, S') \\<and>\n          (\\<not> isVal e \\<or>\n           safe_hd S' = safe_hd (restr_stack (- set r) S'))\n 2. \\<And>a S \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow>\n                   \\<exists>\\<Gamma>' S'.\n                      (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n                      (\\<Gamma>', e, S') \\<and>\n                      to_gc_conf r (\\<Gamma>, e, S) =\n                      to_gc_conf r (\\<Gamma>', e, S') \\<and>\n                      (\\<not> isVal e \\<or>\n                       safe_hd S' = safe_hd (restr_stack (- set r) S'));\n        heap_upds_ok (\\<Gamma>, a # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>' S'.\n                            (\\<Gamma>, e, a # S) \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>', e, S') \\<and>\n                            to_gc_conf r (\\<Gamma>, e, a # S) =\n                            to_gc_conf r (\\<Gamma>', e, S') \\<and>\n                            (\\<not> isVal e \\<or>\n                             safe_hd S' =\n                             safe_hd (restr_stack (- set r) S'))", "thus ?case"], ["proof (prove)\nusing this:\n  heap_upds_ok (\\<Gamma>, [])\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, []) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "by (fastforce)"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>'' S'.\n     (\\<Gamma>, e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n     to_gc_conf r (\\<Gamma>, e, []) =\n     to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n     (\\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S'))\n\ngoal (1 subgoal):\n 1. \\<And>a S \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow>\n                   \\<exists>\\<Gamma>' S'.\n                      (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n                      (\\<Gamma>', e, S') \\<and>\n                      to_gc_conf r (\\<Gamma>, e, S) =\n                      to_gc_conf r (\\<Gamma>', e, S') \\<and>\n                      (\\<not> isVal e \\<or>\n                       safe_hd S' = safe_hd (restr_stack (- set r) S'));\n        heap_upds_ok (\\<Gamma>, a # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>' S'.\n                            (\\<Gamma>, e, a # S) \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>', e, S') \\<and>\n                            to_gc_conf r (\\<Gamma>, e, a # S) =\n                            to_gc_conf r (\\<Gamma>', e, S') \\<and>\n                            (\\<not> isVal e \\<or>\n                             safe_hd S' =\n                             safe_hd (restr_stack (- set r) S'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a S \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow>\n                   \\<exists>\\<Gamma>' S'.\n                      (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n                      (\\<Gamma>', e, S') \\<and>\n                      to_gc_conf r (\\<Gamma>, e, S) =\n                      to_gc_conf r (\\<Gamma>', e, S') \\<and>\n                      (\\<not> isVal e \\<or>\n                       safe_hd S' = safe_hd (restr_stack (- set r) S'));\n        heap_upds_ok (\\<Gamma>, a # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>' S'.\n                            (\\<Gamma>, e, a # S) \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>', e, S') \\<and>\n                            to_gc_conf r (\\<Gamma>, e, a # S) =\n                            to_gc_conf r (\\<Gamma>', e, S') \\<and>\n                            (\\<not> isVal e \\<or>\n                             safe_hd S' =\n                             safe_hd (restr_stack (- set r) S'))", "case (Cons s S)"], ["proof (state)\nthis:\n  heap_upds_ok (?\\<Gamma>, S) \\<Longrightarrow>\n  \\<exists>\\<Gamma>' S'.\n     (?\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S') \\<and>\n     to_gc_conf r (?\\<Gamma>, e, S) = to_gc_conf r (\\<Gamma>', e, S') \\<and>\n     (\\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S'))\n  heap_upds_ok (\\<Gamma>, s # S)\n\ngoal (1 subgoal):\n 1. \\<And>a S \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow>\n                   \\<exists>\\<Gamma>' S'.\n                      (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n                      (\\<Gamma>', e, S') \\<and>\n                      to_gc_conf r (\\<Gamma>, e, S) =\n                      to_gc_conf r (\\<Gamma>', e, S') \\<and>\n                      (\\<not> isVal e \\<or>\n                       safe_hd S' = safe_hd (restr_stack (- set r) S'));\n        heap_upds_ok (\\<Gamma>, a # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>' S'.\n                            (\\<Gamma>, e, a # S) \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>', e, S') \\<and>\n                            to_gc_conf r (\\<Gamma>, e, a # S) =\n                            to_gc_conf r (\\<Gamma>', e, S') \\<and>\n                            (\\<not> isVal e \\<or>\n                             safe_hd S' =\n                             safe_hd (restr_stack (- set r) S'))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "proof(cases \"Some s = safe_hd (restr_stack (- set r) (s#S))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Some s = safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))\n 2. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "case True"], ["proof (state)\nthis:\n  Some s = safe_hd (restr_stack (- set r) (s # S))\n\ngoal (2 subgoals):\n 1. Some s = safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))\n 2. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Some s = safe_hd (restr_stack (- set r) (s # S))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "using \\<open>isVal e\\<close> \\<open>heap_upds_ok (\\<Gamma>, s # S)\\<close>"], ["proof (prove)\nusing this:\n  Some s = safe_hd (restr_stack (- set r) (s # S))\n  isVal e\n  heap_upds_ok (\\<Gamma>, s # S)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>restr_stack (- set r) (s # S) = s # restr_stack (- set r) S;\n     isVal e; heap_upds_ok (\\<Gamma>, s # S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>'' S'.\n                         (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>*\n                         (\\<Gamma>'', e, S') \\<and>\n                         restrictA (- set r) \\<Gamma> =\n                         restrictA (- set r) \\<Gamma>'' \\<and>\n                         s # restr_stack (- set r) S =\n                         restr_stack (- set r) S' \\<and>\n                         safe_hd S' = safe_hd (restr_stack (- set r) S')", "apply (intro exI conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>restr_stack (- set r) (s # S) = s # restr_stack (- set r) S;\n     isVal e; heap_upds_ok (\\<Gamma>, s # S)\\<rbrakk>\n    \\<Longrightarrow> (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>*\n                      (?\\<Gamma>'3, e, ?S'4)\n 2. \\<lbrakk>restr_stack (- set r) (s # S) = s # restr_stack (- set r) S;\n     isVal e; heap_upds_ok (\\<Gamma>, s # S)\\<rbrakk>\n    \\<Longrightarrow> restrictA (- set r) \\<Gamma> =\n                      restrictA (- set r) ?\\<Gamma>'3\n 3. \\<lbrakk>restr_stack (- set r) (s # S) = s # restr_stack (- set r) S;\n     isVal e; heap_upds_ok (\\<Gamma>, s # S)\\<rbrakk>\n    \\<Longrightarrow> s # restr_stack (- set r) S =\n                      restr_stack (- set r) ?S'4\n 4. \\<lbrakk>restr_stack (- set r) (s # S) = s # restr_stack (- set r) S;\n     isVal e; heap_upds_ok (\\<Gamma>, s # S)\\<rbrakk>\n    \\<Longrightarrow> safe_hd ?S'4 = safe_hd (restr_stack (- set r) ?S'4)", "apply (rule rtranclp.intros(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>restr_stack (- set r) (s # S) = s # restr_stack (- set r) S;\n     isVal e; heap_upds_ok (\\<Gamma>, s # S)\\<rbrakk>\n    \\<Longrightarrow> restrictA (- set r) \\<Gamma> =\n                      restrictA (- set r) \\<Gamma>\n 2. \\<lbrakk>restr_stack (- set r) (s # S) = s # restr_stack (- set r) S;\n     isVal e; heap_upds_ok (\\<Gamma>, s # S)\\<rbrakk>\n    \\<Longrightarrow> s # restr_stack (- set r) S =\n                      restr_stack (- set r) (s # S)\n 3. \\<lbrakk>restr_stack (- set r) (s # S) = s # restr_stack (- set r) S;\n     isVal e; heap_upds_ok (\\<Gamma>, s # S)\\<rbrakk>\n    \\<Longrightarrow> safe_hd (s # S) =\n                      safe_hd (restr_stack (- set r) (s # S))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>'' S'.\n     (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n     to_gc_conf r (\\<Gamma>, e, s # S) =\n     to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n     (\\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S'))\n\ngoal (1 subgoal):\n 1. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "case False"], ["proof (state)\nthis:\n  Some s \\<noteq> safe_hd (restr_stack (- set r) (s # S))\n\ngoal (1 subgoal):\n 1. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "then"], ["proof (chain)\npicking this:\n  Some s \\<noteq> safe_hd (restr_stack (- set r) (s # S))", "obtain x where [simp]: \"s = Upd x\" and [simp]: \"x \\<in> set r\""], ["proof (prove)\nusing this:\n  Some s \\<noteq> safe_hd (restr_stack (- set r) (s # S))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>s = Upd x; x \\<in> set r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s) (auto split: if_splits)"], ["proof (state)\nthis:\n  s = Upd x\n  x \\<in> set r\n\ngoal (1 subgoal):\n 1. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "from \\<open>heap_upds_ok (\\<Gamma>, s # S)\\<close> \\<open>s = Upd x\\<close>"], ["proof (chain)\npicking this:\n  heap_upds_ok (\\<Gamma>, s # S)\n  s = Upd x", "have [simp]: \"x \\<notin> domA \\<Gamma>\" and \"heap_upds_ok ((x,e) # \\<Gamma>, S)\""], ["proof (prove)\nusing this:\n  heap_upds_ok (\\<Gamma>, s # S)\n  s = Upd x\n\ngoal (1 subgoal):\n 1. x \\<notin> domA \\<Gamma> &&& heap_upds_ok ((x, e) # \\<Gamma>, S)", "by (auto dest: heap_upds_okE)"], ["proof (state)\nthis:\n  x \\<notin> domA \\<Gamma>\n  heap_upds_ok ((x, e) # \\<Gamma>, S)\n\ngoal (1 subgoal):\n 1. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "have \"(\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, e, Upd x # S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, e, Upd x # S)", "unfolding \\<open>s = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, e, Upd x # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, e, Upd x # S)", ".."], ["proof (state)\nthis:\n  (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, e, Upd x # S)\n\ngoal (1 subgoal):\n 1. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "also"], ["proof (state)\nthis:\n  (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, e, Upd x # S)\n\ngoal (1 subgoal):\n 1. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "have \"\\<dots> \\<Rightarrow> ((x,e) # \\<Gamma>, e, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, e, Upd x # S) \\<Rightarrow> ((x, e) # \\<Gamma>, e, S)", "by (rule step.var\\<^sub>2[OF \\<open>x \\<notin> domA \\<Gamma>\\<close> \\<open>isVal e\\<close>])"], ["proof (state)\nthis:\n  (\\<Gamma>, e, Upd x # S) \\<Rightarrow> ((x, e) # \\<Gamma>, e, S)\n\ngoal (1 subgoal):\n 1. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "also"], ["proof (state)\nthis:\n  (\\<Gamma>, e, Upd x # S) \\<Rightarrow> ((x, e) # \\<Gamma>, e, S)\n\ngoal (1 subgoal):\n 1. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "from Cons.IH[OF \\<open>heap_upds_ok ((x,e) # \\<Gamma>, S)\\<close> ]"], ["proof (chain)\npicking this:\n  \\<exists>\\<Gamma>'' S'.\n     ((x, e) # \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n     (\\<Gamma>'', e, S') \\<and>\n     to_gc_conf r ((x, e) # \\<Gamma>, e, S) =\n     to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n     (\\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S'))", "obtain \\<Gamma>' S' where  \"((x,e) # \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\"\n            and res: \"to_gc_conf r ((x,e) # \\<Gamma>, e, S) = to_gc_conf r (\\<Gamma>', e, S')\"\n                     \"(\\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S'))\""], ["proof (prove)\nusing this:\n  \\<exists>\\<Gamma>'' S'.\n     ((x, e) # \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n     (\\<Gamma>'', e, S') \\<and>\n     to_gc_conf r ((x, e) # \\<Gamma>, e, S) =\n     to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n     (\\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S'))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>'' S'.\n        \\<lbrakk>((x, e) # \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>'', e, S');\n         to_gc_conf r ((x, e) # \\<Gamma>, e, S) =\n         to_gc_conf r (\\<Gamma>'', e, S');\n         \\<not> isVal e \\<or>\n         safe_hd S' = safe_hd (restr_stack (- set r) S')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ((x, e) # \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\n  to_gc_conf r ((x, e) # \\<Gamma>, e, S) = to_gc_conf r (\\<Gamma>', e, S')\n  \\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S')\n\ngoal (1 subgoal):\n 1. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "note this(1)"], ["proof (state)\nthis:\n  ((x, e) # \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\n\ngoal (1 subgoal):\n 1. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "finally"], ["proof (chain)\npicking this:\n  (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')", "have \"(\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\""], ["proof (prove)\nusing this:\n  (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')", "."], ["proof (state)\nthis:\n  (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\n\ngoal (1 subgoal):\n 1. Some s \\<noteq>\n    safe_hd (restr_stack (- set r) (s # S)) \\<Longrightarrow>\n    \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "using res"], ["proof (prove)\nusing this:\n  (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\n  to_gc_conf r ((x, e) # \\<Gamma>, e, S) = to_gc_conf r (\\<Gamma>', e, S')\n  \\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' S'.\n       (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n       to_gc_conf r (\\<Gamma>, e, s # S) =\n       to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n       (\\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S'))", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>'' S'.\n     (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n     to_gc_conf r (\\<Gamma>, e, s # S) =\n     to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n     (\\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>'' S'.\n     (\\<Gamma>, e, s # S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e, S') \\<and>\n     to_gc_conf r (\\<Gamma>, e, s # S) =\n     to_gc_conf r (\\<Gamma>'', e, S') \\<and>\n     (\\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_exI_trivial:\n  \"P x x \\<Longrightarrow> \\<exists> \\<pi>. P (\\<pi> \\<bullet> x) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x x \\<Longrightarrow> \\<exists>\\<pi>. P (\\<pi> \\<bullet> x) x", "by (rule exI[where x = \"0::perm\"]) auto"], ["", "lemma upds_list_restr_stack[simp]:\n  \"upds_list (restr_stack V S) = filter (\\<lambda> x. x\\<in>V) (upds_list S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upds_list (restr_stack V S) =\n    filter (\\<lambda>x. x \\<in> V) (upds_list S)", "by (induction S rule: restr_stack.induct) auto"], ["", "lemma heap_upd_ok_to_gc_conf:\n  \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> to_gc_conf r (\\<Gamma>, e, S) = (\\<Gamma>'', e'', S'') \\<Longrightarrow> heap_upds_ok (\\<Gamma>'', S'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_upds_ok (\\<Gamma>, S);\n     to_gc_conf r (\\<Gamma>, e, S) = (\\<Gamma>'', e'', S'')\\<rbrakk>\n    \\<Longrightarrow> heap_upds_ok (\\<Gamma>'', S'')", "by (auto simp add: heap_upds_ok.simps)"], ["", "lemma delete_restrictA_conv:\n  \"delete x \\<Gamma> = restrictA (-{x}) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete x \\<Gamma> = restrictA (- {x}) \\<Gamma>", "by (induction \\<Gamma>) auto"], ["", "lemma sestoftUnGCstep:\n  assumes \"to_gc_conf r c \\<Rightarrow>\\<^sub>G d\"\n  assumes \"heap_upds_ok_conf c\"\n  assumes \"closed c\"\n  and \"r_ok r c\"\n  shows   \"\\<exists> r' c'. c \\<Rightarrow>\\<^sup>* c' \\<and> d = to_gc_conf r' c' \\<and> r_ok r' c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "obtain \\<Gamma> e S where \"c = (\\<Gamma>, e, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> e S.\n        c = (\\<Gamma>, e, S) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases c) auto"], ["proof (state)\nthis:\n  c = (\\<Gamma>, e, S)\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "with assms"], ["proof (chain)\npicking this:\n  to_gc_conf r c \\<Rightarrow>\\<^sub>G d\n  heap_upds_ok_conf c\n  closed c\n  r_ok r c\n  c = (\\<Gamma>, e, S)", "have \"heap_upds_ok (\\<Gamma>,S)\" and \"closed (\\<Gamma>, e, S)\" and \"r_ok r (\\<Gamma>, e, S)\""], ["proof (prove)\nusing this:\n  to_gc_conf r c \\<Rightarrow>\\<^sub>G d\n  heap_upds_ok_conf c\n  closed c\n  r_ok r c\n  c = (\\<Gamma>, e, S)\n\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>, S) &&&\n    closed (\\<Gamma>, e, S) &&& r_ok r (\\<Gamma>, e, S)", "by auto"], ["proof (state)\nthis:\n  heap_upds_ok (\\<Gamma>, S)\n  closed (\\<Gamma>, e, S)\n  r_ok r (\\<Gamma>, e, S)\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "from sestoftUnGCStack[OF this(1)]"], ["proof (chain)\npicking this:\n  (\\<And>\\<Gamma>' S'.\n      \\<lbrakk>(\\<Gamma>, ?e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', ?e, S');\n       to_gc_conf ?r (\\<Gamma>, ?e, S) = to_gc_conf ?r (\\<Gamma>', ?e, S');\n       \\<not> isVal ?e \\<or>\n       safe_hd S' = safe_hd (restr_stack (- set ?r) S')\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain \\<Gamma>' S' where\n    \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\"\n    and *: \"to_gc_conf r (\\<Gamma>, e, S) = to_gc_conf r (\\<Gamma>', e, S')\"\n    and disj: \"\\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S')\""], ["proof (prove)\nusing this:\n  (\\<And>\\<Gamma>' S'.\n      \\<lbrakk>(\\<Gamma>, ?e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', ?e, S');\n       to_gc_conf ?r (\\<Gamma>, ?e, S) = to_gc_conf ?r (\\<Gamma>', ?e, S');\n       \\<not> isVal ?e \\<or>\n       safe_hd S' = safe_hd (restr_stack (- set ?r) S')\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' S'.\n        \\<lbrakk>(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S');\n         to_gc_conf r (\\<Gamma>, e, S) = to_gc_conf r (\\<Gamma>', e, S');\n         \\<not> isVal e \\<or>\n         safe_hd S' = safe_hd (restr_stack (- set r) S')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\n  to_gc_conf r (\\<Gamma>, e, S) = to_gc_conf r (\\<Gamma>', e, S')\n  \\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S')\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "from invariant_starE[OF \\<open>_ \\<Rightarrow>\\<^sup>* _\\<close> heap_upds_ok_invariant]  \\<open>heap_upds_ok (\\<Gamma>,S)\\<close>"], ["proof (chain)\npicking this:\n  heap_upds_ok_conf (\\<Gamma>, e, S) \\<Longrightarrow>\n  heap_upds_ok_conf (\\<Gamma>', e, S')\n  heap_upds_ok (\\<Gamma>, S)", "have \"heap_upds_ok (\\<Gamma>', S')\""], ["proof (prove)\nusing this:\n  heap_upds_ok_conf (\\<Gamma>, e, S) \\<Longrightarrow>\n  heap_upds_ok_conf (\\<Gamma>', e, S')\n  heap_upds_ok (\\<Gamma>, S)\n\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>', S')", "by auto"], ["proof (state)\nthis:\n  heap_upds_ok (\\<Gamma>', S')\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "from invariant_starE[OF \\<open>_ \\<Rightarrow>\\<^sup>* _\\<close> closed_invariant  \\<open>closed (\\<Gamma>, e, S)\\<close> ]"], ["proof (chain)\npicking this:\n  closed (\\<Gamma>', e, S')", "have \"closed (\\<Gamma>', e, S')\""], ["proof (prove)\nusing this:\n  closed (\\<Gamma>', e, S')\n\ngoal (1 subgoal):\n 1. closed (\\<Gamma>', e, S')", "by auto"], ["proof (state)\nthis:\n  closed (\\<Gamma>', e, S')\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "from invariant_starE[OF \\<open>_ \\<Rightarrow>\\<^sup>* _\\<close> subset_bound_invariant \\<open>r_ok r (\\<Gamma>, e, S)\\<close> ]"], ["proof (chain)\npicking this:\n  r_ok r (\\<Gamma>', e, S')", "have \"r_ok r (\\<Gamma>', e, S')\""], ["proof (prove)\nusing this:\n  r_ok r (\\<Gamma>', e, S')\n\ngoal (1 subgoal):\n 1. r_ok r (\\<Gamma>', e, S')", "by auto"], ["proof (state)\nthis:\n  r_ok r (\\<Gamma>', e, S')\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "from assms(1)[unfolded \\<open>c =_ \\<close> *]"], ["proof (chain)\npicking this:\n  to_gc_conf r (\\<Gamma>', e, S') \\<Rightarrow>\\<^sub>G d", "have \"\\<exists> r' \\<Gamma>'' e'' S''. (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'') \\<and> d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and> r_ok r' (\\<Gamma>'', e'', S'')\""], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') \\<Rightarrow>\\<^sub>G d\n\ngoal (1 subgoal):\n 1. \\<exists>r' \\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n       (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n       r_ok r' (\\<Gamma>'', e'', S'')", "proof(cases rule: gc_step.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. to_gc_conf r (\\<Gamma>', e, S') \\<Rightarrow> d \\<Longrightarrow>\n    \\<exists>r' \\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n       (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n       r_ok r' (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "case normal"], ["proof (state)\nthis:\n  to_gc_conf r (\\<Gamma>', e, S') \\<Rightarrow> d\n\ngoal (2 subgoals):\n 1. to_gc_conf r (\\<Gamma>', e, S') \\<Rightarrow> d \\<Longrightarrow>\n    \\<exists>r' \\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n       (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n       r_ok r' (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "hence \"\\<exists> \\<Gamma>'' e'' S''. (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and> d = to_gc_conf r (\\<Gamma>'', e'', S'')\""], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') \\<Rightarrow> d\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r (\\<Gamma>'', e'', S'')", "proof(cases rule: step.cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, App ea x, S);\n        d = (\\<Gamma>, ea, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> y ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Lam [y]. ea, Arg x # S);\n        d = (\\<Gamma>, ea[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> x ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, Var x, S);\n        d = (delete x \\<Gamma>, ea, Upd x # S);\n        map_of \\<Gamma> x = Some ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 4. \\<And>x \\<Gamma> ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = ((x, ea) # \\<Gamma>, ea, S); x \\<notin> domA \\<Gamma>;\n        isVal ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 5. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 6. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 7. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "case app\\<^sub>1"], ["proof (state)\nthis:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>_, App e_ x_, S_)\n  d = (\\<Gamma>_, e_, Arg x_ # S_)\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, App ea x, S);\n        d = (\\<Gamma>, ea, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> y ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Lam [y]. ea, Arg x # S);\n        d = (\\<Gamma>, ea[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> x ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, Var x, S);\n        d = (delete x \\<Gamma>, ea, Upd x # S);\n        map_of \\<Gamma> x = Some ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 4. \\<And>x \\<Gamma> ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = ((x, ea) # \\<Gamma>, ea, S); x \\<notin> domA \\<Gamma>;\n        isVal ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 5. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 6. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 7. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "thus ?thesis"], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>_, App e_ x_, S_)\n  d = (\\<Gamma>_, e_, Arg x_ # S_)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r (\\<Gamma>'', e'', S'')", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', e_,\n              Arg x_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = App e_ x_;\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>'' S''.\n                         (\\<Gamma>', App e_ x_, S') \\<Rightarrow>\n                         (\\<Gamma>'', e_, S'') \\<and>\n                         restrictA (- set r) \\<Gamma>' =\n                         restrictA (- set r) \\<Gamma>'' \\<and>\n                         Arg x_ # restr_stack (- set r) S' =\n                         restr_stack (- set r) S''", "apply (intro exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', e_,\n              Arg x_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = App e_ x_;\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> (\\<Gamma>', App e_ x_, S') \\<Rightarrow>\n                      (?\\<Gamma>''11, e_, ?S''12)\n 2. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', e_,\n              Arg x_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = App e_ x_;\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> restrictA (- set r) \\<Gamma>' =\n                      restrictA (- set r) ?\\<Gamma>''11\n 3. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', e_,\n              Arg x_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = App e_ x_;\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> Arg x_ # restr_stack (- set r) S' =\n                      restr_stack (- set r) ?S''12", "apply (rule  step.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', e_,\n              Arg x_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = App e_ x_;\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> restrictA (- set r) \\<Gamma>' =\n                      restrictA (- set r) \\<Gamma>'\n 2. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', e_,\n              Arg x_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = App e_ x_;\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> Arg x_ # restr_stack (- set r) S' =\n                      restr_stack (- set r) (Arg x_ # S')", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r (\\<Gamma>'', e'', S'')\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> y ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Lam [y]. ea, Arg x # S);\n        d = (\\<Gamma>, ea[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> x ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, Var x, S);\n        d = (delete x \\<Gamma>, ea, Upd x # S);\n        map_of \\<Gamma> x = Some ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>x \\<Gamma> ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = ((x, ea) # \\<Gamma>, ea, S); x \\<notin> domA \\<Gamma>;\n        isVal ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 4. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 5. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 6. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> y ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Lam [y]. ea, Arg x # S);\n        d = (\\<Gamma>, ea[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> x ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, Var x, S);\n        d = (delete x \\<Gamma>, ea, Upd x # S);\n        map_of \\<Gamma> x = Some ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>x \\<Gamma> ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = ((x, ea) # \\<Gamma>, ea, S); x \\<notin> domA \\<Gamma>;\n        isVal ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 4. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 5. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 6. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "case (app\\<^sub>2 \\<Gamma> y ea x S)"], ["proof (state)\nthis:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, Lam [y]. ea, Arg x # S)\n  d = (\\<Gamma>, ea[y::=x], S)\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> y ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Lam [y]. ea, Arg x # S);\n        d = (\\<Gamma>, ea[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> x ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, Var x, S);\n        d = (delete x \\<Gamma>, ea, Upd x # S);\n        map_of \\<Gamma> x = Some ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>x \\<Gamma> ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = ((x, ea) # \\<Gamma>, ea, S); x \\<notin> domA \\<Gamma>;\n        isVal ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 4. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 5. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 6. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "thus ?thesis"], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, Lam [y]. ea, Arg x # S)\n  d = (\\<Gamma>, ea[y::=x], S)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r (\\<Gamma>'', e'', S'')", "using disj"], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, Lam [y]. ea, Arg x # S)\n  d = (\\<Gamma>, ea[y::=x], S)\n  \\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r (\\<Gamma>'', e'', S'')", "apply (cases S')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n             (\\<Gamma>, Lam [y]. ea, Arg x # S);\n     d = (\\<Gamma>, ea[y::=x], S);\n     \\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S');\n     S' = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                         (\\<Gamma>', e, S') \\<Rightarrow>\n                         (\\<Gamma>'', e'', S'') \\<and>\n                         d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>a list.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Lam [y]. ea, Arg x # S);\n        d = (\\<Gamma>, ea[y::=x], S);\n        \\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S');\n        S' = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', ea[y::=x],\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Arg x # list; \\<Gamma> = restrictA (- set r) \\<Gamma>';\n        e = Lam [y]. ea;\n        S = restr_stack (- set r) list @ map Dummy (rev r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' S''.\n                            (\\<Gamma>', Lam [y]. ea,\n                             Arg x # list) \\<Rightarrow>\n                            (\\<Gamma>'', ea[y::=x], S'') \\<and>\n                            restrictA (- set r) \\<Gamma>' =\n                            restrictA (- set r) \\<Gamma>'' \\<and>\n                            restr_stack (- set r) list =\n                            restr_stack (- set r) S''", "apply (intro exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', ea[y::=x],\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Arg x # list; \\<Gamma> = restrictA (- set r) \\<Gamma>';\n        e = Lam [y]. ea;\n        S = restr_stack (- set r) list @ map Dummy (rev r)\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>', Lam [y]. ea,\n                          Arg x # list) \\<Rightarrow>\n                         (?\\<Gamma>''27 list, ea[y::=x], ?S''28 list)\n 2. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', ea[y::=x],\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Arg x # list; \\<Gamma> = restrictA (- set r) \\<Gamma>';\n        e = Lam [y]. ea;\n        S = restr_stack (- set r) list @ map Dummy (rev r)\\<rbrakk>\n       \\<Longrightarrow> restrictA (- set r) \\<Gamma>' =\n                         restrictA (- set r) (?\\<Gamma>''27 list)\n 3. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', ea[y::=x],\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Arg x # list; \\<Gamma> = restrictA (- set r) \\<Gamma>';\n        e = Lam [y]. ea;\n        S = restr_stack (- set r) list @ map Dummy (rev r)\\<rbrakk>\n       \\<Longrightarrow> restr_stack (- set r) list =\n                         restr_stack (- set r) (?S''28 list)", "apply (rule step.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', ea[y::=x],\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Arg x # list; \\<Gamma> = restrictA (- set r) \\<Gamma>';\n        e = Lam [y]. ea;\n        S = restr_stack (- set r) list @ map Dummy (rev r)\\<rbrakk>\n       \\<Longrightarrow> restrictA (- set r) \\<Gamma>' =\n                         restrictA (- set r) \\<Gamma>'\n 2. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', ea[y::=x],\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Arg x # list; \\<Gamma> = restrictA (- set r) \\<Gamma>';\n        e = Lam [y]. ea;\n        S = restr_stack (- set r) list @ map Dummy (rev r)\\<rbrakk>\n       \\<Longrightarrow> restr_stack (- set r) list =\n                         restr_stack (- set r) list", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r (\\<Gamma>'', e'', S'')\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> x ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, Var x, S);\n        d = (delete x \\<Gamma>, ea, Upd x # S);\n        map_of \\<Gamma> x = Some ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>x \\<Gamma> ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = ((x, ea) # \\<Gamma>, ea, S); x \\<notin> domA \\<Gamma>;\n        isVal ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 4. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 5. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> x ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, Var x, S);\n        d = (delete x \\<Gamma>, ea, Upd x # S);\n        map_of \\<Gamma> x = Some ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>x \\<Gamma> ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = ((x, ea) # \\<Gamma>, ea, S); x \\<notin> domA \\<Gamma>;\n        isVal ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 4. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 5. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "case var\\<^sub>1"], ["proof (state)\nthis:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>_, Var x_, S_)\n  d = (delete x_ \\<Gamma>_, e_, Upd x_ # S_)\n  map_of \\<Gamma>_ x_ = Some e_\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> x ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, Var x, S);\n        d = (delete x \\<Gamma>, ea, Upd x # S);\n        map_of \\<Gamma> x = Some ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>x \\<Gamma> ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = ((x, ea) # \\<Gamma>, ea, S); x \\<notin> domA \\<Gamma>;\n        isVal ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 4. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 5. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "thus ?thesis"], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>_, Var x_, S_)\n  d = (delete x_ \\<Gamma>_, e_, Upd x_ # S_)\n  map_of \\<Gamma>_ x_ = Some e_\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r (\\<Gamma>'', e'', S'')", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d =\n             (restrictA (- set r - {x_}) \\<Gamma>', e_,\n              Upd x_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     map_of \\<Gamma>' x_ = Some e_;\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = Var x_;\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r);\n     x_ \\<notin> set r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>'' S''.\n                         (\\<Gamma>', Var x_, S') \\<Rightarrow>\n                         (\\<Gamma>'', e_, S'') \\<and>\n                         restrictA (- set r - {x_}) \\<Gamma>' =\n                         restrictA (- set r) \\<Gamma>'' \\<and>\n                         Upd x_ # restr_stack (- set r) S' =\n                         restr_stack (- set r) S''", "apply (intro  exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>d =\n             (restrictA (- set r - {x_}) \\<Gamma>', e_,\n              Upd x_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     map_of \\<Gamma>' x_ = Some e_;\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = Var x_;\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r);\n     x_ \\<notin> set r\\<rbrakk>\n    \\<Longrightarrow> (\\<Gamma>', Var x_, S') \\<Rightarrow>\n                      (?\\<Gamma>''18, e_, ?S''19)\n 2. \\<lbrakk>d =\n             (restrictA (- set r - {x_}) \\<Gamma>', e_,\n              Upd x_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     map_of \\<Gamma>' x_ = Some e_;\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = Var x_;\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r);\n     x_ \\<notin> set r\\<rbrakk>\n    \\<Longrightarrow> restrictA (- set r - {x_}) \\<Gamma>' =\n                      restrictA (- set r) ?\\<Gamma>''18\n 3. \\<lbrakk>d =\n             (restrictA (- set r - {x_}) \\<Gamma>', e_,\n              Upd x_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     map_of \\<Gamma>' x_ = Some e_;\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = Var x_;\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r);\n     x_ \\<notin> set r\\<rbrakk>\n    \\<Longrightarrow> Upd x_ # restr_stack (- set r) S' =\n                      restr_stack (- set r) ?S''19", "apply (rule step.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>d =\n             (restrictA (- set r - {x_}) \\<Gamma>', e_,\n              Upd x_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     map_of \\<Gamma>' x_ = Some e_;\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = Var x_;\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r);\n     x_ \\<notin> set r\\<rbrakk>\n    \\<Longrightarrow> map_of \\<Gamma>' x_ = Some e_\n 2. \\<lbrakk>d =\n             (restrictA (- set r - {x_}) \\<Gamma>', e_,\n              Upd x_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     map_of \\<Gamma>' x_ = Some e_;\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = Var x_;\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r);\n     x_ \\<notin> set r\\<rbrakk>\n    \\<Longrightarrow> restrictA (- set r - {x_}) \\<Gamma>' =\n                      restrictA (- set r) (delete x_ \\<Gamma>')\n 3. \\<lbrakk>d =\n             (restrictA (- set r - {x_}) \\<Gamma>', e_,\n              Upd x_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     map_of \\<Gamma>' x_ = Some e_;\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = Var x_;\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r);\n     x_ \\<notin> set r\\<rbrakk>\n    \\<Longrightarrow> Upd x_ # restr_stack (- set r) S' =\n                      restr_stack (- set r) (Upd x_ # S')", "apply (auto simp add: restr_delete_twist)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r (\\<Gamma>'', e'', S'')\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = ((x, ea) # \\<Gamma>, ea, S); x \\<notin> domA \\<Gamma>;\n        isVal ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 4. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = ((x, ea) # \\<Gamma>, ea, S); x \\<notin> domA \\<Gamma>;\n        isVal ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 4. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "case var\\<^sub>2"], ["proof (state)\nthis:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>_, e_, Upd x_ # S_)\n  d = ((x_, e_) # \\<Gamma>_, e_, S_)\n  x_ \\<notin> domA \\<Gamma>_\n  isVal e_\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> ea S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = ((x, ea) # \\<Gamma>, ea, S); x \\<notin> domA \\<Gamma>;\n        isVal ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 4. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "thus ?thesis"], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>_, e_, Upd x_ # S_)\n  d = ((x_, e_) # \\<Gamma>_, e_, S_)\n  x_ \\<notin> domA \\<Gamma>_\n  isVal e_\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r (\\<Gamma>'', e'', S'')", "using disj"], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>_, e_, Upd x_ # S_)\n  d = ((x_, e_) # \\<Gamma>_, e_, S_)\n  x_ \\<notin> domA \\<Gamma>_\n  isVal e_\n  \\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r (\\<Gamma>'', e'', S'')", "apply (cases S')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>_, e_, Upd x_ # S_);\n     d = ((x_, e_) # \\<Gamma>_, e_, S_); x_ \\<notin> domA \\<Gamma>_;\n     isVal e_;\n     \\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S');\n     S' = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                         (\\<Gamma>', e, S') \\<Rightarrow>\n                         (\\<Gamma>'', e'', S'') \\<and>\n                         d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>a list.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>_, e_, Upd x_ # S_);\n        d = ((x_, e_) # \\<Gamma>_, e_, S_); x_ \\<notin> domA \\<Gamma>_;\n        isVal e_;\n        \\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S');\n        S' = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       \\<lbrakk>d =\n                ((x_, e_) # restrictA (- set r) \\<Gamma>', e_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        isVal e_;\n        (if x_ \\<notin> set r then Upd x_ # restr_stack (- set r) list\n         else restr_stack (- set r) list) =\n        Upd x_ # restr_stack (- set r) list;\n        S' = Upd x_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = e_; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        x_ \\<notin> domA \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' S''.\n                            (\\<Gamma>', e_, Upd x_ # list) \\<Rightarrow>\n                            (\\<Gamma>'', e_, S'') \\<and>\n                            (x_, e_) # restrictA (- set r) \\<Gamma>' =\n                            restrictA (- set r) \\<Gamma>'' \\<and>\n                            restr_stack (- set r) list =\n                            restr_stack (- set r) S''", "apply (intro exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>d =\n                ((x_, e_) # restrictA (- set r) \\<Gamma>', e_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        isVal e_;\n        (if x_ \\<notin> set r then Upd x_ # restr_stack (- set r) list\n         else restr_stack (- set r) list) =\n        Upd x_ # restr_stack (- set r) list;\n        S' = Upd x_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = e_; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        x_ \\<notin> domA \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>', e_, Upd x_ # list) \\<Rightarrow>\n                         (?\\<Gamma>''29 list, e_, ?S''30 list)\n 2. \\<And>list.\n       \\<lbrakk>d =\n                ((x_, e_) # restrictA (- set r) \\<Gamma>', e_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        isVal e_;\n        (if x_ \\<notin> set r then Upd x_ # restr_stack (- set r) list\n         else restr_stack (- set r) list) =\n        Upd x_ # restr_stack (- set r) list;\n        S' = Upd x_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = e_; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        x_ \\<notin> domA \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> (x_, e_) # restrictA (- set r) \\<Gamma>' =\n                         restrictA (- set r) (?\\<Gamma>''29 list)\n 3. \\<And>list.\n       \\<lbrakk>d =\n                ((x_, e_) # restrictA (- set r) \\<Gamma>', e_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        isVal e_;\n        (if x_ \\<notin> set r then Upd x_ # restr_stack (- set r) list\n         else restr_stack (- set r) list) =\n        Upd x_ # restr_stack (- set r) list;\n        S' = Upd x_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = e_; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        x_ \\<notin> domA \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> restr_stack (- set r) list =\n                         restr_stack (- set r) (?S''30 list)", "apply (rule step.intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>d =\n                ((x_, e_) # restrictA (- set r) \\<Gamma>', e_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        isVal e_;\n        (if x_ \\<notin> set r then Upd x_ # restr_stack (- set r) list\n         else restr_stack (- set r) list) =\n        Upd x_ # restr_stack (- set r) list;\n        S' = Upd x_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = e_; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        x_ \\<notin> domA \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> x_ \\<notin> domA \\<Gamma>'\n 2. \\<And>list.\n       \\<lbrakk>d =\n                ((x_, e_) # restrictA (- set r) \\<Gamma>', e_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        isVal e_;\n        (if x_ \\<notin> set r then Upd x_ # restr_stack (- set r) list\n         else restr_stack (- set r) list) =\n        Upd x_ # restr_stack (- set r) list;\n        S' = Upd x_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = e_; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        x_ \\<notin> domA \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> isVal e_\n 3. \\<And>list.\n       \\<lbrakk>d =\n                ((x_, e_) # restrictA (- set r) \\<Gamma>', e_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        isVal e_;\n        (if x_ \\<notin> set r then Upd x_ # restr_stack (- set r) list\n         else restr_stack (- set r) list) =\n        Upd x_ # restr_stack (- set r) list;\n        S' = Upd x_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = e_; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        x_ \\<notin> domA \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> (x_, e_) # restrictA (- set r) \\<Gamma>' =\n                         restrictA (- set r) ((x_, e_) # \\<Gamma>')\n 4. \\<And>list.\n       \\<lbrakk>d =\n                ((x_, e_) # restrictA (- set r) \\<Gamma>', e_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        isVal e_;\n        (if x_ \\<notin> set r then Upd x_ # restr_stack (- set r) list\n         else restr_stack (- set r) list) =\n        Upd x_ # restr_stack (- set r) list;\n        S' = Upd x_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = e_; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        x_ \\<notin> domA \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> restr_stack (- set r) list =\n                         restr_stack (- set r) list", "apply (auto split: if_splits dest: Upd_eq_restr_stackD2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r (\\<Gamma>'', e'', S'')\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "case (let\\<^sub>1 \\<Delta>'' \\<Gamma>'' S'' e')"], ["proof (state)\nthis:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', Let \\<Delta>'' e', S'')\n  d = (\\<Delta>'' @ \\<Gamma>'', e', S'')\n  atom ` domA \\<Delta>'' \\<sharp>* \\<Gamma>''\n  atom ` domA \\<Delta>'' \\<sharp>* S''\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "from \\<open>closed (\\<Gamma>', e, S')\\<close> let\\<^sub>1"], ["proof (chain)\npicking this:\n  closed (\\<Gamma>', e, S')\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', Let \\<Delta>'' e', S'')\n  d = (\\<Delta>'' @ \\<Gamma>'', e', S'')\n  atom ` domA \\<Delta>'' \\<sharp>* \\<Gamma>''\n  atom ` domA \\<Delta>'' \\<sharp>* S''", "have \"closed (\\<Gamma>', Let \\<Delta>'' e', S')\""], ["proof (prove)\nusing this:\n  closed (\\<Gamma>', e, S')\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', Let \\<Delta>'' e', S'')\n  d = (\\<Delta>'' @ \\<Gamma>'', e', S'')\n  atom ` domA \\<Delta>'' \\<sharp>* \\<Gamma>''\n  atom ` domA \\<Delta>'' \\<sharp>* S''\n\ngoal (1 subgoal):\n 1. closed (\\<Gamma>', Let \\<Delta>'' e', S')", "by simp"], ["proof (state)\nthis:\n  closed (\\<Gamma>', Let \\<Delta>'' e', S')\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "from fresh_distinct[OF let\\<^sub>1(3)] fresh_distinct_fv[OF let\\<^sub>1(4)]"], ["proof (chain)\npicking this:\n  domA \\<Delta>'' \\<inter> domA \\<Gamma>'' = {}\n  domA \\<Delta>'' \\<inter> fv S'' = {}", "have \"domA \\<Delta>'' \\<inter> domA \\<Gamma>'' = {}\" and \"domA \\<Delta>'' \\<inter> upds S'' = {}\"  and \"domA \\<Delta>'' \\<inter> dummies S'' = {}\""], ["proof (prove)\nusing this:\n  domA \\<Delta>'' \\<inter> domA \\<Gamma>'' = {}\n  domA \\<Delta>'' \\<inter> fv S'' = {}\n\ngoal (1 subgoal):\n 1. domA \\<Delta>'' \\<inter> domA \\<Gamma>'' = {} &&&\n    domA \\<Delta>'' \\<inter> upds S'' = {} &&&\n    domA \\<Delta>'' \\<inter> dummies S'' = {}", "by (auto dest: subsetD[OF ups_fv_subset] subsetD[OF dummies_fv_subset])"], ["proof (state)\nthis:\n  domA \\<Delta>'' \\<inter> domA \\<Gamma>'' = {}\n  domA \\<Delta>'' \\<inter> upds S'' = {}\n  domA \\<Delta>'' \\<inter> dummies S'' = {}\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "moreover"], ["proof (state)\nthis:\n  domA \\<Delta>'' \\<inter> domA \\<Gamma>'' = {}\n  domA \\<Delta>'' \\<inter> upds S'' = {}\n  domA \\<Delta>'' \\<inter> dummies S'' = {}\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "from let\\<^sub>1(1)"], ["proof (chain)\npicking this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', Let \\<Delta>'' e', S'')", "have \"domA \\<Gamma>' \\<union> upds S' \\<subseteq> domA \\<Gamma>'' \\<union> upds S'' \\<union> dummies S''\""], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', Let \\<Delta>'' e', S'')\n\ngoal (1 subgoal):\n 1. domA \\<Gamma>' \\<union> upds S'\n    \\<subseteq> domA \\<Gamma>'' \\<union> upds S'' \\<union> dummies S''", "by auto"], ["proof (state)\nthis:\n  domA \\<Gamma>' \\<union> upds S'\n  \\<subseteq> domA \\<Gamma>'' \\<union> upds S'' \\<union> dummies S''\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "ultimately"], ["proof (chain)\npicking this:\n  domA \\<Delta>'' \\<inter> domA \\<Gamma>'' = {}\n  domA \\<Delta>'' \\<inter> upds S'' = {}\n  domA \\<Delta>'' \\<inter> dummies S'' = {}\n  domA \\<Gamma>' \\<union> upds S'\n  \\<subseteq> domA \\<Gamma>'' \\<union> upds S'' \\<union> dummies S''", "have disj: \"domA \\<Delta>'' \\<inter> domA \\<Gamma>' = {}\" \"domA \\<Delta>'' \\<inter> upds S' = {}\""], ["proof (prove)\nusing this:\n  domA \\<Delta>'' \\<inter> domA \\<Gamma>'' = {}\n  domA \\<Delta>'' \\<inter> upds S'' = {}\n  domA \\<Delta>'' \\<inter> dummies S'' = {}\n  domA \\<Gamma>' \\<union> upds S'\n  \\<subseteq> domA \\<Gamma>'' \\<union> upds S'' \\<union> dummies S''\n\ngoal (1 subgoal):\n 1. domA \\<Delta>'' \\<inter> domA \\<Gamma>' = {} &&&\n    domA \\<Delta>'' \\<inter> upds S' = {}", "by auto"], ["proof (state)\nthis:\n  domA \\<Delta>'' \\<inter> domA \\<Gamma>' = {}\n  domA \\<Delta>'' \\<inter> upds S' = {}\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "from \\<open>domA \\<Delta>'' \\<inter> dummies S'' = {}\\<close> let\\<^sub>1(1)"], ["proof (chain)\npicking this:\n  domA \\<Delta>'' \\<inter> dummies S'' = {}\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', Let \\<Delta>'' e', S'')", "have \"domA \\<Delta>'' \\<inter> set r = {}\""], ["proof (prove)\nusing this:\n  domA \\<Delta>'' \\<inter> dummies S'' = {}\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', Let \\<Delta>'' e', S'')\n\ngoal (1 subgoal):\n 1. domA \\<Delta>'' \\<inter> set r = {}", "by auto"], ["proof (state)\nthis:\n  domA \\<Delta>'' \\<inter> set r = {}\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "hence [simp]: \"restrictA (- set r) \\<Delta>'' = \\<Delta>''\""], ["proof (prove)\nusing this:\n  domA \\<Delta>'' \\<inter> set r = {}\n\ngoal (1 subgoal):\n 1. restrictA (- set r) \\<Delta>'' = \\<Delta>''", "by (auto intro: restrictA_noop)"], ["proof (state)\nthis:\n  restrictA (- set r) \\<Delta>'' = \\<Delta>''\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S ea.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Let \\<Delta> ea, S);\n        d = (\\<Delta> @ \\<Gamma>, ea, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "from let\\<^sub>1(1-3)"], ["proof (chain)\npicking this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', Let \\<Delta>'' e', S'')\n  d = (\\<Delta>'' @ \\<Gamma>'', e', S'')\n  atom ` domA \\<Delta>'' \\<sharp>* \\<Gamma>''", "show ?thesis"], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', Let \\<Delta>'' e', S'')\n  d = (\\<Delta>'' @ \\<Gamma>'', e', S'')\n  atom ` domA \\<Delta>'' \\<sharp>* \\<Gamma>''\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r (\\<Gamma>'', e'', S'')", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d =\n             (\\<Delta>'' @ restrictA (- set r) \\<Gamma>', e',\n              restr_stack (- set r) S' @ map Dummy (rev r));\n     atom ` domA \\<Delta>'' \\<sharp>* restrictA (- set r) \\<Gamma>';\n     \\<Gamma>'' = restrictA (- set r) \\<Gamma>'; e = Let \\<Delta>'' e';\n     S'' = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>'' S''.\n                         (\\<Gamma>', Let \\<Delta>'' e', S') \\<Rightarrow>\n                         (\\<Gamma>'', e', S'') \\<and>\n                         \\<Delta>'' @ restrictA (- set r) \\<Gamma>' =\n                         restrictA (- set r) \\<Gamma>'' \\<and>\n                         restr_stack (- set r) S' =\n                         restr_stack (- set r) S''", "apply (intro  exI[where x = \"r\"] exI[where x = \"\\<Delta>'' @ \\<Gamma>'\"] exI[where x = \"S'\"] conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>d =\n             (\\<Delta>'' @ restrictA (- set r) \\<Gamma>', e',\n              restr_stack (- set r) S' @ map Dummy (rev r));\n     atom ` domA \\<Delta>'' \\<sharp>* restrictA (- set r) \\<Gamma>';\n     \\<Gamma>'' = restrictA (- set r) \\<Gamma>'; e = Let \\<Delta>'' e';\n     S'' = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> (\\<Gamma>', Let \\<Delta>'' e', S') \\<Rightarrow>\n                      (\\<Delta>'' @ \\<Gamma>', e', S')\n 2. \\<lbrakk>d =\n             (\\<Delta>'' @ restrictA (- set r) \\<Gamma>', e',\n              restr_stack (- set r) S' @ map Dummy (rev r));\n     atom ` domA \\<Delta>'' \\<sharp>* restrictA (- set r) \\<Gamma>';\n     \\<Gamma>'' = restrictA (- set r) \\<Gamma>'; e = Let \\<Delta>'' e';\n     S'' = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> \\<Delta>'' @ restrictA (- set r) \\<Gamma>' =\n                      restrictA (- set r) (\\<Delta>'' @ \\<Gamma>')\n 3. \\<lbrakk>d =\n             (\\<Delta>'' @ restrictA (- set r) \\<Gamma>', e',\n              restr_stack (- set r) S' @ map Dummy (rev r));\n     atom ` domA \\<Delta>'' \\<sharp>* restrictA (- set r) \\<Gamma>';\n     \\<Gamma>'' = restrictA (- set r) \\<Gamma>'; e = Let \\<Delta>'' e';\n     S'' = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> restr_stack (- set r) S' = restr_stack (- set r) S'", "apply (rule let\\<^sub>1_closed[OF \\<open>closed (\\<Gamma>', Let \\<Delta>'' e', S')\\<close> disj])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d =\n             (\\<Delta>'' @ restrictA (- set r) \\<Gamma>', e',\n              restr_stack (- set r) S' @ map Dummy (rev r));\n     atom ` domA \\<Delta>'' \\<sharp>* restrictA (- set r) \\<Gamma>';\n     \\<Gamma>'' = restrictA (- set r) \\<Gamma>'; e = Let \\<Delta>'' e';\n     S'' = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> \\<Delta>'' @ restrictA (- set r) \\<Gamma>' =\n                      restrictA (- set r) (\\<Delta>'' @ \\<Gamma>')\n 2. \\<lbrakk>d =\n             (\\<Delta>'' @ restrictA (- set r) \\<Gamma>', e',\n              restr_stack (- set r) S' @ map Dummy (rev r));\n     atom ` domA \\<Delta>'' \\<sharp>* restrictA (- set r) \\<Gamma>';\n     \\<Gamma>'' = restrictA (- set r) \\<Gamma>'; e = Let \\<Delta>'' e';\n     S'' = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> restr_stack (- set r) S' = restr_stack (- set r) S'", "apply (auto simp add: restrictA_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r (\\<Gamma>'', e'', S'')\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "case if\\<^sub>1"], ["proof (state)\nthis:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>_, scrut_ ? e1_ : e2_, S_)\n  d = (\\<Gamma>_, scrut_, Alts e1_ e2_ # S_)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, scrut ? e1 : e2, S);\n        d = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "thus ?thesis"], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>_, scrut_ ? e1_ : e2_, S_)\n  d = (\\<Gamma>_, scrut_, Alts e1_ e2_ # S_)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r (\\<Gamma>'', e'', S'')", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', scrut_,\n              Alts e1_ e2_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = (scrut_ ? e1_ : e2_);\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>'' S''.\n                         (\\<Gamma>', scrut_ ? e1_ : e2_, S') \\<Rightarrow>\n                         (\\<Gamma>'', scrut_, S'') \\<and>\n                         restrictA (- set r) \\<Gamma>' =\n                         restrictA (- set r) \\<Gamma>'' \\<and>\n                         Alts e1_ e2_ # restr_stack (- set r) S' =\n                         restr_stack (- set r) S''", "apply (intro exI[where x = \"0::perm\"] exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', scrut_,\n              Alts e1_ e2_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = (scrut_ ? e1_ : e2_);\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> (\\<Gamma>', scrut_ ? e1_ : e2_, S') \\<Rightarrow>\n                      (?\\<Gamma>''11, scrut_, ?S''12)\n 2. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', scrut_,\n              Alts e1_ e2_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = (scrut_ ? e1_ : e2_);\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> restrictA (- set r) \\<Gamma>' =\n                      restrictA (- set r) ?\\<Gamma>''11\n 3. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', scrut_,\n              Alts e1_ e2_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = (scrut_ ? e1_ : e2_);\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> Alts e1_ e2_ # restr_stack (- set r) S' =\n                      restr_stack (- set r) ?S''12", "unfolding permute_zero"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', scrut_,\n              Alts e1_ e2_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = (scrut_ ? e1_ : e2_);\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> (\\<Gamma>', scrut_ ? e1_ : e2_, S') \\<Rightarrow>\n                      (?\\<Gamma>''11, scrut_, ?S''12)\n 2. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', scrut_,\n              Alts e1_ e2_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = (scrut_ ? e1_ : e2_);\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> restrictA (- set r) \\<Gamma>' =\n                      restrictA (- set r) ?\\<Gamma>''11\n 3. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', scrut_,\n              Alts e1_ e2_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = (scrut_ ? e1_ : e2_);\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> Alts e1_ e2_ # restr_stack (- set r) S' =\n                      restr_stack (- set r) ?S''12", "apply (rule step.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', scrut_,\n              Alts e1_ e2_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = (scrut_ ? e1_ : e2_);\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> restrictA (- set r) \\<Gamma>' =\n                      restrictA (- set r) \\<Gamma>'\n 2. \\<lbrakk>d =\n             (restrictA (- set r) \\<Gamma>', scrut_,\n              Alts e1_ e2_ # restr_stack (- set r) S' @ map Dummy (rev r));\n     \\<Gamma>_ = restrictA (- set r) \\<Gamma>'; e = (scrut_ ? e1_ : e2_);\n     S_ = restr_stack (- set r) S' @ map Dummy (rev r)\\<rbrakk>\n    \\<Longrightarrow> Alts e1_ e2_ # restr_stack (- set r) S' =\n                      restr_stack (- set r) (Alts e1_ e2_ # S')", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r (\\<Gamma>'', e'', S'')\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "case if\\<^sub>2"], ["proof (state)\nthis:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>_, Bool b_, Alts e1_ e2_ # S_)\n  d = (\\<Gamma>_, if b_ then e1_ else e2_, S_)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        d = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "thus ?thesis"], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>_, Bool b_, Alts e1_ e2_ # S_)\n  d = (\\<Gamma>_, if b_ then e1_ else e2_, S_)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r (\\<Gamma>'', e'', S'')", "using disj"], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>_, Bool b_, Alts e1_ e2_ # S_)\n  d = (\\<Gamma>_, if b_ then e1_ else e2_, S_)\n  \\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r (\\<Gamma>'', e'', S'')", "apply (cases S')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n             (\\<Gamma>_, Bool b_, Alts e1_ e2_ # S_);\n     d = (\\<Gamma>_, if b_ then e1_ else e2_, S_);\n     \\<not> isVal e \\<or> safe_hd S' = safe_hd (restr_stack (- set r) S');\n     S' = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                         (\\<Gamma>', e, S') \\<Rightarrow>\n                         (\\<Gamma>'', e'', S'') \\<and>\n                         d = to_gc_conf r (\\<Gamma>'', e'', S'')\n 2. \\<And>a list.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') =\n                (\\<Gamma>_, Bool b_, Alts e1_ e2_ # S_);\n        d = (\\<Gamma>_, if b_ then e1_ else e2_, S_);\n        \\<not> isVal e \\<or>\n        safe_hd S' = safe_hd (restr_stack (- set r) S');\n        S' = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r (\\<Gamma>'', e'', S'')", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e1_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool True; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        b_\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' S''.\n                            (\\<Gamma>', Bool True,\n                             Alts e1_ e2_ # list) \\<Rightarrow>\n                            (\\<Gamma>'', e1_, S'') \\<and>\n                            restrictA (- set r) \\<Gamma>' =\n                            restrictA (- set r) \\<Gamma>'' \\<and>\n                            restr_stack (- set r) list =\n                            restr_stack (- set r) S''\n 2. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e2_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool False; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        \\<not> b_\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' S''.\n                            (\\<Gamma>', Bool False,\n                             Alts e1_ e2_ # list) \\<Rightarrow>\n                            (\\<Gamma>'', e2_, S'') \\<and>\n                            restrictA (- set r) \\<Gamma>' =\n                            restrictA (- set r) \\<Gamma>'' \\<and>\n                            restr_stack (- set r) list =\n                            restr_stack (- set r) S''", "apply (intro exI exI conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e1_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool True; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        b_\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>', Bool True,\n                          Alts e1_ e2_ # list) \\<Rightarrow>\n                         (?\\<Gamma>''34 list, e1_, ?S''35 list)\n 2. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e1_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool True; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        b_\\<rbrakk>\n       \\<Longrightarrow> restrictA (- set r) \\<Gamma>' =\n                         restrictA (- set r) (?\\<Gamma>''34 list)\n 3. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e1_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool True; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        b_\\<rbrakk>\n       \\<Longrightarrow> restr_stack (- set r) list =\n                         restr_stack (- set r) (?S''35 list)\n 4. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e2_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool False; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        \\<not> b_\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' S''.\n                            (\\<Gamma>', Bool False,\n                             Alts e1_ e2_ # list) \\<Rightarrow>\n                            (\\<Gamma>'', e2_, S'') \\<and>\n                            restrictA (- set r) \\<Gamma>' =\n                            restrictA (- set r) \\<Gamma>'' \\<and>\n                            restr_stack (- set r) list =\n                            restr_stack (- set r) S''", "apply (rule step.if\\<^sub>2[where b = True, simplified] step.if\\<^sub>2[where b = False, simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e1_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool True; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        b_\\<rbrakk>\n       \\<Longrightarrow> restrictA (- set r) \\<Gamma>' =\n                         restrictA (- set r) \\<Gamma>'\n 2. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e1_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool True; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        b_\\<rbrakk>\n       \\<Longrightarrow> restr_stack (- set r) list =\n                         restr_stack (- set r) list\n 3. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e2_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool False; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        \\<not> b_\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' S''.\n                            (\\<Gamma>', Bool False,\n                             Alts e1_ e2_ # list) \\<Rightarrow>\n                            (\\<Gamma>'', e2_, S'') \\<and>\n                            restrictA (- set r) \\<Gamma>' =\n                            restrictA (- set r) \\<Gamma>'' \\<and>\n                            restr_stack (- set r) list =\n                            restr_stack (- set r) S''", "apply (auto split: if_splits dest: Upd_eq_restr_stackD2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e2_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool False; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        \\<not> b_\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Gamma>'' S''.\n                            (\\<Gamma>', Bool False,\n                             Alts e1_ e2_ # list) \\<Rightarrow>\n                            (\\<Gamma>'', e2_, S'') \\<and>\n                            restrictA (- set r) \\<Gamma>' =\n                            restrictA (- set r) \\<Gamma>'' \\<and>\n                            restr_stack (- set r) list =\n                            restr_stack (- set r) S''", "apply (intro exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e2_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool False; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        \\<not> b_\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>', Bool False,\n                          Alts e1_ e2_ # list) \\<Rightarrow>\n                         (?\\<Gamma>''39 list, e2_, ?S''40 list)\n 2. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e2_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool False; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        \\<not> b_\\<rbrakk>\n       \\<Longrightarrow> restrictA (- set r) \\<Gamma>' =\n                         restrictA (- set r) (?\\<Gamma>''39 list)\n 3. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e2_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool False; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        \\<not> b_\\<rbrakk>\n       \\<Longrightarrow> restr_stack (- set r) list =\n                         restr_stack (- set r) (?S''40 list)", "apply (rule step.if\\<^sub>2[where b = True, simplified] step.if\\<^sub>2[where b = False, simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e2_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool False; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        \\<not> b_\\<rbrakk>\n       \\<Longrightarrow> restrictA (- set r) \\<Gamma>' =\n                         restrictA (- set r) \\<Gamma>'\n 2. \\<And>list.\n       \\<lbrakk>d =\n                (restrictA (- set r) \\<Gamma>', e2_,\n                 restr_stack (- set r) list @ map Dummy (rev r));\n        S' = Alts e1_ e2_ # list; \\<Gamma>_ = restrictA (- set r) \\<Gamma>';\n        e = Bool False; S_ = restr_stack (- set r) list @ map Dummy (rev r);\n        \\<not> b_\\<rbrakk>\n       \\<Longrightarrow> restr_stack (- set r) list =\n                         restr_stack (- set r) list", "apply (auto split: if_splits dest: Upd_eq_restr_stackD2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r (\\<Gamma>'', e'', S'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r (\\<Gamma>'', e'', S'')\n\ngoal (2 subgoals):\n 1. to_gc_conf r (\\<Gamma>', e, S') \\<Rightarrow> d \\<Longrightarrow>\n    \\<exists>r' \\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n       (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n       r_ok r' (\\<Gamma>'', e'', S'')\n 2. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "with invariantE[OF subset_bound_invariant _ \\<open>r_ok r (\\<Gamma>', e, S')\\<close>]"], ["proof (chain)\npicking this:\n  (\\<Gamma>', e, S') \\<Rightarrow> ?y \\<Longrightarrow> r_ok r ?y\n  \\<exists>\\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r (\\<Gamma>'', e'', S'')", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Gamma>', e, S') \\<Rightarrow> ?y \\<Longrightarrow> r_ok r ?y\n  \\<exists>\\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow> (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r (\\<Gamma>'', e'', S'')\n\ngoal (1 subgoal):\n 1. \\<exists>r' \\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n       (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n       r_ok r' (\\<Gamma>'', e'', S'')", "by blast"], ["proof (state)\nthis:\n  \\<exists>r' \\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n     r_ok r' (\\<Gamma>'', e'', S'')\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "case (dropUpd \\<Gamma>'' e'' x S'')"], ["proof (state)\nthis:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')\n  d = (\\<Gamma>'', e'', S'' @ [Dummy x])\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "from \\<open>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')\\<close>"], ["proof (chain)\npicking this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')", "have \"x \\<notin> set r\""], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')\n\ngoal (1 subgoal):\n 1. x \\<notin> set r", "by (auto dest!: arg_cong[where f = upds])"], ["proof (state)\nthis:\n  x \\<notin> set r\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "from \\<open>heap_upds_ok (\\<Gamma>', S')\\<close> and \\<open>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')\\<close>"], ["proof (chain)\npicking this:\n  heap_upds_ok (\\<Gamma>', S')\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')", "have \"heap_upds_ok (\\<Gamma>'', Upd x # S'')\""], ["proof (prove)\nusing this:\n  heap_upds_ok (\\<Gamma>', S')\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')\n\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>'', Upd x # S'')", "by (rule heap_upd_ok_to_gc_conf)"], ["proof (state)\nthis:\n  heap_upds_ok (\\<Gamma>'', Upd x # S'')\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "hence [simp]: \"x \\<notin> domA \\<Gamma>''\" \"x \\<notin> upds S''\""], ["proof (prove)\nusing this:\n  heap_upds_ok (\\<Gamma>'', Upd x # S'')\n\ngoal (1 subgoal):\n 1. x \\<notin> domA \\<Gamma>'' &&& x \\<notin> upds S''", "by (auto dest: heap_upds_ok_upd)"], ["proof (state)\nthis:\n  x \\<notin> domA \\<Gamma>''\n  x \\<notin> upds S''\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "have \"to_gc_conf (x # r) (\\<Gamma>', e, S') = to_gc_conf ([x]@ r) (\\<Gamma>', e, S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_gc_conf (x # r) (\\<Gamma>', e, S') =\n    to_gc_conf ([x] @ r) (\\<Gamma>', e, S')", "by simp"], ["proof (state)\nthis:\n  to_gc_conf (x # r) (\\<Gamma>', e, S') =\n  to_gc_conf ([x] @ r) (\\<Gamma>', e, S')\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "also"], ["proof (state)\nthis:\n  to_gc_conf (x # r) (\\<Gamma>', e, S') =\n  to_gc_conf ([x] @ r) (\\<Gamma>', e, S')\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "have \"\\<dots> = to_gc_conf [x] (to_gc_conf r (\\<Gamma>', e, S'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_gc_conf ([x] @ r) (\\<Gamma>', e, S') =\n    to_gc_conf [x] (to_gc_conf r (\\<Gamma>', e, S'))", "by (rule to_gc_conf_append)"], ["proof (state)\nthis:\n  to_gc_conf ([x] @ r) (\\<Gamma>', e, S') =\n  to_gc_conf [x] (to_gc_conf r (\\<Gamma>', e, S'))\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "also"], ["proof (state)\nthis:\n  to_gc_conf ([x] @ r) (\\<Gamma>', e, S') =\n  to_gc_conf [x] (to_gc_conf r (\\<Gamma>', e, S'))\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "have \"\\<dots> = to_gc_conf [x] (\\<Gamma>'', e'', Upd x # S'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_gc_conf [x] (to_gc_conf r (\\<Gamma>', e, S')) =\n    to_gc_conf [x] (\\<Gamma>'', e'', Upd x # S'')", "unfolding \\<open>to_gc_conf r (\\<Gamma>', e, S') = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_gc_conf [x] (\\<Gamma>'', e'', Upd x # S'') =\n    to_gc_conf [x] (\\<Gamma>'', e'', Upd x # S'')", ".."], ["proof (state)\nthis:\n  to_gc_conf [x] (to_gc_conf r (\\<Gamma>', e, S')) =\n  to_gc_conf [x] (\\<Gamma>'', e'', Upd x # S'')\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "also"], ["proof (state)\nthis:\n  to_gc_conf [x] (to_gc_conf r (\\<Gamma>', e, S')) =\n  to_gc_conf [x] (\\<Gamma>'', e'', Upd x # S'')\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "have \"\\<dots> = (\\<Gamma>'', e'', S''@[Dummy x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_gc_conf [x] (\\<Gamma>'', e'', Upd x # S'') =\n    (\\<Gamma>'', e'', S'' @ [Dummy x])", "by (auto intro: restrictA_noop)"], ["proof (state)\nthis:\n  to_gc_conf [x] (\\<Gamma>'', e'', Upd x # S'') =\n  (\\<Gamma>'', e'', S'' @ [Dummy x])\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "also"], ["proof (state)\nthis:\n  to_gc_conf [x] (\\<Gamma>'', e'', Upd x # S'') =\n  (\\<Gamma>'', e'', S'' @ [Dummy x])\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "have \"\\<dots> = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>'', e'', S'' @ [Dummy x]) = d", "using \\<open> d= _\\<close>"], ["proof (prove)\nusing this:\n  d = (\\<Gamma>'', e'', S'' @ [Dummy x])\n\ngoal (1 subgoal):\n 1. (\\<Gamma>'', e'', S'' @ [Dummy x]) = d", "by simp"], ["proof (state)\nthis:\n  (\\<Gamma>'', e'', S'' @ [Dummy x]) = d\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "finally"], ["proof (chain)\npicking this:\n  to_gc_conf (x # r) (\\<Gamma>', e, S') = d", "have \"to_gc_conf (x # r) (\\<Gamma>', e, S') = d\""], ["proof (prove)\nusing this:\n  to_gc_conf (x # r) (\\<Gamma>', e, S') = d\n\ngoal (1 subgoal):\n 1. to_gc_conf (x # r) (\\<Gamma>', e, S') = d", "."], ["proof (state)\nthis:\n  to_gc_conf (x # r) (\\<Gamma>', e, S') = d\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "moreover"], ["proof (state)\nthis:\n  to_gc_conf (x # r) (\\<Gamma>', e, S') = d\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "from \\<open>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')\\<close>"], ["proof (chain)\npicking this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')", "have \"x \\<in> upds S'\""], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')\n\ngoal (1 subgoal):\n 1. x \\<in> upds S'", "by (auto dest!: arg_cong[where f = upds])"], ["proof (state)\nthis:\n  x \\<in> upds S'\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "with \\<open>r_ok r (\\<Gamma>', e, S')\\<close>"], ["proof (chain)\npicking this:\n  r_ok r (\\<Gamma>', e, S')\n  x \\<in> upds S'", "have \"r_ok (x # r) (\\<Gamma>', e, S')\""], ["proof (prove)\nusing this:\n  r_ok r (\\<Gamma>', e, S')\n  x \\<in> upds S'\n\ngoal (1 subgoal):\n 1. r_ok (x # r) (\\<Gamma>', e, S')", "by auto"], ["proof (state)\nthis:\n  r_ok (x # r) (\\<Gamma>', e, S')\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "moreover"], ["proof (state)\nthis:\n  r_ok (x # r) (\\<Gamma>', e, S')\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "note \\<open>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')\\<close>"], ["proof (state)\nthis:\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> ea x S.\n       \\<lbrakk>to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>, ea, Upd x # S);\n        d = (\\<Gamma>, ea, S @ [Dummy x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' \\<Gamma>'' e'' S''.\n                            (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                            (\\<Gamma>'', e'', S'') \\<and>\n                            d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n                            r_ok r' (\\<Gamma>'', e'', S'')", "ultimately"], ["proof (chain)\npicking this:\n  to_gc_conf (x # r) (\\<Gamma>', e, S') = d\n  r_ok (x # r) (\\<Gamma>', e, S')\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')", "show ?thesis"], ["proof (prove)\nusing this:\n  to_gc_conf (x # r) (\\<Gamma>', e, S') = d\n  r_ok (x # r) (\\<Gamma>', e, S')\n  to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', Upd x # S'')\n\ngoal (1 subgoal):\n 1. \\<exists>r' \\<Gamma>'' e'' S''.\n       (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n       (\\<Gamma>'', e'', S'') \\<and>\n       d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n       r_ok r' (\\<Gamma>'', e'', S'')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>r' \\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n     r_ok r' (\\<Gamma>'', e'', S'')\n\ngoal:\nNo subgoals!", "(*\n  next\n    case (drop x \\<Gamma>'' e'' S'')\n    from `to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', S'')` and `x \\<in> domA \\<Gamma>''`\n    have \"x \\<notin> set r\" by auto\n\n    from `heap_upds_ok (\\<Gamma>', S')` and  `to_gc_conf r (\\<Gamma>', e, S') = (\\<Gamma>'', e'', S'')`\n    have \"heap_upds_ok (\\<Gamma>'', S'')\" by (rule heap_upd_ok_to_gc_conf)\n    with `x \\<in> domA \\<Gamma>''`\n    have [simp]: \"x \\<notin> upds S''\" by (metis heap_upds_okE)\n\n\n    have \"to_gc_conf (x # r) (\\<Gamma>', e, S') = to_gc_conf ([x]@ r) (\\<Gamma>', e, S')\" by simp\n    also have \"\\<dots> = to_gc_conf [x] (to_gc_conf r (\\<Gamma>', e, S'))\" by (rule to_gc_conf_append)\n    also have \"\\<dots> = to_gc_conf [x] (\\<Gamma>'', e'', S'')\" unfolding `to_gc_conf r (\\<Gamma>', e, S') = _`..\n    also have \"\\<dots> = (delete x \\<Gamma>'', e'', S''@[Dummy x])\" by (auto  simp add: delete_restrictA_conv)\n    also have \"\\<dots> = d\" using ` d= _` by simp\n    finally have \"to_gc_conf (x # r) (\\<Gamma>', e, S') = d\".\n    moreover\n    from `to_gc_conf r (\\<Gamma>', e, S') = _` `x \\<in> domA \\<Gamma>''`\n    have \"x \\<in> domA \\<Gamma>'\" by auto\n    with `r_ok r (\\<Gamma>', e, S')`\n    have \"r_ok (x # r) (\\<Gamma>', e, S')\" by auto\n    moreover\n    note `to_gc_conf r (\\<Gamma>', e, S') = _`\n    ultimately\n    show ?thesis by fastforce\n*)"], ["proof (state)\nthis:\n  \\<exists>r' \\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n     r_ok r' (\\<Gamma>'', e'', S'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r' \\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n     r_ok r' (\\<Gamma>'', e'', S'')\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "then"], ["proof (chain)\npicking this:\n  \\<exists>r' \\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n     r_ok r' (\\<Gamma>'', e'', S'')", "obtain r' \\<Gamma>'' e'' S''\n    where \"(\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'')\"\n    and \"d = to_gc_conf r' (\\<Gamma>'', e'', S'')\"\n    and \"r_ok r' (\\<Gamma>'', e'', S'')\""], ["proof (prove)\nusing this:\n  \\<exists>r' \\<Gamma>'' e'' S''.\n     (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'') \\<and>\n     d = to_gc_conf r' (\\<Gamma>'', e'', S'') \\<and>\n     r_ok r' (\\<Gamma>'', e'', S'')\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>'' e'' S'' r'.\n        \\<lbrakk>(\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>'', e'', S'');\n         d = to_gc_conf r' (\\<Gamma>'', e'', S'');\n         r_ok r' (\\<Gamma>'', e'', S'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'')\n  d = to_gc_conf r' (\\<Gamma>'', e'', S'')\n  r_ok r' (\\<Gamma>'', e'', S'')\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "from  \\<open>(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\\<close> and \\<open>(\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'')\\<close>"], ["proof (chain)\npicking this:\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\n  (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'')", "have \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'')\""], ["proof (prove)\nusing this:\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e, S')\n  (\\<Gamma>', e, S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'')\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'')", "by (rule rtranclp_trans)"], ["proof (state)\nthis:\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'')\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "with \\<open>d = _\\<close> \\<open>r_ok r' _\\<close>"], ["proof (chain)\npicking this:\n  d = to_gc_conf r' (\\<Gamma>'', e'', S'')\n  r_ok r' (\\<Gamma>'', e'', S'')\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'')", "show ?thesis"], ["proof (prove)\nusing this:\n  d = to_gc_conf r' (\\<Gamma>'', e'', S'')\n  r_ok r' (\\<Gamma>'', e'', S'')\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'')\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "unfolding \\<open>c = _\\<close>"], ["proof (prove)\nusing this:\n  d = to_gc_conf r' (\\<Gamma>'', e'', S'')\n  r_ok r' (\\<Gamma>'', e'', S'')\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e'', S'')\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "by auto"], ["proof (state)\nthis:\n  \\<exists>r' c'.\n     c \\<Rightarrow>\\<^sup>* c' \\<and>\n     d = to_gc_conf r' c' \\<and> r_ok r' c'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sestoftUnGC:\n  assumes \"(to_gc_conf r c) \\<Rightarrow>\\<^sub>G\\<^sup>* d\" and \"heap_upds_ok_conf c\" and \"closed c\" and \"r_ok r c\"\n  shows   \"\\<exists> r' c'. c \\<Rightarrow>\\<^sup>* c' \\<and> d = to_gc_conf r' c' \\<and> r_ok r' c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "using assms"], ["proof (prove)\nusing this:\n  to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* d\n  heap_upds_ok_conf c\n  closed c\n  r_ok r c\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d = to_gc_conf r' c' \\<and> r_ok r' c'", "proof(induction rule: rtranclp_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r' c'.\n                         c \\<Rightarrow>\\<^sup>* c' \\<and>\n                         to_gc_conf r c = to_gc_conf r' c' \\<and> r_ok r' c'\n 2. \\<And>y z.\n       \\<lbrakk>to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* y;\n        y \\<Rightarrow>\\<^sub>G z;\n        \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>r' c'.\n                             c \\<Rightarrow>\\<^sup>* c' \\<and>\n                             y = to_gc_conf r' c' \\<and> r_ok r' c';\n        heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' c'.\n                            c \\<Rightarrow>\\<^sup>* c' \\<and>\n                            z = to_gc_conf r' c' \\<and> r_ok r' c'", "case base"], ["proof (state)\nthis:\n  heap_upds_ok_conf c\n  closed c\n  r_ok r c\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r' c'.\n                         c \\<Rightarrow>\\<^sup>* c' \\<and>\n                         to_gc_conf r c = to_gc_conf r' c' \\<and> r_ok r' c'\n 2. \\<And>y z.\n       \\<lbrakk>to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* y;\n        y \\<Rightarrow>\\<^sub>G z;\n        \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>r' c'.\n                             c \\<Rightarrow>\\<^sup>* c' \\<and>\n                             y = to_gc_conf r' c' \\<and> r_ok r' c';\n        heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' c'.\n                            c \\<Rightarrow>\\<^sup>* c' \\<and>\n                            z = to_gc_conf r' c' \\<and> r_ok r' c'", "thus ?case"], ["proof (prove)\nusing this:\n  heap_upds_ok_conf c\n  closed c\n  r_ok r c\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       to_gc_conf r c = to_gc_conf r' c' \\<and> r_ok r' c'", "by blast"], ["proof (state)\nthis:\n  \\<exists>r' c'.\n     c \\<Rightarrow>\\<^sup>* c' \\<and>\n     to_gc_conf r c = to_gc_conf r' c' \\<and> r_ok r' c'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* y;\n        y \\<Rightarrow>\\<^sub>G z;\n        \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>r' c'.\n                             c \\<Rightarrow>\\<^sup>* c' \\<and>\n                             y = to_gc_conf r' c' \\<and> r_ok r' c';\n        heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' c'.\n                            c \\<Rightarrow>\\<^sup>* c' \\<and>\n                            z = to_gc_conf r' c' \\<and> r_ok r' c'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* y;\n        y \\<Rightarrow>\\<^sub>G z;\n        \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>r' c'.\n                             c \\<Rightarrow>\\<^sup>* c' \\<and>\n                             y = to_gc_conf r' c' \\<and> r_ok r' c';\n        heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' c'.\n                            c \\<Rightarrow>\\<^sup>* c' \\<and>\n                            z = to_gc_conf r' c' \\<and> r_ok r' c'", "case (step d' d'')"], ["proof (state)\nthis:\n  to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* d'\n  d' \\<Rightarrow>\\<^sub>G d''\n  \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r' c'.\n                       c \\<Rightarrow>\\<^sup>* c' \\<and>\n                       d' = to_gc_conf r' c' \\<and> r_ok r' c'\n  heap_upds_ok_conf c\n  closed c\n  r_ok r c\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* y;\n        y \\<Rightarrow>\\<^sub>G z;\n        \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>r' c'.\n                             c \\<Rightarrow>\\<^sup>* c' \\<and>\n                             y = to_gc_conf r' c' \\<and> r_ok r' c';\n        heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' c'.\n                            c \\<Rightarrow>\\<^sup>* c' \\<and>\n                            z = to_gc_conf r' c' \\<and> r_ok r' c'", "then"], ["proof (chain)\npicking this:\n  to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* d'\n  d' \\<Rightarrow>\\<^sub>G d''\n  \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r' c'.\n                       c \\<Rightarrow>\\<^sup>* c' \\<and>\n                       d' = to_gc_conf r' c' \\<and> r_ok r' c'\n  heap_upds_ok_conf c\n  closed c\n  r_ok r c", "obtain r' c' where \"c \\<Rightarrow>\\<^sup>*  c'\" and \"d' = to_gc_conf r' c'\" and \"r_ok r' c'\""], ["proof (prove)\nusing this:\n  to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* d'\n  d' \\<Rightarrow>\\<^sub>G d''\n  \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r' c'.\n                       c \\<Rightarrow>\\<^sup>* c' \\<and>\n                       d' = to_gc_conf r' c' \\<and> r_ok r' c'\n  heap_upds_ok_conf c\n  closed c\n  r_ok r c\n\ngoal (1 subgoal):\n 1. (\\<And>c' r'.\n        \\<lbrakk>c \\<Rightarrow>\\<^sup>* c'; d' = to_gc_conf r' c';\n         r_ok r' c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<Rightarrow>\\<^sup>* c'\n  d' = to_gc_conf r' c'\n  r_ok r' c'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* y;\n        y \\<Rightarrow>\\<^sub>G z;\n        \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>r' c'.\n                             c \\<Rightarrow>\\<^sup>* c' \\<and>\n                             y = to_gc_conf r' c' \\<and> r_ok r' c';\n        heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' c'.\n                            c \\<Rightarrow>\\<^sup>* c' \\<and>\n                            z = to_gc_conf r' c' \\<and> r_ok r' c'", "from invariant_starE[OF \\<open>_ \\<Rightarrow>\\<^sup>* _\\<close> heap_upds_ok_invariant]  \\<open>heap_upds_ok _\\<close>"], ["proof (chain)\npicking this:\n  heap_upds_ok_conf c \\<Longrightarrow> heap_upds_ok_conf c'\n  heap_upds_ok_conf c", "have \"heap_upds_ok_conf c'\""], ["proof (prove)\nusing this:\n  heap_upds_ok_conf c \\<Longrightarrow> heap_upds_ok_conf c'\n  heap_upds_ok_conf c\n\ngoal (1 subgoal):\n 1. heap_upds_ok_conf c'", "."], ["proof (state)\nthis:\n  heap_upds_ok_conf c'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* y;\n        y \\<Rightarrow>\\<^sub>G z;\n        \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>r' c'.\n                             c \\<Rightarrow>\\<^sup>* c' \\<and>\n                             y = to_gc_conf r' c' \\<and> r_ok r' c';\n        heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' c'.\n                            c \\<Rightarrow>\\<^sup>* c' \\<and>\n                            z = to_gc_conf r' c' \\<and> r_ok r' c'", "from invariant_starE[OF \\<open>_ \\<Rightarrow>\\<^sup>* _\\<close> closed_invariant]  \\<open>closed _\\<close>"], ["proof (chain)\npicking this:\n  closed c \\<Longrightarrow> closed c'\n  closed c", "have \"closed c'\""], ["proof (prove)\nusing this:\n  closed c \\<Longrightarrow> closed c'\n  closed c\n\ngoal (1 subgoal):\n 1. closed c'", "."], ["proof (state)\nthis:\n  closed c'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* y;\n        y \\<Rightarrow>\\<^sub>G z;\n        \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>r' c'.\n                             c \\<Rightarrow>\\<^sup>* c' \\<and>\n                             y = to_gc_conf r' c' \\<and> r_ok r' c';\n        heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' c'.\n                            c \\<Rightarrow>\\<^sup>* c' \\<and>\n                            z = to_gc_conf r' c' \\<and> r_ok r' c'", "from step \\<open>d' = to_gc_conf r' c'\\<close>"], ["proof (chain)\npicking this:\n  to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* d'\n  d' \\<Rightarrow>\\<^sub>G d''\n  \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r' c'.\n                       c \\<Rightarrow>\\<^sup>* c' \\<and>\n                       d' = to_gc_conf r' c' \\<and> r_ok r' c'\n  heap_upds_ok_conf c\n  closed c\n  r_ok r c\n  d' = to_gc_conf r' c'", "have \"to_gc_conf r' c' \\<Rightarrow>\\<^sub>G d''\""], ["proof (prove)\nusing this:\n  to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* d'\n  d' \\<Rightarrow>\\<^sub>G d''\n  \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r' c'.\n                       c \\<Rightarrow>\\<^sup>* c' \\<and>\n                       d' = to_gc_conf r' c' \\<and> r_ok r' c'\n  heap_upds_ok_conf c\n  closed c\n  r_ok r c\n  d' = to_gc_conf r' c'\n\ngoal (1 subgoal):\n 1. to_gc_conf r' c' \\<Rightarrow>\\<^sub>G d''", "by simp"], ["proof (state)\nthis:\n  to_gc_conf r' c' \\<Rightarrow>\\<^sub>G d''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* y;\n        y \\<Rightarrow>\\<^sub>G z;\n        \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>r' c'.\n                             c \\<Rightarrow>\\<^sup>* c' \\<and>\n                             y = to_gc_conf r' c' \\<and> r_ok r' c';\n        heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' c'.\n                            c \\<Rightarrow>\\<^sup>* c' \\<and>\n                            z = to_gc_conf r' c' \\<and> r_ok r' c'", "from this \\<open>heap_upds_ok_conf c'\\<close> \\<open>closed c'\\<close> \\<open>r_ok r' c'\\<close>"], ["proof (chain)\npicking this:\n  to_gc_conf r' c' \\<Rightarrow>\\<^sub>G d''\n  heap_upds_ok_conf c'\n  closed c'\n  r_ok r' c'", "have \"\\<exists> r'' c''. c' \\<Rightarrow>\\<^sup>* c'' \\<and> d'' = to_gc_conf r'' c'' \\<and> r_ok r'' c''\""], ["proof (prove)\nusing this:\n  to_gc_conf r' c' \\<Rightarrow>\\<^sub>G d''\n  heap_upds_ok_conf c'\n  closed c'\n  r_ok r' c'\n\ngoal (1 subgoal):\n 1. \\<exists>r'' c''.\n       c' \\<Rightarrow>\\<^sup>* c'' \\<and>\n       d'' = to_gc_conf r'' c'' \\<and> r_ok r'' c''", "by (rule sestoftUnGCstep)"], ["proof (state)\nthis:\n  \\<exists>r'' c''.\n     c' \\<Rightarrow>\\<^sup>* c'' \\<and>\n     d'' = to_gc_conf r'' c'' \\<and> r_ok r'' c''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* y;\n        y \\<Rightarrow>\\<^sub>G z;\n        \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>r' c'.\n                             c \\<Rightarrow>\\<^sup>* c' \\<and>\n                             y = to_gc_conf r' c' \\<and> r_ok r' c';\n        heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' c'.\n                            c \\<Rightarrow>\\<^sup>* c' \\<and>\n                            z = to_gc_conf r' c' \\<and> r_ok r' c'", "then"], ["proof (chain)\npicking this:\n  \\<exists>r'' c''.\n     c' \\<Rightarrow>\\<^sup>* c'' \\<and>\n     d'' = to_gc_conf r'' c'' \\<and> r_ok r'' c''", "obtain r'' c'' where \"c' \\<Rightarrow>\\<^sup>* c''\" and \"d'' = to_gc_conf r'' c''\" and \"r_ok r'' c''\""], ["proof (prove)\nusing this:\n  \\<exists>r'' c''.\n     c' \\<Rightarrow>\\<^sup>* c'' \\<and>\n     d'' = to_gc_conf r'' c'' \\<and> r_ok r'' c''\n\ngoal (1 subgoal):\n 1. (\\<And>c'' r''.\n        \\<lbrakk>c' \\<Rightarrow>\\<^sup>* c''; d'' = to_gc_conf r'' c'';\n         r_ok r'' c''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c' \\<Rightarrow>\\<^sup>* c''\n  d'' = to_gc_conf r'' c''\n  r_ok r'' c''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* y;\n        y \\<Rightarrow>\\<^sub>G z;\n        \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>r' c'.\n                             c \\<Rightarrow>\\<^sup>* c' \\<and>\n                             y = to_gc_conf r' c' \\<and> r_ok r' c';\n        heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' c'.\n                            c \\<Rightarrow>\\<^sup>* c' \\<and>\n                            z = to_gc_conf r' c' \\<and> r_ok r' c'", "from \\<open>c' \\<Rightarrow>\\<^sup>*  c''\\<close> \\<open>c \\<Rightarrow>\\<^sup>*  c'\\<close>"], ["proof (chain)\npicking this:\n  c' \\<Rightarrow>\\<^sup>* c''\n  c \\<Rightarrow>\\<^sup>* c'", "have \"c \\<Rightarrow>\\<^sup>* c''\""], ["proof (prove)\nusing this:\n  c' \\<Rightarrow>\\<^sup>* c''\n  c \\<Rightarrow>\\<^sup>* c'\n\ngoal (1 subgoal):\n 1. c \\<Rightarrow>\\<^sup>* c''", "by auto"], ["proof (state)\nthis:\n  c \\<Rightarrow>\\<^sup>* c''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>to_gc_conf r c \\<Rightarrow>\\<^sub>G\\<^sup>* y;\n        y \\<Rightarrow>\\<^sub>G z;\n        \\<lbrakk>heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>r' c'.\n                             c \\<Rightarrow>\\<^sup>* c' \\<and>\n                             y = to_gc_conf r' c' \\<and> r_ok r' c';\n        heap_upds_ok_conf c; closed c; r_ok r c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r' c'.\n                            c \\<Rightarrow>\\<^sup>* c' \\<and>\n                            z = to_gc_conf r' c' \\<and> r_ok r' c'", "with \\<open>d'' = _\\<close> \\<open>r_ok r'' c''\\<close>"], ["proof (chain)\npicking this:\n  d'' = to_gc_conf r'' c''\n  r_ok r'' c''\n  c \\<Rightarrow>\\<^sup>* c''", "show ?case"], ["proof (prove)\nusing this:\n  d'' = to_gc_conf r'' c''\n  r_ok r'' c''\n  c \\<Rightarrow>\\<^sup>* c''\n\ngoal (1 subgoal):\n 1. \\<exists>r' c'.\n       c \\<Rightarrow>\\<^sup>* c' \\<and>\n       d'' = to_gc_conf r' c' \\<and> r_ok r' c'", "by blast"], ["proof (state)\nthis:\n  \\<exists>r' c'.\n     c \\<Rightarrow>\\<^sup>* c' \\<and>\n     d'' = to_gc_conf r' c' \\<and> r_ok r' c'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dummies_unchanged_invariant:\n  \"invariant step (\\<lambda> (\\<Gamma>, e, S) . dummies S = V)\" (is \"invariant _ ?I\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant (\\<Rightarrow>) (\\<lambda>(\\<Gamma>, e, S). dummies S = V)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<Rightarrow> y;\n        case x of (\\<Gamma>, e, S) \\<Rightarrow> dummies S = V\\<rbrakk>\n       \\<Longrightarrow> case y of\n                         (\\<Gamma>, e, S) \\<Rightarrow> dummies S = V", "fix c c'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<Rightarrow> y;\n        case x of (\\<Gamma>, e, S) \\<Rightarrow> dummies S = V\\<rbrakk>\n       \\<Longrightarrow> case y of\n                         (\\<Gamma>, e, S) \\<Rightarrow> dummies S = V", "assume \"c \\<Rightarrow> c'\" and \"?I c\""], ["proof (state)\nthis:\n  c \\<Rightarrow> c'\n  case c of (\\<Gamma>, e, S) \\<Rightarrow> dummies S = V\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<Rightarrow> y;\n        case x of (\\<Gamma>, e, S) \\<Rightarrow> dummies S = V\\<rbrakk>\n       \\<Longrightarrow> case y of\n                         (\\<Gamma>, e, S) \\<Rightarrow> dummies S = V", "thus \"?I c'\""], ["proof (prove)\nusing this:\n  c \\<Rightarrow> c'\n  case c of (\\<Gamma>, e, S) \\<Rightarrow> dummies S = V\n\ngoal (1 subgoal):\n 1. case c' of (\\<Gamma>, e, S) \\<Rightarrow> dummies S = V", "by (induction) auto"], ["proof (state)\nthis:\n  case c' of (\\<Gamma>, e, S) \\<Rightarrow> dummies S = V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sestoftUnGC':\n  assumes \"([], e, []) \\<Rightarrow>\\<^sub>G\\<^sup>* (\\<Gamma>, e', map Dummy r)\"\n  assumes \"isVal e'\"\n  assumes \"fv e = ({}::var set)\"\n  shows   \"\\<exists> \\<Gamma>''. ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and> \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and> set r \\<subseteq> domA \\<Gamma>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "from sestoftUnGC[where r = \"[]\" and c = \"([], e, [])\", simplified, OF assms(1,3)]"], ["proof (chain)\npicking this:\n  \\<exists>r' a aa b.\n     ([], e, []) \\<Rightarrow>\\<^sup>* (a, aa, b) \\<and>\n     (\\<Gamma>, e', map Dummy r) =\n     (restrictA (- set r') a, aa,\n      restr_stack (- set r') b @ map Dummy (rev r')) \\<and>\n     set r' \\<subseteq> domA a \\<union> upds b", "obtain r' \\<Gamma>' S'\n  where \"([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e', S')\"\n    and \"\\<Gamma> = restrictA (- set r') \\<Gamma>'\"\n    and \"map Dummy r = restr_stack (- set r') S' @ map Dummy (rev r')\"\n    and \"r_ok r' (\\<Gamma>', e', S')\""], ["proof (prove)\nusing this:\n  \\<exists>r' a aa b.\n     ([], e, []) \\<Rightarrow>\\<^sup>* (a, aa, b) \\<and>\n     (\\<Gamma>, e', map Dummy r) =\n     (restrictA (- set r') a, aa,\n      restr_stack (- set r') b @ map Dummy (rev r')) \\<and>\n     set r' \\<subseteq> domA a \\<union> upds b\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' S' r'.\n        \\<lbrakk>([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e', S');\n         \\<Gamma> = restrictA (- set r') \\<Gamma>';\n         map Dummy r = restr_stack (- set r') S' @ map Dummy (rev r');\n         r_ok r' (\\<Gamma>', e', S')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e', S')\n  \\<Gamma> = restrictA (- set r') \\<Gamma>'\n  map Dummy r = restr_stack (- set r') S' @ map Dummy (rev r')\n  r_ok r' (\\<Gamma>', e', S')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "from invariant_starE[OF \\<open>([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e', S')\\<close> dummies_unchanged_invariant]"], ["proof (chain)\npicking this:\n  case ([], e, []) of\n  (\\<Gamma>, e, S) \\<Rightarrow> dummies S = ?V1 \\<Longrightarrow>\n  case (\\<Gamma>', e', S') of (\\<Gamma>, e, S) \\<Rightarrow> dummies S = ?V1", "have \"dummies S' = {}\""], ["proof (prove)\nusing this:\n  case ([], e, []) of\n  (\\<Gamma>, e, S) \\<Rightarrow> dummies S = ?V1 \\<Longrightarrow>\n  case (\\<Gamma>', e', S') of (\\<Gamma>, e, S) \\<Rightarrow> dummies S = ?V1\n\ngoal (1 subgoal):\n 1. dummies S' = {}", "by auto"], ["proof (state)\nthis:\n  dummies S' = {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "with  \\<open>map Dummy r = restr_stack (- set r') S' @ map Dummy (rev r')\\<close>"], ["proof (chain)\npicking this:\n  map Dummy r = restr_stack (- set r') S' @ map Dummy (rev r')\n  dummies S' = {}", "have \"restr_stack (- set r') S' = []\" and [simp]: \"r = rev r'\""], ["proof (prove)\nusing this:\n  map Dummy r = restr_stack (- set r') S' @ map Dummy (rev r')\n  dummies S' = {}\n\ngoal (1 subgoal):\n 1. restr_stack (- set r') S' = [] &&& r = rev r'", "by (induction S' rule: restr_stack.induct) (auto split: if_splits)"], ["proof (state)\nthis:\n  restr_stack (- set r') S' = []\n  r = rev r'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "from invariant_starE[OF \\<open>_ \\<Rightarrow>\\<^sup>* _\\<close> heap_upds_ok_invariant]"], ["proof (chain)\npicking this:\n  heap_upds_ok_conf ([], e, []) \\<Longrightarrow>\n  heap_upds_ok_conf (\\<Gamma>', e', S')", "have \"heap_upds_ok (\\<Gamma>', S')\""], ["proof (prove)\nusing this:\n  heap_upds_ok_conf ([], e, []) \\<Longrightarrow>\n  heap_upds_ok_conf (\\<Gamma>', e', S')\n\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>', S')", "by auto"], ["proof (state)\nthis:\n  heap_upds_ok (\\<Gamma>', S')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "from \\<open>isVal e'\\<close> sestoftUnGCStack[where e = e', OF \\<open>heap_upds_ok (\\<Gamma>', S')\\<close> ]"], ["proof (chain)\npicking this:\n  isVal e'\n  (\\<And>\\<Gamma>'' S'a.\n      \\<lbrakk>(\\<Gamma>', e', S') \\<Rightarrow>\\<^sup>*\n               (\\<Gamma>'', e', S'a);\n       to_gc_conf ?r (\\<Gamma>', e', S') =\n       to_gc_conf ?r (\\<Gamma>'', e', S'a);\n       \\<not> isVal e' \\<or>\n       safe_hd S'a = safe_hd (restr_stack (- set ?r) S'a)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain \\<Gamma>'' S''\n    where \"(\\<Gamma>', e', S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', S'')\"\n    and \"to_gc_conf r (\\<Gamma>', e', S') = to_gc_conf r (\\<Gamma>'', e', S'')\"\n    and \"safe_hd S'' = safe_hd (restr_stack (- set r) S'')\""], ["proof (prove)\nusing this:\n  isVal e'\n  (\\<And>\\<Gamma>'' S'a.\n      \\<lbrakk>(\\<Gamma>', e', S') \\<Rightarrow>\\<^sup>*\n               (\\<Gamma>'', e', S'a);\n       to_gc_conf ?r (\\<Gamma>', e', S') =\n       to_gc_conf ?r (\\<Gamma>'', e', S'a);\n       \\<not> isVal e' \\<or>\n       safe_hd S'a = safe_hd (restr_stack (- set ?r) S'a)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>'' S''.\n        \\<lbrakk>(\\<Gamma>', e', S') \\<Rightarrow>\\<^sup>*\n                 (\\<Gamma>'', e', S'');\n         to_gc_conf r (\\<Gamma>', e', S') =\n         to_gc_conf r (\\<Gamma>'', e', S'');\n         safe_hd S'' = safe_hd (restr_stack (- set r) S'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (\\<Gamma>', e', S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', S'')\n  to_gc_conf r (\\<Gamma>', e', S') = to_gc_conf r (\\<Gamma>'', e', S'')\n  safe_hd S'' = safe_hd (restr_stack (- set r) S'')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "from this (2,3) \\<open>restr_stack (- set r') S' = []\\<close>"], ["proof (chain)\npicking this:\n  to_gc_conf r (\\<Gamma>', e', S') = to_gc_conf r (\\<Gamma>'', e', S'')\n  safe_hd S'' = safe_hd (restr_stack (- set r) S'')\n  restr_stack (- set r') S' = []", "have \"S'' = []\""], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e', S') = to_gc_conf r (\\<Gamma>'', e', S'')\n  safe_hd S'' = safe_hd (restr_stack (- set r) S'')\n  restr_stack (- set r') S' = []\n\ngoal (1 subgoal):\n 1. S'' = []", "by auto"], ["proof (state)\nthis:\n  S'' = []\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "from  \\<open>([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e', S')\\<close>  and \\<open>(\\<Gamma>', e', S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', S'')\\<close> and \\<open>S'' = []\\<close>"], ["proof (chain)\npicking this:\n  ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e', S')\n  (\\<Gamma>', e', S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', S'')\n  S'' = []", "have \"([], e, []) \\<Rightarrow>\\<^sup>*  (\\<Gamma>'', e', [])\""], ["proof (prove)\nusing this:\n  ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>', e', S')\n  (\\<Gamma>', e', S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', S'')\n  S'' = []\n\ngoal (1 subgoal):\n 1. ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', [])", "by auto"], ["proof (state)\nthis:\n  ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', [])\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "moreover"], ["proof (state)\nthis:\n  ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', [])\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "have \"\\<Gamma> = restrictA (- set r) \\<Gamma>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> = restrictA (- set r) \\<Gamma>''", "using \\<open>to_gc_conf r _ = _\\<close> \\<open>\\<Gamma> = _\\<close>"], ["proof (prove)\nusing this:\n  to_gc_conf r (\\<Gamma>', e', S') = to_gc_conf r (\\<Gamma>'', e', S'')\n  \\<Gamma> = restrictA (- set r') \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<Gamma> = restrictA (- set r) \\<Gamma>''", "by auto"], ["proof (state)\nthis:\n  \\<Gamma> = restrictA (- set r) \\<Gamma>''\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "moreover"], ["proof (state)\nthis:\n  \\<Gamma> = restrictA (- set r) \\<Gamma>''\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "from invariant_starE[OF \\<open>(\\<Gamma>', e', S') \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', S'')\\<close> subset_bound_invariant \\<open>r_ok r' (\\<Gamma>', e', S')\\<close>]"], ["proof (chain)\npicking this:\n  r_ok r' (\\<Gamma>'', e', S'')", "have \"set r \\<subseteq> domA \\<Gamma>''\""], ["proof (prove)\nusing this:\n  r_ok r' (\\<Gamma>'', e', S'')\n\ngoal (1 subgoal):\n 1. set r \\<subseteq> domA \\<Gamma>''", "using \\<open>S'' = []\\<close>"], ["proof (prove)\nusing this:\n  r_ok r' (\\<Gamma>'', e', S'')\n  S'' = []\n\ngoal (1 subgoal):\n 1. set r \\<subseteq> domA \\<Gamma>''", "by auto"], ["proof (state)\nthis:\n  set r \\<subseteq> domA \\<Gamma>''\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "ultimately"], ["proof (chain)\npicking this:\n  ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', [])\n  \\<Gamma> = restrictA (- set r) \\<Gamma>''\n  set r \\<subseteq> domA \\<Gamma>''", "show ?thesis"], ["proof (prove)\nusing this:\n  ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', [])\n  \\<Gamma> = restrictA (- set r) \\<Gamma>''\n  set r \\<subseteq> domA \\<Gamma>''\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>''.\n       ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n       \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n       set r \\<subseteq> domA \\<Gamma>''", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>''.\n     ([], e, []) \\<Rightarrow>\\<^sup>* (\\<Gamma>'', e', []) \\<and>\n     \\<Gamma> = restrictA (- set r) \\<Gamma>'' \\<and>\n     set r \\<subseteq> domA \\<Gamma>''\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}