{"file_name": "/home/qj213/afp-2021-10-22/thys/Call_Arity/CoCallGraph-TTree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Call_Arity", "problem_names": ["lemma interleave_ccFromList:\n  \"xs \\<in> interleave ys zs \\<Longrightarrow> ccFromList xs = ccFromList ys \\<squnion> ccFromList zs \\<squnion> ccProd (set ys) (set zs)\"", "lemma ccApprox_paths: \"ccApprox t = lub (ccFromList ` (paths t))\"", "lemma ccApprox_strict[simp]: \"ccApprox \\<bottom> = \\<bottom>\"", "lemma in_ccApprox: \"(x--y\\<in>(ccApprox t)) \\<longleftrightarrow> (\\<exists> xs \\<in> paths t. (x--y\\<in>(ccFromList xs)))\"", "lemma ccApprox_mono: \"paths t \\<subseteq> paths t' \\<Longrightarrow> ccApprox t \\<sqsubseteq> ccApprox t'\"", "lemma ccApprox_mono': \"t \\<sqsubseteq>  t' \\<Longrightarrow> ccApprox t \\<sqsubseteq> ccApprox t'\"", "lemma ccApprox_belowI: \"(\\<And> xs. xs \\<in> paths t \\<Longrightarrow> ccFromList xs \\<sqsubseteq> G) \\<Longrightarrow> ccApprox t \\<sqsubseteq> G\"", "lemma ccApprox_below_iff: \"ccApprox t \\<sqsubseteq> G \\<longleftrightarrow> (\\<forall> xs \\<in> paths t. ccFromList xs \\<sqsubseteq> G)\"", "lemma cc_restr_ccApprox_below_iff: \"cc_restr S (ccApprox t) \\<sqsubseteq> G \\<longleftrightarrow> (\\<forall> xs \\<in> paths t. cc_restr S (ccFromList xs) \\<sqsubseteq> G)\"", "lemma ccFromList_below_ccApprox:\n  \"xs \\<in> paths t \\<Longrightarrow> ccFromList xs \\<sqsubseteq> ccApprox t\"", "lemma ccApprox_nxt_below:\n  \"ccApprox (nxt t x) \\<sqsubseteq> ccApprox t\"", "lemma ccApprox_ttree_restr_nxt_below:\n  \"ccApprox (ttree_restr S (nxt t x)) \\<sqsubseteq> ccApprox (ttree_restr S t)\"", "lemma ccApprox_ttree_restr[simp]: \"ccApprox (ttree_restr S t) = cc_restr S (ccApprox t)\"", "lemma ccApprox_both: \"ccApprox (t \\<otimes>\\<otimes> t') = ccApprox t \\<squnion> ccApprox t' \\<squnion> ccProd (carrier t) (carrier t')\"", "lemma ccApprox_many_calls[simp]:\n  \"ccApprox (many_calls x) = ccProd {x} {x}\"", "lemma ccApprox_single[simp]:\n  \"ccApprox (TTree.single y) = \\<bottom>\"", "lemma ccApprox_either[simp]: \"ccApprox (t \\<oplus>\\<oplus> t') = ccApprox t \\<squnion> ccApprox t'\"", "lemma wild_recursion:\n  assumes \"ccApprox  t \\<sqsubseteq> G\"\n  assumes \"\\<And> x. x \\<notin> S \\<Longrightarrow> f x = empty\"\n  assumes \"\\<And> x. x \\<in> S \\<Longrightarrow> ccApprox (f x) \\<sqsubseteq> G\"\n  assumes \"\\<And> x. x \\<in> S \\<Longrightarrow> ccProd (ccNeighbors x G) (carrier (f x)) \\<sqsubseteq> G\"\n  shows \"ccApprox (ttree_restr (-S) (substitute f T t)) \\<sqsubseteq> G\"", "lemma wild_recursion_thunked:\n  assumes \"ccApprox  t \\<sqsubseteq> G\"\n  assumes \"\\<And> x. x \\<notin> S \\<Longrightarrow> f x = empty\"\n  assumes \"\\<And> x. x \\<in> S \\<Longrightarrow> ccApprox (f x) \\<sqsubseteq> G\"\n  assumes \"\\<And> x. x \\<in> S \\<Longrightarrow> ccProd (ccNeighbors x G - {x} \\<inter> T) (carrier (f x)) \\<sqsubseteq> G\"\n  shows \"ccApprox (ttree_restr (-S) (substitute f T t)) \\<sqsubseteq> G\"", "lemma  valid_lists_downset_aux:\n  \"xs \\<in> valid_lists S CoCalls \\<Longrightarrow> butlast xs \\<in> valid_lists S CoCalls\"", "lemma valid_lists_subset: \"xs \\<in> valid_lists S G \\<Longrightarrow> set xs \\<subseteq> S\"", "lemma valid_lists_mono1:\n  assumes \"S \\<subseteq> S'\"\n  shows \"valid_lists S G \\<subseteq> valid_lists S' G\"", "lemma valid_lists_chain1:\n   assumes \"chain Y\" \n   assumes \"xs \\<in> valid_lists (\\<Union>(Y ` UNIV)) G\"\n   shows \"\\<exists> i. xs \\<in> valid_lists (Y i) G\"", "lemma valid_lists_chain2:\n   assumes \"chain Y\" \n   assumes \"xs \\<in> valid_lists S (\\<Squnion>i. Y i)\"\n   shows \"\\<exists> i. xs \\<in> valid_lists S  (Y i)\"", "lemma valid_lists_cc_restr: \"valid_lists S G = valid_lists S (cc_restr S G)\"", "lemma interleave_valid_list:\n  \"xs \\<in> ys \\<otimes> zs \\<Longrightarrow> ys \\<in> valid_lists S G \\<Longrightarrow> zs \\<in> valid_lists S' G' \\<Longrightarrow> xs \\<in> valid_lists (S \\<union> S') (G \\<squnion> (G' \\<squnion> ccProd S S'))\"", "lemma interleave_valid_list':\n  \"xs \\<in> valid_lists (S \\<union> S') G \\<Longrightarrow> \\<exists> ys zs. xs \\<in> ys \\<otimes> zs \\<and> ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\"", "lemma many_calls_valid_list:\n  \"xs \\<in> valid_lists {x} (ccProd {x} {x}) \\<Longrightarrow> xs \\<in> range (\\<lambda>n. replicate n x)\"", "lemma filter_valid_lists:\n  \"xs \\<in> valid_lists S G \\<Longrightarrow> filter P xs \\<in> valid_lists {a \\<in> S. P a} G\"", "lemma paths_ccTTree[simp]: \"paths (ccTTree S G) = valid_lists S G\"", "lemma carrier_ccTTree[simp]: \"carrier (ccTTree S G) = S\"", "lemma valid_lists_ccFromList:\n  \"xs \\<in> valid_lists S G \\<Longrightarrow> ccFromList xs \\<sqsubseteq> cc_restr S G\"", "lemma ccApprox_ccTTree[simp]: \"ccApprox (ccTTree S G) = cc_restr S G\"", "lemma below_ccTTreeI:\n  assumes \"carrier t \\<subseteq> S\" and \"ccApprox t \\<sqsubseteq> G\"\n  shows \"t \\<sqsubseteq> ccTTree S G\"", "lemma ccTTree_mono1:\n  \"S \\<subseteq> S' \\<Longrightarrow> ccTTree S G \\<sqsubseteq> ccTTree S' G\"", "lemma cont_ccTTree1:\n  \"cont (\\<lambda> S. ccTTree S G)\"", "lemma ccTTree_mono2:\n  \"G \\<sqsubseteq> G' \\<Longrightarrow> ccTTree S G \\<sqsubseteq> ccTTree S G'\"", "lemma ccTTree_mono:\n  \"S \\<subseteq> S' \\<Longrightarrow> G \\<sqsubseteq> G' \\<Longrightarrow> ccTTree S G \\<sqsubseteq> ccTTree S' G'\"", "lemma cont_ccTTree2:\n  \"cont (ccTTree S)\"", "lemmas cont_ccTTree = cont_compose2[where c = ccTTree, OF cont_ccTTree1 cont_ccTTree2, simp, cont2cont]", "lemma ccTTree_below_singleI:\n  assumes \"S \\<inter> S' = {}\"\n  shows \"ccTTree S G \\<sqsubseteq> singles S'\"", "lemma ccTTree_cc_restr: \"ccTTree S G = ccTTree S (cc_restr S G)\"", "lemma ccTTree_cong_below: \"cc_restr S G \\<sqsubseteq> cc_restr S G' \\<Longrightarrow> ccTTree S G \\<sqsubseteq> ccTTree S G'\"", "lemma ccTTree_cong: \"cc_restr S G = cc_restr S G' \\<Longrightarrow> ccTTree S G = ccTTree S G'\"", "lemma either_ccTTree:\n  \"ccTTree S G \\<oplus>\\<oplus> ccTTree S' G' \\<sqsubseteq> ccTTree (S \\<union> S') (G \\<squnion> G')\"", "lemma interleave_ccTTree: \n   \"ccTTree S G \\<otimes>\\<otimes> ccTTree S' G' \\<sqsubseteq> ccTTree (S \\<union> S') (G \\<squnion> G' \\<squnion> ccProd S S')\"", "lemma interleave_ccTTree': \n   \"ccTTree (S \\<union> S') G \\<sqsubseteq> ccTTree S G \\<otimes>\\<otimes> ccTTree S' G\"", "lemma many_calls_ccTTree:\n  shows \"many_calls x = ccTTree {x} (ccProd {x} {x})\"", "lemma filter_valid_lists':\n  \"xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow> xs \\<in> filter P ` valid_lists S G\"", "lemma without_ccTTree[simp]:\n   \"without x (ccTTree S G) = ccTTree (S - {x}) G\"", "lemma ttree_restr_ccTTree[simp]:\n   \"ttree_restr S' (ccTTree S G) = ccTTree (S \\<inter> S') G\"", "lemma repeatable_ccTTree_ccSquare: \"S \\<subseteq> S' \\<Longrightarrow> repeatable (ccTTree S (ccSquare S'))\"", "lemma valid_lists_valid_lists':\n  \"xs \\<in> valid_lists S G \\<Longrightarrow> ccProd prefix (set xs) \\<sqsubseteq> G \\<Longrightarrow> valid_lists' S G prefix xs\"", "lemma valid_lists'_valid_lists_aux:\n  \"valid_lists' S G prefix xs \\<Longrightarrow>  x \\<in> prefix \\<Longrightarrow> ccProd (set xs) {x} \\<sqsubseteq> G\"", "lemma valid_lists'_valid_lists:\n  \"valid_lists' S G prefix xs \\<Longrightarrow> xs \\<in> valid_lists S G\"", "lemma valid_lists_characterization:\n  \"xs \\<in> valid_lists S G \\<longleftrightarrow> set xs \\<subseteq> S \\<and> (\\<forall>n. ccProd (set (take n xs)) (set (drop n xs)) \\<sqsubseteq> G)\""], "translations": [["", "lemma interleave_ccFromList:\n  \"xs \\<in> interleave ys zs \\<Longrightarrow> ccFromList xs = ccFromList ys \\<squnion> ccFromList zs \\<squnion> ccProd (set ys) (set zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> ys \\<otimes> zs \\<Longrightarrow>\n    ccFromList xs =\n    ccFromList ys \\<squnion> ccFromList zs \\<squnion>\n    set ys G\\<times> set zs", "by (induction rule: interleave_induct)\n     (auto simp add: interleave_set ccProd_comm ccProd_insert2[where S' = \"set xs\" for xs]  ccProd_insert1[where S' = \"set xs\" for xs] )"], ["", "lift_definition ccApprox :: \"var ttree \\<Rightarrow> CoCalls\"\n  is \"\\<lambda> xss .  lub (ccFromList ` xss)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma ccApprox_paths: \"ccApprox t = lub (ccFromList ` (paths t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox t = lub (ccFromList ` paths t)", "by transfer simp"], ["", "lemma ccApprox_strict[simp]: \"ccApprox \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox \\<bottom> = \\<bottom>", "by (simp add: ccApprox_paths empty_is_bottom[symmetric])"], ["", "lemma in_ccApprox: \"(x--y\\<in>(ccApprox t)) \\<longleftrightarrow> (\\<exists> xs \\<in> paths t. (x--y\\<in>(ccFromList xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x--y\\<in>ccApprox t = (\\<exists>xs\\<in>paths t. x--y\\<in>ccFromList xs)", "unfolding ccApprox_paths"], ["proof (prove)\ngoal (1 subgoal):\n 1. x--y\\<in>lub (ccFromList ` paths t) =\n    (\\<exists>xs\\<in>paths t. x--y\\<in>ccFromList xs)", "by transfer auto"], ["", "lemma ccApprox_mono: \"paths t \\<subseteq> paths t' \\<Longrightarrow> ccApprox t \\<sqsubseteq> ccApprox t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. paths t \\<subseteq> paths t' \\<Longrightarrow>\n    ccApprox t \\<sqsubseteq> ccApprox t'", "by (rule below_CoCallsI) (auto simp add: in_ccApprox)"], ["", "lemma ccApprox_mono': \"t \\<sqsubseteq>  t' \\<Longrightarrow> ccApprox t \\<sqsubseteq> ccApprox t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> t' \\<Longrightarrow>\n    ccApprox t \\<sqsubseteq> ccApprox t'", "by (metis below_set_def ccApprox_mono paths_mono_iff)"], ["", "lemma ccApprox_belowI: \"(\\<And> xs. xs \\<in> paths t \\<Longrightarrow> ccFromList xs \\<sqsubseteq> G) \\<Longrightarrow> ccApprox t \\<sqsubseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        xs \\<in> paths t \\<Longrightarrow>\n        ccFromList xs \\<sqsubseteq> G) \\<Longrightarrow>\n    ccApprox t \\<sqsubseteq> G", "unfolding ccApprox_paths"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        xs \\<in> paths t \\<Longrightarrow>\n        ccFromList xs \\<sqsubseteq> G) \\<Longrightarrow>\n    lub (ccFromList ` paths t) \\<sqsubseteq> G", "by transfer auto"], ["", "lemma ccApprox_below_iff: \"ccApprox t \\<sqsubseteq> G \\<longleftrightarrow> (\\<forall> xs \\<in> paths t. ccFromList xs \\<sqsubseteq> G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ccApprox t \\<sqsubseteq> G) =\n    (\\<forall>xs\\<in>paths t. ccFromList xs \\<sqsubseteq> G)", "unfolding ccApprox_paths"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lub (ccFromList ` paths t) \\<sqsubseteq> G) =\n    (\\<forall>xs\\<in>paths t. ccFromList xs \\<sqsubseteq> G)", "by transfer auto"], ["", "lemma cc_restr_ccApprox_below_iff: \"cc_restr S (ccApprox t) \\<sqsubseteq> G \\<longleftrightarrow> (\\<forall> xs \\<in> paths t. cc_restr S (ccFromList xs) \\<sqsubseteq> G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ccApprox t G|` S \\<sqsubseteq> G) =\n    (\\<forall>xs\\<in>paths t. ccFromList xs G|` S \\<sqsubseteq> G)", "unfolding ccApprox_paths cc_restr_lub"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lub (cc_restr S ` ccFromList ` paths t) \\<sqsubseteq> G) =\n    (\\<forall>xs\\<in>paths t. ccFromList xs G|` S \\<sqsubseteq> G)", "by transfer auto"], ["", "lemma ccFromList_below_ccApprox:\n  \"xs \\<in> paths t \\<Longrightarrow> ccFromList xs \\<sqsubseteq> ccApprox t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> paths t \\<Longrightarrow>\n    ccFromList xs \\<sqsubseteq> ccApprox t", "by (rule below_CoCallsI)(auto simp add: in_ccApprox)"], ["", "lemma ccApprox_nxt_below:\n  \"ccApprox (nxt t x) \\<sqsubseteq> ccApprox t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox (nxt t x) \\<sqsubseteq> ccApprox t", "by (rule below_CoCallsI)(auto simp add: in_ccApprox paths_nxt_eq elim!:  bexI[rotated])"], ["", "lemma ccApprox_ttree_restr_nxt_below:\n  \"ccApprox (ttree_restr S (nxt t x)) \\<sqsubseteq> ccApprox (ttree_restr S t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox (ttree_restr S (nxt t x)) \\<sqsubseteq>\n    ccApprox (ttree_restr S t)", "by (rule below_CoCallsI)\n   (auto simp add: in_ccApprox filter_paths_conv_free_restr[symmetric] paths_nxt_eq  elim!:  bexI[rotated])"], ["", "lemma ccApprox_ttree_restr[simp]: \"ccApprox (ttree_restr S t) = cc_restr S (ccApprox t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox (ttree_restr S t) = ccApprox t G|` S", "by (rule CoCalls_eqI) (auto simp add: in_ccApprox filter_paths_conv_free_restr[symmetric] )"], ["", "lemma ccApprox_both: \"ccApprox (t \\<otimes>\\<otimes> t') = ccApprox t \\<squnion> ccApprox t' \\<squnion> ccProd (carrier t) (carrier t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox (t \\<otimes>\\<otimes> t') =\n    ccApprox t \\<squnion> ccApprox t' \\<squnion>\n    carrier t G\\<times> carrier t'", "proof (rule below_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. ccApprox (t \\<otimes>\\<otimes> t') \\<sqsubseteq>\n    ccApprox t \\<squnion> ccApprox t' \\<squnion>\n    carrier t G\\<times> carrier t'\n 2. ccApprox t \\<squnion> ccApprox t' \\<squnion>\n    carrier t G\\<times> carrier t' \\<sqsubseteq>\n    ccApprox (t \\<otimes>\\<otimes> t')", "show \"ccApprox (t \\<otimes>\\<otimes> t') \\<sqsubseteq> ccApprox t \\<squnion> ccApprox t' \\<squnion> ccProd (carrier t) (carrier t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox (t \\<otimes>\\<otimes> t') \\<sqsubseteq>\n    ccApprox t \\<squnion> ccApprox t' \\<squnion>\n    carrier t G\\<times> carrier t'", "by (rule below_CoCallsI)\n     (auto 4 4  simp add: in_ccApprox paths_both Union_paths_carrier[symmetric]  interleave_ccFromList)"], ["proof (state)\nthis:\n  ccApprox (t \\<otimes>\\<otimes> t') \\<sqsubseteq>\n  ccApprox t \\<squnion> ccApprox t' \\<squnion>\n  carrier t G\\<times> carrier t'\n\ngoal (1 subgoal):\n 1. ccApprox t \\<squnion> ccApprox t' \\<squnion>\n    carrier t G\\<times> carrier t' \\<sqsubseteq>\n    ccApprox (t \\<otimes>\\<otimes> t')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ccApprox t \\<squnion> ccApprox t' \\<squnion>\n    carrier t G\\<times> carrier t' \\<sqsubseteq>\n    ccApprox (t \\<otimes>\\<otimes> t')", "have \"ccApprox t \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox t \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')", "by (rule ccApprox_mono[OF both_contains_arg1])"], ["proof (state)\nthis:\n  ccApprox t \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')\n\ngoal (1 subgoal):\n 1. ccApprox t \\<squnion> ccApprox t' \\<squnion>\n    carrier t G\\<times> carrier t' \\<sqsubseteq>\n    ccApprox (t \\<otimes>\\<otimes> t')", "moreover"], ["proof (state)\nthis:\n  ccApprox t \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')\n\ngoal (1 subgoal):\n 1. ccApprox t \\<squnion> ccApprox t' \\<squnion>\n    carrier t G\\<times> carrier t' \\<sqsubseteq>\n    ccApprox (t \\<otimes>\\<otimes> t')", "have \"ccApprox t' \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox t' \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')", "by (rule ccApprox_mono[OF both_contains_arg2])"], ["proof (state)\nthis:\n  ccApprox t' \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')\n\ngoal (1 subgoal):\n 1. ccApprox t \\<squnion> ccApprox t' \\<squnion>\n    carrier t G\\<times> carrier t' \\<sqsubseteq>\n    ccApprox (t \\<otimes>\\<otimes> t')", "moreover"], ["proof (state)\nthis:\n  ccApprox t' \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')\n\ngoal (1 subgoal):\n 1. ccApprox t \\<squnion> ccApprox t' \\<squnion>\n    carrier t G\\<times> carrier t' \\<sqsubseteq>\n    ccApprox (t \\<otimes>\\<otimes> t')", "have \"ccProd (carrier t) (carrier t') \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier t G\\<times> carrier t' \\<sqsubseteq>\n    ccApprox (t \\<otimes>\\<otimes> t')", "proof(rule ccProd_belowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier t; y \\<in> carrier t'\\<rbrakk>\n       \\<Longrightarrow> x--y\\<in>ccApprox (t \\<otimes>\\<otimes> t')", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier t; y \\<in> carrier t'\\<rbrakk>\n       \\<Longrightarrow> x--y\\<in>ccApprox (t \\<otimes>\\<otimes> t')", "assume \"x \\<in> carrier t\" and \"y \\<in> carrier t'\""], ["proof (state)\nthis:\n  x \\<in> carrier t\n  y \\<in> carrier t'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier t; y \\<in> carrier t'\\<rbrakk>\n       \\<Longrightarrow> x--y\\<in>ccApprox (t \\<otimes>\\<otimes> t')", "then"], ["proof (chain)\npicking this:\n  x \\<in> carrier t\n  y \\<in> carrier t'", "obtain xs ys where \"x \\<in> set xs\" and \"y \\<in> set ys\"\n      and \"xs \\<in> paths t\" and \"ys \\<in> paths t'\""], ["proof (prove)\nusing this:\n  x \\<in> carrier t\n  y \\<in> carrier t'\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>x \\<in> set xs; y \\<in> set ys; xs \\<in> paths t;\n         ys \\<in> paths t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: Union_paths_carrier[symmetric])"], ["proof (state)\nthis:\n  x \\<in> set xs\n  y \\<in> set ys\n  xs \\<in> paths t\n  ys \\<in> paths t'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier t; y \\<in> carrier t'\\<rbrakk>\n       \\<Longrightarrow> x--y\\<in>ccApprox (t \\<otimes>\\<otimes> t')", "hence \"xs @ ys \\<in> paths (t \\<otimes>\\<otimes> t')\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  y \\<in> set ys\n  xs \\<in> paths t\n  ys \\<in> paths t'\n\ngoal (1 subgoal):\n 1. xs @ ys \\<in> paths (t \\<otimes>\\<otimes> t')", "by (metis paths_both append_interleave)"], ["proof (state)\nthis:\n  xs @ ys \\<in> paths (t \\<otimes>\\<otimes> t')\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier t; y \\<in> carrier t'\\<rbrakk>\n       \\<Longrightarrow> x--y\\<in>ccApprox (t \\<otimes>\\<otimes> t')", "moreover"], ["proof (state)\nthis:\n  xs @ ys \\<in> paths (t \\<otimes>\\<otimes> t')\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier t; y \\<in> carrier t'\\<rbrakk>\n       \\<Longrightarrow> x--y\\<in>ccApprox (t \\<otimes>\\<otimes> t')", "from \\<open>x \\<in> set xs\\<close> \\<open>y \\<in> set ys\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set xs\n  y \\<in> set ys", "have \"x--y\\<in>(ccFromList (xs@ys))\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. x--y\\<in>ccFromList (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  x--y\\<in>ccFromList (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier t; y \\<in> carrier t'\\<rbrakk>\n       \\<Longrightarrow> x--y\\<in>ccApprox (t \\<otimes>\\<otimes> t')", "ultimately"], ["proof (chain)\npicking this:\n  xs @ ys \\<in> paths (t \\<otimes>\\<otimes> t')\n  x--y\\<in>ccFromList (xs @ ys)", "show \"x--y\\<in>(ccApprox (t \\<otimes>\\<otimes> t'))\""], ["proof (prove)\nusing this:\n  xs @ ys \\<in> paths (t \\<otimes>\\<otimes> t')\n  x--y\\<in>ccFromList (xs @ ys)\n\ngoal (1 subgoal):\n 1. x--y\\<in>ccApprox (t \\<otimes>\\<otimes> t')", "by (auto simp add: in_ccApprox simp del: ccFromList_append)"], ["proof (state)\nthis:\n  x--y\\<in>ccApprox (t \\<otimes>\\<otimes> t')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  carrier t G\\<times> carrier t' \\<sqsubseteq>\n  ccApprox (t \\<otimes>\\<otimes> t')\n\ngoal (1 subgoal):\n 1. ccApprox t \\<squnion> ccApprox t' \\<squnion>\n    carrier t G\\<times> carrier t' \\<sqsubseteq>\n    ccApprox (t \\<otimes>\\<otimes> t')", "ultimately"], ["proof (chain)\npicking this:\n  ccApprox t \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')\n  ccApprox t' \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')\n  carrier t G\\<times> carrier t' \\<sqsubseteq>\n  ccApprox (t \\<otimes>\\<otimes> t')", "show \"ccApprox t \\<squnion> ccApprox t' \\<squnion> ccProd (carrier t) (carrier t') \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')\""], ["proof (prove)\nusing this:\n  ccApprox t \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')\n  ccApprox t' \\<sqsubseteq> ccApprox (t \\<otimes>\\<otimes> t')\n  carrier t G\\<times> carrier t' \\<sqsubseteq>\n  ccApprox (t \\<otimes>\\<otimes> t')\n\ngoal (1 subgoal):\n 1. ccApprox t \\<squnion> ccApprox t' \\<squnion>\n    carrier t G\\<times> carrier t' \\<sqsubseteq>\n    ccApprox (t \\<otimes>\\<otimes> t')", "by (simp add: join_below_iff)"], ["proof (state)\nthis:\n  ccApprox t \\<squnion> ccApprox t' \\<squnion>\n  carrier t G\\<times> carrier t' \\<sqsubseteq>\n  ccApprox (t \\<otimes>\\<otimes> t')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccApprox_many_calls[simp]:\n  \"ccApprox (many_calls x) = ccProd {x} {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox (many_calls x) = {x} G\\<times> {x}", "by transfer' (rule CoCalls_eqI, auto)"], ["", "lemma ccApprox_single[simp]:\n  \"ccApprox (TTree.single y) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox (single y) = \\<bottom>", "by transfer' auto"], ["", "lemma ccApprox_either[simp]: \"ccApprox (t \\<oplus>\\<oplus> t') = ccApprox t \\<squnion> ccApprox t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox (t \\<oplus>\\<oplus> t') = ccApprox t \\<squnion> ccApprox t'", "by transfer' (rule CoCalls_eqI, auto)"], ["", "(* could work, but tricky\nlemma ccApprox_lub_nxt: \"ccApprox t = (\\<Squnion> x \\<in>UNIV. ccApprox (nxt t x) \\<squnion> (ccProd {x} (carrier (nxt t x))))\"\n*)"], ["", "lemma wild_recursion:\n  assumes \"ccApprox  t \\<sqsubseteq> G\"\n  assumes \"\\<And> x. x \\<notin> S \\<Longrightarrow> f x = empty\"\n  assumes \"\\<And> x. x \\<in> S \\<Longrightarrow> ccApprox (f x) \\<sqsubseteq> G\"\n  assumes \"\\<And> x. x \\<in> S \\<Longrightarrow> ccProd (ccNeighbors x G) (carrier (f x)) \\<sqsubseteq> G\"\n  shows \"ccApprox (ttree_restr (-S) (substitute f T t)) \\<sqsubseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox (ttree_restr (- S) (substitute f T t)) \\<sqsubseteq> G", "proof(rule ccApprox_belowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "define seen :: \"var set\" where \"seen = {}\""], ["proof (state)\nthis:\n  seen = {}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "assume \"xs \\<in> paths (ttree_restr (- S) (substitute f T t))\""], ["proof (state)\nthis:\n  xs \\<in> paths (ttree_restr (- S) (substitute f T t))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "then"], ["proof (chain)\npicking this:\n  xs \\<in> paths (ttree_restr (- S) (substitute f T t))", "obtain xs' xs'' where \"xs = [x\\<leftarrow>xs' . x \\<notin> S]\" and \"substitute'' f T xs'' xs'\" and \"xs'' \\<in> paths t\""], ["proof (prove)\nusing this:\n  xs \\<in> paths (ttree_restr (- S) (substitute f T t))\n\ngoal (1 subgoal):\n 1. (\\<And>xs' xs''.\n        \\<lbrakk>xs = filter (\\<lambda>x. x \\<notin> S) xs';\n         substitute'' f T xs'' xs'; xs'' \\<in> paths t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: filter_paths_conv_free_restr2[symmetric] substitute_substitute'')"], ["proof (state)\nthis:\n  xs = filter (\\<lambda>x. x \\<notin> S) xs'\n  substitute'' f T xs'' xs'\n  xs'' \\<in> paths t\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "note this(2)"], ["proof (state)\nthis:\n  substitute'' f T xs'' xs'\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  substitute'' f T xs'' xs'\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "from \\<open>ccApprox t \\<sqsubseteq> G\\<close> and \\<open>xs'' \\<in> paths t\\<close>"], ["proof (chain)\npicking this:\n  ccApprox t \\<sqsubseteq> G\n  xs'' \\<in> paths t", "have  \"ccFromList xs'' \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  ccApprox t \\<sqsubseteq> G\n  xs'' \\<in> paths t\n\ngoal (1 subgoal):\n 1. ccFromList xs'' \\<sqsubseteq> G", "by (auto simp add: ccApprox_below_iff)"], ["proof (state)\nthis:\n  ccFromList xs'' \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  ccFromList xs'' \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "note assms(2)"], ["proof (state)\nthis:\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "from assms(3,4)"], ["proof (chain)\npicking this:\n  ?x \\<in> S \\<Longrightarrow> ccApprox (f ?x) \\<sqsubseteq> G\n  ?x \\<in> S \\<Longrightarrow>\n  ccNeighbors ?x G G\\<times> carrier (f ?x) \\<sqsubseteq> G", "have \"\\<And> x ys. x \\<in> S \\<Longrightarrow> ys \\<in> paths (f x) \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G\"\n    and \"\\<And> x ys. x \\<in> S \\<Longrightarrow> ys \\<in> paths (f x) \\<Longrightarrow> ccProd (ccNeighbors x G) (set ys) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> ccApprox (f ?x) \\<sqsubseteq> G\n  ?x \\<in> S \\<Longrightarrow>\n  ccNeighbors ?x G G\\<times> carrier (f ?x) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. (\\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G) &&&\n    (\\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq> G)", "by (auto simp add: ccApprox_below_iff Union_paths_carrier[symmetric] cc_lub_below_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccNeighbors ?x G G\\<times> set ?ys \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccNeighbors ?x G G\\<times> set ?ys \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "have \"ccProd seen (set xs'') \\<sqsubseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seen G\\<times> set xs'' \\<sqsubseteq> G", "unfolding seen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} G\\<times> set xs'' \\<sqsubseteq> G", "by simp"], ["proof (state)\nthis:\n  seen G\\<times> set xs'' \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "ultimately"], ["proof (chain)\npicking this:\n  substitute'' f T xs'' xs'\n  ccFromList xs'' \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccNeighbors ?x G G\\<times> set ?ys \\<sqsubseteq> G\n  seen G\\<times> set xs'' \\<sqsubseteq> G", "have \"ccFromList [x\\<leftarrow>xs' . x \\<notin> S] \\<sqsubseteq> G \\<and> ccProd (seen) (set xs') \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  substitute'' f T xs'' xs'\n  ccFromList xs'' \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccNeighbors ?x G G\\<times> set ?ys \\<sqsubseteq> G\n  seen G\\<times> set xs'' \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) xs') \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set xs' \\<sqsubseteq> G", "proof(induction f T xs'' xs' arbitrary: seen rule: substitute''.induct[case_names Nil Cons])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f T seen.\n       \\<lbrakk>ccFromList [] \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set [] \\<sqsubseteq> G\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            []) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times> set [] \\<sqsubseteq> G\n 2. \\<And>zs f x xs' xs T ys seen.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen.\n           \\<lbrakk>ccFromList xs' \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccNeighbors xa G G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> set xs' \\<sqsubseteq> G\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> set ys \\<sqsubseteq> G;\n        ccFromList (x # xs) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set (x # xs) \\<sqsubseteq> G\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times> set (x # ys) \\<sqsubseteq> G", "case Nil"], ["proof (state)\nthis:\n  ccFromList [] \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f_ ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f_ ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f_ ?x)\\<rbrakk>\n  \\<Longrightarrow> ccNeighbors ?x G G\\<times> set ?ys \\<sqsubseteq> G\n  seen G\\<times> set [] \\<sqsubseteq> G\n\ngoal (2 subgoals):\n 1. \\<And>f T seen.\n       \\<lbrakk>ccFromList [] \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set [] \\<sqsubseteq> G\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            []) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times> set [] \\<sqsubseteq> G\n 2. \\<And>zs f x xs' xs T ys seen.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen.\n           \\<lbrakk>ccFromList xs' \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccNeighbors xa G G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> set xs' \\<sqsubseteq> G\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> set ys \\<sqsubseteq> G;\n        ccFromList (x # xs) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set (x # xs) \\<sqsubseteq> G\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times> set (x # ys) \\<sqsubseteq> G", "thus ?case"], ["proof (prove)\nusing this:\n  ccFromList [] \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f_ ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f_ ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f_ ?x)\\<rbrakk>\n  \\<Longrightarrow> ccNeighbors ?x G G\\<times> set ?ys \\<sqsubseteq> G\n  seen G\\<times> set [] \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) []) \\<sqsubseteq> G \\<and>\n    seen G\\<times> set [] \\<sqsubseteq> G", "by simp"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) []) \\<sqsubseteq> G \\<and>\n  seen G\\<times> set [] \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen.\n           \\<lbrakk>ccFromList xs' \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccNeighbors xa G G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> set xs' \\<sqsubseteq> G\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> set ys \\<sqsubseteq> G;\n        ccFromList (x # xs) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set (x # xs) \\<sqsubseteq> G\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times> set (x # ys) \\<sqsubseteq> G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen.\n           \\<lbrakk>ccFromList xs' \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccNeighbors xa G G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> set xs' \\<sqsubseteq> G\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> set ys \\<sqsubseteq> G;\n        ccFromList (x # xs) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set (x # xs) \\<sqsubseteq> G\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times> set (x # ys) \\<sqsubseteq> G", "case (Cons zs f x xs' xs T ys)"], ["proof (state)\nthis:\n  zs \\<in> paths (f x)\n  xs' \\<in> xs \\<otimes> zs\n  substitute'' (f_nxt f T x) T xs' ys\n  \\<lbrakk>ccFromList xs' \\<sqsubseteq> G;\n   \\<And>xa. xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n   \\<And>xa ys.\n      \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n      \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n   \\<And>xa ys.\n      \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n      \\<Longrightarrow> ccNeighbors xa G G\\<times> set ys \\<sqsubseteq> G;\n   ?seen G\\<times> set xs' \\<sqsubseteq> G\\<rbrakk>\n  \\<Longrightarrow> ccFromList\n                     (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq>\n                    G \\<and>\n                    ?seen G\\<times> set ys \\<sqsubseteq> G\n  ccFromList (x # xs) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccNeighbors ?x G G\\<times> set ?ys \\<sqsubseteq> G\n  seen G\\<times> set (x # xs) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen.\n           \\<lbrakk>ccFromList xs' \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccNeighbors xa G G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> set xs' \\<sqsubseteq> G\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> set ys \\<sqsubseteq> G;\n        ccFromList (x # xs) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set (x # xs) \\<sqsubseteq> G\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times> set (x # ys) \\<sqsubseteq> G", "have seen_x: \"ccProd seen {x} \\<sqsubseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seen G\\<times> {x} \\<sqsubseteq> G", "using \\<open>ccProd seen (set (x # xs)) \\<sqsubseteq> G\\<close>"], ["proof (prove)\nusing this:\n  seen G\\<times> set (x # xs) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. seen G\\<times> {x} \\<sqsubseteq> G", "by (auto simp add: ccProd_insert2[where S' = \"set xs\" for xs] join_below_iff)"], ["proof (state)\nthis:\n  seen G\\<times> {x} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen.\n           \\<lbrakk>ccFromList xs' \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccNeighbors xa G G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> set xs' \\<sqsubseteq> G\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> set ys \\<sqsubseteq> G;\n        ccFromList (x # xs) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set (x # xs) \\<sqsubseteq> G\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times> set (x # ys) \\<sqsubseteq> G", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "proof(cases \"x \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "case True"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "from \\<open>ccFromList (x # xs) \\<sqsubseteq> G\\<close>"], ["proof (chain)\npicking this:\n  ccFromList (x # xs) \\<sqsubseteq> G", "have \"ccProd {x} (set xs) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  ccFromList (x # xs) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. {x} G\\<times> set xs \\<sqsubseteq> G", "by (auto simp add: join_below_iff)"], ["proof (state)\nthis:\n  {x} G\\<times> set xs \\<sqsubseteq> G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "hence subset1: \"set xs \\<subseteq> ccNeighbors x G\""], ["proof (prove)\nusing this:\n  {x} G\\<times> set xs \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> ccNeighbors x G", "by transfer auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> ccNeighbors x G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "from \\<open>ccProd seen (set (x # xs)) \\<sqsubseteq> G\\<close>"], ["proof (chain)\npicking this:\n  seen G\\<times> set (x # xs) \\<sqsubseteq> G", "have subset2: \"seen  \\<subseteq> ccNeighbors x G\""], ["proof (prove)\nusing this:\n  seen G\\<times> set (x # xs) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. seen \\<subseteq> ccNeighbors x G", "by (auto simp add: subset_ccNeighbors ccProd_insert2[where S' = \"set xs\" for xs] join_below_iff ccProd_comm)"], ["proof (state)\nthis:\n  seen \\<subseteq> ccNeighbors x G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "from subset1 and subset2"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> ccNeighbors x G\n  seen \\<subseteq> ccNeighbors x G", "have \"seen \\<union> set xs \\<subseteq> ccNeighbors x G\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> ccNeighbors x G\n  seen \\<subseteq> ccNeighbors x G\n\ngoal (1 subgoal):\n 1. seen \\<union> set xs \\<subseteq> ccNeighbors x G", "by auto"], ["proof (state)\nthis:\n  seen \\<union> set xs \\<subseteq> ccNeighbors x G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "hence \"ccProd (seen \\<union> set xs) (set zs) \\<sqsubseteq> ccProd (ccNeighbors x G) (set zs)\""], ["proof (prove)\nusing this:\n  seen \\<union> set xs \\<subseteq> ccNeighbors x G\n\ngoal (1 subgoal):\n 1. (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq>\n    ccNeighbors x G G\\<times> set zs", "by (rule ccProd_mono1)"], ["proof (state)\nthis:\n  (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq>\n  ccNeighbors x G G\\<times> set zs\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "also"], ["proof (state)\nthis:\n  (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq>\n  ccNeighbors x G G\\<times> set zs\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "from \\<open>x \\<in> S\\<close>  \\<open>zs \\<in> paths (f x)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S\n  zs \\<in> paths (f x)", "have \"\\<dots> \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  zs \\<in> paths (f x)\n\ngoal (1 subgoal):\n 1. ccNeighbors x G G\\<times> set zs \\<sqsubseteq> G", "by (rule Cons.prems(4))"], ["proof (state)\nthis:\n  ccNeighbors x G G\\<times> set zs \\<sqsubseteq> G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "finally"], ["proof (chain)\npicking this:\n  cont (\\<lambda>a. a) \\<Longrightarrow>\n  (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq> G", "have \"ccProd (seen \\<union> set xs) (set zs) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  cont (\\<lambda>a. a) \\<Longrightarrow>\n  (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq> G", "by this simp"], ["proof (state)\nthis:\n  (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq> G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "with \\<open>x \\<in> S\\<close> Cons.prems Cons.hyps"], ["proof (chain)\npicking this:\n  x \\<in> S\n  ccFromList (x # xs) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccNeighbors ?x G G\\<times> set ?ys \\<sqsubseteq> G\n  seen G\\<times> set (x # xs) \\<sqsubseteq> G\n  zs \\<in> paths (f x)\n  xs' \\<in> xs \\<otimes> zs\n  substitute'' (f_nxt f T x) T xs' ys\n  (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq> G", "have \"ccFromList [x\\<leftarrow>ys . x \\<notin> S] \\<sqsubseteq> G \\<and> ccProd (seen) (set ys) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  ccFromList (x # xs) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccNeighbors ?x G G\\<times> set ?ys \\<sqsubseteq> G\n  seen G\\<times> set (x # xs) \\<sqsubseteq> G\n  zs \\<in> paths (f x)\n  xs' \\<in> xs \\<otimes> zs\n  substitute'' (f_nxt f T x) T xs' ys\n  (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n    seen G\\<times> set ys \\<sqsubseteq> G", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> S; ccFromList (x # xs) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq> G;\n     seen G\\<times> set (x # xs) \\<sqsubseteq> G; zs \\<in> paths (f x);\n     xs' \\<in> xs \\<otimes> zs; substitute'' (f_nxt f T x) T xs' ys;\n     (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> ccFromList\n                       (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq>\n                      G \\<and>\n                      seen G\\<times> set ys \\<sqsubseteq> G", "apply (rule Cons.IH)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<in> S; ccFromList (x # xs) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq> G;\n     seen G\\<times> set (x # xs) \\<sqsubseteq> G; zs \\<in> paths (f x);\n     xs' \\<in> xs \\<otimes> zs; substitute'' (f_nxt f T x) T xs' ys;\n     (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> ccFromList xs' \\<sqsubseteq> G\n 2. \\<And>xa.\n       \\<lbrakk>x \\<in> S; ccFromList (x # xs) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set (x # xs) \\<sqsubseteq> G; zs \\<in> paths (f x);\n        xs' \\<in> xs \\<otimes> zs; substitute'' (f_nxt f T x) T xs' ys;\n        (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq> G;\n        xa \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> f_nxt f T x xa = TTree.empty\n 3. \\<And>xa ysa.\n       \\<lbrakk>x \\<in> S; ccFromList (x # xs) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set (x # xs) \\<sqsubseteq> G; zs \\<in> paths (f x);\n        xs' \\<in> xs \\<otimes> zs; substitute'' (f_nxt f T x) T xs' ys;\n        (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq> G; xa \\<in> S;\n        ysa \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n       \\<Longrightarrow> ccFromList ysa \\<sqsubseteq> G\n 4. \\<And>xa ysa.\n       \\<lbrakk>x \\<in> S; ccFromList (x # xs) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set (x # xs) \\<sqsubseteq> G; zs \\<in> paths (f x);\n        xs' \\<in> xs \\<otimes> zs; substitute'' (f_nxt f T x) T xs' ys;\n        (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq> G; xa \\<in> S;\n        ysa \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n       \\<Longrightarrow> ccNeighbors xa G G\\<times> set ysa \\<sqsubseteq> G\n 5. \\<lbrakk>x \\<in> S; ccFromList (x # xs) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq> G;\n     seen G\\<times> set (x # xs) \\<sqsubseteq> G; zs \\<in> paths (f x);\n     xs' \\<in> xs \\<otimes> zs; substitute'' (f_nxt f T x) T xs' ys;\n     (seen \\<union> set xs) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times> set xs' \\<sqsubseteq> G", "apply (auto simp add: f_nxt_def  join_below_iff  interleave_ccFromList interleave_set  ccProd_insert2[where S' = \"set xs\" for xs]\n                  split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  seen G\\<times> set ys \\<sqsubseteq> G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "with  \\<open>x \\<in> S\\<close>  seen_x"], ["proof (chain)\npicking this:\n  x \\<in> S\n  seen G\\<times> {x} \\<sqsubseteq> G\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  seen G\\<times> set ys \\<sqsubseteq> G", "show \"ccFromList [x\\<leftarrow>x # ys . x \\<notin> S] \\<sqsubseteq> G  \\<and> ccProd seen (set (x#ys)) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  seen G\\<times> {x} \\<sqsubseteq> G\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  seen G\\<times> set ys \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "by (auto simp add: ccProd_insert2[where S' = \"set xs\" for xs] join_below_iff)"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n  G \\<and>\n  seen G\\<times> set (x # ys) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "case False"], ["proof (state)\nthis:\n  x \\<notin> S\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "from False Cons.prems Cons.hyps"], ["proof (chain)\npicking this:\n  x \\<notin> S\n  ccFromList (x # xs) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccNeighbors ?x G G\\<times> set ?ys \\<sqsubseteq> G\n  seen G\\<times> set (x # xs) \\<sqsubseteq> G\n  zs \\<in> paths (f x)\n  xs' \\<in> xs \\<otimes> zs\n  substitute'' (f_nxt f T x) T xs' ys", "have *: \"ccFromList [x\\<leftarrow>ys . x \\<notin> S] \\<sqsubseteq> G \\<and> ccProd ((insert x seen)) (set ys) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  x \\<notin> S\n  ccFromList (x # xs) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccNeighbors ?x G G\\<times> set ?ys \\<sqsubseteq> G\n  seen G\\<times> set (x # xs) \\<sqsubseteq> G\n  zs \\<in> paths (f x)\n  xs' \\<in> xs \\<otimes> zs\n  substitute'' (f_nxt f T x) T xs' ys\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n    insert x seen G\\<times> set ys \\<sqsubseteq> G", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> S; ccFromList (x # xs) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq> G;\n     seen G\\<times> set (x # xs) \\<sqsubseteq> G; zs \\<in> paths (f x);\n     xs' \\<in> xs \\<otimes> zs; substitute'' (f_nxt f T x) T xs' ys\\<rbrakk>\n    \\<Longrightarrow> ccFromList\n                       (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq>\n                      G \\<and>\n                      insert x seen G\\<times> set ys \\<sqsubseteq> G", "apply (rule Cons.IH[where seen = \"insert x seen\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<notin> S; ccFromList (x # xs) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq> G;\n     seen G\\<times> set (x # xs) \\<sqsubseteq> G; zs \\<in> paths (f x);\n     xs' \\<in> xs \\<otimes> zs; substitute'' (f_nxt f T x) T xs' ys\\<rbrakk>\n    \\<Longrightarrow> ccFromList xs' \\<sqsubseteq> G\n 2. \\<And>xa.\n       \\<lbrakk>x \\<notin> S; ccFromList (x # xs) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set (x # xs) \\<sqsubseteq> G; zs \\<in> paths (f x);\n        xs' \\<in> xs \\<otimes> zs; substitute'' (f_nxt f T x) T xs' ys;\n        xa \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> f_nxt f T x xa = TTree.empty\n 3. \\<And>xa ysa.\n       \\<lbrakk>x \\<notin> S; ccFromList (x # xs) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set (x # xs) \\<sqsubseteq> G; zs \\<in> paths (f x);\n        xs' \\<in> xs \\<otimes> zs; substitute'' (f_nxt f T x) T xs' ys;\n        xa \\<in> S; ysa \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n       \\<Longrightarrow> ccFromList ysa \\<sqsubseteq> G\n 4. \\<And>xa ysa.\n       \\<lbrakk>x \\<notin> S; ccFromList (x # xs) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> set (x # xs) \\<sqsubseteq> G; zs \\<in> paths (f x);\n        xs' \\<in> xs \\<otimes> zs; substitute'' (f_nxt f T x) T xs' ys;\n        xa \\<in> S; ysa \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n       \\<Longrightarrow> ccNeighbors xa G G\\<times> set ysa \\<sqsubseteq> G\n 5. \\<lbrakk>x \\<notin> S; ccFromList (x # xs) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccNeighbors x G G\\<times> set ys \\<sqsubseteq> G;\n     seen G\\<times> set (x # xs) \\<sqsubseteq> G; zs \\<in> paths (f x);\n     xs' \\<in> xs \\<otimes> zs; substitute'' (f_nxt f T x) T xs' ys\\<rbrakk>\n    \\<Longrightarrow> insert x seen G\\<times> set xs' \\<sqsubseteq> G", "apply (auto simp add: ccApprox_both join_below_iff ttree_restr_both interleave_ccFromList insert_Diff_if\n                   simp add:  ccProd_insert2[where S' = \"set xs\" for xs]\n                   simp add:  ccProd_insert1[where S' = \"seen\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  insert x seen G\\<times> set ys \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  insert x seen G\\<times> set ys \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "from False *"], ["proof (chain)\npicking this:\n  x \\<notin> S\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  insert x seen G\\<times> set ys \\<sqsubseteq> G", "have \"ccProd {x} (set ys) \\<sqsubseteq>  G\""], ["proof (prove)\nusing this:\n  x \\<notin> S\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  insert x seen G\\<times> set ys \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. {x} G\\<times> set ys \\<sqsubseteq> G", "by (auto simp add: insert_Diff_if ccProd_insert1[where S' = \"seen\"] join_below_iff)"], ["proof (state)\nthis:\n  {x} G\\<times> set ys \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "hence \"ccProd {x} {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  {x} G\\<times> set ys \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. {x} G\\<times> {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G", "by (rule below_trans[rotated, OF _ ccProd_mono2]) auto"], ["proof (state)\nthis:\n  {x} G\\<times> {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  {x} G\\<times> {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "note False seen_x"], ["proof (state)\nthis:\n  x \\<notin> S\n  seen G\\<times> {x} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "ultimately"], ["proof (chain)\npicking this:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  insert x seen G\\<times> set ys \\<sqsubseteq> G\n  {x} G\\<times> {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G\n  x \\<notin> S\n  seen G\\<times> {x} \\<sqsubseteq> G", "show \"ccFromList [x\\<leftarrow>x # ys . x \\<notin> S] \\<sqsubseteq> G \\<and> ccProd (seen) (set (x # ys)) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  insert x seen G\\<times> set ys \\<sqsubseteq> G\n  {x} G\\<times> {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G\n  x \\<notin> S\n  seen G\\<times> {x} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> set (x # ys) \\<sqsubseteq> G", "by (auto simp add: join_below_iff  simp add: insert_Diff_if  ccProd_insert2[where S' = \"set xs\" for xs]   ccProd_insert1[where S' = \"seen\"])"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n  G \\<and>\n  seen G\\<times> set (x # ys) \\<sqsubseteq> G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n  G \\<and>\n  seen G\\<times> set (x # ys) \\<sqsubseteq> G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) xs') \\<sqsubseteq> G \\<and>\n  seen G\\<times> set xs' \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "with \\<open>xs = _\\<close>"], ["proof (chain)\npicking this:\n  xs = filter (\\<lambda>x. x \\<notin> S) xs'\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) xs') \\<sqsubseteq> G \\<and>\n  seen G\\<times> set xs' \\<sqsubseteq> G", "show \"ccFromList xs \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  xs = filter (\\<lambda>x. x \\<notin> S) xs'\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) xs') \\<sqsubseteq> G \\<and>\n  seen G\\<times> set xs' \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. ccFromList xs \\<sqsubseteq> G", "by simp"], ["proof (state)\nthis:\n  ccFromList xs \\<sqsubseteq> G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wild_recursion_thunked:\n  assumes \"ccApprox  t \\<sqsubseteq> G\"\n  assumes \"\\<And> x. x \\<notin> S \\<Longrightarrow> f x = empty\"\n  assumes \"\\<And> x. x \\<in> S \\<Longrightarrow> ccApprox (f x) \\<sqsubseteq> G\"\n  assumes \"\\<And> x. x \\<in> S \\<Longrightarrow> ccProd (ccNeighbors x G - {x} \\<inter> T) (carrier (f x)) \\<sqsubseteq> G\"\n  shows \"ccApprox (ttree_restr (-S) (substitute f T t)) \\<sqsubseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox (ttree_restr (- S) (substitute f T t)) \\<sqsubseteq> G", "proof(rule ccApprox_belowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "define seen :: \"var set\" where \"seen = {}\""], ["proof (state)\nthis:\n  seen = {}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "define seen_T :: \"var set\" where \"seen_T = {}\""], ["proof (state)\nthis:\n  seen_T = {}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "assume \"xs \\<in> paths (ttree_restr (- S) (substitute f T t))\""], ["proof (state)\nthis:\n  xs \\<in> paths (ttree_restr (- S) (substitute f T t))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "then"], ["proof (chain)\npicking this:\n  xs \\<in> paths (ttree_restr (- S) (substitute f T t))", "obtain xs' xs'' where \"xs = [x\\<leftarrow>xs' . x \\<notin> S]\" and \"substitute'' f T xs'' xs'\" and \"xs'' \\<in> paths t\""], ["proof (prove)\nusing this:\n  xs \\<in> paths (ttree_restr (- S) (substitute f T t))\n\ngoal (1 subgoal):\n 1. (\\<And>xs' xs''.\n        \\<lbrakk>xs = filter (\\<lambda>x. x \\<notin> S) xs';\n         substitute'' f T xs'' xs'; xs'' \\<in> paths t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: filter_paths_conv_free_restr2[symmetric] substitute_substitute'')"], ["proof (state)\nthis:\n  xs = filter (\\<lambda>x. x \\<notin> S) xs'\n  substitute'' f T xs'' xs'\n  xs'' \\<in> paths t\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "note this(2)"], ["proof (state)\nthis:\n  substitute'' f T xs'' xs'\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  substitute'' f T xs'' xs'\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "from \\<open>ccApprox t \\<sqsubseteq> G\\<close> and \\<open>xs'' \\<in> paths t\\<close>"], ["proof (chain)\npicking this:\n  ccApprox t \\<sqsubseteq> G\n  xs'' \\<in> paths t", "have  \"ccFromList xs'' \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  ccApprox t \\<sqsubseteq> G\n  xs'' \\<in> paths t\n\ngoal (1 subgoal):\n 1. ccFromList xs'' \\<sqsubseteq> G", "by (auto simp add: ccApprox_below_iff)"], ["proof (state)\nthis:\n  ccFromList xs'' \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "hence  \"ccFromList xs'' G|` (- seen_T) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  ccFromList xs'' \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. ccFromList xs'' G|` (- seen_T) \\<sqsubseteq> G", "by (rule rev_below_trans[OF _ cc_restr_below_arg])"], ["proof (state)\nthis:\n  ccFromList xs'' G|` (- seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  ccFromList xs'' G|` (- seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "note assms(2)"], ["proof (state)\nthis:\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "from assms(3,4)"], ["proof (chain)\npicking this:\n  ?x \\<in> S \\<Longrightarrow> ccApprox (f ?x) \\<sqsubseteq> G\n  ?x \\<in> S \\<Longrightarrow>\n  (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n  carrier (f ?x) \\<sqsubseteq>\n  G", "have \"\\<And> x ys. x \\<in> S \\<Longrightarrow> ys \\<in> paths (f x) \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G\"\n    and \"\\<And> x ys. x \\<in> S \\<Longrightarrow> ys \\<in> paths (f x) \\<Longrightarrow> ccProd (ccNeighbors x G - {x} \\<inter> T) (set ys) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> ccApprox (f ?x) \\<sqsubseteq> G\n  ?x \\<in> S \\<Longrightarrow>\n  (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n  carrier (f ?x) \\<sqsubseteq>\n  G\n\ngoal (1 subgoal):\n 1. (\\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G) &&&\n    (\\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G)", "by (auto simp add: ccApprox_below_iff seen_T_def Union_paths_carrier[symmetric] cc_lub_below_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "have \"ccProd seen (set xs'' - seen_T) \\<sqsubseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seen G\\<times> (set xs'' - seen_T) \\<sqsubseteq> G", "unfolding seen_def seen_T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} G\\<times> (set xs'' - {}) \\<sqsubseteq> G", "by simp"], ["proof (state)\nthis:\n  seen G\\<times> (set xs'' - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  seen G\\<times> (set xs'' - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "have \"seen \\<inter> S = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seen \\<inter> S = {}", "unfolding seen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<inter> S = {}", "by simp"], ["proof (state)\nthis:\n  seen \\<inter> S = {}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  seen \\<inter> S = {}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "have \"seen_T \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seen_T \\<subseteq> S", "unfolding seen_T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> S", "by simp"], ["proof (state)\nthis:\n  seen_T \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  seen_T \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "have \"\\<And> x. x \\<in> seen_T \\<Longrightarrow> f x = empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty", "unfolding seen_T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {} \\<Longrightarrow> f x = TTree.empty", "by simp"], ["proof (state)\nthis:\n  ?x \\<in> seen_T \\<Longrightarrow> f ?x = TTree.empty\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "ultimately"], ["proof (chain)\npicking this:\n  substitute'' f T xs'' xs'\n  ccFromList xs'' G|` (- seen_T) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n  seen G\\<times> (set xs'' - seen_T) \\<sqsubseteq> G\n  seen \\<inter> S = {}\n  seen_T \\<subseteq> S\n  ?x \\<in> seen_T \\<Longrightarrow> f ?x = TTree.empty", "have \"ccFromList [x\\<leftarrow>xs' . x \\<notin> S] \\<sqsubseteq> G \\<and> ccProd (seen) (set xs' - seen_T) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  substitute'' f T xs'' xs'\n  ccFromList xs'' G|` (- seen_T) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n  seen G\\<times> (set xs'' - seen_T) \\<sqsubseteq> G\n  seen \\<inter> S = {}\n  seen_T \\<subseteq> S\n  ?x \\<in> seen_T \\<Longrightarrow> f ?x = TTree.empty\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) xs') \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G", "proof(induction f T xs'' xs' arbitrary: seen seen_T rule: substitute''.induct[case_names Nil Cons])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f T seen seen_T.\n       \\<lbrakk>ccFromList [] G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set [] - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            []) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times> (set [] - seen_T) \\<sqsubseteq> G\n 2. \\<And>zs f x xs' xs T ys seen seen_T.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen seen_T.\n           \\<lbrakk>ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> (ccNeighbors xa G -\n                                  {xa} \\<inter> T) G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G;\n            seen \\<inter> S = {}; seen_T \\<subseteq> S;\n            \\<And>xa.\n               xa \\<in> seen_T \\<Longrightarrow>\n               f_nxt f T x xa = TTree.empty\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> (set ys - seen_T) \\<sqsubseteq>\n                             G;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times>\n                         (set (x # ys) - seen_T) \\<sqsubseteq>\n                         G", "case Nil"], ["proof (state)\nthis:\n  ccFromList [] G|` (- seen_T) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f_ ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f_ ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f_ ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T_) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n  seen G\\<times> (set [] - seen_T) \\<sqsubseteq> G\n  seen \\<inter> S = {}\n  seen_T \\<subseteq> S\n  ?x \\<in> seen_T \\<Longrightarrow> f_ ?x = TTree.empty\n\ngoal (2 subgoals):\n 1. \\<And>f T seen seen_T.\n       \\<lbrakk>ccFromList [] G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set [] - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            []) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times> (set [] - seen_T) \\<sqsubseteq> G\n 2. \\<And>zs f x xs' xs T ys seen seen_T.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen seen_T.\n           \\<lbrakk>ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> (ccNeighbors xa G -\n                                  {xa} \\<inter> T) G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G;\n            seen \\<inter> S = {}; seen_T \\<subseteq> S;\n            \\<And>xa.\n               xa \\<in> seen_T \\<Longrightarrow>\n               f_nxt f T x xa = TTree.empty\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> (set ys - seen_T) \\<sqsubseteq>\n                             G;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times>\n                         (set (x # ys) - seen_T) \\<sqsubseteq>\n                         G", "thus ?case"], ["proof (prove)\nusing this:\n  ccFromList [] G|` (- seen_T) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f_ ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f_ ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f_ ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T_) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n  seen G\\<times> (set [] - seen_T) \\<sqsubseteq> G\n  seen \\<inter> S = {}\n  seen_T \\<subseteq> S\n  ?x \\<in> seen_T \\<Longrightarrow> f_ ?x = TTree.empty\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) []) \\<sqsubseteq> G \\<and>\n    seen G\\<times> (set [] - seen_T) \\<sqsubseteq> G", "by simp"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) []) \\<sqsubseteq> G \\<and>\n  seen G\\<times> (set [] - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen seen_T.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen seen_T.\n           \\<lbrakk>ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> (ccNeighbors xa G -\n                                  {xa} \\<inter> T) G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G;\n            seen \\<inter> S = {}; seen_T \\<subseteq> S;\n            \\<And>xa.\n               xa \\<in> seen_T \\<Longrightarrow>\n               f_nxt f T x xa = TTree.empty\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> (set ys - seen_T) \\<sqsubseteq>\n                             G;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times>\n                         (set (x # ys) - seen_T) \\<sqsubseteq>\n                         G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen seen_T.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen seen_T.\n           \\<lbrakk>ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> (ccNeighbors xa G -\n                                  {xa} \\<inter> T) G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G;\n            seen \\<inter> S = {}; seen_T \\<subseteq> S;\n            \\<And>xa.\n               xa \\<in> seen_T \\<Longrightarrow>\n               f_nxt f T x xa = TTree.empty\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> (set ys - seen_T) \\<sqsubseteq>\n                             G;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times>\n                         (set (x # ys) - seen_T) \\<sqsubseteq>\n                         G", "case (Cons zs f x xs' xs T ys)"], ["proof (state)\nthis:\n  zs \\<in> paths (f x)\n  xs' \\<in> xs \\<otimes> zs\n  substitute'' (f_nxt f T x) T xs' ys\n  \\<lbrakk>ccFromList xs' G|` (- ?seen_T) \\<sqsubseteq> G;\n   \\<And>xa. xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n   \\<And>xa ys.\n      \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n      \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n   \\<And>xa ys.\n      \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n      \\<Longrightarrow> (ccNeighbors xa G - {xa} \\<inter> T) G\\<times>\n                        set ys \\<sqsubseteq>\n                        G;\n   ?seen G\\<times> (set xs' - ?seen_T) \\<sqsubseteq> G;\n   ?seen \\<inter> S = {}; ?seen_T \\<subseteq> S;\n   \\<And>xa.\n      xa \\<in> ?seen_T \\<Longrightarrow>\n      f_nxt f T x xa = TTree.empty\\<rbrakk>\n  \\<Longrightarrow> ccFromList\n                     (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq>\n                    G \\<and>\n                    ?seen G\\<times> (set ys - ?seen_T) \\<sqsubseteq> G\n  ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n  seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G\n  seen \\<inter> S = {}\n  seen_T \\<subseteq> S\n  ?x \\<in> seen_T \\<Longrightarrow> f ?x = TTree.empty\n\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen seen_T.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen seen_T.\n           \\<lbrakk>ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> (ccNeighbors xa G -\n                                  {xa} \\<inter> T) G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G;\n            seen \\<inter> S = {}; seen_T \\<subseteq> S;\n            \\<And>xa.\n               xa \\<in> seen_T \\<Longrightarrow>\n               f_nxt f T x xa = TTree.empty\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> (set ys - seen_T) \\<sqsubseteq>\n                             G;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times>\n                         (set (x # ys) - seen_T) \\<sqsubseteq>\n                         G", "let  ?seen_T = \"if x \\<in> T then insert x seen_T else seen_T\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen seen_T.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen seen_T.\n           \\<lbrakk>ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> (ccNeighbors xa G -\n                                  {xa} \\<inter> T) G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G;\n            seen \\<inter> S = {}; seen_T \\<subseteq> S;\n            \\<And>xa.\n               xa \\<in> seen_T \\<Longrightarrow>\n               f_nxt f T x xa = TTree.empty\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> (set ys - seen_T) \\<sqsubseteq>\n                             G;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times>\n                         (set (x # ys) - seen_T) \\<sqsubseteq>\n                         G", "have subset: \"- insert x seen_T \\<subseteq> - seen_T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - insert x seen_T \\<subseteq> - seen_T", "by auto"], ["proof (state)\nthis:\n  - insert x seen_T \\<subseteq> - seen_T\n\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen seen_T.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen seen_T.\n           \\<lbrakk>ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> (ccNeighbors xa G -\n                                  {xa} \\<inter> T) G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G;\n            seen \\<inter> S = {}; seen_T \\<subseteq> S;\n            \\<And>xa.\n               xa \\<in> seen_T \\<Longrightarrow>\n               f_nxt f T x xa = TTree.empty\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> (set ys - seen_T) \\<sqsubseteq>\n                             G;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times>\n                         (set (x # ys) - seen_T) \\<sqsubseteq>\n                         G", "have subset2: \"set xs \\<inter> - insert x seen_T \\<subseteq> insert x (set xs) \\<inter> - seen_T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<inter> - insert x seen_T\n    \\<subseteq> insert x (set xs) \\<inter> - seen_T", "by auto"], ["proof (state)\nthis:\n  set xs \\<inter> - insert x seen_T\n  \\<subseteq> insert x (set xs) \\<inter> - seen_T\n\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen seen_T.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen seen_T.\n           \\<lbrakk>ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> (ccNeighbors xa G -\n                                  {xa} \\<inter> T) G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G;\n            seen \\<inter> S = {}; seen_T \\<subseteq> S;\n            \\<And>xa.\n               xa \\<in> seen_T \\<Longrightarrow>\n               f_nxt f T x xa = TTree.empty\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> (set ys - seen_T) \\<sqsubseteq>\n                             G;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times>\n                         (set (x # ys) - seen_T) \\<sqsubseteq>\n                         G", "have subset3: \"set zs \\<inter> - insert x seen_T \\<subseteq> set zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set zs \\<inter> - insert x seen_T \\<subseteq> set zs", "by auto"], ["proof (state)\nthis:\n  set zs \\<inter> - insert x seen_T \\<subseteq> set zs\n\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen seen_T.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen seen_T.\n           \\<lbrakk>ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> (ccNeighbors xa G -\n                                  {xa} \\<inter> T) G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G;\n            seen \\<inter> S = {}; seen_T \\<subseteq> S;\n            \\<And>xa.\n               xa \\<in> seen_T \\<Longrightarrow>\n               f_nxt f T x xa = TTree.empty\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> (set ys - seen_T) \\<sqsubseteq>\n                             G;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times>\n                         (set (x # ys) - seen_T) \\<sqsubseteq>\n                         G", "have subset4: \"set xs \\<inter> - seen_T \\<subseteq> insert x (set xs) \\<inter> - seen_T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<inter> - seen_T \\<subseteq> insert x (set xs) \\<inter> - seen_T", "by auto"], ["proof (state)\nthis:\n  set xs \\<inter> - seen_T \\<subseteq> insert x (set xs) \\<inter> - seen_T\n\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen seen_T.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen seen_T.\n           \\<lbrakk>ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> (ccNeighbors xa G -\n                                  {xa} \\<inter> T) G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G;\n            seen \\<inter> S = {}; seen_T \\<subseteq> S;\n            \\<And>xa.\n               xa \\<in> seen_T \\<Longrightarrow>\n               f_nxt f T x xa = TTree.empty\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> (set ys - seen_T) \\<sqsubseteq>\n                             G;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times>\n                         (set (x # ys) - seen_T) \\<sqsubseteq>\n                         G", "have subset5: \"set zs \\<inter> - seen_T \\<subseteq> set zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set zs \\<inter> - seen_T \\<subseteq> set zs", "by auto"], ["proof (state)\nthis:\n  set zs \\<inter> - seen_T \\<subseteq> set zs\n\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen seen_T.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen seen_T.\n           \\<lbrakk>ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> (ccNeighbors xa G -\n                                  {xa} \\<inter> T) G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G;\n            seen \\<inter> S = {}; seen_T \\<subseteq> S;\n            \\<And>xa.\n               xa \\<in> seen_T \\<Longrightarrow>\n               f_nxt f T x xa = TTree.empty\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> (set ys - seen_T) \\<sqsubseteq>\n                             G;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times>\n                         (set (x # ys) - seen_T) \\<sqsubseteq>\n                         G", "have subset6: \"set ys - seen_T \\<subseteq> (set ys - ?seen_T) \\<union> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys - seen_T\n    \\<subseteq> set ys -\n                (if x \\<in> T then insert x seen_T else seen_T) \\<union>\n                {x}", "by auto"], ["proof (state)\nthis:\n  set ys - seen_T\n  \\<subseteq> set ys -\n              (if x \\<in> T then insert x seen_T else seen_T) \\<union>\n              {x}\n\ngoal (1 subgoal):\n 1. \\<And>zs f x xs' xs T ys seen seen_T.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        \\<And>seen seen_T.\n           \\<lbrakk>ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G;\n            \\<And>xa.\n               xa \\<notin> S \\<Longrightarrow> f_nxt f T x xa = TTree.empty;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n            \\<And>xa ys.\n               \\<lbrakk>xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n               \\<Longrightarrow> (ccNeighbors xa G -\n                                  {xa} \\<inter> T) G\\<times>\n                                 set ys \\<sqsubseteq>\n                                 G;\n            seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G;\n            seen \\<inter> S = {}; seen_T \\<subseteq> S;\n            \\<And>xa.\n               xa \\<in> seen_T \\<Longrightarrow>\n               f_nxt f T x xa = TTree.empty\\<rbrakk>\n           \\<Longrightarrow> ccFromList\n                              (filter (\\<lambda>x. x \\<notin> S)\n                                ys) \\<sqsubseteq>\n                             G \\<and>\n                             seen G\\<times> (set ys - seen_T) \\<sqsubseteq>\n                             G;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n       \\<Longrightarrow> ccFromList\n                          (filter (\\<lambda>x. x \\<notin> S)\n                            (x # ys)) \\<sqsubseteq>\n                         G \\<and>\n                         seen G\\<times>\n                         (set (x # ys) - seen_T) \\<sqsubseteq>\n                         G", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "proof(cases \"x \\<in> seen_T\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "assume \"x \\<in> seen_T\""], ["proof (state)\nthis:\n  x \\<in> seen_T\n\ngoal (2 subgoals):\n 1. x \\<in> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "have [simp]: \"f x = empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = TTree.empty", "using \\<open>x \\<in> seen_T\\<close> Cons.prems"], ["proof (prove)\nusing this:\n  x \\<in> seen_T\n  ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n  seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G\n  seen \\<inter> S = {}\n  seen_T \\<subseteq> S\n  ?x \\<in> seen_T \\<Longrightarrow> f ?x = TTree.empty\n\ngoal (1 subgoal):\n 1. f x = TTree.empty", "by auto"], ["proof (state)\nthis:\n  f x = TTree.empty\n\ngoal (2 subgoals):\n 1. x \\<in> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "have [simp]: \"f_nxt f T x = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_nxt f T x = f", "by (auto simp add: f_nxt_def split:if_splits)"], ["proof (state)\nthis:\n  f_nxt f T x = f\n\ngoal (2 subgoals):\n 1. x \\<in> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "have [simp]: \"zs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zs = []", "using \\<open>zs \\<in> paths (f x)\\<close>"], ["proof (prove)\nusing this:\n  zs \\<in> paths (f x)\n\ngoal (1 subgoal):\n 1. zs = []", "by simp"], ["proof (state)\nthis:\n  zs = []\n\ngoal (2 subgoals):\n 1. x \\<in> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "have [simp]: \"xs' = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = xs", "using \\<open>xs' \\<in> xs \\<otimes> zs\\<close>"], ["proof (prove)\nusing this:\n  xs' \\<in> xs \\<otimes> zs\n\ngoal (1 subgoal):\n 1. xs' = xs", "by simp"], ["proof (state)\nthis:\n  xs' = xs\n\ngoal (2 subgoals):\n 1. x \\<in> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "have [simp]: \"x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S", "using \\<open>x \\<in> seen_T\\<close> Cons.prems"], ["proof (prove)\nusing this:\n  x \\<in> seen_T\n  ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n  seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G\n  seen \\<inter> S = {}\n  seen_T \\<subseteq> S\n  ?x \\<in> seen_T \\<Longrightarrow> f ?x = TTree.empty\n\ngoal (1 subgoal):\n 1. x \\<in> S", "by auto"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (2 subgoals):\n 1. x \\<in> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "from Cons.hyps Cons.prems"], ["proof (chain)\npicking this:\n  zs \\<in> paths (f x)\n  xs' \\<in> xs \\<otimes> zs\n  substitute'' (f_nxt f T x) T xs' ys\n  ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n  seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G\n  seen \\<inter> S = {}\n  seen_T \\<subseteq> S\n  ?x \\<in> seen_T \\<Longrightarrow> f ?x = TTree.empty", "have \"ccFromList [x\\<leftarrow>ys . x \\<notin> S] \\<sqsubseteq> G \\<and> ccProd seen (set ys - seen_T) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  zs \\<in> paths (f x)\n  xs' \\<in> xs \\<otimes> zs\n  substitute'' (f_nxt f T x) T xs' ys\n  ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n  seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G\n  seen \\<inter> S = {}\n  seen_T \\<subseteq> S\n  ?x \\<in> seen_T \\<Longrightarrow> f ?x = TTree.empty\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n    seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     substitute'' (f_nxt f T x) T xs' ys;\n     ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n    \\<Longrightarrow> ccFromList\n                       (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq>\n                      G \\<and>\n                      seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G", "apply (rule Cons.IH[where seen_T = seen_T])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     substitute'' (f_nxt f T x) T xs' ys;\n     ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n    \\<Longrightarrow> ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G\n 2. \\<And>xa.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n        xa \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> f_nxt f T x xa = TTree.empty\n 3. \\<And>xa ysa.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n        xa \\<in> S; ysa \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n       \\<Longrightarrow> ccFromList ysa \\<sqsubseteq> G\n 4. \\<And>xa ysa.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n        xa \\<in> S; ysa \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n       \\<Longrightarrow> (ccNeighbors xa G - {xa} \\<inter> T) G\\<times>\n                         set ysa \\<sqsubseteq>\n                         G\n 5. \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     substitute'' (f_nxt f T x) T xs' ys;\n     ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G\n 6. \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     substitute'' (f_nxt f T x) T xs' ys;\n     ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n    \\<Longrightarrow> seen \\<inter> S = {}\n 7. \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     substitute'' (f_nxt f T x) T xs' ys;\n     ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty\\<rbrakk>\n    \\<Longrightarrow> seen_T \\<subseteq> S\n 8. \\<And>xa.\n       \\<lbrakk>zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n        xa \\<in> seen_T\\<rbrakk>\n       \\<Longrightarrow> f_nxt f T x xa = TTree.empty", "apply (auto simp add: join_below_iff Diff_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>substitute'' f T xs ys;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - seen_T) \\<sqsubseteq>\n                      G", "apply (erule below_trans[OF ccProd_mono[OF order_refl subset4]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G\n\ngoal (2 subgoals):\n 1. x \\<in> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "thus ?thesis"], ["proof (prove)\nusing this:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "using \\<open>x \\<in> seen_T\\<close>"], ["proof (prove)\nusing this:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G\n  x \\<in> seen_T\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "by simp"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n  G \\<and>\n  seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "assume \"x \\<notin> seen_T\""], ["proof (state)\nthis:\n  x \\<notin> seen_T\n\ngoal (1 subgoal):\n 1. x \\<notin> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "have seen_x: \"ccProd seen {x} \\<sqsubseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seen G\\<times> {x} \\<sqsubseteq> G", "using \\<open>ccProd seen (set (x # xs) - seen_T) \\<sqsubseteq> G\\<close> \\<open>x \\<notin> seen_T\\<close>"], ["proof (prove)\nusing this:\n  seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G\n  x \\<notin> seen_T\n\ngoal (1 subgoal):\n 1. seen G\\<times> {x} \\<sqsubseteq> G", "by (auto simp add: insert_Diff_if ccProd_insert2[where S' = \"set xs - seen_T\" for xs] join_below_iff)"], ["proof (state)\nthis:\n  seen G\\<times> {x} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> seen_T \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "proof(cases \"x \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "case True"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "from \\<open>cc_restr (- seen_T) (ccFromList (x # xs)) \\<sqsubseteq> G\\<close>"], ["proof (chain)\npicking this:\n  ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G", "have \"ccProd {x} (set xs - seen_T) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. {x} G\\<times> (set xs - seen_T) \\<sqsubseteq> G", "using \\<open>x \\<notin> seen_T\\<close>"], ["proof (prove)\nusing this:\n  ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G\n  x \\<notin> seen_T\n\ngoal (1 subgoal):\n 1. {x} G\\<times> (set xs - seen_T) \\<sqsubseteq> G", "by (auto simp add: join_below_iff Diff_eq)"], ["proof (state)\nthis:\n  {x} G\\<times> (set xs - seen_T) \\<sqsubseteq> G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "hence \"set xs - seen_T \\<subseteq> ccNeighbors x G\""], ["proof (prove)\nusing this:\n  {x} G\\<times> (set xs - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. set xs - seen_T \\<subseteq> ccNeighbors x G", "by transfer auto"], ["proof (state)\nthis:\n  set xs - seen_T \\<subseteq> ccNeighbors x G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  set xs - seen_T \\<subseteq> ccNeighbors x G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "from seen_x"], ["proof (chain)\npicking this:\n  seen G\\<times> {x} \\<sqsubseteq> G", "have \"seen  \\<subseteq> ccNeighbors x G\""], ["proof (prove)\nusing this:\n  seen G\\<times> {x} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. seen \\<subseteq> ccNeighbors x G", "by (simp add: subset_ccNeighbors   ccProd_comm)"], ["proof (state)\nthis:\n  seen \\<subseteq> ccNeighbors x G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  seen \\<subseteq> ccNeighbors x G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "have \"x \\<notin> seen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> seen", "using True \\<open>seen \\<inter> S = {}\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> S\n  seen \\<inter> S = {}\n\ngoal (1 subgoal):\n 1. x \\<notin> seen", "by auto"], ["proof (state)\nthis:\n  x \\<notin> seen\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "ultimately"], ["proof (chain)\npicking this:\n  set xs - seen_T \\<subseteq> ccNeighbors x G\n  seen \\<subseteq> ccNeighbors x G\n  x \\<notin> seen", "have \"seen \\<union> (set xs \\<inter> - ?seen_T) \\<subseteq> ccNeighbors x G - {x}\\<inter>T\""], ["proof (prove)\nusing this:\n  set xs - seen_T \\<subseteq> ccNeighbors x G\n  seen \\<subseteq> ccNeighbors x G\n  x \\<notin> seen\n\ngoal (1 subgoal):\n 1. seen \\<union>\n    set xs \\<inter> - (if x \\<in> T then insert x seen_T else seen_T)\n    \\<subseteq> ccNeighbors x G - {x} \\<inter> T", "by auto"], ["proof (state)\nthis:\n  seen \\<union>\n  set xs \\<inter> - (if x \\<in> T then insert x seen_T else seen_T)\n  \\<subseteq> ccNeighbors x G - {x} \\<inter> T\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "hence \"ccProd (seen \\<union> (set xs \\<inter> - ?seen_T)) (set zs) \\<sqsubseteq> ccProd (ccNeighbors x G - {x}\\<inter>T) (set zs)\""], ["proof (prove)\nusing this:\n  seen \\<union>\n  set xs \\<inter> - (if x \\<in> T then insert x seen_T else seen_T)\n  \\<subseteq> ccNeighbors x G - {x} \\<inter> T\n\ngoal (1 subgoal):\n 1. (seen \\<union>\n     set xs \\<inter>\n     - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n    set zs \\<sqsubseteq>\n    (ccNeighbors x G - {x} \\<inter> T) G\\<times> set zs", "by (rule ccProd_mono1)"], ["proof (state)\nthis:\n  (seen \\<union>\n   set xs \\<inter>\n   - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n  set zs \\<sqsubseteq>\n  (ccNeighbors x G - {x} \\<inter> T) G\\<times> set zs\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "also"], ["proof (state)\nthis:\n  (seen \\<union>\n   set xs \\<inter>\n   - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n  set zs \\<sqsubseteq>\n  (ccNeighbors x G - {x} \\<inter> T) G\\<times> set zs\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "from \\<open>x \\<in> S\\<close>  \\<open>zs \\<in> paths (f x)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S\n  zs \\<in> paths (f x)", "have \"\\<dots> \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  zs \\<in> paths (f x)\n\ngoal (1 subgoal):\n 1. (ccNeighbors x G - {x} \\<inter> T) G\\<times> set zs \\<sqsubseteq> G", "by (rule Cons.prems(4))"], ["proof (state)\nthis:\n  (ccNeighbors x G - {x} \\<inter> T) G\\<times> set zs \\<sqsubseteq> G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "finally"], ["proof (chain)\npicking this:\n  cont (\\<lambda>a. a) \\<Longrightarrow>\n  (seen \\<union>\n   set xs \\<inter>\n   - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n  set zs \\<sqsubseteq>\n  G", "have \"ccProd (seen \\<union> (set xs \\<inter> - ?seen_T)) (set zs) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  cont (\\<lambda>a. a) \\<Longrightarrow>\n  (seen \\<union>\n   set xs \\<inter>\n   - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n  set zs \\<sqsubseteq>\n  G\n\ngoal (1 subgoal):\n 1. (seen \\<union>\n     set xs \\<inter>\n     - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n    set zs \\<sqsubseteq>\n    G", "by this simp"], ["proof (state)\nthis:\n  (seen \\<union>\n   set xs \\<inter>\n   - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n  set zs \\<sqsubseteq>\n  G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "with \\<open>x \\<in> S\\<close> Cons.prems Cons.hyps(1,2)"], ["proof (chain)\npicking this:\n  x \\<in> S\n  ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n  seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G\n  seen \\<inter> S = {}\n  seen_T \\<subseteq> S\n  ?x \\<in> seen_T \\<Longrightarrow> f ?x = TTree.empty\n  zs \\<in> paths (f x)\n  xs' \\<in> xs \\<otimes> zs\n  (seen \\<union>\n   set xs \\<inter>\n   - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n  set zs \\<sqsubseteq>\n  G", "have \"ccFromList [x\\<leftarrow>ys . x \\<notin> S] \\<sqsubseteq> G \\<and> ccProd (seen) (set ys - ?seen_T) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n  seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G\n  seen \\<inter> S = {}\n  seen_T \\<subseteq> S\n  ?x \\<in> seen_T \\<Longrightarrow> f ?x = TTree.empty\n  zs \\<in> paths (f x)\n  xs' \\<in> xs \\<otimes> zs\n  (seen \\<union>\n   set xs \\<inter>\n   - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n  set zs \\<sqsubseteq>\n  G\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n    seen G\\<times>\n    (set ys - (if x \\<in> T then insert x seen_T else seen_T)) \\<sqsubseteq>\n    G", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> S; ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     (seen \\<union>\n      set xs \\<inter>\n      - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n     set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> ccFromList\n                       (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq>\n                      G \\<and>\n                      seen G\\<times>\n                      (set ys -\n                       (if x \\<in> T then insert x seen_T\n                        else seen_T)) \\<sqsubseteq>\n                      G", "apply (rule Cons.IH[where seen_T = \"?seen_T\"])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>x \\<in> S; ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     (seen \\<union>\n      set xs \\<inter>\n      - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n     set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> ccFromList xs' G|`\n                      (- (if x \\<in> T then insert x seen_T\n                          else seen_T)) \\<sqsubseteq>\n                      G\n 2. \\<And>xa.\n       \\<lbrakk>x \\<in> S;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n        zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        (seen \\<union>\n         set xs \\<inter>\n         - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n        set zs \\<sqsubseteq>\n        G;\n        xa \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> f_nxt f T x xa = TTree.empty\n 3. \\<And>xa ys.\n       \\<lbrakk>x \\<in> S;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n        zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        (seen \\<union>\n         set xs \\<inter>\n         - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n        set zs \\<sqsubseteq>\n        G;\n        xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n       \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G\n 4. \\<And>xa ys.\n       \\<lbrakk>x \\<in> S;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n        zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        (seen \\<union>\n         set xs \\<inter>\n         - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n        set zs \\<sqsubseteq>\n        G;\n        xa \\<in> S; ys \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n       \\<Longrightarrow> (ccNeighbors xa G - {xa} \\<inter> T) G\\<times>\n                         set ys \\<sqsubseteq>\n                         G\n 5. \\<lbrakk>x \\<in> S; ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     (seen \\<union>\n      set xs \\<inter>\n      - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n     set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs' -\n                       (if x \\<in> T then insert x seen_T\n                        else seen_T)) \\<sqsubseteq>\n                      G\n 6. \\<lbrakk>x \\<in> S; ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     (seen \\<union>\n      set xs \\<inter>\n      - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n     set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen \\<inter> S = {}\n 7. \\<lbrakk>x \\<in> S; ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     (seen \\<union>\n      set xs \\<inter>\n      - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n     set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> (if x \\<in> T then insert x seen_T else seen_T)\n                      \\<subseteq> S\n 8. \\<And>xa.\n       \\<lbrakk>x \\<in> S;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n        zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        (seen \\<union>\n         set xs \\<inter>\n         - (if x \\<in> T then insert x seen_T else seen_T)) G\\<times>\n        set zs \\<sqsubseteq>\n        G;\n        xa \\<in> (if x \\<in> T then insert x seen_T else seen_T)\\<rbrakk>\n       \\<Longrightarrow> f_nxt f T x xa = TTree.empty", "apply (auto simp add: Un_Diff Int_Un_distrib2 Diff_eq f_nxt_def  join_below_iff  interleave_ccFromList interleave_set  ccProd_insert2[where S' = \"set xs\" for xs]\n                    split: if_splits)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> ccFromList xs G|` (- insert x seen_T) \\<sqsubseteq> G\n 2. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> ccFromList zs G|` (- insert x seen_T) \\<sqsubseteq> G\n 3. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> (set xs \\<inter> - insert x seen_T) G\\<times>\n                      (set zs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 4. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> ccFromList zs G|` (- seen_T) \\<sqsubseteq> G\n 5. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> (set xs \\<inter> - seen_T) G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G\n 6. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 7. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 8. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - seen_T) \\<sqsubseteq>\n                      G\n 9. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G", "apply (erule below_trans[OF cc_restr_mono1[OF subset]])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> ccFromList zs G|` (- insert x seen_T) \\<sqsubseteq> G\n 2. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> (set xs \\<inter> - insert x seen_T) G\\<times>\n                      (set zs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 3. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> ccFromList zs G|` (- seen_T) \\<sqsubseteq> G\n 4. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> (set xs \\<inter> - seen_T) G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G\n 5. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 6. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 7. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - seen_T) \\<sqsubseteq>\n                      G\n 8. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G", "apply (rule below_trans[OF cc_restr_below_arg], simp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> (set xs \\<inter> - insert x seen_T) G\\<times>\n                      (set zs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 2. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> ccFromList zs G|` (- seen_T) \\<sqsubseteq> G\n 3. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> (set xs \\<inter> - seen_T) G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G\n 4. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 5. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 6. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - seen_T) \\<sqsubseteq>\n                      G\n 7. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G", "apply (erule below_trans[OF ccProd_mono[OF order_refl Int_lower1]])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> ccFromList zs G|` (- seen_T) \\<sqsubseteq> G\n 2. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> (set xs \\<inter> - seen_T) G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G\n 3. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 4. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 5. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - seen_T) \\<sqsubseteq>\n                      G\n 6. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G", "apply (rule below_trans[OF cc_restr_below_arg], simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> (set xs \\<inter> - seen_T) G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G\n 2. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 3. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 4. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - seen_T) \\<sqsubseteq>\n                      G\n 5. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G", "apply (erule below_trans[OF ccProd_mono[OF order_refl Int_lower1]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 2. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 3. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - seen_T) \\<sqsubseteq>\n                      G\n 4. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G", "apply (erule below_trans[OF ccProd_mono[OF order_refl subset2]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<in> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - insert x seen_T) G\\<times> set zs \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - insert x seen_T) \\<sqsubseteq>\n                      G\n 2. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - seen_T) \\<sqsubseteq>\n                      G\n 3. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G", "apply (erule below_trans[OF ccProd_mono[OF order_refl subset3]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set xs \\<inter> - seen_T) \\<sqsubseteq>\n                      G\n 2. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G", "apply (erule below_trans[OF ccProd_mono[OF order_refl subset4]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> S;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G \\<inter>\n                           (- {x} \\<union> - T)) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (insert x (set xs) \\<inter> - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs; x \\<notin> T;\n     ccFromList xs G|` (- seen_T) \\<sqsubseteq> G;\n     ({x} \\<inter> - seen_T) G\\<times>\n     (set xs \\<inter> - seen_T) \\<sqsubseteq>\n     G;\n     seen G\\<times> set zs \\<sqsubseteq> G;\n     (set xs \\<inter> - seen_T) G\\<times> set zs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set zs \\<inter> - seen_T) \\<sqsubseteq>\n                      G", "apply (erule below_trans[OF ccProd_mono[OF order_refl subset5]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  seen G\\<times>\n  (set ys - (if x \\<in> T then insert x seen_T else seen_T)) \\<sqsubseteq>\n  G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n 2. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "with  \\<open>x \\<in> S\\<close>  seen_x \\<open>x \\<notin> seen_T\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S\n  seen G\\<times> {x} \\<sqsubseteq> G\n  x \\<notin> seen_T\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  seen G\\<times>\n  (set ys - (if x \\<in> T then insert x seen_T else seen_T)) \\<sqsubseteq>\n  G", "show \"ccFromList [x\\<leftarrow>x # ys . x \\<notin> S] \\<sqsubseteq> G  \\<and> ccProd seen (set (x#ys) - seen_T) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  seen G\\<times> {x} \\<sqsubseteq> G\n  x \\<notin> seen_T\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  seen G\\<times>\n  (set ys - (if x \\<in> T then insert x seen_T else seen_T)) \\<sqsubseteq>\n  G\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "apply (auto simp add: insert_Diff_if ccProd_insert2[where S' = \"set ys - seen_T\" for xs] join_below_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> S; seen G\\<times> {x} \\<sqsubseteq> G;\n     x \\<notin> seen_T; ccFromList ys G|` {x. x \\<notin> S} \\<sqsubseteq> G;\n     seen G\\<times>\n     (set ys -\n      (if x \\<in> T then insert x seen_T else seen_T)) \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G", "apply (rule below_trans[OF ccProd_mono[OF order_refl subset6]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> S; seen G\\<times> {x} \\<sqsubseteq> G;\n     x \\<notin> seen_T; ccFromList ys G|` {x. x \\<notin> S} \\<sqsubseteq> G;\n     seen G\\<times>\n     (set ys -\n      (if x \\<in> T then insert x seen_T else seen_T)) \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set ys -\n                       (if x \\<in> T then insert x seen_T\n                        else seen_T) \\<union>\n                       {x}) \\<sqsubseteq>\n                      G", "apply (subst ccProd_union2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> S; seen G\\<times> {x} \\<sqsubseteq> G;\n     x \\<notin> seen_T; ccFromList ys G|` {x. x \\<notin> S} \\<sqsubseteq> G;\n     seen G\\<times>\n     (set ys -\n      (if x \\<in> T then insert x seen_T else seen_T)) \\<sqsubseteq>\n     G\\<rbrakk>\n    \\<Longrightarrow> seen G\\<times>\n                      (set ys -\n                       (if x \\<in> T then insert x seen_T\n                        else seen_T)) \\<squnion>\n                      seen G\\<times> {x} \\<sqsubseteq>\n                      G", "apply (auto simp add: join_below_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n  G \\<and>\n  seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "case False"], ["proof (state)\nthis:\n  x \\<notin> S\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "from False Cons.prems Cons.hyps"], ["proof (chain)\npicking this:\n  x \\<notin> S\n  ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n  seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G\n  seen \\<inter> S = {}\n  seen_T \\<subseteq> S\n  ?x \\<in> seen_T \\<Longrightarrow> f ?x = TTree.empty\n  zs \\<in> paths (f x)\n  xs' \\<in> xs \\<otimes> zs\n  substitute'' (f_nxt f T x) T xs' ys", "have *: \"ccFromList [x\\<leftarrow>ys . x \\<notin> S] \\<sqsubseteq> G \\<and> ccProd ((insert x seen)) (set ys - seen_T) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  x \\<notin> S\n  ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G\n  ?x \\<notin> S \\<Longrightarrow> f ?x = TTree.empty\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> ccFromList ?ys \\<sqsubseteq> G\n  \\<lbrakk>?x \\<in> S; ?ys \\<in> paths (f ?x)\\<rbrakk>\n  \\<Longrightarrow> (ccNeighbors ?x G - {?x} \\<inter> T) G\\<times>\n                    set ?ys \\<sqsubseteq>\n                    G\n  seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G\n  seen \\<inter> S = {}\n  seen_T \\<subseteq> S\n  ?x \\<in> seen_T \\<Longrightarrow> f ?x = TTree.empty\n  zs \\<in> paths (f x)\n  xs' \\<in> xs \\<otimes> zs\n  substitute'' (f_nxt f T x) T xs' ys\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n    insert x seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> S;\n     ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     substitute'' (f_nxt f T x) T xs' ys\\<rbrakk>\n    \\<Longrightarrow> ccFromList\n                       (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq>\n                      G \\<and>\n                      insert x seen G\\<times>\n                      (set ys - seen_T) \\<sqsubseteq>\n                      G", "apply (rule Cons.IH[where seen = \"insert x seen\" and seen_T = seen_T])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>x \\<notin> S;\n     ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     substitute'' (f_nxt f T x) T xs' ys\\<rbrakk>\n    \\<Longrightarrow> ccFromList xs' G|` (- seen_T) \\<sqsubseteq> G\n 2. \\<And>xa.\n       \\<lbrakk>x \\<notin> S;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n        zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys; xa \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> f_nxt f T x xa = TTree.empty\n 3. \\<And>xa ysa.\n       \\<lbrakk>x \\<notin> S;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n        zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys; xa \\<in> S;\n        ysa \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n       \\<Longrightarrow> ccFromList ysa \\<sqsubseteq> G\n 4. \\<And>xa ysa.\n       \\<lbrakk>x \\<notin> S;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n        zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys; xa \\<in> S;\n        ysa \\<in> paths (f_nxt f T x xa)\\<rbrakk>\n       \\<Longrightarrow> (ccNeighbors xa G - {xa} \\<inter> T) G\\<times>\n                         set ysa \\<sqsubseteq>\n                         G\n 5. \\<lbrakk>x \\<notin> S;\n     ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     substitute'' (f_nxt f T x) T xs' ys\\<rbrakk>\n    \\<Longrightarrow> insert x seen G\\<times>\n                      (set xs' - seen_T) \\<sqsubseteq>\n                      G\n 6. \\<lbrakk>x \\<notin> S;\n     ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     substitute'' (f_nxt f T x) T xs' ys\\<rbrakk>\n    \\<Longrightarrow> insert x seen \\<inter> S = {}\n 7. \\<lbrakk>x \\<notin> S;\n     ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n     \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n     \\<And>x ys.\n        \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n        \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                          set ys \\<sqsubseteq>\n                          G;\n     seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n     seen \\<inter> S = {}; seen_T \\<subseteq> S;\n     \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n     zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n     substitute'' (f_nxt f T x) T xs' ys\\<rbrakk>\n    \\<Longrightarrow> seen_T \\<subseteq> S\n 8. \\<And>xa.\n       \\<lbrakk>x \\<notin> S;\n        ccFromList (x # xs) G|` (- seen_T) \\<sqsubseteq> G;\n        \\<And>x. x \\<notin> S \\<Longrightarrow> f x = TTree.empty;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> ccFromList ys \\<sqsubseteq> G;\n        \\<And>x ys.\n           \\<lbrakk>x \\<in> S; ys \\<in> paths (f x)\\<rbrakk>\n           \\<Longrightarrow> (ccNeighbors x G - {x} \\<inter> T) G\\<times>\n                             set ys \\<sqsubseteq>\n                             G;\n        seen G\\<times> (set (x # xs) - seen_T) \\<sqsubseteq> G;\n        seen \\<inter> S = {}; seen_T \\<subseteq> S;\n        \\<And>x. x \\<in> seen_T \\<Longrightarrow> f x = TTree.empty;\n        zs \\<in> paths (f x); xs' \\<in> xs \\<otimes> zs;\n        substitute'' (f_nxt f T x) T xs' ys; xa \\<in> seen_T\\<rbrakk>\n       \\<Longrightarrow> f_nxt f T x xa = TTree.empty", "apply (auto simp add: \\<open>x \\<notin> seen_T\\<close> Diff_eq ccApprox_both join_below_iff ttree_restr_both interleave_ccFromList insert_Diff_if\n                     simp add:  ccProd_insert2[where S' = \"set xs \\<inter> - seen_T\" for xs]\n                     simp add:  ccProd_insert1[where S' = \"seen\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  insert x seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  insert x seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "{"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  insert x seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "from False *"], ["proof (chain)\npicking this:\n  x \\<notin> S\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  insert x seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G", "have \"ccProd {x} (set ys - seen_T) \\<sqsubseteq>  G\""], ["proof (prove)\nusing this:\n  x \\<notin> S\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  insert x seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. {x} G\\<times> (set ys - seen_T) \\<sqsubseteq> G", "by (auto simp add: insert_Diff_if ccProd_insert1[where S' = \"seen\"] join_below_iff)"], ["proof (state)\nthis:\n  {x} G\\<times> (set ys - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "hence \"ccProd {x} {x \\<in> set ys - seen_T. x \\<notin> S} \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  {x} G\\<times> (set ys - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. {x} G\\<times> {x \\<in> set ys - seen_T. x \\<notin> S} \\<sqsubseteq> G", "by (rule below_trans[rotated, OF _ ccProd_mono2]) auto"], ["proof (state)\nthis:\n  {x} G\\<times> {x \\<in> set ys - seen_T. x \\<notin> S} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "also"], ["proof (state)\nthis:\n  {x} G\\<times> {x \\<in> set ys - seen_T. x \\<notin> S} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "have \"{x \\<in> set ys - seen_T. x \\<notin> S} =  {x \\<in> set ys. x \\<notin> S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> set ys - seen_T. x \\<notin> S} = {x \\<in> set ys. x \\<notin> S}", "using \\<open>seen_T \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  seen_T \\<subseteq> S\n\ngoal (1 subgoal):\n 1. {x \\<in> set ys - seen_T. x \\<notin> S} = {x \\<in> set ys. x \\<notin> S}", "by auto"], ["proof (state)\nthis:\n  {x \\<in> set ys - seen_T. x \\<notin> S} = {x \\<in> set ys. x \\<notin> S}\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "finally"], ["proof (chain)\npicking this:\n  {x} G\\<times> {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G", "have \"ccProd {x} {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  {x} G\\<times> {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. {x} G\\<times> {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G", "."], ["proof (state)\nthis:\n  {x} G\\<times> {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "}"], ["proof (state)\nthis:\n  {x} G\\<times> {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "moreover"], ["proof (state)\nthis:\n  {x} G\\<times> {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "note False seen_x"], ["proof (state)\nthis:\n  x \\<notin> S\n  seen G\\<times> {x} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow>\n    ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "ultimately"], ["proof (chain)\npicking this:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  insert x seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G\n  {x} G\\<times> {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G\n  x \\<notin> S\n  seen G\\<times> {x} \\<sqsubseteq> G", "show \"ccFromList [x\\<leftarrow>x # ys . x \\<notin> S] \\<sqsubseteq> G \\<and> ccProd (seen) (set (x # ys) - seen_T) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) ys) \\<sqsubseteq> G \\<and>\n  insert x seen G\\<times> (set ys - seen_T) \\<sqsubseteq> G\n  {x} G\\<times> {x \\<in> set ys. x \\<notin> S} \\<sqsubseteq> G\n  x \\<notin> S\n  seen G\\<times> {x} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n    G \\<and>\n    seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G", "by (auto simp add: join_below_iff  simp add: insert_Diff_if  ccProd_insert2[where S' = \"set ys - seen_T\" for xs]   ccProd_insert1[where S' = \"seen\"])"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n  G \\<and>\n  seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n  G \\<and>\n  seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) (x # ys)) \\<sqsubseteq>\n  G \\<and>\n  seen G\\<times> (set (x # ys) - seen_T) \\<sqsubseteq> G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) xs') \\<sqsubseteq> G \\<and>\n  seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths\n                 (ttree_restr (- S) (substitute f T t)) \\<Longrightarrow>\n       ccFromList xs \\<sqsubseteq> G", "with \\<open>xs = _\\<close>"], ["proof (chain)\npicking this:\n  xs = filter (\\<lambda>x. x \\<notin> S) xs'\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) xs') \\<sqsubseteq> G \\<and>\n  seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G", "show \"ccFromList xs \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  xs = filter (\\<lambda>x. x \\<notin> S) xs'\n  ccFromList (filter (\\<lambda>x. x \\<notin> S) xs') \\<sqsubseteq> G \\<and>\n  seen G\\<times> (set xs' - seen_T) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. ccFromList xs \\<sqsubseteq> G", "by simp"], ["proof (state)\nthis:\n  ccFromList xs \\<sqsubseteq> G\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive_set valid_lists :: \"var set \\<Rightarrow> CoCalls \\<Rightarrow> var list set\"\n  for S G\n  where  \"[] \\<in> valid_lists S G\"\n  | \"set xs \\<subseteq> ccNeighbors x G \\<Longrightarrow> xs \\<in> valid_lists S G \\<Longrightarrow> x \\<in> S \\<Longrightarrow> x#xs \\<in> valid_lists S G\""], ["", "inductive_simps valid_lists_simps[simp]: \"[] \\<in> valid_lists S G\" \"(x#xs) \\<in> valid_lists S G\""], ["", "inductive_cases vald_lists_ConsE: \"(x#xs) \\<in> valid_lists S G\""], ["", "lemma  valid_lists_downset_aux:\n  \"xs \\<in> valid_lists S CoCalls \\<Longrightarrow> butlast xs \\<in> valid_lists S CoCalls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists S CoCalls \\<Longrightarrow>\n    butlast xs \\<in> valid_lists S CoCalls", "by (induction xs) (auto dest: in_set_butlastD)"], ["", "lemma valid_lists_subset: \"xs \\<in> valid_lists S G \\<Longrightarrow> set xs \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists S G \\<Longrightarrow> set xs \\<subseteq> S", "by (induction rule: valid_lists.induct) auto"], ["", "lemma valid_lists_mono1:\n  assumes \"S \\<subseteq> S'\"\n  shows \"valid_lists S G \\<subseteq> valid_lists S' G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_lists S G \\<subseteq> valid_lists S' G", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> valid_lists S G \\<Longrightarrow> x \\<in> valid_lists S' G", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> valid_lists S G \\<Longrightarrow> x \\<in> valid_lists S' G", "assume \"xs \\<in> valid_lists S G\""], ["proof (state)\nthis:\n  xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> valid_lists S G \\<Longrightarrow> x \\<in> valid_lists S' G", "thus \"xs \\<in> valid_lists S' G\""], ["proof (prove)\nusing this:\n  xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists S' G", "by (induction rule: valid_lists.induct) (auto dest: subsetD[OF assms])"], ["proof (state)\nthis:\n  xs \\<in> valid_lists S' G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_lists_chain1:\n   assumes \"chain Y\" \n   assumes \"xs \\<in> valid_lists (\\<Union>(Y ` UNIV)) G\"\n   shows \"\\<exists> i. xs \\<in> valid_lists (Y i) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. xs \\<in> valid_lists (Y i) G", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i. xs \\<in> valid_lists (Y i) G", "note \\<open>chain Y\\<close>"], ["proof (state)\nthis:\n  chain Y\n\ngoal (1 subgoal):\n 1. \\<exists>i. xs \\<in> valid_lists (Y i) G", "moreover"], ["proof (state)\nthis:\n  chain Y\n\ngoal (1 subgoal):\n 1. \\<exists>i. xs \\<in> valid_lists (Y i) G", "from assms(2)"], ["proof (chain)\npicking this:\n  xs \\<in> valid_lists (\\<Union> (range Y)) G", "have \"set xs \\<subseteq> \\<Union>(Y ` UNIV)\""], ["proof (prove)\nusing this:\n  xs \\<in> valid_lists (\\<Union> (range Y)) G\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> \\<Union> (range Y)", "by (rule valid_lists_subset)"], ["proof (state)\nthis:\n  set xs \\<subseteq> \\<Union> (range Y)\n\ngoal (1 subgoal):\n 1. \\<exists>i. xs \\<in> valid_lists (Y i) G", "moreover"], ["proof (state)\nthis:\n  set xs \\<subseteq> \\<Union> (range Y)\n\ngoal (1 subgoal):\n 1. \\<exists>i. xs \\<in> valid_lists (Y i) G", "have \"finite (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set xs)", "by simp"], ["proof (state)\nthis:\n  finite (set xs)\n\ngoal (1 subgoal):\n 1. \\<exists>i. xs \\<in> valid_lists (Y i) G", "ultimately"], ["proof (chain)\npicking this:\n  chain Y\n  set xs \\<subseteq> \\<Union> (range Y)\n  finite (set xs)", "have \"\\<exists>i. set xs \\<subseteq> Y i\""], ["proof (prove)\nusing this:\n  chain Y\n  set xs \\<subseteq> \\<Union> (range Y)\n  finite (set xs)\n\ngoal (1 subgoal):\n 1. \\<exists>i. set xs \\<subseteq> Y i", "by (rule finite_subset_chain)"], ["proof (state)\nthis:\n  \\<exists>i. set xs \\<subseteq> Y i\n\ngoal (1 subgoal):\n 1. \\<exists>i. xs \\<in> valid_lists (Y i) G", "then"], ["proof (chain)\npicking this:\n  \\<exists>i. set xs \\<subseteq> Y i", "obtain i where \"set xs \\<subseteq> Y i\""], ["proof (prove)\nusing this:\n  \\<exists>i. set xs \\<subseteq> Y i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        set xs \\<subseteq> Y i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  set xs \\<subseteq> Y i\n\ngoal (1 subgoal):\n 1. \\<exists>i. xs \\<in> valid_lists (Y i) G", "from assms(2) this"], ["proof (chain)\npicking this:\n  xs \\<in> valid_lists (\\<Union> (range Y)) G\n  set xs \\<subseteq> Y i", "have \"xs \\<in> valid_lists (Y i) G\""], ["proof (prove)\nusing this:\n  xs \\<in> valid_lists (\\<Union> (range Y)) G\n  set xs \\<subseteq> Y i\n\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists (Y i) G", "by (induction rule:valid_lists.induct) auto"], ["proof (state)\nthis:\n  xs \\<in> valid_lists (Y i) G\n\ngoal (1 subgoal):\n 1. \\<exists>i. xs \\<in> valid_lists (Y i) G", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs \\<in> valid_lists (Y i) G\n\ngoal (1 subgoal):\n 1. \\<exists>i. xs \\<in> valid_lists (Y i) G", ".."], ["proof (state)\nthis:\n  \\<exists>i. xs \\<in> valid_lists (Y i) G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_lists_chain2:\n   assumes \"chain Y\" \n   assumes \"xs \\<in> valid_lists S (\\<Squnion>i. Y i)\"\n   shows \"\\<exists> i. xs \\<in> valid_lists S  (Y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. xs \\<in> valid_lists S (Y i)", "using assms(2)"], ["proof (prove)\nusing this:\n  xs \\<in> valid_lists S (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. \\<exists>i. xs \\<in> valid_lists S (Y i)", "proof(induction rule:valid_lists.induct[case_names Nil Cons])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i. [] \\<in> valid_lists S (Y i)\n 2. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>i. [] \\<in> valid_lists S (Y i)\n 2. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. [] \\<in> valid_lists S (Y i)", "by simp"], ["proof (state)\nthis:\n  \\<exists>i. [] \\<in> valid_lists S (Y i)\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "case (Cons xs x)"], ["proof (state)\nthis:\n  set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i)\n  xs \\<in> valid_lists S (\\<Squnion>i. Y i)\n  x \\<in> S\n  \\<exists>i. xs \\<in> valid_lists S (Y i)\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "from \\<open>chain Y\\<close>"], ["proof (chain)\npicking this:\n  chain Y", "have \"chain (\\<lambda> i. ccNeighbors x (Y i))\""], ["proof (prove)\nusing this:\n  chain Y\n\ngoal (1 subgoal):\n 1. chain (\\<lambda>i. ccNeighbors x (Y i))", "apply (rule ch2ch_monofun[OF monofunI, rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       xa \\<sqsubseteq> y \\<Longrightarrow>\n       ccNeighbors x xa \\<sqsubseteq> ccNeighbors x y", "unfolding below_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       xa \\<sqsubseteq> y \\<Longrightarrow>\n       ccNeighbors x xa \\<subseteq> ccNeighbors x y", "by (rule ccNeighbors_mono)"], ["proof (state)\nthis:\n  chain (\\<lambda>i. ccNeighbors x (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "moreover"], ["proof (state)\nthis:\n  chain (\\<lambda>i. ccNeighbors x (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "from \\<open>set xs \\<subseteq> ccNeighbors x (\\<Squnion> i. Y i)\\<close>"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i)", "have \"set xs \\<subseteq> (\\<Union> i. ccNeighbors x (Y i))\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> (\\<Union>i. ccNeighbors x (Y i))", "by (simp add:  lub_set)"], ["proof (state)\nthis:\n  set xs \\<subseteq> (\\<Union>i. ccNeighbors x (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "moreover"], ["proof (state)\nthis:\n  set xs \\<subseteq> (\\<Union>i. ccNeighbors x (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "have \"finite (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set xs)", "by simp"], ["proof (state)\nthis:\n  finite (set xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "ultimately"], ["proof (chain)\npicking this:\n  chain (\\<lambda>i. ccNeighbors x (Y i))\n  set xs \\<subseteq> (\\<Union>i. ccNeighbors x (Y i))\n  finite (set xs)", "have \"\\<exists>i. set xs \\<subseteq> ccNeighbors x (Y i)\""], ["proof (prove)\nusing this:\n  chain (\\<lambda>i. ccNeighbors x (Y i))\n  set xs \\<subseteq> (\\<Union>i. ccNeighbors x (Y i))\n  finite (set xs)\n\ngoal (1 subgoal):\n 1. \\<exists>i. set xs \\<subseteq> ccNeighbors x (Y i)", "by (rule finite_subset_chain)"], ["proof (state)\nthis:\n  \\<exists>i. set xs \\<subseteq> ccNeighbors x (Y i)\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i. set xs \\<subseteq> ccNeighbors x (Y i)", "obtain i where i: \"set xs \\<subseteq> ccNeighbors x (Y i)\""], ["proof (prove)\nusing this:\n  \\<exists>i. set xs \\<subseteq> ccNeighbors x (Y i)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        set xs \\<subseteq> ccNeighbors x (Y i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  set xs \\<subseteq> ccNeighbors x (Y i)\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "from Cons.IH"], ["proof (chain)\npicking this:\n  \\<exists>i. xs \\<in> valid_lists S (Y i)", "obtain j where j: \"xs \\<in> valid_lists S (Y j)\""], ["proof (prove)\nusing this:\n  \\<exists>i. xs \\<in> valid_lists S (Y i)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        xs \\<in> valid_lists S (Y j) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  xs \\<in> valid_lists S (Y j)\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "from i"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> ccNeighbors x (Y i)", "have \"set xs \\<subseteq> ccNeighbors x (Y (max i j))\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> ccNeighbors x (Y i)\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> ccNeighbors x (Y (max i j))", "by (rule order_trans[OF _ ccNeighbors_mono[OF chain_mono[OF \\<open>chain Y\\<close> max.cobounded1]]])"], ["proof (state)\nthis:\n  set xs \\<subseteq> ccNeighbors x (Y (max i j))\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "moreover"], ["proof (state)\nthis:\n  set xs \\<subseteq> ccNeighbors x (Y (max i j))\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "from j"], ["proof (chain)\npicking this:\n  xs \\<in> valid_lists S (Y j)", "have \"xs \\<in> valid_lists S (Y (max i j))\""], ["proof (prove)\nusing this:\n  xs \\<in> valid_lists S (Y j)\n\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists S (Y (max i j))", "by (induction rule: valid_lists.induct)\n       (auto del: subsetI elim: order_trans[OF _ ccNeighbors_mono[OF chain_mono[OF \\<open>chain Y\\<close> max.cobounded2]]])"], ["proof (state)\nthis:\n  xs \\<in> valid_lists S (Y (max i j))\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "moreover"], ["proof (state)\nthis:\n  xs \\<in> valid_lists S (Y (max i j))\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "note \\<open>x \\<in> S\\<close>"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "ultimately"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> ccNeighbors x (Y (max i j))\n  xs \\<in> valid_lists S (Y (max i j))\n  x \\<in> S", "have \"x # xs \\<in> valid_lists S (Y (max i j))\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> ccNeighbors x (Y (max i j))\n  xs \\<in> valid_lists S (Y (max i j))\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x # xs \\<in> valid_lists S (Y (max i j))", "by rule"], ["proof (state)\nthis:\n  x # xs \\<in> valid_lists S (Y (max i j))\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x (\\<Squnion>i. Y i);\n        xs \\<in> valid_lists S (\\<Squnion>i. Y i);\n        \\<exists>i. xs \\<in> valid_lists S (Y i); x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. x # xs \\<in> valid_lists S (Y i)", "thus ?case"], ["proof (prove)\nusing this:\n  x # xs \\<in> valid_lists S (Y (max i j))\n\ngoal (1 subgoal):\n 1. \\<exists>i. x # xs \\<in> valid_lists S (Y i)", ".."], ["proof (state)\nthis:\n  \\<exists>i. x # xs \\<in> valid_lists S (Y i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_lists_cc_restr: \"valid_lists S G = valid_lists S (cc_restr S G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_lists S G = valid_lists S (G G|` S)", "proof(rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> valid_lists S G) = (x \\<in> valid_lists S (G G|` S))", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> valid_lists S G) = (x \\<in> valid_lists S (G G|` S))", "show \"(xs \\<in> valid_lists S G) = (xs \\<in> valid_lists S (cc_restr S G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<in> valid_lists S G) = (xs \\<in> valid_lists S (G G|` S))", "by (induction xs) (auto dest: subsetD[OF valid_lists_subset])"], ["proof (state)\nthis:\n  (xs \\<in> valid_lists S G) = (xs \\<in> valid_lists S (G G|` S))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interleave_valid_list:\n  \"xs \\<in> ys \\<otimes> zs \\<Longrightarrow> ys \\<in> valid_lists S G \\<Longrightarrow> zs \\<in> valid_lists S' G' \\<Longrightarrow> xs \\<in> valid_lists (S \\<union> S') (G \\<squnion> (G' \\<squnion> ccProd S S'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<in> ys \\<otimes> zs; ys \\<in> valid_lists S G;\n     zs \\<in> valid_lists S' G'\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "proof (induction rule:interleave_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>[] \\<in> valid_lists S G; [] \\<in> valid_lists S' G'\\<rbrakk>\n    \\<Longrightarrow> [] \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 2. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        x # xs \\<in> valid_lists S G; ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 3. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> valid_lists S G\n  [] \\<in> valid_lists S' G'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>[] \\<in> valid_lists S G; [] \\<in> valid_lists S' G'\\<rbrakk>\n    \\<Longrightarrow> [] \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 2. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        x # xs \\<in> valid_lists S G; ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 3. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> valid_lists (S \\<union> S')\n              (G \\<squnion> (G' \\<squnion> S G\\<times> S'))", "by simp"], ["proof (state)\nthis:\n  [] \\<in> valid_lists (S \\<union> S')\n            (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n\ngoal (2 subgoals):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        x # xs \\<in> valid_lists S G; ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 2. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        x # xs \\<in> valid_lists S G; ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 2. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "case (left ys zs xs x)"], ["proof (state)\nthis:\n  xs \\<in> ys \\<otimes> zs\n  \\<lbrakk>ys \\<in> valid_lists S G; zs \\<in> valid_lists S' G'\\<rbrakk>\n  \\<Longrightarrow> xs \\<in> valid_lists (S \\<union> S')\n                              (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n  x # ys \\<in> valid_lists S G\n  zs \\<in> valid_lists S' G'\n\ngoal (2 subgoals):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        x # xs \\<in> valid_lists S G; ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 2. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "from \\<open>x # ys \\<in> valid_lists S G\\<close>"], ["proof (chain)\npicking this:\n  x # ys \\<in> valid_lists S G", "have \"x \\<in> S\" and \"set ys \\<subseteq> ccNeighbors x G\" and \"ys \\<in> valid_lists S G\""], ["proof (prove)\nusing this:\n  x # ys \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. x \\<in> S &&&\n    set ys \\<subseteq> ccNeighbors x G &&& ys \\<in> valid_lists S G", "by auto"], ["proof (state)\nthis:\n  x \\<in> S\n  set ys \\<subseteq> ccNeighbors x G\n  ys \\<in> valid_lists S G\n\ngoal (2 subgoals):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        x # xs \\<in> valid_lists S G; ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 2. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "from \\<open>xs \\<in> ys \\<otimes> zs\\<close>"], ["proof (chain)\npicking this:\n  xs \\<in> ys \\<otimes> zs", "have \"set xs = set ys \\<union> set zs\""], ["proof (prove)\nusing this:\n  xs \\<in> ys \\<otimes> zs\n\ngoal (1 subgoal):\n 1. set xs = set ys \\<union> set zs", "by (rule interleave_set)"], ["proof (state)\nthis:\n  set xs = set ys \\<union> set zs\n\ngoal (2 subgoals):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        x # xs \\<in> valid_lists S G; ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 2. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "with \\<open>set ys \\<subseteq> ccNeighbors x G\\<close> valid_lists_subset[OF \\<open>zs \\<in> valid_lists S' G'\\<close>]"], ["proof (chain)\npicking this:\n  set ys \\<subseteq> ccNeighbors x G\n  set zs \\<subseteq> S'\n  set xs = set ys \\<union> set zs", "have \"set xs \\<subseteq> ccNeighbors x (G \\<squnion> (G' \\<squnion> ccProd S S'))\""], ["proof (prove)\nusing this:\n  set ys \\<subseteq> ccNeighbors x G\n  set zs \\<subseteq> S'\n  set xs = set ys \\<union> set zs\n\ngoal (1 subgoal):\n 1. set xs\n    \\<subseteq> ccNeighbors x (G \\<squnion> (G' \\<squnion> S G\\<times> S'))", "by (auto simp add: ccNeighbors_ccProd \\<open>x \\<in> S\\<close>)"], ["proof (state)\nthis:\n  set xs\n  \\<subseteq> ccNeighbors x (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n\ngoal (2 subgoals):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        x # xs \\<in> valid_lists S G; ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 2. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "moreover"], ["proof (state)\nthis:\n  set xs\n  \\<subseteq> ccNeighbors x (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n\ngoal (2 subgoals):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        x # xs \\<in> valid_lists S G; ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 2. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "from \\<open>ys \\<in> valid_lists S G\\<close> \\<open>zs \\<in> valid_lists S' G'\\<close>"], ["proof (chain)\npicking this:\n  ys \\<in> valid_lists S G\n  zs \\<in> valid_lists S' G'", "have \"xs \\<in> valid_lists (S \\<union> S') (G \\<squnion> (G' \\<squnion> ccProd S S'))\""], ["proof (prove)\nusing this:\n  ys \\<in> valid_lists S G\n  zs \\<in> valid_lists S' G'\n\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists (S \\<union> S')\n              (G \\<squnion> (G' \\<squnion> S G\\<times> S'))", "by (rule left.IH)"], ["proof (state)\nthis:\n  xs \\<in> valid_lists (S \\<union> S')\n            (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n\ngoal (2 subgoals):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        x # xs \\<in> valid_lists S G; ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 2. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "moreover"], ["proof (state)\nthis:\n  xs \\<in> valid_lists (S \\<union> S')\n            (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n\ngoal (2 subgoals):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        x # xs \\<in> valid_lists S G; ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 2. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "from \\<open>x \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S", "have \"x \\<in> S \\<union> S'\""], ["proof (prove)\nusing this:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x \\<in> S \\<union> S'", "by simp"], ["proof (state)\nthis:\n  x \\<in> S \\<union> S'\n\ngoal (2 subgoals):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        x # xs \\<in> valid_lists S G; ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))\n 2. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "ultimately"], ["proof (chain)\npicking this:\n  set xs\n  \\<subseteq> ccNeighbors x (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n  xs \\<in> valid_lists (S \\<union> S')\n            (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n  x \\<in> S \\<union> S'", "show ?case"], ["proof (prove)\nusing this:\n  set xs\n  \\<subseteq> ccNeighbors x (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n  xs \\<in> valid_lists (S \\<union> S')\n            (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n  x \\<in> S \\<union> S'\n\ngoal (1 subgoal):\n 1. x # xs\n    \\<in> valid_lists (S \\<union> S')\n           (G \\<squnion> (G' \\<squnion> S G\\<times> S'))", ".."], ["proof (state)\nthis:\n  x # xs\n  \\<in> valid_lists (S \\<union> S')\n         (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n\ngoal (1 subgoal):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "case (right ys zs xs x)"], ["proof (state)\nthis:\n  xs \\<in> ys \\<otimes> zs\n  \\<lbrakk>ys \\<in> valid_lists S G; zs \\<in> valid_lists S' G'\\<rbrakk>\n  \\<Longrightarrow> xs \\<in> valid_lists (S \\<union> S')\n                              (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n  ys \\<in> valid_lists S G\n  x # zs \\<in> valid_lists S' G'\n\ngoal (1 subgoal):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "from \\<open>x # zs \\<in> valid_lists S' G'\\<close>"], ["proof (chain)\npicking this:\n  x # zs \\<in> valid_lists S' G'", "have \"x \\<in> S'\" and \"set zs \\<subseteq> ccNeighbors x G'\" and \"zs \\<in> valid_lists S' G'\""], ["proof (prove)\nusing this:\n  x # zs \\<in> valid_lists S' G'\n\ngoal (1 subgoal):\n 1. x \\<in> S' &&&\n    set zs \\<subseteq> ccNeighbors x G' &&& zs \\<in> valid_lists S' G'", "by auto"], ["proof (state)\nthis:\n  x \\<in> S'\n  set zs \\<subseteq> ccNeighbors x G'\n  zs \\<in> valid_lists S' G'\n\ngoal (1 subgoal):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "from \\<open>xs \\<in> ys \\<otimes> zs\\<close>"], ["proof (chain)\npicking this:\n  xs \\<in> ys \\<otimes> zs", "have \"set xs = set ys \\<union> set zs\""], ["proof (prove)\nusing this:\n  xs \\<in> ys \\<otimes> zs\n\ngoal (1 subgoal):\n 1. set xs = set ys \\<union> set zs", "by (rule interleave_set)"], ["proof (state)\nthis:\n  set xs = set ys \\<union> set zs\n\ngoal (1 subgoal):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "with \\<open>set zs \\<subseteq> ccNeighbors x G'\\<close> valid_lists_subset[OF \\<open>ys \\<in> valid_lists S G\\<close>]"], ["proof (chain)\npicking this:\n  set zs \\<subseteq> ccNeighbors x G'\n  set ys \\<subseteq> S\n  set xs = set ys \\<union> set zs", "have \"set xs \\<subseteq> ccNeighbors x (G \\<squnion> (G' \\<squnion> ccProd S S'))\""], ["proof (prove)\nusing this:\n  set zs \\<subseteq> ccNeighbors x G'\n  set ys \\<subseteq> S\n  set xs = set ys \\<union> set zs\n\ngoal (1 subgoal):\n 1. set xs\n    \\<subseteq> ccNeighbors x (G \\<squnion> (G' \\<squnion> S G\\<times> S'))", "by (auto simp add: ccNeighbors_ccProd \\<open>x \\<in> S'\\<close>)"], ["proof (state)\nthis:\n  set xs\n  \\<subseteq> ccNeighbors x (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n\ngoal (1 subgoal):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "moreover"], ["proof (state)\nthis:\n  set xs\n  \\<subseteq> ccNeighbors x (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n\ngoal (1 subgoal):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "from \\<open>ys \\<in> valid_lists S G\\<close> \\<open>zs \\<in> valid_lists S' G'\\<close>"], ["proof (chain)\npicking this:\n  ys \\<in> valid_lists S G\n  zs \\<in> valid_lists S' G'", "have \"xs \\<in> valid_lists (S \\<union> S') (G \\<squnion> (G' \\<squnion> ccProd S S'))\""], ["proof (prove)\nusing this:\n  ys \\<in> valid_lists S G\n  zs \\<in> valid_lists S' G'\n\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists (S \\<union> S')\n              (G \\<squnion> (G' \\<squnion> S G\\<times> S'))", "by (rule right.IH)"], ["proof (state)\nthis:\n  xs \\<in> valid_lists (S \\<union> S')\n            (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n\ngoal (1 subgoal):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "moreover"], ["proof (state)\nthis:\n  xs \\<in> valid_lists (S \\<union> S')\n            (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n\ngoal (1 subgoal):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "from \\<open>x \\<in> S'\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S'", "have \"x \\<in> S \\<union> S'\""], ["proof (prove)\nusing this:\n  x \\<in> S'\n\ngoal (1 subgoal):\n 1. x \\<in> S \\<union> S'", "by simp"], ["proof (state)\nthis:\n  x \\<in> S \\<union> S'\n\ngoal (1 subgoal):\n 1. \\<And>xs ys zs x.\n       \\<lbrakk>zs \\<in> xs \\<otimes> ys;\n        \\<lbrakk>xs \\<in> valid_lists S G;\n         ys \\<in> valid_lists S' G'\\<rbrakk>\n        \\<Longrightarrow> zs \\<in> valid_lists (S \\<union> S')\n                                    (G \\<squnion>\n                                     (G' \\<squnion> S G\\<times> S'));\n        xs \\<in> valid_lists S G; x # ys \\<in> valid_lists S' G'\\<rbrakk>\n       \\<Longrightarrow> x # zs\n                         \\<in> valid_lists (S \\<union> S')\n                                (G \\<squnion>\n                                 (G' \\<squnion> S G\\<times> S'))", "ultimately"], ["proof (chain)\npicking this:\n  set xs\n  \\<subseteq> ccNeighbors x (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n  xs \\<in> valid_lists (S \\<union> S')\n            (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n  x \\<in> S \\<union> S'", "show ?case"], ["proof (prove)\nusing this:\n  set xs\n  \\<subseteq> ccNeighbors x (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n  xs \\<in> valid_lists (S \\<union> S')\n            (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n  x \\<in> S \\<union> S'\n\ngoal (1 subgoal):\n 1. x # xs\n    \\<in> valid_lists (S \\<union> S')\n           (G \\<squnion> (G' \\<squnion> S G\\<times> S'))", ".."], ["proof (state)\nthis:\n  x # xs\n  \\<in> valid_lists (S \\<union> S')\n         (G \\<squnion> (G' \\<squnion> S G\\<times> S'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interleave_valid_list':\n  \"xs \\<in> valid_lists (S \\<union> S') G \\<Longrightarrow> \\<exists> ys zs. xs \\<in> ys \\<otimes> zs \\<and> ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists (S \\<union> S') G \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "proof(induction rule: valid_lists.induct[case_names Nil Cons])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>ys zs.\n       [] \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\n 2. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists (S \\<union> S') G;\n        \\<exists>ys zs.\n           xs \\<in> ys \\<otimes> zs \\<and>\n           ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G;\n        x \\<in> S \\<union> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            x # xs \\<in> ys \\<otimes> zs \\<and>\n                            ys \\<in> valid_lists S G \\<and>\n                            zs \\<in> valid_lists S' G", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>ys zs.\n       [] \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\n 2. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists (S \\<union> S') G;\n        \\<exists>ys zs.\n           xs \\<in> ys \\<otimes> zs \\<and>\n           ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G;\n        x \\<in> S \\<union> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            x # xs \\<in> ys \\<otimes> zs \\<and>\n                            ys \\<in> valid_lists S G \\<and>\n                            zs \\<in> valid_lists S' G", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       [] \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "by simp"], ["proof (state)\nthis:\n  \\<exists>ys zs.\n     [] \\<in> ys \\<otimes> zs \\<and>\n     ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists (S \\<union> S') G;\n        \\<exists>ys zs.\n           xs \\<in> ys \\<otimes> zs \\<and>\n           ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G;\n        x \\<in> S \\<union> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            x # xs \\<in> ys \\<otimes> zs \\<and>\n                            ys \\<in> valid_lists S G \\<and>\n                            zs \\<in> valid_lists S' G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists (S \\<union> S') G;\n        \\<exists>ys zs.\n           xs \\<in> ys \\<otimes> zs \\<and>\n           ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G;\n        x \\<in> S \\<union> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            x # xs \\<in> ys \\<otimes> zs \\<and>\n                            ys \\<in> valid_lists S G \\<and>\n                            zs \\<in> valid_lists S' G", "case (Cons xs x)"], ["proof (state)\nthis:\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists (S \\<union> S') G\n  x \\<in> S \\<union> S'\n  \\<exists>ys zs.\n     xs \\<in> ys \\<otimes> zs \\<and>\n     ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists (S \\<union> S') G;\n        \\<exists>ys zs.\n           xs \\<in> ys \\<otimes> zs \\<and>\n           ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G;\n        x \\<in> S \\<union> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            x # xs \\<in> ys \\<otimes> zs \\<and>\n                            ys \\<in> valid_lists S G \\<and>\n                            zs \\<in> valid_lists S' G", "then"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists (S \\<union> S') G\n  x \\<in> S \\<union> S'\n  \\<exists>ys zs.\n     xs \\<in> ys \\<otimes> zs \\<and>\n     ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "obtain ys zs where \"xs \\<in> ys \\<otimes> zs\" \"ys \\<in> valid_lists S G\" \"zs \\<in> valid_lists S' G\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists (S \\<union> S') G\n  x \\<in> S \\<union> S'\n  \\<exists>ys zs.\n     xs \\<in> ys \\<otimes> zs \\<and>\n     ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs \\<in> ys \\<otimes> zs; ys \\<in> valid_lists S G;\n         zs \\<in> valid_lists S' G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs \\<in> ys \\<otimes> zs\n  ys \\<in> valid_lists S G\n  zs \\<in> valid_lists S' G\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists (S \\<union> S') G;\n        \\<exists>ys zs.\n           xs \\<in> ys \\<otimes> zs \\<and>\n           ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G;\n        x \\<in> S \\<union> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            x # xs \\<in> ys \\<otimes> zs \\<and>\n                            ys \\<in> valid_lists S G \\<and>\n                            zs \\<in> valid_lists S' G", "from \\<open>xs \\<in> ys \\<otimes> zs\\<close>"], ["proof (chain)\npicking this:\n  xs \\<in> ys \\<otimes> zs", "have \"set xs = set ys \\<union> set zs\""], ["proof (prove)\nusing this:\n  xs \\<in> ys \\<otimes> zs\n\ngoal (1 subgoal):\n 1. set xs = set ys \\<union> set zs", "by (rule interleave_set)"], ["proof (state)\nthis:\n  set xs = set ys \\<union> set zs\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists (S \\<union> S') G;\n        \\<exists>ys zs.\n           xs \\<in> ys \\<otimes> zs \\<and>\n           ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G;\n        x \\<in> S \\<union> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            x # xs \\<in> ys \\<otimes> zs \\<and>\n                            ys \\<in> valid_lists S G \\<and>\n                            zs \\<in> valid_lists S' G", "with \\<open>set xs \\<subseteq> ccNeighbors x G\\<close>"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> ccNeighbors x G\n  set xs = set ys \\<union> set zs", "have \"set ys \\<subseteq> ccNeighbors x G\" and \"set zs \\<subseteq> ccNeighbors x G\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> ccNeighbors x G\n  set xs = set ys \\<union> set zs\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> ccNeighbors x G &&&\n    set zs \\<subseteq> ccNeighbors x G", "by auto"], ["proof (state)\nthis:\n  set ys \\<subseteq> ccNeighbors x G\n  set zs \\<subseteq> ccNeighbors x G\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists (S \\<union> S') G;\n        \\<exists>ys zs.\n           xs \\<in> ys \\<otimes> zs \\<and>\n           ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G;\n        x \\<in> S \\<union> S'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            x # xs \\<in> ys \\<otimes> zs \\<and>\n                            ys \\<in> valid_lists S G \\<and>\n                            zs \\<in> valid_lists S' G", "from \\<open>x \\<in> S \\<union> S'\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S \\<union> S'", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> S \\<union> S'\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\n 2. x \\<in> S' \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "assume \"x \\<in> S\""], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\n 2. x \\<in> S' \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "with \\<open>set ys \\<subseteq> ccNeighbors x G\\<close> \\<open>ys \\<in> valid_lists S G\\<close>"], ["proof (chain)\npicking this:\n  set ys \\<subseteq> ccNeighbors x G\n  ys \\<in> valid_lists S G\n  x \\<in> S", "have \"x # ys \\<in> valid_lists S G\""], ["proof (prove)\nusing this:\n  set ys \\<subseteq> ccNeighbors x G\n  ys \\<in> valid_lists S G\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x # ys \\<in> valid_lists S G", "by rule"], ["proof (state)\nthis:\n  x # ys \\<in> valid_lists S G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\n 2. x \\<in> S' \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "moreover"], ["proof (state)\nthis:\n  x # ys \\<in> valid_lists S G\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\n 2. x \\<in> S' \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "from \\<open>xs \\<in> ys \\<otimes> zs\\<close>"], ["proof (chain)\npicking this:\n  xs \\<in> ys \\<otimes> zs", "have \"x#xs \\<in> x#ys \\<otimes> zs\""], ["proof (prove)\nusing this:\n  xs \\<in> ys \\<otimes> zs\n\ngoal (1 subgoal):\n 1. x # xs \\<in> x # ys \\<otimes> zs", ".."], ["proof (state)\nthis:\n  x # xs \\<in> x # ys \\<otimes> zs\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\n 2. x \\<in> S' \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "ultimately"], ["proof (chain)\npicking this:\n  x # ys \\<in> valid_lists S G\n  x # xs \\<in> x # ys \\<otimes> zs", "show ?thesis"], ["proof (prove)\nusing this:\n  x # ys \\<in> valid_lists S G\n  x # xs \\<in> x # ys \\<otimes> zs\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "using \\<open>zs \\<in> valid_lists S' G\\<close>"], ["proof (prove)\nusing this:\n  x # ys \\<in> valid_lists S G\n  x # xs \\<in> x # ys \\<otimes> zs\n  zs \\<in> valid_lists S' G\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys zs.\n     x # xs \\<in> ys \\<otimes> zs \\<and>\n     ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\n\ngoal (1 subgoal):\n 1. x \\<in> S' \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> S' \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "assume \"x \\<in> S'\""], ["proof (state)\nthis:\n  x \\<in> S'\n\ngoal (1 subgoal):\n 1. x \\<in> S' \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "with \\<open>set zs \\<subseteq> ccNeighbors x G\\<close> \\<open>zs \\<in> valid_lists S' G\\<close>"], ["proof (chain)\npicking this:\n  set zs \\<subseteq> ccNeighbors x G\n  zs \\<in> valid_lists S' G\n  x \\<in> S'", "have \"x # zs \\<in> valid_lists S' G\""], ["proof (prove)\nusing this:\n  set zs \\<subseteq> ccNeighbors x G\n  zs \\<in> valid_lists S' G\n  x \\<in> S'\n\ngoal (1 subgoal):\n 1. x # zs \\<in> valid_lists S' G", "by rule"], ["proof (state)\nthis:\n  x # zs \\<in> valid_lists S' G\n\ngoal (1 subgoal):\n 1. x \\<in> S' \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "moreover"], ["proof (state)\nthis:\n  x # zs \\<in> valid_lists S' G\n\ngoal (1 subgoal):\n 1. x \\<in> S' \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "from \\<open>xs \\<in> ys \\<otimes> zs\\<close>"], ["proof (chain)\npicking this:\n  xs \\<in> ys \\<otimes> zs", "have \"x#xs \\<in> ys \\<otimes> x#zs\""], ["proof (prove)\nusing this:\n  xs \\<in> ys \\<otimes> zs\n\ngoal (1 subgoal):\n 1. x # xs \\<in> ys \\<otimes> x # zs", ".."], ["proof (state)\nthis:\n  x # xs \\<in> ys \\<otimes> x # zs\n\ngoal (1 subgoal):\n 1. x \\<in> S' \\<Longrightarrow>\n    \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "ultimately"], ["proof (chain)\npicking this:\n  x # zs \\<in> valid_lists S' G\n  x # xs \\<in> ys \\<otimes> x # zs", "show ?thesis"], ["proof (prove)\nusing this:\n  x # zs \\<in> valid_lists S' G\n  x # xs \\<in> ys \\<otimes> x # zs\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "using \\<open>ys \\<in> valid_lists S G\\<close>"], ["proof (prove)\nusing this:\n  x # zs \\<in> valid_lists S' G\n  x # xs \\<in> ys \\<otimes> x # zs\n  ys \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       x # xs \\<in> ys \\<otimes> zs \\<and>\n       ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys zs.\n     x # xs \\<in> ys \\<otimes> zs \\<and>\n     ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ys zs.\n     x # xs \\<in> ys \\<otimes> zs \\<and>\n     ys \\<in> valid_lists S G \\<and> zs \\<in> valid_lists S' G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma many_calls_valid_list:\n  \"xs \\<in> valid_lists {x} (ccProd {x} {x}) \\<Longrightarrow> xs \\<in> range (\\<lambda>n. replicate n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists {x} ({x} G\\<times> {x}) \\<Longrightarrow>\n    xs \\<in> range (\\<lambda>n. replicate n x)", "by (induction rule: valid_lists.induct) (auto, metis UNIV_I image_iff replicate_Suc)"], ["", "lemma filter_valid_lists:\n  \"xs \\<in> valid_lists S G \\<Longrightarrow> filter P xs \\<in> valid_lists {a \\<in> S. P a} G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists S G \\<Longrightarrow>\n    filter P xs \\<in> valid_lists {a \\<in> S. P a} G", "by (induction rule:valid_lists.induct) auto"], ["", "lift_definition ccTTree :: \"var set \\<Rightarrow> CoCalls \\<Rightarrow> var ttree\" is \"\\<lambda> S G. valid_lists S G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set CoCalls.\n       [] \\<in> valid_lists set CoCalls \\<and>\n       downset (valid_lists set CoCalls)", "by (auto intro: valid_lists_downset_aux)"], ["", "lemma paths_ccTTree[simp]: \"paths (ccTTree S G) = valid_lists S G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. paths (ccTTree S G) = valid_lists S G", "by transfer auto"], ["", "lemma carrier_ccTTree[simp]: \"carrier (ccTTree S G) = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier (ccTTree S G) = S", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S G. \\<Union> (set ` valid_lists S G) = S", "apply (auto dest: valid_lists_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S G x.\n       x \\<in> S \\<Longrightarrow>\n       \\<exists>xa\\<in>valid_lists S G. x \\<in> set xa", "apply (rule_tac x = \"[x]\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S G x. x \\<in> S \\<Longrightarrow> x \\<in> set [x]\n 2. \\<And>S G x. x \\<in> S \\<Longrightarrow> [x] \\<in> valid_lists S G", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_lists_ccFromList:\n  \"xs \\<in> valid_lists S G \\<Longrightarrow> ccFromList xs \\<sqsubseteq> cc_restr S G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists S G \\<Longrightarrow>\n    ccFromList xs \\<sqsubseteq> G G|` S", "by (induction rule:valid_lists.induct)\n   (auto simp add: join_below_iff subset_ccNeighbors ccProd_below_cc_restr elim: subsetD[OF valid_lists_subset])"], ["", "lemma ccApprox_ccTTree[simp]: \"ccApprox (ccTTree S G) = cc_restr S G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccApprox (ccTTree S G) = G G|` S", "proof (transfer' fixing: S G, rule below_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. lub (ccFromList ` valid_lists S G) \\<sqsubseteq> G G|` S\n 2. G G|` S \\<sqsubseteq> lub (ccFromList ` valid_lists S G)", "show \"lub (ccFromList ` valid_lists S G) \\<sqsubseteq> cc_restr S G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lub (ccFromList ` valid_lists S G) \\<sqsubseteq> G G|` S", "apply (rule is_lub_thelub_ex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>u. ccFromList ` valid_lists S G <<| u\n 2. ccFromList ` valid_lists S G <| G G|` S", "apply (metis coCallsLub_is_lub)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccFromList ` valid_lists S G <| G G|` S", "apply (rule is_ubI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ccFromList ` valid_lists S G \\<Longrightarrow>\n       x \\<sqsubseteq> G G|` S", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> valid_lists S G \\<Longrightarrow>\n       ccFromList xa \\<sqsubseteq> G G|` S", "apply (erule valid_lists_ccFromList)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lub (ccFromList ` valid_lists S G) \\<sqsubseteq> G G|` S\n\ngoal (1 subgoal):\n 1. G G|` S \\<sqsubseteq> lub (ccFromList ` valid_lists S G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. G G|` S \\<sqsubseteq> lub (ccFromList ` valid_lists S G)", "show \"cc_restr S G \\<sqsubseteq> lub (ccFromList ` valid_lists S G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G G|` S \\<sqsubseteq> lub (ccFromList ` valid_lists S G)", "proof (rule below_CoCallsI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x--y\\<in>(G G|` S) \\<Longrightarrow>\n       x--y\\<in>lub (ccFromList ` valid_lists S G)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x--y\\<in>(G G|` S) \\<Longrightarrow>\n       x--y\\<in>lub (ccFromList ` valid_lists S G)", "have \"x--y\\<in>(ccFromList [y,x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x--y\\<in>ccFromList [y, x]", "by simp"], ["proof (state)\nthis:\n  x--y\\<in>ccFromList [y, x]\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x--y\\<in>(G G|` S) \\<Longrightarrow>\n       x--y\\<in>lub (ccFromList ` valid_lists S G)", "moreover"], ["proof (state)\nthis:\n  x--y\\<in>ccFromList [y, x]\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x--y\\<in>(G G|` S) \\<Longrightarrow>\n       x--y\\<in>lub (ccFromList ` valid_lists S G)", "assume \"x--y\\<in>(cc_restr S G)\""], ["proof (state)\nthis:\n  x--y\\<in>(G G|` S)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x--y\\<in>(G G|` S) \\<Longrightarrow>\n       x--y\\<in>lub (ccFromList ` valid_lists S G)", "hence \"[y,x] \\<in> valid_lists S G\""], ["proof (prove)\nusing this:\n  x--y\\<in>(G G|` S)\n\ngoal (1 subgoal):\n 1. [y, x] \\<in> valid_lists S G", "by (auto simp add: elem_ccNeighbors)"], ["proof (state)\nthis:\n  [y, x] \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x--y\\<in>(G G|` S) \\<Longrightarrow>\n       x--y\\<in>lub (ccFromList ` valid_lists S G)", "ultimately"], ["proof (chain)\npicking this:\n  x--y\\<in>ccFromList [y, x]\n  [y, x] \\<in> valid_lists S G", "show \"x--y\\<in>(lub (ccFromList ` valid_lists S G))\""], ["proof (prove)\nusing this:\n  x--y\\<in>ccFromList [y, x]\n  [y, x] \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. x--y\\<in>lub (ccFromList ` valid_lists S G)", "by (rule in_CoCallsLubI[OF _ imageI])"], ["proof (state)\nthis:\n  x--y\\<in>lub (ccFromList ` valid_lists S G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G G|` S \\<sqsubseteq> lub (ccFromList ` valid_lists S G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma below_ccTTreeI:\n  assumes \"carrier t \\<subseteq> S\" and \"ccApprox t \\<sqsubseteq> G\"\n  shows \"t \\<sqsubseteq> ccTTree S G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> ccTTree S G", "unfolding paths_mono_iff[symmetric] below_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. paths t \\<subseteq> paths (ccTTree S G)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> paths t \\<Longrightarrow> x \\<in> paths (ccTTree S G)", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> paths t \\<Longrightarrow> x \\<in> paths (ccTTree S G)", "assume \"xs \\<in> paths t\""], ["proof (state)\nthis:\n  xs \\<in> paths t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> paths t \\<Longrightarrow> x \\<in> paths (ccTTree S G)", "with assms"], ["proof (chain)\npicking this:\n  carrier t \\<subseteq> S\n  ccApprox t \\<sqsubseteq> G\n  xs \\<in> paths t", "have \"xs \\<in> valid_lists S G\""], ["proof (prove)\nusing this:\n  carrier t \\<subseteq> S\n  ccApprox t \\<sqsubseteq> G\n  xs \\<in> paths t\n\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists S G", "proof(induction xs arbitrary : t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        [] \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> [] \\<in> valid_lists S G\n 2. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "case Nil"], ["proof (state)\nthis:\n  carrier t \\<subseteq> S\n  ccApprox t \\<sqsubseteq> G\n  [] \\<in> paths t\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        [] \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> [] \\<in> valid_lists S G\n 2. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "thus ?case"], ["proof (prove)\nusing this:\n  carrier t \\<subseteq> S\n  ccApprox t \\<sqsubseteq> G\n  [] \\<in> paths t\n\ngoal (1 subgoal):\n 1. [] \\<in> valid_lists S G", "by simp"], ["proof (state)\nthis:\n  [] \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>carrier ?t \\<subseteq> S; ccApprox ?t \\<sqsubseteq> G;\n   xs \\<in> paths ?t\\<rbrakk>\n  \\<Longrightarrow> xs \\<in> valid_lists S G\n  carrier t \\<subseteq> S\n  ccApprox t \\<sqsubseteq> G\n  x # xs \\<in> paths t\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "from \\<open>x # xs \\<in> paths t\\<close>"], ["proof (chain)\npicking this:\n  x # xs \\<in> paths t", "have \"possible t x\" and \"xs \\<in> paths (nxt t x)\""], ["proof (prove)\nusing this:\n  x # xs \\<in> paths t\n\ngoal (1 subgoal):\n 1. possible t x &&& xs \\<in> paths (nxt t x)", "by (auto simp add: Cons_path)"], ["proof (state)\nthis:\n  possible t x\n  xs \\<in> paths (nxt t x)\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "have \"ccProd {x} (set xs) \\<sqsubseteq> ccFromList (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} G\\<times> set xs \\<sqsubseteq> ccFromList (x # xs)", "by simp"], ["proof (state)\nthis:\n  {x} G\\<times> set xs \\<sqsubseteq> ccFromList (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "also"], ["proof (state)\nthis:\n  {x} G\\<times> set xs \\<sqsubseteq> ccFromList (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "from \\<open>x # xs \\<in> paths t\\<close>"], ["proof (chain)\npicking this:\n  x # xs \\<in> paths t", "have \"\\<dots> \\<sqsubseteq> ccApprox t\""], ["proof (prove)\nusing this:\n  x # xs \\<in> paths t\n\ngoal (1 subgoal):\n 1. ccFromList (x # xs) \\<sqsubseteq> ccApprox t", "by (rule ccFromList_below_ccApprox)"], ["proof (state)\nthis:\n  ccFromList (x # xs) \\<sqsubseteq> ccApprox t\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "also"], ["proof (state)\nthis:\n  ccFromList (x # xs) \\<sqsubseteq> ccApprox t\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "note \\<open>ccApprox t \\<sqsubseteq> G\\<close>"], ["proof (state)\nthis:\n  ccApprox t \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>cont (\\<lambda>a. a); cont (\\<lambda>a. a)\\<rbrakk>\n  \\<Longrightarrow> {x} G\\<times> set xs \\<sqsubseteq> G", "have \"ccProd {x} (set xs) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  \\<lbrakk>cont (\\<lambda>a. a); cont (\\<lambda>a. a)\\<rbrakk>\n  \\<Longrightarrow> {x} G\\<times> set xs \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. {x} G\\<times> set xs \\<sqsubseteq> G", "by this simp_all"], ["proof (state)\nthis:\n  {x} G\\<times> set xs \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "hence \"set xs \\<subseteq> ccNeighbors x G\""], ["proof (prove)\nusing this:\n  {x} G\\<times> set xs \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> ccNeighbors x G", "unfolding subset_ccNeighbors"], ["proof (prove)\nusing this:\n  {x} G\\<times> set xs \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. {x} G\\<times> set xs \\<sqsubseteq> G", "."], ["proof (state)\nthis:\n  set xs \\<subseteq> ccNeighbors x G\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "moreover"], ["proof (state)\nthis:\n  set xs \\<subseteq> ccNeighbors x G\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "have \"xs \\<in> valid_lists S G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists S G", "proof(rule Cons.IH)"], ["proof (state)\ngoal (3 subgoals):\n 1. carrier ?t \\<subseteq> S\n 2. ccApprox ?t \\<sqsubseteq> G\n 3. xs \\<in> paths ?t", "show \"xs \\<in> paths (nxt t x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> paths (nxt t x)", "by fact"], ["proof (state)\nthis:\n  xs \\<in> paths (nxt t x)\n\ngoal (2 subgoals):\n 1. carrier (nxt t x) \\<subseteq> S\n 2. ccApprox (nxt t x) \\<sqsubseteq> G", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. carrier (nxt t x) \\<subseteq> S\n 2. ccApprox (nxt t x) \\<sqsubseteq> G", "from \\<open>carrier t \\<subseteq> S\\<close>"], ["proof (chain)\npicking this:\n  carrier t \\<subseteq> S", "show \"carrier (nxt t x) \\<subseteq> S\""], ["proof (prove)\nusing this:\n  carrier t \\<subseteq> S\n\ngoal (1 subgoal):\n 1. carrier (nxt t x) \\<subseteq> S", "by (rule order_trans[OF carrier_nxt_subset])"], ["proof (state)\nthis:\n  carrier (nxt t x) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. ccApprox (nxt t x) \\<sqsubseteq> G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ccApprox (nxt t x) \\<sqsubseteq> G", "from \\<open>ccApprox t \\<sqsubseteq> G\\<close>"], ["proof (chain)\npicking this:\n  ccApprox t \\<sqsubseteq> G", "show \"ccApprox (nxt t x) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  ccApprox t \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. ccApprox (nxt t x) \\<sqsubseteq> G", "by (rule below_trans[OF ccApprox_nxt_below])"], ["proof (state)\nthis:\n  ccApprox (nxt t x) \\<sqsubseteq> G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "moreover"], ["proof (state)\nthis:\n  xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "from  \\<open>carrier t \\<subseteq> S\\<close> and \\<open>possible t x\\<close>"], ["proof (chain)\npicking this:\n  carrier t \\<subseteq> S\n  possible t x", "have \"x \\<in> S\""], ["proof (prove)\nusing this:\n  carrier t \\<subseteq> S\n  possible t x\n\ngoal (1 subgoal):\n 1. x \\<in> S", "by (rule carrier_possible_subset)"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>carrier t \\<subseteq> S;\n                    ccApprox t \\<sqsubseteq> G; xs \\<in> paths t\\<rbrakk>\n                   \\<Longrightarrow> xs \\<in> valid_lists S G;\n        carrier t \\<subseteq> S; ccApprox t \\<sqsubseteq> G;\n        a # xs \\<in> paths t\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "ultimately"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists S G\n  x \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists S G\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x # xs \\<in> valid_lists S G", ".."], ["proof (state)\nthis:\n  x # xs \\<in> valid_lists S G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> paths t \\<Longrightarrow> x \\<in> paths (ccTTree S G)", "thus \"xs \\<in> paths (ccTTree S G)\""], ["proof (prove)\nusing this:\n  xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. xs \\<in> paths (ccTTree S G)", "by (metis paths_ccTTree)"], ["proof (state)\nthis:\n  xs \\<in> paths (ccTTree S G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccTTree_mono1:\n  \"S \\<subseteq> S' \\<Longrightarrow> ccTTree S G \\<sqsubseteq> ccTTree S' G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> S' \\<Longrightarrow>\n    ccTTree S G \\<sqsubseteq> ccTTree S' G", "by (rule below_ccTTreeI) (auto simp add:  cc_restr_below_arg)"], ["", "lemma cont_ccTTree1:\n  \"cont (\\<lambda> S. ccTTree S G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>S. ccTTree S G)", "apply (rule contI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. monofun (\\<lambda>S. ccTTree S G)\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. ccTTree (Y i) G)\\<rbrakk>\n       \\<Longrightarrow> ccTTree (\\<Squnion>i. Y i) G \\<sqsubseteq>\n                         (\\<Squnion>i. ccTTree (Y i) G)", "apply (rule monofunI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       ccTTree x G \\<sqsubseteq> ccTTree y G\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. ccTTree (Y i) G)\\<rbrakk>\n       \\<Longrightarrow> ccTTree (\\<Squnion>i. Y i) G \\<sqsubseteq>\n                         (\\<Squnion>i. ccTTree (Y i) G)", "apply (erule ccTTree_mono1[folded below_set_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. ccTTree (Y i) G)\\<rbrakk>\n       \\<Longrightarrow> ccTTree (\\<Squnion>i. Y i) G \\<sqsubseteq>\n                         (\\<Squnion>i. ccTTree (Y i) G)", "apply (rule ttree_belowI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y xs.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. ccTTree (Y i) G);\n        xs \\<in> paths (ccTTree (\\<Squnion>i. Y i) G)\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> paths (\\<Squnion>i. ccTTree (Y i) G)", "apply (simp add: paths_Either lub_set lub_is_either)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y xs.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. ccTTree (Y i) G);\n        xs \\<in> valid_lists (\\<Union> (range Y)) G\\<rbrakk>\n       \\<Longrightarrow> xs = [] \\<or>\n                         (\\<exists>x. xs \\<in> valid_lists (Y x) G)", "apply (drule (1) valid_lists_chain1[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y xs.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. ccTTree (Y i) G);\n        \\<exists>i. xs \\<in> valid_lists (Y i) G\\<rbrakk>\n       \\<Longrightarrow> xs = [] \\<or>\n                         (\\<exists>x. xs \\<in> valid_lists (Y x) G)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ccTTree_mono2:\n  \"G \\<sqsubseteq> G' \\<Longrightarrow> ccTTree S G \\<sqsubseteq> ccTTree S G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<sqsubseteq> G' \\<Longrightarrow>\n    ccTTree S G \\<sqsubseteq> ccTTree S G'", "apply (rule ttree_belowI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>G \\<sqsubseteq> G'; xs \\<in> paths (ccTTree S G)\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> paths (ccTTree S G')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>G \\<sqsubseteq> G'; xs \\<in> valid_lists S G\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> valid_lists S G'", "apply (induct_tac  rule:valid_lists.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>G \\<sqsubseteq> G'; xs \\<in> valid_lists S G\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> valid_lists (?S2 xs) (?G2 xs)\n 2. \\<And>xs.\n       \\<lbrakk>G \\<sqsubseteq> G'; xs \\<in> valid_lists S G\\<rbrakk>\n       \\<Longrightarrow> [] \\<in> valid_lists S G'\n 3. \\<And>xs xsa x.\n       \\<lbrakk>G \\<sqsubseteq> G'; xs \\<in> valid_lists S G;\n        set xsa \\<subseteq> ccNeighbors x (?G2 xs);\n        xsa \\<in> valid_lists (?S2 xs) (?G2 xs); xsa \\<in> valid_lists S G';\n        x \\<in> ?S2 xs\\<rbrakk>\n       \\<Longrightarrow> x # xsa \\<in> valid_lists S G'", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>G \\<sqsubseteq> G'; xs \\<in> valid_lists S G\\<rbrakk>\n       \\<Longrightarrow> [] \\<in> valid_lists S G'\n 2. \\<And>xs xsa x.\n       \\<lbrakk>G \\<sqsubseteq> G'; xs \\<in> valid_lists S G;\n        set xsa \\<subseteq> ccNeighbors x G; xsa \\<in> valid_lists S G;\n        xsa \\<in> valid_lists S G'; x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> x # xsa \\<in> valid_lists S G'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xsa x.\n       \\<lbrakk>G \\<sqsubseteq> G'; xs \\<in> valid_lists S G;\n        set xsa \\<subseteq> ccNeighbors x G; xsa \\<in> valid_lists S G;\n        xsa \\<in> valid_lists S G'; x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> x # xsa \\<in> valid_lists S G'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xsa x.\n       \\<lbrakk>G \\<sqsubseteq> G'; xs \\<in> valid_lists S G;\n        set xsa \\<subseteq> ccNeighbors x G; xsa \\<in> valid_lists S G;\n        xsa \\<in> valid_lists S G'; x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> set xsa \\<subseteq> ccNeighbors x G'", "apply (erule (1) order_trans[OF _ ccNeighbors_mono])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ccTTree_mono:\n  \"S \\<subseteq> S' \\<Longrightarrow> G \\<sqsubseteq> G' \\<Longrightarrow> ccTTree S G \\<sqsubseteq> ccTTree S' G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<subseteq> S'; G \\<sqsubseteq> G'\\<rbrakk>\n    \\<Longrightarrow> ccTTree S G \\<sqsubseteq> ccTTree S' G'", "by (metis below_trans[OF ccTTree_mono1 ccTTree_mono2])"], ["", "lemma cont_ccTTree2:\n  \"cont (ccTTree S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (ccTTree S)", "apply (rule contI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. monofun (ccTTree S)\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. ccTTree S (Y i))\\<rbrakk>\n       \\<Longrightarrow> ccTTree S (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. ccTTree S (Y i))", "apply (rule monofunI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       ccTTree S x \\<sqsubseteq> ccTTree S y\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. ccTTree S (Y i))\\<rbrakk>\n       \\<Longrightarrow> ccTTree S (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. ccTTree S (Y i))", "apply (erule ccTTree_mono2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. ccTTree S (Y i))\\<rbrakk>\n       \\<Longrightarrow> ccTTree S (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. ccTTree S (Y i))", "apply (rule ttree_belowI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y xs.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. ccTTree S (Y i));\n        xs \\<in> paths (ccTTree S (\\<Squnion>i. Y i))\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> paths (\\<Squnion>i. ccTTree S (Y i))", "apply (simp add: paths_Either lub_set lub_is_either)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y xs.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. ccTTree S (Y i));\n        xs \\<in> valid_lists S (Lub Y)\\<rbrakk>\n       \\<Longrightarrow> xs = [] \\<or>\n                         (\\<exists>x. xs \\<in> valid_lists S (Y x))", "apply (drule (1) valid_lists_chain2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y xs.\n       \\<lbrakk>chain (\\<lambda>i. ccTTree S (Y i));\n        xs \\<in> valid_lists S (Lub Y);\n        \\<exists>i. xs \\<in> valid_lists S (Y i)\\<rbrakk>\n       \\<Longrightarrow> xs = [] \\<or>\n                         (\\<exists>x. xs \\<in> valid_lists S (Y x))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas cont_ccTTree = cont_compose2[where c = ccTTree, OF cont_ccTTree1 cont_ccTTree2, simp, cont2cont]"], ["", "lemma ccTTree_below_singleI:\n  assumes \"S \\<inter> S' = {}\"\n  shows \"ccTTree S G \\<sqsubseteq> singles S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccTTree S G \\<sqsubseteq> singles S'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ccTTree S G \\<sqsubseteq> singles S'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ccTTree S G \\<sqsubseteq> singles S'", "fix xs x"], ["proof (state)\ngoal (1 subgoal):\n 1. ccTTree S G \\<sqsubseteq> singles S'", "assume \"xs \\<in> valid_lists S G\" and \"x \\<in> S'\""], ["proof (state)\nthis:\n  xs \\<in> valid_lists S G\n  x \\<in> S'\n\ngoal (1 subgoal):\n 1. ccTTree S G \\<sqsubseteq> singles S'", "from this assms"], ["proof (chain)\npicking this:\n  xs \\<in> valid_lists S G\n  x \\<in> S'\n  S \\<inter> S' = {}", "have \"length [x'\\<leftarrow>xs . x' = x] \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  xs \\<in> valid_lists S G\n  x \\<in> S'\n  S \\<inter> S' = {}\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x'. x' = x) xs) \\<le> Suc 0", "by(induction rule: valid_lists.induct[case_names Nil Cons]) auto"], ["proof (state)\nthis:\n  length (filter (\\<lambda>x'. x' = x) xs) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. ccTTree S G \\<sqsubseteq> singles S'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xs2 \\<in> valid_lists S G; ?x2 \\<in> S'\\<rbrakk>\n  \\<Longrightarrow> length (filter (\\<lambda>x'. x' = ?x2) ?xs2) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. ccTTree S G \\<sqsubseteq> singles S'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs2 \\<in> valid_lists S G; ?x2 \\<in> S'\\<rbrakk>\n  \\<Longrightarrow> length (filter (\\<lambda>x'. x' = ?x2) ?xs2) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. ccTTree S G \\<sqsubseteq> singles S'", "by transfer auto"], ["proof (state)\nthis:\n  ccTTree S G \\<sqsubseteq> singles S'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccTTree_cc_restr: \"ccTTree S G = ccTTree S (cc_restr S G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccTTree S G = ccTTree S (G G|` S)", "by transfer' (rule valid_lists_cc_restr)"], ["", "lemma ccTTree_cong_below: \"cc_restr S G \\<sqsubseteq> cc_restr S G' \\<Longrightarrow> ccTTree S G \\<sqsubseteq> ccTTree S G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G G|` S \\<sqsubseteq> G' G|` S \\<Longrightarrow>\n    ccTTree S G \\<sqsubseteq> ccTTree S G'", "by (metis ccTTree_mono2 ccTTree_cc_restr)"], ["", "lemma ccTTree_cong: \"cc_restr S G = cc_restr S G' \\<Longrightarrow> ccTTree S G = ccTTree S G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G G|` S = G' G|` S \\<Longrightarrow> ccTTree S G = ccTTree S G'", "by (metis ccTTree_cc_restr)"], ["", "lemma either_ccTTree:\n  \"ccTTree S G \\<oplus>\\<oplus> ccTTree S' G' \\<sqsubseteq> ccTTree (S \\<union> S') (G \\<squnion> G')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccTTree S G \\<oplus>\\<oplus> ccTTree S' G' \\<sqsubseteq>\n    ccTTree (S \\<union> S') (G \\<squnion> G')", "by (auto intro!: either_belowI ccTTree_mono)"], ["", "lemma interleave_ccTTree: \n   \"ccTTree S G \\<otimes>\\<otimes> ccTTree S' G' \\<sqsubseteq> ccTTree (S \\<union> S') (G \\<squnion> G' \\<squnion> ccProd S S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccTTree S G \\<otimes>\\<otimes> ccTTree S' G' \\<sqsubseteq>\n    ccTTree (S \\<union> S') (G \\<squnion> G' \\<squnion> S G\\<times> S')", "by transfer' (auto, erule (2) interleave_valid_list)"], ["", "lemma interleave_ccTTree': \n   \"ccTTree (S \\<union> S') G \\<sqsubseteq> ccTTree S G \\<otimes>\\<otimes> ccTTree S' G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccTTree (S \\<union> S') G \\<sqsubseteq>\n    ccTTree S G \\<otimes>\\<otimes> ccTTree S' G", "by transfer' (auto dest!:  interleave_valid_list')"], ["", "lemma many_calls_ccTTree:\n  shows \"many_calls x = ccTTree {x} (ccProd {x} {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. many_calls x = ccTTree {x} ({x} G\\<times> {x})", "apply(transfer')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       range (\\<lambda>n. replicate n x) =\n       valid_lists {x} ({x} G\\<times> {x})", "apply (auto intro: many_calls_valid_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n. replicate n x \\<in> valid_lists {x} ({x} G\\<times> {x})", "apply (induct_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x n. replicate 0 x \\<in> valid_lists {x} ({x} G\\<times> {x})\n 2. \\<And>x n na.\n       replicate na x\n       \\<in> valid_lists {x} ({x} G\\<times> {x}) \\<Longrightarrow>\n       replicate (Suc na) x \\<in> valid_lists {x} ({x} G\\<times> {x})", "apply (auto simp add: ccNeighbors_ccProd)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma filter_valid_lists':\n  \"xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow> xs \\<in> filter P ` valid_lists S G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n    xs \\<in> filter P ` valid_lists S G", "proof (induction xs )"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n    [] \\<in> filter P ` valid_lists S G\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n                xs \\<in> filter P ` valid_lists S G;\n        a # xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> filter P ` valid_lists S G", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> valid_lists {x' \\<in> S. P x'} G\n\ngoal (2 subgoals):\n 1. [] \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n    [] \\<in> filter P ` valid_lists S G\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n                xs \\<in> filter P ` valid_lists S G;\n        a # xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> filter P ` valid_lists S G", "thus ?case"], ["proof (prove)\nusing this:\n  [] \\<in> valid_lists {x' \\<in> S. P x'} G\n\ngoal (1 subgoal):\n 1. [] \\<in> filter P ` valid_lists S G", "by auto  (metis filter.simps(1) image_iff valid_lists_simps(1))"], ["proof (state)\nthis:\n  [] \\<in> filter P ` valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n                xs \\<in> filter P ` valid_lists S G;\n        a # xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> filter P ` valid_lists S G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n                xs \\<in> filter P ` valid_lists S G;\n        a # xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> filter P ` valid_lists S G", "case (Cons x xs)"], ["proof (state)\nthis:\n  xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n  xs \\<in> filter P ` valid_lists S G\n  x # xs \\<in> valid_lists {x' \\<in> S. P x'} G\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n                xs \\<in> filter P ` valid_lists S G;\n        a # xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> filter P ` valid_lists S G", "from Cons.prems"], ["proof (chain)\npicking this:\n  x # xs \\<in> valid_lists {x' \\<in> S. P x'} G", "have \"set xs \\<subseteq> ccNeighbors x G\" and \"xs \\<in> valid_lists {x' \\<in> S. P x'} G\" and \"x \\<in> S\" and \"P x\""], ["proof (prove)\nusing this:\n  x # xs \\<in> valid_lists {x' \\<in> S. P x'} G\n\ngoal (1 subgoal):\n 1. (set xs \\<subseteq> ccNeighbors x G &&&\n     xs \\<in> valid_lists {x' \\<in> S. P x'} G) &&&\n    x \\<in> S &&& P x", "by auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists {x' \\<in> S. P x'} G\n  x \\<in> S\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n                xs \\<in> filter P ` valid_lists S G;\n        a # xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> filter P ` valid_lists S G", "from this(2)"], ["proof (chain)\npicking this:\n  xs \\<in> valid_lists {x' \\<in> S. P x'} G", "have \"set xs \\<subseteq> {x' \\<in> S. P x'}\""], ["proof (prove)\nusing this:\n  xs \\<in> valid_lists {x' \\<in> S. P x'} G\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> {x' \\<in> S. P x'}", "by (rule valid_lists_subset)"], ["proof (state)\nthis:\n  set xs \\<subseteq> {x' \\<in> S. P x'}\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n                xs \\<in> filter P ` valid_lists S G;\n        a # xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> filter P ` valid_lists S G", "hence \"\\<forall>x \\<in> set xs. P x\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> {x' \\<in> S. P x'}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. P x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. P x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n                xs \\<in> filter P ` valid_lists S G;\n        a # xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> filter P ` valid_lists S G", "hence [simp]: \"filter P xs = xs\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. P x\n\ngoal (1 subgoal):\n 1. filter P xs = xs", "by (rule filter_True)"], ["proof (state)\nthis:\n  filter P xs = xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n                xs \\<in> filter P ` valid_lists S G;\n        a # xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> filter P ` valid_lists S G", "from Cons.IH[OF \\<open>xs \\<in> _\\<close>]"], ["proof (chain)\npicking this:\n  xs \\<in> filter P ` valid_lists S G", "have \"xs \\<in> filter P ` valid_lists S G\""], ["proof (prove)\nusing this:\n  xs \\<in> filter P ` valid_lists S G\n\ngoal (1 subgoal):\n 1. xs \\<in> filter P ` valid_lists S G", "."], ["proof (state)\nthis:\n  xs \\<in> filter P ` valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n                xs \\<in> filter P ` valid_lists S G;\n        a # xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> filter P ` valid_lists S G", "from  \\<open>xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<close>"], ["proof (chain)\npicking this:\n  xs \\<in> valid_lists {x' \\<in> S. P x'} G", "have \"xs \\<in> valid_lists S G\""], ["proof (prove)\nusing this:\n  xs \\<in> valid_lists {x' \\<in> S. P x'} G\n\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists S G", "by (rule subsetD[OF valid_lists_mono1, rotated]) auto"], ["proof (state)\nthis:\n  xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n                xs \\<in> filter P ` valid_lists S G;\n        a # xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> filter P ` valid_lists S G", "from \\<open>set xs \\<subseteq> ccNeighbors x G\\<close> this \\<open>x \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists S G\n  x \\<in> S", "have \"x # xs \\<in> valid_lists S G\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists S G\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x # xs \\<in> valid_lists S G", "by rule"], ["proof (state)\nthis:\n  x # xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n                xs \\<in> filter P ` valid_lists S G;\n        a # xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> filter P ` valid_lists S G", "hence \"filter P (x # xs) \\<in> filter P ` valid_lists S G\""], ["proof (prove)\nusing this:\n  x # xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. filter P (x # xs) \\<in> filter P ` valid_lists S G", "by (rule imageI)"], ["proof (state)\nthis:\n  filter P (x # xs) \\<in> filter P ` valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<in> valid_lists {x' \\<in> S. P x'} G \\<Longrightarrow>\n                xs \\<in> filter P ` valid_lists S G;\n        a # xs \\<in> valid_lists {x' \\<in> S. P x'} G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> filter P ` valid_lists S G", "thus ?case"], ["proof (prove)\nusing this:\n  filter P (x # xs) \\<in> filter P ` valid_lists S G\n\ngoal (1 subgoal):\n 1. x # xs \\<in> filter P ` valid_lists S G", "using \\<open>P x\\<close> \\<open>filter P xs =xs\\<close>"], ["proof (prove)\nusing this:\n  filter P (x # xs) \\<in> filter P ` valid_lists S G\n  P x\n  filter P xs = xs\n\ngoal (1 subgoal):\n 1. x # xs \\<in> filter P ` valid_lists S G", "by simp"], ["proof (state)\nthis:\n  x # xs \\<in> filter P ` valid_lists S G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma without_ccTTree[simp]:\n   \"without x (ccTTree S G) = ccTTree (S - {x}) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. without x (ccTTree S G) = ccTTree (S - {x}) G", "by (transfer' fixing: x) (auto dest: filter_valid_lists'  filter_valid_lists[where P = \"(\\<lambda> x'. x'\\<noteq> x)\"]  simp add: set_diff_eq)"], ["", "lemma ttree_restr_ccTTree[simp]:\n   \"ttree_restr S' (ccTTree S G) = ccTTree (S \\<inter> S') G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ttree_restr S' (ccTTree S G) = ccTTree (S \\<inter> S') G", "by (transfer' fixing: S') (auto dest: filter_valid_lists'  filter_valid_lists[where P = \"(\\<lambda> x'. x' \\<in> S')\"]  simp add:Int_def)"], ["", "lemma repeatable_ccTTree_ccSquare: \"S \\<subseteq> S' \\<Longrightarrow> repeatable (ccTTree S (ccSquare S'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> S' \\<Longrightarrow> repeatable (ccTTree S (S'\\<^sup>2))", "unfolding repeatable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> S' \\<Longrightarrow>\n    \\<forall>x.\n       possible (ccTTree S (S'\\<^sup>2)) x \\<longrightarrow>\n       nxt (ccTTree S (S'\\<^sup>2)) x = ccTTree S (S'\\<^sup>2)", "by transfer (auto simp add:ccNeighbors_ccSquare dest: subsetD[OF valid_lists_subset])"], ["", "text \\<open>An alternative definition\\<close>"], ["", "inductive valid_lists' :: \"var set \\<Rightarrow> CoCalls \\<Rightarrow> var set \\<Rightarrow> var list \\<Rightarrow> bool\"\n  for S G\n  where  \"valid_lists' S G prefix []\"\n  | \"prefix \\<subseteq> ccNeighbors x G \\<Longrightarrow> valid_lists' S G (insert x prefix) xs \\<Longrightarrow> x \\<in> S \\<Longrightarrow> valid_lists' S G prefix (x#xs)\""], ["", "inductive_simps valid_lists'_simps[simp]: \"valid_lists' S G prefix []\" \"valid_lists' S G prefix (x#xs)\""], ["", "inductive_cases vald_lists'_ConsE: \"valid_lists' S G prefix (x#xs)\""], ["", "lemma valid_lists_valid_lists':\n  \"xs \\<in> valid_lists S G \\<Longrightarrow> ccProd prefix (set xs) \\<sqsubseteq> G \\<Longrightarrow> valid_lists' S G prefix xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<in> valid_lists S G;\n     prefix G\\<times> set xs \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> valid_lists' S G prefix xs", "proof(induction arbitrary: prefix rule: valid_lists.induct[case_names Nil Cons])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>prefix.\n       prefix G\\<times> set [] \\<sqsubseteq> G \\<Longrightarrow>\n       valid_lists' S G prefix []\n 2. \\<And>xs x prefix.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists S G;\n        \\<And>prefix.\n           prefix G\\<times> set xs \\<sqsubseteq> G \\<Longrightarrow>\n           valid_lists' S G prefix xs;\n        x \\<in> S; prefix G\\<times> set (x # xs) \\<sqsubseteq> G\\<rbrakk>\n       \\<Longrightarrow> valid_lists' S G prefix (x # xs)", "case Nil"], ["proof (state)\nthis:\n  prefix G\\<times> set [] \\<sqsubseteq> G\n\ngoal (2 subgoals):\n 1. \\<And>prefix.\n       prefix G\\<times> set [] \\<sqsubseteq> G \\<Longrightarrow>\n       valid_lists' S G prefix []\n 2. \\<And>xs x prefix.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists S G;\n        \\<And>prefix.\n           prefix G\\<times> set xs \\<sqsubseteq> G \\<Longrightarrow>\n           valid_lists' S G prefix xs;\n        x \\<in> S; prefix G\\<times> set (x # xs) \\<sqsubseteq> G\\<rbrakk>\n       \\<Longrightarrow> valid_lists' S G prefix (x # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  prefix G\\<times> set [] \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. valid_lists' S G prefix []", "by simp"], ["proof (state)\nthis:\n  valid_lists' S G prefix []\n\ngoal (1 subgoal):\n 1. \\<And>xs x prefix.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists S G;\n        \\<And>prefix.\n           prefix G\\<times> set xs \\<sqsubseteq> G \\<Longrightarrow>\n           valid_lists' S G prefix xs;\n        x \\<in> S; prefix G\\<times> set (x # xs) \\<sqsubseteq> G\\<rbrakk>\n       \\<Longrightarrow> valid_lists' S G prefix (x # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x prefix.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists S G;\n        \\<And>prefix.\n           prefix G\\<times> set xs \\<sqsubseteq> G \\<Longrightarrow>\n           valid_lists' S G prefix xs;\n        x \\<in> S; prefix G\\<times> set (x # xs) \\<sqsubseteq> G\\<rbrakk>\n       \\<Longrightarrow> valid_lists' S G prefix (x # xs)", "case (Cons xs x)"], ["proof (state)\nthis:\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists S G\n  x \\<in> S\n  ?prefix G\\<times> set xs \\<sqsubseteq> G \\<Longrightarrow>\n  valid_lists' S G ?prefix xs\n  prefix G\\<times> set (x # xs) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs x prefix.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists S G;\n        \\<And>prefix.\n           prefix G\\<times> set xs \\<sqsubseteq> G \\<Longrightarrow>\n           valid_lists' S G prefix xs;\n        x \\<in> S; prefix G\\<times> set (x # xs) \\<sqsubseteq> G\\<rbrakk>\n       \\<Longrightarrow> valid_lists' S G prefix (x # xs)", "from Cons.prems Cons.hyps Cons.IH[where prefix = \"insert x prefix\"]"], ["proof (chain)\npicking this:\n  prefix G\\<times> set (x # xs) \\<sqsubseteq> G\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists S G\n  x \\<in> S\n  insert x prefix G\\<times> set xs \\<sqsubseteq> G \\<Longrightarrow>\n  valid_lists' S G (insert x prefix) xs", "show ?case"], ["proof (prove)\nusing this:\n  prefix G\\<times> set (x # xs) \\<sqsubseteq> G\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists S G\n  x \\<in> S\n  insert x prefix G\\<times> set xs \\<sqsubseteq> G \\<Longrightarrow>\n  valid_lists' S G (insert x prefix) xs\n\ngoal (1 subgoal):\n 1. valid_lists' S G prefix (x # xs)", "by (auto simp add: insert_is_Un[where A = \"set xs\"]  insert_is_Un[where A = prefix]\n                     join_below_iff subset_ccNeighbors elem_ccNeighbors ccProd_comm simp del: Un_insert_left )"], ["proof (state)\nthis:\n  valid_lists' S G prefix (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_lists'_valid_lists_aux:\n  \"valid_lists' S G prefix xs \\<Longrightarrow>  x \\<in> prefix \\<Longrightarrow> ccProd (set xs) {x} \\<sqsubseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_lists' S G prefix xs; x \\<in> prefix\\<rbrakk>\n    \\<Longrightarrow> set xs G\\<times> {x} \\<sqsubseteq> G", "proof(induction  rule: valid_lists'.induct[case_names Nil Cons])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>prefix.\n       x \\<in> prefix \\<Longrightarrow> set [] G\\<times> {x} \\<sqsubseteq> G\n 2. \\<And>prefix xa xs.\n       \\<lbrakk>prefix \\<subseteq> ccNeighbors xa G;\n        valid_lists' S G (insert xa prefix) xs;\n        x \\<in> insert xa prefix \\<Longrightarrow>\n        set xs G\\<times> {x} \\<sqsubseteq> G;\n        xa \\<in> S; x \\<in> prefix\\<rbrakk>\n       \\<Longrightarrow> set (xa # xs) G\\<times> {x} \\<sqsubseteq> G", "case Nil"], ["proof (state)\nthis:\n  x \\<in> prefix_\n\ngoal (2 subgoals):\n 1. \\<And>prefix.\n       x \\<in> prefix \\<Longrightarrow> set [] G\\<times> {x} \\<sqsubseteq> G\n 2. \\<And>prefix xa xs.\n       \\<lbrakk>prefix \\<subseteq> ccNeighbors xa G;\n        valid_lists' S G (insert xa prefix) xs;\n        x \\<in> insert xa prefix \\<Longrightarrow>\n        set xs G\\<times> {x} \\<sqsubseteq> G;\n        xa \\<in> S; x \\<in> prefix\\<rbrakk>\n       \\<Longrightarrow> set (xa # xs) G\\<times> {x} \\<sqsubseteq> G", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in> prefix_\n\ngoal (1 subgoal):\n 1. set [] G\\<times> {x} \\<sqsubseteq> G", "by simp"], ["proof (state)\nthis:\n  set [] G\\<times> {x} \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>prefix xa xs.\n       \\<lbrakk>prefix \\<subseteq> ccNeighbors xa G;\n        valid_lists' S G (insert xa prefix) xs;\n        x \\<in> insert xa prefix \\<Longrightarrow>\n        set xs G\\<times> {x} \\<sqsubseteq> G;\n        xa \\<in> S; x \\<in> prefix\\<rbrakk>\n       \\<Longrightarrow> set (xa # xs) G\\<times> {x} \\<sqsubseteq> G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>prefix xa xs.\n       \\<lbrakk>prefix \\<subseteq> ccNeighbors xa G;\n        valid_lists' S G (insert xa prefix) xs;\n        x \\<in> insert xa prefix \\<Longrightarrow>\n        set xs G\\<times> {x} \\<sqsubseteq> G;\n        xa \\<in> S; x \\<in> prefix\\<rbrakk>\n       \\<Longrightarrow> set (xa # xs) G\\<times> {x} \\<sqsubseteq> G", "case (Cons prefix x xs)"], ["proof (state)\nthis:\n  prefix \\<subseteq> ccNeighbors x G\n  valid_lists' S G (insert x prefix) xs\n  x \\<in> S\n  x \\<in> insert x prefix \\<Longrightarrow>\n  set xs G\\<times> {x} \\<sqsubseteq> G\n  x \\<in> prefix\n\ngoal (1 subgoal):\n 1. \\<And>prefix xa xs.\n       \\<lbrakk>prefix \\<subseteq> ccNeighbors xa G;\n        valid_lists' S G (insert xa prefix) xs;\n        x \\<in> insert xa prefix \\<Longrightarrow>\n        set xs G\\<times> {x} \\<sqsubseteq> G;\n        xa \\<in> S; x \\<in> prefix\\<rbrakk>\n       \\<Longrightarrow> set (xa # xs) G\\<times> {x} \\<sqsubseteq> G", "thus ?case"], ["proof (prove)\nusing this:\n  prefix \\<subseteq> ccNeighbors x G\n  valid_lists' S G (insert x prefix) xs\n  x \\<in> S\n  x \\<in> insert x prefix \\<Longrightarrow>\n  set xs G\\<times> {x} \\<sqsubseteq> G\n  x \\<in> prefix\n\ngoal (1 subgoal):\n 1. set (x # xs) G\\<times> {x} \\<sqsubseteq> G", "apply (auto simp add: ccProd_insert2[where S' = prefix] ccProd_insert1[where S' = \"set xs\"] join_below_iff subset_ccNeighbors)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{x} G\\<times> prefix \\<sqsubseteq> G;\n     valid_lists' S G (insert x prefix) xs; x \\<in> S;\n     set xs G\\<times> {x} \\<sqsubseteq> G; x \\<in> prefix\\<rbrakk>\n    \\<Longrightarrow> {x} G\\<times> {x} \\<sqsubseteq> G", "by (metis Cons.hyps(1) dual_order.trans empty_subsetI insert_subset subset_ccNeighbors)"], ["proof (state)\nthis:\n  set (x # xs) G\\<times> {x} \\<sqsubseteq> G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_lists'_valid_lists:\n  \"valid_lists' S G prefix xs \\<Longrightarrow> xs \\<in> valid_lists S G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_lists' S G prefix xs \\<Longrightarrow> xs \\<in> valid_lists S G", "proof(induction  rule: valid_lists'.induct[case_names Nil Cons])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>prefix. [] \\<in> valid_lists S G\n 2. \\<And>prefix x xs.\n       \\<lbrakk>prefix \\<subseteq> ccNeighbors x G;\n        valid_lists' S G (insert x prefix) xs; xs \\<in> valid_lists S G;\n        x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> x # xs \\<in> valid_lists S G", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>prefix. [] \\<in> valid_lists S G\n 2. \\<And>prefix x xs.\n       \\<lbrakk>prefix \\<subseteq> ccNeighbors x G;\n        valid_lists' S G (insert x prefix) xs; xs \\<in> valid_lists S G;\n        x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> x # xs \\<in> valid_lists S G", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> valid_lists S G", "by simp"], ["proof (state)\nthis:\n  [] \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>prefix x xs.\n       \\<lbrakk>prefix \\<subseteq> ccNeighbors x G;\n        valid_lists' S G (insert x prefix) xs; xs \\<in> valid_lists S G;\n        x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> x # xs \\<in> valid_lists S G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>prefix x xs.\n       \\<lbrakk>prefix \\<subseteq> ccNeighbors x G;\n        valid_lists' S G (insert x prefix) xs; xs \\<in> valid_lists S G;\n        x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> x # xs \\<in> valid_lists S G", "case (Cons prefix x xs)"], ["proof (state)\nthis:\n  prefix \\<subseteq> ccNeighbors x G\n  valid_lists' S G (insert x prefix) xs\n  x \\<in> S\n  xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>prefix x xs.\n       \\<lbrakk>prefix \\<subseteq> ccNeighbors x G;\n        valid_lists' S G (insert x prefix) xs; xs \\<in> valid_lists S G;\n        x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> x # xs \\<in> valid_lists S G", "thus ?case"], ["proof (prove)\nusing this:\n  prefix \\<subseteq> ccNeighbors x G\n  valid_lists' S G (insert x prefix) xs\n  x \\<in> S\n  xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. x # xs \\<in> valid_lists S G", "by (auto simp add: insert_is_Un[where A = \"set xs\"]  insert_is_Un[where A = prefix]\n                   join_below_iff subset_ccNeighbors elem_ccNeighbors ccProd_comm simp del: Un_insert_left \n         intro: valid_lists'_valid_lists_aux)"], ["proof (state)\nthis:\n  x # xs \\<in> valid_lists S G\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Yet another definition\\<close>"], ["", "lemma valid_lists_characterization:\n  \"xs \\<in> valid_lists S G \\<longleftrightarrow> set xs \\<subseteq> S \\<and> (\\<forall>n. ccProd (set (take n xs)) (set (drop n xs)) \\<sqsubseteq> G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<in> valid_lists S G) =\n    (set xs \\<subseteq> S \\<and>\n     (\\<forall>n.\n         set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G))", "proof(safe)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xs \\<in> valid_lists S G; x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> S\n 2. \\<And>n.\n       xs \\<in> valid_lists S G \\<Longrightarrow>\n       set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\n 3. \\<lbrakk>set xs \\<subseteq> S;\n     \\<forall>n.\n        set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> valid_lists S G", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xs \\<in> valid_lists S G; x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> S\n 2. \\<And>n.\n       xs \\<in> valid_lists S G \\<Longrightarrow>\n       set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\n 3. \\<lbrakk>set xs \\<subseteq> S;\n     \\<forall>n.\n        set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> valid_lists S G", "assume \"xs \\<in> valid_lists S G\""], ["proof (state)\nthis:\n  xs \\<in> valid_lists S G\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xs \\<in> valid_lists S G; x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> S\n 2. \\<And>n.\n       xs \\<in> valid_lists S G \\<Longrightarrow>\n       set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\n 3. \\<lbrakk>set xs \\<subseteq> S;\n     \\<forall>n.\n        set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> valid_lists S G", "from  valid_lists_subset[OF this]"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> S", "show \"x \\<in> set xs \\<Longrightarrow> x \\<in> S\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> S\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> x \\<in> S", "by auto"], ["proof (state)\nthis:\n  x \\<in> set xs \\<Longrightarrow> x \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       xs \\<in> valid_lists S G \\<Longrightarrow>\n       set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\n 2. \\<lbrakk>set xs \\<subseteq> S;\n     \\<forall>n.\n        set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> valid_lists S G", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       xs \\<in> valid_lists S G \\<Longrightarrow>\n       set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\n 2. \\<lbrakk>set xs \\<subseteq> S;\n     \\<forall>n.\n        set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> valid_lists S G", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       xs \\<in> valid_lists S G \\<Longrightarrow>\n       set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\n 2. \\<lbrakk>set xs \\<subseteq> S;\n     \\<forall>n.\n        set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> valid_lists S G", "assume \"xs \\<in> valid_lists S G\""], ["proof (state)\nthis:\n  xs \\<in> valid_lists S G\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       xs \\<in> valid_lists S G \\<Longrightarrow>\n       set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\n 2. \\<lbrakk>set xs \\<subseteq> S;\n     \\<forall>n.\n        set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> valid_lists S G", "thus \"ccProd (set (take n xs)) (set (drop n xs)) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G", "proof(induction arbitrary: n rule: valid_lists.induct[case_names Nil Cons])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. set (take n []) G\\<times> set (drop n []) \\<sqsubseteq> G\n 2. \\<And>xs x n.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists S G;\n        \\<And>n. set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G;\n        x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> set (take n (x # xs)) G\\<times>\n                         set (drop n (x # xs)) \\<sqsubseteq>\n                         G", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>n. set (take n []) G\\<times> set (drop n []) \\<sqsubseteq> G\n 2. \\<And>xs x n.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists S G;\n        \\<And>n. set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G;\n        x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> set (take n (x # xs)) G\\<times>\n                         set (drop n (x # xs)) \\<sqsubseteq>\n                         G", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take n []) G\\<times> set (drop n []) \\<sqsubseteq> G", "by simp"], ["proof (state)\nthis:\n  set (take n []) G\\<times> set (drop n []) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs x n.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists S G;\n        \\<And>n. set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G;\n        x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> set (take n (x # xs)) G\\<times>\n                         set (drop n (x # xs)) \\<sqsubseteq>\n                         G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x n.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists S G;\n        \\<And>n. set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G;\n        x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> set (take n (x # xs)) G\\<times>\n                         set (drop n (x # xs)) \\<sqsubseteq>\n                         G", "case (Cons xs x)"], ["proof (state)\nthis:\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists S G\n  x \\<in> S\n  set (take ?n xs) G\\<times> set (drop ?n xs) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>xs x n.\n       \\<lbrakk>set xs \\<subseteq> ccNeighbors x G;\n        xs \\<in> valid_lists S G;\n        \\<And>n. set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G;\n        x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> set (take n (x # xs)) G\\<times>\n                         set (drop n (x # xs)) \\<sqsubseteq>\n                         G", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G", "proof(cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G", "by simp"], ["proof (state)\nthis:\n  set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G", "case (Suc n)"], ["proof (state)\nthis:\n  na__ = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       na__ = Suc nat \\<Longrightarrow>\n       set (take na__ (x # xs)) G\\<times>\n       set (drop na__ (x # xs)) \\<sqsubseteq>\n       G", "with Cons.hyps Cons.IH[where n = n]"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists S G\n  x \\<in> S\n  set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\n  na__ = Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> ccNeighbors x G\n  xs \\<in> valid_lists S G\n  x \\<in> S\n  set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\n  na__ = Suc n\n\ngoal (1 subgoal):\n 1. set (take na__ (x # xs)) G\\<times>\n    set (drop na__ (x # xs)) \\<sqsubseteq>\n    G", "apply (auto simp add: ccProd_insert1[where S' = \"set xs\" for xs] join_below_iff subset_ccNeighbors)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{x} G\\<times> set xs \\<sqsubseteq> G; xs \\<in> valid_lists S G;\n     x \\<in> S; set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G;\n     na__ = Suc n\\<rbrakk>\n    \\<Longrightarrow> {x} G\\<times> set (drop n xs) \\<sqsubseteq> G", "by (metis dual_order.trans set_drop_subset subset_ccNeighbors)"], ["proof (state)\nthis:\n  set (take na__ (x # xs)) G\\<times> set (drop na__ (x # xs)) \\<sqsubseteq>\n  G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs \\<subseteq> S;\n     \\<forall>n.\n        set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> valid_lists S G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs \\<subseteq> S;\n     \\<forall>n.\n        set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> valid_lists S G", "assume \"set xs \\<subseteq> S\"\n  and \"\\<forall> n. ccProd (set (take n xs)) (set (drop n xs)) \\<sqsubseteq> G\""], ["proof (state)\nthis:\n  set xs \\<subseteq> S\n  \\<forall>n. set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs \\<subseteq> S;\n     \\<forall>n.\n        set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> valid_lists S G", "thus \"xs \\<in> valid_lists S G\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> S\n  \\<forall>n. set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists S G", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> S;\n     \\<forall>n.\n        set (take n []) G\\<times> set (drop n []) \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> [] \\<in> valid_lists S G\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>set xs \\<subseteq> S;\n                 \\<forall>n.\n                    set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq>\n                    G\\<rbrakk>\n                \\<Longrightarrow> xs \\<in> valid_lists S G;\n        set (a # xs) \\<subseteq> S;\n        \\<forall>n.\n           set (take n (a # xs)) G\\<times>\n           set (drop n (a # xs)) \\<sqsubseteq>\n           G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> S\n  \\<forall>n. set (take n []) G\\<times> set (drop n []) \\<sqsubseteq> G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> S;\n     \\<forall>n.\n        set (take n []) G\\<times> set (drop n []) \\<sqsubseteq> G\\<rbrakk>\n    \\<Longrightarrow> [] \\<in> valid_lists S G\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>set xs \\<subseteq> S;\n                 \\<forall>n.\n                    set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq>\n                    G\\<rbrakk>\n                \\<Longrightarrow> xs \\<in> valid_lists S G;\n        set (a # xs) \\<subseteq> S;\n        \\<forall>n.\n           set (take n (a # xs)) G\\<times>\n           set (drop n (a # xs)) \\<sqsubseteq>\n           G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "thus ?case"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> S\n  \\<forall>n. set (take n []) G\\<times> set (drop n []) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. [] \\<in> valid_lists S G", "by simp"], ["proof (state)\nthis:\n  [] \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>set xs \\<subseteq> S;\n                 \\<forall>n.\n                    set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq>\n                    G\\<rbrakk>\n                \\<Longrightarrow> xs \\<in> valid_lists S G;\n        set (a # xs) \\<subseteq> S;\n        \\<forall>n.\n           set (take n (a # xs)) G\\<times>\n           set (drop n (a # xs)) \\<sqsubseteq>\n           G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>set xs \\<subseteq> S;\n                 \\<forall>n.\n                    set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq>\n                    G\\<rbrakk>\n                \\<Longrightarrow> xs \\<in> valid_lists S G;\n        set (a # xs) \\<subseteq> S;\n        \\<forall>n.\n           set (take n (a # xs)) G\\<times>\n           set (drop n (a # xs)) \\<sqsubseteq>\n           G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>set xs \\<subseteq> S;\n   \\<forall>n.\n      set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\\<rbrakk>\n  \\<Longrightarrow> xs \\<in> valid_lists S G\n  set (x # xs) \\<subseteq> S\n  \\<forall>n.\n     set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>set xs \\<subseteq> S;\n                 \\<forall>n.\n                    set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq>\n                    G\\<rbrakk>\n                \\<Longrightarrow> xs \\<in> valid_lists S G;\n        set (a # xs) \\<subseteq> S;\n        \\<forall>n.\n           set (take n (a # xs)) G\\<times>\n           set (drop n (a # xs)) \\<sqsubseteq>\n           G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "from \\<open>\\<forall>n. ccProd (set (take n (x # xs))) (set (drop n (x # xs))) \\<sqsubseteq> G\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n.\n     set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G", "have \"\\<forall>n. ccProd (set (take n xs)) (set (drop n xs)) \\<sqsubseteq> G\""], ["proof (prove)\nusing this:\n  \\<forall>n.\n     set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<forall>n. set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G", "by -(rule, erule_tac x = \"Suc n\" in allE, auto simp add: ccProd_insert1[where S' = \"set xs\" for xs] join_below_iff)"], ["proof (state)\nthis:\n  \\<forall>n. set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq> G\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>set xs \\<subseteq> S;\n                 \\<forall>n.\n                    set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq>\n                    G\\<rbrakk>\n                \\<Longrightarrow> xs \\<in> valid_lists S G;\n        set (a # xs) \\<subseteq> S;\n        \\<forall>n.\n           set (take n (a # xs)) G\\<times>\n           set (drop n (a # xs)) \\<sqsubseteq>\n           G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "from Cons.prems Cons.IH[OF _ this]"], ["proof (chain)\npicking this:\n  set (x # xs) \\<subseteq> S\n  \\<forall>n.\n     set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G\n  set xs \\<subseteq> S \\<Longrightarrow> xs \\<in> valid_lists S G", "have \"xs \\<in> valid_lists S G\""], ["proof (prove)\nusing this:\n  set (x # xs) \\<subseteq> S\n  \\<forall>n.\n     set (take n (x # xs)) G\\<times> set (drop n (x # xs)) \\<sqsubseteq> G\n  set xs \\<subseteq> S \\<Longrightarrow> xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. xs \\<in> valid_lists S G", "by auto"], ["proof (state)\nthis:\n  xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>set xs \\<subseteq> S;\n                 \\<forall>n.\n                    set (take n xs) G\\<times> set (drop n xs) \\<sqsubseteq>\n                    G\\<rbrakk>\n                \\<Longrightarrow> xs \\<in> valid_lists S G;\n        set (a # xs) \\<subseteq> S;\n        \\<forall>n.\n           set (take n (a # xs)) G\\<times>\n           set (drop n (a # xs)) \\<sqsubseteq>\n           G\\<rbrakk>\n       \\<Longrightarrow> a # xs \\<in> valid_lists S G", "with Cons.prems(1)  spec[OF \\<open>\\<forall>n. ccProd (set (take n (x # xs))) (set (drop n (x # xs))) \\<sqsubseteq> G\\<close>, where x = 1]"], ["proof (chain)\npicking this:\n  set (x # xs) \\<subseteq> S\n  set (take 1 (x # xs)) G\\<times> set (drop 1 (x # xs)) \\<sqsubseteq> G\n  xs \\<in> valid_lists S G", "show ?case"], ["proof (prove)\nusing this:\n  set (x # xs) \\<subseteq> S\n  set (take 1 (x # xs)) G\\<times> set (drop 1 (x # xs)) \\<sqsubseteq> G\n  xs \\<in> valid_lists S G\n\ngoal (1 subgoal):\n 1. x # xs \\<in> valid_lists S G", "by (simp add: subset_ccNeighbors)"], ["proof (state)\nthis:\n  x # xs \\<in> valid_lists S G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs \\<in> valid_lists S G\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}