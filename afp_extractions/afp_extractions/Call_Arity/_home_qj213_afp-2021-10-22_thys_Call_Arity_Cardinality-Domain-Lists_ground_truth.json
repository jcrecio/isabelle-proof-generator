{"file_name": "/home/qj213/afp-2021-10-22/thys/Call_Arity/Cardinality-Domain-Lists.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Call_Arity", "problem_names": ["lemma no_call_in_path_set_conv:\n  \"no_call_in_path x p \\<longleftrightarrow> x \\<notin> set p\"", "lemma one_call_in_path_filter_conv:\n  \"one_call_in_path x p \\<longleftrightarrow> length (filter (\\<lambda> x'. x' = x) p) \\<le> 1\"", "lemma no_call_in_tail: \"no_call_in_path x (tl p) \\<longleftrightarrow> (no_call_in_path x p \\<or> one_call_in_path x p \\<and> hd p = x)\"", "lemma no_imp_one: \"no_call_in_path x p \\<Longrightarrow> one_call_in_path x p\"", "lemma one_imp_one_tail: \"one_call_in_path x p \\<Longrightarrow> one_call_in_path x (tl p)\"", "lemma more_than_one_setD:\n  \"\\<not> one_call_in_path x p \\<Longrightarrow> x \\<in> set p\"", "lemma no_call_in_path[eqvt]: \"no_call_in_path p x \\<Longrightarrow> no_call_in_path (\\<pi> \\<bullet> p) (\\<pi> \\<bullet> x)\"", "lemma one_call_in_path[eqvt]: \"one_call_in_path p x \\<Longrightarrow> one_call_in_path (\\<pi> \\<bullet> p) (\\<pi> \\<bullet> x)\"", "lemma pathCard_Nil[simp]: \"pathCard [] = \\<bottom>\"", "lemma pathCard_Cons[simp]: \"pathCard (x#xs) x = two_add\\<cdot>once\\<cdot>(pathCard xs x)\"", "lemma pathCard_Cons_other[simp]: \"x' \\<noteq> x \\<Longrightarrow> pathCard (x#xs) x' = pathCard xs x'\"", "lemma no_call_in_path_filter[simp]: \"no_call_in_path x [x\\<leftarrow>xs . x \\<in> S] \\<longleftrightarrow> no_call_in_path x xs \\<or> x \\<notin> S\"", "lemma one_call_in_path_filter[simp]: \"one_call_in_path x [x\\<leftarrow>xs . x \\<in> S] \\<longleftrightarrow> one_call_in_path x xs \\<or> x \\<notin> S\"", "lemma paths_Card_above:\n  \"p \\<in> ps \\<Longrightarrow> pathCard p \\<sqsubseteq> pathsCard ps\"", "lemma pathsCard_below:\n  assumes  \"\\<And> p. p \\<in> ps \\<Longrightarrow> pathCard p \\<sqsubseteq> ce\"\n  shows \"pathsCard ps \\<sqsubseteq> ce\"", "lemma pathsCard_mono:\n  \"ps \\<subseteq> ps' \\<Longrightarrow> pathsCard ps \\<sqsubseteq> pathsCard ps'\"", "lemmas pathsCard_mono' = pathsCard_mono[folded below_set_def]", "lemma record_call_pathsCard: \n  \"pathsCard ({ tl p | p . p \\<in> fs \\<and> hd p = x}) \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)\"", "lemma pathCards_noneD:\n  \"pathsCard ps x = none \\<Longrightarrow> x \\<notin> \\<Union>(set ` ps)\"", "lemma cont_pathsCard[THEN cont_compose, cont2cont, simp]:\n  \"cont pathsCard\"", "lemma pathsCard_eqvt[eqvt]: \"\\<pi> \\<bullet> pathsCard ps x = pathsCard (\\<pi> \\<bullet> ps) (\\<pi> \\<bullet> x)\"", "lemma edom_pathsCard[simp]: \"edom (pathsCard ps) = \\<Union>(set ` ps)\"", "lemma env_restr_pathsCard[simp]: \"pathsCard ps f|` S = pathsCard (filter (\\<lambda> x. x \\<in> S) ` ps)\""], "translations": [["", "lemma no_call_in_path_set_conv:\n  \"no_call_in_path x p \\<longleftrightarrow> x \\<notin> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_call_in_path x p = (x \\<notin> set p)", "by(induction p) auto"], ["", "lemma one_call_in_path_filter_conv:\n  \"one_call_in_path x p \\<longleftrightarrow> length (filter (\\<lambda> x'. x' = x) p) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_call_in_path x p = (length (filter (\\<lambda>x'. x' = x) p) \\<le> 1)", "by(induction p) (auto simp add: no_call_in_path_set_conv filter_empty_conv)"], ["", "lemma no_call_in_tail: \"no_call_in_path x (tl p) \\<longleftrightarrow> (no_call_in_path x p \\<or> one_call_in_path x p \\<and> hd p = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_call_in_path x (tl p) =\n    (no_call_in_path x p \\<or> one_call_in_path x p \\<and> hd p = x)", "by(induction p) auto"], ["", "lemma no_imp_one: \"no_call_in_path x p \\<Longrightarrow> one_call_in_path x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_call_in_path x p \\<Longrightarrow> one_call_in_path x p", "by (induction p) auto"], ["", "lemma one_imp_one_tail: \"one_call_in_path x p \\<Longrightarrow> one_call_in_path x (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_call_in_path x p \\<Longrightarrow> one_call_in_path x (tl p)", "by (induction p) (auto split: if_splits intro: no_imp_one)"], ["", "lemma more_than_one_setD:\n  \"\\<not> one_call_in_path x p \\<Longrightarrow> x \\<in> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> one_call_in_path x p \\<Longrightarrow> x \\<in> set p", "by (induction p) (auto split: if_splits)"], ["", "lemma no_call_in_path[eqvt]: \"no_call_in_path p x \\<Longrightarrow> no_call_in_path (\\<pi> \\<bullet> p) (\\<pi> \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_call_in_path p x \\<Longrightarrow>\n    no_call_in_path (\\<pi> \\<bullet> p) (\\<pi> \\<bullet> x)", "by (induction p x rule: no_call_in_path.induct) auto"], ["", "lemma one_call_in_path[eqvt]: \"one_call_in_path p x \\<Longrightarrow> one_call_in_path (\\<pi> \\<bullet> p) (\\<pi> \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_call_in_path p x \\<Longrightarrow>\n    one_call_in_path (\\<pi> \\<bullet> p) (\\<pi> \\<bullet> x)", "by (induction p x rule: one_call_in_path.induct) (auto dest: no_call_in_path)"], ["", "definition pathCard :: \"var list  \\<Rightarrow> (var \\<Rightarrow> two)\"\n  where \"pathCard p x = (if no_call_in_path x p then none else (if one_call_in_path x p then once else many))\""], ["", "lemma pathCard_Nil[simp]: \"pathCard [] = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathCard [] = \\<bottom>", "by rule (simp add: pathCard_def)"], ["", "lemma pathCard_Cons[simp]: \"pathCard (x#xs) x = two_add\\<cdot>once\\<cdot>(pathCard xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathCard (x # xs) x = two_add\\<cdot>once\\<cdot>(pathCard xs x)", "unfolding pathCard_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if no_call_in_path x (x # xs) then none\n     else if one_call_in_path x (x # xs) then once else many) =\n    two_add\\<cdot>once\\<cdot>\n    (if no_call_in_path x xs then none\n     else if one_call_in_path x xs then once else many)", "by (auto simp add: two_add_simp)"], ["", "lemma pathCard_Cons_other[simp]: \"x' \\<noteq> x \\<Longrightarrow> pathCard (x#xs) x' = pathCard xs x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<noteq> x \\<Longrightarrow> pathCard (x # xs) x' = pathCard xs x'", "unfolding pathCard_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<noteq> x \\<Longrightarrow>\n    (if no_call_in_path x' (x # xs) then none\n     else if one_call_in_path x' (x # xs) then once else many) =\n    (if no_call_in_path x' xs then none\n     else if one_call_in_path x' xs then once else many)", "by auto"], ["", "lemma no_call_in_path_filter[simp]: \"no_call_in_path x [x\\<leftarrow>xs . x \\<in> S] \\<longleftrightarrow> no_call_in_path x xs \\<or> x \\<notin> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_call_in_path x (filter (\\<lambda>x. x \\<in> S) xs) =\n    (no_call_in_path x xs \\<or> x \\<notin> S)", "by (induction xs) auto"], ["", "lemma one_call_in_path_filter[simp]: \"one_call_in_path x [x\\<leftarrow>xs . x \\<in> S] \\<longleftrightarrow> one_call_in_path x xs \\<or> x \\<notin> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_call_in_path x (filter (\\<lambda>x. x \\<in> S) xs) =\n    (one_call_in_path x xs \\<or> x \\<notin> S)", "by (induction xs) auto"], ["", "definition pathsCard :: \"var list set \\<Rightarrow> (var \\<Rightarrow> two)\"\n  where \"pathsCard ps x = (if (\\<forall> p \\<in> ps. no_call_in_path x p) then none else (if (\\<forall> p\\<in>ps. one_call_in_path x p) then once else many))\""], ["", "lemma paths_Card_above:\n  \"p \\<in> ps \\<Longrightarrow> pathCard p \\<sqsubseteq> pathsCard ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> ps \\<Longrightarrow> pathCard p \\<sqsubseteq> pathsCard ps", "by (rule fun_belowI) (auto simp add: pathsCard_def pathCard_def)"], ["", "lemma pathsCard_below:\n  assumes  \"\\<And> p. p \\<in> ps \\<Longrightarrow> pathCard p \\<sqsubseteq> ce\"\n  shows \"pathsCard ps \\<sqsubseteq> ce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathsCard ps \\<sqsubseteq> ce", "proof(rule fun_belowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. pathsCard ps x \\<sqsubseteq> ce x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. pathsCard ps x \\<sqsubseteq> ce x", "show \"pathsCard ps x \\<sqsubseteq> ce x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathsCard ps x \\<sqsubseteq> ce x", "by (auto simp add: pathsCard_def pathCard_def split: if_splits dest!: fun_belowD[OF assms, where x = x] elim: below_trans[rotated] dest: no_imp_one)"], ["proof (state)\nthis:\n  pathsCard ps x \\<sqsubseteq> ce x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pathsCard_mono:\n  \"ps \\<subseteq> ps' \\<Longrightarrow> pathsCard ps \\<sqsubseteq> pathsCard ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<subseteq> ps' \\<Longrightarrow>\n    pathsCard ps \\<sqsubseteq> pathsCard ps'", "by (auto intro: pathsCard_below paths_Card_above)"], ["", "lemmas pathsCard_mono' = pathsCard_mono[folded below_set_def]"], ["", "lemma record_call_pathsCard: \n  \"pathsCard ({ tl p | p . p \\<in> fs \\<and> hd p = x}) \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathsCard {tl p |p. p \\<in> fs \\<and> hd p = x} \\<sqsubseteq>\n    record_call x\\<cdot>(pathsCard fs)", "proof (rule pathsCard_below)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> {tl p |p. p \\<in> fs \\<and> hd p = x} \\<Longrightarrow>\n       pathCard p \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)", "fix p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> {tl p |p. p \\<in> fs \\<and> hd p = x} \\<Longrightarrow>\n       pathCard p \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)", "assume \"p' \\<in> {tl p |p. p \\<in> fs \\<and> hd p = x}\""], ["proof (state)\nthis:\n  p' \\<in> {tl p |p. p \\<in> fs \\<and> hd p = x}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> {tl p |p. p \\<in> fs \\<and> hd p = x} \\<Longrightarrow>\n       pathCard p \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)", "then"], ["proof (chain)\npicking this:\n  p' \\<in> {tl p |p. p \\<in> fs \\<and> hd p = x}", "obtain p where \"p' = tl p\" and \"p \\<in> fs\" and \"hd p = x\""], ["proof (prove)\nusing this:\n  p' \\<in> {tl p |p. p \\<in> fs \\<and> hd p = x}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p' = tl p; p \\<in> fs; hd p = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p' = tl p\n  p \\<in> fs\n  hd p = x\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> {tl p |p. p \\<in> fs \\<and> hd p = x} \\<Longrightarrow>\n       pathCard p \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)", "have \"pathCard (tl p) \\<sqsubseteq> record_call x\\<cdot>(pathCard p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathCard (tl p) \\<sqsubseteq> record_call x\\<cdot>(pathCard p)", "apply (rule fun_belowI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       pathCard (tl p) xa \\<sqsubseteq>\n       (record_call x\\<cdot>(pathCard p)) xa", "using \\<open>hd p = x\\<close>"], ["proof (prove)\nusing this:\n  hd p = x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       pathCard (tl p) xa \\<sqsubseteq>\n       (record_call x\\<cdot>(pathCard p)) xa", "by (auto simp add: pathCard_def record_call_simp no_call_in_tail dest: one_imp_one_tail)"], ["proof (state)\nthis:\n  pathCard (tl p) \\<sqsubseteq> record_call x\\<cdot>(pathCard p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> {tl p |p. p \\<in> fs \\<and> hd p = x} \\<Longrightarrow>\n       pathCard p \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)", "hence \"pathCard (tl p) \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)\""], ["proof (prove)\nusing this:\n  pathCard (tl p) \\<sqsubseteq> record_call x\\<cdot>(pathCard p)\n\ngoal (1 subgoal):\n 1. pathCard (tl p) \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)", "by (rule below_trans[OF _ monofun_cfun_arg[OF  paths_Card_above[OF \\<open>p \\<in> fs\\<close>]]])"], ["proof (state)\nthis:\n  pathCard (tl p) \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> {tl p |p. p \\<in> fs \\<and> hd p = x} \\<Longrightarrow>\n       pathCard p \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)", "thus \"pathCard p' \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)\""], ["proof (prove)\nusing this:\n  pathCard (tl p) \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)\n\ngoal (1 subgoal):\n 1. pathCard p' \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)", "using \\<open>p' = _\\<close>"], ["proof (prove)\nusing this:\n  pathCard (tl p) \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)\n  p' = tl p\n\ngoal (1 subgoal):\n 1. pathCard p' \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)", "by simp"], ["proof (state)\nthis:\n  pathCard p' \\<sqsubseteq> record_call x\\<cdot>(pathsCard fs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pathCards_noneD:\n  \"pathsCard ps x = none \\<Longrightarrow> x \\<notin> \\<Union>(set ` ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathsCard ps x = none \\<Longrightarrow> x \\<notin> \\<Union> (set ` ps)", "by (auto simp add: pathsCard_def no_call_in_path_set_conv split:if_splits)"], ["", "lemma cont_pathsCard[THEN cont_compose, cont2cont, simp]:\n  \"cont pathsCard\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont pathsCard", "by(fastforce intro!: cont2cont_lambda cont_if_else_above simp add: pathsCard_def below_set_def)"], ["", "lemma pathsCard_eqvt[eqvt]: \"\\<pi> \\<bullet> pathsCard ps x = pathsCard (\\<pi> \\<bullet> ps) (\\<pi> \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> pathsCard ps x =\n    pathsCard (\\<pi> \\<bullet> ps) (\\<pi> \\<bullet> x)", "unfolding pathsCard_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> (if Ball ps (no_call_in_path x) then none\n                     else if Ball ps (one_call_in_path x) then once\n                          else many) =\n    (if Ball (\\<pi> \\<bullet> ps) (no_call_in_path (\\<pi> \\<bullet> x))\n     then none\n     else if Ball (\\<pi> \\<bullet> ps)\n              (one_call_in_path (\\<pi> \\<bullet> x))\n          then once else many)", "by perm_simp rule"], ["", "lemma edom_pathsCard[simp]: \"edom (pathsCard ps) = \\<Union>(set ` ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edom (pathsCard ps) = \\<Union> (set ` ps)", "unfolding edom_def pathsCard_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. (if Ball ps (no_call_in_path x) then none\n         else if Ball ps (one_call_in_path x) then once else many) \\<noteq>\n        none} =\n    \\<Union> (set ` ps)", "by (auto simp add:  no_call_in_path_set_conv)"], ["", "lemma env_restr_pathsCard[simp]: \"pathsCard ps f|` S = pathsCard (filter (\\<lambda> x. x \\<in> S) ` ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathsCard ps f|` S = pathsCard (filter (\\<lambda>x. x \\<in> S) ` ps)", "by (auto simp add: pathsCard_def lookup_env_restr_eq)"], ["", "end"]]}