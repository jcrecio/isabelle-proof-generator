{"file_name": "/home/qj213/afp-2021-10-22/thys/Call_Arity/AbstractTransform.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Call_Arity", "problem_names": ["lemma supp_transform: \"supp (transform a e) \\<subseteq> supp e\"", "lemma fv_transform: \"fv (transform a e) \\<subseteq> fv e\"", "lemma subst_transform: \"(transform a e)[x ::= y] = transform a e[x ::= y]\"", "lemma isLam_transform[simp]:\n    \"isLam (transform a e) \\<longleftrightarrow> isLam e\"", "lemma isVal_transform[simp]:\n    \"isVal (transform a e) \\<longleftrightarrow> isVal e\""], "translations": [["", "lemma supp_transform: \"supp (transform a e) \\<subseteq> supp e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (transform a e) \\<subseteq> supp e", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. supp (transform a e) \\<subseteq> supp e", "note PropApp_eqvt[eqvt_raw] PropLam_eqvt[eqvt_raw] PropLetBody_eqvt[eqvt_raw]  AnalLet_eqvt[eqvt_raw] PropLetHeap_eqvt[eqvt_raw] TransVar_eqvt[eqvt]  TransApp_eqvt[eqvt]  TransLam_eqvt[eqvt] TransLet_eqvt[eqvt]"], ["proof (state)\nthis:\n  ?\\<pi> \\<bullet> PropApp \\<equiv> PropApp\n  ?\\<pi> \\<bullet> PropLam \\<equiv> PropLam\n  ?\\<pi> \\<bullet> PropLetBody \\<equiv> PropLetBody\n  ?\\<pi> \\<bullet> AnalLet \\<equiv> AnalLet\n  ?\\<pi> \\<bullet> PropLetHeap \\<equiv> PropLetHeap\n  ?\\<pi> \\<bullet> TransVar = TransVar\n  ?\\<pi> \\<bullet> TransApp = TransApp\n  ?\\<pi> \\<bullet> TransLam = TransLam\n  ?\\<pi> \\<bullet> TransLet = TransLet\n\ngoal (1 subgoal):\n 1. supp (transform a e) \\<subseteq> supp e", "note transform.eqvt[eqvt]"], ["proof (state)\nthis:\n  ?p \\<bullet> transform ?a ?aa =\n  transform (?p \\<bullet> ?a) (?p \\<bullet> ?aa)\n\ngoal (1 subgoal):\n 1. supp (transform a e) \\<subseteq> supp e", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (transform a e) \\<subseteq> supp e", "apply (rule supp_fun_app_eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt (transform a)", "apply (rule eqvtI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<bullet> transform a \\<equiv> transform a", "apply perm_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. transform a \\<equiv> transform a", "apply (rule reflexive)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  supp (transform a e) \\<subseteq> supp e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fv_transform: \"fv (transform a e) \\<subseteq> fv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (transform a e) \\<subseteq> fv e", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. atom v \\<in> supp (transform a e)}\n    \\<subseteq> {v. atom v \\<in> supp e}", "by (auto dest: subsetD[OF supp_transform])"], ["", "end"], ["", "locale AbstractTransformSubst = AbstractTransform + AbstractAnalPropSubst +\n  assumes TransVar_subst: \"(TransVar a v)[x ::= y] = (TransVar a v[x ::v= y])\"\n  assumes TransApp_subst: \"(TransApp a e v)[x ::= y] = (TransApp a e[x ::= y] v[x ::v= y])\"\n  assumes TransLam_subst: \"atom v \\<sharp> (x,y) \\<Longrightarrow> (TransLam a v e)[x ::= y] = (TransLam a v[x ::v= y] e[x ::= y])\"\n  assumes TransLet_subst: \"atom ` domA \\<Gamma> \\<sharp>* (x,y) \\<Longrightarrow> (TransLet b \\<Gamma> e)[x ::= y] = (TransLet b \\<Gamma>[x ::h= y] e[x ::= y])\"\nbegin"], ["", "lemma subst_transform: \"(transform a e)[x ::= y] = transform a e[x ::= y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (transform a e)[x::=y] = transform a e[x::=y]", "proof (nominal_induct e avoiding: x y arbitrary: a  rule: exp_strong_induct_set)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>var x y a.\n       (transform a (Var var))[x::=y] = transform a (Var var)[x::=y]\n 2. \\<And>exp var x y a.\n       (\\<And>b ba a.\n           (transform a exp)[b::=ba] =\n           transform a exp[b::=ba]) \\<Longrightarrow>\n       (transform a (App exp var))[x::=y] = transform a (App exp var)[x::=y]\n 3. \\<And>\\<Gamma> exp x y a.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* x;\n        atom ` domA \\<Gamma> \\<sharp>* y;\n        \\<And>b ba x e a.\n           (x, e) \\<in> set \\<Gamma> \\<Longrightarrow>\n           (transform a e)[b::=ba] = transform a e[b::=ba];\n        \\<And>b ba a.\n           (transform a exp)[b::=ba] = transform a exp[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (Terms.Let \\<Gamma> exp))[x::=y] =\n                         transform a (Terms.Let \\<Gamma> exp)[x::=y]\n 4. \\<And>var exp x y a.\n       \\<lbrakk>atom var \\<sharp> x; atom var \\<sharp> y;\n        \\<And>b ba a.\n           (transform a exp)[b::=ba] = transform a exp[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (Lam [var]. exp))[x::=y] =\n                         transform a (Lam [var]. exp)[x::=y]\n 5. \\<And>b x y a.\n       (transform a (Bool b))[x::=y] = transform a (Bool b)[x::=y]\n 6. \\<And>scrut e1 e2 x y a.\n       \\<lbrakk>\\<And>b ba a.\n                   (transform a scrut)[b::=ba] = transform a scrut[b::=ba];\n        \\<And>b ba a. (transform a e1)[b::=ba] = transform a e1[b::=ba];\n        \\<And>b ba a.\n           (transform a e2)[b::=ba] = transform a e2[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (scrut ? e1 : e2))[x::=y] =\n                         transform a (scrut ? e1 : e2)[x::=y]", "case (Let \\<Delta> body x y)"], ["proof (state)\nthis:\n  atom ` domA \\<Delta> \\<sharp>* x\n  atom ` domA \\<Delta> \\<sharp>* y\n  (?x, ?e) \\<in> set \\<Delta> \\<Longrightarrow>\n  (transform ?a ?e)[?b::=?ba] = transform ?a ?e[?b::=?ba]\n  (transform ?a body)[?b::=?ba] = transform ?a body[?b::=?ba]\n\ngoal (6 subgoals):\n 1. \\<And>var x y a.\n       (transform a (Var var))[x::=y] = transform a (Var var)[x::=y]\n 2. \\<And>exp var x y a.\n       (\\<And>b ba a.\n           (transform a exp)[b::=ba] =\n           transform a exp[b::=ba]) \\<Longrightarrow>\n       (transform a (App exp var))[x::=y] = transform a (App exp var)[x::=y]\n 3. \\<And>\\<Gamma> exp x y a.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* x;\n        atom ` domA \\<Gamma> \\<sharp>* y;\n        \\<And>b ba x e a.\n           (x, e) \\<in> set \\<Gamma> \\<Longrightarrow>\n           (transform a e)[b::=ba] = transform a e[b::=ba];\n        \\<And>b ba a.\n           (transform a exp)[b::=ba] = transform a exp[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (Terms.Let \\<Gamma> exp))[x::=y] =\n                         transform a (Terms.Let \\<Gamma> exp)[x::=y]\n 4. \\<And>var exp x y a.\n       \\<lbrakk>atom var \\<sharp> x; atom var \\<sharp> y;\n        \\<And>b ba a.\n           (transform a exp)[b::=ba] = transform a exp[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (Lam [var]. exp))[x::=y] =\n                         transform a (Lam [var]. exp)[x::=y]\n 5. \\<And>b x y a.\n       (transform a (Bool b))[x::=y] = transform a (Bool b)[x::=y]\n 6. \\<And>scrut e1 e2 x y a.\n       \\<lbrakk>\\<And>b ba a.\n                   (transform a scrut)[b::=ba] = transform a scrut[b::=ba];\n        \\<And>b ba a. (transform a e1)[b::=ba] = transform a e1[b::=ba];\n        \\<And>b ba a.\n           (transform a e2)[b::=ba] = transform a e2[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (scrut ? e1 : e2))[x::=y] =\n                         transform a (scrut ? e1 : e2)[x::=y]", "hence *: \"x \\<notin> domA \\<Delta>\" \"y \\<notin> domA \\<Delta>\""], ["proof (prove)\nusing this:\n  atom ` domA \\<Delta> \\<sharp>* x\n  atom ` domA \\<Delta> \\<sharp>* y\n  (?x, ?e) \\<in> set \\<Delta> \\<Longrightarrow>\n  (transform ?a ?e)[?b::=?ba] = transform ?a ?e[?b::=?ba]\n  (transform ?a body)[?b::=?ba] = transform ?a body[?b::=?ba]\n\ngoal (1 subgoal):\n 1. x \\<notin> domA \\<Delta> &&& y \\<notin> domA \\<Delta>", "by (auto simp add: fresh_star_def fresh_at_base)"], ["proof (state)\nthis:\n  x \\<notin> domA \\<Delta>\n  y \\<notin> domA \\<Delta>\n\ngoal (6 subgoals):\n 1. \\<And>var x y a.\n       (transform a (Var var))[x::=y] = transform a (Var var)[x::=y]\n 2. \\<And>exp var x y a.\n       (\\<And>b ba a.\n           (transform a exp)[b::=ba] =\n           transform a exp[b::=ba]) \\<Longrightarrow>\n       (transform a (App exp var))[x::=y] = transform a (App exp var)[x::=y]\n 3. \\<And>\\<Gamma> exp x y a.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* x;\n        atom ` domA \\<Gamma> \\<sharp>* y;\n        \\<And>b ba x e a.\n           (x, e) \\<in> set \\<Gamma> \\<Longrightarrow>\n           (transform a e)[b::=ba] = transform a e[b::=ba];\n        \\<And>b ba a.\n           (transform a exp)[b::=ba] = transform a exp[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (Terms.Let \\<Gamma> exp))[x::=y] =\n                         transform a (Terms.Let \\<Gamma> exp)[x::=y]\n 4. \\<And>var exp x y a.\n       \\<lbrakk>atom var \\<sharp> x; atom var \\<sharp> y;\n        \\<And>b ba a.\n           (transform a exp)[b::=ba] = transform a exp[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (Lam [var]. exp))[x::=y] =\n                         transform a (Lam [var]. exp)[x::=y]\n 5. \\<And>b x y a.\n       (transform a (Bool b))[x::=y] = transform a (Bool b)[x::=y]\n 6. \\<And>scrut e1 e2 x y a.\n       \\<lbrakk>\\<And>b ba a.\n                   (transform a scrut)[b::=ba] = transform a scrut[b::=ba];\n        \\<And>b ba a. (transform a e1)[b::=ba] = transform a e1[b::=ba];\n        \\<And>b ba a.\n           (transform a e2)[b::=ba] = transform a e2[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (scrut ? e1 : e2))[x::=y] =\n                         transform a (scrut ? e1 : e2)[x::=y]", "hence \"AnalLet \\<Delta>[x::h=y] body[x::=y] a = AnalLet \\<Delta> body a\""], ["proof (prove)\nusing this:\n  x \\<notin> domA \\<Delta>\n  y \\<notin> domA \\<Delta>\n\ngoal (1 subgoal):\n 1. AnalLet \\<Delta>[x::h=y] body[x::=y] a = AnalLet \\<Delta> body a", "by (rule AnalLet_subst)"], ["proof (state)\nthis:\n  AnalLet \\<Delta>[x::h=y] body[x::=y] a = AnalLet \\<Delta> body a\n\ngoal (6 subgoals):\n 1. \\<And>var x y a.\n       (transform a (Var var))[x::=y] = transform a (Var var)[x::=y]\n 2. \\<And>exp var x y a.\n       (\\<And>b ba a.\n           (transform a exp)[b::=ba] =\n           transform a exp[b::=ba]) \\<Longrightarrow>\n       (transform a (App exp var))[x::=y] = transform a (App exp var)[x::=y]\n 3. \\<And>\\<Gamma> exp x y a.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* x;\n        atom ` domA \\<Gamma> \\<sharp>* y;\n        \\<And>b ba x e a.\n           (x, e) \\<in> set \\<Gamma> \\<Longrightarrow>\n           (transform a e)[b::=ba] = transform a e[b::=ba];\n        \\<And>b ba a.\n           (transform a exp)[b::=ba] = transform a exp[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (Terms.Let \\<Gamma> exp))[x::=y] =\n                         transform a (Terms.Let \\<Gamma> exp)[x::=y]\n 4. \\<And>var exp x y a.\n       \\<lbrakk>atom var \\<sharp> x; atom var \\<sharp> y;\n        \\<And>b ba a.\n           (transform a exp)[b::=ba] = transform a exp[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (Lam [var]. exp))[x::=y] =\n                         transform a (Lam [var]. exp)[x::=y]\n 5. \\<And>b x y a.\n       (transform a (Bool b))[x::=y] = transform a (Bool b)[x::=y]\n 6. \\<And>scrut e1 e2 x y a.\n       \\<lbrakk>\\<And>b ba a.\n                   (transform a scrut)[b::=ba] = transform a scrut[b::=ba];\n        \\<And>b ba a. (transform a e1)[b::=ba] = transform a e1[b::=ba];\n        \\<And>b ba a.\n           (transform a e2)[b::=ba] = transform a e2[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (scrut ? e1 : e2))[x::=y] =\n                         transform a (scrut ? e1 : e2)[x::=y]", "with Let"], ["proof (chain)\npicking this:\n  atom ` domA \\<Delta> \\<sharp>* x\n  atom ` domA \\<Delta> \\<sharp>* y\n  (?x, ?e) \\<in> set \\<Delta> \\<Longrightarrow>\n  (transform ?a ?e)[?b::=?ba] = transform ?a ?e[?b::=?ba]\n  (transform ?a body)[?b::=?ba] = transform ?a body[?b::=?ba]\n  AnalLet \\<Delta>[x::h=y] body[x::=y] a = AnalLet \\<Delta> body a", "show ?case"], ["proof (prove)\nusing this:\n  atom ` domA \\<Delta> \\<sharp>* x\n  atom ` domA \\<Delta> \\<sharp>* y\n  (?x, ?e) \\<in> set \\<Delta> \\<Longrightarrow>\n  (transform ?a ?e)[?b::=?ba] = transform ?a ?e[?b::=?ba]\n  (transform ?a body)[?b::=?ba] = transform ?a body[?b::=?ba]\n  AnalLet \\<Delta>[x::h=y] body[x::=y] a = AnalLet \\<Delta> body a\n\ngoal (1 subgoal):\n 1. (transform a (Terms.Let \\<Delta> body))[x::=y] =\n    transform a (Terms.Let \\<Delta> body)[x::=y]", "apply (auto simp add: fresh_star_Pair TransLet_subst simp del: Let_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* x;\n     atom ` domA \\<Delta> \\<sharp>* y;\n     \\<And>x e a b ba.\n        (x, e) \\<in> set \\<Delta> \\<Longrightarrow>\n        (transform a e)[b::=ba] = transform a e[b::=ba];\n     \\<And>a b ba. (transform a body)[b::=ba] = transform a body[b::=ba];\n     AnalLet \\<Delta>[x::h=y] body[x::=y] a =\n     AnalLet \\<Delta> body a\\<rbrakk>\n    \\<Longrightarrow> TransLet (AnalLet \\<Delta> body a)\n                       (map_transform transform\n                         (PropLetHeap (AnalLet \\<Delta> body a))\n                         \\<Delta>)[x::h=y]\n                       (transform (PropLetBody (AnalLet \\<Delta> body a))\n                         body[x::=y]) =\n                      TransLet (AnalLet \\<Delta> body a)\n                       (map_transform transform\n                         (PropLetHeap (AnalLet \\<Delta> body a))\n                         \\<Delta>[x::h=y])\n                       (transform (PropLetBody (AnalLet \\<Delta> body a))\n                         body[x::=y])", "apply (rule fun_cong[OF arg_cong[where f = \"TransLet b\" for b]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* x;\n     atom ` domA \\<Delta> \\<sharp>* y;\n     \\<And>x e a b ba.\n        (x, e) \\<in> set \\<Delta> \\<Longrightarrow>\n        (transform a e)[b::=ba] = transform a e[b::=ba];\n     \\<And>a b ba. (transform a body)[b::=ba] = transform a body[b::=ba];\n     AnalLet \\<Delta>[x::h=y] body[x::=y] a =\n     AnalLet \\<Delta> body a\\<rbrakk>\n    \\<Longrightarrow> (map_transform transform\n                        (PropLetHeap (AnalLet \\<Delta> body a))\n                        \\<Delta>)[x::h=y] =\n                      map_transform transform\n                       (PropLetHeap (AnalLet \\<Delta> body a))\n                       \\<Delta>[x::h=y]", "apply (rule subst_map_transform)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x' e a.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* x;\n        atom ` domA \\<Delta> \\<sharp>* y;\n        \\<And>x e a b ba.\n           (x, e) \\<in> set \\<Delta> \\<Longrightarrow>\n           (transform a e)[b::=ba] = transform a e[b::=ba];\n        \\<And>a b ba. (transform a body)[b::=ba] = transform a body[b::=ba];\n        AnalLet \\<Delta>[x::h=y] body[x::=y] a = AnalLet \\<Delta> body a;\n        (x', e) \\<in> set \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> (transform a e)[x::=y] = transform a e[x::=y]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (transform a (Terms.Let \\<Delta> body))[x::=y] =\n  transform a (Terms.Let \\<Delta> body)[x::=y]\n\ngoal (5 subgoals):\n 1. \\<And>var x y a.\n       (transform a (Var var))[x::=y] = transform a (Var var)[x::=y]\n 2. \\<And>exp var x y a.\n       (\\<And>b ba a.\n           (transform a exp)[b::=ba] =\n           transform a exp[b::=ba]) \\<Longrightarrow>\n       (transform a (App exp var))[x::=y] = transform a (App exp var)[x::=y]\n 3. \\<And>var exp x y a.\n       \\<lbrakk>atom var \\<sharp> x; atom var \\<sharp> y;\n        \\<And>b ba a.\n           (transform a exp)[b::=ba] = transform a exp[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (Lam [var]. exp))[x::=y] =\n                         transform a (Lam [var]. exp)[x::=y]\n 4. \\<And>b x y a.\n       (transform a (Bool b))[x::=y] = transform a (Bool b)[x::=y]\n 5. \\<And>scrut e1 e2 x y a.\n       \\<lbrakk>\\<And>b ba a.\n                   (transform a scrut)[b::=ba] = transform a scrut[b::=ba];\n        \\<And>b ba a. (transform a e1)[b::=ba] = transform a e1[b::=ba];\n        \\<And>b ba a.\n           (transform a e2)[b::=ba] = transform a e2[b::=ba]\\<rbrakk>\n       \\<Longrightarrow> (transform a (scrut ? e1 : e2))[x::=y] =\n                         transform a (scrut ? e1 : e2)[x::=y]", "qed (simp_all add: TransVar_subst TransApp_subst TransLam_subst)"], ["", "end"], ["", "locale AbstractTransformBound = AbstractAnalProp + supp_bounded_transform  +\n  constrains PropApp :: \"'a \\<Rightarrow> 'a::pure_cont_pt\"\n  constrains PropLetHeap :: \"'b::cont_pt \\<Rightarrow> var \\<Rightarrow> 'a\\<^sub>\\<bottom>\"\n  constrains trans :: \"'c::cont_pt \\<Rightarrow> exp \\<Rightarrow> exp\"\n  fixes PropLetHeapTrans :: \"'b\\<Rightarrow> var \\<Rightarrow> 'c\\<^sub>\\<bottom>\"\n  assumes PropLetHeapTrans_eqvt: \"\\<pi> \\<bullet> PropLetHeapTrans = PropLetHeapTrans\"\n  assumes TransBound_eqvt: \"\\<pi> \\<bullet> trans = trans\"\nbegin"], ["", "sublocale AbstractTransform PropApp PropLam AnalLet PropLetBody PropLetHeap PropIfScrut\n      \"(\\<lambda> a. Var)\"\n      \"(\\<lambda> a. App)\"\n      \"(\\<lambda> a. Terms.Lam)\"\n      \"(\\<lambda> b \\<Gamma> e . Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AbstractTransform PropApp PropLam AnalLet PropLetBody PropLetHeap\n     PropIfScrut (\\<lambda>a. Var) (\\<lambda>a. App) (\\<lambda>a. Lam)\n     (\\<lambda>b \\<Gamma>.\n         Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. AbstractTransform PropApp PropLam AnalLet PropLetBody PropLetHeap\n     PropIfScrut (\\<lambda>a. Var) (\\<lambda>a. App) (\\<lambda>a. Lam)\n     (\\<lambda>b \\<Gamma>.\n         Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. AbstractTransform PropApp PropLam AnalLet PropLetBody PropLetHeap\n     PropIfScrut (\\<lambda>a. Var) (\\<lambda>a. App) (\\<lambda>a. Lam)\n     (\\<lambda>b \\<Gamma>.\n         Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>))", "note PropApp_eqvt[eqvt_raw] PropLam_eqvt[eqvt_raw] PropLetBody_eqvt[eqvt_raw] PropLetHeap_eqvt[eqvt_raw] PropIfScrut_eqvt[eqvt_raw]\n        AnalLet_eqvt[eqvt_raw] PropLetHeapTrans_eqvt[eqvt] TransBound_eqvt[eqvt]"], ["proof (state)\nthis:\n  ?\\<pi> \\<bullet> PropApp \\<equiv> PropApp\n  ?\\<pi> \\<bullet> PropLam \\<equiv> PropLam\n  ?\\<pi> \\<bullet> PropLetBody \\<equiv> PropLetBody\n  ?\\<pi> \\<bullet> PropLetHeap \\<equiv> PropLetHeap\n  ?\\<pi> \\<bullet> PropIfScrut \\<equiv> PropIfScrut\n  ?\\<pi> \\<bullet> AnalLet \\<equiv> AnalLet\n  ?\\<pi> \\<bullet> PropLetHeapTrans = PropLetHeapTrans\n  ?\\<pi> \\<bullet> trans = trans\n\ngoal (1 subgoal):\n 1. AbstractTransform PropApp PropLam AnalLet PropLetBody PropLetHeap\n     PropIfScrut (\\<lambda>a. Var) (\\<lambda>a. App) (\\<lambda>a. Lam)\n     (\\<lambda>b \\<Gamma>.\n         Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. AbstractTransform PropApp PropLam AnalLet PropLetBody PropLetHeap\n     PropIfScrut (\\<lambda>a. Var) (\\<lambda>a. App) (\\<lambda>a. Lam)\n     (\\<lambda>b \\<Gamma>.\n         Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>))", "apply standard"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>\\<pi>. \\<pi> \\<bullet> (\\<lambda>a. Var) = (\\<lambda>a. Var)\n 2. \\<And>\\<pi>. \\<pi> \\<bullet> (\\<lambda>a. App) = (\\<lambda>a. App)\n 3. \\<And>\\<pi>. \\<pi> \\<bullet> (\\<lambda>a. Lam) = (\\<lambda>a. Lam)\n 4. \\<And>\\<pi>.\n       \\<pi> \\<bullet> (\\<lambda>b \\<Gamma>.\n                           Terms.Let\n                            (map_transform trans (PropLetHeapTrans b)\n                              \\<Gamma>)) =\n       (\\<lambda>b \\<Gamma>.\n           Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>))\n 5. \\<And>a v e. supp (Lam [v]. e) \\<subseteq> supp e - supp v\n 6. \\<And>b \\<Gamma> e.\n       supp\n        (Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>) e)\n       \\<subseteq> supp (\\<Gamma>, e) - atom ` domA \\<Gamma>", "apply ((perm_simp, rule)+)[4]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a v e. supp (Lam [v]. e) \\<subseteq> supp e - supp v\n 2. \\<And>b \\<Gamma> e.\n       supp\n        (Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>) e)\n       \\<subseteq> supp (\\<Gamma>, e) - atom ` domA \\<Gamma>", "apply (auto simp add: exp_assn.supp supp_at_base)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b \\<Gamma> e.\n       supp\n        (Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>) e)\n       \\<subseteq> supp (\\<Gamma>, e) - atom ` domA \\<Gamma>", "apply (auto simp add: Let_supp supp_Pair supp_at_base dest: subsetD[OF supp_map_transform])[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  AbstractTransform PropApp PropLam AnalLet PropLetBody PropLetHeap\n   PropIfScrut (\\<lambda>a. Var) (\\<lambda>a. App) (\\<lambda>a. Lam)\n   (\\<lambda>b \\<Gamma>.\n       Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isLam_transform[simp]:\n    \"isLam (transform a e) \\<longleftrightarrow> isLam e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isLam (transform a e) = isLam e", "by (induction e rule:isLam.induct) auto"], ["", "lemma isVal_transform[simp]:\n    \"isVal (transform a e) \\<longleftrightarrow> isVal e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isVal (transform a e) = isVal e", "by (induction e rule:isLam.induct) auto"], ["", "end"], ["", "locale AbstractTransformBoundSubst = AbstractAnalPropSubst + AbstractTransformBound + \n  assumes TransBound_subst: \"(trans a e)[x::=y] = trans a e[x::=y]\"\nbegin"], ["", "sublocale AbstractTransformSubst PropApp PropLam AnalLet PropLetBody PropLetHeap PropIfScrut\n      \"(\\<lambda> a. Var)\"\n      \"(\\<lambda> a. App)\"\n      \"(\\<lambda> a. Terms.Lam)\"\n      \"(\\<lambda> b \\<Gamma> e . Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AbstractTransformSubst PropApp PropLam AnalLet PropLetBody PropLetHeap\n     PropIfScrut (\\<lambda>a. Var) (\\<lambda>a. App) (\\<lambda>a. Lam)\n     (\\<lambda>b \\<Gamma>.\n         Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. AbstractTransformSubst PropApp PropLam AnalLet PropLetBody PropLetHeap\n     PropIfScrut (\\<lambda>a. Var) (\\<lambda>a. App) (\\<lambda>a. Lam)\n     (\\<lambda>b \\<Gamma>.\n         Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. AbstractTransformSubst PropApp PropLam AnalLet PropLetBody PropLetHeap\n     PropIfScrut (\\<lambda>a. Var) (\\<lambda>a. App) (\\<lambda>a. Lam)\n     (\\<lambda>b \\<Gamma>.\n         Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>))", "note PropApp_eqvt[eqvt_raw] PropLam_eqvt[eqvt_raw] PropLetBody_eqvt[eqvt_raw] PropLetHeap_eqvt[eqvt_raw] PropIfScrut_eqvt[eqvt_raw]\n         TransBound_eqvt[eqvt]"], ["proof (state)\nthis:\n  ?\\<pi> \\<bullet> PropApp \\<equiv> PropApp\n  ?\\<pi> \\<bullet> PropLam \\<equiv> PropLam\n  ?\\<pi> \\<bullet> PropLetBody \\<equiv> PropLetBody\n  ?\\<pi> \\<bullet> PropLetHeap \\<equiv> PropLetHeap\n  ?\\<pi> \\<bullet> PropIfScrut \\<equiv> PropIfScrut\n  ?\\<pi> \\<bullet> trans = trans\n\ngoal (1 subgoal):\n 1. AbstractTransformSubst PropApp PropLam AnalLet PropLetBody PropLetHeap\n     PropIfScrut (\\<lambda>a. Var) (\\<lambda>a. App) (\\<lambda>a. Lam)\n     (\\<lambda>b \\<Gamma>.\n         Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. AbstractTransformSubst PropApp PropLam AnalLet PropLetBody PropLetHeap\n     PropIfScrut (\\<lambda>a. Var) (\\<lambda>a. App) (\\<lambda>a. Lam)\n     (\\<lambda>b \\<Gamma>.\n         Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>))", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a v x y. (Var v)[x::=y] = Var v[x::v=y]\n 2. \\<And>a e v x y. (App e v)[x::=y] = App e[x::=y] v[x::v=y]\n 3. \\<And>v x y a e.\n       atom v \\<sharp> (x, y) \\<Longrightarrow>\n       (Lam [v]. e)[x::=y] = Lam [v[x::v=y]]. e[x::=y]\n 4. \\<And>\\<Gamma> x y b e.\n       atom ` domA \\<Gamma> \\<sharp>* (x, y) \\<Longrightarrow>\n       (Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>)\n         e)[x::=y] =\n       Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>[x::h=y])\n        e[x::=y]", "apply simp_all[3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> x y b e.\n       atom ` domA \\<Gamma> \\<sharp>* (x, y) \\<Longrightarrow>\n       (Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>)\n         e)[x::=y] =\n       Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>[x::h=y])\n        e[x::=y]", "apply (simp del: Let_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> x y b e.\n       atom ` domA \\<Gamma> \\<sharp>* (x, y) \\<Longrightarrow>\n       Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>)[x::h=y]\n        e[x::=y] =\n       Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>[x::h=y])\n        e[x::=y]", "apply (rule arg_cong[where f = \"\\<lambda> x. Let x y\" for y])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> x y b e.\n       atom ` domA \\<Gamma> \\<sharp>* (x, y) \\<Longrightarrow>\n       (map_transform trans (PropLetHeapTrans b) \\<Gamma>)[x::h=y] =\n       map_transform trans (PropLetHeapTrans b) \\<Gamma>[x::h=y]", "apply (rule subst_map_transform)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> x y b e x' ea a.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* (x, y);\n        (x', ea) \\<in> set \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (trans a ea)[x::=y] = trans a ea[x::=y]", "apply (simp add: TransBound_subst)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  AbstractTransformSubst PropApp PropLam AnalLet PropLetBody PropLetHeap\n   PropIfScrut (\\<lambda>a. Var) (\\<lambda>a. App) (\\<lambda>a. Lam)\n   (\\<lambda>b \\<Gamma>.\n       Terms.Let (map_transform trans (PropLetHeapTrans b) \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}