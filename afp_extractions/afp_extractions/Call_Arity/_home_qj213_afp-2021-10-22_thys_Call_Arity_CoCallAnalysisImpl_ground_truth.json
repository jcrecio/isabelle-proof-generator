{"file_name": "/home/qj213/afp-2021-10-22/thys/Call_Arity/CoCallAnalysisImpl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Call_Arity", "problem_names": ["lemma fst_combined_restrict[simp]:\n  \"fst (combined_restrict S p) = fst p f|` S\"", "lemma snd_combined_restrict[simp]:\n  \"snd (combined_restrict S p) = cc_restr S (snd p)\"", "lemma combined_restrict_eqvt[eqvt]:\n  shows \"\\<pi> \\<bullet> combined_restrict S p = combined_restrict (\\<pi> \\<bullet> S) (\\<pi> \\<bullet> p)\"", "lemma combined_restrict_cont:\n  \"cont (\\<lambda>x. combined_restrict S x)\"", "lemmas cont_compose[OF combined_restrict_cont, cont2cont, simp]", "lemma combined_restrict_perm:\n  assumes \"supp \\<pi> \\<sharp>* S\" and [simp]: \"finite S\"\n  shows \"combined_restrict S (\\<pi> \\<bullet> p) = combined_restrict S p\"", "lemma predCC_eq:\n  shows \"predCC S f \\<cdot> a = (if a \\<noteq> 0 then cc_restr S (f\\<cdot>(pred\\<cdot>a)) else ccSquare S)\"", "lemma predCC_eqvt[eqvt, simp]: \"\\<pi> \\<bullet> (predCC S f) = predCC (\\<pi> \\<bullet> S) (\\<pi> \\<bullet> f)\"", "lemma cc_restr_predCC:\n  \"cc_restr S (predCC S' f\\<cdot>n) = (predCC (S' \\<inter> S) (\\<Lambda> n. cc_restr S (f\\<cdot>n)))\\<cdot>n\"", "lemma cc_restr_predCC'[simp]:\n  \"cc_restr S (predCC S f\\<cdot>n) = predCC S f\\<cdot>n\"", "lemma cCCexp_eq[simp]:\n  \"cCCexp (Var x)\\<cdot>n =      (esing x \\<cdot> (up \\<cdot> n),                                   \\<bottom>)\"\n  \"cCCexp (Lam [x]. e)\\<cdot>n = combined_restrict (fv (Lam [x]. e)) (fst (cCCexp e\\<cdot>(pred\\<cdot>n)), predCC (fv (Lam [x]. e)) (\\<Lambda> a. snd(cCCexp e\\<cdot>a))\\<cdot>n)\"\n  \"cCCexp (App e x)\\<cdot>n =    (fst (cCCexp e\\<cdot>(inc\\<cdot>n)) \\<squnion> (esing x \\<cdot> (up\\<cdot>0)),          snd (cCCexp e\\<cdot>(inc\\<cdot>n)) \\<squnion> ccProd {x} (insert x (fv e)))\"\n  \"cCCexp (Let \\<Gamma> e)\\<cdot>n =    combined_restrict (fv (Let \\<Gamma> e)) (CoCallArityAnalysis.cccFix_choose cCCexp \\<Gamma> \\<cdot> (cCCexp e\\<cdot>n))\"\n  \"cCCexp (Bool b)\\<cdot>n = \\<bottom>\"\n  \"cCCexp (scrut ? e1 : e2)\\<cdot>n = (fst (cCCexp scrut\\<cdot>0) \\<squnion> fst (cCCexp e1\\<cdot>n) \\<squnion> fst (cCCexp e2\\<cdot>n),\n        snd (cCCexp scrut\\<cdot>0) \\<squnion> (snd (cCCexp e1\\<cdot>n) \\<squnion> snd (cCCexp e2\\<cdot>n)) \\<squnion> ccProd (edom (fst (cCCexp scrut\\<cdot>0))) (edom (fst (cCCexp e1\\<cdot>n)) \\<union> edom (fst (cCCexp e2\\<cdot>n))))\"", "lemma Aexp_pre_simps:\n  \"\\<A>\\<^bsub>a\\<^esub> (Var x) = esing x\\<cdot>(up\\<cdot>a)\"\n  \"\\<A>\\<^bsub>a\\<^esub> (Lam [x]. e) = Aexp e\\<cdot>(pred\\<cdot>a) f|` fv (Lam [x]. e)\"\n  \"\\<A>\\<^bsub>a\\<^esub> (App e x) = Aexp e\\<cdot>(inc\\<cdot>a) \\<squnion> esing x\\<cdot>(up\\<cdot>0)\"\n  \"\\<not> nonrec \\<Gamma> \\<Longrightarrow>\n     \\<A>\\<^bsub>a\\<^esub> (Let \\<Gamma> e) = (Afix \\<Gamma>\\<cdot>(\\<A>\\<^bsub>a\\<^esub> e \\<squnion> (\\<lambda>_.up\\<cdot>0) f|` thunks \\<Gamma>)) f|` (fv (Let \\<Gamma> e))\"\n  \"x \\<notin> fv e \\<Longrightarrow>\n     \\<A>\\<^bsub>a\\<^esub> (let x be e in exp) =\n        (fup\\<cdot>(Aexp e)\\<cdot>(ABind_nonrec x e\\<cdot>(\\<A>\\<^bsub>a\\<^esub> exp, CCexp exp\\<cdot>a)) \\<squnion> \\<A>\\<^bsub>a\\<^esub> exp)\n            f|` (fv (let x be e in exp))\"\n  \"\\<A>\\<^bsub>a\\<^esub> (Bool b) = \\<bottom>\"\n  \"\\<A>\\<^bsub>a\\<^esub> (scrut ? e1 : e2) = \\<A>\\<^bsub>0\\<^esub> scrut \\<squnion> \\<A>\\<^bsub>a\\<^esub> e1 \\<squnion> \\<A>\\<^bsub>a\\<^esub> e2\"", "lemma CCexp_pre_simps:\n  \"CCexp (Var x)\\<cdot>n = \\<bottom>\"\n  \"CCexp (Lam [x]. e)\\<cdot>n = predCC (fv (Lam [x]. e)) (CCexp e)\\<cdot>n\"\n  \"CCexp (App e x)\\<cdot>n = CCexp e\\<cdot>(inc\\<cdot>n) \\<squnion> ccProd {x} (insert x (fv e))\"\n  \"\\<not> nonrec \\<Gamma> \\<Longrightarrow>\n      CCexp (Let \\<Gamma> e)\\<cdot>n = cc_restr (fv (Let \\<Gamma> e))\n        (CCfix \\<Gamma>\\<cdot>(Afix \\<Gamma>\\<cdot>(Aexp e\\<cdot>n \\<squnion> (\\<lambda>_.up\\<cdot>0) f|` thunks \\<Gamma>), CCexp e\\<cdot>n))\"\n  \"x \\<notin> fv e \\<Longrightarrow> CCexp (let x be e in exp)\\<cdot>n =\n    cc_restr (fv (let x be e in exp))\n       (ccBind x e \\<cdot>(Aheap_nonrec x e\\<cdot>(Aexp exp\\<cdot>n, CCexp exp\\<cdot>n), CCexp exp\\<cdot>n)\n       \\<squnion> ccProd (fv e) (ccNeighbors x (CCexp exp\\<cdot>n) - (if isVal e then {} else {x})) \\<squnion> CCexp exp\\<cdot>n)\"\n  \"CCexp (Bool b)\\<cdot>n = \\<bottom>\"\n  \"CCexp (scrut ? e1 : e2)\\<cdot>n =\n       CCexp scrut\\<cdot>0 \\<squnion>\n       (CCexp e1\\<cdot>n \\<squnion> CCexp e2\\<cdot>n) \\<squnion>\n       ccProd (edom (Aexp scrut\\<cdot>0)) (edom (Aexp e1\\<cdot>n) \\<union> edom (Aexp e2\\<cdot>n))\"", "lemma \n  shows ccField_CCexp: \"ccField (CCexp e\\<cdot>a) \\<subseteq> fv e\" and Aexp_edom': \"edom (\\<A>\\<^bsub>a\\<^esub> e) \\<subseteq> fv e\"", "lemma cc_restr_CCexp[simp]:\n  \"cc_restr (fv e) (CCexp e\\<cdot>a) = CCexp e\\<cdot>a\"", "lemma ccField_fup_CCexp:\n  \"ccField (fup\\<cdot>(CCexp e)\\<cdot>n) \\<subseteq> fv e\"", "lemma cc_restr_fup_ccExp_useless[simp]: \"cc_restr (fv e) (fup\\<cdot>(CCexp e)\\<cdot>n) = fup\\<cdot>(CCexp e)\\<cdot>n\"", "lemma CCexp_simps[simp]:\n  \"\\<G>\\<^bsub>a\\<^esub>(Var x) = \\<bottom>\"\n  \"\\<G>\\<^bsub>0\\<^esub>(Lam [x]. e) = (fv (Lam [x]. e))\\<^sup>2\"\n  \"\\<G>\\<^bsub>inc\\<cdot>a\\<^esub>(Lam [x]. e) = cc_delete x (\\<G>\\<^bsub>a\\<^esub> e)\"\n  \"\\<G>\\<^bsub>a\\<^esub> (App e x) = \\<G>\\<^bsub>inc\\<cdot>a\\<^esub> e \\<squnion> {x} G\\<times>insert x (fv e)\"\n  \"\\<not> nonrec \\<Gamma> \\<Longrightarrow> \\<G>\\<^bsub>a\\<^esub> (Let \\<Gamma> e) =\n    (CCfix \\<Gamma>\\<cdot>(Afix \\<Gamma>\\<cdot>(\\<A>\\<^bsub>a\\<^esub> e \\<squnion> (\\<lambda>_.up\\<cdot>0) f|` thunks \\<Gamma>), \\<G>\\<^bsub>a\\<^esub> e)) G|` (- domA \\<Gamma>)\"\n  \"x \\<notin> fv e' \\<Longrightarrow> \\<G>\\<^bsub>a\\<^esub> (let x be e' in e) =\n    cc_delete x\n       (ccBind x e' \\<cdot>(Aheap_nonrec x e'\\<cdot>(\\<A>\\<^bsub>a\\<^esub> e, \\<G>\\<^bsub>a\\<^esub> e), \\<G>\\<^bsub>a\\<^esub> e)\n       \\<squnion> fv e' G\\<times> (ccNeighbors x (\\<G>\\<^bsub>a\\<^esub> e) - (if isVal e' then {} else {x})) \\<squnion> \\<G>\\<^bsub>a\\<^esub> e)\"\n  \"\\<G>\\<^bsub>a\\<^esub> (Bool b) = \\<bottom>\"\n  \"\\<G>\\<^bsub>a\\<^esub> (scrut ? e1 : e2) =\n       \\<G>\\<^bsub>0\\<^esub> scrut \\<squnion> (\\<G>\\<^bsub>a\\<^esub> e1 \\<squnion> \\<G>\\<^bsub>a\\<^esub> e2) \\<squnion>\n       edom (\\<A>\\<^bsub>0\\<^esub> scrut) G\\<times> (edom (\\<A>\\<^bsub>a\\<^esub> e1) \\<union> edom (\\<A>\\<^bsub>a\\<^esub> e2))\"", "lemma Aheap_simp1[simp]:\n  \"\\<not> nonrec \\<Gamma> \\<Longrightarrow> Aheap \\<Gamma> e \\<cdot>a = (Afix \\<Gamma> \\<cdot> (Aexp e\\<cdot>a \\<squnion> (\\<lambda>_.up\\<cdot>0) f|` thunks \\<Gamma>)) f|` domA \\<Gamma>\"", "lemma Aheap_simp2[simp]:\n  \"x \\<notin> fv e' \\<Longrightarrow> Aheap [(x,e')] e \\<cdot>a = Aheap_nonrec x e'\\<cdot>(Aexp e\\<cdot>a, CCexp e\\<cdot>a)\"", "lemma Aheap_eqvt'[eqvt]:\n  \"\\<pi> \\<bullet> (Aheap \\<Gamma> e) = Aheap (\\<pi> \\<bullet> \\<Gamma>) (\\<pi> \\<bullet> e)\"", "lemma Aexp_lam_simp: \"Aexp (Lam [x]. e) \\<cdot> n = env_delete x (Aexp e \\<cdot> (pred \\<cdot> n))\"", "lemma Aexp_Let_simp1:\n  \"\\<not> nonrec \\<Gamma> \\<Longrightarrow> \\<A>\\<^bsub>a\\<^esub> (Let \\<Gamma> e) = (Afix \\<Gamma>\\<cdot>(\\<A>\\<^bsub>a\\<^esub> e \\<squnion> (\\<lambda>_.up\\<cdot>0) f|` thunks \\<Gamma>)) f|` (- domA \\<Gamma>)\"", "lemma Aexp_Let_simp2:\n  \"x \\<notin> fv e \\<Longrightarrow> \\<A>\\<^bsub>a\\<^esub>(let x be e in exp) = env_delete x (\\<A>\\<^sup>\\<bottom>\\<^bsub>ABind_nonrec x e \\<cdot> (\\<A>\\<^bsub>a\\<^esub> exp, CCexp exp\\<cdot>a)\\<^esub> e \\<squnion> \\<A>\\<^bsub>a\\<^esub> exp)\"", "lemma Aexp_simps[simp]:\n  \"\\<A>\\<^bsub>a\\<^esub>(Var x) = esing x\\<cdot>(up\\<cdot>a)\"\n  \"\\<A>\\<^bsub>a\\<^esub>(Lam [x]. e) = env_delete x (\\<A>\\<^bsub>pred\\<cdot>a\\<^esub> e)\"\n  \"\\<A>\\<^bsub>a\\<^esub>(App e x) = Aexp e\\<cdot>(inc\\<cdot>a) \\<squnion> esing x\\<cdot>(up\\<cdot>0)\"\n  \"\\<not> nonrec \\<Gamma> \\<Longrightarrow> \\<A>\\<^bsub>a\\<^esub>(Let \\<Gamma> e) =\n      (Afix \\<Gamma>\\<cdot>(\\<A>\\<^bsub>a\\<^esub> e \\<squnion> (\\<lambda>_.up\\<cdot>0) f|` thunks \\<Gamma>)) f|` (- domA \\<Gamma>)\"\n  \"x \\<notin> fv e' \\<Longrightarrow> \\<A>\\<^bsub>a\\<^esub>(let x be e' in e) =\n      env_delete x (\\<A>\\<^sup>\\<bottom>\\<^bsub>ABind_nonrec x e'\\<cdot>(\\<A>\\<^bsub>a\\<^esub> e, \\<G>\\<^bsub>a\\<^esub> e)\\<^esub> e' \\<squnion> \\<A>\\<^bsub>a\\<^esub> e)\"\n  \"\\<A>\\<^bsub>a\\<^esub>(Bool b) = \\<bottom>\"\n  \"\\<A>\\<^bsub>a\\<^esub>(scrut ? e1 : e2) = \\<A>\\<^bsub>0\\<^esub> scrut \\<squnion> \\<A>\\<^bsub>a\\<^esub> e1 \\<squnion> \\<A>\\<^bsub>a\\<^esub> e2\""], "translations": [["", "lemma fst_combined_restrict[simp]:\n  \"fst (combined_restrict S p) = fst p f|` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (combined_restrict S p) = fst p f|` S", "by (cases p, simp)"], ["", "lemma snd_combined_restrict[simp]:\n  \"snd (combined_restrict S p) = cc_restr S (snd p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (combined_restrict S p) = snd p G|` S", "by (cases p, simp)"], ["", "lemma combined_restrict_eqvt[eqvt]:\n  shows \"\\<pi> \\<bullet> combined_restrict S p = combined_restrict (\\<pi> \\<bullet> S) (\\<pi> \\<bullet> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> combined_restrict S p =\n    combined_restrict (\\<pi> \\<bullet> S) (\\<pi> \\<bullet> p)", "by (cases p) auto"], ["", "lemma combined_restrict_cont:\n  \"cont (\\<lambda>x. combined_restrict S x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (combined_restrict S)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cont (combined_restrict S)", "have \"cont (\\<lambda>(env, G). combined_restrict S (env, G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>(env, G). combined_restrict S (env, G))", "by simp"], ["proof (state)\nthis:\n  cont (\\<lambda>(env, G). combined_restrict S (env, G))\n\ngoal (1 subgoal):\n 1. cont (combined_restrict S)", "then"], ["proof (chain)\npicking this:\n  cont (\\<lambda>(env, G). combined_restrict S (env, G))", "show ?thesis"], ["proof (prove)\nusing this:\n  cont (\\<lambda>(env, G). combined_restrict S (env, G))\n\ngoal (1 subgoal):\n 1. cont (combined_restrict S)", "by (simp only: case_prod_eta)"], ["proof (state)\nthis:\n  cont (combined_restrict S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas cont_compose[OF combined_restrict_cont, cont2cont, simp]"], ["", "lemma combined_restrict_perm:\n  assumes \"supp \\<pi> \\<sharp>* S\" and [simp]: \"finite S\"\n  shows \"combined_restrict S (\\<pi> \\<bullet> p) = combined_restrict S p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. combined_restrict S (\\<pi> \\<bullet> p) = combined_restrict S p", "proof(cases p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = (a, b) \\<Longrightarrow>\n       combined_restrict S (\\<pi> \\<bullet> p) = combined_restrict S p", "fix env :: AEnv and  G :: CoCalls"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = (a, b) \\<Longrightarrow>\n       combined_restrict S (\\<pi> \\<bullet> p) = combined_restrict S p", "assume \"p = (env, G)\""], ["proof (state)\nthis:\n  p = (env, G)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = (a, b) \\<Longrightarrow>\n       combined_restrict S (\\<pi> \\<bullet> p) = combined_restrict S p", "moreover"], ["proof (state)\nthis:\n  p = (env, G)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = (a, b) \\<Longrightarrow>\n       combined_restrict S (\\<pi> \\<bullet> p) = combined_restrict S p", "from assms"], ["proof (chain)\npicking this:\n  supp \\<pi> \\<sharp>* S\n  finite S", "have \"env_restr S (\\<pi> \\<bullet> env) = env_restr S env\""], ["proof (prove)\nusing this:\n  supp \\<pi> \\<sharp>* S\n  finite S\n\ngoal (1 subgoal):\n 1. (\\<pi> \\<bullet> env) f|` S = env f|` S", "by (rule env_restr_perm)"], ["proof (state)\nthis:\n  (\\<pi> \\<bullet> env) f|` S = env f|` S\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = (a, b) \\<Longrightarrow>\n       combined_restrict S (\\<pi> \\<bullet> p) = combined_restrict S p", "moreover"], ["proof (state)\nthis:\n  (\\<pi> \\<bullet> env) f|` S = env f|` S\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = (a, b) \\<Longrightarrow>\n       combined_restrict S (\\<pi> \\<bullet> p) = combined_restrict S p", "from assms"], ["proof (chain)\npicking this:\n  supp \\<pi> \\<sharp>* S\n  finite S", "have \"cc_restr S (\\<pi> \\<bullet> G) = cc_restr S G\""], ["proof (prove)\nusing this:\n  supp \\<pi> \\<sharp>* S\n  finite S\n\ngoal (1 subgoal):\n 1. (\\<pi> \\<bullet> G) G|` S = G G|` S", "by (rule cc_restr_perm)"], ["proof (state)\nthis:\n  (\\<pi> \\<bullet> G) G|` S = G G|` S\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = (a, b) \\<Longrightarrow>\n       combined_restrict S (\\<pi> \\<bullet> p) = combined_restrict S p", "ultimately"], ["proof (chain)\npicking this:\n  p = (env, G)\n  (\\<pi> \\<bullet> env) f|` S = env f|` S\n  (\\<pi> \\<bullet> G) G|` S = G G|` S", "show ?thesis"], ["proof (prove)\nusing this:\n  p = (env, G)\n  (\\<pi> \\<bullet> env) f|` S = env f|` S\n  (\\<pi> \\<bullet> G) G|` S = G G|` S\n\ngoal (1 subgoal):\n 1. combined_restrict S (\\<pi> \\<bullet> p) = combined_restrict S p", "by simp"], ["proof (state)\nthis:\n  combined_restrict S (\\<pi> \\<bullet> p) = combined_restrict S p\n\ngoal:\nNo subgoals!", "qed"], ["", "definition predCC :: \"var set \\<Rightarrow> (Arity \\<rightarrow> CoCalls) \\<Rightarrow> (Arity \\<rightarrow> CoCalls)\"\n  where \"predCC S f = (\\<Lambda> a. if a \\<noteq> 0 then cc_restr S (f\\<cdot>(pred\\<cdot>a)) else ccSquare S)\""], ["", "lemma predCC_eq:\n  shows \"predCC S f \\<cdot> a = (if a \\<noteq> 0 then cc_restr S (f\\<cdot>(pred\\<cdot>a)) else ccSquare S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. predCC S f\\<cdot>a =\n    (if a \\<noteq> 0 then f\\<cdot>(pred\\<cdot>a) G|` S else S\\<^sup>2)", "unfolding predCC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> a.\n        if a \\<noteq> 0 then f\\<cdot>(pred\\<cdot>a) G|` S\n        else S\\<^sup>2)\\<cdot>\n    a =\n    (if a \\<noteq> 0 then f\\<cdot>(pred\\<cdot>a) G|` S else S\\<^sup>2)", "apply (rule beta_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         if x \\<noteq> 0 then f\\<cdot>(pred\\<cdot>x) G|` S else S\\<^sup>2)", "apply (rule cont_if_else_above)"], ["proof (prove)\ngoal (5 subgoals):\n 1. cont (\\<lambda>x. f\\<cdot>(pred\\<cdot>x) G|` S)\n 2. cont (\\<lambda>x. S\\<^sup>2)\n 3. \\<And>x. f\\<cdot>(pred\\<cdot>x) G|` S \\<sqsubseteq> S\\<^sup>2\n 4. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> 0\n 5. adm (\\<lambda>x. x \\<noteq> 0)", "apply (auto dest: subsetD[OF ccField_cc_restr])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma predCC_eqvt[eqvt, simp]: \"\\<pi> \\<bullet> (predCC S f) = predCC (\\<pi> \\<bullet> S) (\\<pi> \\<bullet> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> predCC S f =\n    predCC (\\<pi> \\<bullet> S) (\\<pi> \\<bullet> f)", "apply (rule cfun_eqvtI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<pi> \\<bullet> predCC S f\\<cdot>x =\n       predCC (\\<pi> \\<bullet> S) (\\<pi> \\<bullet> f)\\<cdot>\n       (\\<pi> \\<bullet> x)", "unfolding predCC_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<pi> \\<bullet> (if x \\<noteq> 0 then f\\<cdot>(pred\\<cdot>x) G|` S\n                        else S\\<^sup>2) =\n       (if \\<pi> \\<bullet> x \\<noteq> 0\n        then (\\<pi> \\<bullet> f)\\<cdot>(pred\\<cdot>(\\<pi> \\<bullet> x)) G|`\n             (\\<pi> \\<bullet> S)\n        else (\\<pi> \\<bullet> S)\\<^sup>2)", "by perm_simp rule"], ["", "lemma cc_restr_predCC:\n  \"cc_restr S (predCC S' f\\<cdot>n) = (predCC (S' \\<inter> S) (\\<Lambda> n. cc_restr S (f\\<cdot>n)))\\<cdot>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. predCC S' f\\<cdot>n G|` S =\n    predCC (S' \\<inter> S) (\\<Lambda> n. f\\<cdot>n G|` S)\\<cdot>n", "unfolding predCC_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n \\<noteq> 0 then f\\<cdot>(pred\\<cdot>n) G|` S' else S'\\<^sup>2) G|`\n    S =\n    (if n \\<noteq> 0\n     then (\\<Lambda> n. f\\<cdot>n G|` S)\\<cdot>(pred\\<cdot>n) G|`\n          (S' \\<inter> S)\n     else (S' \\<inter> S)\\<^sup>2)", "by (auto simp add: inf_commute ccSquare_def)"], ["", "lemma cc_restr_predCC'[simp]:\n  \"cc_restr S (predCC S f\\<cdot>n) = predCC S f\\<cdot>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. predCC S f\\<cdot>n G|` S = predCC S f\\<cdot>n", "unfolding predCC_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n \\<noteq> 0 then f\\<cdot>(pred\\<cdot>n) G|` S else S\\<^sup>2) G|`\n    S =\n    (if n \\<noteq> 0 then f\\<cdot>(pred\\<cdot>n) G|` S else S\\<^sup>2)", "by simp"], ["", "nominal_function\n  cCCexp :: \"exp \\<Rightarrow> (Arity \\<rightarrow> AEnv \\<times> CoCalls)\" \nwhere\n  \"cCCexp (Var x) =      (\\<Lambda> n . (esing x \\<cdot> (up \\<cdot> n),                                   \\<bottom>))\"\n| \"cCCexp (Lam [x]. e) = (\\<Lambda> n . combined_restrict (fv (Lam [x]. e)) (fst (cCCexp e\\<cdot>(pred\\<cdot>n)), predCC (fv (Lam [x]. e)) (\\<Lambda> a. snd(cCCexp e\\<cdot>a))\\<cdot>n))\"\n| \"cCCexp (App e x) =    (\\<Lambda> n . (fst (cCCexp e\\<cdot>(inc\\<cdot>n)) \\<squnion> (esing x \\<cdot> (up\\<cdot>0)),          snd (cCCexp e\\<cdot>(inc\\<cdot>n)) \\<squnion> ccProd {x} (insert x (fv e))))\"\n| \"cCCexp (Let \\<Gamma> e) =    (\\<Lambda> n . combined_restrict (fv (Let \\<Gamma> e)) (CoCallArityAnalysis.cccFix_choose cCCexp \\<Gamma> \\<cdot> (cCCexp e\\<cdot>n)))\"\n| \"cCCexp (Bool b) =     \\<bottom>\"\n| \"cCCexp (scrut ? e1 : e2) = (\\<Lambda> n. (fst (cCCexp scrut\\<cdot>0) \\<squnion> fst (cCCexp e1\\<cdot>n) \\<squnion> fst (cCCexp e2\\<cdot>n),\n     snd (cCCexp scrut\\<cdot>0) \\<squnion> (snd (cCCexp e1\\<cdot>n) \\<squnion> snd (cCCexp e2\\<cdot>n)) \\<squnion> ccProd (edom (fst (cCCexp scrut\\<cdot>0))) (edom (fst (cCCexp e1\\<cdot>n)) \\<union> edom (fst (cCCexp e2\\<cdot>n)))))\""], ["proof (prove)\ngoal (24 subgoals):\n 1. eqvt cCCexp_graph_aux\n 2. \\<And>x y. cCCexp_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>\\<Gamma> e. x = Terms.Let \\<Gamma> e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>x xa.\n       Var x = Var xa \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n       (\\<Lambda> n. (esing xa\\<cdot>(up\\<cdot>n), \\<bottom>))\n 5. \\<And>x xa e.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n        \\<And>xa xb. True; Var x = Lam [xa]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))\n 6. \\<And>x e xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC e; \\<And>xa. True; \\<And>xa. True;\n        Var x = App e xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv e)))\n 7. \\<And>x \\<Gamma> e.\n       \\<lbrakk>\\<And>x ea.\n                   ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n                   eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC e;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Var x = Terms.Let \\<Gamma> e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> e))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC e\\<cdot>n)))\n 8. \\<And>x b.\n       Var x = Bool b \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) = \\<bottom>\n 9. \\<And>x scrut e1 e2.\n       \\<lbrakk>\\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. eqvt_at cCCexp_sumC scrut; \\<And>x. eqvt_at cCCexp_sumC e1;\n        \\<And>x. eqvt_at cCCexp_sumC e2; \\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; Var x = (scrut ? e1 : e2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              fst (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                              fst (cCCexp_sumC e2\\<cdot>n),\n                              snd (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              (snd (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                               snd (cCCexp_sumC e2\\<cdot>n)) \\<squnion>\n                              edom\n                               (fst (cCCexp_sumC scrut\\<cdot>0)) G\\<times>\n                              (edom (fst (cCCexp_sumC e1\\<cdot>n)) \\<union>\n                               edom (fst (cCCexp_sumC e2\\<cdot>n)))))\n 10. \\<And>x e xa ea.\n        \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n         \\<And>xa xb. eqvt_at cCCexp_sumC e;\n         \\<And>xa. eqvt_at cCCexp_sumC ea;\n         \\<And>xa xb. eqvt_at cCCexp_sumC ea; \\<And>xa. True;\n         \\<And>xa xb. True; \\<And>xa. True; \\<And>xa xb. True;\n         Lam [x]. e = Lam [xa]. ea\\<rbrakk>\n        \\<Longrightarrow> (\\<Lambda> n.\n                              combined_restrict (fv (Lam [x]. e))\n                               (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [x]. e))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                                n)) =\n                          (\\<Lambda> n.\n                              combined_restrict (fv (Lam [xa]. ea))\n                               (fst (cCCexp_sumC ea\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [xa]. ea))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC ea\\<cdot>a))\\<cdot>\n                                n))\nA total of 24 subgoals...", "proof goal_cases"], ["proof (state)\ngoal (24 subgoals):\n 1. eqvt cCCexp_graph_aux\n 2. \\<And>x y. cCCexp_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>\\<Gamma> e. x = Terms.Let \\<Gamma> e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>x xa.\n       Var x = Var xa \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n       (\\<Lambda> n. (esing xa\\<cdot>(up\\<cdot>n), \\<bottom>))\n 5. \\<And>x xa e.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n        \\<And>xa xb. True; Var x = Lam [xa]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))\n 6. \\<And>x e xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC e; \\<And>xa. True; \\<And>xa. True;\n        Var x = App e xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv e)))\n 7. \\<And>x \\<Gamma> e.\n       \\<lbrakk>\\<And>x ea.\n                   ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n                   eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC e;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Var x = Terms.Let \\<Gamma> e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> e))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC e\\<cdot>n)))\n 8. \\<And>x b.\n       Var x = Bool b \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) = \\<bottom>\n 9. \\<And>x scrut e1 e2.\n       \\<lbrakk>\\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. eqvt_at cCCexp_sumC scrut; \\<And>x. eqvt_at cCCexp_sumC e1;\n        \\<And>x. eqvt_at cCCexp_sumC e2; \\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; Var x = (scrut ? e1 : e2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              fst (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                              fst (cCCexp_sumC e2\\<cdot>n),\n                              snd (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              (snd (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                               snd (cCCexp_sumC e2\\<cdot>n)) \\<squnion>\n                              edom\n                               (fst (cCCexp_sumC scrut\\<cdot>0)) G\\<times>\n                              (edom (fst (cCCexp_sumC e1\\<cdot>n)) \\<union>\n                               edom (fst (cCCexp_sumC e2\\<cdot>n)))))\n 10. \\<And>x e xa ea.\n        \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n         \\<And>xa xb. eqvt_at cCCexp_sumC e;\n         \\<And>xa. eqvt_at cCCexp_sumC ea;\n         \\<And>xa xb. eqvt_at cCCexp_sumC ea; \\<And>xa. True;\n         \\<And>xa xb. True; \\<And>xa. True; \\<And>xa xb. True;\n         Lam [x]. e = Lam [xa]. ea\\<rbrakk>\n        \\<Longrightarrow> (\\<Lambda> n.\n                              combined_restrict (fv (Lam [x]. e))\n                               (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [x]. e))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                                n)) =\n                          (\\<Lambda> n.\n                              combined_restrict (fv (Lam [xa]. ea))\n                               (fst (cCCexp_sumC ea\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [xa]. ea))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC ea\\<cdot>a))\\<cdot>\n                                n))\nA total of 24 subgoals...", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (24 subgoals):\n 1. eqvt cCCexp_graph_aux\n 2. \\<And>x y. cCCexp_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>\\<Gamma> e. x = Terms.Let \\<Gamma> e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>x xa.\n       Var x = Var xa \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n       (\\<Lambda> n. (esing xa\\<cdot>(up\\<cdot>n), \\<bottom>))\n 5. \\<And>x xa e.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n        \\<And>xa xb. True; Var x = Lam [xa]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))\n 6. \\<And>x e xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC e; \\<And>xa. True; \\<And>xa. True;\n        Var x = App e xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv e)))\n 7. \\<And>x \\<Gamma> e.\n       \\<lbrakk>\\<And>x ea.\n                   ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n                   eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC e;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Var x = Terms.Let \\<Gamma> e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> e))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC e\\<cdot>n)))\n 8. \\<And>x b.\n       Var x = Bool b \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) = \\<bottom>\n 9. \\<And>x scrut e1 e2.\n       \\<lbrakk>\\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. eqvt_at cCCexp_sumC scrut; \\<And>x. eqvt_at cCCexp_sumC e1;\n        \\<And>x. eqvt_at cCCexp_sumC e2; \\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; Var x = (scrut ? e1 : e2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              fst (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                              fst (cCCexp_sumC e2\\<cdot>n),\n                              snd (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              (snd (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                               snd (cCCexp_sumC e2\\<cdot>n)) \\<squnion>\n                              edom\n                               (fst (cCCexp_sumC scrut\\<cdot>0)) G\\<times>\n                              (edom (fst (cCCexp_sumC e1\\<cdot>n)) \\<union>\n                               edom (fst (cCCexp_sumC e2\\<cdot>n)))))\n 10. \\<And>x e xa ea.\n        \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n         \\<And>xa xb. eqvt_at cCCexp_sumC e;\n         \\<And>xa. eqvt_at cCCexp_sumC ea;\n         \\<And>xa xb. eqvt_at cCCexp_sumC ea; \\<And>xa. True;\n         \\<And>xa xb. True; \\<And>xa. True; \\<And>xa xb. True;\n         Lam [x]. e = Lam [xa]. ea\\<rbrakk>\n        \\<Longrightarrow> (\\<Lambda> n.\n                              combined_restrict (fv (Lam [x]. e))\n                               (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [x]. e))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                                n)) =\n                          (\\<Lambda> n.\n                              combined_restrict (fv (Lam [xa]. ea))\n                               (fst (cCCexp_sumC ea\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [xa]. ea))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC ea\\<cdot>a))\\<cdot>\n                                n))\nA total of 24 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt cCCexp_graph_aux", "unfolding eqvt_def cCCexp_graph_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       p \\<bullet> lfp (\\<lambda>p x1 x2.\n                           (\\<exists>cCCexp_aux x.\n                               x1 = Var x \\<and>\n                               x2 =\n                               (\\<Lambda> n.\n                                   (esing x\\<cdot>(up\\<cdot>n),\n                                    \\<bottom>))) \\<or>\n                           (\\<exists>cCCexp_aux x e.\n                               x1 = Lam [x]. e \\<and>\n                               x2 =\n                               (\\<Lambda> n.\n                                   combined_restrict (fv (Lam [x]. e))\n                                    (fst\n(((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e\\<cdot>(pred\\<cdot>n)),\n                                     predCC (fv (Lam [x]. e))\n(\\<Lambda> a.\n    snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e\\<cdot>a))\\<cdot>\n                                     n)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>xa.\n                                    p e (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>xa.\n                                    HOL.induct_forall\n                                     (\\<lambda>xb.\n   p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e)))) \\<or>\n                           (\\<exists>cCCexp_aux e x.\n                               x1 = App e x \\<and>\n                               x2 =\n                               (\\<Lambda> n.\n                                   (fst (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e\\<cdot>\n   (inc\\<cdot>n)) \\<squnion>\n                                    esing x\\<cdot>(up\\<cdot>0),\n                                    snd (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e\\<cdot>\n   (inc\\<cdot>n)) \\<squnion>\n                                    {x} G\\<times> insert x (fv e))) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>xa.\n                                    p e (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>xa.\n                                    p e (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e))) \\<or>\n                           (\\<exists>cCCexp_aux \\<Gamma> e.\n                               x1 = Terms.Let \\<Gamma> e \\<and>\n                               x2 =\n                               (\\<Lambda> n.\n                                   combined_restrict\n                                    (fv (Terms.Let \\<Gamma> e))\n                                    (CoCallArityAnalysis.cccFix_choose\n((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) \\<Gamma>\\<cdot>\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e\\<cdot>\nn))) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    HOL.induct_forall\n                                     (\\<lambda>ea.\n   HOL.induct_implies (ea \\<in> snd ` set \\<Gamma>)\n    (p ea (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) ea)))) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e))) \\<or>\n                           (\\<exists>cCCexp_aux b.\n                               x1 = Bool b \\<and> x2 = \\<bottom>) \\<or>\n                           (\\<exists>cCCexp_aux scrut e1 e2.\n                               x1 = (scrut ? e1 : e2) \\<and>\n                               x2 =\n                               (\\<Lambda> n.\n                                   (fst (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    scrut\\<cdot>\n   0) \\<squnion>\n                                    fst (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e1\\<cdot>\n   n) \\<squnion>\n                                    fst (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e2\\<cdot>\n   n),\n                                    snd (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    scrut\\<cdot>\n   0) \\<squnion>\n                                    (snd\n(((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e1\\<cdot>n) \\<squnion>\n                                     snd\n(((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e2\\<cdot>n)) \\<squnion>\n                                    edom\n                                     (fst\n (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) scrut\\<cdot>0)) G\\<times>\n                                    (edom\n(fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e1\\<cdot>n)) \\<union>\n                                     edom\n(fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e2\\<cdot>n))))) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p scrut\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n scrut)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e1\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e1)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e2\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e2)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p scrut\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n scrut)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e1\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e1)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e2\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e2)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p scrut\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n scrut)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e1\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e1)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e2\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e2)))) =\n       lfp (\\<lambda>p x1 x2.\n               (\\<exists>cCCexp_aux x.\n                   x1 = Var x \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       (esing x\\<cdot>(up\\<cdot>n), \\<bottom>))) \\<or>\n               (\\<exists>cCCexp_aux x e.\n                   x1 = Lam [x]. e \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       combined_restrict (fv (Lam [x]. e))\n                        (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                               e\\<cdot>\n                              (pred\\<cdot>n)),\n                         predCC (fv (Lam [x]. e))\n                          (\\<Lambda> a.\n                              snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                    e\\<cdot>\n                                   a))\\<cdot>\n                         n)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        HOL.induct_forall\n                         (\\<lambda>xb.\n                             p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                   e)))) \\<or>\n               (\\<exists>cCCexp_aux e x.\n                   x1 = App e x \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e\\<cdot>\n                             (inc\\<cdot>n)) \\<squnion>\n                        esing x\\<cdot>(up\\<cdot>0),\n                        snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e\\<cdot>\n                             (inc\\<cdot>n)) \\<squnion>\n                        {x} G\\<times> insert x (fv e))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e))) \\<or>\n               (\\<exists>cCCexp_aux \\<Gamma> e.\n                   x1 = Terms.Let \\<Gamma> e \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       combined_restrict (fv (Terms.Let \\<Gamma> e))\n                        (CoCallArityAnalysis.cccFix_choose\n                          ((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                          \\<Gamma>\\<cdot>\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e\\<cdot>\n                          n))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        HOL.induct_forall\n                         (\\<lambda>ea.\n                             HOL.induct_implies\n                              (ea \\<in> snd ` set \\<Gamma>)\n                              (p ea\n                                (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                  ea)))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e))) \\<or>\n               (\\<exists>cCCexp_aux b.\n                   x1 = Bool b \\<and> x2 = \\<bottom>) \\<or>\n               (\\<exists>cCCexp_aux scrut e1 e2.\n                   x1 = (scrut ? e1 : e2) \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              scrut\\<cdot>\n                             0) \\<squnion>\n                        fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e1\\<cdot>\n                             n) \\<squnion>\n                        fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e2\\<cdot>\n                             n),\n                        snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              scrut\\<cdot>\n                             0) \\<squnion>\n                        (snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                               e1\\<cdot>\n                              n) \\<squnion>\n                         snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                               e2\\<cdot>\n                              n)) \\<squnion>\n                        edom\n                         (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                scrut\\<cdot>\n                               0)) G\\<times>\n                        (edom\n                          (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                 e1\\<cdot>\n                                n)) \\<union>\n                         edom\n                          (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                 e2\\<cdot>\n                                n))))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p scrut\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           scrut)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e1\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e1)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e2\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e2)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p scrut\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           scrut)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e1\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e1)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e2\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e2)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p scrut\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           scrut)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e1\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e1)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e2\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e2))))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<bullet> lfp (\\<lambda>p x1 x2.\n                           (\\<exists>cCCexp_aux x.\n                               x1 = Var x \\<and>\n                               x2 =\n                               (\\<Lambda> n.\n                                   (esing x\\<cdot>(up\\<cdot>n),\n                                    \\<bottom>))) \\<or>\n                           (\\<exists>cCCexp_aux x e.\n                               x1 = Lam [x]. e \\<and>\n                               x2 =\n                               (\\<Lambda> n.\n                                   combined_restrict (fv (Lam [x]. e))\n                                    (fst\n(((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e\\<cdot>(pred\\<cdot>n)),\n                                     predCC (fv (Lam [x]. e))\n(\\<Lambda> a.\n    snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e\\<cdot>a))\\<cdot>\n                                     n)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>xa.\n                                    p e (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>xa.\n                                    HOL.induct_forall\n                                     (\\<lambda>xb.\n   p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e)))) \\<or>\n                           (\\<exists>cCCexp_aux e x.\n                               x1 = App e x \\<and>\n                               x2 =\n                               (\\<Lambda> n.\n                                   (fst (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e\\<cdot>\n   (inc\\<cdot>n)) \\<squnion>\n                                    esing x\\<cdot>(up\\<cdot>0),\n                                    snd (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e\\<cdot>\n   (inc\\<cdot>n)) \\<squnion>\n                                    {x} G\\<times> insert x (fv e))) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>xa.\n                                    p e (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>xa.\n                                    p e (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e))) \\<or>\n                           (\\<exists>cCCexp_aux \\<Gamma> e.\n                               x1 = Terms.Let \\<Gamma> e \\<and>\n                               x2 =\n                               (\\<Lambda> n.\n                                   combined_restrict\n                                    (fv (Terms.Let \\<Gamma> e))\n                                    (CoCallArityAnalysis.cccFix_choose\n((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) \\<Gamma>\\<cdot>\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e\\<cdot>\nn))) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    HOL.induct_forall\n                                     (\\<lambda>ea.\n   HOL.induct_implies (ea \\<in> snd ` set \\<Gamma>)\n    (p ea (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) ea)))) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e))) \\<or>\n                           (\\<exists>cCCexp_aux b.\n                               x1 = Bool b \\<and> x2 = \\<bottom>) \\<or>\n                           (\\<exists>cCCexp_aux scrut e1 e2.\n                               x1 = (scrut ? e1 : e2) \\<and>\n                               x2 =\n                               (\\<Lambda> n.\n                                   (fst (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    scrut\\<cdot>\n   0) \\<squnion>\n                                    fst (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e1\\<cdot>\n   n) \\<squnion>\n                                    fst (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    e2\\<cdot>\n   n),\n                                    snd (((\\<lambda>uu_. uu_) \\<circ>\n    cCCexp_aux)\n    scrut\\<cdot>\n   0) \\<squnion>\n                                    (snd\n(((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e1\\<cdot>n) \\<squnion>\n                                     snd\n(((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e2\\<cdot>n)) \\<squnion>\n                                    edom\n                                     (fst\n (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) scrut\\<cdot>0)) G\\<times>\n                                    (edom\n(fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e1\\<cdot>n)) \\<union>\n                                     edom\n(fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e2\\<cdot>n))))) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p scrut\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n scrut)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e1\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e1)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e2\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e2)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p scrut\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n scrut)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e1\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e1)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e2\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e2)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p scrut\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n scrut)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e1\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e1)) \\<and>\n                               HOL.induct_forall\n                                (\\<lambda>x.\n                                    p e2\n                                     (((\\<lambda>uu_. uu_) \\<circ>\n cCCexp_aux)\n e2)))) =\n       lfp (\\<lambda>p x1 x2.\n               (\\<exists>cCCexp_aux x.\n                   x1 = Var x \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       (esing x\\<cdot>(up\\<cdot>n), \\<bottom>))) \\<or>\n               (\\<exists>cCCexp_aux x e.\n                   x1 = Lam [x]. e \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       combined_restrict (fv (Lam [x]. e))\n                        (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                               e\\<cdot>\n                              (pred\\<cdot>n)),\n                         predCC (fv (Lam [x]. e))\n                          (\\<Lambda> a.\n                              snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                    e\\<cdot>\n                                   a))\\<cdot>\n                         n)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        HOL.induct_forall\n                         (\\<lambda>xb.\n                             p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                   e)))) \\<or>\n               (\\<exists>cCCexp_aux e x.\n                   x1 = App e x \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e\\<cdot>\n                             (inc\\<cdot>n)) \\<squnion>\n                        esing x\\<cdot>(up\\<cdot>0),\n                        snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e\\<cdot>\n                             (inc\\<cdot>n)) \\<squnion>\n                        {x} G\\<times> insert x (fv e))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e))) \\<or>\n               (\\<exists>cCCexp_aux \\<Gamma> e.\n                   x1 = Terms.Let \\<Gamma> e \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       combined_restrict (fv (Terms.Let \\<Gamma> e))\n                        (CoCallArityAnalysis.cccFix_choose\n                          ((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                          \\<Gamma>\\<cdot>\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e\\<cdot>\n                          n))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        HOL.induct_forall\n                         (\\<lambda>ea.\n                             HOL.induct_implies\n                              (ea \\<in> snd ` set \\<Gamma>)\n                              (p ea\n                                (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                  ea)))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e))) \\<or>\n               (\\<exists>cCCexp_aux b.\n                   x1 = Bool b \\<and> x2 = \\<bottom>) \\<or>\n               (\\<exists>cCCexp_aux scrut e1 e2.\n                   x1 = (scrut ? e1 : e2) \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              scrut\\<cdot>\n                             0) \\<squnion>\n                        fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e1\\<cdot>\n                             n) \\<squnion>\n                        fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e2\\<cdot>\n                             n),\n                        snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              scrut\\<cdot>\n                             0) \\<squnion>\n                        (snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                               e1\\<cdot>\n                              n) \\<squnion>\n                         snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                               e2\\<cdot>\n                              n)) \\<squnion>\n                        edom\n                         (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                scrut\\<cdot>\n                               0)) G\\<times>\n                        (edom\n                          (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                 e1\\<cdot>\n                                n)) \\<union>\n                         edom\n                          (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                 e2\\<cdot>\n                                n))))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p scrut\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           scrut)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e1\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e1)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e2\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e2)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p scrut\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           scrut)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e1\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e1)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e2\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e2)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p scrut\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           scrut)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e1\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e1)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e2\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e2))))", "apply (perm_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       lfp (\\<lambda>x xa xb.\n               (\\<exists>x xc.\n                   xa = Var xc \\<and>\n                   xb =\n                   (p \\<bullet> Abs_cfun)\n                    (\\<lambda>x.\n                        (esing xc\\<cdot>(up\\<cdot>x), \\<bottom>))) \\<or>\n               (\\<exists>xc xd xe.\n                   xa = Lam [xd]. xe \\<and>\n                   xb =\n                   (p \\<bullet> Abs_cfun)\n                    (\\<lambda>x.\n                        combined_restrict (fv (Lam [xd]. xe))\n                         (fst (((\\<lambda>x. x) \\<circ> xc) xe\\<cdot>\n                               (pred\\<cdot>x)),\n                          predCC (fv (Lam [xd]. xe))\n                           ((p \\<bullet> Abs_cfun)\n                             (\\<lambda>x.\n                                 snd (((\\<lambda>x. x) \\<circ> xc) xe\\<cdot>\nx)))\\<cdot>\n                          x)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        x xe (((\\<lambda>x. x) \\<circ> xc) xe)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        HOL.induct_forall\n                         (\\<lambda>xa.\n                             x xe (((\\<lambda>x. x) \\<circ> xc) xe)))) \\<or>\n               (\\<exists>xc xd xe.\n                   xa = App xd xe \\<and>\n                   xb =\n                   (p \\<bullet> Abs_cfun)\n                    (\\<lambda>x.\n                        (fst (((\\<lambda>x. x) \\<circ> xc) xd\\<cdot>\n                              (inc\\<cdot>x)) \\<squnion>\n                         esing xe\\<cdot>(up\\<cdot>0),\n                         snd (((\\<lambda>x. x) \\<circ> xc) xd\\<cdot>\n                              (inc\\<cdot>x)) \\<squnion>\n                         {xe} G\\<times> insert xe (fv xd))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        x xd (((\\<lambda>x. x) \\<circ> xc) xd)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        x xd (((\\<lambda>x. x) \\<circ> xc) xd))) \\<or>\n               (\\<exists>xc xd xe.\n                   xa = Terms.Let xd xe \\<and>\n                   xb =\n                   (p \\<bullet> Abs_cfun)\n                    (\\<lambda>x.\n                        combined_restrict (fv (Terms.Let xd xe))\n                         (CoCallArityAnalysis.cccFix_choose\n                           ((\\<lambda>x. x) \\<circ> xc) xd\\<cdot>\n                          (((\\<lambda>x. x) \\<circ> xc) xe\\<cdot>x))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        HOL.induct_forall\n                         (\\<lambda>xa.\n                             HOL.induct_implies (xa \\<in> snd ` set xd)\n                              (x xa\n                                (((\\<lambda>x. x) \\<circ> xc) xa)))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        x xe (((\\<lambda>x. x) \\<circ> xc) xe))) \\<or>\n               (\\<exists>x xc. xa = Bool xc \\<and> xb = \\<bottom>) \\<or>\n               (\\<exists>xc xd xe xf.\n                   xa = (xd ? xe : xf) \\<and>\n                   xb =\n                   (p \\<bullet> Abs_cfun)\n                    (\\<lambda>x.\n                        (fst (((\\<lambda>x. x) \\<circ> xc) xd\\<cdot>\n                              0) \\<squnion>\n                         fst (((\\<lambda>x. x) \\<circ> xc) xe\\<cdot>\n                              x) \\<squnion>\n                         fst (((\\<lambda>x. x) \\<circ> xc) xf\\<cdot>x),\n                         snd (((\\<lambda>x. x) \\<circ> xc) xd\\<cdot>\n                              0) \\<squnion>\n                         (snd (((\\<lambda>x. x) \\<circ> xc) xe\\<cdot>\n                               x) \\<squnion>\n                          snd (((\\<lambda>x. x) \\<circ> xc) xf\\<cdot>\n                               x)) \\<squnion>\n                         edom\n                          (fst (((\\<lambda>x. x) \\<circ> xc) xd\\<cdot>\n                                0)) G\\<times>\n                         (edom\n                           (fst (((\\<lambda>x. x) \\<circ> xc) xe\\<cdot>\n                                 x)) \\<union>\n                          edom\n                           (fst (((\\<lambda>x. x) \\<circ> xc) xf\\<cdot>\n                                 x))))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        x xd (((\\<lambda>x. x) \\<circ> xc) xd)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        x xe (((\\<lambda>x. x) \\<circ> xc) xe)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        x xf (((\\<lambda>x. x) \\<circ> xc) xf)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        x xd (((\\<lambda>x. x) \\<circ> xc) xd)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        x xe (((\\<lambda>x. x) \\<circ> xc) xe)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        x xf (((\\<lambda>x. x) \\<circ> xc) xf)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        x xd (((\\<lambda>x. x) \\<circ> xc) xd)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        x xe (((\\<lambda>x. x) \\<circ> xc) xe)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        x xf (((\\<lambda>x. x) \\<circ> xc) xf)))) =\n       lfp (\\<lambda>p x1 x2.\n               (\\<exists>cCCexp_aux x.\n                   x1 = Var x \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       (esing x\\<cdot>(up\\<cdot>n), \\<bottom>))) \\<or>\n               (\\<exists>cCCexp_aux x e.\n                   x1 = Lam [x]. e \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       combined_restrict (fv (Lam [x]. e))\n                        (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                               e\\<cdot>\n                              (pred\\<cdot>n)),\n                         predCC (fv (Lam [x]. e))\n                          (\\<Lambda> a.\n                              snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                    e\\<cdot>\n                                   a))\\<cdot>\n                         n)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        HOL.induct_forall\n                         (\\<lambda>xb.\n                             p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                   e)))) \\<or>\n               (\\<exists>cCCexp_aux e x.\n                   x1 = App e x \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e\\<cdot>\n                             (inc\\<cdot>n)) \\<squnion>\n                        esing x\\<cdot>(up\\<cdot>0),\n                        snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e\\<cdot>\n                             (inc\\<cdot>n)) \\<squnion>\n                        {x} G\\<times> insert x (fv e))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>xa.\n                        p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e))) \\<or>\n               (\\<exists>cCCexp_aux \\<Gamma> e.\n                   x1 = Terms.Let \\<Gamma> e \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       combined_restrict (fv (Terms.Let \\<Gamma> e))\n                        (CoCallArityAnalysis.cccFix_choose\n                          ((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                          \\<Gamma>\\<cdot>\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e\\<cdot>\n                          n))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        HOL.induct_forall\n                         (\\<lambda>ea.\n                             HOL.induct_implies\n                              (ea \\<in> snd ` set \\<Gamma>)\n                              (p ea\n                                (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                  ea)))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e))) \\<or>\n               (\\<exists>cCCexp_aux b.\n                   x1 = Bool b \\<and> x2 = \\<bottom>) \\<or>\n               (\\<exists>cCCexp_aux scrut e1 e2.\n                   x1 = (scrut ? e1 : e2) \\<and>\n                   x2 =\n                   (\\<Lambda> n.\n                       (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              scrut\\<cdot>\n                             0) \\<squnion>\n                        fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e1\\<cdot>\n                             n) \\<squnion>\n                        fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              e2\\<cdot>\n                             n),\n                        snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                              scrut\\<cdot>\n                             0) \\<squnion>\n                        (snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                               e1\\<cdot>\n                              n) \\<squnion>\n                         snd (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                               e2\\<cdot>\n                              n)) \\<squnion>\n                        edom\n                         (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                scrut\\<cdot>\n                               0)) G\\<times>\n                        (edom\n                          (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                 e1\\<cdot>\n                                n)) \\<union>\n                         edom\n                          (fst (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                                 e2\\<cdot>\n                                n))))) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p scrut\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           scrut)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e1\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e1)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e2\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e2)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p scrut\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           scrut)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e1\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e1)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e2\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e2)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p scrut\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           scrut)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e1\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux)\n                           e1)) \\<and>\n                   HOL.induct_forall\n                    (\\<lambda>x.\n                        p e2\n                         (((\\<lambda>uu_. uu_) \\<circ> cCCexp_aux) e2))))", "apply (simp add: Abs_cfun_eqvt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eqvt cCCexp_graph_aux\n\ngoal (23 subgoals):\n 1. \\<And>x y. cCCexp_graph x y \\<Longrightarrow> True\n 2. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>\\<Gamma> e. x = Terms.Let \\<Gamma> e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>x xa.\n       Var x = Var xa \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n       (\\<Lambda> n. (esing xa\\<cdot>(up\\<cdot>n), \\<bottom>))\n 4. \\<And>x xa e.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n        \\<And>xa xb. True; Var x = Lam [xa]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))\n 5. \\<And>x e xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC e; \\<And>xa. True; \\<And>xa. True;\n        Var x = App e xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv e)))\n 6. \\<And>x \\<Gamma> e.\n       \\<lbrakk>\\<And>x ea.\n                   ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n                   eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC e;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Var x = Terms.Let \\<Gamma> e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> e))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC e\\<cdot>n)))\n 7. \\<And>x b.\n       Var x = Bool b \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) = \\<bottom>\n 8. \\<And>x scrut e1 e2.\n       \\<lbrakk>\\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. eqvt_at cCCexp_sumC scrut; \\<And>x. eqvt_at cCCexp_sumC e1;\n        \\<And>x. eqvt_at cCCexp_sumC e2; \\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; Var x = (scrut ? e1 : e2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              fst (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                              fst (cCCexp_sumC e2\\<cdot>n),\n                              snd (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              (snd (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                               snd (cCCexp_sumC e2\\<cdot>n)) \\<squnion>\n                              edom\n                               (fst (cCCexp_sumC scrut\\<cdot>0)) G\\<times>\n                              (edom (fst (cCCexp_sumC e1\\<cdot>n)) \\<union>\n                               edom (fst (cCCexp_sumC e2\\<cdot>n)))))\n 9. \\<And>x e xa ea.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC ea;\n        \\<And>xa xb. eqvt_at cCCexp_sumC ea; \\<And>xa. True;\n        \\<And>xa xb. True; \\<And>xa. True; \\<And>xa xb. True;\n        Lam [x]. e = Lam [xa]. ea\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. ea))\n                              (fst (cCCexp_sumC ea\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. ea))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC ea\\<cdot>a))\\<cdot>\n                               n))\n 10. \\<And>x e ea xa.\n        \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n         \\<And>xa xb. eqvt_at cCCexp_sumC e;\n         \\<And>xa. eqvt_at cCCexp_sumC ea; \\<And>xa. eqvt_at cCCexp_sumC ea;\n         \\<And>xa. True; \\<And>xa xb. True; \\<And>xa. True; \\<And>xa. True;\n         Lam [x]. e = App ea xa\\<rbrakk>\n        \\<Longrightarrow> (\\<Lambda> n.\n                              combined_restrict (fv (Lam [x]. e))\n                               (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [x]. e))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                                n)) =\n                          (\\<Lambda> n.\n                              (fst (cCCexp_sumC ea\\<cdot>\n                                    (inc\\<cdot>n)) \\<squnion>\n                               esing xa\\<cdot>(up\\<cdot>0),\n                               snd (cCCexp_sumC ea\\<cdot>\n                                    (inc\\<cdot>n)) \\<squnion>\n                               {xa} G\\<times> insert xa (fv ea)))\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>x y. cCCexp_graph x y \\<Longrightarrow> True\n 2. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>\\<Gamma> e. x = Terms.Let \\<Gamma> e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>x xa.\n       Var x = Var xa \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n       (\\<Lambda> n. (esing xa\\<cdot>(up\\<cdot>n), \\<bottom>))\n 4. \\<And>x xa e.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n        \\<And>xa xb. True; Var x = Lam [xa]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))\n 5. \\<And>x e xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC e; \\<And>xa. True; \\<And>xa. True;\n        Var x = App e xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv e)))\n 6. \\<And>x \\<Gamma> e.\n       \\<lbrakk>\\<And>x ea.\n                   ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n                   eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC e;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Var x = Terms.Let \\<Gamma> e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> e))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC e\\<cdot>n)))\n 7. \\<And>x b.\n       Var x = Bool b \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) = \\<bottom>\n 8. \\<And>x scrut e1 e2.\n       \\<lbrakk>\\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. eqvt_at cCCexp_sumC scrut; \\<And>x. eqvt_at cCCexp_sumC e1;\n        \\<And>x. eqvt_at cCCexp_sumC e2; \\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; Var x = (scrut ? e1 : e2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              fst (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                              fst (cCCexp_sumC e2\\<cdot>n),\n                              snd (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              (snd (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                               snd (cCCexp_sumC e2\\<cdot>n)) \\<squnion>\n                              edom\n                               (fst (cCCexp_sumC scrut\\<cdot>0)) G\\<times>\n                              (edom (fst (cCCexp_sumC e1\\<cdot>n)) \\<union>\n                               edom (fst (cCCexp_sumC e2\\<cdot>n)))))\n 9. \\<And>x e xa ea.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC ea;\n        \\<And>xa xb. eqvt_at cCCexp_sumC ea; \\<And>xa. True;\n        \\<And>xa xb. True; \\<And>xa. True; \\<And>xa xb. True;\n        Lam [x]. e = Lam [xa]. ea\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. ea))\n                              (fst (cCCexp_sumC ea\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. ea))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC ea\\<cdot>a))\\<cdot>\n                               n))\n 10. \\<And>x e ea xa.\n        \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n         \\<And>xa xb. eqvt_at cCCexp_sumC e;\n         \\<And>xa. eqvt_at cCCexp_sumC ea; \\<And>xa. eqvt_at cCCexp_sumC ea;\n         \\<And>xa. True; \\<And>xa xb. True; \\<And>xa. True; \\<And>xa. True;\n         Lam [x]. e = App ea xa\\<rbrakk>\n        \\<Longrightarrow> (\\<Lambda> n.\n                              combined_restrict (fv (Lam [x]. e))\n                               (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [x]. e))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                                n)) =\n                          (\\<Lambda> n.\n                              (fst (cCCexp_sumC ea\\<cdot>\n                                    (inc\\<cdot>n)) \\<squnion>\n                               esing xa\\<cdot>(up\\<cdot>0),\n                               snd (cCCexp_sumC ea\\<cdot>\n                                    (inc\\<cdot>n)) \\<squnion>\n                               {xa} G\\<times> insert xa (fv ea)))\nA total of 23 subgoals...", "case 3"], ["proof (state)\nthis:\n  x_ = Var ?x \\<Longrightarrow> P_\n  x_ = Lam [?x]. ?e \\<Longrightarrow> P_\n  x_ = App ?e ?x \\<Longrightarrow> P_\n  x_ = Terms.Let ?\\<Gamma> ?e \\<Longrightarrow> P_\n  x_ = Bool ?b \\<Longrightarrow> P_\n  x_ = (?scrut ? ?e1.0 : ?e2.0) \\<Longrightarrow> P_\n\ngoal (23 subgoals):\n 1. \\<And>x y. cCCexp_graph x y \\<Longrightarrow> True\n 2. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>\\<Gamma> e. x = Terms.Let \\<Gamma> e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>x xa.\n       Var x = Var xa \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n       (\\<Lambda> n. (esing xa\\<cdot>(up\\<cdot>n), \\<bottom>))\n 4. \\<And>x xa e.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n        \\<And>xa xb. True; Var x = Lam [xa]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))\n 5. \\<And>x e xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC e; \\<And>xa. True; \\<And>xa. True;\n        Var x = App e xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv e)))\n 6. \\<And>x \\<Gamma> e.\n       \\<lbrakk>\\<And>x ea.\n                   ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n                   eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC e;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Var x = Terms.Let \\<Gamma> e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> e))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC e\\<cdot>n)))\n 7. \\<And>x b.\n       Var x = Bool b \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) = \\<bottom>\n 8. \\<And>x scrut e1 e2.\n       \\<lbrakk>\\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. eqvt_at cCCexp_sumC scrut; \\<And>x. eqvt_at cCCexp_sumC e1;\n        \\<And>x. eqvt_at cCCexp_sumC e2; \\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; Var x = (scrut ? e1 : e2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              fst (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                              fst (cCCexp_sumC e2\\<cdot>n),\n                              snd (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              (snd (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                               snd (cCCexp_sumC e2\\<cdot>n)) \\<squnion>\n                              edom\n                               (fst (cCCexp_sumC scrut\\<cdot>0)) G\\<times>\n                              (edom (fst (cCCexp_sumC e1\\<cdot>n)) \\<union>\n                               edom (fst (cCCexp_sumC e2\\<cdot>n)))))\n 9. \\<And>x e xa ea.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC ea;\n        \\<And>xa xb. eqvt_at cCCexp_sumC ea; \\<And>xa. True;\n        \\<And>xa xb. True; \\<And>xa. True; \\<And>xa xb. True;\n        Lam [x]. e = Lam [xa]. ea\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. ea))\n                              (fst (cCCexp_sumC ea\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. ea))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC ea\\<cdot>a))\\<cdot>\n                               n))\n 10. \\<And>x e ea xa.\n        \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n         \\<And>xa xb. eqvt_at cCCexp_sumC e;\n         \\<And>xa. eqvt_at cCCexp_sumC ea; \\<And>xa. eqvt_at cCCexp_sumC ea;\n         \\<And>xa. True; \\<And>xa xb. True; \\<And>xa. True; \\<And>xa. True;\n         Lam [x]. e = App ea xa\\<rbrakk>\n        \\<Longrightarrow> (\\<Lambda> n.\n                              combined_restrict (fv (Lam [x]. e))\n                               (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [x]. e))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                                n)) =\n                          (\\<Lambda> n.\n                              (fst (cCCexp_sumC ea\\<cdot>\n                                    (inc\\<cdot>n)) \\<squnion>\n                               esing xa\\<cdot>(up\\<cdot>0),\n                               snd (cCCexp_sumC ea\\<cdot>\n                                    (inc\\<cdot>n)) \\<squnion>\n                               {xa} G\\<times> insert xa (fv ea)))\nA total of 23 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  x_ = Var ?x \\<Longrightarrow> P_\n  x_ = Lam [?x]. ?e \\<Longrightarrow> P_\n  x_ = App ?e ?x \\<Longrightarrow> P_\n  x_ = Terms.Let ?\\<Gamma> ?e \\<Longrightarrow> P_\n  x_ = Bool ?b \\<Longrightarrow> P_\n  x_ = (?scrut ? ?e1.0 : ?e2.0) \\<Longrightarrow> P_\n\ngoal (1 subgoal):\n 1. P_", "by (metis Terms.exp_strong_exhaust)"], ["proof (state)\nthis:\n  P_\n\ngoal (22 subgoals):\n 1. \\<And>x y. cCCexp_graph x y \\<Longrightarrow> True\n 2. \\<And>x xa.\n       Var x = Var xa \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n       (\\<Lambda> n. (esing xa\\<cdot>(up\\<cdot>n), \\<bottom>))\n 3. \\<And>x xa e.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n        \\<And>xa xb. True; Var x = Lam [xa]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))\n 4. \\<And>x e xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC e; \\<And>xa. True; \\<And>xa. True;\n        Var x = App e xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv e)))\n 5. \\<And>x \\<Gamma> e.\n       \\<lbrakk>\\<And>x ea.\n                   ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n                   eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC e;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Var x = Terms.Let \\<Gamma> e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> e))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC e\\<cdot>n)))\n 6. \\<And>x b.\n       Var x = Bool b \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) = \\<bottom>\n 7. \\<And>x scrut e1 e2.\n       \\<lbrakk>\\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. eqvt_at cCCexp_sumC scrut; \\<And>x. eqvt_at cCCexp_sumC e1;\n        \\<And>x. eqvt_at cCCexp_sumC e2; \\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; Var x = (scrut ? e1 : e2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              fst (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                              fst (cCCexp_sumC e2\\<cdot>n),\n                              snd (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              (snd (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                               snd (cCCexp_sumC e2\\<cdot>n)) \\<squnion>\n                              edom\n                               (fst (cCCexp_sumC scrut\\<cdot>0)) G\\<times>\n                              (edom (fst (cCCexp_sumC e1\\<cdot>n)) \\<union>\n                               edom (fst (cCCexp_sumC e2\\<cdot>n)))))\n 8. \\<And>x e xa ea.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC ea;\n        \\<And>xa xb. eqvt_at cCCexp_sumC ea; \\<And>xa. True;\n        \\<And>xa xb. True; \\<And>xa. True; \\<And>xa xb. True;\n        Lam [x]. e = Lam [xa]. ea\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. ea))\n                              (fst (cCCexp_sumC ea\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. ea))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC ea\\<cdot>a))\\<cdot>\n                               n))\n 9. \\<And>x e ea xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC ea; \\<And>xa. eqvt_at cCCexp_sumC ea;\n        \\<And>xa. True; \\<And>xa xb. True; \\<And>xa. True; \\<And>xa. True;\n        Lam [x]. e = App ea xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv ea)))\n 10. \\<And>x e \\<Gamma> ea.\n        \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n         \\<And>xa xb. eqvt_at cCCexp_sumC e;\n         \\<And>x ea.\n            ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n            eqvt_at cCCexp_sumC ea;\n         \\<And>x. eqvt_at cCCexp_sumC ea; \\<And>xa. True; \\<And>xa xb. True;\n         \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n         \\<And>x. True; Lam [x]. e = Terms.Let \\<Gamma> ea\\<rbrakk>\n        \\<Longrightarrow> (\\<Lambda> n.\n                              combined_restrict (fv (Lam [x]. e))\n                               (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [x]. e))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                                n)) =\n                          (\\<Lambda> n.\n                              combined_restrict (fv (Terms.Let \\<Gamma> ea))\n                               (CoCallArityAnalysis.cccFix_choose\n                                 cCCexp_sumC \\<Gamma>\\<cdot>\n                                (cCCexp_sumC ea\\<cdot>n)))\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>x y. cCCexp_graph x y \\<Longrightarrow> True\n 2. \\<And>x xa.\n       Var x = Var xa \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n       (\\<Lambda> n. (esing xa\\<cdot>(up\\<cdot>n), \\<bottom>))\n 3. \\<And>x xa e.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n        \\<And>xa xb. True; Var x = Lam [xa]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))\n 4. \\<And>x e xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC e; \\<And>xa. True; \\<And>xa. True;\n        Var x = App e xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv e)))\n 5. \\<And>x \\<Gamma> e.\n       \\<lbrakk>\\<And>x ea.\n                   ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n                   eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC e;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Var x = Terms.Let \\<Gamma> e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> e))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC e\\<cdot>n)))\n 6. \\<And>x b.\n       Var x = Bool b \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) = \\<bottom>\n 7. \\<And>x scrut e1 e2.\n       \\<lbrakk>\\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. eqvt_at cCCexp_sumC scrut; \\<And>x. eqvt_at cCCexp_sumC e1;\n        \\<And>x. eqvt_at cCCexp_sumC e2; \\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; Var x = (scrut ? e1 : e2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              fst (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                              fst (cCCexp_sumC e2\\<cdot>n),\n                              snd (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              (snd (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                               snd (cCCexp_sumC e2\\<cdot>n)) \\<squnion>\n                              edom\n                               (fst (cCCexp_sumC scrut\\<cdot>0)) G\\<times>\n                              (edom (fst (cCCexp_sumC e1\\<cdot>n)) \\<union>\n                               edom (fst (cCCexp_sumC e2\\<cdot>n)))))\n 8. \\<And>x e xa ea.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC ea;\n        \\<And>xa xb. eqvt_at cCCexp_sumC ea; \\<And>xa. True;\n        \\<And>xa xb. True; \\<And>xa. True; \\<And>xa xb. True;\n        Lam [x]. e = Lam [xa]. ea\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. ea))\n                              (fst (cCCexp_sumC ea\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. ea))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC ea\\<cdot>a))\\<cdot>\n                               n))\n 9. \\<And>x e ea xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC ea; \\<And>xa. eqvt_at cCCexp_sumC ea;\n        \\<And>xa. True; \\<And>xa xb. True; \\<And>xa. True; \\<And>xa. True;\n        Lam [x]. e = App ea xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv ea)))\n 10. \\<And>x e \\<Gamma> ea.\n        \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n         \\<And>xa xb. eqvt_at cCCexp_sumC e;\n         \\<And>x ea.\n            ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n            eqvt_at cCCexp_sumC ea;\n         \\<And>x. eqvt_at cCCexp_sumC ea; \\<And>xa. True; \\<And>xa xb. True;\n         \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n         \\<And>x. True; Lam [x]. e = Terms.Let \\<Gamma> ea\\<rbrakk>\n        \\<Longrightarrow> (\\<Lambda> n.\n                              combined_restrict (fv (Lam [x]. e))\n                               (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [x]. e))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                                n)) =\n                          (\\<Lambda> n.\n                              combined_restrict (fv (Terms.Let \\<Gamma> ea))\n                               (CoCallArityAnalysis.cccFix_choose\n                                 cCCexp_sumC \\<Gamma>\\<cdot>\n                                (cCCexp_sumC ea\\<cdot>n)))\nA total of 22 subgoals...", "case prems: (10 x e x' e')"], ["proof (state)\nthis:\n  eqvt_at cCCexp_sumC e\n  eqvt_at cCCexp_sumC e\n  eqvt_at cCCexp_sumC e'\n  eqvt_at cCCexp_sumC e'\n  True\n  True\n  True\n  True\n  Lam [x]. e = Lam [x']. e'\n\ngoal (22 subgoals):\n 1. \\<And>x y. cCCexp_graph x y \\<Longrightarrow> True\n 2. \\<And>x xa.\n       Var x = Var xa \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n       (\\<Lambda> n. (esing xa\\<cdot>(up\\<cdot>n), \\<bottom>))\n 3. \\<And>x xa e.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n        \\<And>xa xb. True; Var x = Lam [xa]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))\n 4. \\<And>x e xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC e; \\<And>xa. True; \\<And>xa. True;\n        Var x = App e xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv e)))\n 5. \\<And>x \\<Gamma> e.\n       \\<lbrakk>\\<And>x ea.\n                   ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n                   eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC e;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Var x = Terms.Let \\<Gamma> e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> e))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC e\\<cdot>n)))\n 6. \\<And>x b.\n       Var x = Bool b \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) = \\<bottom>\n 7. \\<And>x scrut e1 e2.\n       \\<lbrakk>\\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. eqvt_at cCCexp_sumC scrut; \\<And>x. eqvt_at cCCexp_sumC e1;\n        \\<And>x. eqvt_at cCCexp_sumC e2; \\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; Var x = (scrut ? e1 : e2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              fst (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                              fst (cCCexp_sumC e2\\<cdot>n),\n                              snd (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              (snd (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                               snd (cCCexp_sumC e2\\<cdot>n)) \\<squnion>\n                              edom\n                               (fst (cCCexp_sumC scrut\\<cdot>0)) G\\<times>\n                              (edom (fst (cCCexp_sumC e1\\<cdot>n)) \\<union>\n                               edom (fst (cCCexp_sumC e2\\<cdot>n)))))\n 8. \\<And>x e xa ea.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC ea;\n        \\<And>xa xb. eqvt_at cCCexp_sumC ea; \\<And>xa. True;\n        \\<And>xa xb. True; \\<And>xa. True; \\<And>xa xb. True;\n        Lam [x]. e = Lam [xa]. ea\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. ea))\n                              (fst (cCCexp_sumC ea\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. ea))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC ea\\<cdot>a))\\<cdot>\n                               n))\n 9. \\<And>x e ea xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC ea; \\<And>xa. eqvt_at cCCexp_sumC ea;\n        \\<And>xa. True; \\<And>xa xb. True; \\<And>xa. True; \\<And>xa. True;\n        Lam [x]. e = App ea xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv ea)))\n 10. \\<And>x e \\<Gamma> ea.\n        \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n         \\<And>xa xb. eqvt_at cCCexp_sumC e;\n         \\<And>x ea.\n            ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n            eqvt_at cCCexp_sumC ea;\n         \\<And>x. eqvt_at cCCexp_sumC ea; \\<And>xa. True; \\<And>xa xb. True;\n         \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n         \\<And>x. True; Lam [x]. e = Terms.Let \\<Gamma> ea\\<rbrakk>\n        \\<Longrightarrow> (\\<Lambda> n.\n                              combined_restrict (fv (Lam [x]. e))\n                               (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [x]. e))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                                n)) =\n                          (\\<Lambda> n.\n                              combined_restrict (fv (Terms.Let \\<Gamma> ea))\n                               (CoCallArityAnalysis.cccFix_choose\n                                 cCCexp_sumC \\<Gamma>\\<cdot>\n                                (cCCexp_sumC ea\\<cdot>n)))\nA total of 22 subgoals...", "from prems(9)"], ["proof (chain)\npicking this:\n  Lam [x]. e = Lam [x']. e'", "show ?case"], ["proof (prove)\nusing this:\n  Lam [x]. e = Lam [x']. e'\n\ngoal (1 subgoal):\n 1. (\\<Lambda> n.\n        combined_restrict (fv (Lam [x]. e))\n         (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n          predCC (fv (Lam [x]. e))\n           (\\<Lambda> a. snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n          n)) =\n    (\\<Lambda> n.\n        combined_restrict (fv (Lam [x']. e'))\n         (fst (cCCexp_sumC e'\\<cdot>(pred\\<cdot>n)),\n          predCC (fv (Lam [x']. e'))\n           (\\<Lambda> a. snd (cCCexp_sumC e'\\<cdot>a))\\<cdot>\n          n))", "proof(rule eqvt_lam_case)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e);\n        supp \\<pi> \\<sharp>* Lam [x]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                    (pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC\n    (\\<pi> \\<bullet> e)\\<cdot>\n   a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))", "fix \\<pi> :: perm"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e);\n        supp \\<pi> \\<sharp>* Lam [x]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                    (pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC\n    (\\<pi> \\<bullet> e)\\<cdot>\n   a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))", "assume *: \"supp (-\\<pi>) \\<sharp>* (fv (Lam [x]. e) :: var set)\""], ["proof (state)\nthis:\n  supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e);\n        supp \\<pi> \\<sharp>* Lam [x]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                    (pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC\n    (\\<pi> \\<bullet> e)\\<cdot>\n   a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))", "{"], ["proof (state)\nthis:\n  supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e);\n        supp \\<pi> \\<sharp>* Lam [x]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                    (pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC\n    (\\<pi> \\<bullet> e)\\<cdot>\n   a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e);\n        supp \\<pi> \\<sharp>* Lam [x]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                    (pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC\n    (\\<pi> \\<bullet> e)\\<cdot>\n   a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))", "have \"combined_restrict (fv (Lam [x]. e)) (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>(pred\\<cdot>n)), predCC (fv (Lam [x]. e)) (\\<Lambda> a. snd(cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>a))\\<cdot>n)\n       = combined_restrict (fv (Lam [x]. e)) (- \\<pi> \\<bullet> (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>(pred\\<cdot>n)), predCC (fv (Lam [x]. e)) (\\<Lambda> a. snd(cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>a))\\<cdot>n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. combined_restrict (fv (Lam [x]. e))\n     (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>(pred\\<cdot>n)),\n      predCC (fv (Lam [x]. e))\n       (\\<Lambda> a. snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>a))\\<cdot>\n      n) =\n    combined_restrict (fv (Lam [x]. e))\n     (- \\<pi> \\<bullet> (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                              (pred\\<cdot>n)),\n                         predCC (fv (Lam [x]. e))\n                          (\\<Lambda> a.\n                              snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                   a))\\<cdot>\n                         n))", "by (rule combined_restrict_perm[symmetric, OF *]) simp"], ["proof (state)\nthis:\n  combined_restrict (fv (Lam [x]. e))\n   (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>(pred\\<cdot>n)),\n    predCC (fv (Lam [x]. e))\n     (\\<Lambda> a. snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>a))\\<cdot>\n    n) =\n  combined_restrict (fv (Lam [x]. e))\n   (- \\<pi> \\<bullet> (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                            (pred\\<cdot>n)),\n                       predCC (fv (Lam [x]. e))\n                        (\\<Lambda> a.\n                            snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                 a))\\<cdot>\n                       n))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e);\n        supp \\<pi> \\<sharp>* Lam [x]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                    (pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC\n    (\\<pi> \\<bullet> e)\\<cdot>\n   a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))", "also"], ["proof (state)\nthis:\n  combined_restrict (fv (Lam [x]. e))\n   (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>(pred\\<cdot>n)),\n    predCC (fv (Lam [x]. e))\n     (\\<Lambda> a. snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>a))\\<cdot>\n    n) =\n  combined_restrict (fv (Lam [x]. e))\n   (- \\<pi> \\<bullet> (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                            (pred\\<cdot>n)),\n                       predCC (fv (Lam [x]. e))\n                        (\\<Lambda> a.\n                            snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                 a))\\<cdot>\n                       n))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e);\n        supp \\<pi> \\<sharp>* Lam [x]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                    (pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC\n    (\\<pi> \\<bullet> e)\\<cdot>\n   a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))", "have \"\\<dots> = combined_restrict (fv (Lam [x]. e)) (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)), predCC (- \\<pi> \\<bullet> fv (Lam [x]. e)) (\\<Lambda> a. snd(cCCexp_sumC e\\<cdot>a))\\<cdot>n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. combined_restrict (fv (Lam [x]. e))\n     (- \\<pi> \\<bullet> (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                              (pred\\<cdot>n)),\n                         predCC (fv (Lam [x]. e))\n                          (\\<Lambda> a.\n                              snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                   a))\\<cdot>\n                         n)) =\n    combined_restrict (fv (Lam [x]. e))\n     (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n      predCC (- \\<pi> \\<bullet> fv (Lam [x]. e))\n       (\\<Lambda> a. snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n      n)", "by (perm_simp, simp add: eqvt_at_apply[OF prems(1)] pemute_minus_self Abs_cfun_eqvt)"], ["proof (state)\nthis:\n  combined_restrict (fv (Lam [x]. e))\n   (- \\<pi> \\<bullet> (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                            (pred\\<cdot>n)),\n                       predCC (fv (Lam [x]. e))\n                        (\\<Lambda> a.\n                            snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                 a))\\<cdot>\n                       n)) =\n  combined_restrict (fv (Lam [x]. e))\n   (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n    predCC (- \\<pi> \\<bullet> fv (Lam [x]. e))\n     (\\<Lambda> a. snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n    n)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e);\n        supp \\<pi> \\<sharp>* Lam [x]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                    (pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC\n    (\\<pi> \\<bullet> e)\\<cdot>\n   a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))", "also"], ["proof (state)\nthis:\n  combined_restrict (fv (Lam [x]. e))\n   (- \\<pi> \\<bullet> (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                            (pred\\<cdot>n)),\n                       predCC (fv (Lam [x]. e))\n                        (\\<Lambda> a.\n                            snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                 a))\\<cdot>\n                       n)) =\n  combined_restrict (fv (Lam [x]. e))\n   (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n    predCC (- \\<pi> \\<bullet> fv (Lam [x]. e))\n     (\\<Lambda> a. snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n    n)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e);\n        supp \\<pi> \\<sharp>* Lam [x]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                    (pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC\n    (\\<pi> \\<bullet> e)\\<cdot>\n   a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))", "have \"- \\<pi> \\<bullet> fv (Lam [x]. e) = (fv (Lam [x]. e) :: var set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<pi> \\<bullet> fv (Lam [x]. e) = fv (Lam [x]. e)", "by (rule perm_supp_eq[OF *])"], ["proof (state)\nthis:\n  - \\<pi> \\<bullet> fv (Lam [x]. e) = fv (Lam [x]. e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e);\n        supp \\<pi> \\<sharp>* Lam [x]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                    (pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC\n    (\\<pi> \\<bullet> e)\\<cdot>\n   a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))", "also"], ["proof (state)\nthis:\n  - \\<pi> \\<bullet> fv (Lam [x]. e) = fv (Lam [x]. e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e);\n        supp \\<pi> \\<sharp>* Lam [x]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                    (pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC\n    (\\<pi> \\<bullet> e)\\<cdot>\n   a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))", "note calculation"], ["proof (state)\nthis:\n  combined_restrict (fv (Lam [x]. e))\n   (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>(pred\\<cdot>n)),\n    predCC (fv (Lam [x]. e))\n     (\\<Lambda> a. snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>a))\\<cdot>\n    n) =\n  combined_restrict (fv (Lam [x]. e))\n   (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n    predCC (fv (Lam [x]. e))\n     (\\<Lambda> a. snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n    n)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e);\n        supp \\<pi> \\<sharp>* Lam [x]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                    (pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC\n    (\\<pi> \\<bullet> e)\\<cdot>\n   a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))", "}"], ["proof (state)\nthis:\n  combined_restrict (fv (Lam [x]. e))\n   (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>(pred\\<cdot>?n2)),\n    predCC (fv (Lam [x]. e))\n     (\\<Lambda> a. snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>a))\\<cdot>\n    ?n2) =\n  combined_restrict (fv (Lam [x]. e))\n   (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>?n2)),\n    predCC (fv (Lam [x]. e))\n     (\\<Lambda> a. snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n    ?n2)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Lam [x]. e);\n        supp \\<pi> \\<sharp>* Lam [x]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>\n                                    (pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC\n    (\\<pi> \\<bullet> e)\\<cdot>\n   a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))", "thus \"(\\<Lambda> n. combined_restrict (fv (Lam [x]. e)) (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>(pred\\<cdot>n)), predCC (fv (Lam [x]. e)) (\\<Lambda> a. snd(cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>a))\\<cdot>n))\n        = (\\<Lambda> n. combined_restrict (fv (Lam [x]. e)) (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)), predCC (fv (Lam [x]. e)) (\\<Lambda> a. snd(cCCexp_sumC e\\<cdot>a))\\<cdot>n))\""], ["proof (prove)\nusing this:\n  combined_restrict (fv (Lam [x]. e))\n   (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>(pred\\<cdot>?n2)),\n    predCC (fv (Lam [x]. e))\n     (\\<Lambda> a. snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>a))\\<cdot>\n    ?n2) =\n  combined_restrict (fv (Lam [x]. e))\n   (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>?n2)),\n    predCC (fv (Lam [x]. e))\n     (\\<Lambda> a. snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n    ?n2)\n\ngoal (1 subgoal):\n 1. (\\<Lambda> n.\n        combined_restrict (fv (Lam [x]. e))\n         (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>(pred\\<cdot>n)),\n          predCC (fv (Lam [x]. e))\n           (\\<Lambda> a.\n               snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>a))\\<cdot>\n          n)) =\n    (\\<Lambda> n.\n        combined_restrict (fv (Lam [x]. e))\n         (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n          predCC (fv (Lam [x]. e))\n           (\\<Lambda> a. snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n          n))", "by simp"], ["proof (state)\nthis:\n  (\\<Lambda> n.\n      combined_restrict (fv (Lam [x]. e))\n       (fst (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>(pred\\<cdot>n)),\n        predCC (fv (Lam [x]. e))\n         (\\<Lambda> a. snd (cCCexp_sumC (\\<pi> \\<bullet> e)\\<cdot>a))\\<cdot>\n        n)) =\n  (\\<Lambda> n.\n      combined_restrict (fv (Lam [x]. e))\n       (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n        predCC (fv (Lam [x]. e))\n         (\\<Lambda> a. snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n        n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Lambda> n.\n      combined_restrict (fv (Lam [x]. e))\n       (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n        predCC (fv (Lam [x]. e))\n         (\\<Lambda> a. snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n        n)) =\n  (\\<Lambda> n.\n      combined_restrict (fv (Lam [x']. e'))\n       (fst (cCCexp_sumC e'\\<cdot>(pred\\<cdot>n)),\n        predCC (fv (Lam [x']. e'))\n         (\\<Lambda> a. snd (cCCexp_sumC e'\\<cdot>a))\\<cdot>\n        n))\n\ngoal (21 subgoals):\n 1. \\<And>x y. cCCexp_graph x y \\<Longrightarrow> True\n 2. \\<And>x xa.\n       Var x = Var xa \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n       (\\<Lambda> n. (esing xa\\<cdot>(up\\<cdot>n), \\<bottom>))\n 3. \\<And>x xa e.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n        \\<And>xa xb. True; Var x = Lam [xa]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))\n 4. \\<And>x e xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC e; \\<And>xa. True; \\<And>xa. True;\n        Var x = App e xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv e)))\n 5. \\<And>x \\<Gamma> e.\n       \\<lbrakk>\\<And>x ea.\n                   ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n                   eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC e;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Var x = Terms.Let \\<Gamma> e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> e))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC e\\<cdot>n)))\n 6. \\<And>x b.\n       Var x = Bool b \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) = \\<bottom>\n 7. \\<And>x scrut e1 e2.\n       \\<lbrakk>\\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. eqvt_at cCCexp_sumC scrut; \\<And>x. eqvt_at cCCexp_sumC e1;\n        \\<And>x. eqvt_at cCCexp_sumC e2; \\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; Var x = (scrut ? e1 : e2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              fst (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                              fst (cCCexp_sumC e2\\<cdot>n),\n                              snd (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              (snd (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                               snd (cCCexp_sumC e2\\<cdot>n)) \\<squnion>\n                              edom\n                               (fst (cCCexp_sumC scrut\\<cdot>0)) G\\<times>\n                              (edom (fst (cCCexp_sumC e1\\<cdot>n)) \\<union>\n                               edom (fst (cCCexp_sumC e2\\<cdot>n)))))\n 8. \\<And>x e ea xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC ea; \\<And>xa. eqvt_at cCCexp_sumC ea;\n        \\<And>xa. True; \\<And>xa xb. True; \\<And>xa. True; \\<And>xa. True;\n        Lam [x]. e = App ea xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv ea)))\n 9. \\<And>x e \\<Gamma> ea.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>x ea.\n           ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n           eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC ea; \\<And>xa. True; \\<And>xa xb. True;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Lam [x]. e = Terms.Let \\<Gamma> ea\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> ea))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC ea\\<cdot>n)))\n 10. \\<And>x e b.\n        \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n         \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n         \\<And>xa xb. True; Lam [x]. e = Bool b\\<rbrakk>\n        \\<Longrightarrow> (\\<Lambda> n.\n                              combined_restrict (fv (Lam [x]. e))\n                               (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [x]. e))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                                n)) =\n                          \\<bottom>\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>x y. cCCexp_graph x y \\<Longrightarrow> True\n 2. \\<And>x xa.\n       Var x = Var xa \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n       (\\<Lambda> n. (esing xa\\<cdot>(up\\<cdot>n), \\<bottom>))\n 3. \\<And>x xa e.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n        \\<And>xa xb. True; Var x = Lam [xa]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))\n 4. \\<And>x e xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC e; \\<And>xa. True; \\<And>xa. True;\n        Var x = App e xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv e)))\n 5. \\<And>x \\<Gamma> e.\n       \\<lbrakk>\\<And>x ea.\n                   ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n                   eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC e;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Var x = Terms.Let \\<Gamma> e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> e))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC e\\<cdot>n)))\n 6. \\<And>x b.\n       Var x = Bool b \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) = \\<bottom>\n 7. \\<And>x scrut e1 e2.\n       \\<lbrakk>\\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. eqvt_at cCCexp_sumC scrut; \\<And>x. eqvt_at cCCexp_sumC e1;\n        \\<And>x. eqvt_at cCCexp_sumC e2; \\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; Var x = (scrut ? e1 : e2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              fst (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                              fst (cCCexp_sumC e2\\<cdot>n),\n                              snd (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              (snd (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                               snd (cCCexp_sumC e2\\<cdot>n)) \\<squnion>\n                              edom\n                               (fst (cCCexp_sumC scrut\\<cdot>0)) G\\<times>\n                              (edom (fst (cCCexp_sumC e1\\<cdot>n)) \\<union>\n                               edom (fst (cCCexp_sumC e2\\<cdot>n)))))\n 8. \\<And>x e ea xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC ea; \\<And>xa. eqvt_at cCCexp_sumC ea;\n        \\<And>xa. True; \\<And>xa xb. True; \\<And>xa. True; \\<And>xa. True;\n        Lam [x]. e = App ea xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv ea)))\n 9. \\<And>x e \\<Gamma> ea.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>x ea.\n           ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n           eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC ea; \\<And>xa. True; \\<And>xa xb. True;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Lam [x]. e = Terms.Let \\<Gamma> ea\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> ea))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC ea\\<cdot>n)))\n 10. \\<And>x e b.\n        \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n         \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n         \\<And>xa xb. True; Lam [x]. e = Bool b\\<rbrakk>\n        \\<Longrightarrow> (\\<Lambda> n.\n                              combined_restrict (fv (Lam [x]. e))\n                               (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [x]. e))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                                n)) =\n                          \\<bottom>\nA total of 21 subgoals...", "case prems: (19 \\<Gamma> body \\<Gamma>' body')"], ["proof (state)\nthis:\n  ?ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> eqvt_at cCCexp_sumC ?ea\n  eqvt_at cCCexp_sumC body\n  ?ea \\<in> snd ` set \\<Gamma>' \\<Longrightarrow> eqvt_at cCCexp_sumC ?ea\n  eqvt_at cCCexp_sumC body'\n  ?ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True\n  True\n  ?ea \\<in> snd ` set \\<Gamma>' \\<Longrightarrow> True\n  True\n  Terms.Let \\<Gamma> body = Terms.Let \\<Gamma>' body'\n\ngoal (21 subgoals):\n 1. \\<And>x y. cCCexp_graph x y \\<Longrightarrow> True\n 2. \\<And>x xa.\n       Var x = Var xa \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n       (\\<Lambda> n. (esing xa\\<cdot>(up\\<cdot>n), \\<bottom>))\n 3. \\<And>x xa e.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n        \\<And>xa xb. True; Var x = Lam [xa]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))\n 4. \\<And>x e xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC e; \\<And>xa. True; \\<And>xa. True;\n        Var x = App e xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv e)))\n 5. \\<And>x \\<Gamma> e.\n       \\<lbrakk>\\<And>x ea.\n                   ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n                   eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC e;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Var x = Terms.Let \\<Gamma> e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> e))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC e\\<cdot>n)))\n 6. \\<And>x b.\n       Var x = Bool b \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) = \\<bottom>\n 7. \\<And>x scrut e1 e2.\n       \\<lbrakk>\\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. eqvt_at cCCexp_sumC scrut; \\<And>x. eqvt_at cCCexp_sumC e1;\n        \\<And>x. eqvt_at cCCexp_sumC e2; \\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; Var x = (scrut ? e1 : e2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              fst (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                              fst (cCCexp_sumC e2\\<cdot>n),\n                              snd (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              (snd (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                               snd (cCCexp_sumC e2\\<cdot>n)) \\<squnion>\n                              edom\n                               (fst (cCCexp_sumC scrut\\<cdot>0)) G\\<times>\n                              (edom (fst (cCCexp_sumC e1\\<cdot>n)) \\<union>\n                               edom (fst (cCCexp_sumC e2\\<cdot>n)))))\n 8. \\<And>x e ea xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC ea; \\<And>xa. eqvt_at cCCexp_sumC ea;\n        \\<And>xa. True; \\<And>xa xb. True; \\<And>xa. True; \\<And>xa. True;\n        Lam [x]. e = App ea xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv ea)))\n 9. \\<And>x e \\<Gamma> ea.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>x ea.\n           ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n           eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC ea; \\<And>xa. True; \\<And>xa xb. True;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Lam [x]. e = Terms.Let \\<Gamma> ea\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> ea))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC ea\\<cdot>n)))\n 10. \\<And>x e b.\n        \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n         \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n         \\<And>xa xb. True; Lam [x]. e = Bool b\\<rbrakk>\n        \\<Longrightarrow> (\\<Lambda> n.\n                              combined_restrict (fv (Lam [x]. e))\n                               (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [x]. e))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                                n)) =\n                          \\<bottom>\nA total of 21 subgoals...", "from prems(9)"], ["proof (chain)\npicking this:\n  Terms.Let \\<Gamma> body = Terms.Let \\<Gamma>' body'", "show ?case"], ["proof (prove)\nusing this:\n  Terms.Let \\<Gamma> body = Terms.Let \\<Gamma>' body'\n\ngoal (1 subgoal):\n 1. (\\<Lambda> n.\n        combined_restrict (fv (Terms.Let \\<Gamma> body))\n         (CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>\\<cdot>\n          (cCCexp_sumC body\\<cdot>n))) =\n    (\\<Lambda> n.\n        combined_restrict (fv (Terms.Let \\<Gamma>' body'))\n         (CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>'\\<cdot>\n          (cCCexp_sumC body'\\<cdot>n)))", "proof (rule eqvt_let_case)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "fix \\<pi> :: perm"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "assume *: \"supp (-\\<pi>) \\<sharp>* (fv (Terms.Let \\<Gamma> body) :: var set)\""], ["proof (state)\nthis:\n  supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "{"], ["proof (state)\nthis:\n  supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "have \"combined_restrict (fv (Terms.Let \\<Gamma> body)) (CoCallArityAnalysis.cccFix_choose cCCexp_sumC (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>(cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n))\n      =  combined_restrict (fv (Terms.Let \\<Gamma> body)) (- \\<pi> \\<bullet> (CoCallArityAnalysis.cccFix_choose cCCexp_sumC (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>(cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. combined_restrict (fv (Terms.Let \\<Gamma> body))\n     (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n       (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n      (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n)) =\n    combined_restrict (fv (Terms.Let \\<Gamma> body))\n     (- \\<pi> \\<bullet> CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                         (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                        (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n))", "by (rule combined_restrict_perm[OF *, symmetric]) simp"], ["proof (state)\nthis:\n  combined_restrict (fv (Terms.Let \\<Gamma> body))\n   (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n     (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n    (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n)) =\n  combined_restrict (fv (Terms.Let \\<Gamma> body))\n   (- \\<pi> \\<bullet> CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                       (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                      (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "also"], ["proof (state)\nthis:\n  combined_restrict (fv (Terms.Let \\<Gamma> body))\n   (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n     (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n    (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n)) =\n  combined_restrict (fv (Terms.Let \\<Gamma> body))\n   (- \\<pi> \\<bullet> CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                       (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                      (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "have \"- \\<pi> \\<bullet> (CoCallArityAnalysis.cccFix_choose cCCexp_sumC (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>(cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n)) = \n                       CoCallArityAnalysis.cccFix_choose (- \\<pi> \\<bullet> cCCexp_sumC) \\<Gamma>\\<cdot>((- \\<pi> \\<bullet> cCCexp_sumC) body\\<cdot>n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<pi> \\<bullet> CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                       (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                      (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n) =\n    CoCallArityAnalysis.cccFix_choose (- \\<pi> \\<bullet> cCCexp_sumC)\n     \\<Gamma>\\<cdot>\n    ((- \\<pi> \\<bullet> cCCexp_sumC) body\\<cdot>n)", "by (simp add: pemute_minus_self)"], ["proof (state)\nthis:\n  - \\<pi> \\<bullet> CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                     (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                    (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n) =\n  CoCallArityAnalysis.cccFix_choose (- \\<pi> \\<bullet> cCCexp_sumC)\n   \\<Gamma>\\<cdot>\n  ((- \\<pi> \\<bullet> cCCexp_sumC) body\\<cdot>n)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "also"], ["proof (state)\nthis:\n  - \\<pi> \\<bullet> CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                     (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                    (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n) =\n  CoCallArityAnalysis.cccFix_choose (- \\<pi> \\<bullet> cCCexp_sumC)\n   \\<Gamma>\\<cdot>\n  ((- \\<pi> \\<bullet> cCCexp_sumC) body\\<cdot>n)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "have \"CoCallArityAnalysis.cccFix_choose (- \\<pi> \\<bullet> cCCexp_sumC) \\<Gamma> = CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CoCallArityAnalysis.cccFix_choose (- \\<pi> \\<bullet> cCCexp_sumC)\n     \\<Gamma> =\n    CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>", "by (rule cccFix_choose_cong[OF eqvt_at_apply[OF prems(1)] refl])"], ["proof (state)\nthis:\n  CoCallArityAnalysis.cccFix_choose (- \\<pi> \\<bullet> cCCexp_sumC)\n   \\<Gamma> =\n  CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "also"], ["proof (state)\nthis:\n  CoCallArityAnalysis.cccFix_choose (- \\<pi> \\<bullet> cCCexp_sumC)\n   \\<Gamma> =\n  CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "have \"(- \\<pi> \\<bullet> cCCexp_sumC) body = cCCexp_sumC body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- \\<pi> \\<bullet> cCCexp_sumC) body = cCCexp_sumC body", "by (rule eqvt_at_apply[OF prems(2)])"], ["proof (state)\nthis:\n  (- \\<pi> \\<bullet> cCCexp_sumC) body = cCCexp_sumC body\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "also"], ["proof (state)\nthis:\n  (- \\<pi> \\<bullet> cCCexp_sumC) body = cCCexp_sumC body\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "note calculation"], ["proof (state)\nthis:\n  combined_restrict (fv (Terms.Let \\<Gamma> body))\n   (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n     (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n    (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n)) =\n  combined_restrict (fv (Terms.Let \\<Gamma> body))\n   (CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>\\<cdot>\n    (cCCexp_sumC body\\<cdot>n))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "}"], ["proof (state)\nthis:\n  combined_restrict (fv (Terms.Let \\<Gamma> body))\n   (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n     (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n    (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>?n2)) =\n  combined_restrict (fv (Terms.Let \\<Gamma> body))\n   (CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>\\<cdot>\n    (cCCexp_sumC body\\<cdot>?n2))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>supp (- \\<pi>) \\<sharp>* fv (Terms.Let \\<Gamma> body);\n        supp \\<pi> \\<sharp>* Terms.Let \\<Gamma> body\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                               (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>\n                                n))) =\n                         (\\<Lambda> n.\n                             combined_restrict\n                              (fv (Terms.Let \\<Gamma> body))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC body\\<cdot>n)))", "thus \"(\\<Lambda> n. combined_restrict (fv (Terms.Let \\<Gamma> body)) (CoCallArityAnalysis.cccFix_choose cCCexp_sumC (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>(cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n))) =\n         (\\<Lambda> n. combined_restrict (fv (Terms.Let \\<Gamma> body)) (CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>\\<cdot>(cCCexp_sumC body\\<cdot>n)))\""], ["proof (prove)\nusing this:\n  combined_restrict (fv (Terms.Let \\<Gamma> body))\n   (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n     (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n    (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>?n2)) =\n  combined_restrict (fv (Terms.Let \\<Gamma> body))\n   (CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>\\<cdot>\n    (cCCexp_sumC body\\<cdot>?n2))\n\ngoal (1 subgoal):\n 1. (\\<Lambda> n.\n        combined_restrict (fv (Terms.Let \\<Gamma> body))\n         (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n           (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n          (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n))) =\n    (\\<Lambda> n.\n        combined_restrict (fv (Terms.Let \\<Gamma> body))\n         (CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>\\<cdot>\n          (cCCexp_sumC body\\<cdot>n)))", "by (simp only:)"], ["proof (state)\nthis:\n  (\\<Lambda> n.\n      combined_restrict (fv (Terms.Let \\<Gamma> body))\n       (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n         (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n        (cCCexp_sumC (\\<pi> \\<bullet> body)\\<cdot>n))) =\n  (\\<Lambda> n.\n      combined_restrict (fv (Terms.Let \\<Gamma> body))\n       (CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>\\<cdot>\n        (cCCexp_sumC body\\<cdot>n)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Lambda> n.\n      combined_restrict (fv (Terms.Let \\<Gamma> body))\n       (CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>\\<cdot>\n        (cCCexp_sumC body\\<cdot>n))) =\n  (\\<Lambda> n.\n      combined_restrict (fv (Terms.Let \\<Gamma>' body'))\n       (CoCallArityAnalysis.cccFix_choose cCCexp_sumC \\<Gamma>'\\<cdot>\n        (cCCexp_sumC body'\\<cdot>n)))\n\ngoal (20 subgoals):\n 1. \\<And>x y. cCCexp_graph x y \\<Longrightarrow> True\n 2. \\<And>x xa.\n       Var x = Var xa \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n       (\\<Lambda> n. (esing xa\\<cdot>(up\\<cdot>n), \\<bottom>))\n 3. \\<And>x xa e.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n        \\<And>xa xb. True; Var x = Lam [xa]. e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Lam [xa]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [xa]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n))\n 4. \\<And>x e xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC e; \\<And>xa. True; \\<And>xa. True;\n        Var x = App e xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC e\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv e)))\n 5. \\<And>x \\<Gamma> e.\n       \\<lbrakk>\\<And>x ea.\n                   ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n                   eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC e;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Var x = Terms.Let \\<Gamma> e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> e))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC e\\<cdot>n)))\n 6. \\<And>x b.\n       Var x = Bool b \\<Longrightarrow>\n       (\\<Lambda> n. (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) = \\<bottom>\n 7. \\<And>x scrut e1 e2.\n       \\<lbrakk>\\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. eqvt_at cCCexp_sumC scrut; \\<And>x. eqvt_at cCCexp_sumC e1;\n        \\<And>x. eqvt_at cCCexp_sumC e2; \\<And>x. eqvt_at cCCexp_sumC scrut;\n        \\<And>x. eqvt_at cCCexp_sumC e1; \\<And>x. eqvt_at cCCexp_sumC e2;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; \\<And>x. True; \\<And>x. True; \\<And>x. True;\n        \\<And>x. True; Var x = (scrut ? e1 : e2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             (esing x\\<cdot>(up\\<cdot>n), \\<bottom>)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              fst (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                              fst (cCCexp_sumC e2\\<cdot>n),\n                              snd (cCCexp_sumC scrut\\<cdot>0) \\<squnion>\n                              (snd (cCCexp_sumC e1\\<cdot>n) \\<squnion>\n                               snd (cCCexp_sumC e2\\<cdot>n)) \\<squnion>\n                              edom\n                               (fst (cCCexp_sumC scrut\\<cdot>0)) G\\<times>\n                              (edom (fst (cCCexp_sumC e1\\<cdot>n)) \\<union>\n                               edom (fst (cCCexp_sumC e2\\<cdot>n)))))\n 8. \\<And>x e ea xa.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>xa. eqvt_at cCCexp_sumC ea; \\<And>xa. eqvt_at cCCexp_sumC ea;\n        \\<And>xa. True; \\<And>xa xb. True; \\<And>xa. True; \\<And>xa. True;\n        Lam [x]. e = App ea xa\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             (fst (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              esing xa\\<cdot>(up\\<cdot>0),\n                              snd (cCCexp_sumC ea\\<cdot>\n                                   (inc\\<cdot>n)) \\<squnion>\n                              {xa} G\\<times> insert xa (fv ea)))\n 9. \\<And>x e \\<Gamma> ea.\n       \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n        \\<And>xa xb. eqvt_at cCCexp_sumC e;\n        \\<And>x ea.\n           ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow>\n           eqvt_at cCCexp_sumC ea;\n        \\<And>x. eqvt_at cCCexp_sumC ea; \\<And>xa. True; \\<And>xa xb. True;\n        \\<And>x ea. ea \\<in> snd ` set \\<Gamma> \\<Longrightarrow> True;\n        \\<And>x. True; Lam [x]. e = Terms.Let \\<Gamma> ea\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> n.\n                             combined_restrict (fv (Lam [x]. e))\n                              (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                               predCC (fv (Lam [x]. e))\n                                (\\<Lambda> a.\n                                    snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                               n)) =\n                         (\\<Lambda> n.\n                             combined_restrict (fv (Terms.Let \\<Gamma> ea))\n                              (CoCallArityAnalysis.cccFix_choose cCCexp_sumC\n                                \\<Gamma>\\<cdot>\n                               (cCCexp_sumC ea\\<cdot>n)))\n 10. \\<And>x e b.\n        \\<lbrakk>\\<And>xa. eqvt_at cCCexp_sumC e;\n         \\<And>xa xb. eqvt_at cCCexp_sumC e; \\<And>xa. True;\n         \\<And>xa xb. True; Lam [x]. e = Bool b\\<rbrakk>\n        \\<Longrightarrow> (\\<Lambda> n.\n                              combined_restrict (fv (Lam [x]. e))\n                               (fst (cCCexp_sumC e\\<cdot>(pred\\<cdot>n)),\n                                predCC (fv (Lam [x]. e))\n                                 (\\<Lambda> a.\n                                     snd (cCCexp_sumC e\\<cdot>a))\\<cdot>\n                                n)) =\n                          \\<bottom>\nA total of 20 subgoals...", "qed auto"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. All cCCexp_dom", "by lexicographic_order"], ["", "locale CoCallAnalysisImpl\nbegin"], ["", "sublocale CoCallArityAnalysis cCCexp"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale ArityAnalysis Aexp"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation Aexp_syn'' (\"\\<A>\\<^bsub>_\\<^esub>\") where \"\\<A>\\<^bsub>a\\<^esub> e \\<equiv> Aexp e\\<cdot>a\""], ["", "abbreviation Aexp_bot_syn'' (\"\\<A>\\<^sup>\\<bottom>\\<^bsub>_\\<^esub>\") where \"\\<A>\\<^sup>\\<bottom>\\<^bsub>a\\<^esub> e \\<equiv> fup\\<cdot>(Aexp e)\\<cdot>a\""], ["", "abbreviation ccExp_syn'' (\"\\<G>\\<^bsub>_\\<^esub>\") where \"\\<G>\\<^bsub>a\\<^esub> e \\<equiv> CCexp e\\<cdot>a\""], ["", "abbreviation ccExp_bot_syn'' (\"\\<G>\\<^sup>\\<bottom>\\<^bsub>_\\<^esub>\") where \"\\<G>\\<^sup>\\<bottom>\\<^bsub>a\\<^esub> e \\<equiv> fup\\<cdot>(CCexp e)\\<cdot>a\""], ["", "lemma cCCexp_eq[simp]:\n  \"cCCexp (Var x)\\<cdot>n =      (esing x \\<cdot> (up \\<cdot> n),                                   \\<bottom>)\"\n  \"cCCexp (Lam [x]. e)\\<cdot>n = combined_restrict (fv (Lam [x]. e)) (fst (cCCexp e\\<cdot>(pred\\<cdot>n)), predCC (fv (Lam [x]. e)) (\\<Lambda> a. snd(cCCexp e\\<cdot>a))\\<cdot>n)\"\n  \"cCCexp (App e x)\\<cdot>n =    (fst (cCCexp e\\<cdot>(inc\\<cdot>n)) \\<squnion> (esing x \\<cdot> (up\\<cdot>0)),          snd (cCCexp e\\<cdot>(inc\\<cdot>n)) \\<squnion> ccProd {x} (insert x (fv e)))\"\n  \"cCCexp (Let \\<Gamma> e)\\<cdot>n =    combined_restrict (fv (Let \\<Gamma> e)) (CoCallArityAnalysis.cccFix_choose cCCexp \\<Gamma> \\<cdot> (cCCexp e\\<cdot>n))\"\n  \"cCCexp (Bool b)\\<cdot>n = \\<bottom>\"\n  \"cCCexp (scrut ? e1 : e2)\\<cdot>n = (fst (cCCexp scrut\\<cdot>0) \\<squnion> fst (cCCexp e1\\<cdot>n) \\<squnion> fst (cCCexp e2\\<cdot>n),\n        snd (cCCexp scrut\\<cdot>0) \\<squnion> (snd (cCCexp e1\\<cdot>n) \\<squnion> snd (cCCexp e2\\<cdot>n)) \\<squnion> ccProd (edom (fst (cCCexp scrut\\<cdot>0))) (edom (fst (cCCexp e1\\<cdot>n)) \\<union> edom (fst (cCCexp e2\\<cdot>n))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cCCexp (Var x)\\<cdot>n = (esing x\\<cdot>(up\\<cdot>n), \\<bottom>) &&&\n     cCCexp (Lam [x]. e)\\<cdot>n =\n     combined_restrict (fv (Lam [x]. e))\n      (fst (cCCexp e\\<cdot>(pred\\<cdot>n)),\n       predCC (fv (Lam [x]. e)) (\\<Lambda> a. snd (cCCexp e\\<cdot>a))\\<cdot>\n       n) &&&\n     cCCexp (App e x)\\<cdot>n =\n     (fst (cCCexp e\\<cdot>(inc\\<cdot>n)) \\<squnion>\n      esing x\\<cdot>(up\\<cdot>0),\n      snd (cCCexp e\\<cdot>(inc\\<cdot>n)) \\<squnion>\n      {x} G\\<times> insert x (fv e))) &&&\n    cCCexp (Terms.Let \\<Gamma> e)\\<cdot>n =\n    combined_restrict (fv (Terms.Let \\<Gamma> e))\n     (cccFix_choose \\<Gamma>\\<cdot>(cCCexp e\\<cdot>n)) &&&\n    cCCexp (Bool b)\\<cdot>n = \\<bottom> &&&\n    cCCexp (scrut ? e1 : e2)\\<cdot>n =\n    (fst (cCCexp scrut\\<cdot>0) \\<squnion>\n     fst (cCCexp e1\\<cdot>n) \\<squnion>\n     fst (cCCexp e2\\<cdot>n),\n     snd (cCCexp scrut\\<cdot>0) \\<squnion>\n     (snd (cCCexp e1\\<cdot>n) \\<squnion> snd (cCCexp e2\\<cdot>n)) \\<squnion>\n     edom (fst (cCCexp scrut\\<cdot>0)) G\\<times>\n     (edom (fst (cCCexp e1\\<cdot>n)) \\<union>\n      edom (fst (cCCexp e2\\<cdot>n))))", "by (simp_all)"], ["", "declare cCCexp.simps[simp del]"], ["", "lemma Aexp_pre_simps:\n  \"\\<A>\\<^bsub>a\\<^esub> (Var x) = esing x\\<cdot>(up\\<cdot>a)\"\n  \"\\<A>\\<^bsub>a\\<^esub> (Lam [x]. e) = Aexp e\\<cdot>(pred\\<cdot>a) f|` fv (Lam [x]. e)\"\n  \"\\<A>\\<^bsub>a\\<^esub> (App e x) = Aexp e\\<cdot>(inc\\<cdot>a) \\<squnion> esing x\\<cdot>(up\\<cdot>0)\"\n  \"\\<not> nonrec \\<Gamma> \\<Longrightarrow>\n     \\<A>\\<^bsub>a\\<^esub> (Let \\<Gamma> e) = (Afix \\<Gamma>\\<cdot>(\\<A>\\<^bsub>a\\<^esub> e \\<squnion> (\\<lambda>_.up\\<cdot>0) f|` thunks \\<Gamma>)) f|` (fv (Let \\<Gamma> e))\"\n  \"x \\<notin> fv e \\<Longrightarrow>\n     \\<A>\\<^bsub>a\\<^esub> (let x be e in exp) =\n        (fup\\<cdot>(Aexp e)\\<cdot>(ABind_nonrec x e\\<cdot>(\\<A>\\<^bsub>a\\<^esub> exp, CCexp exp\\<cdot>a)) \\<squnion> \\<A>\\<^bsub>a\\<^esub> exp)\n            f|` (fv (let x be e in exp))\"\n  \"\\<A>\\<^bsub>a\\<^esub> (Bool b) = \\<bottom>\"\n  \"\\<A>\\<^bsub>a\\<^esub> (scrut ? e1 : e2) = \\<A>\\<^bsub>0\\<^esub> scrut \\<squnion> \\<A>\\<^bsub>a\\<^esub> e1 \\<squnion> \\<A>\\<^bsub>a\\<^esub> e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Aexp_syn' a (Var x) = esing x\\<cdot>(up\\<cdot>a) &&&\n     Aexp_syn' a (Lam [x]. e) =\n     Aexp_syn' (pred\\<cdot>a) e f|` fv (Lam [x]. e) &&&\n     Aexp_syn' a (App e x) =\n     Aexp_syn' (inc\\<cdot>a) e \\<squnion> esing x\\<cdot>(up\\<cdot>0)) &&&\n    ((\\<not> nonrec \\<Gamma> \\<Longrightarrow>\n      Aexp_syn' a (Terms.Let \\<Gamma> e) =\n      Afix \\<Gamma>\\<cdot>\n      (Aexp_syn' a e \\<squnion>\n       (\\<lambda>_. up\\<cdot>0) f|` thunks \\<Gamma>) f|`\n      fv (Terms.Let \\<Gamma> e)) &&&\n     (x \\<notin> fv e \\<Longrightarrow>\n      Aexp_syn' a (let x be e in exp ) =\n      (Aexp_bot_syn'\n        (ABind_nonrec x e\\<cdot>(Aexp_syn' a exp, ccExp_syn a exp))\n        e \\<squnion>\n       Aexp_syn' a exp) f|`\n      fv (let x be e in exp ))) &&&\n    Aexp_syn' a (Bool b) = \\<bottom> &&&\n    Aexp_syn' a (scrut ? e1 : e2) =\n    Aexp_syn' 0 scrut \\<squnion> Aexp_syn' a e1 \\<squnion> Aexp_syn' a e2", "by (simp add: cccFix_eq Aexp_eq fup_Aexp_eq CCexp_eq fup_CCexp_eq)+"], ["", "lemma CCexp_pre_simps:\n  \"CCexp (Var x)\\<cdot>n = \\<bottom>\"\n  \"CCexp (Lam [x]. e)\\<cdot>n = predCC (fv (Lam [x]. e)) (CCexp e)\\<cdot>n\"\n  \"CCexp (App e x)\\<cdot>n = CCexp e\\<cdot>(inc\\<cdot>n) \\<squnion> ccProd {x} (insert x (fv e))\"\n  \"\\<not> nonrec \\<Gamma> \\<Longrightarrow>\n      CCexp (Let \\<Gamma> e)\\<cdot>n = cc_restr (fv (Let \\<Gamma> e))\n        (CCfix \\<Gamma>\\<cdot>(Afix \\<Gamma>\\<cdot>(Aexp e\\<cdot>n \\<squnion> (\\<lambda>_.up\\<cdot>0) f|` thunks \\<Gamma>), CCexp e\\<cdot>n))\"\n  \"x \\<notin> fv e \\<Longrightarrow> CCexp (let x be e in exp)\\<cdot>n =\n    cc_restr (fv (let x be e in exp))\n       (ccBind x e \\<cdot>(Aheap_nonrec x e\\<cdot>(Aexp exp\\<cdot>n, CCexp exp\\<cdot>n), CCexp exp\\<cdot>n)\n       \\<squnion> ccProd (fv e) (ccNeighbors x (CCexp exp\\<cdot>n) - (if isVal e then {} else {x})) \\<squnion> CCexp exp\\<cdot>n)\"\n  \"CCexp (Bool b)\\<cdot>n = \\<bottom>\"\n  \"CCexp (scrut ? e1 : e2)\\<cdot>n =\n       CCexp scrut\\<cdot>0 \\<squnion>\n       (CCexp e1\\<cdot>n \\<squnion> CCexp e2\\<cdot>n) \\<squnion>\n       ccProd (edom (Aexp scrut\\<cdot>0)) (edom (Aexp e1\\<cdot>n) \\<union> edom (Aexp e2\\<cdot>n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ccExp_syn n (Var x) = \\<bottom> &&&\n     ccExp_syn n (Lam [x]. e) =\n     predCC (fv (Lam [x]. e)) (CCexp e)\\<cdot>n &&&\n     ccExp_syn n (App e x) =\n     ccExp_syn (inc\\<cdot>n) e \\<squnion> {x} G\\<times> insert x (fv e)) &&&\n    ((\\<not> nonrec \\<Gamma> \\<Longrightarrow>\n      ccExp_syn n (Terms.Let \\<Gamma> e) =\n      CCfix \\<Gamma>\\<cdot>\n      (Afix \\<Gamma>\\<cdot>\n       (Aexp_syn' n e \\<squnion>\n        (\\<lambda>_. up\\<cdot>0) f|` thunks \\<Gamma>),\n       ccExp_syn n e) G|`\n      fv (Terms.Let \\<Gamma> e)) &&&\n     (x \\<notin> fv e \\<Longrightarrow>\n      ccExp_syn n (let x be e in exp ) =\n      (ccBind x e\\<cdot>\n       (Aheap_nonrec x e\\<cdot>(Aexp_syn' n exp, ccExp_syn n exp),\n        ccExp_syn n exp) \\<squnion>\n       fv e G\\<times>\n       (ccNeighbors x (ccExp_syn n exp) -\n        (if isVal e then {} else {x})) \\<squnion>\n       ccExp_syn n exp) G|`\n      fv (let x be e in exp ))) &&&\n    ccExp_syn n (Bool b) = \\<bottom> &&&\n    ccExp_syn n (scrut ? e1 : e2) =\n    ccExp_syn 0 scrut \\<squnion>\n    (ccExp_syn n e1 \\<squnion> ccExp_syn n e2) \\<squnion>\n    edom (Aexp_syn' 0 scrut) G\\<times>\n    (edom (Aexp_syn' n e1) \\<union> edom (Aexp_syn' n e2))", "by (simp add: cccFix_eq Aexp_eq fup_Aexp_eq CCexp_eq fup_CCexp_eq predCC_eq)+"], ["", "lemma \n  shows ccField_CCexp: \"ccField (CCexp e\\<cdot>a) \\<subseteq> fv e\" and Aexp_edom': \"edom (\\<A>\\<^bsub>a\\<^esub> e) \\<subseteq> fv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField (ccExp_syn a e) \\<subseteq> fv e &&&\n    edom (Aexp_syn' a e) \\<subseteq> fv e", "apply (induction e arbitrary: a rule: exp_induct_rec)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>var a. ccField (ccExp_syn a (Var var)) \\<subseteq> fv (Var var)\n 2. \\<And>var a. edom (Aexp_syn' a (Var var)) \\<subseteq> fv (Var var)\n 3. \\<And>exp var a.\n       \\<lbrakk>\\<And>a. ccField (ccExp_syn a exp) \\<subseteq> fv exp;\n        \\<And>a. edom (Aexp_syn' a exp) \\<subseteq> fv exp\\<rbrakk>\n       \\<Longrightarrow> ccField (ccExp_syn a (App exp var))\n                         \\<subseteq> fv (App exp var)\n 4. \\<And>exp var a.\n       \\<lbrakk>\\<And>a. ccField (ccExp_syn a exp) \\<subseteq> fv exp;\n        \\<And>a. edom (Aexp_syn' a exp) \\<subseteq> fv exp\\<rbrakk>\n       \\<Longrightarrow> edom (Aexp_syn' a (App exp var))\n                         \\<subseteq> fv (App exp var)\n 5. \\<And>\\<Gamma> exp a.\n       \\<lbrakk>\\<not> nonrec \\<Gamma>;\n        \\<And>x a.\n           x \\<in> domA \\<Gamma> \\<Longrightarrow>\n           ccField (ccExp_syn a (the (map_of \\<Gamma> x)))\n           \\<subseteq> fv (the (map_of \\<Gamma> x));\n        \\<And>x a.\n           x \\<in> domA \\<Gamma> \\<Longrightarrow>\n           edom (Aexp_syn' a (the (map_of \\<Gamma> x)))\n           \\<subseteq> fv (the (map_of \\<Gamma> x));\n        \\<And>a. ccField (ccExp_syn a exp) \\<subseteq> fv exp;\n        \\<And>a. edom (Aexp_syn' a exp) \\<subseteq> fv exp\\<rbrakk>\n       \\<Longrightarrow> ccField (ccExp_syn a (Terms.Let \\<Gamma> exp))\n                         \\<subseteq> fv (Terms.Let \\<Gamma> exp)\n 6. \\<And>\\<Gamma> exp a.\n       \\<lbrakk>\\<not> nonrec \\<Gamma>;\n        \\<And>x a.\n           x \\<in> domA \\<Gamma> \\<Longrightarrow>\n           ccField (ccExp_syn a (the (map_of \\<Gamma> x)))\n           \\<subseteq> fv (the (map_of \\<Gamma> x));\n        \\<And>x a.\n           x \\<in> domA \\<Gamma> \\<Longrightarrow>\n           edom (Aexp_syn' a (the (map_of \\<Gamma> x)))\n           \\<subseteq> fv (the (map_of \\<Gamma> x));\n        \\<And>a. ccField (ccExp_syn a exp) \\<subseteq> fv exp;\n        \\<And>a. edom (Aexp_syn' a exp) \\<subseteq> fv exp\\<rbrakk>\n       \\<Longrightarrow> edom (Aexp_syn' a (Terms.Let \\<Gamma> exp))\n                         \\<subseteq> fv (Terms.Let \\<Gamma> exp)\n 7. \\<And>x e exp a.\n       \\<lbrakk>x \\<notin> fv e;\n        \\<And>a. ccField (ccExp_syn a e) \\<subseteq> fv e;\n        \\<And>a. edom (Aexp_syn' a e) \\<subseteq> fv e;\n        \\<And>a. ccField (ccExp_syn a exp) \\<subseteq> fv exp;\n        \\<And>a. edom (Aexp_syn' a exp) \\<subseteq> fv exp\\<rbrakk>\n       \\<Longrightarrow> ccField (ccExp_syn a (let x be e in exp ))\n                         \\<subseteq> fv (let x be e in exp )\n 8. \\<And>x e exp a.\n       \\<lbrakk>x \\<notin> fv e;\n        \\<And>a. ccField (ccExp_syn a e) \\<subseteq> fv e;\n        \\<And>a. edom (Aexp_syn' a e) \\<subseteq> fv e;\n        \\<And>a. ccField (ccExp_syn a exp) \\<subseteq> fv exp;\n        \\<And>a. edom (Aexp_syn' a exp) \\<subseteq> fv exp\\<rbrakk>\n       \\<Longrightarrow> edom (Aexp_syn' a (let x be e in exp ))\n                         \\<subseteq> fv (let x be e in exp )\n 9. \\<And>var exp a.\n       \\<lbrakk>\\<And>a. ccField (ccExp_syn a exp) \\<subseteq> fv exp;\n        \\<And>a. edom (Aexp_syn' a exp) \\<subseteq> fv exp\\<rbrakk>\n       \\<Longrightarrow> ccField (ccExp_syn a (Lam [var]. exp))\n                         \\<subseteq> fv (Lam [var]. exp)\n 10. \\<And>var exp a.\n        \\<lbrakk>\\<And>a. ccField (ccExp_syn a exp) \\<subseteq> fv exp;\n         \\<And>a. edom (Aexp_syn' a exp) \\<subseteq> fv exp\\<rbrakk>\n        \\<Longrightarrow> edom (Aexp_syn' a (Lam [var]. exp))\n                          \\<subseteq> fv (Lam [var]. exp)\nA total of 14 subgoals...", "apply (auto simp add: CCexp_pre_simps predCC_eq Aexp_pre_simps dest!: subsetD[OF ccField_cc_restr] subsetD[OF ccField_ccProd_subset])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>scrut e1 e2 a x.\n       \\<lbrakk>\\<And>a. ccField (ccExp_syn a scrut) \\<subseteq> fv scrut;\n        \\<And>a. edom (Aexp_syn' a scrut) \\<subseteq> fv scrut;\n        \\<And>a. ccField (ccExp_syn a e1) \\<subseteq> fv e1;\n        \\<And>a. edom (Aexp_syn' a e1) \\<subseteq> fv e1;\n        \\<And>a. ccField (ccExp_syn a e2) \\<subseteq> fv e2;\n        \\<And>a. edom (Aexp_syn' a e2) \\<subseteq> fv e2;\n        x \\<in> ccField (ccExp_syn a e1); x \\<notin> fv e2;\n        x \\<notin> fv e1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fv scrut\n 2. \\<And>scrut e1 e2 a x.\n       \\<lbrakk>\\<And>a. ccField (ccExp_syn a scrut) \\<subseteq> fv scrut;\n        \\<And>a. edom (Aexp_syn' a scrut) \\<subseteq> fv scrut;\n        \\<And>a. ccField (ccExp_syn a e1) \\<subseteq> fv e1;\n        \\<And>a. edom (Aexp_syn' a e1) \\<subseteq> fv e1;\n        \\<And>a. ccField (ccExp_syn a e2) \\<subseteq> fv e2;\n        \\<And>a. edom (Aexp_syn' a e2) \\<subseteq> fv e2;\n        x \\<in> ccField (ccExp_syn a e2); x \\<notin> fv e2;\n        x \\<notin> fv e1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fv scrut\n 3. \\<And>scrut e1 e2 a x.\n       \\<lbrakk>\\<And>a. ccField (ccExp_syn a scrut) \\<subseteq> fv scrut;\n        \\<And>a. edom (Aexp_syn' a scrut) \\<subseteq> fv scrut;\n        \\<And>a. ccField (ccExp_syn a e1) \\<subseteq> fv e1;\n        \\<And>a. edom (Aexp_syn' a e1) \\<subseteq> fv e1;\n        \\<And>a. ccField (ccExp_syn a e2) \\<subseteq> fv e2;\n        \\<And>a. edom (Aexp_syn' a e2) \\<subseteq> fv e2; x \\<notin> fv e2;\n        x \\<notin> fv e1; x \\<in> edom (Aexp_syn' a e1)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fv scrut\n 4. \\<And>scrut e1 e2 a x.\n       \\<lbrakk>\\<And>a. ccField (ccExp_syn a scrut) \\<subseteq> fv scrut;\n        \\<And>a. edom (Aexp_syn' a scrut) \\<subseteq> fv scrut;\n        \\<And>a. ccField (ccExp_syn a e1) \\<subseteq> fv e1;\n        \\<And>a. edom (Aexp_syn' a e1) \\<subseteq> fv e1;\n        \\<And>a. ccField (ccExp_syn a e2) \\<subseteq> fv e2;\n        \\<And>a. edom (Aexp_syn' a e2) \\<subseteq> fv e2; x \\<notin> fv e2;\n        x \\<notin> fv e1; x \\<in> edom (Aexp_syn' a e2)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fv scrut\n 5. \\<And>scrut e1 e2 a x.\n       \\<lbrakk>\\<And>a. ccField (ccExp_syn a scrut) \\<subseteq> fv scrut;\n        \\<And>a. edom (Aexp_syn' a scrut) \\<subseteq> fv scrut;\n        \\<And>a. ccField (ccExp_syn a e1) \\<subseteq> fv e1;\n        \\<And>a. edom (Aexp_syn' a e1) \\<subseteq> fv e1;\n        \\<And>a. ccField (ccExp_syn a e2) \\<subseteq> fv e2;\n        \\<And>a. edom (Aexp_syn' a e2) \\<subseteq> fv e2;\n        x \\<in> edom (Aexp_syn' a e1); x \\<notin> fv e2;\n        x \\<notin> fv e1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fv scrut\n 6. \\<And>scrut e1 e2 a x.\n       \\<lbrakk>\\<And>a. ccField (ccExp_syn a scrut) \\<subseteq> fv scrut;\n        \\<And>a. edom (Aexp_syn' a scrut) \\<subseteq> fv scrut;\n        \\<And>a. ccField (ccExp_syn a e1) \\<subseteq> fv e1;\n        \\<And>a. edom (Aexp_syn' a e1) \\<subseteq> fv e1;\n        \\<And>a. ccField (ccExp_syn a e2) \\<subseteq> fv e2;\n        \\<And>a. edom (Aexp_syn' a e2) \\<subseteq> fv e2;\n        x \\<in> edom (Aexp_syn' a e2); x \\<notin> fv e2;\n        x \\<notin> fv e1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fv scrut", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cc_restr_CCexp[simp]:\n  \"cc_restr (fv e) (CCexp e\\<cdot>a) = CCexp e\\<cdot>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccExp_syn a e G|` fv e = ccExp_syn a e", "by (rule cc_restr_noop[OF ccField_CCexp])"], ["", "lemma ccField_fup_CCexp:\n  \"ccField (fup\\<cdot>(CCexp e)\\<cdot>n) \\<subseteq> fv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccField (ccExp_bot_syn n e) \\<subseteq> fv e", "by (cases n) (auto dest: subsetD[OF ccField_CCexp])"], ["", "lemma cc_restr_fup_ccExp_useless[simp]: \"cc_restr (fv e) (fup\\<cdot>(CCexp e)\\<cdot>n) = fup\\<cdot>(CCexp e)\\<cdot>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccExp_bot_syn n e G|` fv e = ccExp_bot_syn n e", "by (rule cc_restr_noop[OF ccField_fup_CCexp])"], ["", "sublocale EdomArityAnalysis Aexp"], ["proof (prove)\ngoal (1 subgoal):\n 1. EdomArityAnalysis Aexp", "by standard (rule Aexp_edom')"], ["", "lemma CCexp_simps[simp]:\n  \"\\<G>\\<^bsub>a\\<^esub>(Var x) = \\<bottom>\"\n  \"\\<G>\\<^bsub>0\\<^esub>(Lam [x]. e) = (fv (Lam [x]. e))\\<^sup>2\"\n  \"\\<G>\\<^bsub>inc\\<cdot>a\\<^esub>(Lam [x]. e) = cc_delete x (\\<G>\\<^bsub>a\\<^esub> e)\"\n  \"\\<G>\\<^bsub>a\\<^esub> (App e x) = \\<G>\\<^bsub>inc\\<cdot>a\\<^esub> e \\<squnion> {x} G\\<times>insert x (fv e)\"\n  \"\\<not> nonrec \\<Gamma> \\<Longrightarrow> \\<G>\\<^bsub>a\\<^esub> (Let \\<Gamma> e) =\n    (CCfix \\<Gamma>\\<cdot>(Afix \\<Gamma>\\<cdot>(\\<A>\\<^bsub>a\\<^esub> e \\<squnion> (\\<lambda>_.up\\<cdot>0) f|` thunks \\<Gamma>), \\<G>\\<^bsub>a\\<^esub> e)) G|` (- domA \\<Gamma>)\"\n  \"x \\<notin> fv e' \\<Longrightarrow> \\<G>\\<^bsub>a\\<^esub> (let x be e' in e) =\n    cc_delete x\n       (ccBind x e' \\<cdot>(Aheap_nonrec x e'\\<cdot>(\\<A>\\<^bsub>a\\<^esub> e, \\<G>\\<^bsub>a\\<^esub> e), \\<G>\\<^bsub>a\\<^esub> e)\n       \\<squnion> fv e' G\\<times> (ccNeighbors x (\\<G>\\<^bsub>a\\<^esub> e) - (if isVal e' then {} else {x})) \\<squnion> \\<G>\\<^bsub>a\\<^esub> e)\"\n  \"\\<G>\\<^bsub>a\\<^esub> (Bool b) = \\<bottom>\"\n  \"\\<G>\\<^bsub>a\\<^esub> (scrut ? e1 : e2) =\n       \\<G>\\<^bsub>0\\<^esub> scrut \\<squnion> (\\<G>\\<^bsub>a\\<^esub> e1 \\<squnion> \\<G>\\<^bsub>a\\<^esub> e2) \\<squnion>\n       edom (\\<A>\\<^bsub>0\\<^esub> scrut) G\\<times> (edom (\\<A>\\<^bsub>a\\<^esub> e1) \\<union> edom (\\<A>\\<^bsub>a\\<^esub> e2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ccExp_syn a (Var x) = \\<bottom> &&&\n      ccExp_syn 0 (Lam [x]. e) = fv (Lam [x]. e)\\<^sup>2) &&&\n     ccExp_syn (inc\\<cdot>a) (Lam [x]. e) = cc_delete x (ccExp_syn a e) &&&\n     ccExp_syn a (App e x) =\n     ccExp_syn (inc\\<cdot>a) e \\<squnion> {x} G\\<times> insert x (fv e)) &&&\n    ((\\<not> nonrec \\<Gamma> \\<Longrightarrow>\n      ccExp_syn a (Terms.Let \\<Gamma> e) =\n      CCfix \\<Gamma>\\<cdot>\n      (Afix \\<Gamma>\\<cdot>\n       (Aexp_syn' a e \\<squnion>\n        (\\<lambda>_. up\\<cdot>0) f|` thunks \\<Gamma>),\n       ccExp_syn a e) G|`\n      (- domA \\<Gamma>)) &&&\n     (x \\<notin> fv e' \\<Longrightarrow>\n      ccExp_syn a (let x be e' in e ) =\n      cc_delete x\n       (ccBind x e'\\<cdot>\n        (Aheap_nonrec x e'\\<cdot>(Aexp_syn' a e, ccExp_syn a e),\n         ccExp_syn a e) \\<squnion>\n        fv e' G\\<times>\n        (ccNeighbors x (ccExp_syn a e) -\n         (if isVal e' then {} else {x})) \\<squnion>\n        ccExp_syn a e))) &&&\n    ccExp_syn a (Bool b) = \\<bottom> &&&\n    ccExp_syn a (scrut ? e1 : e2) =\n    ccExp_syn 0 scrut \\<squnion>\n    (ccExp_syn a e1 \\<squnion> ccExp_syn a e2) \\<squnion>\n    edom (Aexp_syn' 0 scrut) G\\<times>\n    (edom (Aexp_syn' a e1) \\<union> edom (Aexp_syn' a e2))", "by (auto simp add: CCexp_pre_simps Diff_eq cc_restr_cc_restr[symmetric] predCC_eq \n            simp del: cc_restr_cc_restr cc_restr_join\n            intro!: cc_restr_noop\n            dest!: subsetD[OF ccField_cc_delete] subsetD[OF ccField_cc_restr]  subsetD[OF ccField_CCexp]\n                   subsetD[OF ccField_CCfix] subsetD[OF ccField_ccBind]  subsetD[OF ccField_ccProd_subset] elem_to_ccField\n     )"], ["", "definition Aheap where\n  \"Aheap \\<Gamma> e = (\\<Lambda> a. if nonrec \\<Gamma> then (case_prod Aheap_nonrec (hd \\<Gamma>))\\<cdot>(Aexp e\\<cdot>a, CCexp e\\<cdot>a) else  (Afix \\<Gamma> \\<cdot> (Aexp e\\<cdot>a \\<squnion> (\\<lambda>_.up\\<cdot>0) f|` thunks \\<Gamma>)) f|` domA \\<Gamma>)\""], ["", "lemma Aheap_simp1[simp]:\n  \"\\<not> nonrec \\<Gamma> \\<Longrightarrow> Aheap \\<Gamma> e \\<cdot>a = (Afix \\<Gamma> \\<cdot> (Aexp e\\<cdot>a \\<squnion> (\\<lambda>_.up\\<cdot>0) f|` thunks \\<Gamma>)) f|` domA \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nonrec \\<Gamma> \\<Longrightarrow>\n    Aheap \\<Gamma> e\\<cdot>a =\n    Afix \\<Gamma>\\<cdot>\n    (Aexp_syn' a e \\<squnion>\n     (\\<lambda>_. up\\<cdot>0) f|` thunks \\<Gamma>) f|`\n    domA \\<Gamma>", "unfolding Aheap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nonrec \\<Gamma> \\<Longrightarrow>\n    (\\<Lambda> a.\n        if nonrec \\<Gamma>\n        then (case hd \\<Gamma> of\n              (x, xa) \\<Rightarrow> Aheap_nonrec x xa)\\<cdot>\n             (Aexp_syn' a e, ccExp_syn a e)\n        else Afix \\<Gamma>\\<cdot>\n             (Aexp_syn' a e \\<squnion>\n              (\\<lambda>_. up\\<cdot>0) f|` thunks \\<Gamma>) f|`\n             domA \\<Gamma>)\\<cdot>\n    a =\n    Afix \\<Gamma>\\<cdot>\n    (Aexp_syn' a e \\<squnion>\n     (\\<lambda>_. up\\<cdot>0) f|` thunks \\<Gamma>) f|`\n    domA \\<Gamma>", "by simp"], ["", "lemma Aheap_simp2[simp]:\n  \"x \\<notin> fv e' \\<Longrightarrow> Aheap [(x,e')] e \\<cdot>a = Aheap_nonrec x e'\\<cdot>(Aexp e\\<cdot>a, CCexp e\\<cdot>a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fv e' \\<Longrightarrow>\n    Aheap [(x, e')] e\\<cdot>a =\n    Aheap_nonrec x e'\\<cdot>(Aexp_syn' a e, ccExp_syn a e)", "unfolding Aheap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fv e' \\<Longrightarrow>\n    (\\<Lambda> a.\n        if nonrec [(x, e')]\n        then (case hd [(x, e')] of\n              (x, xa) \\<Rightarrow> Aheap_nonrec x xa)\\<cdot>\n             (Aexp_syn' a e, ccExp_syn a e)\n        else Afix [(x, e')]\\<cdot>\n             (Aexp_syn' a e \\<squnion>\n              (\\<lambda>_. up\\<cdot>0) f|` thunks [(x, e')]) f|`\n             domA [(x, e')])\\<cdot>\n    a =\n    Aheap_nonrec x e'\\<cdot>(Aexp_syn' a e, ccExp_syn a e)", "by (simp add: nonrec_def)"], ["", "lemma Aheap_eqvt'[eqvt]:\n  \"\\<pi> \\<bullet> (Aheap \\<Gamma> e) = Aheap (\\<pi> \\<bullet> \\<Gamma>) (\\<pi> \\<bullet> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> Aheap \\<Gamma> e =\n    Aheap (\\<pi> \\<bullet> \\<Gamma>) (\\<pi> \\<bullet> e)", "apply (rule cfun_eqvtI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<pi> \\<bullet> Aheap \\<Gamma> e\\<cdot>x =\n       Aheap (\\<pi> \\<bullet> \\<Gamma>) (\\<pi> \\<bullet> e)\\<cdot>\n       (\\<pi> \\<bullet> x)", "apply (cases nonrec \\<pi> rule: eqvt_cases[where x = \\<Gamma>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa. \\<pi> \\<bullet> nonrec xa = nonrec (\\<pi> \\<bullet> xa)\n 2. \\<And>x.\n       \\<lbrakk>nonrec \\<Gamma>; nonrec (\\<pi> \\<bullet> \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> Aheap \\<Gamma> e\\<cdot>x =\n                         Aheap (\\<pi> \\<bullet> \\<Gamma>)\n                          (\\<pi> \\<bullet> e)\\<cdot>\n                         (\\<pi> \\<bullet> x)\n 3. \\<And>x.\n       \\<lbrakk>\\<not> nonrec \\<Gamma>;\n        \\<not> nonrec (\\<pi> \\<bullet> \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> Aheap \\<Gamma> e\\<cdot>x =\n                         Aheap (\\<pi> \\<bullet> \\<Gamma>)\n                          (\\<pi> \\<bullet> e)\\<cdot>\n                         (\\<pi> \\<bullet> x)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nonrec \\<Gamma>; nonrec (\\<pi> \\<bullet> \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> Aheap \\<Gamma> e\\<cdot>x =\n                         Aheap (\\<pi> \\<bullet> \\<Gamma>)\n                          (\\<pi> \\<bullet> e)\\<cdot>\n                         (\\<pi> \\<bullet> x)\n 2. \\<And>x.\n       \\<lbrakk>\\<not> nonrec \\<Gamma>;\n        \\<not> nonrec (\\<pi> \\<bullet> \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> Aheap \\<Gamma> e\\<cdot>x =\n                         Aheap (\\<pi> \\<bullet> \\<Gamma>)\n                          (\\<pi> \\<bullet> e)\\<cdot>\n                         (\\<pi> \\<bullet> x)", "apply (erule nonrecE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa ea.\n       \\<lbrakk>nonrec (\\<pi> \\<bullet> \\<Gamma>); \\<Gamma> = [(xa, ea)];\n        xa \\<notin> fv ea\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> Aheap \\<Gamma> e\\<cdot>x =\n                         Aheap (\\<pi> \\<bullet> \\<Gamma>)\n                          (\\<pi> \\<bullet> e)\\<cdot>\n                         (\\<pi> \\<bullet> x)\n 2. \\<And>x.\n       \\<lbrakk>\\<not> nonrec \\<Gamma>;\n        \\<not> nonrec (\\<pi> \\<bullet> \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> Aheap \\<Gamma> e\\<cdot>x =\n                         Aheap (\\<pi> \\<bullet> \\<Gamma>)\n                          (\\<pi> \\<bullet> e)\\<cdot>\n                         (\\<pi> \\<bullet> x)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa ea.\n       \\<lbrakk>nonrec [(\\<pi> \\<bullet> xa, \\<pi> \\<bullet> ea)];\n        \\<Gamma> = [(xa, ea)]; xa \\<notin> fv ea\\<rbrakk>\n       \\<Longrightarrow> Aheap_nonrec (\\<pi> \\<bullet> xa)\n                          (\\<pi> \\<bullet> ea)\\<cdot>\n                         (Aexp_syn' x (\\<pi> \\<bullet> e),\n                          ccExp_syn x (\\<pi> \\<bullet> e)) =\n                         Aheap [(\\<pi> \\<bullet> xa, \\<pi> \\<bullet> ea)]\n                          (\\<pi> \\<bullet> e)\\<cdot>\n                         (\\<pi> \\<bullet> x)\n 2. \\<And>x.\n       \\<lbrakk>\\<not> nonrec \\<Gamma>;\n        \\<not> nonrec (\\<pi> \\<bullet> \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> Aheap \\<Gamma> e\\<cdot>x =\n                         Aheap (\\<pi> \\<bullet> \\<Gamma>)\n                          (\\<pi> \\<bullet> e)\\<cdot>\n                         (\\<pi> \\<bullet> x)", "apply (erule nonrecE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa ea xb eaa.\n       \\<lbrakk>\\<Gamma> = [(xa, ea)]; xa \\<notin> fv ea;\n        [(\\<pi> \\<bullet> xa, \\<pi> \\<bullet> ea)] = [(xb, eaa)];\n        xb \\<notin> fv eaa\\<rbrakk>\n       \\<Longrightarrow> Aheap_nonrec (\\<pi> \\<bullet> xa)\n                          (\\<pi> \\<bullet> ea)\\<cdot>\n                         (Aexp_syn' x (\\<pi> \\<bullet> e),\n                          ccExp_syn x (\\<pi> \\<bullet> e)) =\n                         Aheap [(\\<pi> \\<bullet> xa, \\<pi> \\<bullet> ea)]\n                          (\\<pi> \\<bullet> e)\\<cdot>\n                         (\\<pi> \\<bullet> x)\n 2. \\<And>x.\n       \\<lbrakk>\\<not> nonrec \\<Gamma>;\n        \\<not> nonrec (\\<pi> \\<bullet> \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> Aheap \\<Gamma> e\\<cdot>x =\n                         Aheap (\\<pi> \\<bullet> \\<Gamma>)\n                          (\\<pi> \\<bullet> e)\\<cdot>\n                         (\\<pi> \\<bullet> x)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa ea xb.\n       \\<lbrakk>\\<Gamma> = [(xa, ea)]; xa \\<notin> fv ea;\n        \\<pi> \\<bullet> xa = xb;\n        xb \\<notin> fv (\\<pi> \\<bullet> ea)\\<rbrakk>\n       \\<Longrightarrow> Aheap_nonrec xb (\\<pi> \\<bullet> ea)\\<cdot>\n                         (Aexp_syn' x (\\<pi> \\<bullet> e),\n                          ccExp_syn x (\\<pi> \\<bullet> e)) =\n                         Aheap_nonrec xb (\\<pi> \\<bullet> ea)\\<cdot>\n                         (Aexp_syn' (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> e),\n                          ccExp_syn (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> e))\n 2. \\<And>x.\n       \\<lbrakk>\\<not> nonrec \\<Gamma>;\n        \\<not> nonrec (\\<pi> \\<bullet> \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> Aheap \\<Gamma> e\\<cdot>x =\n                         Aheap (\\<pi> \\<bullet> \\<Gamma>)\n                          (\\<pi> \\<bullet> e)\\<cdot>\n                         (\\<pi> \\<bullet> x)", "apply (perm_simp, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> nonrec \\<Gamma>;\n        \\<not> nonrec (\\<pi> \\<bullet> \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> Aheap \\<Gamma> e\\<cdot>x =\n                         Aheap (\\<pi> \\<bullet> \\<Gamma>)\n                          (\\<pi> \\<bullet> e)\\<cdot>\n                         (\\<pi> \\<bullet> x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> nonrec \\<Gamma>;\n        \\<not> nonrec (\\<pi> \\<bullet> \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> Afix (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                         (Aexp_syn' x (\\<pi> \\<bullet> e) \\<squnion>\n                          (\\<lambda>x. up\\<cdot>0) f|`\n                          thunks (\\<pi> \\<bullet> \\<Gamma>)) f|`\n                         domA (\\<pi> \\<bullet> \\<Gamma>) =\n                         Afix (\\<pi> \\<bullet> \\<Gamma>)\\<cdot>\n                         (Aexp_syn' (\\<pi> \\<bullet> x)\n                           (\\<pi> \\<bullet> e) \\<squnion>\n                          (\\<lambda>_. up\\<cdot>0) f|`\n                          thunks (\\<pi> \\<bullet> \\<Gamma>)) f|`\n                         domA (\\<pi> \\<bullet> \\<Gamma>)", "apply (perm_simp, rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sublocale ArityAnalysisHeap Aheap"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale ArityAnalysisHeapEqvt Aheap"], ["proof (prove)\ngoal (1 subgoal):\n 1. ArityAnalysisHeapEqvt Aheap", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>. \\<pi> \\<bullet> Aheap = Aheap", "fix \\<pi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>. \\<pi> \\<bullet> Aheap = Aheap", "show \"\\<pi> \\<bullet> Aheap = Aheap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> Aheap = Aheap", "by perm_simp rule"], ["proof (state)\nthis:\n  \\<pi> \\<bullet> Aheap = Aheap\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Aexp_lam_simp: \"Aexp (Lam [x]. e) \\<cdot> n = env_delete x (Aexp e \\<cdot> (pred \\<cdot> n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Aexp_syn' n (Lam [x]. e) = env_delete x (Aexp_syn' (pred\\<cdot>n) e)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Aexp_syn' n (Lam [x]. e) = env_delete x (Aexp_syn' (pred\\<cdot>n) e)", "have \"Aexp (Lam [x]. e) \\<cdot> n = Aexp e\\<cdot>(pred\\<cdot>n) f|` (fv e - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Aexp_syn' n (Lam [x]. e) = Aexp_syn' (pred\\<cdot>n) e f|` (fv e - {x})", "by (simp add: Aexp_pre_simps)"], ["proof (state)\nthis:\n  Aexp_syn' n (Lam [x]. e) = Aexp_syn' (pred\\<cdot>n) e f|` (fv e - {x})\n\ngoal (1 subgoal):\n 1. Aexp_syn' n (Lam [x]. e) = env_delete x (Aexp_syn' (pred\\<cdot>n) e)", "also"], ["proof (state)\nthis:\n  Aexp_syn' n (Lam [x]. e) = Aexp_syn' (pred\\<cdot>n) e f|` (fv e - {x})\n\ngoal (1 subgoal):\n 1. Aexp_syn' n (Lam [x]. e) = env_delete x (Aexp_syn' (pred\\<cdot>n) e)", "have \"... = env_delete x (Aexp e\\<cdot>(pred\\<cdot>n)) f|` (fv e - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Aexp_syn' (pred\\<cdot>n) e f|` (fv e - {x}) =\n    env_delete x (Aexp_syn' (pred\\<cdot>n) e) f|` (fv e - {x})", "by simp"], ["proof (state)\nthis:\n  Aexp_syn' (pred\\<cdot>n) e f|` (fv e - {x}) =\n  env_delete x (Aexp_syn' (pred\\<cdot>n) e) f|` (fv e - {x})\n\ngoal (1 subgoal):\n 1. Aexp_syn' n (Lam [x]. e) = env_delete x (Aexp_syn' (pred\\<cdot>n) e)", "also"], ["proof (state)\nthis:\n  Aexp_syn' (pred\\<cdot>n) e f|` (fv e - {x}) =\n  env_delete x (Aexp_syn' (pred\\<cdot>n) e) f|` (fv e - {x})\n\ngoal (1 subgoal):\n 1. Aexp_syn' n (Lam [x]. e) = env_delete x (Aexp_syn' (pred\\<cdot>n) e)", "have \"\\<dots> = env_delete x (Aexp e\\<cdot>(pred\\<cdot>n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. env_delete x (Aexp_syn' (pred\\<cdot>n) e) f|` (fv e - {x}) =\n    env_delete x (Aexp_syn' (pred\\<cdot>n) e)", "by (rule env_restr_useless) (auto dest: subsetD[OF Aexp_edom])"], ["proof (state)\nthis:\n  env_delete x (Aexp_syn' (pred\\<cdot>n) e) f|` (fv e - {x}) =\n  env_delete x (Aexp_syn' (pred\\<cdot>n) e)\n\ngoal (1 subgoal):\n 1. Aexp_syn' n (Lam [x]. e) = env_delete x (Aexp_syn' (pred\\<cdot>n) e)", "finally"], ["proof (chain)\npicking this:\n  Aexp_syn' n (Lam [x]. e) = env_delete x (Aexp_syn' (pred\\<cdot>n) e)", "show ?thesis"], ["proof (prove)\nusing this:\n  Aexp_syn' n (Lam [x]. e) = env_delete x (Aexp_syn' (pred\\<cdot>n) e)\n\ngoal (1 subgoal):\n 1. Aexp_syn' n (Lam [x]. e) = env_delete x (Aexp_syn' (pred\\<cdot>n) e)", "."], ["proof (state)\nthis:\n  Aexp_syn' n (Lam [x]. e) = env_delete x (Aexp_syn' (pred\\<cdot>n) e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Aexp_Let_simp1:\n  \"\\<not> nonrec \\<Gamma> \\<Longrightarrow> \\<A>\\<^bsub>a\\<^esub> (Let \\<Gamma> e) = (Afix \\<Gamma>\\<cdot>(\\<A>\\<^bsub>a\\<^esub> e \\<squnion> (\\<lambda>_.up\\<cdot>0) f|` thunks \\<Gamma>)) f|` (- domA \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nonrec \\<Gamma> \\<Longrightarrow>\n    Aexp_syn' a (Terms.Let \\<Gamma> e) =\n    Afix \\<Gamma>\\<cdot>\n    (Aexp_syn' a e \\<squnion>\n     (\\<lambda>_. up\\<cdot>0) f|` thunks \\<Gamma>) f|`\n    (- domA \\<Gamma>)", "unfolding Aexp_pre_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nonrec \\<Gamma> \\<Longrightarrow>\n    Afix \\<Gamma>\\<cdot>\n    (Aexp_syn' a e \\<squnion>\n     (\\<lambda>_. up\\<cdot>0) f|` thunks \\<Gamma>) f|`\n    fv (Terms.Let \\<Gamma> e) =\n    Afix \\<Gamma>\\<cdot>\n    (Aexp_syn' a e \\<squnion>\n     (\\<lambda>_. up\\<cdot>0) f|` thunks \\<Gamma>) f|`\n    (- domA \\<Gamma>)", "by (rule env_restr_cong) (auto simp add: dest!: subsetD[OF Afix_edom] subsetD[OF Aexp_edom] subsetD[OF thunks_domA])"], ["", "lemma Aexp_Let_simp2:\n  \"x \\<notin> fv e \\<Longrightarrow> \\<A>\\<^bsub>a\\<^esub>(let x be e in exp) = env_delete x (\\<A>\\<^sup>\\<bottom>\\<^bsub>ABind_nonrec x e \\<cdot> (\\<A>\\<^bsub>a\\<^esub> exp, CCexp exp\\<cdot>a)\\<^esub> e \\<squnion> \\<A>\\<^bsub>a\\<^esub> exp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fv e \\<Longrightarrow>\n    Aexp_syn' a (let x be e in exp ) =\n    env_delete x\n     (Aexp_bot_syn'\n       (ABind_nonrec x e\\<cdot>(Aexp_syn' a exp, ccExp_syn a exp))\n       e \\<squnion>\n      Aexp_syn' a exp)", "unfolding Aexp_pre_simps env_delete_restr"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fv e \\<Longrightarrow>\n    (Aexp_bot_syn'\n      (ABind_nonrec x e\\<cdot>(Aexp_syn' a exp, ccExp_syn a exp))\n      e \\<squnion>\n     Aexp_syn' a exp) f|`\n    fv (let x be e in exp ) =\n    (Aexp_bot_syn'\n      (ABind_nonrec x e\\<cdot>(Aexp_syn' a exp, ccExp_syn a exp))\n      e \\<squnion>\n     Aexp_syn' a exp) f|`\n    (- {x})", "by (rule env_restr_cong) (auto dest!: subsetD[OF fup_Aexp_edom]  subsetD[OF Aexp_edom])"], ["", "lemma Aexp_simps[simp]:\n  \"\\<A>\\<^bsub>a\\<^esub>(Var x) = esing x\\<cdot>(up\\<cdot>a)\"\n  \"\\<A>\\<^bsub>a\\<^esub>(Lam [x]. e) = env_delete x (\\<A>\\<^bsub>pred\\<cdot>a\\<^esub> e)\"\n  \"\\<A>\\<^bsub>a\\<^esub>(App e x) = Aexp e\\<cdot>(inc\\<cdot>a) \\<squnion> esing x\\<cdot>(up\\<cdot>0)\"\n  \"\\<not> nonrec \\<Gamma> \\<Longrightarrow> \\<A>\\<^bsub>a\\<^esub>(Let \\<Gamma> e) =\n      (Afix \\<Gamma>\\<cdot>(\\<A>\\<^bsub>a\\<^esub> e \\<squnion> (\\<lambda>_.up\\<cdot>0) f|` thunks \\<Gamma>)) f|` (- domA \\<Gamma>)\"\n  \"x \\<notin> fv e' \\<Longrightarrow> \\<A>\\<^bsub>a\\<^esub>(let x be e' in e) =\n      env_delete x (\\<A>\\<^sup>\\<bottom>\\<^bsub>ABind_nonrec x e'\\<cdot>(\\<A>\\<^bsub>a\\<^esub> e, \\<G>\\<^bsub>a\\<^esub> e)\\<^esub> e' \\<squnion> \\<A>\\<^bsub>a\\<^esub> e)\"\n  \"\\<A>\\<^bsub>a\\<^esub>(Bool b) = \\<bottom>\"\n  \"\\<A>\\<^bsub>a\\<^esub>(scrut ? e1 : e2) = \\<A>\\<^bsub>0\\<^esub> scrut \\<squnion> \\<A>\\<^bsub>a\\<^esub> e1 \\<squnion> \\<A>\\<^bsub>a\\<^esub> e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Aexp_syn' a (Var x) = esing x\\<cdot>(up\\<cdot>a) &&&\n     Aexp_syn' a (Lam [x]. e) =\n     env_delete x (Aexp_syn' (pred\\<cdot>a) e) &&&\n     Aexp_syn' a (App e x) =\n     Aexp_syn' (inc\\<cdot>a) e \\<squnion> esing x\\<cdot>(up\\<cdot>0)) &&&\n    ((\\<not> nonrec \\<Gamma> \\<Longrightarrow>\n      Aexp_syn' a (Terms.Let \\<Gamma> e) =\n      Afix \\<Gamma>\\<cdot>\n      (Aexp_syn' a e \\<squnion>\n       (\\<lambda>_. up\\<cdot>0) f|` thunks \\<Gamma>) f|`\n      (- domA \\<Gamma>)) &&&\n     (x \\<notin> fv e' \\<Longrightarrow>\n      Aexp_syn' a (let x be e' in e ) =\n      env_delete x\n       (Aexp_bot_syn'\n         (ABind_nonrec x e'\\<cdot>(Aexp_syn' a e, ccExp_syn a e))\n         e' \\<squnion>\n        Aexp_syn' a e))) &&&\n    Aexp_syn' a (Bool b) = \\<bottom> &&&\n    Aexp_syn' a (scrut ? e1 : e2) =\n    Aexp_syn' 0 scrut \\<squnion> Aexp_syn' a e1 \\<squnion> Aexp_syn' a e2", "by (simp_all add: Aexp_lam_simp Aexp_Let_simp1 Aexp_Let_simp2, simp_all add: Aexp_pre_simps)"], ["", "end"], ["", "end"]]}