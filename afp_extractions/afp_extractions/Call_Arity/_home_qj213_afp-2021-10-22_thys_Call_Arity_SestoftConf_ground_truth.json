{"file_name": "/home/qj213/afp-2021-10-22/thys/Call_Arity/SestoftConf.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Call_Arity", "problem_names": ["lemma Alts_eqvt[eqvt]: \"\\<pi> \\<bullet> (Alts e1 e2) = Alts (\\<pi> \\<bullet> e1) (\\<pi> \\<bullet> e2)\"\n  and Arg_eqvt[eqvt]: \"\\<pi> \\<bullet> (Arg v) = Arg (\\<pi> \\<bullet> v)\"\n  and Upd_eqvt[eqvt]: \"\\<pi> \\<bullet> (Upd v) = Upd (\\<pi> \\<bullet> v)\"\n  and Dummy_eqvt[eqvt]: \"\\<pi> \\<bullet> (Dummy v) = Dummy (\\<pi> \\<bullet> v)\"", "lemma supp_Alts[simp]: \"supp (Alts e1 e2) = supp e1 \\<union> supp e2\"", "lemma supp_Arg[simp]: \"supp (Arg v) = supp v\"", "lemma supp_Upd[simp]: \"supp (Upd v) = supp v\"", "lemma supp_Dummy[simp]: \"supp (Dummy v) = supp v\"", "lemma fresh_Alts[simp]: \"a \\<sharp> Alts e1 e2 = (a \\<sharp> e1 \\<and> a \\<sharp> e2)\"", "lemma fresh_star_Alts[simp]: \"a \\<sharp>* Alts e1 e2 = (a \\<sharp>* e1 \\<and> a \\<sharp>* e2)\"", "lemma fresh_Arg[simp]: \"a \\<sharp> Arg v = a \\<sharp> v\"", "lemma fresh_Upd[simp]: \"a \\<sharp> Upd v = a \\<sharp> v\"", "lemma fresh_Dummy[simp]: \"a \\<sharp> Dummy v = a \\<sharp> v\"", "lemma fv_Alts[simp]: \"fv (Alts e1 e2) = fv e1 \\<union> fv e2\"", "lemma fv_Arg[simp]: \"fv (Arg v) = fv v\"", "lemma fv_Upd[simp]: \"fv (Upd v) = fv v\"", "lemma fv_Dummy[simp]: \"fv (Dummy v) = fv v\"", "lemma set_upds_list[simp]:\n  \"set (upds_list S) = upds S\"", "lemma ups_fv_subset: \"upds S \\<subseteq> fv S\"", "lemma fresh_distinct_ups: \"atom ` V \\<sharp>* S \\<Longrightarrow> V \\<inter> upds S = {}\"", "lemma ap_fv_subset: \"ap S \\<subseteq> fv S\"", "lemma dummies_fv_subset: \"dummies S \\<subseteq> fv S\"", "lemma fresh_flattn[simp]: \"atom (a::var) \\<sharp> flattn S \\<longleftrightarrow> atom a \\<sharp> S\"", "lemma fresh_star_flattn[simp]: \"atom ` (as:: var set) \\<sharp>* flattn S \\<longleftrightarrow> atom ` as \\<sharp>* S\"", "lemma fresh_upds_list[simp]: \"atom a \\<sharp> S \\<Longrightarrow> atom (a::var) \\<sharp> upds_list S\"", "lemma fresh_star_upds_list[simp]: \"atom ` (as:: var set) \\<sharp>* S \\<Longrightarrow> atom ` (as:: var set) \\<sharp>* upds_list S\"", "lemma upds_append[simp]: \"upds (S@S') = upds S \\<union> upds S'\"", "lemma upds_map_Dummy[simp]: \"upds (map Dummy l) = {}\"", "lemma upds_list_append[simp]: \"upds_list (S@S') = upds_list S @ upds_list S'\"", "lemma upds_list_map_Dummy[simp]: \"upds_list (map Dummy l) = []\"", "lemma dummies_append[simp]: \"dummies (S@S') = dummies S \\<union> dummies S'\"", "lemma dummies_map_Dummy[simp]: \"dummies (map Dummy l) = set l\"", "lemma map_Dummy_inj[simp]: \"map Dummy l = map Dummy l' \\<longleftrightarrow> l = l'\"", "lemma restr_stack_cong:\n  \"(\\<And> x. x \\<in> upds S \\<Longrightarrow> x \\<in> V \\<longleftrightarrow> x \\<in> V') \\<Longrightarrow> restr_stack V S = restr_stack V' S\"", "lemma upds_restr_stack[simp]: \"upds (restr_stack V S) = upds S \\<inter> V\"", "lemma fresh_star_restict_stack[intro]:\n  \"a \\<sharp>* S \\<Longrightarrow> a \\<sharp>* restr_stack V S\"", "lemma restr_stack_restr_stack[simp]:\n  \"restr_stack V (restr_stack V' S) = restr_stack (V \\<inter> V') S\"", "lemma Upd_eq_restr_stackD:\n  assumes \"Upd x # S = restr_stack V S'\"\n  shows \"x \\<in> V\"", "lemma Upd_eq_restr_stackD2:\n  assumes \"restr_stack V S' = Upd x # S\"\n  shows \"x \\<in> V\"", "lemma restr_stack_noop[simp]:\n  \"restr_stack V S = S \\<longleftrightarrow> upds S \\<subseteq> V\"", "lemmas invariant.intros[case_names step]", "lemma invariantE:\n  \"invariant rel I \\<Longrightarrow> rel x y \\<Longrightarrow> I x \\<Longrightarrow> I y\"", "lemma invariant_starE:\n  \"rtranclp rel x y \\<Longrightarrow> invariant rel I \\<Longrightarrow>  I x \\<Longrightarrow> I y\"", "lemma invariant_True:\n  \"invariant rel (\\<lambda> _. True)\"", "lemma invariant_conj:\n  \"invariant rel I1 \\<Longrightarrow> invariant rel I2 \\<Longrightarrow> invariant rel (\\<lambda> x. I1 x \\<and> I2 x)\"", "lemma rtranclp_invariant_induct[consumes 3, case_names base step]:\n  assumes \"r\\<^sup>*\\<^sup>* a b\"\n  assumes \"invariant r I\"\n  assumes \"I a\"\n  assumes \"P a\"\n  assumes \"(\\<And>y z. r\\<^sup>*\\<^sup>* a y \\<Longrightarrow> r y z \\<Longrightarrow> I y \\<Longrightarrow> I z \\<Longrightarrow> P y \\<Longrightarrow> P z)\"\n  shows \"P b\"", "lemma heap_upds_okE: \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> x \\<in> domA \\<Gamma> \\<Longrightarrow> x \\<notin> upds S\"", "lemma heap_upds_ok_Nil[simp]: \"heap_upds_ok (\\<Gamma>, [])\"", "lemma heap_upds_ok_app1: \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (\\<Gamma>,Arg x # S)\"", "lemma heap_upds_ok_app2: \"heap_upds_ok (\\<Gamma>, Arg x # S) \\<Longrightarrow> heap_upds_ok (\\<Gamma>, S)\"", "lemma heap_upds_ok_alts1: \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (\\<Gamma>,Alts e1 e2 # S)\"", "lemma heap_upds_ok_alts2: \"heap_upds_ok (\\<Gamma>, Alts e1 e2 # S) \\<Longrightarrow> heap_upds_ok (\\<Gamma>, S)\"", "lemma heap_upds_ok_append:\n  assumes \"domA \\<Delta> \\<inter> upds S = {}\"\n  assumes \"heap_upds_ok (\\<Gamma>,S)\"\n  shows \"heap_upds_ok (\\<Delta>@\\<Gamma>, S)\"", "lemma heap_upds_ok_let:\n  assumes \"atom ` domA \\<Delta> \\<sharp>* S\"\n  assumes \"heap_upds_ok (\\<Gamma>, S)\"\n  shows \"heap_upds_ok (\\<Delta> @ \\<Gamma>, S)\"", "lemma heap_upds_ok_to_stack:\n  \"x \\<in> domA \\<Gamma> \\<Longrightarrow> heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (delete x \\<Gamma>, Upd x #S)\"", "lemma heap_upds_ok_to_stack':\n  \"map_of \\<Gamma> x = Some e \\<Longrightarrow> heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (delete x \\<Gamma>, Upd x #S)\"", "lemma heap_upds_ok_delete:\n  \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (delete x \\<Gamma>, S)\"", "lemma heap_upds_ok_restrictA:\n  \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (restrictA V \\<Gamma>, S)\"", "lemma heap_upds_ok_restr_stack:\n  \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (\\<Gamma>, restr_stack V S)\"", "lemma heap_upds_ok_to_heap:\n  \"heap_upds_ok (\\<Gamma>, Upd x # S) \\<Longrightarrow> heap_upds_ok ((x,e) # \\<Gamma>, S)\"", "lemma heap_upds_ok_reorder:\n  \"x \\<in> domA \\<Gamma> \\<Longrightarrow> heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok ((x,e) # delete x \\<Gamma>, S)\"", "lemma heap_upds_ok_upd:\n\"heap_upds_ok (\\<Gamma>, Upd x # S) \\<Longrightarrow> x \\<notin> domA \\<Gamma> \\<and> x \\<notin> upds S\"", "lemmas heap_upds_ok_intros[intro] =\n  heap_upds_ok_to_heap heap_upds_ok_to_stack heap_upds_ok_to_stack' heap_upds_ok_reorder\n  heap_upds_ok_app1 heap_upds_ok_app2 heap_upds_ok_alts1 heap_upds_ok_alts2 heap_upds_ok_delete\n  heap_upds_ok_restrictA heap_upds_ok_restr_stack\n  heap_upds_ok_let", "lemmas heap_upds_ok.simps[simp del]"], "translations": [["", "lemma Alts_eqvt[eqvt]: \"\\<pi> \\<bullet> (Alts e1 e2) = Alts (\\<pi> \\<bullet> e1) (\\<pi> \\<bullet> e2)\"\n  and Arg_eqvt[eqvt]: \"\\<pi> \\<bullet> (Arg v) = Arg (\\<pi> \\<bullet> v)\"\n  and Upd_eqvt[eqvt]: \"\\<pi> \\<bullet> (Upd v) = Upd (\\<pi> \\<bullet> v)\"\n  and Dummy_eqvt[eqvt]: \"\\<pi> \\<bullet> (Dummy v) = Dummy (\\<pi> \\<bullet> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi> \\<bullet> Alts e1 e2 =\n     Alts (\\<pi> \\<bullet> e1) (\\<pi> \\<bullet> e2) &&&\n     \\<pi> \\<bullet> Arg v = Arg (\\<pi> \\<bullet> v)) &&&\n    \\<pi> \\<bullet> Upd v = Upd (\\<pi> \\<bullet> v) &&&\n    \\<pi> \\<bullet> Dummy v = Dummy (\\<pi> \\<bullet> v)", "by (auto simp add: permute_stack_elem_def split:stack_elem.split)"], ["", "lemma supp_Alts[simp]: \"supp (Alts e1 e2) = supp e1 \\<union> supp e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (Alts e1 e2) = supp e1 \\<union> supp e2", "unfolding supp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. infinite\n         {b. (a \\<rightleftharpoons> b) \\<bullet> Alts e1 e2 \\<noteq>\n             Alts e1 e2}} =\n    {a. infinite\n         {b. (a \\<rightleftharpoons> b) \\<bullet> e1 \\<noteq> e1}} \\<union>\n    {a. infinite {b. (a \\<rightleftharpoons> b) \\<bullet> e2 \\<noteq> e2}}", "by (auto simp add: Collect_imp_eq Collect_neg_eq)"], ["", "lemma supp_Arg[simp]: \"supp (Arg v) = supp v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (Arg v) = supp v", "unfolding supp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. infinite\n         {b. (a \\<rightleftharpoons> b) \\<bullet> Arg v \\<noteq> Arg v}} =\n    {a. infinite {b. (a \\<rightleftharpoons> b) \\<bullet> v \\<noteq> v}}", "by auto"], ["", "lemma supp_Upd[simp]: \"supp (Upd v) = supp v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (Upd v) = supp v", "unfolding supp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. infinite\n         {b. (a \\<rightleftharpoons> b) \\<bullet> Upd v \\<noteq> Upd v}} =\n    {a. infinite {b. (a \\<rightleftharpoons> b) \\<bullet> v \\<noteq> v}}", "by auto"], ["", "lemma supp_Dummy[simp]: \"supp (Dummy v) = supp v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (Dummy v) = supp v", "unfolding supp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. infinite\n         {b. (a \\<rightleftharpoons> b) \\<bullet> Dummy v \\<noteq>\n             Dummy v}} =\n    {a. infinite {b. (a \\<rightleftharpoons> b) \\<bullet> v \\<noteq> v}}", "by auto"], ["", "lemma fresh_Alts[simp]: \"a \\<sharp> Alts e1 e2 = (a \\<sharp> e1 \\<and> a \\<sharp> e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> Alts e1 e2 = (a \\<sharp> e1 \\<and> a \\<sharp> e2)", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> supp (Alts e1 e2)) =\n    (a \\<notin> supp e1 \\<and> a \\<notin> supp e2)", "by auto"], ["", "lemma fresh_star_Alts[simp]: \"a \\<sharp>* Alts e1 e2 = (a \\<sharp>* e1 \\<and> a \\<sharp>* e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp>* Alts e1 e2 = (a \\<sharp>* e1 \\<and> a \\<sharp>* e2)", "unfolding fresh_star_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>a. a \\<sharp> Alts e1 e2) =\n    ((\\<forall>a\\<in>a. a \\<sharp> e1) \\<and>\n     (\\<forall>a\\<in>a. a \\<sharp> e2))", "by auto"], ["", "lemma fresh_Arg[simp]: \"a \\<sharp> Arg v = a \\<sharp> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> Arg v = a \\<sharp> v", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> supp (Arg v)) = (a \\<notin> supp v)", "by auto"], ["", "lemma fresh_Upd[simp]: \"a \\<sharp> Upd v = a \\<sharp> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> Upd v = a \\<sharp> v", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> supp (Upd v)) = (a \\<notin> supp v)", "by auto"], ["", "lemma fresh_Dummy[simp]: \"a \\<sharp> Dummy v = a \\<sharp> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> Dummy v = a \\<sharp> v", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> supp (Dummy v)) = (a \\<notin> supp v)", "by auto"], ["", "lemma fv_Alts[simp]: \"fv (Alts e1 e2) = fv e1 \\<union> fv e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (Alts e1 e2) = fv e1 \\<union> fv e2", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. atom v \\<in> supp (Alts e1 e2)} =\n    {v. atom v \\<in> supp e1} \\<union> {v. atom v \\<in> supp e2}", "by auto"], ["", "lemma fv_Arg[simp]: \"fv (Arg v) = fv v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (Arg v) = fv v", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {va. atom va \\<in> supp (Arg v)} = {va. atom va \\<in> supp v}", "by auto"], ["", "lemma fv_Upd[simp]: \"fv (Upd v) = fv v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (Upd v) = fv v", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {va. atom va \\<in> supp (Upd v)} = {va. atom va \\<in> supp v}", "by auto"], ["", "lemma fv_Dummy[simp]: \"fv (Dummy v) = fv v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (Dummy v) = fv v", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {va. atom va \\<in> supp (Dummy v)} = {va. atom va \\<in> supp v}", "by auto"], ["", "instance stack_elem :: fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(stack_elem, fs_class)", "by standard (case_tac x, auto simp add: finite_supp)"], ["", "type_synonym stack = \"stack_elem list\""], ["", "fun ap :: \"stack \\<Rightarrow> var set\" where\n  \"ap [] = {}\"\n| \"ap (Alts e1 e2 # S) = ap S\"\n| \"ap (Arg x # S) = insert x (ap S)\"\n| \"ap (Upd x # S) = ap S\"\n| \"ap (Dummy x # S) = ap S\""], ["", "fun upds :: \"stack \\<Rightarrow> var set\" where\n  \"upds [] = {}\"\n| \"upds (Alts e1 e2 # S) = upds S\"\n| \"upds (Upd x # S) = insert x (upds S)\"\n| \"upds (Arg x # S) = upds S\"\n| \"upds (Dummy x # S) = upds S\""], ["", "fun dummies :: \"stack \\<Rightarrow> var set\" where\n  \"dummies [] = {}\"\n| \"dummies (Alts e1 e2 # S) = dummies S\"\n| \"dummies (Upd x # S) = dummies S\"\n| \"dummies (Arg x # S) = dummies S\"\n| \"dummies (Dummy x # S) = insert x (dummies S)\""], ["", "fun flattn :: \"stack \\<Rightarrow> var list\" where\n  \"flattn [] = []\"\n| \"flattn (Alts e1 e2 # S) = fv_list e1 @ fv_list e2 @ flattn S\"\n| \"flattn (Upd x # S) = x # flattn S\"\n| \"flattn (Arg x # S) = x # flattn S\"\n| \"flattn (Dummy x # S) = x # flattn S\""], ["", "fun upds_list :: \"stack \\<Rightarrow> var list\" where\n  \"upds_list [] = []\"\n| \"upds_list (Alts e1 e2 # S) = upds_list S\"\n| \"upds_list (Upd x # S) = x # upds_list S\"\n| \"upds_list (Arg x # S) = upds_list S\"\n| \"upds_list (Dummy x # S) = upds_list S\""], ["", "lemma set_upds_list[simp]:\n  \"set (upds_list S) = upds S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (upds_list S) = upds S", "by (induction S rule: upds_list.induct) auto"], ["", "lemma ups_fv_subset: \"upds S \\<subseteq> fv S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upds S \\<subseteq> fv S", "by (induction S rule: upds.induct) auto"], ["", "lemma fresh_distinct_ups: \"atom ` V \\<sharp>* S \\<Longrightarrow> V \\<inter> upds S = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom ` V \\<sharp>* S \\<Longrightarrow> V \\<inter> upds S = {}", "by (auto dest!: fresh_distinct_fv subsetD[OF ups_fv_subset])"], ["", "lemma ap_fv_subset: \"ap S \\<subseteq> fv S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ap S \\<subseteq> fv S", "by (induction S rule: upds.induct) auto"], ["", "lemma dummies_fv_subset: \"dummies S \\<subseteq> fv S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dummies S \\<subseteq> fv S", "by (induction S rule: dummies.induct) auto"], ["", "lemma fresh_flattn[simp]: \"atom (a::var) \\<sharp> flattn S \\<longleftrightarrow> atom a \\<sharp> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom a \\<sharp> flattn S = atom a \\<sharp> S", "by (induction S rule:flattn.induct) (auto simp add: fresh_Nil fresh_Cons fresh_append fresh_fv[OF finite_fv])"], ["", "lemma fresh_star_flattn[simp]: \"atom ` (as:: var set) \\<sharp>* flattn S \\<longleftrightarrow> atom ` as \\<sharp>* S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom ` as \\<sharp>* flattn S = atom ` as \\<sharp>* S", "by (auto simp add: fresh_star_def)"], ["", "lemma fresh_upds_list[simp]: \"atom a \\<sharp> S \\<Longrightarrow> atom (a::var) \\<sharp> upds_list S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom a \\<sharp> S \\<Longrightarrow> atom a \\<sharp> upds_list S", "by (induction S rule:upds_list.induct) (auto simp add: fresh_Nil fresh_Cons fresh_append fresh_fv[OF finite_fv])"], ["", "lemma fresh_star_upds_list[simp]: \"atom ` (as:: var set) \\<sharp>* S \\<Longrightarrow> atom ` (as:: var set) \\<sharp>* upds_list S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom ` as \\<sharp>* S \\<Longrightarrow> atom ` as \\<sharp>* upds_list S", "by (auto simp add: fresh_star_def)"], ["", "lemma upds_append[simp]: \"upds (S@S') = upds S \\<union> upds S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upds (S @ S') = upds S \\<union> upds S'", "by (induction S rule: upds.induct) auto"], ["", "lemma upds_map_Dummy[simp]: \"upds (map Dummy l) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upds (map Dummy l) = {}", "by (induction l) auto"], ["", "lemma upds_list_append[simp]: \"upds_list (S@S') = upds_list S @ upds_list S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upds_list (S @ S') = upds_list S @ upds_list S'", "by (induction S rule: upds.induct) auto"], ["", "lemma upds_list_map_Dummy[simp]: \"upds_list (map Dummy l) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upds_list (map Dummy l) = []", "by (induction l) auto"], ["", "lemma dummies_append[simp]: \"dummies (S@S') = dummies S \\<union> dummies S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dummies (S @ S') = dummies S \\<union> dummies S'", "by (induction S rule: dummies.induct) auto"], ["", "lemma dummies_map_Dummy[simp]: \"dummies (map Dummy l) = set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dummies (map Dummy l) = set l", "by (induction l) auto"], ["", "lemma map_Dummy_inj[simp]: \"map Dummy l = map Dummy l' \\<longleftrightarrow> l = l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map Dummy l = map Dummy l') = (l = l')", "apply (induction l arbitrary: l')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l'. (map Dummy [] = map Dummy l') = ([] = l')\n 2. \\<And>a l l'.\n       (\\<And>l'. (map Dummy l = map Dummy l') = (l = l')) \\<Longrightarrow>\n       (map Dummy (a # l) = map Dummy l') = (a # l = l')", "apply (case_tac [!] l')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l'.\n       l' = [] \\<Longrightarrow> (map Dummy [] = map Dummy l') = ([] = l')\n 2. \\<And>l' a list.\n       l' = a # list \\<Longrightarrow>\n       (map Dummy [] = map Dummy l') = ([] = l')\n 3. \\<And>a l l'.\n       \\<lbrakk>\\<And>l'. (map Dummy l = map Dummy l') = (l = l');\n        l' = []\\<rbrakk>\n       \\<Longrightarrow> (map Dummy (a # l) = map Dummy l') = (a # l = l')\n 4. \\<And>a l l' aa list.\n       \\<lbrakk>\\<And>l'. (map Dummy l = map Dummy l') = (l = l');\n        l' = aa # list\\<rbrakk>\n       \\<Longrightarrow> (map Dummy (a # l) = map Dummy l') = (a # l = l')", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "type_synonym conf = \"(heap \\<times> exp \\<times> stack)\""], ["", "inductive boring_step where\n  \"isVal e \\<Longrightarrow> boring_step (\\<Gamma>, e, Upd x # S)\""], ["", "fun restr_stack :: \"var set \\<Rightarrow> stack \\<Rightarrow> stack\"\n  where \"restr_stack V [] = []\"\n      | \"restr_stack V (Alts e1 e2 # S) = Alts e1 e2 # restr_stack V S\"\n      | \"restr_stack V (Arg x # S) = Arg x # restr_stack V S\"\n      | \"restr_stack V (Upd x # S) = (if x \\<in> V then Upd x # restr_stack V S else restr_stack V S)\"\n      | \"restr_stack V (Dummy x # S) = Dummy x # restr_stack V S\""], ["", "lemma restr_stack_cong:\n  \"(\\<And> x. x \\<in> upds S \\<Longrightarrow> x \\<in> V \\<longleftrightarrow> x \\<in> V') \\<Longrightarrow> restr_stack V S = restr_stack V' S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> upds S \\<Longrightarrow>\n        (x \\<in> V) = (x \\<in> V')) \\<Longrightarrow>\n    restr_stack V S = restr_stack V' S", "by (induction V S rule: restr_stack.induct) auto"], ["", "lemma upds_restr_stack[simp]: \"upds (restr_stack V S) = upds S \\<inter> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upds (restr_stack V S) = upds S \\<inter> V", "by (induction V S rule: restr_stack.induct) auto"], ["", "lemma fresh_star_restict_stack[intro]:\n  \"a \\<sharp>* S \\<Longrightarrow> a \\<sharp>* restr_stack V S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp>* S \\<Longrightarrow> a \\<sharp>* restr_stack V S", "by (induction V S rule: restr_stack.induct) (auto simp add: fresh_star_Cons)"], ["", "lemma restr_stack_restr_stack[simp]:\n  \"restr_stack V (restr_stack V' S) = restr_stack (V \\<inter> V') S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restr_stack V (restr_stack V' S) = restr_stack (V \\<inter> V') S", "by (induction V S rule: restr_stack.induct) auto"], ["", "lemma Upd_eq_restr_stackD:\n  assumes \"Upd x # S = restr_stack V S'\"\n  shows \"x \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> V", "using arg_cong[where f = upds, OF assms]"], ["proof (prove)\nusing this:\n  upds (Upd x # S) = upds (restr_stack V S')\n\ngoal (1 subgoal):\n 1. x \\<in> V", "by auto"], ["", "lemma Upd_eq_restr_stackD2:\n  assumes \"restr_stack V S' = Upd x # S\"\n  shows \"x \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> V", "using arg_cong[where f = upds, OF assms]"], ["proof (prove)\nusing this:\n  upds (restr_stack V S') = upds (Upd x # S)\n\ngoal (1 subgoal):\n 1. x \\<in> V", "by auto"], ["", "lemma restr_stack_noop[simp]:\n  \"restr_stack V S = S \\<longleftrightarrow> upds S \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (restr_stack V S = S) = (upds S \\<subseteq> V)", "by (induction V S rule: restr_stack.induct)\n     (auto dest: Upd_eq_restr_stackD2)"], ["", "subsubsection \\<open>Invariants of the semantics\\<close>"], ["", "inductive invariant :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  where \"(\\<And> x y. rel x y \\<Longrightarrow> I x \\<Longrightarrow> I y) \\<Longrightarrow> invariant rel I\""], ["", "lemmas invariant.intros[case_names step]"], ["", "lemma invariantE:\n  \"invariant rel I \\<Longrightarrow> rel x y \\<Longrightarrow> I x \\<Longrightarrow> I y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant rel I; rel x y; I x\\<rbrakk> \\<Longrightarrow> I y", "by (auto elim: invariant.cases)"], ["", "lemma invariant_starE:\n  \"rtranclp rel x y \\<Longrightarrow> invariant rel I \\<Longrightarrow>  I x \\<Longrightarrow> I y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel\\<^sup>*\\<^sup>* x y; invariant rel I; I x\\<rbrakk>\n    \\<Longrightarrow> I y", "by (induction rule: rtranclp.induct) (auto elim: invariantE)"], ["", "lemma invariant_True:\n  \"invariant rel (\\<lambda> _. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant rel (\\<lambda>_. True)", "by (auto intro: invariant.intros)"], ["", "lemma invariant_conj:\n  \"invariant rel I1 \\<Longrightarrow> invariant rel I2 \\<Longrightarrow> invariant rel (\\<lambda> x. I1 x \\<and> I2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant rel I1; invariant rel I2\\<rbrakk>\n    \\<Longrightarrow> invariant rel (\\<lambda>x. I1 x \\<and> I2 x)", "by (auto simp add: invariant.simps)"], ["", "lemma rtranclp_invariant_induct[consumes 3, case_names base step]:\n  assumes \"r\\<^sup>*\\<^sup>* a b\"\n  assumes \"invariant r I\"\n  assumes \"I a\"\n  assumes \"P a\"\n  assumes \"(\\<And>y z. r\\<^sup>*\\<^sup>* a y \\<Longrightarrow> r y z \\<Longrightarrow> I y \\<Longrightarrow> I z \\<Longrightarrow> P y \\<Longrightarrow> P z)\"\n  shows \"P b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P b", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P b", "from assms(1,3)"], ["proof (chain)\npicking this:\n  r\\<^sup>*\\<^sup>* a b\n  I a", "have \"P b\" and \"I b\""], ["proof (prove)\nusing this:\n  r\\<^sup>*\\<^sup>* a b\n  I a\n\ngoal (1 subgoal):\n 1. P b &&& I b", "proof(induction)"], ["proof (state)\ngoal (4 subgoals):\n 1. I a \\<Longrightarrow> P a\n 2. I a \\<Longrightarrow> I a\n 3. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> P z\n 4. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> I z", "case base"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. I a \\<Longrightarrow> P a\n 2. I a \\<Longrightarrow> I a\n 3. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> P z\n 4. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> I z", "from \\<open>P a\\<close>"], ["proof (chain)\npicking this:\n  P a", "show \"P a\""], ["proof (prove)\nusing this:\n  P a\n\ngoal (1 subgoal):\n 1. P a", "."], ["proof (state)\nthis:\n  P a\n\ngoal (3 subgoals):\n 1. I a \\<Longrightarrow> I a\n 2. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> P z\n 3. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> I z", "from \\<open>I a\\<close>"], ["proof (chain)\npicking this:\n  I a", "show \"I a\""], ["proof (prove)\nusing this:\n  I a\n\ngoal (1 subgoal):\n 1. I a", "."], ["proof (state)\nthis:\n  I a\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> P z\n 2. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> I z", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> P z\n 2. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> I z", "case (step y z)"], ["proof (state)\nthis:\n  r\\<^sup>*\\<^sup>* a y\n  r y z\n  I a \\<Longrightarrow> P y\n  I a \\<Longrightarrow> I y\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> P z\n 2. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> I z", "with \\<open>I a\\<close>"], ["proof (chain)\npicking this:\n  I a\n  r\\<^sup>*\\<^sup>* a y\n  r y z\n  I a \\<Longrightarrow> P y\n  I a \\<Longrightarrow> I y", "have \"P y\" and \"I y\""], ["proof (prove)\nusing this:\n  I a\n  r\\<^sup>*\\<^sup>* a y\n  r y z\n  I a \\<Longrightarrow> P y\n  I a \\<Longrightarrow> I y\n\ngoal (1 subgoal):\n 1. P y &&& I y", "by auto"], ["proof (state)\nthis:\n  P y\n  I y\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> P z\n 2. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> I z", "from assms(2) \\<open>r y z\\<close> \\<open>I y\\<close>"], ["proof (chain)\npicking this:\n  invariant r I\n  r y z\n  I y", "show \"I z\""], ["proof (prove)\nusing this:\n  invariant r I\n  r y z\n  I y\n\ngoal (1 subgoal):\n 1. I z", "by (rule invariantE)"], ["proof (state)\nthis:\n  I z\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>r\\<^sup>*\\<^sup>* a y; r y z; I a \\<Longrightarrow> P y;\n        I a \\<Longrightarrow> I y; I a\\<rbrakk>\n       \\<Longrightarrow> P z", "from \\<open>r\\<^sup>*\\<^sup>* a y\\<close> \\<open>r y z\\<close> \\<open>I y\\<close> \\<open>I z\\<close> \\<open>P y\\<close>"], ["proof (chain)\npicking this:\n  r\\<^sup>*\\<^sup>* a y\n  r y z\n  I y\n  I z\n  P y", "show \"P z\""], ["proof (prove)\nusing this:\n  r\\<^sup>*\\<^sup>* a y\n  r y z\n  I y\n  I z\n  P y\n\ngoal (1 subgoal):\n 1. P z", "by (rule assms(5))"], ["proof (state)\nthis:\n  P z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P b\n  I b\n\ngoal (1 subgoal):\n 1. P b", "thus \"P b\""], ["proof (prove)\nusing this:\n  P b\n  I b\n\ngoal (1 subgoal):\n 1. P b", "by-"], ["proof (state)\nthis:\n  P b\n\ngoal:\nNo subgoals!", "qed"], ["", "fun closed :: \"conf \\<Rightarrow> bool\"\n  where \"closed (\\<Gamma>, e, S) \\<longleftrightarrow> fv (\\<Gamma>, e, S) \\<subseteq> domA \\<Gamma> \\<union> upds S\""], ["", "fun heap_upds_ok where \"heap_upds_ok (\\<Gamma>,S) \\<longleftrightarrow> domA \\<Gamma> \\<inter> upds S = {} \\<and> distinct (upds_list S)\""], ["", "abbreviation heap_upds_ok_conf :: \"conf \\<Rightarrow> bool\"\n  where \"heap_upds_ok_conf c \\<equiv> heap_upds_ok (fst c, snd (snd c))\""], ["", "lemma heap_upds_okE: \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> x \\<in> domA \\<Gamma> \\<Longrightarrow> x \\<notin> upds S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_upds_ok (\\<Gamma>, S); x \\<in> domA \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> upds S", "by auto"], ["", "lemma heap_upds_ok_Nil[simp]: \"heap_upds_ok (\\<Gamma>, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>, [])", "by auto"], ["", "lemma heap_upds_ok_app1: \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (\\<Gamma>,Arg x # S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow>\n    heap_upds_ok (\\<Gamma>, Arg x # S)", "by auto"], ["", "lemma heap_upds_ok_app2: \"heap_upds_ok (\\<Gamma>, Arg x # S) \\<Longrightarrow> heap_upds_ok (\\<Gamma>, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>, Arg x # S) \\<Longrightarrow>\n    heap_upds_ok (\\<Gamma>, S)", "by auto"], ["", "lemma heap_upds_ok_alts1: \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (\\<Gamma>,Alts e1 e2 # S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow>\n    heap_upds_ok (\\<Gamma>, Alts e1 e2 # S)", "by auto"], ["", "lemma heap_upds_ok_alts2: \"heap_upds_ok (\\<Gamma>, Alts e1 e2 # S) \\<Longrightarrow> heap_upds_ok (\\<Gamma>, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>, Alts e1 e2 # S) \\<Longrightarrow>\n    heap_upds_ok (\\<Gamma>, S)", "by auto"], ["", "lemma heap_upds_ok_append:\n  assumes \"domA \\<Delta> \\<inter> upds S = {}\"\n  assumes \"heap_upds_ok (\\<Gamma>,S)\"\n  shows \"heap_upds_ok (\\<Delta>@\\<Gamma>, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Delta> @ \\<Gamma>, S)", "using assms"], ["proof (prove)\nusing this:\n  domA \\<Delta> \\<inter> upds S = {}\n  heap_upds_ok (\\<Gamma>, S)\n\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Delta> @ \\<Gamma>, S)", "unfolding heap_upds_ok.simps"], ["proof (prove)\nusing this:\n  domA \\<Delta> \\<inter> upds S = {}\n  domA \\<Gamma> \\<inter> upds S = {} \\<and> distinct (upds_list S)\n\ngoal (1 subgoal):\n 1. domA (\\<Delta> @ \\<Gamma>) \\<inter> upds S = {} \\<and>\n    distinct (upds_list S)", "by auto"], ["", "lemma heap_upds_ok_let:\n  assumes \"atom ` domA \\<Delta> \\<sharp>* S\"\n  assumes \"heap_upds_ok (\\<Gamma>, S)\"\n  shows \"heap_upds_ok (\\<Delta> @ \\<Gamma>, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Delta> @ \\<Gamma>, S)", "using assms(2) fresh_distinct_fv[OF assms(1)]"], ["proof (prove)\nusing this:\n  heap_upds_ok (\\<Gamma>, S)\n  domA \\<Delta> \\<inter> fv S = {}\n\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Delta> @ \\<Gamma>, S)", "by (auto intro: heap_upds_ok_append dest: subsetD[OF ups_fv_subset])"], ["", "lemma heap_upds_ok_to_stack:\n  \"x \\<in> domA \\<Gamma> \\<Longrightarrow> heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (delete x \\<Gamma>, Upd x #S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> domA \\<Gamma>; heap_upds_ok (\\<Gamma>, S)\\<rbrakk>\n    \\<Longrightarrow> heap_upds_ok (delete x \\<Gamma>, Upd x # S)", "by (auto)"], ["", "lemma heap_upds_ok_to_stack':\n  \"map_of \\<Gamma> x = Some e \\<Longrightarrow> heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (delete x \\<Gamma>, Upd x #S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>map_of \\<Gamma> x = Some e; heap_upds_ok (\\<Gamma>, S)\\<rbrakk>\n    \\<Longrightarrow> heap_upds_ok (delete x \\<Gamma>, Upd x # S)", "by (metis Domain.DomainI domA_def fst_eq_Domain heap_upds_ok_to_stack map_of_SomeD)"], ["", "lemma heap_upds_ok_delete:\n  \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (delete x \\<Gamma>, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow>\n    heap_upds_ok (delete x \\<Gamma>, S)", "by auto"], ["", "lemma heap_upds_ok_restrictA:\n  \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (restrictA V \\<Gamma>, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow>\n    heap_upds_ok (restrictA V \\<Gamma>, S)", "by auto"], ["", "lemma heap_upds_ok_restr_stack:\n  \"heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok (\\<Gamma>, restr_stack V S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow>\n    heap_upds_ok (\\<Gamma>, restr_stack V S)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>domA \\<Gamma> \\<inter> upds S = {};\n     distinct (upds_list S)\\<rbrakk>\n    \\<Longrightarrow> distinct (upds_list (restr_stack V S))", "by (induction V S rule: restr_stack.induct) auto"], ["", "lemma heap_upds_ok_to_heap:\n  \"heap_upds_ok (\\<Gamma>, Upd x # S) \\<Longrightarrow> heap_upds_ok ((x,e) # \\<Gamma>, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>, Upd x # S) \\<Longrightarrow>\n    heap_upds_ok ((x, e) # \\<Gamma>, S)", "by auto"], ["", "lemma heap_upds_ok_reorder:\n  \"x \\<in> domA \\<Gamma> \\<Longrightarrow> heap_upds_ok (\\<Gamma>, S) \\<Longrightarrow> heap_upds_ok ((x,e) # delete x \\<Gamma>, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> domA \\<Gamma>; heap_upds_ok (\\<Gamma>, S)\\<rbrakk>\n    \\<Longrightarrow> heap_upds_ok ((x, e) # delete x \\<Gamma>, S)", "by (intro heap_upds_ok_to_heap heap_upds_ok_to_stack)"], ["", "lemma heap_upds_ok_upd:\n\"heap_upds_ok (\\<Gamma>, Upd x # S) \\<Longrightarrow> x \\<notin> domA \\<Gamma> \\<and> x \\<notin> upds S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_upds_ok (\\<Gamma>, Upd x # S) \\<Longrightarrow>\n    x \\<notin> domA \\<Gamma> \\<and> x \\<notin> upds S", "by auto"], ["", "lemmas heap_upds_ok_intros[intro] =\n  heap_upds_ok_to_heap heap_upds_ok_to_stack heap_upds_ok_to_stack' heap_upds_ok_reorder\n  heap_upds_ok_app1 heap_upds_ok_app2 heap_upds_ok_alts1 heap_upds_ok_alts2 heap_upds_ok_delete\n  heap_upds_ok_restrictA heap_upds_ok_restr_stack\n  heap_upds_ok_let"], ["", "lemmas heap_upds_ok.simps[simp del]"], ["", "end"]]}