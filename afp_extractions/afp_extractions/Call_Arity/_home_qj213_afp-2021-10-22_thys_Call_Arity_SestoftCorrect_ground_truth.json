{"file_name": "/home/qj213/afp-2021-10-22/thys/Call_Arity/SestoftCorrect.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Call_Arity", "problem_names": ["lemma lemma_2:\n  assumes \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\"\n  and     \"fv (\\<Gamma>, e, S) \\<subseteq> set L \\<union> domA \\<Gamma>\"\n  shows \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S)\"", "lemma conf_trace_induct_final[consumes 1, case_names trace_nil trace_cons]:\n  \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> final \\<Longrightarrow> (\\<And> \\<Gamma> e S. final = (\\<Gamma>, e, S) \\<Longrightarrow> P \\<Gamma> e S [] (\\<Gamma>, e, S)) \\<Longrightarrow> (\\<And>\\<Gamma> e S T \\<Gamma>' e' S'. (\\<Gamma>', e', S') \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> final \\<Longrightarrow> P \\<Gamma>' e' S' T final \\<Longrightarrow> (\\<Gamma>, e, S) \\<Rightarrow> (\\<Gamma>', e', S') \\<Longrightarrow> P \\<Gamma> e S ((\\<Gamma>', e', S') # T) final) \\<Longrightarrow> P \\<Gamma> e S T final\"", "lemma isVal_stops:\n  assumes \"isVal e\"\n  assumes \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\"\n  shows \"T=[]\"", "lemma Ball_subst[simp]:\n  \"(\\<forall>p\\<in>set (\\<Gamma>[y::h=x]). f p) \\<longleftrightarrow> (\\<forall>p\\<in>set \\<Gamma>. case p of (z,e) \\<Rightarrow> f (z, e[y::=x]))\"", "lemma lemma_3:\n  assumes \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\"\n  assumes \"isVal z\"\n  shows \"\\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\"", "lemma dummy_stack_extended:\n  \"set S \\<subseteq>  Dummy ` UNIV \\<Longrightarrow> x \\<notin> Dummy ` UNIV \\<Longrightarrow> (S \\<lesssim> x # S') \\<longleftrightarrow>  S \\<lesssim> S'\"", "lemma[simp]: \"Arg x \\<notin> range Dummy\"  \"Upd x \\<notin> range Dummy\"   \"Alts e\\<^sub>1 e\\<^sub>2 \\<notin> range Dummy\"", "lemma dummy_stack_balanced:\n  assumes \"set S \\<subseteq> Dummy ` UNIV\"\n  assumes \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S)\"\n  obtains T where \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\""], "translations": [["", "lemma lemma_2:\n  assumes \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\"\n  and     \"fv (\\<Gamma>, e, S) \\<subseteq> set L \\<union> domA \\<Gamma>\"\n  shows \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S)", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\n  fv (\\<Gamma>, e, S) \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S)", "proof(induction arbitrary: S  rule:reds.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> x e L S.\n       fv (\\<Gamma>, Lam [x]. e, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Lam [x]. e, S) \\<Rightarrow>\\<^sup>*\n       (\\<Gamma>, Lam [x]. e, S)\n 2. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 3. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 4. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 5. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 6. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "case (Lambda \\<Gamma> x e L)"], ["proof (state)\nthis:\n  fv (\\<Gamma>, Lam [x]. e, S) \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> x e L S.\n       fv (\\<Gamma>, Lam [x]. e, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Lam [x]. e, S) \\<Rightarrow>\\<^sup>*\n       (\\<Gamma>, Lam [x]. e, S)\n 2. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 3. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 4. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 5. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 6. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, Lam [x]. e, S) \\<Rightarrow>\\<^sup>*\n    (\\<Gamma>, Lam [x]. e, S)", ".."], ["proof (state)\nthis:\n  (\\<Gamma>, Lam [x]. e, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Lam [x]. e, S)\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 4. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 4. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "case (Application y \\<Gamma> e x L \\<Delta> \\<Theta> z e')"], ["proof (state)\nthis:\n  atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z)\n  \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e'\n  \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n  fv (\\<Gamma>, e, ?S)\n  \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n  (\\<Gamma>, e, ?S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Lam [y]. e', ?S)\n  fv (\\<Delta>, e'[y::=x], ?S)\n  \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n  (\\<Delta>, e'[y::=x], ?S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, ?S)\n  fv (\\<Gamma>, App e x, S) \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 4. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "from \\<open>fv (\\<Gamma>, App e x, S) \\<subseteq> set L \\<union> domA \\<Gamma>\\<close>"], ["proof (chain)\npicking this:\n  fv (\\<Gamma>, App e x, S) \\<subseteq> set L \\<union> domA \\<Gamma>", "have prem1: \"fv (\\<Gamma>, e, Arg x # S) \\<subseteq> set L \\<union> domA \\<Gamma>\""], ["proof (prove)\nusing this:\n  fv (\\<Gamma>, App e x, S) \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (1 subgoal):\n 1. fv (\\<Gamma>, e, Arg x # S) \\<subseteq> set L \\<union> domA \\<Gamma>", "by simp"], ["proof (state)\nthis:\n  fv (\\<Gamma>, e, Arg x # S) \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 4. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "from prem1 reds_pres_closed[OF \\<open>\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e'\\<close>] reds_doesnt_forget[OF \\<open>\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e'\\<close>]"], ["proof (chain)\npicking this:\n  fv (\\<Gamma>, e, Arg x # S) \\<subseteq> set L \\<union> domA \\<Gamma>\n  fv (\\<Gamma>, e)\n  \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n  fv (\\<Delta>, Lam [y]. e') \\<subseteq> set L \\<union> domA \\<Delta>\n  domA \\<Gamma> \\<subseteq> domA \\<Delta>", "have prem2: \"fv (\\<Delta>, e'[y::=x], S) \\<subseteq> set L \\<union> domA \\<Delta>\""], ["proof (prove)\nusing this:\n  fv (\\<Gamma>, e, Arg x # S) \\<subseteq> set L \\<union> domA \\<Gamma>\n  fv (\\<Gamma>, e)\n  \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n  fv (\\<Delta>, Lam [y]. e') \\<subseteq> set L \\<union> domA \\<Delta>\n  domA \\<Gamma> \\<subseteq> domA \\<Delta>\n\ngoal (1 subgoal):\n 1. fv (\\<Delta>, e'[y::=x], S) \\<subseteq> set L \\<union> domA \\<Delta>", "by (auto simp add: fv_subst_eq)"], ["proof (state)\nthis:\n  fv (\\<Delta>, e'[y::=x], S) \\<subseteq> set L \\<union> domA \\<Delta>\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 4. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "have \"(\\<Gamma>, App e x, S) \\<Rightarrow> (\\<Gamma>, e, Arg x # S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, App e x, S) \\<Rightarrow> (\\<Gamma>, e, Arg x # S)", ".."], ["proof (state)\nthis:\n  (\\<Gamma>, App e x, S) \\<Rightarrow> (\\<Gamma>, e, Arg x # S)\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 4. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "also"], ["proof (state)\nthis:\n  (\\<Gamma>, App e x, S) \\<Rightarrow> (\\<Gamma>, e, Arg x # S)\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 4. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "have \"\\<dots> \\<Rightarrow>\\<^sup>* (\\<Delta>, Lam [y]. e', Arg x# S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, e, Arg x # S) \\<Rightarrow>\\<^sup>*\n    (\\<Delta>, Lam [y]. e', Arg x # S)", "by (rule Application.IH(1)[OF prem1])"], ["proof (state)\nthis:\n  (\\<Gamma>, e, Arg x # S) \\<Rightarrow>\\<^sup>*\n  (\\<Delta>, Lam [y]. e', Arg x # S)\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 4. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "also"], ["proof (state)\nthis:\n  (\\<Gamma>, e, Arg x # S) \\<Rightarrow>\\<^sup>*\n  (\\<Delta>, Lam [y]. e', Arg x # S)\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 4. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "have \"\\<dots> \\<Rightarrow> (\\<Delta>, e'[y ::= x], S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Delta>, Lam [y]. e', Arg x # S) \\<Rightarrow>\n    (\\<Delta>, e'[y::=x], S)", ".."], ["proof (state)\nthis:\n  (\\<Delta>, Lam [y]. e', Arg x # S) \\<Rightarrow> (\\<Delta>, e'[y::=x], S)\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 4. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "also"], ["proof (state)\nthis:\n  (\\<Delta>, Lam [y]. e', Arg x # S) \\<Rightarrow> (\\<Delta>, e'[y::=x], S)\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 4. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "have \"\\<dots> \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S)", "by (rule Application.IH(2)[OF prem2])"], ["proof (state)\nthis:\n  (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S)\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' S.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>S.\n           fv (\\<Gamma>, e, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\n           (\\<Delta>, Lam [y]. e', S);\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, e'[y::=x], S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, e'[y::=x], S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S);\n        fv (\\<Gamma>, App e x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 4. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "finally"], ["proof (chain)\npicking this:\n  (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S)\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S)", "."], ["proof (state)\nthis:\n  (\\<Gamma>, App e x, S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 3. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 3. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "case (Variable \\<Gamma> x e L \\<Delta> z S)"], ["proof (state)\nthis:\n  map_of \\<Gamma> x = Some e\n  delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z\n  fv (delete x \\<Gamma>, e, ?S)\n  \\<subseteq> set (x # L) \\<union>\n              domA (delete x \\<Gamma>) \\<Longrightarrow>\n  (delete x \\<Gamma>, e, ?S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, ?S)\n  fv (\\<Gamma>, Var x, S) \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 3. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "from Variable(2)"], ["proof (chain)\npicking this:\n  delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z", "have \"isVal z\""], ["proof (prove)\nusing this:\n  delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z\n\ngoal (1 subgoal):\n 1. isVal z", "by (rule result_evaluated)"], ["proof (state)\nthis:\n  isVal z\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 3. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "have \"x \\<notin> domA \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> domA \\<Delta>", "by (rule reds_avoids_live[OF Variable(2), where x = x]) simp_all"], ["proof (state)\nthis:\n  x \\<notin> domA \\<Delta>\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 3. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "from \\<open>fv (\\<Gamma>, Var x, S) \\<subseteq> set L \\<union> domA \\<Gamma>\\<close>"], ["proof (chain)\npicking this:\n  fv (\\<Gamma>, Var x, S) \\<subseteq> set L \\<union> domA \\<Gamma>", "have prem: \"fv (delete x \\<Gamma>, e, Upd x # S) \\<subseteq> set (x#L) \\<union> domA (delete x \\<Gamma>)\""], ["proof (prove)\nusing this:\n  fv (\\<Gamma>, Var x, S) \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (1 subgoal):\n 1. fv (delete x \\<Gamma>, e, Upd x # S)\n    \\<subseteq> set (x # L) \\<union> domA (delete x \\<Gamma>)", "by (auto dest: subsetD[OF fv_delete_subset] subsetD[OF map_of_Some_fv_subset[OF \\<open>map_of \\<Gamma> x = Some e\\<close>]])"], ["proof (state)\nthis:\n  fv (delete x \\<Gamma>, e, Upd x # S)\n  \\<subseteq> set (x # L) \\<union> domA (delete x \\<Gamma>)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 3. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "from \\<open>map_of \\<Gamma> x = Some e\\<close>"], ["proof (chain)\npicking this:\n  map_of \\<Gamma> x = Some e", "have \"(\\<Gamma>, Var x, S) \\<Rightarrow> (delete x \\<Gamma>, e, Upd x # S)\""], ["proof (prove)\nusing this:\n  map_of \\<Gamma> x = Some e\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, Var x, S) \\<Rightarrow> (delete x \\<Gamma>, e, Upd x # S)", ".."], ["proof (state)\nthis:\n  (\\<Gamma>, Var x, S) \\<Rightarrow> (delete x \\<Gamma>, e, Upd x # S)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 3. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "also"], ["proof (state)\nthis:\n  (\\<Gamma>, Var x, S) \\<Rightarrow> (delete x \\<Gamma>, e, Upd x # S)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 3. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "have \"\\<dots> \\<Rightarrow>\\<^sup>* (\\<Delta>, z, Upd x # S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (delete x \\<Gamma>, e, Upd x # S) \\<Rightarrow>\\<^sup>*\n    (\\<Delta>, z, Upd x # S)", "by (rule Variable.IH[OF prem])"], ["proof (state)\nthis:\n  (delete x \\<Gamma>, e, Upd x # S) \\<Rightarrow>\\<^sup>*\n  (\\<Delta>, z, Upd x # S)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 3. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "also"], ["proof (state)\nthis:\n  (delete x \\<Gamma>, e, Upd x # S) \\<Rightarrow>\\<^sup>*\n  (\\<Delta>, z, Upd x # S)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 3. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "have \"\\<dots> \\<Rightarrow> ((x,z)#\\<Delta>, z, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Delta>, z, Upd x # S) \\<Rightarrow> ((x, z) # \\<Delta>, z, S)", "using \\<open>x \\<notin> domA \\<Delta>\\<close> \\<open>isVal z\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> domA \\<Delta>\n  isVal z\n\ngoal (1 subgoal):\n 1. (\\<Delta>, z, Upd x # S) \\<Rightarrow> ((x, z) # \\<Delta>, z, S)", "by (rule var\\<^sub>2)"], ["proof (state)\nthis:\n  (\\<Delta>, z, Upd x # S) \\<Rightarrow> ((x, z) # \\<Delta>, z, S)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z S.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>S.\n           fv (delete x \\<Gamma>, e, S)\n           \\<subseteq> set (x # L) \\<union>\n                       domA (delete x \\<Gamma>) \\<Longrightarrow>\n           (delete x \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S);\n        fv (\\<Gamma>, Var x, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                         ((x, z) # \\<Delta>, z, S)\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 3. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "finally"], ["proof (chain)\npicking this:\n  (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>* ((x, z) # \\<Delta>, z, S)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>* ((x, z) # \\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>* ((x, z) # \\<Delta>, z, S)", "."], ["proof (state)\nthis:\n  (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>* ((x, z) # \\<Delta>, z, S)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 3. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 3. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "case (Bool \\<Gamma> b L S)"], ["proof (state)\nthis:\n  fv (\\<Gamma>, Bool b, S) \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> b L S.\n       fv (\\<Gamma>, Bool b, S)\n       \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n       (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n 3. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)", ".."], ["proof (state)\nthis:\n  (\\<Gamma>, Bool b, S) \\<Rightarrow>\\<^sup>* (\\<Gamma>, Bool b, S)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "case (IfThenElse \\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S)"], ["proof (state)\nthis:\n  \\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b\n  \\<Delta> : (if b then e\\<^sub>1\n              else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n  fv (\\<Gamma>, scrut, ?S)\n  \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n  (\\<Gamma>, scrut, ?S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, ?S)\n  fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, ?S)\n  \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n  (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, ?S) \\<Rightarrow>\\<^sup>*\n  (\\<Theta>, z, ?S)\n  fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n  \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "have \"(\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S) \\<Rightarrow> (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 #S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S) \\<Rightarrow>\n    (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 # S)", ".."], ["proof (state)\nthis:\n  (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S) \\<Rightarrow>\n  (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 # S)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "also"], ["proof (state)\nthis:\n  (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S) \\<Rightarrow>\n  (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 # S)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "from IfThenElse.prems"], ["proof (chain)\npicking this:\n  fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n  \\<subseteq> set L \\<union> domA \\<Gamma>", "have prem1: \"fv (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 #S) \\<subseteq> set L \\<union> domA \\<Gamma>\""], ["proof (prove)\nusing this:\n  fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n  \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (1 subgoal):\n 1. fv (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 # S)\n    \\<subseteq> set L \\<union> domA \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  fv (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 # S)\n  \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "hence \"(\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 #S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, Alts e\\<^sub>1 e\\<^sub>2 #S)\""], ["proof (prove)\nusing this:\n  fv (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 # S)\n  \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 # S) \\<Rightarrow>\\<^sup>*\n    (\\<Delta>, Bool b, Alts e\\<^sub>1 e\\<^sub>2 # S)", "by (rule IfThenElse.IH)"], ["proof (state)\nthis:\n  (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 # S) \\<Rightarrow>\\<^sup>*\n  (\\<Delta>, Bool b, Alts e\\<^sub>1 e\\<^sub>2 # S)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "also"], ["proof (state)\nthis:\n  (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 # S) \\<Rightarrow>\\<^sup>*\n  (\\<Delta>, Bool b, Alts e\\<^sub>1 e\\<^sub>2 # S)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "have \"(\\<Delta>, Bool b, Alts e\\<^sub>1 e\\<^sub>2 #S) \\<Rightarrow> (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Delta>, Bool b, Alts e\\<^sub>1 e\\<^sub>2 # S) \\<Rightarrow>\n    (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)", ".."], ["proof (state)\nthis:\n  (\\<Delta>, Bool b, Alts e\\<^sub>1 e\\<^sub>2 # S) \\<Rightarrow>\n  (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "also"], ["proof (state)\nthis:\n  (\\<Delta>, Bool b, Alts e\\<^sub>1 e\\<^sub>2 # S) \\<Rightarrow>\n  (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "from prem1 reds_pres_closed[OF IfThenElse(1)] reds_doesnt_forget[OF IfThenElse(1)]"], ["proof (chain)\npicking this:\n  fv (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 # S)\n  \\<subseteq> set L \\<union> domA \\<Gamma>\n  fv (\\<Gamma>, scrut)\n  \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n  fv (\\<Delta>, Bool b) \\<subseteq> set L \\<union> domA \\<Delta>\n  domA \\<Gamma> \\<subseteq> domA \\<Delta>", "have prem2: \"fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S) \\<subseteq> set L \\<union> domA \\<Delta>\""], ["proof (prove)\nusing this:\n  fv (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 # S)\n  \\<subseteq> set L \\<union> domA \\<Gamma>\n  fv (\\<Gamma>, scrut)\n  \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n  fv (\\<Delta>, Bool b) \\<subseteq> set L \\<union> domA \\<Delta>\n  domA \\<Gamma> \\<subseteq> domA \\<Delta>\n\ngoal (1 subgoal):\n 1. fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n    \\<subseteq> set L \\<union> domA \\<Delta>", "by auto"], ["proof (state)\nthis:\n  fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n  \\<subseteq> set L \\<union> domA \\<Delta>\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "hence \"(\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S) \\<Rightarrow>\\<^sup>* (\\<Theta>, z, S)\""], ["proof (prove)\nusing this:\n  fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n  \\<subseteq> set L \\<union> domA \\<Delta>\n\ngoal (1 subgoal):\n 1. (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S) \\<Rightarrow>\\<^sup>*\n    (\\<Theta>, z, S)", "by (rule IfThenElse.IH(2))"], ["proof (state)\nthis:\n  (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S) \\<Rightarrow>\\<^sup>*\n  (\\<Theta>, z, S)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z S.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>S.\n           fv (\\<Gamma>, scrut, S)\n           \\<subseteq> set L \\<union> domA \\<Gamma> \\<Longrightarrow>\n           (\\<Gamma>, scrut, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, Bool b, S);\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2, S)\n           \\<subseteq> set L \\<union> domA \\<Delta> \\<Longrightarrow>\n           (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2,\n            S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "finally"], ["proof (chain)\npicking this:\n  (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S) \\<Rightarrow>\\<^sup>*\n  (\\<Theta>, z, S)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S) \\<Rightarrow>\\<^sup>*\n  (\\<Theta>, z, S)\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S) \\<Rightarrow>\\<^sup>*\n    (\\<Theta>, z, S)", "."], ["proof (state)\nthis:\n  (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2, S) \\<Rightarrow>\\<^sup>*\n  (\\<Theta>, z, S)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "case (Let as \\<Gamma> L body \\<Delta> z S)"], ["proof (state)\nthis:\n  atom ` domA as \\<sharp>* (\\<Gamma>, L)\n  as @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\n  fv (as @ \\<Gamma>, body, ?S)\n  \\<subseteq> set L \\<union> domA (as @ \\<Gamma>) \\<Longrightarrow>\n  (as @ \\<Gamma>, body, ?S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, ?S)\n  fv (\\<Gamma>, Terms.Let as body, S)\n  \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "from Let(4)"], ["proof (chain)\npicking this:\n  fv (\\<Gamma>, Terms.Let as body, S)\n  \\<subseteq> set L \\<union> domA \\<Gamma>", "have prem: \"fv (as @ \\<Gamma>, body, S) \\<subseteq> set L \\<union> domA (as @ \\<Gamma>)\""], ["proof (prove)\nusing this:\n  fv (\\<Gamma>, Terms.Let as body, S)\n  \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (1 subgoal):\n 1. fv (as @ \\<Gamma>, body, S)\n    \\<subseteq> set L \\<union> domA (as @ \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  fv (as @ \\<Gamma>, body, S)\n  \\<subseteq> set L \\<union> domA (as @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "from Let(1)"], ["proof (chain)\npicking this:\n  atom ` domA as \\<sharp>* (\\<Gamma>, L)", "have \"atom ` domA as \\<sharp>* \\<Gamma>\""], ["proof (prove)\nusing this:\n  atom ` domA as \\<sharp>* (\\<Gamma>, L)\n\ngoal (1 subgoal):\n 1. atom ` domA as \\<sharp>* \\<Gamma>", "by (auto simp add: fresh_star_Pair)"], ["proof (state)\nthis:\n  atom ` domA as \\<sharp>* \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "moreover"], ["proof (state)\nthis:\n  atom ` domA as \\<sharp>* \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "from Let(1)"], ["proof (chain)\npicking this:\n  atom ` domA as \\<sharp>* (\\<Gamma>, L)", "have \"domA as \\<inter> fv (\\<Gamma>, L) = {}\""], ["proof (prove)\nusing this:\n  atom ` domA as \\<sharp>* (\\<Gamma>, L)\n\ngoal (1 subgoal):\n 1. domA as \\<inter> fv (\\<Gamma>, L) = {}", "by (rule fresh_distinct_fv)"], ["proof (state)\nthis:\n  domA as \\<inter> fv (\\<Gamma>, L) = {}\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "hence \"domA as \\<inter> (set L \\<union> domA \\<Gamma>) = {}\""], ["proof (prove)\nusing this:\n  domA as \\<inter> fv (\\<Gamma>, L) = {}\n\ngoal (1 subgoal):\n 1. domA as \\<inter> (set L \\<union> domA \\<Gamma>) = {}", "by (auto dest: subsetD[OF domA_fv_subset])"], ["proof (state)\nthis:\n  domA as \\<inter> (set L \\<union> domA \\<Gamma>) = {}\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "with Let(4)"], ["proof (chain)\npicking this:\n  fv (\\<Gamma>, Terms.Let as body, S)\n  \\<subseteq> set L \\<union> domA \\<Gamma>\n  domA as \\<inter> (set L \\<union> domA \\<Gamma>) = {}", "have \"domA as \\<inter> fv S = {}\""], ["proof (prove)\nusing this:\n  fv (\\<Gamma>, Terms.Let as body, S)\n  \\<subseteq> set L \\<union> domA \\<Gamma>\n  domA as \\<inter> (set L \\<union> domA \\<Gamma>) = {}\n\ngoal (1 subgoal):\n 1. domA as \\<inter> fv S = {}", "by auto"], ["proof (state)\nthis:\n  domA as \\<inter> fv S = {}\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "hence \"atom ` domA as \\<sharp>* S\""], ["proof (prove)\nusing this:\n  domA as \\<inter> fv S = {}\n\ngoal (1 subgoal):\n 1. atom ` domA as \\<sharp>* S", "by (auto simp add: fresh_star_def fv_def fresh_def)"], ["proof (state)\nthis:\n  atom ` domA as \\<sharp>* S\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "ultimately"], ["proof (chain)\npicking this:\n  atom ` domA as \\<sharp>* \\<Gamma>\n  atom ` domA as \\<sharp>* S", "have \"(\\<Gamma>, Terms.Let as body, S) \\<Rightarrow> (as@\\<Gamma>, body, S)\""], ["proof (prove)\nusing this:\n  atom ` domA as \\<sharp>* \\<Gamma>\n  atom ` domA as \\<sharp>* S\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, Terms.Let as body, S) \\<Rightarrow> (as @ \\<Gamma>, body, S)", ".."], ["proof (state)\nthis:\n  (\\<Gamma>, Terms.Let as body, S) \\<Rightarrow> (as @ \\<Gamma>, body, S)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "also"], ["proof (state)\nthis:\n  (\\<Gamma>, Terms.Let as body, S) \\<Rightarrow> (as @ \\<Gamma>, body, S)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "have \"\\<dots> \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (as @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S)", "by (rule Let.IH[OF prem])"], ["proof (state)\nthis:\n  (as @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z S.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>S.\n           fv (\\<Delta> @ \\<Gamma>, body, S)\n           \\<subseteq> set L \\<union>\n                       domA (\\<Delta> @ \\<Gamma>) \\<Longrightarrow>\n           (\\<Delta> @ \\<Gamma>, body, S) \\<Rightarrow>\\<^sup>*\n           (\\<Theta>, z, S);\n        fv (\\<Gamma>, Terms.Let \\<Delta> body, S)\n        \\<subseteq> set L \\<union> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> (\\<Gamma>, Terms.Let \\<Delta> body,\n                          S) \\<Rightarrow>\\<^sup>*\n                         (\\<Theta>, z, S)", "finally"], ["proof (chain)\npicking this:\n  (\\<Gamma>, Terms.Let as body, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Gamma>, Terms.Let as body, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, Terms.Let as body, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S)", "."], ["proof (state)\nthis:\n  (\\<Gamma>, Terms.Let as body, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S)\n\ngoal:\nNo subgoals!", "qed"], ["", "type_synonym trace = \"conf list\""], ["", "fun stack :: \"conf \\<Rightarrow> stack\" where \"stack (\\<Gamma>, e, S) = S\""], ["", "interpretation traces step"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation trace_syn (\"_ \\<Rightarrow>\\<^sup>*\\<^bsub>_\\<^esub> _\" [50,50,50] 50) where \"trace_syn \\<equiv> trace\""], ["", "lemma conf_trace_induct_final[consumes 1, case_names trace_nil trace_cons]:\n  \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> final \\<Longrightarrow> (\\<And> \\<Gamma> e S. final = (\\<Gamma>, e, S) \\<Longrightarrow> P \\<Gamma> e S [] (\\<Gamma>, e, S)) \\<Longrightarrow> (\\<And>\\<Gamma> e S T \\<Gamma>' e' S'. (\\<Gamma>', e', S') \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> final \\<Longrightarrow> P \\<Gamma>' e' S' T final \\<Longrightarrow> (\\<Gamma>, e, S) \\<Rightarrow> (\\<Gamma>', e', S') \\<Longrightarrow> P \\<Gamma> e S ((\\<Gamma>', e', S') # T) final) \\<Longrightarrow> P \\<Gamma> e S T final\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> final;\n     \\<And>\\<Gamma> e S.\n        final = (\\<Gamma>, e, S) \\<Longrightarrow>\n        P \\<Gamma> e S [] (\\<Gamma>, e, S);\n     \\<And>\\<Gamma> e S T \\<Gamma>' e' S'.\n        \\<lbrakk>(\\<Gamma>', e',\n                  S') \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> final;\n         P \\<Gamma>' e' S' T final;\n         (\\<Gamma>, e, S) \\<Rightarrow> (\\<Gamma>', e', S')\\<rbrakk>\n        \\<Longrightarrow> P \\<Gamma> e S ((\\<Gamma>', e', S') # T)\n                           final\\<rbrakk>\n    \\<Longrightarrow> P \\<Gamma> e S T final", "by (induction \"(\\<Gamma>, e, S)\" T final arbitrary: \\<Gamma> e S rule: trace_induct_final) auto"], ["", "interpretation balance_trace step  stack"], ["proof (prove)\ngoal (1 subgoal):\n 1. balance_trace (\\<Rightarrow>) stack", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c c'.\n       c \\<Rightarrow> c' \\<Longrightarrow>\n       stack c = stack c' \\<or>\n       (\\<exists>x. stack c' = x # stack c) \\<or>\n       (\\<exists>x. stack c = x # stack c')", "apply (erule step.cases)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>c c' \\<Gamma> e x S.\n       \\<lbrakk>c = (\\<Gamma>, App e x, S);\n        c' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> stack c = stack c' \\<or>\n                         (\\<exists>x. stack c' = x # stack c) \\<or>\n                         (\\<exists>x. stack c = x # stack c')\n 2. \\<And>c c' \\<Gamma> y e x S.\n       \\<lbrakk>c = (\\<Gamma>, Lam [y]. e, Arg x # S);\n        c' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> stack c = stack c' \\<or>\n                         (\\<exists>x. stack c' = x # stack c) \\<or>\n                         (\\<exists>x. stack c = x # stack c')\n 3. \\<And>c c' \\<Gamma> x e S.\n       \\<lbrakk>c = (\\<Gamma>, Var x, S);\n        c' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> stack c = stack c' \\<or>\n                         (\\<exists>x. stack c' = x # stack c) \\<or>\n                         (\\<exists>x. stack c = x # stack c')\n 4. \\<And>c c' x \\<Gamma> e S.\n       \\<lbrakk>c = (\\<Gamma>, e, Upd x # S);\n        c' = ((x, e) # \\<Gamma>, e, S); x \\<notin> domA \\<Gamma>;\n        isVal e\\<rbrakk>\n       \\<Longrightarrow> stack c = stack c' \\<or>\n                         (\\<exists>x. stack c' = x # stack c) \\<or>\n                         (\\<exists>x. stack c = x # stack c')\n 5. \\<And>c c' \\<Delta> \\<Gamma> S e.\n       \\<lbrakk>c = (\\<Gamma>, Terms.Let \\<Delta> e, S);\n        c' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> stack c = stack c' \\<or>\n                         (\\<exists>x. stack c' = x # stack c) \\<or>\n                         (\\<exists>x. stack c = x # stack c')\n 6. \\<And>c c' \\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>c = (\\<Gamma>, scrut ? e1 : e2, S);\n        c' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> stack c = stack c' \\<or>\n                         (\\<exists>x. stack c' = x # stack c) \\<or>\n                         (\\<exists>x. stack c = x # stack c')\n 7. \\<And>c c' \\<Gamma> b e1 e2 S.\n       \\<lbrakk>c = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        c' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> stack c = stack c' \\<or>\n                         (\\<exists>x. stack c' = x # stack c) \\<or>\n                         (\\<exists>x. stack c = x # stack c')", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation bal_syn (\"_ \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>_\\<^esub> _\" [50,50,50] 50) where \"bal_syn \\<equiv> bal\""], ["", "lemma isVal_stops:\n  assumes \"isVal e\"\n  assumes \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\"\n  shows \"T=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T = []", "using assms"], ["proof (prove)\nusing this:\n  isVal e\n  (\\<Gamma>, e,\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. T = []", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isVal e;\n     (\\<Gamma>, e,\n      S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z,\n                   S)\\<rbrakk>\n    \\<Longrightarrow> T = []", "apply (erule balE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isVal e;\n     (\\<Gamma>, e,\n      S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S);\n     \\<forall>c'\\<in>set T. stack (\\<Gamma>, e, S) \\<lesssim> stack c';\n     stack (\\<Delta>, z, S) = stack (\\<Gamma>, e, S)\\<rbrakk>\n    \\<Longrightarrow> T = []", "apply (erule trace.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>final.\n       \\<lbrakk>isVal e;\n        \\<forall>c'\\<in>set T. stack (\\<Gamma>, e, S) \\<lesssim> stack c';\n        stack (\\<Delta>, z, S) = stack (\\<Gamma>, e, S);\n        (\\<Gamma>, e, S) = final; T = []; (\\<Delta>, z, S) = final\\<rbrakk>\n       \\<Longrightarrow> T = []\n 2. \\<And>conf' Ta final conf.\n       \\<lbrakk>isVal e;\n        \\<forall>c'\\<in>set T. stack (\\<Gamma>, e, S) \\<lesssim> stack c';\n        stack (\\<Delta>, z, S) = stack (\\<Gamma>, e, S);\n        (\\<Gamma>, e, S) = conf; T = conf' # Ta; (\\<Delta>, z, S) = final;\n        conf' \\<Rightarrow>\\<^sup>*\\<^bsub>Ta\\<^esub> final;\n        conf \\<Rightarrow> conf'\\<rbrakk>\n       \\<Longrightarrow> T = []", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conf' Ta final conf.\n       \\<lbrakk>isVal e;\n        \\<forall>c'\\<in>set T. stack (\\<Gamma>, e, S) \\<lesssim> stack c';\n        stack (\\<Delta>, z, S) = stack (\\<Gamma>, e, S);\n        (\\<Gamma>, e, S) = conf; T = conf' # Ta; (\\<Delta>, z, S) = final;\n        conf' \\<Rightarrow>\\<^sup>*\\<^bsub>Ta\\<^esub> final;\n        conf \\<Rightarrow> conf'\\<rbrakk>\n       \\<Longrightarrow> T = []", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b Ta.\n       \\<lbrakk>isVal e; T = (a, aa, b) # Ta;\n        (a, aa, b) \\<Rightarrow>\\<^sup>*\\<^bsub>Ta\\<^esub> (\\<Delta>, z, S);\n        (\\<Gamma>, e, S) \\<Rightarrow> (a, aa, b); S \\<lesssim> b;\n        \\<forall>c'\\<in>set Ta. S \\<lesssim> stack c'\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto elim!: step.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Ball_subst[simp]:\n  \"(\\<forall>p\\<in>set (\\<Gamma>[y::h=x]). f p) \\<longleftrightarrow> (\\<forall>p\\<in>set \\<Gamma>. case p of (z,e) \\<Rightarrow> f (z, e[y::=x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set \\<Gamma>[y::h=x]. f p) =\n    (\\<forall>p\\<in>set \\<Gamma>.\n        case p of (z, e) \\<Rightarrow> f (z, e[y::=x]))", "by (induction \\<Gamma>) auto"], ["", "lemma lemma_3:\n  assumes \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\"\n  assumes \"isVal z\"\n  shows \"\\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "using assms"], ["proof (prove)\nusing this:\n  (\\<Gamma>, e,\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n  isVal z\n\ngoal (1 subgoal):\n 1. \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "proof(induction T arbitrary: \\<Gamma> e S \\<Delta> z rule: measure_induct_rule[where f = length])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x \\<Gamma> e S \\<Delta> z.\n       \\<lbrakk>\\<And>y \\<Gamma> e S \\<Delta> z.\n                   \\<lbrakk>length y < length x;\n                    (\\<Gamma>, e,\n                     S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>y\\<^esub> (\\<Delta>,\n                                  z, S);\n                    isVal z\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                            S\\<^esub> \\<Delta> : z;\n        (\\<Gamma>, e,\n         S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>x\\<^esub> (\\<Delta>, z, S);\n        isVal z\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "case (less T \\<Gamma> e S \\<Delta> z)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?y < length T;\n   (?\\<Gamma>, ?e,\n    ?S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>?y\\<^esub> (?\\<Delta>, ?z, ?S);\n   isVal ?z\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> : ?e \\<Down>\\<^bsub>upds_list\n             ?S\\<^esub> ?\\<Delta> : ?z\n  (\\<Gamma>, e,\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n  isVal z\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Gamma> e S \\<Delta> z.\n       \\<lbrakk>\\<And>y \\<Gamma> e S \\<Delta> z.\n                   \\<lbrakk>length y < length x;\n                    (\\<Gamma>, e,\n                     S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>y\\<^esub> (\\<Delta>,\n                                  z, S);\n                    isVal z\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                            S\\<^esub> \\<Delta> : z;\n        (\\<Gamma>, e,\n         S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>x\\<^esub> (\\<Delta>, z, S);\n        isVal z\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "from \\<open>(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\\<close>"], ["proof (chain)\npicking this:\n  (\\<Gamma>, e,\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)", "have \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\" and \"\\<forall> c'\\<in>set T. S \\<lesssim> stack c'\""], ["proof (prove)\nusing this:\n  (\\<Gamma>, e,\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, e,\n     S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S) &&&\n    \\<forall>c'\\<in>set T. S \\<lesssim> stack c'", "unfolding bal.simps"], ["proof (prove)\nusing this:\n  \\<exists>c T c'.\n     (\\<Gamma>, e, S) = c \\<and>\n     T = T \\<and>\n     (\\<Delta>, z, S) = c' \\<and>\n     c \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> c' \\<and>\n     (\\<forall>c'\\<in>set T. stack c \\<lesssim> stack c') \\<and>\n     stack c' = stack c\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, e,\n     S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S) &&&\n    \\<forall>c'\\<in>set T. S \\<lesssim> stack c'", "by auto"], ["proof (state)\nthis:\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n  \\<forall>c'\\<in>set T. S \\<lesssim> stack c'\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Gamma> e S \\<Delta> z.\n       \\<lbrakk>\\<And>y \\<Gamma> e S \\<Delta> z.\n                   \\<lbrakk>length y < length x;\n                    (\\<Gamma>, e,\n                     S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>y\\<^esub> (\\<Delta>,\n                                  z, S);\n                    isVal z\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                            S\\<^esub> \\<Delta> : z;\n        (\\<Gamma>, e,\n         S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>x\\<^esub> (\\<Delta>, z, S);\n        isVal z\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "from this(1)"], ["proof (chain)\npicking this:\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>T = []; \\<Delta> = \\<Gamma>; z = e\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n             S\\<^esub> \\<Delta> : z\n 2. \\<And>conf' T.\n       \\<lbrakk>T = conf' # T;\n        conf' \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S);\n        (\\<Gamma>, e, S) \\<Rightarrow> conf'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "case trace_nil"], ["proof (state)\nthis:\n  T = []\n  \\<Delta> = \\<Gamma>\n  z = e\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T = []; \\<Delta> = \\<Gamma>; z = e\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n             S\\<^esub> \\<Delta> : z\n 2. \\<And>conf' T.\n       \\<lbrakk>T = conf' # T;\n        conf' \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S);\n        (\\<Gamma>, e, S) \\<Rightarrow> conf'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "from \\<open>isVal z\\<close>  trace_nil"], ["proof (chain)\npicking this:\n  isVal z\n  T = []\n  \\<Delta> = \\<Gamma>\n  z = e", "show ?thesis"], ["proof (prove)\nusing this:\n  isVal z\n  T = []\n  \\<Delta> = \\<Gamma>\n  z = e\n\ngoal (1 subgoal):\n 1. \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "by (auto intro: reds_isValI)"], ["proof (state)\nthis:\n  \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal (1 subgoal):\n 1. \\<And>conf' T.\n       \\<lbrakk>T = conf' # T;\n        conf' \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S);\n        (\\<Gamma>, e, S) \\<Rightarrow> conf'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>conf' T.\n       \\<lbrakk>T = conf' # T;\n        conf' \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S);\n        (\\<Gamma>, e, S) \\<Rightarrow> conf'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "case (trace_cons conf' T')"], ["proof (state)\nthis:\n  T = conf' # T'\n  conf' \\<Rightarrow>\\<^sup>*\\<^bsub>T'\\<^esub> (\\<Delta>, z, S)\n  (\\<Gamma>, e, S) \\<Rightarrow> conf'\n\ngoal (1 subgoal):\n 1. \\<And>conf' T.\n       \\<lbrakk>T = conf' # T;\n        conf' \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S);\n        (\\<Gamma>, e, S) \\<Rightarrow> conf'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "from \\<open>T = conf' # T'\\<close> and \\<open>\\<forall> c'\\<in>set T. S \\<lesssim> stack c'\\<close>"], ["proof (chain)\npicking this:\n  T = conf' # T'\n  \\<forall>c'\\<in>set T. S \\<lesssim> stack c'", "have \"S \\<lesssim> stack conf'\""], ["proof (prove)\nusing this:\n  T = conf' # T'\n  \\<forall>c'\\<in>set T. S \\<lesssim> stack c'\n\ngoal (1 subgoal):\n 1. S \\<lesssim> stack conf'", "by auto"], ["proof (state)\nthis:\n  S \\<lesssim> stack conf'\n\ngoal (1 subgoal):\n 1. \\<And>conf' T.\n       \\<lbrakk>T = conf' # T;\n        conf' \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S);\n        (\\<Gamma>, e, S) \\<Rightarrow> conf'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "from \\<open>(\\<Gamma>, e, S) \\<Rightarrow> conf'\\<close>"], ["proof (chain)\npicking this:\n  (\\<Gamma>, e, S) \\<Rightarrow> conf'", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Gamma>, e, S) \\<Rightarrow> conf'\n\ngoal (1 subgoal):\n 1. \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "proof(cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<lbrakk>e = App e x; conf' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>y e x S.\n       \\<lbrakk>e = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>x e.\n       \\<lbrakk>e = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 4. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 5. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 7. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "case (app\\<^sub>1 e x)"], ["proof (state)\nthis:\n  ea__ = App e x\n  conf' = (\\<Gamma>, e, Arg x # S)\n\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<lbrakk>ea__ = App e x; conf' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 7. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "obtain T\\<^sub>1 c\\<^sub>3 c\\<^sub>4 T\\<^sub>2\n      where \"T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2\" and prem1: \"(\\<Gamma>, e, Arg x # S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3\" and \"c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\" and prem2: \" c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>, z, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T\\<^sub>1 c\\<^sub>4 T\\<^sub>2 c\\<^sub>3.\n        \\<lbrakk>T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2;\n         (\\<Gamma>, e,\n          Arg x #\n          S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3;\n         c\\<^sub>3 \\<Rightarrow> c\\<^sub>4;\n         c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                                     z, S)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule bal_consE[OF  \\<open>bal _ T _\\<close>[unfolded app\\<^sub>1 trace_cons]]) (simp, rule)"], ["proof (state)\nthis:\n  T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2\n  (\\<Gamma>, e,\n   Arg x #\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3\n  c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\n  c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                              z, S)\n\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<lbrakk>ea__ = App e x; conf' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 7. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "from \\<open>T = _\\<close> \\<open>T' = _\\<close>"], ["proof (chain)\npicking this:\n  T = conf' # T'\n  T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2", "have \"length T\\<^sub>1 < length T\" and \"length T\\<^sub>2 < length T\""], ["proof (prove)\nusing this:\n  T = conf' # T'\n  T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2\n\ngoal (1 subgoal):\n 1. length T\\<^sub>1 < length T &&& length T\\<^sub>2 < length T", "by auto"], ["proof (state)\nthis:\n  length T\\<^sub>1 < length T\n  length T\\<^sub>2 < length T\n\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<lbrakk>ea__ = App e x; conf' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 7. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "from prem1"], ["proof (chain)\npicking this:\n  (\\<Gamma>, e,\n   Arg x #\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3", "have \"stack c\\<^sub>3 =  Arg x # S\""], ["proof (prove)\nusing this:\n  (\\<Gamma>, e,\n   Arg x #\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3\n\ngoal (1 subgoal):\n 1. stack c\\<^sub>3 = Arg x # S", "by (auto dest:  bal_stackD)"], ["proof (state)\nthis:\n  stack c\\<^sub>3 = Arg x # S\n\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<lbrakk>ea__ = App e x; conf' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 7. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "moreover"], ["proof (state)\nthis:\n  stack c\\<^sub>3 = Arg x # S\n\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<lbrakk>ea__ = App e x; conf' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 7. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "from prem2"], ["proof (chain)\npicking this:\n  c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                              z, S)", "have \"stack c\\<^sub>4 = S\""], ["proof (prove)\nusing this:\n  c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                              z, S)\n\ngoal (1 subgoal):\n 1. stack c\\<^sub>4 = S", "by (auto dest: bal_stackD)"], ["proof (state)\nthis:\n  stack c\\<^sub>4 = S\n\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<lbrakk>ea__ = App e x; conf' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 7. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "moreover"], ["proof (state)\nthis:\n  stack c\\<^sub>4 = S\n\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<lbrakk>ea__ = App e x; conf' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 7. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "note \\<open>c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\n\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<lbrakk>ea__ = App e x; conf' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 7. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "ultimately"], ["proof (chain)\npicking this:\n  stack c\\<^sub>3 = Arg x # S\n  stack c\\<^sub>4 = S\n  c\\<^sub>3 \\<Rightarrow> c\\<^sub>4", "obtain \\<Delta>' y e' where \"c\\<^sub>3 = (\\<Delta>', Lam [y]. e', Arg x # S)\" and \"c\\<^sub>4 = (\\<Delta>', e'[y ::= x], S)\""], ["proof (prove)\nusing this:\n  stack c\\<^sub>3 = Arg x # S\n  stack c\\<^sub>4 = S\n  c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Delta>' y e'.\n        \\<lbrakk>c\\<^sub>3 = (\\<Delta>', Lam [y]. e', Arg x # S);\n         c\\<^sub>4 = (\\<Delta>', e'[y::=x], S)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: step.cases simp del: exp_assn.eq_iff)"], ["proof (state)\nthis:\n  c\\<^sub>3 = (\\<Delta>', Lam [y]. e', Arg x # S)\n  c\\<^sub>4 = (\\<Delta>', e'[y::=x], S)\n\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<lbrakk>ea__ = App e x; conf' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 7. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "from less(1)[OF \\<open>length T\\<^sub>1 < length T\\<close> prem1[unfolded \\<open>c\\<^sub>3 = _\\<close> \\<open>c\\<^sub>4 = _\\<close>]]"], ["proof (chain)\npicking this:\n  isVal (Lam [y]. e') \\<Longrightarrow>\n  \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                               (Arg x # S)\\<^esub> \\<Delta>' : Lam [y]. e'", "have \"\\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Lam [y]. e'\""], ["proof (prove)\nusing this:\n  isVal (Lam [y]. e') \\<Longrightarrow>\n  \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                               (Arg x # S)\\<^esub> \\<Delta>' : Lam [y]. e'\n\ngoal (1 subgoal):\n 1. \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Lam [y]. e'", "by simp"], ["proof (state)\nthis:\n  \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Lam [y]. e'\n\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<lbrakk>ea__ = App e x; conf' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 7. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "moreover"], ["proof (state)\nthis:\n  \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Lam [y]. e'\n\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<lbrakk>ea__ = App e x; conf' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 7. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "from less(1)[OF \\<open>length T\\<^sub>2 < length T\\<close> prem2[unfolded \\<open>c\\<^sub>3 = _\\<close> \\<open>c\\<^sub>4 = _\\<close>] \\<open>isVal z\\<close>]"], ["proof (chain)\npicking this:\n  \\<Delta>' : e'[y::=x] \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "have \"\\<Delta>' : e'[y::=x] \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\""], ["proof (prove)\nusing this:\n  \\<Delta>' : e'[y::=x] \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal (1 subgoal):\n 1. \\<Delta>' : e'[y::=x] \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "by simp"], ["proof (state)\nthis:\n  \\<Delta>' : e'[y::=x] \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<lbrakk>ea__ = App e x; conf' = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 7. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "ultimately"], ["proof (chain)\npicking this:\n  \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Lam [y]. e'\n  \\<Delta>' : e'[y::=x] \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Lam [y]. e'\n  \\<Delta>' : e'[y::=x] \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal (1 subgoal):\n 1. \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "unfolding app\\<^sub>1"], ["proof (prove)\nusing this:\n  \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Lam [y]. e'\n  \\<Delta>' : e'[y::=x] \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal (1 subgoal):\n 1. \\<Gamma> : App e x \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "by (rule reds_ApplicationI)"], ["proof (state)\nthis:\n  \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal (6 subgoals):\n 1. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>y e x S.\n       \\<lbrakk>e = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>x e.\n       \\<lbrakk>e = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 4. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 5. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 6. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "case (app\\<^sub>2 y e x S')"], ["proof (state)\nthis:\n  ea__ = Lam [y]. e\n  S = Arg x # S'\n  conf' = (\\<Gamma>, e[y::=x], S')\n\ngoal (6 subgoals):\n 1. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "from \\<open>conf' =_\\<close> \\<open>S = _ # S'\\<close> \\<open>S \\<lesssim> stack conf'\\<close>"], ["proof (chain)\npicking this:\n  conf' = (\\<Gamma>, e[y::=x], S')\n  S = Arg x # S'\n  S \\<lesssim> stack conf'", "have False"], ["proof (prove)\nusing this:\n  conf' = (\\<Gamma>, e[y::=x], S')\n  S = Arg x # S'\n  S \\<lesssim> stack conf'\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: extends_def)"], ["proof (state)\nthis:\n  False\n\ngoal (6 subgoals):\n 1. \\<And>y e x S.\n       \\<lbrakk>ea__ = Lam [y]. e; S = Arg x # S;\n        conf' = (\\<Gamma>, e[y::=x], S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 6. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", ".."], ["proof (state)\nthis:\n  \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>e = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "case (var\\<^sub>1 x e)"], ["proof (state)\nthis:\n  ea__ = Var x\n  conf' = (delete x \\<Gamma>, e, Upd x # S)\n  map_of \\<Gamma> x = Some e\n\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "obtain T\\<^sub>1 c\\<^sub>3 c\\<^sub>4 T\\<^sub>2\n      where \"T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2\" and prem1: \"(delete x \\<Gamma>, e, Upd x # S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3\" and \"c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\" and prem2: \"c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>, z, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T\\<^sub>1 c\\<^sub>4 T\\<^sub>2 c\\<^sub>3.\n        \\<lbrakk>T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2;\n         (delete x \\<Gamma>, e,\n          Upd x #\n          S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3;\n         c\\<^sub>3 \\<Rightarrow> c\\<^sub>4;\n         c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                                     z, S)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule bal_consE[OF  \\<open>bal _ T _\\<close>[unfolded var\\<^sub>1 trace_cons]]) (simp, rule)"], ["proof (state)\nthis:\n  T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2\n  (delete x \\<Gamma>, e,\n   Upd x #\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3\n  c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\n  c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                              z, S)\n\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "from \\<open>T = _\\<close> \\<open>T' = _\\<close>"], ["proof (chain)\npicking this:\n  T = conf' # T'\n  T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2", "have \"length T\\<^sub>1 < length T\" and \"length T\\<^sub>2 < length T\""], ["proof (prove)\nusing this:\n  T = conf' # T'\n  T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2\n\ngoal (1 subgoal):\n 1. length T\\<^sub>1 < length T &&& length T\\<^sub>2 < length T", "by auto"], ["proof (state)\nthis:\n  length T\\<^sub>1 < length T\n  length T\\<^sub>2 < length T\n\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "from prem1"], ["proof (chain)\npicking this:\n  (delete x \\<Gamma>, e,\n   Upd x #\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3", "have \"stack c\\<^sub>3 = Upd x # S\""], ["proof (prove)\nusing this:\n  (delete x \\<Gamma>, e,\n   Upd x #\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3\n\ngoal (1 subgoal):\n 1. stack c\\<^sub>3 = Upd x # S", "by (auto dest:  bal_stackD)"], ["proof (state)\nthis:\n  stack c\\<^sub>3 = Upd x # S\n\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "moreover"], ["proof (state)\nthis:\n  stack c\\<^sub>3 = Upd x # S\n\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "from prem2"], ["proof (chain)\npicking this:\n  c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                              z, S)", "have \"stack c\\<^sub>4 = S\""], ["proof (prove)\nusing this:\n  c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                              z, S)\n\ngoal (1 subgoal):\n 1. stack c\\<^sub>4 = S", "by (auto dest: bal_stackD)"], ["proof (state)\nthis:\n  stack c\\<^sub>4 = S\n\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "moreover"], ["proof (state)\nthis:\n  stack c\\<^sub>4 = S\n\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "note \\<open>c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\n\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "ultimately"], ["proof (chain)\npicking this:\n  stack c\\<^sub>3 = Upd x # S\n  stack c\\<^sub>4 = S\n  c\\<^sub>3 \\<Rightarrow> c\\<^sub>4", "obtain \\<Delta>' z' where \"c\\<^sub>3 = (\\<Delta>', z', Upd x # S)\" and \"c\\<^sub>4 = ((x,z')#\\<Delta>', z', S)\" and \"isVal z'\""], ["proof (prove)\nusing this:\n  stack c\\<^sub>3 = Upd x # S\n  stack c\\<^sub>4 = S\n  c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Delta>' z'.\n        \\<lbrakk>c\\<^sub>3 = (\\<Delta>', z', Upd x # S);\n         c\\<^sub>4 = ((x, z') # \\<Delta>', z', S); isVal z'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: step.cases simp del: exp_assn.eq_iff)"], ["proof (state)\nthis:\n  c\\<^sub>3 = (\\<Delta>', z', Upd x # S)\n  c\\<^sub>4 = ((x, z') # \\<Delta>', z', S)\n  isVal z'\n\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "from \\<open>isVal z'\\<close> and prem2[unfolded \\<open>c\\<^sub>4 = _\\<close>]"], ["proof (chain)\npicking this:\n  isVal z'\n  ((x, z') # \\<Delta>', z',\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>, z,\n                        S)", "have \"T\\<^sub>2 = []\""], ["proof (prove)\nusing this:\n  isVal z'\n  ((x, z') # \\<Delta>', z',\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>, z,\n                        S)\n\ngoal (1 subgoal):\n 1. T\\<^sub>2 = []", "by (rule isVal_stops)"], ["proof (state)\nthis:\n  T\\<^sub>2 = []\n\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "with prem2 \\<open>c\\<^sub>4 = _\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                              z, S)\n  c\\<^sub>4 = ((x, z') # \\<Delta>', z', S)\n  T\\<^sub>2 = []", "have \"z' = z\" and \"\\<Delta> = (x,z)#\\<Delta>'\""], ["proof (prove)\nusing this:\n  c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                              z, S)\n  c\\<^sub>4 = ((x, z') # \\<Delta>', z', S)\n  T\\<^sub>2 = []\n\ngoal (1 subgoal):\n 1. z' = z &&& \\<Delta> = (x, z) # \\<Delta>'", "by auto"], ["proof (state)\nthis:\n  z' = z\n  \\<Delta> = (x, z) # \\<Delta>'\n\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "from less(1)[OF \\<open>length T\\<^sub>1 < length T\\<close> prem1[unfolded \\<open>c\\<^sub>3 = _\\<close> \\<open>c\\<^sub>4 = _\\<close>  \\<open>z' = _\\<close>]  \\<open>isVal z\\<close>]"], ["proof (chain)\npicking this:\n  delete x\n   \\<Gamma> : e \\<Down>\\<^bsub>upds_list (Upd x # S)\\<^esub> \\<Delta>' : z", "have \"delete x \\<Gamma> : e \\<Down>\\<^bsub>x # upds_list S\\<^esub> \\<Delta>' : z\""], ["proof (prove)\nusing this:\n  delete x\n   \\<Gamma> : e \\<Down>\\<^bsub>upds_list (Upd x # S)\\<^esub> \\<Delta>' : z\n\ngoal (1 subgoal):\n 1. delete x\n     \\<Gamma> : e \\<Down>\\<^bsub>x # upds_list S\\<^esub> \\<Delta>' : z", "by simp"], ["proof (state)\nthis:\n  delete x \\<Gamma> : e \\<Down>\\<^bsub>x # upds_list S\\<^esub> \\<Delta>' : z\n\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>ea__ = Var x; conf' = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 5. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "with \\<open>map_of _ _ = _\\<close>"], ["proof (chain)\npicking this:\n  map_of \\<Gamma> x = Some e\n  delete x \\<Gamma> : e \\<Down>\\<^bsub>x # upds_list S\\<^esub> \\<Delta>' : z", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of \\<Gamma> x = Some e\n  delete x \\<Gamma> : e \\<Down>\\<^bsub>x # upds_list S\\<^esub> \\<Delta>' : z\n\ngoal (1 subgoal):\n 1. \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "unfolding var\\<^sub>1(1) \\<open>\\<Delta> = _\\<close>"], ["proof (prove)\nusing this:\n  map_of \\<Gamma> x = Some e\n  delete x \\<Gamma> : e \\<Down>\\<^bsub>x # upds_list S\\<^esub> \\<Delta>' : z\n\ngoal (1 subgoal):\n 1. \\<Gamma> : Var x \\<Down>\\<^bsub>upds_list\n                                     S\\<^esub> (x, z) # \\<Delta>' : z", "by rule"], ["proof (state)\nthis:\n  \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal (4 subgoals):\n 1. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, ea__) # \\<Gamma>, ea__, S);\n        x \\<notin> domA \\<Gamma>; isVal ea__\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 2. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 3. \\<And>scrut e1 e2.\n       \\<lbrakk>ea__ = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z\n 4. \\<And>b e1 e2 S.\n       \\<lbrakk>ea__ = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 4. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "case (var\\<^sub>2 x S')"], ["proof (state)\nthis:\n  S = Upd x # S'\n  conf' = ((x, e) # \\<Gamma>, e, S')\n  x \\<notin> domA \\<Gamma>\n  isVal e\n\ngoal (4 subgoals):\n 1. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 4. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "from \\<open>conf' = _\\<close> \\<open>S = _ # S'\\<close> \\<open>S \\<lesssim> stack conf'\\<close>"], ["proof (chain)\npicking this:\n  conf' = ((x, e) # \\<Gamma>, e, S')\n  S = Upd x # S'\n  S \\<lesssim> stack conf'", "have False"], ["proof (prove)\nusing this:\n  conf' = ((x, e) # \\<Gamma>, e, S')\n  S = Upd x # S'\n  S \\<lesssim> stack conf'\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: extends_def)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>x S.\n       \\<lbrakk>S = Upd x # S; conf' = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 4. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", ".."], ["proof (state)\nthis:\n  \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "case (if\\<^sub>1 scrut  e\\<^sub>1 e\\<^sub>2)"], ["proof (state)\nthis:\n  e = (scrut ? e\\<^sub>1 : e\\<^sub>2)\n  conf' = (\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 # S)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "obtain T\\<^sub>1 c\\<^sub>3 c\\<^sub>4 T\\<^sub>2\n      where \"T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2\" and prem1: \"(\\<Gamma>, scrut, Alts e\\<^sub>1 e\\<^sub>2 # S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3\" and \"c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\" and prem2: \"c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>, z, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T\\<^sub>1 c\\<^sub>4 T\\<^sub>2 c\\<^sub>3.\n        \\<lbrakk>T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2;\n         (\\<Gamma>, scrut,\n          Alts e\\<^sub>1 e\\<^sub>2 #\n          S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3;\n         c\\<^sub>3 \\<Rightarrow> c\\<^sub>4;\n         c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                                     z, S)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule bal_consE[OF  \\<open>bal _ T _\\<close>[unfolded if\\<^sub>1 trace_cons]])  (simp, rule)"], ["proof (state)\nthis:\n  T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2\n  (\\<Gamma>, scrut,\n   Alts e\\<^sub>1 e\\<^sub>2 #\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3\n  c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\n  c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                              z, S)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "from \\<open>T = _\\<close> \\<open>T' = _\\<close>"], ["proof (chain)\npicking this:\n  T = conf' # T'\n  T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2", "have \"length T\\<^sub>1 < length T\" and \"length T\\<^sub>2 < length T\""], ["proof (prove)\nusing this:\n  T = conf' # T'\n  T' = T\\<^sub>1 @ c\\<^sub>4 # T\\<^sub>2\n\ngoal (1 subgoal):\n 1. length T\\<^sub>1 < length T &&& length T\\<^sub>2 < length T", "by auto"], ["proof (state)\nthis:\n  length T\\<^sub>1 < length T\n  length T\\<^sub>2 < length T\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "from prem1"], ["proof (chain)\npicking this:\n  (\\<Gamma>, scrut,\n   Alts e\\<^sub>1 e\\<^sub>2 #\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3", "have \"stack c\\<^sub>3 = Alts e\\<^sub>1 e\\<^sub>2 # S\""], ["proof (prove)\nusing this:\n  (\\<Gamma>, scrut,\n   Alts e\\<^sub>1 e\\<^sub>2 #\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>1\\<^esub> c\\<^sub>3\n\ngoal (1 subgoal):\n 1. stack c\\<^sub>3 = Alts e\\<^sub>1 e\\<^sub>2 # S", "by (auto dest:  bal_stackD)"], ["proof (state)\nthis:\n  stack c\\<^sub>3 = Alts e\\<^sub>1 e\\<^sub>2 # S\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "moreover"], ["proof (state)\nthis:\n  stack c\\<^sub>3 = Alts e\\<^sub>1 e\\<^sub>2 # S\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "from prem2"], ["proof (chain)\npicking this:\n  c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                              z, S)", "have \"stack c\\<^sub>4 = S\""], ["proof (prove)\nusing this:\n  c\\<^sub>4 \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^sub>2\\<^esub> (\\<Delta>,\n                              z, S)\n\ngoal (1 subgoal):\n 1. stack c\\<^sub>4 = S", "by (auto dest: bal_stackD)"], ["proof (state)\nthis:\n  stack c\\<^sub>4 = S\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "moreover"], ["proof (state)\nthis:\n  stack c\\<^sub>4 = S\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "note \\<open>c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "ultimately"], ["proof (chain)\npicking this:\n  stack c\\<^sub>3 = Alts e\\<^sub>1 e\\<^sub>2 # S\n  stack c\\<^sub>4 = S\n  c\\<^sub>3 \\<Rightarrow> c\\<^sub>4", "obtain \\<Delta>' b where \"c\\<^sub>3 = (\\<Delta>', Bool b, Alts e\\<^sub>1 e\\<^sub>2 # S)\" and \"c\\<^sub>4 = (\\<Delta>', (if b then e\\<^sub>1 else e\\<^sub>2), S)\""], ["proof (prove)\nusing this:\n  stack c\\<^sub>3 = Alts e\\<^sub>1 e\\<^sub>2 # S\n  stack c\\<^sub>4 = S\n  c\\<^sub>3 \\<Rightarrow> c\\<^sub>4\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Delta>' b.\n        \\<lbrakk>c\\<^sub>3 =\n                 (\\<Delta>', Bool b, Alts e\\<^sub>1 e\\<^sub>2 # S);\n         c\\<^sub>4 =\n         (\\<Delta>', if b then e\\<^sub>1 else e\\<^sub>2, S)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: step.cases simp del: exp_assn.eq_iff)"], ["proof (state)\nthis:\n  c\\<^sub>3 = (\\<Delta>', Bool b, Alts e\\<^sub>1 e\\<^sub>2 # S)\n  c\\<^sub>4 = (\\<Delta>', if b then e\\<^sub>1 else e\\<^sub>2, S)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "from less(1)[OF \\<open>length T\\<^sub>1 < length T\\<close> prem1[unfolded \\<open>c\\<^sub>3 = _\\<close> \\<open>c\\<^sub>4 = _\\<close> ] isVal_Bool]"], ["proof (chain)\npicking this:\n  \\<Gamma> : scrut \\<Down>\\<^bsub>upds_list\n                                   (Alts e\\<^sub>1 e\\<^sub>2 #\n                                    S)\\<^esub> \\<Delta>' : Bool b", "have \"\\<Gamma> : scrut \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Bool b\""], ["proof (prove)\nusing this:\n  \\<Gamma> : scrut \\<Down>\\<^bsub>upds_list\n                                   (Alts e\\<^sub>1 e\\<^sub>2 #\n                                    S)\\<^esub> \\<Delta>' : Bool b\n\ngoal (1 subgoal):\n 1. \\<Gamma> : scrut \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Bool b", "by simp"], ["proof (state)\nthis:\n  \\<Gamma> : scrut \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Bool b\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "moreover"], ["proof (state)\nthis:\n  \\<Gamma> : scrut \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Bool b\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "from less(1)[OF \\<open>length T\\<^sub>2 < length T\\<close> prem2[unfolded \\<open>c\\<^sub>4 = _\\<close>] \\<open>isVal z\\<close>]"], ["proof (chain)\npicking this:\n  \\<Delta>' : (if b then e\\<^sub>1\n               else e\\<^sub>2) \\<Down>\\<^bsub>upds_list\n         S\\<^esub> \\<Delta> : z", "have \"\\<Delta>' : (if b then e\\<^sub>1 else e\\<^sub>2) \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\""], ["proof (prove)\nusing this:\n  \\<Delta>' : (if b then e\\<^sub>1\n               else e\\<^sub>2) \\<Down>\\<^bsub>upds_list\n         S\\<^esub> \\<Delta> : z\n\ngoal (1 subgoal):\n 1. \\<Delta>' : (if b then e\\<^sub>1\n                 else e\\<^sub>2) \\<Down>\\<^bsub>upds_list\n           S\\<^esub> \\<Delta> : z", "."], ["proof (state)\nthis:\n  \\<Delta>' : (if b then e\\<^sub>1\n               else e\\<^sub>2) \\<Down>\\<^bsub>upds_list\n         S\\<^esub> \\<Delta> : z\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>e = (scrut ? e1 : e2);\n        conf' = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 3. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "ultimately"], ["proof (chain)\npicking this:\n  \\<Gamma> : scrut \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Bool b\n  \\<Delta>' : (if b then e\\<^sub>1\n               else e\\<^sub>2) \\<Down>\\<^bsub>upds_list\n         S\\<^esub> \\<Delta> : z", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma> : scrut \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Bool b\n  \\<Delta>' : (if b then e\\<^sub>1\n               else e\\<^sub>2) \\<Down>\\<^bsub>upds_list\n         S\\<^esub> \\<Delta> : z\n\ngoal (1 subgoal):\n 1. \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "unfolding if\\<^sub>1"], ["proof (prove)\nusing this:\n  \\<Gamma> : scrut \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta>' : Bool b\n  \\<Delta>' : (if b then e\\<^sub>1\n               else e\\<^sub>2) \\<Down>\\<^bsub>upds_list\n         S\\<^esub> \\<Delta> : z\n\ngoal (1 subgoal):\n 1. \\<Gamma> : (scrut ? e\\<^sub>1\n                : e\\<^sub>2) \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "by (rule reds.IfThenElse)"], ["proof (state)\nthis:\n  \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "case (if\\<^sub>2 b e1 e2 S')"], ["proof (state)\nthis:\n  e = Bool b\n  S = Alts e1 e2 # S'\n  conf' = (\\<Gamma>, if b then e1 else e2, S')\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "from \\<open>conf' = _\\<close> \\<open>S = _ # S'\\<close> \\<open>S \\<lesssim> stack conf'\\<close>"], ["proof (chain)\npicking this:\n  conf' = (\\<Gamma>, if b then e1 else e2, S')\n  S = Alts e1 e2 # S'\n  S \\<lesssim> stack conf'", "have False"], ["proof (prove)\nusing this:\n  conf' = (\\<Gamma>, if b then e1 else e2, S')\n  S = Alts e1 e2 # S'\n  S \\<lesssim> stack conf'\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: extends_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z\n 2. \\<And>b e1 e2 S.\n       \\<lbrakk>e = Bool b; S = Alts e1 e2 # S;\n        conf' = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", ".."], ["proof (state)\nthis:\n  \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>e = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>upds_list\n                S\\<^esub> \\<Delta> : z", "case (let\\<^sub>1 as e)"], ["proof (state)\nthis:\n  ea__ = Terms.Let as e\n  conf' = (as @ \\<Gamma>, e, S)\n  atom ` domA as \\<sharp>* \\<Gamma>\n  atom ` domA as \\<sharp>* S\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "from \\<open>T = conf' # T'\\<close>"], ["proof (chain)\npicking this:\n  T = conf' # T'", "have \"length T' < length T\""], ["proof (prove)\nusing this:\n  T = conf' # T'\n\ngoal (1 subgoal):\n 1. length T' < length T", "by auto"], ["proof (state)\nthis:\n  length T' < length T\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "moreover"], ["proof (state)\nthis:\n  length T' < length T\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "have \"(as @ \\<Gamma>, e, S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T'\\<^esub> (\\<Delta>, z, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (as @ \\<Gamma>, e,\n     S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T'\\<^esub> (\\<Delta>, z, S)", "using trace_cons \\<open>conf' = _\\<close>  \\<open>\\<forall> c'\\<in>set T. S \\<lesssim> stack c'\\<close>"], ["proof (prove)\nusing this:\n  T = conf' # T'\n  conf' \\<Rightarrow>\\<^sup>*\\<^bsub>T'\\<^esub> (\\<Delta>, z, S)\n  (\\<Gamma>, ea__, S) \\<Rightarrow> conf'\n  conf' = (as @ \\<Gamma>, e, S)\n  \\<forall>c'\\<in>set T. S \\<lesssim> stack c'\n\ngoal (1 subgoal):\n 1. (as @ \\<Gamma>, e,\n     S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T'\\<^esub> (\\<Delta>, z, S)", "by fastforce"], ["proof (state)\nthis:\n  (as @ \\<Gamma>, e,\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T'\\<^esub> (\\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "moreover"], ["proof (state)\nthis:\n  (as @ \\<Gamma>, e,\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T'\\<^esub> (\\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "note \\<open>isVal z\\<close>"], ["proof (state)\nthis:\n  isVal z\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "ultimately"], ["proof (chain)\npicking this:\n  length T' < length T\n  (as @ \\<Gamma>, e,\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T'\\<^esub> (\\<Delta>, z, S)\n  isVal z", "have \"as @ \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\""], ["proof (prove)\nusing this:\n  length T' < length T\n  (as @ \\<Gamma>, e,\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T'\\<^esub> (\\<Delta>, z, S)\n  isVal z\n\ngoal (1 subgoal):\n 1. as @ \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "by (rule less)"], ["proof (state)\nthis:\n  as @ \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "moreover"], ["proof (state)\nthis:\n  as @ \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "from \\<open>atom ` domA as \\<sharp>* \\<Gamma>\\<close>  \\<open>atom ` domA as \\<sharp>* S\\<close>"], ["proof (chain)\npicking this:\n  atom ` domA as \\<sharp>* \\<Gamma>\n  atom ` domA as \\<sharp>* S", "have \"atom ` domA as \\<sharp>* (\\<Gamma>, upds_list S)\""], ["proof (prove)\nusing this:\n  atom ` domA as \\<sharp>* \\<Gamma>\n  atom ` domA as \\<sharp>* S\n\ngoal (1 subgoal):\n 1. atom ` domA as \\<sharp>* (\\<Gamma>, upds_list S)", "by (auto simp add: fresh_star_Pair)"], ["proof (state)\nthis:\n  atom ` domA as \\<sharp>* (\\<Gamma>, upds_list S)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> e.\n       \\<lbrakk>ea__ = Terms.Let \\<Delta> e;\n        conf' = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list\n                   S\\<^esub> \\<Delta> : z", "ultimately"], ["proof (chain)\npicking this:\n  as @ \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n  atom ` domA as \\<sharp>* (\\<Gamma>, upds_list S)", "show ?thesis"], ["proof (prove)\nusing this:\n  as @ \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n  atom ` domA as \\<sharp>* (\\<Gamma>, upds_list S)\n\ngoal (1 subgoal):\n 1. \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "unfolding let\\<^sub>1"], ["proof (prove)\nusing this:\n  as @ \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n  atom ` domA as \\<sharp>* (\\<Gamma>, upds_list S)\n\ngoal (1 subgoal):\n 1. \\<Gamma> : Terms.Let as\n                e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z", "by (rule reds.Let[rotated])"], ["proof (state)\nthis:\n  \\<Gamma> : ea__ \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma> : e \\<Down>\\<^bsub>upds_list S\\<^esub> \\<Delta> : z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dummy_stack_extended:\n  \"set S \\<subseteq>  Dummy ` UNIV \\<Longrightarrow> x \\<notin> Dummy ` UNIV \\<Longrightarrow> (S \\<lesssim> x # S') \\<longleftrightarrow>  S \\<lesssim> S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set S \\<subseteq> range Dummy; x \\<notin> range Dummy\\<rbrakk>\n    \\<Longrightarrow> (S \\<lesssim> x # S') = (S \\<lesssim> S')", "apply (auto simp add: extends_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S''.\n       \\<lbrakk>set S \\<subseteq> range Dummy; x \\<notin> range Dummy;\n        x # S' = S'' @ S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S''. S' = S'' @ S", "apply (case_tac S'')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S''.\n       \\<lbrakk>set S \\<subseteq> range Dummy; x \\<notin> range Dummy;\n        x # S' = S'' @ S; S'' = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S''. S' = S'' @ S\n 2. \\<And>S'' a list.\n       \\<lbrakk>set S \\<subseteq> range Dummy; x \\<notin> range Dummy;\n        x # S' = S'' @ S; S'' = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S''. S' = S'' @ S", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma[simp]: \"Arg x \\<notin> range Dummy\"  \"Upd x \\<notin> range Dummy\"   \"Alts e\\<^sub>1 e\\<^sub>2 \\<notin> range Dummy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Arg x \\<notin> range Dummy &&&\n    Upd x \\<notin> range Dummy &&&\n    Alts e\\<^sub>1 e\\<^sub>2 \\<notin> range Dummy", "by auto"], ["", "lemma dummy_stack_balanced:\n  assumes \"set S \\<subseteq> Dummy ` UNIV\"\n  assumes \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>* (\\<Delta>, z, S)\"\n  obtains T where \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T.\n        (\\<Gamma>, e,\n         S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z,\n                      S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>T.\n        (\\<Gamma>, e,\n         S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z,\n                      S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from build_trace[OF assms(2)]"], ["proof (chain)\npicking this:\n  \\<exists>T.\n     (\\<Gamma>, e,\n      S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)", "obtain T where \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\""], ["proof (prove)\nusing this:\n  \\<exists>T.\n     (\\<Gamma>, e,\n      S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        (\\<Gamma>, e,\n         S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z,\n              S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        (\\<Gamma>, e,\n         S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z,\n                      S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        (\\<Gamma>, e,\n         S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z,\n                      S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "hence \"\\<forall> c'\\<in>set T. stack (\\<Gamma>, e, S) \\<lesssim> stack c'\""], ["proof (prove)\nusing this:\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. \\<forall>c'\\<in>set T. stack (\\<Gamma>, e, S) \\<lesssim> stack c'", "by (rule conjunct1[OF traces_list_all])\n       (auto elim: step.cases simp add: dummy_stack_extended[OF \\<open>set S \\<subseteq> Dummy ` UNIV\\<close>])"], ["proof (state)\nthis:\n  \\<forall>c'\\<in>set T. stack (\\<Gamma>, e, S) \\<lesssim> stack c'\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        (\\<Gamma>, e,\n         S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z,\n                      S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n  \\<forall>c'\\<in>set T. stack (\\<Gamma>, e, S) \\<lesssim> stack c'", "have \"(\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\""], ["proof (prove)\nusing this:\n  (\\<Gamma>, e, S) \\<Rightarrow>\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n  \\<forall>c'\\<in>set T. stack (\\<Gamma>, e, S) \\<lesssim> stack c'\n\ngoal (1 subgoal):\n 1. (\\<Gamma>, e,\n     S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)", "by (rule balI) simp"], ["proof (state)\nthis:\n  (\\<Gamma>, e,\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        (\\<Gamma>, e,\n         S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z,\n                      S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Gamma>, e,\n   S) \\<Rightarrow>\\<^sup>b\\<^sup>*\\<^bsub>T\\<^esub> (\\<Delta>, z, S)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}