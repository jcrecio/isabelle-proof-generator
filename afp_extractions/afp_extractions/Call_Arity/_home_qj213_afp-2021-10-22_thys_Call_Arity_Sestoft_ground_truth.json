{"file_name": "/home/qj213/afp-2021-10-22/thys/Call_Arity/Sestoft.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Call_Arity", "problem_names": ["lemma SmartLet_stepI:\n   \"atom ` domA \\<Delta> \\<sharp>* \\<Gamma> \\<Longrightarrow> atom ` domA \\<Delta> \\<sharp>* S \\<Longrightarrow> (\\<Gamma>, SmartLet \\<Delta> e, S) \\<Rightarrow>\\<^sup>*  (\\<Delta>@\\<Gamma>, e , S)\"", "lemma lambda_var: \"map_of \\<Gamma> x = Some e \\<Longrightarrow> isVal e  \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>* ((x,e) # delete x \\<Gamma>, e , S)\"", "lemma let\\<^sub>1_closed:\n  assumes \"closed (\\<Gamma>, Let \\<Delta> e, S)\"\n  assumes \"domA \\<Delta> \\<inter> domA \\<Gamma> = {}\"\n  assumes \"domA \\<Delta> \\<inter> upds S = {}\"\n  shows \"(\\<Gamma>, Let \\<Delta> e, S) \\<Rightarrow> (\\<Delta>@\\<Gamma>, e , S)\"", "lemma step_invariant_induction[consumes 4, case_names app\\<^sub>1 app\\<^sub>2 thunk lamvar var\\<^sub>2 let\\<^sub>1 if\\<^sub>1 if\\<^sub>2 refl trans]:\n  assumes \"c \\<Rightarrow>\\<^sup>* c'\"\n  assumes \"\\<not> boring_step c'\"\n  assumes \"invariant (\\<Rightarrow>) I\"\n  assumes \"I c\"\n  assumes app\\<^sub>1:  \"\\<And> \\<Gamma> e x S . I (\\<Gamma>, App e x, S) \\<Longrightarrow> P (\\<Gamma>, App e x, S)  (\\<Gamma>, e , Arg x # S)\"\n  assumes app\\<^sub>2:  \"\\<And> \\<Gamma> y e x S . I (\\<Gamma>, Lam [y]. e, Arg x # S) \\<Longrightarrow> P (\\<Gamma>, Lam [y]. e, Arg x # S) (\\<Gamma>, e[y ::= x] , S)\"\n  assumes thunk:  \"\\<And> \\<Gamma> x e S . map_of \\<Gamma> x = Some e \\<Longrightarrow> \\<not> isVal e \\<Longrightarrow> I (\\<Gamma>, Var x, S) \\<Longrightarrow>  P (\\<Gamma>, Var x, S) (delete x \\<Gamma>, e , Upd x # S)\"\n  assumes lamvar:  \"\\<And> \\<Gamma> x e S . map_of \\<Gamma> x = Some e \\<Longrightarrow> isVal e \\<Longrightarrow> I (\\<Gamma>, Var x, S) \\<Longrightarrow> P (\\<Gamma>, Var x, S) ((x,e) # delete x \\<Gamma>, e , S)\"\n  assumes var\\<^sub>2:  \"\\<And> \\<Gamma> x e S . x \\<notin> domA \\<Gamma> \\<Longrightarrow> isVal e \\<Longrightarrow> I (\\<Gamma>, e, Upd x # S) \\<Longrightarrow> P (\\<Gamma>, e, Upd x # S) ((x,e)# \\<Gamma>, e , S)\"\n  assumes let\\<^sub>1:  \"\\<And> \\<Delta> \\<Gamma> e S . atom ` domA \\<Delta> \\<sharp>* \\<Gamma> \\<Longrightarrow> atom ` domA \\<Delta> \\<sharp>* S \\<Longrightarrow> I (\\<Gamma>, Let \\<Delta> e, S) \\<Longrightarrow> P (\\<Gamma>, Let \\<Delta> e, S) (\\<Delta>@\\<Gamma>, e, S)\"\n  assumes if\\<^sub>1:   \"\\<And>\\<Gamma> scrut e1 e2 S. I  (\\<Gamma>, scrut ? e1 : e2, S) \\<Longrightarrow> P (\\<Gamma>, scrut ? e1 : e2, S) (\\<Gamma>, scrut, Alts e1 e2 # S)\"\n  assumes if\\<^sub>2:   \"\\<And>\\<Gamma> b e1 e2 S. I  (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Longrightarrow> P (\\<Gamma>, Bool b, Alts e1 e2 # S) (\\<Gamma>, if b then e1 else e2, S)\"\n  assumes refl: \"\\<And> c. P c c\"\n  assumes trans[trans]: \"\\<And> c c' c''. c \\<Rightarrow>\\<^sup>* c' \\<Longrightarrow> c' \\<Rightarrow>\\<^sup>* c'' \\<Longrightarrow> P c c' \\<Longrightarrow> P c' c'' \\<Longrightarrow> P c c''\"\n  shows \"P c c'\"", "lemma step_induction[consumes 2, case_names app\\<^sub>1 app\\<^sub>2 thunk lamvar var\\<^sub>2 let\\<^sub>1 if\\<^sub>1 if\\<^sub>2 refl trans]:\n  assumes \"c \\<Rightarrow>\\<^sup>* c'\"\n  assumes \"\\<not> boring_step c'\"\n  assumes app\\<^sub>1:  \"\\<And> \\<Gamma> e x S . P (\\<Gamma>, App e x, S)  (\\<Gamma>, e , Arg x # S)\"\n  assumes app\\<^sub>2:  \"\\<And> \\<Gamma> y e x S . P (\\<Gamma>, Lam [y]. e, Arg x # S) (\\<Gamma>, e[y ::= x] , S)\"\n  assumes thunk:  \"\\<And> \\<Gamma> x e S . map_of \\<Gamma> x = Some e \\<Longrightarrow> \\<not> isVal e \\<Longrightarrow> P (\\<Gamma>, Var x, S) (delete x \\<Gamma>, e , Upd x # S)\"\n  assumes lamvar:  \"\\<And> \\<Gamma> x e S . map_of \\<Gamma> x = Some e \\<Longrightarrow> isVal e \\<Longrightarrow> P (\\<Gamma>, Var x, S) ((x,e) # delete x \\<Gamma>, e , S)\"\n  assumes var\\<^sub>2:  \"\\<And> \\<Gamma> x e S . x \\<notin> domA \\<Gamma> \\<Longrightarrow> isVal e \\<Longrightarrow> P (\\<Gamma>, e, Upd x # S) ((x,e)# \\<Gamma>, e , S)\"\n  assumes let\\<^sub>1:  \"\\<And> \\<Delta> \\<Gamma> e S . atom ` domA \\<Delta> \\<sharp>* \\<Gamma> \\<Longrightarrow> atom ` domA \\<Delta> \\<sharp>* S \\<Longrightarrow> P (\\<Gamma>, Let \\<Delta> e, S) (\\<Delta>@\\<Gamma>, e, S)\"\n  assumes if\\<^sub>1:   \"\\<And>\\<Gamma> scrut e1 e2 S. P (\\<Gamma>, scrut ? e1 : e2, S) (\\<Gamma>, scrut, Alts e1 e2 # S)\"\n  assumes if\\<^sub>2:   \"\\<And>\\<Gamma> b e1 e2 S. P (\\<Gamma>, Bool b, Alts e1 e2 # S) (\\<Gamma>, if b then e1 else e2, S)\"\n  assumes refl: \"\\<And> c. P c c\"\n  assumes trans[trans]: \"\\<And> c c' c''. c \\<Rightarrow>\\<^sup>* c' \\<Longrightarrow> c' \\<Rightarrow>\\<^sup>* c'' \\<Longrightarrow> P c c' \\<Longrightarrow> P c' c'' \\<Longrightarrow> P c c''\"\n  shows \"P c c'\"", "lemma step_eqvt[eqvt]: \"step x y \\<Longrightarrow> step (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> y)\"", "lemma closed_invariant:\n  \"invariant step closed\"", "lemma heap_upds_ok_invariant:\n  \"invariant step heap_upds_ok_conf\""], "translations": [["", "lemma SmartLet_stepI:\n   \"atom ` domA \\<Delta> \\<sharp>* \\<Gamma> \\<Longrightarrow> atom ` domA \\<Delta> \\<sharp>* S \\<Longrightarrow> (\\<Gamma>, SmartLet \\<Delta> e, S) \\<Rightarrow>\\<^sup>*  (\\<Delta>@\\<Gamma>, e , S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n     atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n    \\<Longrightarrow> (\\<Gamma>, SmartLet \\<Delta> e,\n                       S) \\<Rightarrow>\\<^sup>*\n                      (\\<Delta> @ \\<Gamma>, e, S)", "unfolding SmartLet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n     atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n    \\<Longrightarrow> (\\<Gamma>,\n                       if \\<Delta> = [] then e else Let \\<Delta> e,\n                       S) \\<Rightarrow>\\<^sup>*\n                      (\\<Delta> @ \\<Gamma>, e, S)", "by (auto intro: let\\<^sub>1)"], ["", "lemma lambda_var: \"map_of \\<Gamma> x = Some e \\<Longrightarrow> isVal e  \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>* ((x,e) # delete x \\<Gamma>, e , S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>map_of \\<Gamma> x = Some e; isVal e\\<rbrakk>\n    \\<Longrightarrow> (\\<Gamma>, Var x, S) \\<Rightarrow>\\<^sup>*\n                      ((x, e) # delete x \\<Gamma>, e, S)", "by (rule rtranclp_trans[OF r_into_rtranclp r_into_rtranclp])\n     (auto intro: var\\<^sub>1 var\\<^sub>2)"], ["", "lemma let\\<^sub>1_closed:\n  assumes \"closed (\\<Gamma>, Let \\<Delta> e, S)\"\n  assumes \"domA \\<Delta> \\<inter> domA \\<Gamma> = {}\"\n  assumes \"domA \\<Delta> \\<inter> upds S = {}\"\n  shows \"(\\<Gamma>, Let \\<Delta> e, S) \\<Rightarrow> (\\<Delta>@\\<Gamma>, e , S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>, Let \\<Delta> e, S) \\<Rightarrow> (\\<Delta> @ \\<Gamma>, e, S)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. atom ` domA \\<Delta> \\<sharp>* \\<Gamma>\n 2. atom ` domA \\<Delta> \\<sharp>* S", "from \\<open>domA \\<Delta> \\<inter> domA \\<Gamma> = {}\\<close> and \\<open>domA \\<Delta> \\<inter> upds S = {}\\<close>"], ["proof (chain)\npicking this:\n  domA \\<Delta> \\<inter> domA \\<Gamma> = {}\n  domA \\<Delta> \\<inter> upds S = {}", "have \"domA \\<Delta> \\<inter> (domA \\<Gamma> \\<union> upds S) = {}\""], ["proof (prove)\nusing this:\n  domA \\<Delta> \\<inter> domA \\<Gamma> = {}\n  domA \\<Delta> \\<inter> upds S = {}\n\ngoal (1 subgoal):\n 1. domA \\<Delta> \\<inter> (domA \\<Gamma> \\<union> upds S) = {}", "by auto"], ["proof (state)\nthis:\n  domA \\<Delta> \\<inter> (domA \\<Gamma> \\<union> upds S) = {}\n\ngoal (2 subgoals):\n 1. atom ` domA \\<Delta> \\<sharp>* \\<Gamma>\n 2. atom ` domA \\<Delta> \\<sharp>* S", "with \\<open>closed _\\<close>"], ["proof (chain)\npicking this:\n  closed (\\<Gamma>, Let \\<Delta> e, S)\n  domA \\<Delta> \\<inter> (domA \\<Gamma> \\<union> upds S) = {}", "have \"domA \\<Delta> \\<inter> fv (\\<Gamma>, S) = {}\""], ["proof (prove)\nusing this:\n  closed (\\<Gamma>, Let \\<Delta> e, S)\n  domA \\<Delta> \\<inter> (domA \\<Gamma> \\<union> upds S) = {}\n\ngoal (1 subgoal):\n 1. domA \\<Delta> \\<inter> fv (\\<Gamma>, S) = {}", "by auto"], ["proof (state)\nthis:\n  domA \\<Delta> \\<inter> fv (\\<Gamma>, S) = {}\n\ngoal (2 subgoals):\n 1. atom ` domA \\<Delta> \\<sharp>* \\<Gamma>\n 2. atom ` domA \\<Delta> \\<sharp>* S", "hence \"atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, S)\""], ["proof (prove)\nusing this:\n  domA \\<Delta> \\<inter> fv (\\<Gamma>, S) = {}\n\ngoal (1 subgoal):\n 1. atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, S)", "by (auto simp add: fresh_star_def fv_def fresh_def)"], ["proof (state)\nthis:\n  atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, S)\n\ngoal (2 subgoals):\n 1. atom ` domA \\<Delta> \\<sharp>* \\<Gamma>\n 2. atom ` domA \\<Delta> \\<sharp>* S", "thus \"atom` domA \\<Delta> \\<sharp>* \\<Gamma>\" and \"atom ` domA \\<Delta> \\<sharp>* S\""], ["proof (prove)\nusing this:\n  atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, S)\n\ngoal (1 subgoal):\n 1. atom ` domA \\<Delta> \\<sharp>* \\<Gamma> &&&\n    atom ` domA \\<Delta> \\<sharp>* S", "by (auto simp add: fresh_star_Pair)"], ["proof (state)\nthis:\n  atom ` domA \\<Delta> \\<sharp>* \\<Gamma>\n  atom ` domA \\<Delta> \\<sharp>* S\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>An induction rule that skips the annoying case of a lambda taken off the heap\\<close>"], ["", "lemma step_invariant_induction[consumes 4, case_names app\\<^sub>1 app\\<^sub>2 thunk lamvar var\\<^sub>2 let\\<^sub>1 if\\<^sub>1 if\\<^sub>2 refl trans]:\n  assumes \"c \\<Rightarrow>\\<^sup>* c'\"\n  assumes \"\\<not> boring_step c'\"\n  assumes \"invariant (\\<Rightarrow>) I\"\n  assumes \"I c\"\n  assumes app\\<^sub>1:  \"\\<And> \\<Gamma> e x S . I (\\<Gamma>, App e x, S) \\<Longrightarrow> P (\\<Gamma>, App e x, S)  (\\<Gamma>, e , Arg x # S)\"\n  assumes app\\<^sub>2:  \"\\<And> \\<Gamma> y e x S . I (\\<Gamma>, Lam [y]. e, Arg x # S) \\<Longrightarrow> P (\\<Gamma>, Lam [y]. e, Arg x # S) (\\<Gamma>, e[y ::= x] , S)\"\n  assumes thunk:  \"\\<And> \\<Gamma> x e S . map_of \\<Gamma> x = Some e \\<Longrightarrow> \\<not> isVal e \\<Longrightarrow> I (\\<Gamma>, Var x, S) \\<Longrightarrow>  P (\\<Gamma>, Var x, S) (delete x \\<Gamma>, e , Upd x # S)\"\n  assumes lamvar:  \"\\<And> \\<Gamma> x e S . map_of \\<Gamma> x = Some e \\<Longrightarrow> isVal e \\<Longrightarrow> I (\\<Gamma>, Var x, S) \\<Longrightarrow> P (\\<Gamma>, Var x, S) ((x,e) # delete x \\<Gamma>, e , S)\"\n  assumes var\\<^sub>2:  \"\\<And> \\<Gamma> x e S . x \\<notin> domA \\<Gamma> \\<Longrightarrow> isVal e \\<Longrightarrow> I (\\<Gamma>, e, Upd x # S) \\<Longrightarrow> P (\\<Gamma>, e, Upd x # S) ((x,e)# \\<Gamma>, e , S)\"\n  assumes let\\<^sub>1:  \"\\<And> \\<Delta> \\<Gamma> e S . atom ` domA \\<Delta> \\<sharp>* \\<Gamma> \\<Longrightarrow> atom ` domA \\<Delta> \\<sharp>* S \\<Longrightarrow> I (\\<Gamma>, Let \\<Delta> e, S) \\<Longrightarrow> P (\\<Gamma>, Let \\<Delta> e, S) (\\<Delta>@\\<Gamma>, e, S)\"\n  assumes if\\<^sub>1:   \"\\<And>\\<Gamma> scrut e1 e2 S. I  (\\<Gamma>, scrut ? e1 : e2, S) \\<Longrightarrow> P (\\<Gamma>, scrut ? e1 : e2, S) (\\<Gamma>, scrut, Alts e1 e2 # S)\"\n  assumes if\\<^sub>2:   \"\\<And>\\<Gamma> b e1 e2 S. I  (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Longrightarrow> P (\\<Gamma>, Bool b, Alts e1 e2 # S) (\\<Gamma>, if b then e1 else e2, S)\"\n  assumes refl: \"\\<And> c. P c c\"\n  assumes trans[trans]: \"\\<And> c c' c''. c \\<Rightarrow>\\<^sup>* c' \\<Longrightarrow> c' \\<Rightarrow>\\<^sup>* c'' \\<Longrightarrow> P c c' \\<Longrightarrow> P c' c'' \\<Longrightarrow> P c c''\"\n  shows \"P c c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P c c'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P c c'", "from assms(1,3,4)"], ["proof (chain)\npicking this:\n  c \\<Rightarrow>\\<^sup>* c'\n  invariant (\\<Rightarrow>) I\n  I c", "have \"P c c' \\<or> (boring_step c' \\<and> (\\<forall> c''. c' \\<Rightarrow> c'' \\<longrightarrow> P c c''))\""], ["proof (prove)\nusing this:\n  c \\<Rightarrow>\\<^sup>* c'\n  invariant (\\<Rightarrow>) I\n  I c\n\ngoal (1 subgoal):\n 1. P c c' \\<or>\n    boring_step c' \\<and>\n    (\\<forall>c''. c' \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "proof(induction rule: rtranclp_invariant_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. P c c \\<or>\n    boring_step c \\<and>\n    (\\<forall>c''. c \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>y z.\n       \\<lbrakk>c \\<Rightarrow>\\<^sup>* y; y \\<Rightarrow> z; I y; I z;\n        P c y \\<or>\n        boring_step y \\<and>\n        (\\<forall>c''.\n            y \\<Rightarrow> c'' \\<longrightarrow> P c c'')\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. P c c \\<or>\n    boring_step c \\<and>\n    (\\<forall>c''. c \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>y z.\n       \\<lbrakk>c \\<Rightarrow>\\<^sup>* y; y \\<Rightarrow> z; I y; I z;\n        P c y \\<or>\n        boring_step y \\<and>\n        (\\<forall>c''.\n            y \\<Rightarrow> c'' \\<longrightarrow> P c c'')\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "have \"P c c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P c c", "by (rule refl)"], ["proof (state)\nthis:\n  P c c\n\ngoal (2 subgoals):\n 1. P c c \\<or>\n    boring_step c \\<and>\n    (\\<forall>c''. c \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>y z.\n       \\<lbrakk>c \\<Rightarrow>\\<^sup>* y; y \\<Rightarrow> z; I y; I z;\n        P c y \\<or>\n        boring_step y \\<and>\n        (\\<forall>c''.\n            y \\<Rightarrow> c'' \\<longrightarrow> P c c'')\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "thus ?case"], ["proof (prove)\nusing this:\n  P c c\n\ngoal (1 subgoal):\n 1. P c c \\<or>\n    boring_step c \\<and>\n    (\\<forall>c''. c \\<Rightarrow> c'' \\<longrightarrow> P c c'')", ".."], ["proof (state)\nthis:\n  P c c \\<or>\n  boring_step c \\<and>\n  (\\<forall>c''. c \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>c \\<Rightarrow>\\<^sup>* y; y \\<Rightarrow> z; I y; I z;\n        P c y \\<or>\n        boring_step y \\<and>\n        (\\<forall>c''.\n            y \\<Rightarrow> c'' \\<longrightarrow> P c c'')\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>c \\<Rightarrow>\\<^sup>* y; y \\<Rightarrow> z; I y; I z;\n        P c y \\<or>\n        boring_step y \\<and>\n        (\\<forall>c''.\n            y \\<Rightarrow> c'' \\<longrightarrow> P c c'')\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "case (step y z)"], ["proof (state)\nthis:\n  c \\<Rightarrow>\\<^sup>* y\n  y \\<Rightarrow> z\n  I y\n  I z\n  P c y \\<or>\n  boring_step y \\<and>\n  (\\<forall>c''. y \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>c \\<Rightarrow>\\<^sup>* y; y \\<Rightarrow> z; I y; I z;\n        P c y \\<or>\n        boring_step y \\<and>\n        (\\<forall>c''.\n            y \\<Rightarrow> c'' \\<longrightarrow> P c c'')\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "from step(5)"], ["proof (chain)\npicking this:\n  P c y \\<or>\n  boring_step y \\<and>\n  (\\<forall>c''. y \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "show ?case"], ["proof (prove)\nusing this:\n  P c y \\<or>\n  boring_step y \\<and>\n  (\\<forall>c''. y \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (1 subgoal):\n 1. P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. P c y \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. boring_step y \\<and>\n    (\\<forall>c''.\n        y \\<Rightarrow> c'' \\<longrightarrow> P c c'') \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "assume \"P c y\""], ["proof (state)\nthis:\n  P c y\n\ngoal (2 subgoals):\n 1. P c y \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. boring_step y \\<and>\n    (\\<forall>c''.\n        y \\<Rightarrow> c'' \\<longrightarrow> P c c'') \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "note t = trans[OF \\<open>c \\<Rightarrow>\\<^sup>* y\\<close> r_into_rtranclp[where r = step, OF \\<open>y \\<Rightarrow> z\\<close>]]"], ["proof (state)\nthis:\n  \\<lbrakk>P c y; P y z\\<rbrakk> \\<Longrightarrow> P c z\n\ngoal (2 subgoals):\n 1. P c y \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. boring_step y \\<and>\n    (\\<forall>c''.\n        y \\<Rightarrow> c'' \\<longrightarrow> P c c'') \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "from \\<open>y \\<Rightarrow> z\\<close>"], ["proof (chain)\npicking this:\n  y \\<Rightarrow> z", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<Rightarrow> z\n\ngoal (1 subgoal):\n 1. P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "proof (cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> e x S.\n       \\<lbrakk>y = (\\<Gamma>, App e x, S);\n        z = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> ya e x S.\n       \\<lbrakk>y = (\\<Gamma>, Lam [ya]. e, Arg x # S);\n        z = (\\<Gamma>, e[ya::=x], S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Gamma> x e S.\n       \\<lbrakk>y = (\\<Gamma>, Var x, S);\n        z = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 5. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 6. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 7. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "case app\\<^sub>1"], ["proof (state)\nthis:\n  y = (\\<Gamma>_, App e_ x_, S_)\n  z = (\\<Gamma>_, e_, Arg x_ # S_)\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> e x S.\n       \\<lbrakk>y = (\\<Gamma>, App e x, S);\n        z = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> ya e x S.\n       \\<lbrakk>y = (\\<Gamma>, Lam [ya]. e, Arg x # S);\n        z = (\\<Gamma>, e[ya::=x], S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Gamma> x e S.\n       \\<lbrakk>y = (\\<Gamma>, Var x, S);\n        z = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 5. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 6. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 7. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "hence \"P y z\""], ["proof (prove)\nusing this:\n  y = (\\<Gamma>_, App e_ x_, S_)\n  z = (\\<Gamma>_, e_, Arg x_ # S_)\n\ngoal (1 subgoal):\n 1. P y z", "using assms(5) \\<open>I y\\<close>"], ["proof (prove)\nusing this:\n  y = (\\<Gamma>_, App e_ x_, S_)\n  z = (\\<Gamma>_, e_, Arg x_ # S_)\n  I (?\\<Gamma>, App ?e ?x, ?S) \\<Longrightarrow>\n  P (?\\<Gamma>, App ?e ?x, ?S) (?\\<Gamma>, ?e, Arg ?x # ?S)\n  I y\n\ngoal (1 subgoal):\n 1. P y z", "by metis"], ["proof (state)\nthis:\n  P y z\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> e x S.\n       \\<lbrakk>y = (\\<Gamma>, App e x, S);\n        z = (\\<Gamma>, e, Arg x # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> ya e x S.\n       \\<lbrakk>y = (\\<Gamma>, Lam [ya]. e, Arg x # S);\n        z = (\\<Gamma>, e[ya::=x], S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Gamma> x e S.\n       \\<lbrakk>y = (\\<Gamma>, Var x, S);\n        z = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 5. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 6. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 7. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "with \\<open>P c y\\<close>"], ["proof (chain)\npicking this:\n  P c y\n  P y z", "show ?thesis"], ["proof (prove)\nusing this:\n  P c y\n  P y z\n\ngoal (1 subgoal):\n 1. P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "by (metis t)"], ["proof (state)\nthis:\n  P c z \\<or>\n  boring_step z \\<and>\n  (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> ya e x S.\n       \\<lbrakk>y = (\\<Gamma>, Lam [ya]. e, Arg x # S);\n        z = (\\<Gamma>, e[ya::=x], S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> x e S.\n       \\<lbrakk>y = (\\<Gamma>, Var x, S);\n        z = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 5. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 6. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> ya e x S.\n       \\<lbrakk>y = (\\<Gamma>, Lam [ya]. e, Arg x # S);\n        z = (\\<Gamma>, e[ya::=x], S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> x e S.\n       \\<lbrakk>y = (\\<Gamma>, Var x, S);\n        z = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 5. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 6. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "case app\\<^sub>2"], ["proof (state)\nthis:\n  y = (\\<Gamma>_, Lam [y_]. e_, Arg x_ # S_)\n  z = (\\<Gamma>_, e_[y_::=x_], S_)\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> ya e x S.\n       \\<lbrakk>y = (\\<Gamma>, Lam [ya]. e, Arg x # S);\n        z = (\\<Gamma>, e[ya::=x], S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> x e S.\n       \\<lbrakk>y = (\\<Gamma>, Var x, S);\n        z = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 5. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 6. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "hence \"P y z\""], ["proof (prove)\nusing this:\n  y = (\\<Gamma>_, Lam [y_]. e_, Arg x_ # S_)\n  z = (\\<Gamma>_, e_[y_::=x_], S_)\n\ngoal (1 subgoal):\n 1. P y z", "using assms(6) \\<open>I y\\<close>"], ["proof (prove)\nusing this:\n  y = (\\<Gamma>_, Lam [y_]. e_, Arg x_ # S_)\n  z = (\\<Gamma>_, e_[y_::=x_], S_)\n  I (?\\<Gamma>, Lam [?y]. ?e, Arg ?x # ?S) \\<Longrightarrow>\n  P (?\\<Gamma>, Lam [?y]. ?e, Arg ?x # ?S) (?\\<Gamma>, ?e[?y::=?x], ?S)\n  I y\n\ngoal (1 subgoal):\n 1. P y z", "by metis"], ["proof (state)\nthis:\n  P y z\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> ya e x S.\n       \\<lbrakk>y = (\\<Gamma>, Lam [ya]. e, Arg x # S);\n        z = (\\<Gamma>, e[ya::=x], S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> x e S.\n       \\<lbrakk>y = (\\<Gamma>, Var x, S);\n        z = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 5. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 6. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "with \\<open>P c y\\<close>"], ["proof (chain)\npicking this:\n  P c y\n  P y z", "show ?thesis"], ["proof (prove)\nusing this:\n  P c y\n  P y z\n\ngoal (1 subgoal):\n 1. P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "by (metis t)"], ["proof (state)\nthis:\n  P c z \\<or>\n  boring_step z \\<and>\n  (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> x e S.\n       \\<lbrakk>y = (\\<Gamma>, Var x, S);\n        z = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 5. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> x e S.\n       \\<lbrakk>y = (\\<Gamma>, Var x, S);\n        z = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 5. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "case (var\\<^sub>1 \\<Gamma> x e S)"], ["proof (state)\nthis:\n  y = (\\<Gamma>, Var x, S)\n  z = (delete x \\<Gamma>, e, Upd x # S)\n  map_of \\<Gamma> x = Some e\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> x e S.\n       \\<lbrakk>y = (\\<Gamma>, Var x, S);\n        z = (delete x \\<Gamma>, e, Upd x # S);\n        map_of \\<Gamma> x = Some e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 5. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "proof (cases \"isVal e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<not> isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "case False"], ["proof (state)\nthis:\n  \\<not> isVal e\n\ngoal (2 subgoals):\n 1. isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<not> isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "with var\\<^sub>1"], ["proof (chain)\npicking this:\n  y = (\\<Gamma>, Var x, S)\n  z = (delete x \\<Gamma>, e, Upd x # S)\n  map_of \\<Gamma> x = Some e\n  \\<not> isVal e", "have \"P y z\""], ["proof (prove)\nusing this:\n  y = (\\<Gamma>, Var x, S)\n  z = (delete x \\<Gamma>, e, Upd x # S)\n  map_of \\<Gamma> x = Some e\n  \\<not> isVal e\n\ngoal (1 subgoal):\n 1. P y z", "using assms(7) \\<open>I y\\<close>"], ["proof (prove)\nusing this:\n  y = (\\<Gamma>, Var x, S)\n  z = (delete x \\<Gamma>, e, Upd x # S)\n  map_of \\<Gamma> x = Some e\n  \\<not> isVal e\n  \\<lbrakk>map_of ?\\<Gamma> ?x = Some ?e; \\<not> isVal ?e;\n   I (?\\<Gamma>, Var ?x, ?S)\\<rbrakk>\n  \\<Longrightarrow> P (?\\<Gamma>, Var ?x, ?S)\n                     (delete ?x ?\\<Gamma>, ?e, Upd ?x # ?S)\n  I y\n\ngoal (1 subgoal):\n 1. P y z", "by metis"], ["proof (state)\nthis:\n  P y z\n\ngoal (2 subgoals):\n 1. isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<not> isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "with \\<open>P c y\\<close>"], ["proof (chain)\npicking this:\n  P c y\n  P y z", "show ?thesis"], ["proof (prove)\nusing this:\n  P c y\n  P y z\n\ngoal (1 subgoal):\n 1. P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "by (metis t)"], ["proof (state)\nthis:\n  P c z \\<or>\n  boring_step z \\<and>\n  (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (1 subgoal):\n 1. isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "case True"], ["proof (state)\nthis:\n  isVal e\n\ngoal (1 subgoal):\n 1. isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "have *: \"y \\<Rightarrow>\\<^sup>* ((x,e) # delete x \\<Gamma>, e , S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<Rightarrow>\\<^sup>* ((x, e) # delete x \\<Gamma>, e, S)", "using var\\<^sub>1 True lambda_var"], ["proof (prove)\nusing this:\n  y = (\\<Gamma>, Var x, S)\n  z = (delete x \\<Gamma>, e, Upd x # S)\n  map_of \\<Gamma> x = Some e\n  isVal e\n  \\<lbrakk>map_of ?\\<Gamma> ?x = Some ?e; isVal ?e\\<rbrakk>\n  \\<Longrightarrow> (?\\<Gamma>, Var ?x, ?S) \\<Rightarrow>\\<^sup>*\n                    ((?x, ?e) # delete ?x ?\\<Gamma>, ?e, ?S)\n\ngoal (1 subgoal):\n 1. y \\<Rightarrow>\\<^sup>* ((x, e) # delete x \\<Gamma>, e, S)", "by metis"], ["proof (state)\nthis:\n  y \\<Rightarrow>\\<^sup>* ((x, e) # delete x \\<Gamma>, e, S)\n\ngoal (1 subgoal):\n 1. isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "have \"boring_step (delete x \\<Gamma>, e, Upd x # S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boring_step (delete x \\<Gamma>, e, Upd x # S)", "using True"], ["proof (prove)\nusing this:\n  isVal e\n\ngoal (1 subgoal):\n 1. boring_step (delete x \\<Gamma>, e, Upd x # S)", ".."], ["proof (state)\nthis:\n  boring_step (delete x \\<Gamma>, e, Upd x # S)\n\ngoal (1 subgoal):\n 1. isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "moreover"], ["proof (state)\nthis:\n  boring_step (delete x \\<Gamma>, e, Upd x # S)\n\ngoal (1 subgoal):\n 1. isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "have \"P y ((x,e) # delete x \\<Gamma>, e , S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P y ((x, e) # delete x \\<Gamma>, e, S)", "using var\\<^sub>1 True assms(8) \\<open>I y\\<close>"], ["proof (prove)\nusing this:\n  y = (\\<Gamma>, Var x, S)\n  z = (delete x \\<Gamma>, e, Upd x # S)\n  map_of \\<Gamma> x = Some e\n  isVal e\n  \\<lbrakk>map_of ?\\<Gamma> ?x = Some ?e; isVal ?e;\n   I (?\\<Gamma>, Var ?x, ?S)\\<rbrakk>\n  \\<Longrightarrow> P (?\\<Gamma>, Var ?x, ?S)\n                     ((?x, ?e) # delete ?x ?\\<Gamma>, ?e, ?S)\n  I y\n\ngoal (1 subgoal):\n 1. P y ((x, e) # delete x \\<Gamma>, e, S)", "by metis"], ["proof (state)\nthis:\n  P y ((x, e) # delete x \\<Gamma>, e, S)\n\ngoal (1 subgoal):\n 1. isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "with \\<open>P c y\\<close>"], ["proof (chain)\npicking this:\n  P c y\n  P y ((x, e) # delete x \\<Gamma>, e, S)", "have \"P c ((x,e) # delete x \\<Gamma>, e , S)\""], ["proof (prove)\nusing this:\n  P c y\n  P y ((x, e) # delete x \\<Gamma>, e, S)\n\ngoal (1 subgoal):\n 1. P c ((x, e) # delete x \\<Gamma>, e, S)", "by (rule trans[OF \\<open>c \\<Rightarrow>\\<^sup>* y\\<close> *])"], ["proof (state)\nthis:\n  P c ((x, e) # delete x \\<Gamma>, e, S)\n\ngoal (1 subgoal):\n 1. isVal e \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "ultimately"], ["proof (chain)\npicking this:\n  boring_step (delete x \\<Gamma>, e, Upd x # S)\n  P c ((x, e) # delete x \\<Gamma>, e, S)", "show ?thesis"], ["proof (prove)\nusing this:\n  boring_step (delete x \\<Gamma>, e, Upd x # S)\n  P c ((x, e) # delete x \\<Gamma>, e, S)\n\ngoal (1 subgoal):\n 1. P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "using var\\<^sub>1(2,3) True"], ["proof (prove)\nusing this:\n  boring_step (delete x \\<Gamma>, e, Upd x # S)\n  P c ((x, e) # delete x \\<Gamma>, e, S)\n  z = (delete x \\<Gamma>, e, Upd x # S)\n  map_of \\<Gamma> x = Some e\n  isVal e\n\ngoal (1 subgoal):\n 1. P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "by (auto elim!: step.cases)"], ["proof (state)\nthis:\n  P c z \\<or>\n  boring_step z \\<and>\n  (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P c z \\<or>\n  boring_step z \\<and>\n  (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "case var\\<^sub>2"], ["proof (state)\nthis:\n  y = (\\<Gamma>_, e_, Upd x_ # S_)\n  z = ((x_, e_) # \\<Gamma>_, e_, S_)\n  x_ \\<notin> domA \\<Gamma>_\n  isVal e_\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "hence \"P y z\""], ["proof (prove)\nusing this:\n  y = (\\<Gamma>_, e_, Upd x_ # S_)\n  z = ((x_, e_) # \\<Gamma>_, e_, S_)\n  x_ \\<notin> domA \\<Gamma>_\n  isVal e_\n\ngoal (1 subgoal):\n 1. P y z", "using assms(9) \\<open>I y\\<close>"], ["proof (prove)\nusing this:\n  y = (\\<Gamma>_, e_, Upd x_ # S_)\n  z = ((x_, e_) # \\<Gamma>_, e_, S_)\n  x_ \\<notin> domA \\<Gamma>_\n  isVal e_\n  \\<lbrakk>?x \\<notin> domA ?\\<Gamma>; isVal ?e;\n   I (?\\<Gamma>, ?e, Upd ?x # ?S)\\<rbrakk>\n  \\<Longrightarrow> P (?\\<Gamma>, ?e, Upd ?x # ?S)\n                     ((?x, ?e) # ?\\<Gamma>, ?e, ?S)\n  I y\n\ngoal (1 subgoal):\n 1. P y z", "by metis"], ["proof (state)\nthis:\n  P y z\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>y = (\\<Gamma>, e, Upd x # S); z = ((x, e) # \\<Gamma>, e, S);\n        x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 4. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "with \\<open>P c y\\<close>"], ["proof (chain)\npicking this:\n  P c y\n  P y z", "show ?thesis"], ["proof (prove)\nusing this:\n  P c y\n  P y z\n\ngoal (1 subgoal):\n 1. P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "by (metis t)"], ["proof (state)\nthis:\n  P c z \\<or>\n  boring_step z \\<and>\n  (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "case let\\<^sub>1"], ["proof (state)\nthis:\n  y = (\\<Gamma>_, Let \\<Delta>_ e_, S_)\n  z = (\\<Delta>_ @ \\<Gamma>_, e_, S_)\n  atom ` domA \\<Delta>_ \\<sharp>* \\<Gamma>_\n  atom ` domA \\<Delta>_ \\<sharp>* S_\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "hence \"P y z\""], ["proof (prove)\nusing this:\n  y = (\\<Gamma>_, Let \\<Delta>_ e_, S_)\n  z = (\\<Delta>_ @ \\<Gamma>_, e_, S_)\n  atom ` domA \\<Delta>_ \\<sharp>* \\<Gamma>_\n  atom ` domA \\<Delta>_ \\<sharp>* S_\n\ngoal (1 subgoal):\n 1. P y z", "using assms(10) \\<open>I y\\<close>"], ["proof (prove)\nusing this:\n  y = (\\<Gamma>_, Let \\<Delta>_ e_, S_)\n  z = (\\<Delta>_ @ \\<Gamma>_, e_, S_)\n  atom ` domA \\<Delta>_ \\<sharp>* \\<Gamma>_\n  atom ` domA \\<Delta>_ \\<sharp>* S_\n  \\<lbrakk>atom ` domA ?\\<Delta> \\<sharp>* ?\\<Gamma>;\n   atom ` domA ?\\<Delta> \\<sharp>* ?S;\n   I (?\\<Gamma>, Let ?\\<Delta> ?e, ?S)\\<rbrakk>\n  \\<Longrightarrow> P (?\\<Gamma>, Let ?\\<Delta> ?e, ?S)\n                     (?\\<Delta> @ ?\\<Gamma>, ?e, ?S)\n  I y\n\ngoal (1 subgoal):\n 1. P y z", "by metis"], ["proof (state)\nthis:\n  P y z\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>y = (\\<Gamma>, Let \\<Delta> e, S);\n        z = (\\<Delta> @ \\<Gamma>, e, S);\n        atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "with \\<open>P c y\\<close>"], ["proof (chain)\npicking this:\n  P c y\n  P y z", "show ?thesis"], ["proof (prove)\nusing this:\n  P c y\n  P y z\n\ngoal (1 subgoal):\n 1. P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "by (metis t)"], ["proof (state)\nthis:\n  P c z \\<or>\n  boring_step z \\<and>\n  (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "case if\\<^sub>1"], ["proof (state)\nthis:\n  y = (\\<Gamma>_, scrut_ ? e1_ : e2_, S_)\n  z = (\\<Gamma>_, scrut_, Alts e1_ e2_ # S_)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "hence \"P y z\""], ["proof (prove)\nusing this:\n  y = (\\<Gamma>_, scrut_ ? e1_ : e2_, S_)\n  z = (\\<Gamma>_, scrut_, Alts e1_ e2_ # S_)\n\ngoal (1 subgoal):\n 1. P y z", "using assms(11) \\<open>I y\\<close>"], ["proof (prove)\nusing this:\n  y = (\\<Gamma>_, scrut_ ? e1_ : e2_, S_)\n  z = (\\<Gamma>_, scrut_, Alts e1_ e2_ # S_)\n  I (?\\<Gamma>, ?scrut ? ?e1.0 : ?e2.0, ?S) \\<Longrightarrow>\n  P (?\\<Gamma>, ?scrut ? ?e1.0 : ?e2.0, ?S)\n   (?\\<Gamma>, ?scrut, Alts ?e1.0 ?e2.0 # ?S)\n  I y\n\ngoal (1 subgoal):\n 1. P y z", "by metis"], ["proof (state)\nthis:\n  P y z\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, scrut ? e1 : e2, S);\n        z = (\\<Gamma>, scrut, Alts e1 e2 # S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n 2. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "with \\<open>P c y\\<close>"], ["proof (chain)\npicking this:\n  P c y\n  P y z", "show ?thesis"], ["proof (prove)\nusing this:\n  P c y\n  P y z\n\ngoal (1 subgoal):\n 1. P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "by (metis t)"], ["proof (state)\nthis:\n  P c z \\<or>\n  boring_step z \\<and>\n  (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "case if\\<^sub>2"], ["proof (state)\nthis:\n  y = (\\<Gamma>_, Bool b_, Alts e1_ e2_ # S_)\n  z = (\\<Gamma>_, if b_ then e1_ else e2_, S_)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "hence \"P y z\""], ["proof (prove)\nusing this:\n  y = (\\<Gamma>_, Bool b_, Alts e1_ e2_ # S_)\n  z = (\\<Gamma>_, if b_ then e1_ else e2_, S_)\n\ngoal (1 subgoal):\n 1. P y z", "using assms(12) \\<open>I y\\<close>"], ["proof (prove)\nusing this:\n  y = (\\<Gamma>_, Bool b_, Alts e1_ e2_ # S_)\n  z = (\\<Gamma>_, if b_ then e1_ else e2_, S_)\n  I (?\\<Gamma>, Bool ?b, Alts ?e1.0 ?e2.0 # ?S) \\<Longrightarrow>\n  P (?\\<Gamma>, Bool ?b, Alts ?e1.0 ?e2.0 # ?S)\n   (?\\<Gamma>, if ?b then ?e1.0 else ?e2.0, ?S)\n  I y\n\ngoal (1 subgoal):\n 1. P y z", "by metis"], ["proof (state)\nthis:\n  P y z\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> b e1 e2 S.\n       \\<lbrakk>y = (\\<Gamma>, Bool b, Alts e1 e2 # S);\n        z = (\\<Gamma>, if b then e1 else e2, S)\\<rbrakk>\n       \\<Longrightarrow> P c z \\<or>\n                         boring_step z \\<and>\n                         (\\<forall>c''.\n                             z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "with \\<open>P c y\\<close>"], ["proof (chain)\npicking this:\n  P c y\n  P y z", "show ?thesis"], ["proof (prove)\nusing this:\n  P c y\n  P y z\n\ngoal (1 subgoal):\n 1. P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "by (metis t)"], ["proof (state)\nthis:\n  P c z \\<or>\n  boring_step z \\<and>\n  (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P c z \\<or>\n  boring_step z \\<and>\n  (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (1 subgoal):\n 1. boring_step y \\<and>\n    (\\<forall>c''.\n        y \\<Rightarrow> c'' \\<longrightarrow> P c c'') \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. boring_step y \\<and>\n    (\\<forall>c''.\n        y \\<Rightarrow> c'' \\<longrightarrow> P c c'') \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "assume \"boring_step y \\<and> (\\<forall>c''. y \\<Rightarrow> c'' \\<longrightarrow> P c c'')\""], ["proof (state)\nthis:\n  boring_step y \\<and>\n  (\\<forall>c''. y \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (1 subgoal):\n 1. boring_step y \\<and>\n    (\\<forall>c''.\n        y \\<Rightarrow> c'' \\<longrightarrow> P c c'') \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "with \\<open>y \\<Rightarrow> z\\<close>"], ["proof (chain)\npicking this:\n  y \\<Rightarrow> z\n  boring_step y \\<and>\n  (\\<forall>c''. y \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "have \"P c z\""], ["proof (prove)\nusing this:\n  y \\<Rightarrow> z\n  boring_step y \\<and>\n  (\\<forall>c''. y \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (1 subgoal):\n 1. P c z", "by blast"], ["proof (state)\nthis:\n  P c z\n\ngoal (1 subgoal):\n 1. boring_step y \\<and>\n    (\\<forall>c''.\n        y \\<Rightarrow> c'' \\<longrightarrow> P c c'') \\<Longrightarrow>\n    P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "thus ?thesis"], ["proof (prove)\nusing this:\n  P c z\n\ngoal (1 subgoal):\n 1. P c z \\<or>\n    boring_step z \\<and>\n    (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')", ".."], ["proof (state)\nthis:\n  P c z \\<or>\n  boring_step z \\<and>\n  (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P c z \\<or>\n  boring_step z \\<and>\n  (\\<forall>c''. z \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P c c' \\<or>\n  boring_step c' \\<and>\n  (\\<forall>c''. c' \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (1 subgoal):\n 1. P c c'", "with assms(2)"], ["proof (chain)\npicking this:\n  \\<not> boring_step c'\n  P c c' \\<or>\n  boring_step c' \\<and>\n  (\\<forall>c''. c' \\<Rightarrow> c'' \\<longrightarrow> P c c'')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> boring_step c'\n  P c c' \\<or>\n  boring_step c' \\<and>\n  (\\<forall>c''. c' \\<Rightarrow> c'' \\<longrightarrow> P c c'')\n\ngoal (1 subgoal):\n 1. P c c'", "by auto"], ["proof (state)\nthis:\n  P c c'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_induction[consumes 2, case_names app\\<^sub>1 app\\<^sub>2 thunk lamvar var\\<^sub>2 let\\<^sub>1 if\\<^sub>1 if\\<^sub>2 refl trans]:\n  assumes \"c \\<Rightarrow>\\<^sup>* c'\"\n  assumes \"\\<not> boring_step c'\"\n  assumes app\\<^sub>1:  \"\\<And> \\<Gamma> e x S . P (\\<Gamma>, App e x, S)  (\\<Gamma>, e , Arg x # S)\"\n  assumes app\\<^sub>2:  \"\\<And> \\<Gamma> y e x S . P (\\<Gamma>, Lam [y]. e, Arg x # S) (\\<Gamma>, e[y ::= x] , S)\"\n  assumes thunk:  \"\\<And> \\<Gamma> x e S . map_of \\<Gamma> x = Some e \\<Longrightarrow> \\<not> isVal e \\<Longrightarrow> P (\\<Gamma>, Var x, S) (delete x \\<Gamma>, e , Upd x # S)\"\n  assumes lamvar:  \"\\<And> \\<Gamma> x e S . map_of \\<Gamma> x = Some e \\<Longrightarrow> isVal e \\<Longrightarrow> P (\\<Gamma>, Var x, S) ((x,e) # delete x \\<Gamma>, e , S)\"\n  assumes var\\<^sub>2:  \"\\<And> \\<Gamma> x e S . x \\<notin> domA \\<Gamma> \\<Longrightarrow> isVal e \\<Longrightarrow> P (\\<Gamma>, e, Upd x # S) ((x,e)# \\<Gamma>, e , S)\"\n  assumes let\\<^sub>1:  \"\\<And> \\<Delta> \\<Gamma> e S . atom ` domA \\<Delta> \\<sharp>* \\<Gamma> \\<Longrightarrow> atom ` domA \\<Delta> \\<sharp>* S \\<Longrightarrow> P (\\<Gamma>, Let \\<Delta> e, S) (\\<Delta>@\\<Gamma>, e, S)\"\n  assumes if\\<^sub>1:   \"\\<And>\\<Gamma> scrut e1 e2 S. P (\\<Gamma>, scrut ? e1 : e2, S) (\\<Gamma>, scrut, Alts e1 e2 # S)\"\n  assumes if\\<^sub>2:   \"\\<And>\\<Gamma> b e1 e2 S. P (\\<Gamma>, Bool b, Alts e1 e2 # S) (\\<Gamma>, if b then e1 else e2, S)\"\n  assumes refl: \"\\<And> c. P c c\"\n  assumes trans[trans]: \"\\<And> c c' c''. c \\<Rightarrow>\\<^sup>* c' \\<Longrightarrow> c' \\<Rightarrow>\\<^sup>* c'' \\<Longrightarrow> P c c' \\<Longrightarrow> P c' c'' \\<Longrightarrow> P c c''\"\n  shows \"P c c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P c c'", "by (rule step_invariant_induction[OF _ _ invariant_True, simplified, OF assms])"], ["", "subsubsection \\<open>Equivariance\\<close>"], ["", "lemma step_eqvt[eqvt]: \"step x y \\<Longrightarrow> step (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<Rightarrow> y \\<Longrightarrow>\n    \\<pi> \\<bullet> x \\<Rightarrow> \\<pi> \\<bullet> y", "apply (induction  rule: step.induct)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> e x S.\n       \\<pi> \\<bullet> (\\<Gamma>, App e x, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, e, Arg x # S)\n 2. \\<And>\\<Gamma> y e x S.\n       \\<pi> \\<bullet> (\\<Gamma>, Lam [y]. e, Arg x # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, e[y::=x], S)\n 3. \\<And>\\<Gamma> x e S.\n       map_of \\<Gamma> x = Some e \\<Longrightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, Var x, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (delete x \\<Gamma>, e, Upd x # S)\n 4. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> (\\<Gamma>, e,\n    Upd x # S) \\<Rightarrow>\n                         \\<pi> \\<bullet> ((x, e) # \\<Gamma>, e, S)\n 5. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> (\\<Gamma>, Let \\<Delta> e,\n    S) \\<Rightarrow>\n                         \\<pi> \\<bullet> (\\<Delta> @ \\<Gamma>, e, S)\n 6. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, scrut ? e1 : e2, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, scrut, Alts e1 e2 # S)\n 7. \\<And>\\<Gamma> b e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, if b then e1 else e2, S)", "apply (perm_simp, rule step.intros)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> y e x S.\n       \\<pi> \\<bullet> (\\<Gamma>, Lam [y]. e, Arg x # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, e[y::=x], S)\n 2. \\<And>\\<Gamma> x e S.\n       map_of \\<Gamma> x = Some e \\<Longrightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, Var x, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (delete x \\<Gamma>, e, Upd x # S)\n 3. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> (\\<Gamma>, e,\n    Upd x # S) \\<Rightarrow>\n                         \\<pi> \\<bullet> ((x, e) # \\<Gamma>, e, S)\n 4. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> (\\<Gamma>, Let \\<Delta> e,\n    S) \\<Rightarrow>\n                         \\<pi> \\<bullet> (\\<Delta> @ \\<Gamma>, e, S)\n 5. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, scrut ? e1 : e2, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, scrut, Alts e1 e2 # S)\n 6. \\<And>\\<Gamma> b e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, if b then e1 else e2, S)", "apply (perm_simp, rule step.intros)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> x e S.\n       map_of \\<Gamma> x = Some e \\<Longrightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, Var x, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (delete x \\<Gamma>, e, Upd x # S)\n 2. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> (\\<Gamma>, e,\n    Upd x # S) \\<Rightarrow>\n                         \\<pi> \\<bullet> ((x, e) # \\<Gamma>, e, S)\n 3. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> (\\<Gamma>, Let \\<Delta> e,\n    S) \\<Rightarrow>\n                         \\<pi> \\<bullet> (\\<Delta> @ \\<Gamma>, e, S)\n 4. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, scrut ? e1 : e2, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, scrut, Alts e1 e2 # S)\n 5. \\<And>\\<Gamma> b e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, if b then e1 else e2, S)", "apply (perm_simp, rule step.intros)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> x e S.\n       map_of \\<Gamma> x = Some e \\<Longrightarrow>\n       map_of (\\<pi> \\<bullet> \\<Gamma>) (\\<pi> \\<bullet> x) =\n       Some (\\<pi> \\<bullet> e)\n 2. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> (\\<Gamma>, e,\n    Upd x # S) \\<Rightarrow>\n                         \\<pi> \\<bullet> ((x, e) # \\<Gamma>, e, S)\n 3. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> (\\<Gamma>, Let \\<Delta> e,\n    S) \\<Rightarrow>\n                         \\<pi> \\<bullet> (\\<Delta> @ \\<Gamma>, e, S)\n 4. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, scrut ? e1 : e2, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, scrut, Alts e1 e2 # S)\n 5. \\<And>\\<Gamma> b e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, if b then e1 else e2, S)", "apply (rule permute_boolE[where p = \"-\\<pi>\"], simp add: pemute_minus_self)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> (\\<Gamma>, e,\n    Upd x # S) \\<Rightarrow>\n                         \\<pi> \\<bullet> ((x, e) # \\<Gamma>, e, S)\n 2. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> (\\<Gamma>, Let \\<Delta> e,\n    S) \\<Rightarrow>\n                         \\<pi> \\<bullet> (\\<Delta> @ \\<Gamma>, e, S)\n 3. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, scrut ? e1 : e2, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, scrut, Alts e1 e2 # S)\n 4. \\<And>\\<Gamma> b e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, if b then e1 else e2, S)", "apply (perm_simp, rule step.intros)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> x\n                         \\<notin> domA (\\<pi> \\<bullet> \\<Gamma>)\n 2. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> isVal (\\<pi> \\<bullet> e)\n 3. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> (\\<Gamma>, Let \\<Delta> e,\n    S) \\<Rightarrow>\n                         \\<pi> \\<bullet> (\\<Delta> @ \\<Gamma>, e, S)\n 4. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, scrut ? e1 : e2, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, scrut, Alts e1 e2 # S)\n 5. \\<And>\\<Gamma> b e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, if b then e1 else e2, S)", "apply (rule permute_boolE[where p = \"-\\<pi>\"], simp add: pemute_minus_self)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e S.\n       \\<lbrakk>x \\<notin> domA \\<Gamma>; isVal e\\<rbrakk>\n       \\<Longrightarrow> isVal (\\<pi> \\<bullet> e)\n 2. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> (\\<Gamma>, Let \\<Delta> e,\n    S) \\<Rightarrow>\n                         \\<pi> \\<bullet> (\\<Delta> @ \\<Gamma>, e, S)\n 3. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, scrut ? e1 : e2, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, scrut, Alts e1 e2 # S)\n 4. \\<And>\\<Gamma> b e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, if b then e1 else e2, S)", "apply (rule permute_boolE[where p = \"-\\<pi>\"], simp add: pemute_minus_self)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> \\<pi> \\<bullet> (\\<Gamma>, Let \\<Delta> e,\n    S) \\<Rightarrow>\n                         \\<pi> \\<bullet> (\\<Delta> @ \\<Gamma>, e, S)\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, scrut ? e1 : e2, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, scrut, Alts e1 e2 # S)\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, if b then e1 else e2, S)", "apply (perm_simp, rule step.intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> atom `\n                         domA\n                          (\\<pi> \\<bullet> \\<Delta>) \\<sharp>* (\\<pi> \\<bullet> \\<Gamma>)\n 2. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> atom `\n                         domA\n                          (\\<pi> \\<bullet> \\<Delta>) \\<sharp>* (\\<pi> \\<bullet> S)\n 3. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, scrut ? e1 : e2, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, scrut, Alts e1 e2 # S)\n 4. \\<And>\\<Gamma> b e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, if b then e1 else e2, S)", "apply (rule permute_boolE[where p = \"-\\<pi>\"], simp add: pemute_minus_self)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> S e.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* S\\<rbrakk>\n       \\<Longrightarrow> atom `\n                         domA\n                          (\\<pi> \\<bullet> \\<Delta>) \\<sharp>* (\\<pi> \\<bullet> S)\n 2. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, scrut ? e1 : e2, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, scrut, Alts e1 e2 # S)\n 3. \\<And>\\<Gamma> b e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, if b then e1 else e2, S)", "apply (rule permute_boolE[where p = \"-\\<pi>\"], simp add: pemute_minus_self)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> scrut e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, scrut ? e1 : e2, S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, scrut, Alts e1 e2 # S)\n 2. \\<And>\\<Gamma> b e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, if b then e1 else e2, S)", "apply (perm_simp, rule step.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> b e1 e2 S.\n       \\<pi> \\<bullet> (\\<Gamma>, Bool b, Alts e1 e2 # S) \\<Rightarrow>\n       \\<pi> \\<bullet> (\\<Gamma>, if b then e1 else e2, S)", "apply (perm_simp, rule step.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Invariants\\<close>"], ["", "lemma closed_invariant:\n  \"invariant step closed\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant (\\<Rightarrow>) closed", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<Rightarrow> y; closed x\\<rbrakk>\n       \\<Longrightarrow> closed y", "fix c c'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<Rightarrow> y; closed x\\<rbrakk>\n       \\<Longrightarrow> closed y", "assume \"c \\<Rightarrow> c'\" and \"closed c\""], ["proof (state)\nthis:\n  c \\<Rightarrow> c'\n  closed c\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<Rightarrow> y; closed x\\<rbrakk>\n       \\<Longrightarrow> closed y", "thus \"closed c'\""], ["proof (prove)\nusing this:\n  c \\<Rightarrow> c'\n  closed c\n\ngoal (1 subgoal):\n 1. closed c'", "by (induction rule: step.induct) (auto simp add: fv_subst_eq dest!: subsetD[OF fv_delete_subset] dest: subsetD[OF map_of_Some_fv_subset])"], ["proof (state)\nthis:\n  closed c'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_upds_ok_invariant:\n  \"invariant step heap_upds_ok_conf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant (\\<Rightarrow>) heap_upds_ok_conf", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<Rightarrow> y; heap_upds_ok_conf x\\<rbrakk>\n       \\<Longrightarrow> heap_upds_ok_conf y", "fix c c'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<Rightarrow> y; heap_upds_ok_conf x\\<rbrakk>\n       \\<Longrightarrow> heap_upds_ok_conf y", "assume \"c \\<Rightarrow> c'\" and \"heap_upds_ok_conf c\""], ["proof (state)\nthis:\n  c \\<Rightarrow> c'\n  heap_upds_ok_conf c\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<Rightarrow> y; heap_upds_ok_conf x\\<rbrakk>\n       \\<Longrightarrow> heap_upds_ok_conf y", "thus \"heap_upds_ok_conf c'\""], ["proof (prove)\nusing this:\n  c \\<Rightarrow> c'\n  heap_upds_ok_conf c\n\ngoal (1 subgoal):\n 1. heap_upds_ok_conf c'", "by (induction rule: step.induct) auto"], ["proof (state)\nthis:\n  heap_upds_ok_conf c'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}