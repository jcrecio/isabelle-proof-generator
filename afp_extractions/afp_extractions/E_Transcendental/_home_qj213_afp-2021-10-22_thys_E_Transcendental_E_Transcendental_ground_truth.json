{"file_name": "/home/qj213/afp-2021-10-22/thys/E_Transcendental/E_Transcendental.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/E_Transcendental", "problem_names": ["lemma fact_dvd_pochhammer:\n  assumes \"m \\<le> n + 1\"\n  shows   \"fact m dvd pochhammer (int n - int m + 1) m\"", "lemma of_nat_eq_1_iff [simp]: \"of_nat x = (1 :: 'a :: semiring_char_0) \\<longleftrightarrow> x = 1\"", "lemma prime_elem_int_not_dvd_neg1_power:\n  \"prime_elem (p :: int) \\<Longrightarrow> \\<not>p dvd (-1) ^ n\"", "lemma nat_fact [simp]: \"nat (fact n) = fact n\"", "lemma prime_dvd_fact_iff_int:\n  \"p dvd fact n \\<longleftrightarrow> p \\<le> int n\" if \"prime p\"", "lemma filterlim_minus_nat_at_top:\n  \"filterlim (\\<lambda>n. n - k :: nat) at_top at_top\"", "lemma power_over_fact_tendsto_0:\n  \"(\\<lambda>n. (x :: real) ^ n / fact n) \\<longlonglongrightarrow> 0\"", "lemma power_over_fact_tendsto_0':\n  \"(\\<lambda>n. c * (x :: real) ^ n / fact n) \\<longlonglongrightarrow> 0\"", "lemma coeff_of_int_poly [simp]: \"coeff (of_int_poly p) n = of_int (coeff p n)\"", "lemma of_int_poly_0 [simp]: \"of_int_poly 0 = 0\"", "lemma of_int_poly_pCons [simp]: \"of_int_poly (pCons c p) = pCons (of_int c) (of_int_poly p)\"", "lemma of_int_poly_smult [simp]: \"of_int_poly (smult c p) = smult (of_int c) (of_int_poly p)\"", "lemma of_int_poly_1 [simp]: \"of_int_poly 1 = 1\"", "lemma of_int_poly_add [simp]: \"of_int_poly (p + q) = of_int_poly p + of_int_poly q\"", "lemma of_int_poly_mult [simp]: \"of_int_poly (p * q) = (of_int_poly p * of_int_poly q)\"", "lemma of_int_poly_sum [simp]: \"of_int_poly (sum f A) = sum (\\<lambda>x. of_int_poly (f x)) A\"", "lemma of_int_poly_prod [simp]: \"of_int_poly (prod f A) = prod (\\<lambda>x. of_int_poly (f x)) A\"", "lemma of_int_poly_power [simp]: \"of_int_poly (p ^ n) = of_int_poly p ^ n\"", "lemma of_int_poly_monom [simp]: \"of_int_poly (monom c n) = monom (of_int c) n\"", "lemma poly_of_int_poly [simp]: \"poly (of_int_poly p) (of_int x) = of_int (poly p x)\"", "lemma poly_of_int_poly_of_nat [simp]: \"poly (of_int_poly p) (of_nat x) = of_int (poly p (int x))\"", "lemma poly_of_int_poly_0 [simp]: \"poly (of_int_poly p) 0 = of_int (poly p 0)\"", "lemma poly_of_int_poly_1 [simp]: \"poly (of_int_poly p) 1 = of_int (poly p 1)\"", "lemma poly_of_int_poly_of_real [simp]:\n    \"poly (of_int_poly p) (of_real x) = of_real (poly (of_int_poly p) x)\"", "lemma of_int_poly_eq_iff [simp]:\n  \"of_int_poly p = (of_int_poly q :: 'a :: {comm_ring_1, ring_char_0} poly) \\<longleftrightarrow> p = q\"", "lemma of_int_poly_eq_0_iff [simp]:\n  \"of_int_poly p = (0 :: 'a :: {comm_ring_1, ring_char_0} poly) \\<longleftrightarrow> p = 0\"", "lemma degree_of_int_poly [simp]:\n  \"degree (of_int_poly p :: 'a :: {comm_ring_1, ring_char_0} poly) = degree p\"", "lemma pderiv_of_int_poly [simp]: \"pderiv (of_int_poly p) = of_int_poly (pderiv p)\"", "lemma higher_pderiv_of_int_poly [simp]:\n  \"(pderiv ^^ n) (of_int_poly p) = of_int_poly ((pderiv ^^ n) p)\"", "lemma int_polyE:\n  assumes \"\\<And>n. coeff (p :: 'a :: {comm_ring_1, ring_char_0} poly) n \\<in> \\<int>\"\n  obtains p' where \"p = of_int_poly p'\"", "lemma pderiv_power:\n  \"pderiv (p ^ n) = smult (of_nat n) (p ^ (n - 1) * pderiv p)\"", "lemma degree_prod_sum_eq:\n  \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0) \\<Longrightarrow>\n     degree (prod f A :: 'a :: idom poly) = (\\<Sum>x\\<in>A. degree (f x))\"", "lemma pderiv_monom:\n  \"pderiv (monom c n) = monom (of_nat n * c) (n - 1)\"", "lemma power_poly_const [simp]: \"[:c:] ^ n = [:c ^ n:]\"", "lemma monom_power: \"monom c n ^ k = monom (c ^ k) (n * k)\"", "lemma coeff_higher_pderiv:\n  \"coeff ((pderiv ^^ m) f) n = pochhammer (of_nat (Suc n)) m * coeff f (n + m)\"", "lemma higher_pderiv_add: \"(pderiv ^^ n) (p + q) = (pderiv ^^ n) p + (pderiv ^^ n) q\"", "lemma higher_pderiv_smult: \"(pderiv ^^ n) (smult c p) = smult c ((pderiv ^^ n) p)\"", "lemma higher_pderiv_0 [simp]: \"(pderiv ^^ n) 0 = 0\"", "lemma higher_pderiv_monom:\n  \"m \\<le> n + 1 \\<Longrightarrow> (pderiv ^^ m) (monom c n) = monom (pochhammer (int n - int m + 1) m * c) (n - m)\"", "lemma higher_pderiv_monom_eq_zero:\n  \"m > n + 1 \\<Longrightarrow> (pderiv ^^ m) (monom c n) = 0\"", "lemma higher_pderiv_sum: \"(pderiv ^^ n) (sum f A) = (\\<Sum>x\\<in>A. (pderiv ^^ n) (f x))\"", "lemma fact_dvd_higher_pderiv:\n  \"[:fact n :: int:] dvd (pderiv ^^ n) p\"", "lemma fact_dvd_poly_higher_pderiv_aux:\n  \"(fact n :: int) dvd poly ((pderiv ^^ n) p) x\"", "lemma fact_dvd_poly_higher_pderiv_aux':\n  \"m \\<le> n \\<Longrightarrow> (fact m :: int) dvd poly ((pderiv ^^ n) p) x\"", "lemma algebraicE':\n  assumes \"algebraic (x :: 'a :: field_char_0)\"\n  obtains p where \"p \\<noteq> 0\" \"poly (of_int_poly p) x = 0\"", "lemma algebraicE'_nonzero:\n  assumes \"algebraic (x :: 'a :: field_char_0)\" \"x \\<noteq> 0\"\n  obtains p where \"p \\<noteq> 0\" \"coeff p 0 \\<noteq> 0\" \"poly (of_int_poly p) x = 0\"", "lemma algebraic_of_real_iff [simp]:\n   \"algebraic (of_real x :: 'a :: {real_algebra_1,field_char_0}) \\<longleftrightarrow> algebraic x\"", "lemma lindemann_weierstrass_integral:\n  fixes u :: complex and f :: \"complex poly\"\n  defines \"df \\<equiv> \\<lambda>n. (pderiv ^^ n) f\"\n  defines \"m \\<equiv> degree f\"\n  defines \"I \\<equiv> \\<lambda>f u. exp u * (\\<Sum>j\\<le>degree f. poly ((pderiv ^^ j) f) 0) -\n                       (\\<Sum>j\\<le>degree f. poly ((pderiv ^^ j) f) u)\"\n  shows \"((\\<lambda>t. exp (u - t) * poly f t) has_contour_integral I f u) (linepath 0 u)\"", "lemma lindemann_weierstrass_integral_bound:\n  fixes u :: complex\n  assumes \"C \\<ge> 0\" \"\\<And>t. t \\<in> closed_segment 0 u \\<Longrightarrow> norm (poly f t) \\<le> C\"\n  shows \"norm (I u) \\<le> norm u * exp (norm u) * C\"", "lemma poly_higher_pderiv_aux1:\n  fixes c :: \"'a :: idom\"\n  assumes \"k < n\"\n  shows   \"poly ((pderiv ^^ k) ([:-c, 1:] ^ n * p)) c = 0\"", "lemma poly_higher_pderiv_aux1':\n  fixes c :: \"'a :: idom\"\n  assumes \"k < n\" \"[:-c, 1:] ^ n dvd p\"\n  shows   \"poly ((pderiv ^^ k) p) c = 0\"", "lemma poly_higher_pderiv_aux2:\n  fixes c :: \"'a :: {idom, semiring_char_0}\"\n  shows   \"poly ((pderiv ^^ n) ([:-c, 1:] ^ n * p)) c = fact n * poly p c\"", "lemma poly_higher_pderiv_aux3:\n  fixes c :: \"'a :: {idom,semiring_char_0}\"\n  assumes \"k \\<ge> n\"\n  shows   \"\\<exists>q. poly ((pderiv ^^ k) ([:-c, 1:] ^ n * p)) c = fact n * poly q c\"", "lemma poly_higher_pderiv_aux3':\n  fixes c :: \"'a :: {idom, semiring_char_0}\"\n  assumes \"k \\<ge> n\" \"[:-c, 1:] ^ n dvd p\"\n  shows   \"fact n dvd poly ((pderiv ^^ k) p) c\"", "lemma e_transcendental_aux_bound:\n  obtains C where \"C \\<ge> 0\"\n    \"\\<And>x. x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n        norm (\\<Prod>k\\<in>{1..n}. (x - of_nat k :: complex)) \\<le> C\"", "theorem e_transcendental_complex: \"\\<not> algebraic (exp 1 :: complex)\""], "translations": [["", "lemma fact_dvd_pochhammer:\n  assumes \"m \\<le> n + 1\"\n  shows   \"fact m dvd pochhammer (int n - int m + 1) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "have \"(real n gchoose m) * fact m = of_int (pochhammer (int n - int m + 1) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real n gchoose m) * fact m =\n    real_of_int (pochhammer (int n - int m + 1) m)", "by (simp add: gbinomial_pochhammer' pochhammer_of_int [symmetric])"], ["proof (state)\nthis:\n  (real n gchoose m) * fact m =\n  real_of_int (pochhammer (int n - int m + 1) m)\n\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "also"], ["proof (state)\nthis:\n  (real n gchoose m) * fact m =\n  real_of_int (pochhammer (int n - int m + 1) m)\n\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "have \"(real n gchoose m) * fact m = of_int (int (n choose m) * fact m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real n gchoose m) * fact m = real_of_int (int (n choose m) * fact m)", "by (simp add: binomial_gbinomial)"], ["proof (state)\nthis:\n  (real n gchoose m) * fact m = real_of_int (int (n choose m) * fact m)\n\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "finally"], ["proof (chain)\npicking this:\n  real_of_int (int (n choose m) * fact m) =\n  real_of_int (pochhammer (int n - int m + 1) m)", "have \"int (n choose m) * fact m = pochhammer (int n - int m + 1) m\""], ["proof (prove)\nusing this:\n  real_of_int (int (n choose m) * fact m) =\n  real_of_int (pochhammer (int n - int m + 1) m)\n\ngoal (1 subgoal):\n 1. int (n choose m) * fact m = pochhammer (int n - int m + 1) m", "by (subst (asm) of_int_eq_iff)"], ["proof (state)\nthis:\n  int (n choose m) * fact m = pochhammer (int n - int m + 1) m\n\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "from this [symmetric]"], ["proof (chain)\npicking this:\n  pochhammer (int n - int m + 1) m = int (n choose m) * fact m", "show ?thesis"], ["proof (prove)\nusing this:\n  pochhammer (int n - int m + 1) m = int (n choose m) * fact m\n\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "by simp"], ["proof (state)\nthis:\n  fact m dvd pochhammer (int n - int m + 1) m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_nat_eq_1_iff [simp]: \"of_nat x = (1 :: 'a :: semiring_char_0) \\<longleftrightarrow> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat x = (1::'a)) = (x = 1)", "by (fact of_nat_eq_1_iff)"], ["", "lemma prime_elem_int_not_dvd_neg1_power:\n  \"prime_elem (p :: int) \\<Longrightarrow> \\<not>p dvd (-1) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_elem p \\<Longrightarrow> \\<not> p dvd (- 1) ^ n", "by (rule notI, frule (1) prime_elem_dvd_power, cases \"p \\<ge> 0\") (auto simp: prime_elem_def)"], ["", "lemma nat_fact [simp]: \"nat (fact n) = fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (fact n) = fact n", "by (subst of_nat_fact [symmetric]) (rule nat_int)"], ["", "lemma prime_dvd_fact_iff_int:\n  \"p dvd fact n \\<longleftrightarrow> p \\<le> int n\" if \"prime p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p dvd fact n) = (p \\<le> int n)", "using that prime_dvd_fact_iff [of \"nat \\<bar>p\\<bar>\" n]"], ["proof (prove)\nusing this:\n  prime p\n  prime (nat \\<bar>p\\<bar>) \\<Longrightarrow>\n  (nat \\<bar>p\\<bar> dvd fact n) = (nat \\<bar>p\\<bar> \\<le> n)\n\ngoal (1 subgoal):\n 1. (p dvd fact n) = (p \\<le> int n)", "by auto (simp add: prime_ge_0_int)"], ["", "lemma filterlim_minus_nat_at_top:\n  \"filterlim (\\<lambda>n. n - k :: nat) at_top at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM n sequentially. n - k :> sequentially", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM n sequentially. n - k :> sequentially", "have \"sequentially = filtermap (\\<lambda>n. n + k) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sequentially = filtermap (\\<lambda>n. n + k) sequentially", "by (auto simp: filter_eq_iff eventually_filtermap)"], ["proof (state)\nthis:\n  sequentially = filtermap (\\<lambda>n. n + k) sequentially\n\ngoal (1 subgoal):\n 1. LIM n sequentially. n - k :> sequentially", "also"], ["proof (state)\nthis:\n  sequentially = filtermap (\\<lambda>n. n + k) sequentially\n\ngoal (1 subgoal):\n 1. LIM n sequentially. n - k :> sequentially", "have \"filterlim (\\<lambda>n. n - k :: nat) at_top \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM n filtermap (\\<lambda>n. n + k) sequentially. n - k :> sequentially", "by (simp add: filterlim_filtermap filterlim_ident)"], ["proof (state)\nthis:\n  LIM n filtermap (\\<lambda>n. n + k) sequentially. n - k :> sequentially\n\ngoal (1 subgoal):\n 1. LIM n sequentially. n - k :> sequentially", "finally"], ["proof (chain)\npicking this:\n  LIM n sequentially. n - k :> sequentially", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM n sequentially. n - k :> sequentially\n\ngoal (1 subgoal):\n 1. LIM n sequentially. n - k :> sequentially", "."], ["proof (state)\nthis:\n  LIM n sequentially. n - k :> sequentially\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma power_over_fact_tendsto_0:\n  \"(\\<lambda>n. (x :: real) ^ n / fact n) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. x ^ n / fact n) \\<longlonglongrightarrow> 0", "using summable_exp[of x]"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. inverse (fact n) * x ^ n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x ^ n / fact n) \\<longlonglongrightarrow> 0", "by (intro summable_LIMSEQ_zero) (simp add: sums_iff field_simps)"], ["", "lemma power_over_fact_tendsto_0':\n  \"(\\<lambda>n. c * (x :: real) ^ n / fact n) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. c * x ^ n / fact n) \\<longlonglongrightarrow> 0", "using tendsto_mult[OF tendsto_const[of c] power_over_fact_tendsto_0[of x]]"], ["proof (prove)\nusing this:\n  (\\<lambda>xa. c * (x ^ xa / fact xa)) \\<longlonglongrightarrow> c * 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. c * x ^ n / fact n) \\<longlonglongrightarrow> 0", "by simp"], ["", "subsection \\<open>Lifting integer polynomials\\<close>"], ["", "lift_definition of_int_poly :: \"int poly \\<Rightarrow> 'a :: comm_ring_1 poly\" is \"\\<lambda>g x. of_int (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun.\n       \\<forall>\\<^sub>\\<infinity>n. fun n = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>\\<infinity>n. of_int (fun n) = (0::'a)", "by (auto elim: eventually_mono)"], ["", "lemma coeff_of_int_poly [simp]: \"coeff (of_int_poly p) n = of_int (coeff p n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (of_int_poly p) n = of_int (poly.coeff p n)", "by transfer' simp"], ["", "lemma of_int_poly_0 [simp]: \"of_int_poly 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly 0 = 0", "by transfer (simp add: fun_eq_iff)"], ["", "lemma of_int_poly_pCons [simp]: \"of_int_poly (pCons c p) = pCons (of_int c) (of_int_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (pCons c p) = pCons (of_int c) (of_int_poly p)", "by transfer' (simp add: fun_eq_iff split: nat.splits)"], ["", "lemma of_int_poly_smult [simp]: \"of_int_poly (smult c p) = smult (of_int c) (of_int_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (Polynomial.smult c p) =\n    Polynomial.smult (of_int c) (of_int_poly p)", "by transfer simp"], ["", "lemma of_int_poly_1 [simp]: \"of_int_poly 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly 1 = 1", "by (simp add: one_pCons)"], ["", "lemma of_int_poly_add [simp]: \"of_int_poly (p + q) = of_int_poly p + of_int_poly q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (p + q) = of_int_poly p + of_int_poly q", "by transfer' (simp add: fun_eq_iff)"], ["", "lemma of_int_poly_mult [simp]: \"of_int_poly (p * q) = (of_int_poly p * of_int_poly q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (p * q) = of_int_poly p * of_int_poly q", "by (induction p) simp_all"], ["", "lemma of_int_poly_sum [simp]: \"of_int_poly (sum f A) = sum (\\<lambda>x. of_int_poly (f x)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (sum f A) = (\\<Sum>x\\<in>A. of_int_poly (f x))", "by (induction A rule: infinite_finite_induct) simp_all"], ["", "lemma of_int_poly_prod [simp]: \"of_int_poly (prod f A) = prod (\\<lambda>x. of_int_poly (f x)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (prod f A) = (\\<Prod>x\\<in>A. of_int_poly (f x))", "by (induction A rule: infinite_finite_induct) simp_all"], ["", "lemma of_int_poly_power [simp]: \"of_int_poly (p ^ n) = of_int_poly p ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (p ^ n) = of_int_poly p ^ n", "by (induction n) simp_all"], ["", "lemma of_int_poly_monom [simp]: \"of_int_poly (monom c n) = monom (of_int c) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (Polynomial.monom c n) = Polynomial.monom (of_int c) n", "by transfer (simp add: fun_eq_iff)"], ["", "lemma poly_of_int_poly [simp]: \"poly (of_int_poly p) (of_int x) = of_int (poly p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (of_int_poly p) (of_int x) = of_int (poly p x)", "by (induction p) simp_all"], ["", "lemma poly_of_int_poly_of_nat [simp]: \"poly (of_int_poly p) (of_nat x) = of_int (poly p (int x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (of_int_poly p) (of_nat x) = of_int (poly p (int x))", "by (induction p) simp_all"], ["", "lemma poly_of_int_poly_0 [simp]: \"poly (of_int_poly p) 0 = of_int (poly p 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (of_int_poly p) (0::'a) = of_int (poly p 0)", "by (induction p) simp_all"], ["", "lemma poly_of_int_poly_1 [simp]: \"poly (of_int_poly p) 1 = of_int (poly p 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (of_int_poly p) (1::'a) = of_int (poly p 1)", "by (induction p) simp_all"], ["", "lemma poly_of_int_poly_of_real [simp]:\n    \"poly (of_int_poly p) (of_real x) = of_real (poly (of_int_poly p) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (of_int_poly p) (of_real x) = of_real (poly (of_int_poly p) x)", "by (induction p) simp_all"], ["", "lemma of_int_poly_eq_iff [simp]:\n  \"of_int_poly p = (of_int_poly q :: 'a :: {comm_ring_1, ring_char_0} poly) \\<longleftrightarrow> p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int_poly p = of_int_poly q) = (p = q)", "by (simp add: poly_eq_iff)"], ["", "lemma of_int_poly_eq_0_iff [simp]:\n  \"of_int_poly p = (0 :: 'a :: {comm_ring_1, ring_char_0} poly) \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int_poly p = 0) = (p = 0)", "using of_int_poly_eq_iff[of p 0]"], ["proof (prove)\nusing this:\n  (of_int_poly p = of_int_poly 0) = (p = 0)\n\ngoal (1 subgoal):\n 1. (of_int_poly p = 0) = (p = 0)", "by (simp del: of_int_poly_eq_iff)"], ["", "lemma degree_of_int_poly [simp]:\n  \"degree (of_int_poly p :: 'a :: {comm_ring_1, ring_char_0} poly) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (of_int_poly p) = degree p", "by (simp add: degree_def)"], ["", "lemma pderiv_of_int_poly [simp]: \"pderiv (of_int_poly p) = of_int_poly (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (of_int_poly p) = of_int_poly (pderiv p)", "by (induction p) (simp_all add: pderiv_pCons)"], ["", "lemma higher_pderiv_of_int_poly [simp]:\n  \"(pderiv ^^ n) (of_int_poly p) = of_int_poly ((pderiv ^^ n) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ n) (of_int_poly p) = of_int_poly ((pderiv ^^ n) p)", "by (induction n) simp_all"], ["", "lemma int_polyE:\n  assumes \"\\<And>n. coeff (p :: 'a :: {comm_ring_1, ring_char_0} poly) n \\<in> \\<int>\"\n  obtains p' where \"p = of_int_poly p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p = of_int_poly p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p = of_int_poly p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  poly.coeff p ?n \\<in> \\<int>", "have \"\\<forall>n. \\<exists>c. coeff p n = of_int c\""], ["proof (prove)\nusing this:\n  poly.coeff p ?n \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<forall>n. \\<exists>c. poly.coeff p n = of_int c", "by (auto simp: Ints_def)"], ["proof (state)\nthis:\n  \\<forall>n. \\<exists>c. poly.coeff p n = of_int c\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p = of_int_poly p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"\\<exists>c. \\<forall>n. of_int (c n) = coeff p n\""], ["proof (prove)\nusing this:\n  \\<forall>n. \\<exists>c. poly.coeff p n = of_int c\n\ngoal (1 subgoal):\n 1. \\<exists>c. \\<forall>n. of_int (c n) = poly.coeff p n", "by (simp add: choice_iff eq_commute)"], ["proof (state)\nthis:\n  \\<exists>c. \\<forall>n. of_int (c n) = poly.coeff p n\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p = of_int_poly p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>c. \\<forall>n. of_int (c n) = poly.coeff p n", "obtain c where c: \"of_int (c n) = coeff p n\" for n"], ["proof (prove)\nusing this:\n  \\<exists>c. \\<forall>n. of_int (c n) = poly.coeff p n\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (\\<And>n. of_int (c n) = poly.coeff p n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  of_int (c ?n) = poly.coeff p ?n\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p = of_int_poly p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]: \"coeff (Abs_poly c) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (Abs_poly c) = c", "proof (rule poly.Abs_poly_inverse, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n. c n = 0", "have \"eventually (\\<lambda>n. n > degree p) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually ((<) (degree p)) sequentially", "by (rule eventually_gt_at_top)"], ["proof (state)\nthis:\n  eventually ((<) (degree p)) sequentially\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n. c n = 0", "hence \"eventually (\\<lambda>n. coeff p n = 0) at_top\""], ["proof (prove)\nusing this:\n  eventually ((<) (degree p)) sequentially\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. poly.coeff p n = (0::'a)", "by eventually_elim (simp add: coeff_eq_0)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. poly.coeff p n = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n. c n = 0", "thus \"eventually (\\<lambda>n. c n = 0) cofinite\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially. poly.coeff p n = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n. c n = 0", "by (simp add: c [symmetric] cofinite_eq_sequentially)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>\\<infinity>n. c n = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly.coeff (Abs_poly c) = c\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p = of_int_poly p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"p = of_int_poly (Abs_poly c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = of_int_poly (Abs_poly c)", "by (rule poly_eqI) (simp add: c)"], ["proof (state)\nthis:\n  p = of_int_poly (Abs_poly c)\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p = of_int_poly p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = of_int_poly (Abs_poly c)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>General facts about polynomials\\<close>"], ["", "lemma pderiv_power:\n  \"pderiv (p ^ n) = smult (of_nat n) (p ^ (n - 1) * pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (p ^ n) = Polynomial.smult (of_nat n) (p ^ (n - 1) * pderiv p)", "by (cases n) (simp_all add: pderiv_power_Suc del: power_Suc)"], ["", "lemma degree_prod_sum_eq:\n  \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0) \\<Longrightarrow>\n     degree (prod f A :: 'a :: idom poly) = (\\<Sum>x\\<in>A. degree (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0) \\<Longrightarrow>\n    degree (prod f A) = (\\<Sum>x\\<in>A. degree (f x))", "by (induction A rule: infinite_finite_induct) (auto simp: degree_mult_eq)"], ["", "lemma pderiv_monom:\n  \"pderiv (monom c n) = monom (of_nat n * c) (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (Polynomial.monom c n) = Polynomial.monom (of_nat n * c) (n - 1)", "by (cases n)\n     (simp_all add: monom_altdef pderiv_power_Suc pderiv_smult pderiv_pCons mult_ac del: power_Suc)"], ["", "lemma power_poly_const [simp]: \"[:c:] ^ n = [:c ^ n:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:c:] ^ n = [:c ^ n:]", "by (induction n) (simp_all add: power_commutes)"], ["", "lemma monom_power: \"monom c n ^ k = monom (c ^ k) (n * k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.monom c n ^ k = Polynomial.monom (c ^ k) (n * k)", "by (induction k) (simp_all add: mult_monom)"], ["", "lemma coeff_higher_pderiv:\n  \"coeff ((pderiv ^^ m) f) n = pochhammer (of_nat (Suc n)) m * coeff f (n + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff ((pderiv ^^ m) f) n =\n    pochhammer (of_nat (Suc n)) m * poly.coeff f (n + m)", "by (induction m arbitrary: n) (simp_all add: coeff_pderiv pochhammer_rec algebra_simps)"], ["", "lemma higher_pderiv_add: \"(pderiv ^^ n) (p + q) = (pderiv ^^ n) p + (pderiv ^^ n) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ n) (p + q) = (pderiv ^^ n) p + (pderiv ^^ n) q", "by (induction n arbitrary: p q) (simp_all del: funpow.simps add: funpow_Suc_right pderiv_add)"], ["", "lemma higher_pderiv_smult: \"(pderiv ^^ n) (smult c p) = smult c ((pderiv ^^ n) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ n) (Polynomial.smult c p) =\n    Polynomial.smult c ((pderiv ^^ n) p)", "by (induction n arbitrary: p) (simp_all del: funpow.simps add: funpow_Suc_right pderiv_smult)"], ["", "lemma higher_pderiv_0 [simp]: \"(pderiv ^^ n) 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ n) 0 = 0", "by (induction n) simp_all"], ["", "lemma higher_pderiv_monom:\n  \"m \\<le> n + 1 \\<Longrightarrow> (pderiv ^^ m) (monom c n) = monom (pochhammer (int n - int m + 1) m * c) (n - m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n + 1 \\<Longrightarrow>\n    (pderiv ^^ m) (Polynomial.monom c n) =\n    Polynomial.monom (pochhammer (int n - int m + 1) m * c) (n - m)", "proof (induction m arbitrary: c n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c n.\n       0 \\<le> n + 1 \\<Longrightarrow>\n       (pderiv ^^ 0) (Polynomial.monom c n) =\n       Polynomial.monom (pochhammer (int n - int 0 + 1) 0 * c) (n - 0)\n 2. \\<And>m c n.\n       \\<lbrakk>\\<And>c n.\n                   m \\<le> n + 1 \\<Longrightarrow>\n                   (pderiv ^^ m) (Polynomial.monom c n) =\n                   Polynomial.monom (pochhammer (int n - int m + 1) m * c)\n                    (n - m);\n        Suc m \\<le> n + 1\\<rbrakk>\n       \\<Longrightarrow> (pderiv ^^ Suc m) (Polynomial.monom c n) =\n                         Polynomial.monom\n                          (pochhammer (int n - int (Suc m) + 1) (Suc m) * c)\n                          (n - Suc m)", "case (Suc m)"], ["proof (state)\nthis:\n  m \\<le> ?n + 1 \\<Longrightarrow>\n  (pderiv ^^ m) (Polynomial.monom ?c ?n) =\n  Polynomial.monom (pochhammer (int ?n - int m + 1) m * ?c) (?n - m)\n  Suc m \\<le> n + 1\n\ngoal (2 subgoals):\n 1. \\<And>c n.\n       0 \\<le> n + 1 \\<Longrightarrow>\n       (pderiv ^^ 0) (Polynomial.monom c n) =\n       Polynomial.monom (pochhammer (int n - int 0 + 1) 0 * c) (n - 0)\n 2. \\<And>m c n.\n       \\<lbrakk>\\<And>c n.\n                   m \\<le> n + 1 \\<Longrightarrow>\n                   (pderiv ^^ m) (Polynomial.monom c n) =\n                   Polynomial.monom (pochhammer (int n - int m + 1) m * c)\n                    (n - m);\n        Suc m \\<le> n + 1\\<rbrakk>\n       \\<Longrightarrow> (pderiv ^^ Suc m) (Polynomial.monom c n) =\n                         Polynomial.monom\n                          (pochhammer (int n - int (Suc m) + 1) (Suc m) * c)\n                          (n - Suc m)", "thus ?case"], ["proof (prove)\nusing this:\n  m \\<le> ?n + 1 \\<Longrightarrow>\n  (pderiv ^^ m) (Polynomial.monom ?c ?n) =\n  Polynomial.monom (pochhammer (int ?n - int m + 1) m * ?c) (?n - m)\n  Suc m \\<le> n + 1\n\ngoal (1 subgoal):\n 1. (pderiv ^^ Suc m) (Polynomial.monom c n) =\n    Polynomial.monom (pochhammer (int n - int (Suc m) + 1) (Suc m) * c)\n     (n - Suc m)", "by (cases n)\n       (simp_all del: funpow.simps add: funpow_Suc_right pderiv_monom pochhammer_rec' Suc.IH)"], ["proof (state)\nthis:\n  (pderiv ^^ Suc m) (Polynomial.monom c n) =\n  Polynomial.monom (pochhammer (int n - int (Suc m) + 1) (Suc m) * c)\n   (n - Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       0 \\<le> n + 1 \\<Longrightarrow>\n       (pderiv ^^ 0) (Polynomial.monom c n) =\n       Polynomial.monom (pochhammer (int n - int 0 + 1) 0 * c) (n - 0)", "qed simp_all"], ["", "lemma higher_pderiv_monom_eq_zero:\n  \"m > n + 1 \\<Longrightarrow> (pderiv ^^ m) (monom c n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + 1 < m \\<Longrightarrow> (pderiv ^^ m) (Polynomial.monom c n) = 0", "proof (induction m arbitrary: c n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c n.\n       n + 1 < 0 \\<Longrightarrow> (pderiv ^^ 0) (Polynomial.monom c n) = 0\n 2. \\<And>m c n.\n       \\<lbrakk>\\<And>c n.\n                   n + 1 < m \\<Longrightarrow>\n                   (pderiv ^^ m) (Polynomial.monom c n) = 0;\n        n + 1 < Suc m\\<rbrakk>\n       \\<Longrightarrow> (pderiv ^^ Suc m) (Polynomial.monom c n) = 0", "case (Suc m)"], ["proof (state)\nthis:\n  ?n + 1 < m \\<Longrightarrow> (pderiv ^^ m) (Polynomial.monom ?c ?n) = 0\n  n + 1 < Suc m\n\ngoal (2 subgoals):\n 1. \\<And>c n.\n       n + 1 < 0 \\<Longrightarrow> (pderiv ^^ 0) (Polynomial.monom c n) = 0\n 2. \\<And>m c n.\n       \\<lbrakk>\\<And>c n.\n                   n + 1 < m \\<Longrightarrow>\n                   (pderiv ^^ m) (Polynomial.monom c n) = 0;\n        n + 1 < Suc m\\<rbrakk>\n       \\<Longrightarrow> (pderiv ^^ Suc m) (Polynomial.monom c n) = 0", "thus ?case"], ["proof (prove)\nusing this:\n  ?n + 1 < m \\<Longrightarrow> (pderiv ^^ m) (Polynomial.monom ?c ?n) = 0\n  n + 1 < Suc m\n\ngoal (1 subgoal):\n 1. (pderiv ^^ Suc m) (Polynomial.monom c n) = 0", "by (cases n)\n       (simp_all del: funpow.simps add: funpow_Suc_right pderiv_monom pochhammer_rec' Suc.IH)"], ["proof (state)\nthis:\n  (pderiv ^^ Suc m) (Polynomial.monom c n) = 0\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       n + 1 < 0 \\<Longrightarrow> (pderiv ^^ 0) (Polynomial.monom c n) = 0", "qed simp_all"], ["", "lemma higher_pderiv_sum: \"(pderiv ^^ n) (sum f A) = (\\<Sum>x\\<in>A. (pderiv ^^ n) (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ n) (sum f A) = (\\<Sum>x\\<in>A. (pderiv ^^ n) (f x))", "by (induction A rule: infinite_finite_induct) (simp_all add: higher_pderiv_add)"], ["", "lemma fact_dvd_higher_pderiv:\n  \"[:fact n :: int:] dvd (pderiv ^^ n) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:fact n:] dvd (pderiv ^^ n) p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [:fact n:] dvd (pderiv ^^ n) p", "have \"[:fact n:] dvd (pderiv ^^ n) (monom c k)\" for c :: int and k :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:fact n:] dvd (pderiv ^^ n) (Polynomial.monom c k)", "by (cases \"n \\<le> k + 1\")\n       (simp_all add: higher_pderiv_monom higher_pderiv_monom_eq_zero\n          fact_dvd_pochhammer const_poly_dvd_iff)"], ["proof (state)\nthis:\n  [:fact n:] dvd (pderiv ^^ n) (Polynomial.monom ?c ?k)\n\ngoal (1 subgoal):\n 1. [:fact n:] dvd (pderiv ^^ n) p", "hence \"[:fact n:] dvd (pderiv ^^ n) (\\<Sum>k\\<le>degree p. monom (coeff p k) k)\""], ["proof (prove)\nusing this:\n  [:fact n:] dvd (pderiv ^^ n) (Polynomial.monom ?c ?k)\n\ngoal (1 subgoal):\n 1. [:fact n:] dvd\n    (pderiv ^^ n)\n     (\\<Sum>k\\<le>degree p. Polynomial.monom (poly.coeff p k) k)", "by (simp_all add: higher_pderiv_sum dvd_sum)"], ["proof (state)\nthis:\n  [:fact n:] dvd\n  (pderiv ^^ n) (\\<Sum>k\\<le>degree p. Polynomial.monom (poly.coeff p k) k)\n\ngoal (1 subgoal):\n 1. [:fact n:] dvd (pderiv ^^ n) p", "thus ?thesis"], ["proof (prove)\nusing this:\n  [:fact n:] dvd\n  (pderiv ^^ n) (\\<Sum>k\\<le>degree p. Polynomial.monom (poly.coeff p k) k)\n\ngoal (1 subgoal):\n 1. [:fact n:] dvd (pderiv ^^ n) p", "by (simp add: poly_as_sum_of_monoms)"], ["proof (state)\nthis:\n  [:fact n:] dvd (pderiv ^^ n) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fact_dvd_poly_higher_pderiv_aux:\n  \"(fact n :: int) dvd poly ((pderiv ^^ n) p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact n dvd poly ((pderiv ^^ n) p) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fact n dvd poly ((pderiv ^^ n) p) x", "have \"[:fact n:] dvd (pderiv ^^ n) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:fact n:] dvd (pderiv ^^ n) p", "by (rule fact_dvd_higher_pderiv)"], ["proof (state)\nthis:\n  [:fact n:] dvd (pderiv ^^ n) p\n\ngoal (1 subgoal):\n 1. fact n dvd poly ((pderiv ^^ n) p) x", "then"], ["proof (chain)\npicking this:\n  [:fact n:] dvd (pderiv ^^ n) p", "obtain q where \"(pderiv ^^ n) p = [:fact n:] * q\""], ["proof (prove)\nusing this:\n  [:fact n:] dvd (pderiv ^^ n) p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        (pderiv ^^ n) p = [:fact n:] * q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (erule dvdE)"], ["proof (state)\nthis:\n  (pderiv ^^ n) p = [:fact n:] * q\n\ngoal (1 subgoal):\n 1. fact n dvd poly ((pderiv ^^ n) p) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  (pderiv ^^ n) p = [:fact n:] * q\n\ngoal (1 subgoal):\n 1. fact n dvd poly ((pderiv ^^ n) p) x", "by simp"], ["proof (state)\nthis:\n  fact n dvd poly ((pderiv ^^ n) p) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fact_dvd_poly_higher_pderiv_aux':\n  \"m \\<le> n \\<Longrightarrow> (fact m :: int) dvd poly ((pderiv ^^ n) p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> fact m dvd poly ((pderiv ^^ n) p) x", "by (rule dvd_trans[OF fact_dvd fact_dvd_poly_higher_pderiv_aux]) simp_all"], ["", "lemma algebraicE':\n  assumes \"algebraic (x :: 'a :: field_char_0)\"\n  obtains p where \"p \\<noteq> 0\" \"poly (of_int_poly p) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  algebraic x", "obtain q where \"\\<And>i. coeff q i \\<in> \\<int>\" \"q \\<noteq> 0\" \"poly q x = 0\""], ["proof (prove)\nusing this:\n  algebraic x\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>\\<And>i. poly.coeff q i \\<in> \\<int>; q \\<noteq> 0;\n         poly q x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule algebraicE)"], ["proof (state)\nthis:\n  poly.coeff q ?i \\<in> \\<int>\n  q \\<noteq> 0\n  poly q x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  poly.coeff q ?i \\<in> \\<int>\n  q \\<noteq> 0\n  poly q x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(1)"], ["proof (chain)\npicking this:\n  poly.coeff q ?i \\<in> \\<int>", "obtain q' where \"q = of_int_poly q'\""], ["proof (prove)\nusing this:\n  poly.coeff q ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        q = of_int_poly q' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule int_polyE)"], ["proof (state)\nthis:\n  q = of_int_poly q'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  poly.coeff q ?i \\<in> \\<int>\n  q \\<noteq> 0\n  poly q x = (0::'a)\n  q = of_int_poly q'", "show ?thesis"], ["proof (prove)\nusing this:\n  poly.coeff q ?i \\<in> \\<int>\n  q \\<noteq> 0\n  poly q x = (0::'a)\n  q = of_int_poly q'\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of q']) simp_all"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraicE'_nonzero:\n  assumes \"algebraic (x :: 'a :: field_char_0)\" \"x \\<noteq> 0\"\n  obtains p where \"p \\<noteq> 0\" \"coeff p 0 \\<noteq> 0\" \"poly (of_int_poly p) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly.coeff p 0 \\<noteq> 0;\n         poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly.coeff p 0 \\<noteq> 0;\n         poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(1)"], ["proof (chain)\npicking this:\n  algebraic x", "obtain p where p: \"p \\<noteq> 0\" \"poly (of_int_poly p) x = 0\""], ["proof (prove)\nusing this:\n  algebraic x\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule algebraicE')"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  poly (of_int_poly p) x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly.coeff p 0 \\<noteq> 0;\n         poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define n :: nat where \"n = order 0 p\""], ["proof (state)\nthis:\n  n = Polynomial.order 0 p\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly.coeff p 0 \\<noteq> 0;\n         poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"monom 1 n dvd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.monom 1 n dvd p", "by (simp add: monom_1_dvd_iff p n_def)"], ["proof (state)\nthis:\n  Polynomial.monom 1 n dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly.coeff p 0 \\<noteq> 0;\n         poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  Polynomial.monom 1 n dvd p", "obtain q where q: \"p = monom 1 n * q\""], ["proof (prove)\nusing this:\n  Polynomial.monom 1 n dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = Polynomial.monom 1 n * q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (erule dvdE)"], ["proof (state)\nthis:\n  p = Polynomial.monom 1 n * q\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly.coeff p 0 \\<noteq> 0;\n         poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  poly (of_int_poly p) x = (0::'a)", "have \"q \\<noteq> 0\" \"poly (of_int_poly q) x = 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly (of_int_poly p) x = (0::'a)\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& poly (of_int_poly q) x = (0::'a)", "by (auto simp: q poly_monom assms(2))"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  poly (of_int_poly q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly.coeff p 0 \\<noteq> 0;\n         poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  poly (of_int_poly q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly.coeff p 0 \\<noteq> 0;\n         poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  poly (of_int_poly q) x = (0::'a)", "have \"order 0 p = n + order 0 q\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  poly (of_int_poly q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. Polynomial.order 0 p = n + Polynomial.order 0 q", "by (simp add: q order_mult)"], ["proof (state)\nthis:\n  Polynomial.order 0 p = n + Polynomial.order 0 q\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly.coeff p 0 \\<noteq> 0;\n         poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"order 0 q = 0\""], ["proof (prove)\nusing this:\n  Polynomial.order 0 p = n + Polynomial.order 0 q\n\ngoal (1 subgoal):\n 1. Polynomial.order 0 q = 0", "by (simp add: n_def)"], ["proof (state)\nthis:\n  Polynomial.order 0 q = 0\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly.coeff p 0 \\<noteq> 0;\n         poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>q \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  Polynomial.order 0 q = 0", "have \"poly q 0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  Polynomial.order 0 q = 0\n\ngoal (1 subgoal):\n 1. poly q 0 \\<noteq> 0", "by (simp add: order_root)"], ["proof (state)\nthis:\n  poly q 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly.coeff p 0 \\<noteq> 0;\n         poly (of_int_poly p) x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  poly (of_int_poly q) x = (0::'a)\n  poly q 0 \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  poly (of_int_poly q) x = (0::'a)\n  poly q 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. thesis", "using that[of q]"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  poly (of_int_poly q) x = (0::'a)\n  poly q 0 \\<noteq> 0\n  \\<lbrakk>q \\<noteq> 0; poly.coeff q 0 \\<noteq> 0;\n   poly (of_int_poly q) x = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: poly_0_coeff_0)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraic_of_real_iff [simp]:\n   \"algebraic (of_real x :: 'a :: {real_algebra_1,field_char_0}) \\<longleftrightarrow> algebraic x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (of_real x) = algebraic x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. algebraic (of_real x) \\<Longrightarrow> algebraic x\n 2. algebraic x \\<Longrightarrow> algebraic (of_real x)", "assume \"algebraic (of_real x :: 'a)\""], ["proof (state)\nthis:\n  algebraic (of_real x)\n\ngoal (2 subgoals):\n 1. algebraic (of_real x) \\<Longrightarrow> algebraic x\n 2. algebraic x \\<Longrightarrow> algebraic (of_real x)", "then"], ["proof (chain)\npicking this:\n  algebraic (of_real x)", "obtain p where \"p \\<noteq> 0\" \"poly (of_int_poly p) (of_real x :: 'a) = 0\""], ["proof (prove)\nusing this:\n  algebraic (of_real x)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0;\n         poly (of_int_poly p) (of_real x) = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule algebraicE')"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  poly (of_int_poly p) (of_real x) = (0::'a)\n\ngoal (2 subgoals):\n 1. algebraic (of_real x) \\<Longrightarrow> algebraic x\n 2. algebraic x \\<Longrightarrow> algebraic (of_real x)", "hence \"(of_int_poly p :: real poly) \\<noteq> 0\"\n        \"poly (of_int_poly p :: real poly) x = 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly (of_int_poly p) (of_real x) = (0::'a)\n\ngoal (1 subgoal):\n 1. of_int_poly p \\<noteq> 0 &&& poly (of_int_poly p) x = 0", "by simp_all"], ["proof (state)\nthis:\n  of_int_poly p \\<noteq> 0\n  poly (of_int_poly p) x = 0\n\ngoal (2 subgoals):\n 1. algebraic (of_real x) \\<Longrightarrow> algebraic x\n 2. algebraic x \\<Longrightarrow> algebraic (of_real x)", "thus \"algebraic x\""], ["proof (prove)\nusing this:\n  of_int_poly p \\<noteq> 0\n  poly (of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. algebraic x", "by (intro algebraicI[of \"of_int_poly p\"]) simp_all"], ["proof (state)\nthis:\n  algebraic x\n\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> algebraic (of_real x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> algebraic (of_real x)", "assume \"algebraic x\""], ["proof (state)\nthis:\n  algebraic x\n\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> algebraic (of_real x)", "then"], ["proof (chain)\npicking this:\n  algebraic x", "obtain p where \"p \\<noteq> 0\" \"poly (of_int_poly p) x = 0\""], ["proof (prove)\nusing this:\n  algebraic x\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<noteq> 0; poly (of_int_poly p) x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule algebraicE')"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  poly (of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> algebraic (of_real x)", "hence \"of_int_poly p \\<noteq> (0 :: 'a poly)\" \"poly (of_int_poly p) (of_real x :: 'a) = 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly (of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. of_int_poly p \\<noteq> 0 &&& poly (of_int_poly p) (of_real x) = (0::'a)", "by simp_all"], ["proof (state)\nthis:\n  of_int_poly p \\<noteq> 0\n  poly (of_int_poly p) (of_real x) = (0::'a)\n\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> algebraic (of_real x)", "thus \"algebraic (of_real x)\""], ["proof (prove)\nusing this:\n  of_int_poly p \\<noteq> 0\n  poly (of_int_poly p) (of_real x) = (0::'a)\n\ngoal (1 subgoal):\n 1. algebraic (of_real x)", "by (intro algebraicI[of \"of_int_poly p\"]) simp_all"], ["proof (state)\nthis:\n  algebraic (of_real x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Main proof\\<close>"], ["", "lemma lindemann_weierstrass_integral:\n  fixes u :: complex and f :: \"complex poly\"\n  defines \"df \\<equiv> \\<lambda>n. (pderiv ^^ n) f\"\n  defines \"m \\<equiv> degree f\"\n  defines \"I \\<equiv> \\<lambda>f u. exp u * (\\<Sum>j\\<le>degree f. poly ((pderiv ^^ j) f) 0) -\n                       (\\<Sum>j\\<le>degree f. poly ((pderiv ^^ j) f) u)\"\n  shows \"((\\<lambda>t. exp (u - t) * poly f t) has_contour_integral I f u) (linepath 0 u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (u - t) * poly f t) has_contour_integral I f u)\n     (linepath 0 u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (u - t) * poly f t) has_contour_integral I f u)\n     (linepath 0 u)", "note [derivative_intros] =\n    exp_scaleR_has_vector_derivative_right vector_diff_chain_within"], ["proof (state)\nthis:\n  ((\\<lambda>t. exp (t *\\<^sub>R ?A)) has_vector_derivative\n   exp (?t *\\<^sub>R ?A) * ?A)\n   (at ?t within ?T)\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x within ?s);\n   (?g has_vector_derivative ?g') (at (?f ?x) within ?f ` ?s)\\<rbrakk>\n  \\<Longrightarrow> (?g \\<circ> ?f has_vector_derivative ?f' *\\<^sub>R ?g')\n                     (at ?x within ?s)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (u - t) * poly f t) has_contour_integral I f u)\n     (linepath 0 u)", "let ?g = \"\\<lambda>t. 1 - t\" and ?f = \"\\<lambda>t. -exp (t *\\<^sub>R u)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (u - t) * poly f t) has_contour_integral I f u)\n     (linepath 0 u)", "have \"((\\<lambda>t. exp ((1 - t) *\\<^sub>R u) * u) has_integral\n          (?f \\<circ> ?g) 1 - (?f \\<circ> ?g) 0) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp ((1 - t) *\\<^sub>R u) * u) has_integral\n     ((\\<lambda>t. - exp (t *\\<^sub>R u)) \\<circ> (-) 1) 1 -\n     ((\\<lambda>t. - exp (t *\\<^sub>R u)) \\<circ> (-) 1) 0)\n     {0..1}", "by (rule fundamental_theorem_of_calculus)\n       (auto intro!: derivative_eq_intros simp del: o_apply)"], ["proof (state)\nthis:\n  ((\\<lambda>t. exp ((1 - t) *\\<^sub>R u) * u) has_integral\n   ((\\<lambda>t. - exp (t *\\<^sub>R u)) \\<circ> (-) 1) 1 -\n   ((\\<lambda>t. - exp (t *\\<^sub>R u)) \\<circ> (-) 1) 0)\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (u - t) * poly f t) has_contour_integral I f u)\n     (linepath 0 u)", "hence aux_integral: \"((\\<lambda>t. exp (u - t *\\<^sub>R u) * u) has_integral exp u - 1) {0..1}\""], ["proof (prove)\nusing this:\n  ((\\<lambda>t. exp ((1 - t) *\\<^sub>R u) * u) has_integral\n   ((\\<lambda>t. - exp (t *\\<^sub>R u)) \\<circ> (-) 1) 1 -\n   ((\\<lambda>t. - exp (t *\\<^sub>R u)) \\<circ> (-) 1) 0)\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (u - t *\\<^sub>R u) * u) has_integral exp u - 1)\n     {0..1}", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  ((\\<lambda>t. exp (u - t *\\<^sub>R u) * u) has_integral exp u - 1) {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (u - t) * poly f t) has_contour_integral I f u)\n     (linepath 0 u)", "have \"((\\<lambda>t. exp (u - t *\\<^sub>R u) * u * poly f (t *\\<^sub>R u)) has_integral I f u) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         exp (u - t *\\<^sub>R u) * u * poly f (t *\\<^sub>R u)) has_integral\n     I f u)\n     {0..1}", "unfolding df_def m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         exp (u - t *\\<^sub>R u) * u * poly f (t *\\<^sub>R u)) has_integral\n     I f u)\n     {0..1}", "proof (induction \"degree f\" arbitrary: f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       0 = degree f \\<Longrightarrow>\n       ((\\<lambda>t.\n            exp (u - t *\\<^sub>R u) * u *\n            poly f (t *\\<^sub>R u)) has_integral\n        I f u)\n        {0..1}\n 2. \\<And>x f.\n       \\<lbrakk>\\<And>f.\n                   x = degree f \\<Longrightarrow>\n                   ((\\<lambda>t.\n                        exp (u - t *\\<^sub>R u) * u *\n                        poly f (t *\\<^sub>R u)) has_integral\n                    I f u)\n                    {0..1};\n        Suc x = degree f\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>t.\n                              exp (u - t *\\<^sub>R u) * u *\n                              poly f (t *\\<^sub>R u)) has_integral\n                          I f u)\n                          {0..1}", "case 0"], ["proof (state)\nthis:\n  0 = degree f\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       0 = degree f \\<Longrightarrow>\n       ((\\<lambda>t.\n            exp (u - t *\\<^sub>R u) * u *\n            poly f (t *\\<^sub>R u)) has_integral\n        I f u)\n        {0..1}\n 2. \\<And>x f.\n       \\<lbrakk>\\<And>f.\n                   x = degree f \\<Longrightarrow>\n                   ((\\<lambda>t.\n                        exp (u - t *\\<^sub>R u) * u *\n                        poly f (t *\\<^sub>R u)) has_integral\n                    I f u)\n                    {0..1};\n        Suc x = degree f\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>t.\n                              exp (u - t *\\<^sub>R u) * u *\n                              poly f (t *\\<^sub>R u)) has_integral\n                          I f u)\n                          {0..1}", "then"], ["proof (chain)\npicking this:\n  0 = degree f", "obtain c where c: \"f = [:c:]\""], ["proof (prove)\nusing this:\n  0 = degree f\n\ngoal (1 subgoal):\n 1. (\\<And>c. f = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto elim: degree_eq_zeroE)"], ["proof (state)\nthis:\n  f = [:c:]\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       0 = degree f \\<Longrightarrow>\n       ((\\<lambda>t.\n            exp (u - t *\\<^sub>R u) * u *\n            poly f (t *\\<^sub>R u)) has_integral\n        I f u)\n        {0..1}\n 2. \\<And>x f.\n       \\<lbrakk>\\<And>f.\n                   x = degree f \\<Longrightarrow>\n                   ((\\<lambda>t.\n                        exp (u - t *\\<^sub>R u) * u *\n                        poly f (t *\\<^sub>R u)) has_integral\n                    I f u)\n                    {0..1};\n        Suc x = degree f\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>t.\n                              exp (u - t *\\<^sub>R u) * u *\n                              poly f (t *\\<^sub>R u)) has_integral\n                          I f u)\n                          {0..1}", "have \"((\\<lambda>t. c * (exp (u - t *\\<^sub>R u) * u)) has_integral c * (exp u - 1)) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. c * (exp (u - t *\\<^sub>R u) * u)) has_integral\n     c * (exp u - 1))\n     {0..1}", "using aux_integral"], ["proof (prove)\nusing this:\n  ((\\<lambda>t. exp (u - t *\\<^sub>R u) * u) has_integral exp u - 1) {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. c * (exp (u - t *\\<^sub>R u) * u)) has_integral\n     c * (exp u - 1))\n     {0..1}", "by (rule has_integral_mult_right)"], ["proof (state)\nthis:\n  ((\\<lambda>t. c * (exp (u - t *\\<^sub>R u) * u)) has_integral\n   c * (exp u - 1))\n   {0..1}\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       0 = degree f \\<Longrightarrow>\n       ((\\<lambda>t.\n            exp (u - t *\\<^sub>R u) * u *\n            poly f (t *\\<^sub>R u)) has_integral\n        I f u)\n        {0..1}\n 2. \\<And>x f.\n       \\<lbrakk>\\<And>f.\n                   x = degree f \\<Longrightarrow>\n                   ((\\<lambda>t.\n                        exp (u - t *\\<^sub>R u) * u *\n                        poly f (t *\\<^sub>R u)) has_integral\n                    I f u)\n                    {0..1};\n        Suc x = degree f\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>t.\n                              exp (u - t *\\<^sub>R u) * u *\n                              poly f (t *\\<^sub>R u)) has_integral\n                          I f u)\n                          {0..1}", "with c"], ["proof (chain)\npicking this:\n  f = [:c:]\n  ((\\<lambda>t. c * (exp (u - t *\\<^sub>R u) * u)) has_integral\n   c * (exp u - 1))\n   {0..1}", "show ?case"], ["proof (prove)\nusing this:\n  f = [:c:]\n  ((\\<lambda>t. c * (exp (u - t *\\<^sub>R u) * u)) has_integral\n   c * (exp u - 1))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         exp (u - t *\\<^sub>R u) * u * poly f (t *\\<^sub>R u)) has_integral\n     I f u)\n     {0..1}", "by (simp add: algebra_simps I_def)"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       exp (u - t *\\<^sub>R u) * u * poly f (t *\\<^sub>R u)) has_integral\n   I f u)\n   {0..1}\n\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>\\<And>f.\n                   x = degree f \\<Longrightarrow>\n                   ((\\<lambda>t.\n                        exp (u - t *\\<^sub>R u) * u *\n                        poly f (t *\\<^sub>R u)) has_integral\n                    I f u)\n                    {0..1};\n        Suc x = degree f\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>t.\n                              exp (u - t *\\<^sub>R u) * u *\n                              poly f (t *\\<^sub>R u)) has_integral\n                          I f u)\n                          {0..1}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>\\<And>f.\n                   x = degree f \\<Longrightarrow>\n                   ((\\<lambda>t.\n                        exp (u - t *\\<^sub>R u) * u *\n                        poly f (t *\\<^sub>R u)) has_integral\n                    I f u)\n                    {0..1};\n        Suc x = degree f\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>t.\n                              exp (u - t *\\<^sub>R u) * u *\n                              poly f (t *\\<^sub>R u)) has_integral\n                          I f u)\n                          {0..1}", "case (Suc m)"], ["proof (state)\nthis:\n  m = degree ?f1 \\<Longrightarrow>\n  ((\\<lambda>t.\n       exp (u - t *\\<^sub>R u) * u * poly ?f1 (t *\\<^sub>R u)) has_integral\n   I ?f1 u)\n   {0..1}\n  Suc m = degree f\n\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>\\<And>f.\n                   x = degree f \\<Longrightarrow>\n                   ((\\<lambda>t.\n                        exp (u - t *\\<^sub>R u) * u *\n                        poly f (t *\\<^sub>R u)) has_integral\n                    I f u)\n                    {0..1};\n        Suc x = degree f\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>t.\n                              exp (u - t *\\<^sub>R u) * u *\n                              poly f (t *\\<^sub>R u)) has_integral\n                          I f u)\n                          {0..1}", "define df where \"df = (\\<lambda>j. (pderiv ^^ j) f)\""], ["proof (state)\nthis:\n  df = (\\<lambda>j. (pderiv ^^ j) f)\n\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>\\<And>f.\n                   x = degree f \\<Longrightarrow>\n                   ((\\<lambda>t.\n                        exp (u - t *\\<^sub>R u) * u *\n                        poly f (t *\\<^sub>R u)) has_integral\n                    I f u)\n                    {0..1};\n        Suc x = degree f\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>t.\n                              exp (u - t *\\<^sub>R u) * u *\n                              poly f (t *\\<^sub>R u)) has_integral\n                          I f u)\n                          {0..1}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         exp (u - t *\\<^sub>R u) * u * poly f (t *\\<^sub>R u)) has_integral\n     I f u)\n     {0..1}", "proof (rule integration_by_parts[OF bounded_bilinear_mult])"], ["proof (state)\ngoal (6 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} ?f\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       (?f has_vector_derivative exp (u - t *\\<^sub>R u) * u) (at t)\n 5. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       ((\\<lambda>x. poly f (x *\\<^sub>R u)) has_vector_derivative ?g' t)\n        (at t)\n 6. ((\\<lambda>t. ?f t * ?g' t) has_integral\n     ?f 1 * poly f (1 *\\<^sub>R u) - ?f 0 * poly f (0 *\\<^sub>R u) - I f u)\n     {0..1}", "fix t :: real"], ["proof (state)\ngoal (6 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} ?f\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       (?f has_vector_derivative exp (u - t *\\<^sub>R u) * u) (at t)\n 5. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       ((\\<lambda>x. poly f (x *\\<^sub>R u)) has_vector_derivative ?g' t)\n        (at t)\n 6. ((\\<lambda>t. ?f t * ?g' t) has_integral\n     ?f 1 * poly f (1 *\\<^sub>R u) - ?f 0 * poly f (0 *\\<^sub>R u) - I f u)\n     {0..1}", "assume \"t \\<in> {0..1}\""], ["proof (state)\nthis:\n  t \\<in> {0..1}\n\ngoal (6 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} ?f\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       (?f has_vector_derivative exp (u - t *\\<^sub>R u) * u) (at t)\n 5. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       ((\\<lambda>x. poly f (x *\\<^sub>R u)) has_vector_derivative ?g' t)\n        (at t)\n 6. ((\\<lambda>t. ?f t * ?g' t) has_integral\n     ?f 1 * poly f (1 *\\<^sub>R u) - ?f 0 * poly f (0 *\\<^sub>R u) - I f u)\n     {0..1}", "have \"((?f \\<circ> ?g) has_vector_derivative exp (u - t *\\<^sub>R u) * u) (at t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. - exp (t *\\<^sub>R u)) \\<circ> (-) 1 has_vector_derivative\n     exp (u - t *\\<^sub>R u) * u)\n     (at t)", "by (auto intro!: derivative_eq_intros simp: algebra_simps simp del: o_apply)"], ["proof (state)\nthis:\n  ((\\<lambda>t. - exp (t *\\<^sub>R u)) \\<circ> (-) 1 has_vector_derivative\n   exp (u - t *\\<^sub>R u) * u)\n   (at t)\n\ngoal (6 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} ?f\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       (?f has_vector_derivative exp (u - t *\\<^sub>R u) * u) (at t)\n 5. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       ((\\<lambda>x. poly f (x *\\<^sub>R u)) has_vector_derivative ?g' t)\n        (at t)\n 6. ((\\<lambda>t. ?f t * ?g' t) has_integral\n     ?f 1 * poly f (1 *\\<^sub>R u) - ?f 0 * poly f (0 *\\<^sub>R u) - I f u)\n     {0..1}", "thus \"((\\<lambda>t. -exp (u - t *\\<^sub>R u)) has_vector_derivative exp (u - t *\\<^sub>R u) * u) (at t)\""], ["proof (prove)\nusing this:\n  ((\\<lambda>t. - exp (t *\\<^sub>R u)) \\<circ> (-) 1 has_vector_derivative\n   exp (u - t *\\<^sub>R u) * u)\n   (at t)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. - exp (u - t *\\<^sub>R u)) has_vector_derivative\n     exp (u - t *\\<^sub>R u) * u)\n     (at t)", "by (simp add: algebra_simps o_def)"], ["proof (state)\nthis:\n  ((\\<lambda>t. - exp (u - t *\\<^sub>R u)) has_vector_derivative\n   exp (u - t *\\<^sub>R u) * u)\n   (at t)\n\ngoal (5 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       ((\\<lambda>x. poly f (x *\\<^sub>R u)) has_vector_derivative ?g' t)\n        (at t)\n 5. ((\\<lambda>t. - exp (u - t *\\<^sub>R u) * ?g' t) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       ((\\<lambda>x. poly f (x *\\<^sub>R u)) has_vector_derivative ?g' t)\n        (at t)\n 5. ((\\<lambda>t. - exp (u - t *\\<^sub>R u) * ?g' t) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "fix t :: real"], ["proof (state)\ngoal (5 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       ((\\<lambda>x. poly f (x *\\<^sub>R u)) has_vector_derivative ?g' t)\n        (at t)\n 5. ((\\<lambda>t. - exp (u - t *\\<^sub>R u) * ?g' t) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "assume \"t \\<in> {0..1}\""], ["proof (state)\nthis:\n  t \\<in> {0..1}\n\ngoal (5 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       ((\\<lambda>x. poly f (x *\\<^sub>R u)) has_vector_derivative ?g' t)\n        (at t)\n 5. ((\\<lambda>t. - exp (u - t *\\<^sub>R u) * ?g' t) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "have \"(poly f \\<circ> (\\<lambda>t. t *\\<^sub>R u) has_vector_derivative u * poly (pderiv f) (t *\\<^sub>R u)) (at t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly f \\<circ> (\\<lambda>t. t *\\<^sub>R u) has_vector_derivative\n     u * poly (pderiv f) (t *\\<^sub>R u))\n     (at t)", "by (rule field_vector_diff_chain_at) (auto intro!: derivative_eq_intros)"], ["proof (state)\nthis:\n  (poly f \\<circ> (\\<lambda>t. t *\\<^sub>R u) has_vector_derivative\n   u * poly (pderiv f) (t *\\<^sub>R u))\n   (at t)\n\ngoal (5 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. \\<And>t.\n       t \\<in> {0..1} \\<Longrightarrow>\n       ((\\<lambda>x. poly f (x *\\<^sub>R u)) has_vector_derivative ?g' t)\n        (at t)\n 5. ((\\<lambda>t. - exp (u - t *\\<^sub>R u) * ?g' t) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "thus \"((\\<lambda>t. poly f (t *\\<^sub>R u)) has_vector_derivative u * poly (pderiv f) (t *\\<^sub>R u)) (at t)\""], ["proof (prove)\nusing this:\n  (poly f \\<circ> (\\<lambda>t. t *\\<^sub>R u) has_vector_derivative\n   u * poly (pderiv f) (t *\\<^sub>R u))\n   (at t)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. poly f (t *\\<^sub>R u)) has_vector_derivative\n     u * poly (pderiv f) (t *\\<^sub>R u))\n     (at t)", "by (simp add: o_def)"], ["proof (state)\nthis:\n  ((\\<lambda>t. poly f (t *\\<^sub>R u)) has_vector_derivative\n   u * poly (pderiv f) (t *\\<^sub>R u))\n   (at t)\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "from Suc(2)"], ["proof (chain)\npicking this:\n  Suc m = degree f", "have m: \"m = degree (pderiv f)\""], ["proof (prove)\nusing this:\n  Suc m = degree f\n\ngoal (1 subgoal):\n 1. m = degree (pderiv f)", "by (simp add: degree_pderiv)"], ["proof (state)\nthis:\n  m = degree (pderiv f)\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "from Suc(1)[OF this] this"], ["proof (chain)\npicking this:\n  ((\\<lambda>t.\n       exp (u - t *\\<^sub>R u) * u *\n       poly (pderiv f) (t *\\<^sub>R u)) has_integral\n   I (pderiv f) u)\n   {0..1}\n  m = degree (pderiv f)", "have \"((\\<lambda>t. exp (u - t *\\<^sub>R u) * u * poly (pderiv f) (t *\\<^sub>R u)) has_integral\n                exp u * (\\<Sum>j=0..m. poly (df (Suc j)) 0) - (\\<Sum>j=0..m. poly (df (Suc j)) u)) {0..1}\""], ["proof (prove)\nusing this:\n  ((\\<lambda>t.\n       exp (u - t *\\<^sub>R u) * u *\n       poly (pderiv f) (t *\\<^sub>R u)) has_integral\n   I (pderiv f) u)\n   {0..1}\n  m = degree (pderiv f)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         exp (u - t *\\<^sub>R u) * u *\n         poly (pderiv f) (t *\\<^sub>R u)) has_integral\n     exp u * (\\<Sum>j = 0..m. poly (df (Suc j)) 0) -\n     (\\<Sum>j = 0..m. poly (df (Suc j)) u))\n     {0..1}", "by (simp add: df_def funpow_swap1 atMost_atLeast0 I_def)"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       exp (u - t *\\<^sub>R u) * u *\n       poly (pderiv f) (t *\\<^sub>R u)) has_integral\n   exp u * (\\<Sum>j = 0..m. poly (df (Suc j)) 0) -\n   (\\<Sum>j = 0..m. poly (df (Suc j)) u))\n   {0..1}\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "also"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       exp (u - t *\\<^sub>R u) * u *\n       poly (pderiv f) (t *\\<^sub>R u)) has_integral\n   exp u * (\\<Sum>j = 0..m. poly (df (Suc j)) 0) -\n   (\\<Sum>j = 0..m. poly (df (Suc j)) u))\n   {0..1}\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "have \"(\\<Sum>j=0..m. poly (df (Suc j)) 0) = (\\<Sum>j=Suc 0..Suc m. poly (df j) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..m. poly (df (Suc j)) 0) =\n    (\\<Sum>j = Suc 0..Suc m. poly (df j) 0)", "by (rule sum.shift_bounds_cl_Suc_ivl [symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..m. poly (df (Suc j)) 0) =\n  (\\<Sum>j = Suc 0..Suc m. poly (df j) 0)\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..m. poly (df (Suc j)) 0) =\n  (\\<Sum>j = Suc 0..Suc m. poly (df j) 0)\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "have \"\\<dots> = (\\<Sum>j=0..Suc m. poly (df j) 0) - poly f 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = Suc 0..Suc m. poly (df j) 0) =\n    (\\<Sum>j = 0..Suc m. poly (df j) 0) - poly f 0", "by (subst (2) sum.atLeast_Suc_atMost) (simp_all add: df_def)"], ["proof (state)\nthis:\n  (\\<Sum>j = Suc 0..Suc m. poly (df j) 0) =\n  (\\<Sum>j = 0..Suc m. poly (df j) 0) - poly f 0\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = Suc 0..Suc m. poly (df j) 0) =\n  (\\<Sum>j = 0..Suc m. poly (df j) 0) - poly f 0\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "have \"(\\<Sum>j=0..m. poly (df (Suc j)) u) = (\\<Sum>j=Suc 0..Suc m. poly (df j) u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..m. poly (df (Suc j)) u) =\n    (\\<Sum>j = Suc 0..Suc m. poly (df j) u)", "by (rule sum.shift_bounds_cl_Suc_ivl [symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..m. poly (df (Suc j)) u) =\n  (\\<Sum>j = Suc 0..Suc m. poly (df j) u)\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..m. poly (df (Suc j)) u) =\n  (\\<Sum>j = Suc 0..Suc m. poly (df j) u)\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "have \"\\<dots> = (\\<Sum>j=0..Suc m. poly (df j) u) - poly f u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = Suc 0..Suc m. poly (df j) u) =\n    (\\<Sum>j = 0..Suc m. poly (df j) u) - poly f u", "by (subst (2) sum.atLeast_Suc_atMost) (simp_all add: df_def)"], ["proof (state)\nthis:\n  (\\<Sum>j = Suc 0..Suc m. poly (df j) u) =\n  (\\<Sum>j = 0..Suc m. poly (df j) u) - poly f u\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>t.\n       exp (u - t *\\<^sub>R u) * u *\n       poly (pderiv f) (t *\\<^sub>R u)) has_integral\n   exp u * ((\\<Sum>j = 0..Suc m. poly (df j) 0) - poly f 0) -\n   ((\\<Sum>j = 0..Suc m. poly (df j) u) - poly f u))\n   {0..1}", "have \"((\\<lambda>t. - (exp (u - t *\\<^sub>R u) * u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n                        -(exp u * ((\\<Sum>j = 0..Suc m. poly (df j) 0) - poly f 0) -\n                                  ((\\<Sum>j = 0..Suc m. poly (df j) u) - poly f u))) {0..1}\"\n          (is \"(_ has_integral ?I) _\")"], ["proof (prove)\nusing this:\n  ((\\<lambda>t.\n       exp (u - t *\\<^sub>R u) * u *\n       poly (pderiv f) (t *\\<^sub>R u)) has_integral\n   exp u * ((\\<Sum>j = 0..Suc m. poly (df j) 0) - poly f 0) -\n   ((\\<Sum>j = 0..Suc m. poly (df j) u) - poly f u))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         - (exp (u - t *\\<^sub>R u) * u *\n            poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - (exp u * ((\\<Sum>j = 0..Suc m. poly (df j) 0) - poly f 0) -\n        ((\\<Sum>j = 0..Suc m. poly (df j) u) - poly f u)))\n     {0..1}", "by (rule has_integral_neg)"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       - (exp (u - t *\\<^sub>R u) * u *\n          poly (pderiv f) (t *\\<^sub>R u))) has_integral\n   - (exp u * ((\\<Sum>j = 0..Suc m. poly (df j) 0) - poly f 0) -\n      ((\\<Sum>j = 0..Suc m. poly (df j) u) - poly f u)))\n   {0..1}\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "also"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       - (exp (u - t *\\<^sub>R u) * u *\n          poly (pderiv f) (t *\\<^sub>R u))) has_integral\n   - (exp u * ((\\<Sum>j = 0..Suc m. poly (df j) 0) - poly f 0) -\n      ((\\<Sum>j = 0..Suc m. poly (df j) u) - poly f u)))\n   {0..1}\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "have \"?I = - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n                       - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) - I f u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (exp u * ((\\<Sum>j = 0..Suc m. poly (df j) 0) - poly f 0) -\n       ((\\<Sum>j = 0..Suc m. poly (df j) u) - poly f u)) =\n    - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n    - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n    I f u", "by (simp add: df_def algebra_simps Suc(2) atMost_atLeast0 I_def)"], ["proof (state)\nthis:\n  - (exp u * ((\\<Sum>j = 0..Suc m. poly (df j) 0) - poly f 0) -\n     ((\\<Sum>j = 0..Suc m. poly (df j) u) - poly f u)) =\n  - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n  - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n  I f u\n\ngoal (4 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))\n 4. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>t.\n       - (exp (u - t *\\<^sub>R u) * u *\n          poly (pderiv f) (t *\\<^sub>R u))) has_integral\n   - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n   - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n   I f u)\n   {0..1}", "show \"((\\<lambda>t. - exp (u - t *\\<^sub>R u) * (u * poly (pderiv f) (t *\\<^sub>R u)))\n                        has_integral \\<dots>) {0..1}\""], ["proof (prove)\nusing this:\n  ((\\<lambda>t.\n       - (exp (u - t *\\<^sub>R u) * u *\n          poly (pderiv f) (t *\\<^sub>R u))) has_integral\n   - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n   - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n   I f u)\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         - exp (u - t *\\<^sub>R u) *\n         (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n     - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n     - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n     I f u)\n     {0..1}", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       - exp (u - t *\\<^sub>R u) *\n       (u * poly (pderiv f) (t *\\<^sub>R u))) has_integral\n   - exp (u - 1 *\\<^sub>R u) * poly f (1 *\\<^sub>R u) -\n   - exp (u - 0 *\\<^sub>R u) * poly f (0 *\\<^sub>R u) -\n   I f u)\n   {0..1}\n\ngoal (3 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} (\\<lambda>t. - exp (u - t *\\<^sub>R u))\n 3. continuous_on {0..1} (\\<lambda>x. poly f (x *\\<^sub>R u))", "qed (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       exp (u - t *\\<^sub>R u) * u * poly f (t *\\<^sub>R u)) has_integral\n   I f u)\n   {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       exp (u - t *\\<^sub>R u) * u * poly f (t *\\<^sub>R u)) has_integral\n   I f u)\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (u - t) * poly f t) has_contour_integral I f u)\n     (linepath 0 u)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>t.\n       exp (u - t *\\<^sub>R u) * u * poly f (t *\\<^sub>R u)) has_integral\n   I f u)\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (u - t) * poly f t) has_contour_integral I f u)\n     (linepath 0 u)", "by (simp add: has_contour_integral_linepath algebra_simps)"], ["proof (state)\nthis:\n  ((\\<lambda>t. exp (u - t) * poly f t) has_contour_integral I f u)\n   (linepath 0 u)\n\ngoal:\nNo subgoals!", "qed"], ["", "locale lindemann_weierstrass_aux =\n  fixes f :: \"complex poly\"\nbegin"], ["", "definition I :: \"complex \\<Rightarrow> complex\" where\n  \"I u = exp u * (\\<Sum>j\\<le>degree f. poly ((pderiv ^^ j) f) 0) -\n                       (\\<Sum>j\\<le>degree f. poly ((pderiv ^^ j) f) u)\""], ["", "lemma lindemann_weierstrass_integral_bound:\n  fixes u :: complex\n  assumes \"C \\<ge> 0\" \"\\<And>t. t \\<in> closed_segment 0 u \\<Longrightarrow> norm (poly f t) \\<le> C\"\n  shows \"norm (I u) \\<le> norm u * exp (norm u) * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (I u) \\<le> cmod u * exp (cmod u) * C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (I u) \\<le> cmod u * exp (cmod u) * C", "have \"I u = contour_integral (linepath 0 u) (\\<lambda>t. exp (u - t) * poly f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I u =\n    contour_integral (linepath 0 u) (\\<lambda>t. exp (u - t) * poly f t)", "using contour_integral_unique[OF lindemann_weierstrass_integral[of u f]]"], ["proof (prove)\nusing this:\n  contour_integral (linepath 0 u) (\\<lambda>t. exp (u - t) * poly f t) =\n  exp u * (\\<Sum>j\\<le>degree f. poly ((pderiv ^^ j) f) 0) -\n  (\\<Sum>j\\<le>degree f. poly ((pderiv ^^ j) f) u)\n\ngoal (1 subgoal):\n 1. I u =\n    contour_integral (linepath 0 u) (\\<lambda>t. exp (u - t) * poly f t)", "unfolding I_def"], ["proof (prove)\nusing this:\n  contour_integral (linepath 0 u) (\\<lambda>t. exp (u - t) * poly f t) =\n  exp u * (\\<Sum>j\\<le>degree f. poly ((pderiv ^^ j) f) 0) -\n  (\\<Sum>j\\<le>degree f. poly ((pderiv ^^ j) f) u)\n\ngoal (1 subgoal):\n 1. exp u * (\\<Sum>j\\<le>degree f. poly ((pderiv ^^ j) f) 0) -\n    (\\<Sum>j\\<le>degree f. poly ((pderiv ^^ j) f) u) =\n    contour_integral (linepath 0 u) (\\<lambda>t. exp (u - t) * poly f t)", ".."], ["proof (state)\nthis:\n  I u = contour_integral (linepath 0 u) (\\<lambda>t. exp (u - t) * poly f t)\n\ngoal (1 subgoal):\n 1. cmod (I u) \\<le> cmod u * exp (cmod u) * C", "also"], ["proof (state)\nthis:\n  I u = contour_integral (linepath 0 u) (\\<lambda>t. exp (u - t) * poly f t)\n\ngoal (1 subgoal):\n 1. cmod (I u) \\<le> cmod u * exp (cmod u) * C", "have \"norm \\<dots> \\<le> exp (norm u) * C * norm (u - 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (contour_integral (linepath 0 u) (\\<lambda>t. exp (u - t) * poly f t))\n    \\<le> exp (cmod u) * C * cmod (u - 0)", "proof (intro contour_integral_bound_linepath)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>t. exp (u - t) * poly f t) contour_integrable_on linepath 0 u\n 2. 0 \\<le> exp (cmod u) * C\n 3. \\<And>x.\n       x \\<in> closed_segment 0 u \\<Longrightarrow>\n       cmod (exp (u - x) * poly f x) \\<le> exp (cmod u) * C", "fix t"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>t. exp (u - t) * poly f t) contour_integrable_on linepath 0 u\n 2. 0 \\<le> exp (cmod u) * C\n 3. \\<And>x.\n       x \\<in> closed_segment 0 u \\<Longrightarrow>\n       cmod (exp (u - x) * poly f x) \\<le> exp (cmod u) * C", "assume t: \"t \\<in> closed_segment 0 u\""], ["proof (state)\nthis:\n  t \\<in> closed_segment 0 u\n\ngoal (3 subgoals):\n 1. (\\<lambda>t. exp (u - t) * poly f t) contour_integrable_on linepath 0 u\n 2. 0 \\<le> exp (cmod u) * C\n 3. \\<And>x.\n       x \\<in> closed_segment 0 u \\<Longrightarrow>\n       cmod (exp (u - x) * poly f x) \\<le> exp (cmod u) * C", "then"], ["proof (chain)\npicking this:\n  t \\<in> closed_segment 0 u", "obtain s where s: \"s \\<in> {0..1}\" \"t = s *\\<^sub>R u\""], ["proof (prove)\nusing this:\n  t \\<in> closed_segment 0 u\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> {0..1}; t = s *\\<^sub>R u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: closed_segment_def)"], ["proof (state)\nthis:\n  s \\<in> {0..1}\n  t = s *\\<^sub>R u\n\ngoal (3 subgoals):\n 1. (\\<lambda>t. exp (u - t) * poly f t) contour_integrable_on linepath 0 u\n 2. 0 \\<le> exp (cmod u) * C\n 3. \\<And>x.\n       x \\<in> closed_segment 0 u \\<Longrightarrow>\n       cmod (exp (u - x) * poly f x) \\<le> exp (cmod u) * C", "hence \"s * norm u \\<le> 1 * norm u\""], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n  t = s *\\<^sub>R u\n\ngoal (1 subgoal):\n 1. s * cmod u \\<le> 1 * cmod u", "by (intro mult_right_mono) simp_all"], ["proof (state)\nthis:\n  s * cmod u \\<le> 1 * cmod u\n\ngoal (3 subgoals):\n 1. (\\<lambda>t. exp (u - t) * poly f t) contour_integrable_on linepath 0 u\n 2. 0 \\<le> exp (cmod u) * C\n 3. \\<And>x.\n       x \\<in> closed_segment 0 u \\<Longrightarrow>\n       cmod (exp (u - x) * poly f x) \\<le> exp (cmod u) * C", "with s"], ["proof (chain)\npicking this:\n  s \\<in> {0..1}\n  t = s *\\<^sub>R u\n  s * cmod u \\<le> 1 * cmod u", "have norm_t: \"norm t \\<le> norm u\""], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n  t = s *\\<^sub>R u\n  s * cmod u \\<le> 1 * cmod u\n\ngoal (1 subgoal):\n 1. cmod t \\<le> cmod u", "by auto"], ["proof (state)\nthis:\n  cmod t \\<le> cmod u\n\ngoal (3 subgoals):\n 1. (\\<lambda>t. exp (u - t) * poly f t) contour_integrable_on linepath 0 u\n 2. 0 \\<le> exp (cmod u) * C\n 3. \\<And>x.\n       x \\<in> closed_segment 0 u \\<Longrightarrow>\n       cmod (exp (u - x) * poly f x) \\<le> exp (cmod u) * C", "from s"], ["proof (chain)\npicking this:\n  s \\<in> {0..1}\n  t = s *\\<^sub>R u", "have \"Re u - Re t = (1 - s) * Re u\""], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n  t = s *\\<^sub>R u\n\ngoal (1 subgoal):\n 1. Re u - Re t = (1 - s) * Re u", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  Re u - Re t = (1 - s) * Re u\n\ngoal (3 subgoals):\n 1. (\\<lambda>t. exp (u - t) * poly f t) contour_integrable_on linepath 0 u\n 2. 0 \\<le> exp (cmod u) * C\n 3. \\<And>x.\n       x \\<in> closed_segment 0 u \\<Longrightarrow>\n       cmod (exp (u - x) * poly f x) \\<le> exp (cmod u) * C", "also"], ["proof (state)\nthis:\n  Re u - Re t = (1 - s) * Re u\n\ngoal (3 subgoals):\n 1. (\\<lambda>t. exp (u - t) * poly f t) contour_integrable_on linepath 0 u\n 2. 0 \\<le> exp (cmod u) * C\n 3. \\<And>x.\n       x \\<in> closed_segment 0 u \\<Longrightarrow>\n       cmod (exp (u - x) * poly f x) \\<le> exp (cmod u) * C", "have \"\\<dots> \\<le> norm u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - s) * Re u \\<le> cmod u", "proof (cases \"Re u \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u\n 2. \\<not> 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u", "case True"], ["proof (state)\nthis:\n  0 \\<le> Re u\n\ngoal (2 subgoals):\n 1. 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u\n 2. \\<not> 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u", "with \\<open>s \\<in> {0..1}\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> {0..1}\n  0 \\<le> Re u", "have \"(1 - s) * Re u \\<le> 1 * Re u\""], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n  0 \\<le> Re u\n\ngoal (1 subgoal):\n 1. (1 - s) * Re u \\<le> 1 * Re u", "by (intro mult_right_mono) simp_all"], ["proof (state)\nthis:\n  (1 - s) * Re u \\<le> 1 * Re u\n\ngoal (2 subgoals):\n 1. 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u\n 2. \\<not> 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u", "also"], ["proof (state)\nthis:\n  (1 - s) * Re u \\<le> 1 * Re u\n\ngoal (2 subgoals):\n 1. 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u\n 2. \\<not> 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u", "have \"Re u \\<le> norm u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re u \\<le> cmod u", "by (rule complex_Re_le_cmod)"], ["proof (state)\nthis:\n  Re u \\<le> cmod u\n\ngoal (2 subgoals):\n 1. 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u\n 2. \\<not> 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> 1 * x \\<le> 1 * y) \\<Longrightarrow>\n  (1 - s) * Re u \\<le> 1 * cmod u", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> 1 * x \\<le> 1 * y) \\<Longrightarrow>\n  (1 - s) * Re u \\<le> 1 * cmod u\n\ngoal (1 subgoal):\n 1. (1 - s) * Re u \\<le> cmod u", "by simp"], ["proof (state)\nthis:\n  (1 - s) * Re u \\<le> cmod u\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> Re u\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u", "with \\<open>s \\<in> {0..1}\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> {0..1}\n  \\<not> 0 \\<le> Re u", "have \"(1 - s) * Re u \\<le> 0\""], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n  \\<not> 0 \\<le> Re u\n\ngoal (1 subgoal):\n 1. (1 - s) * Re u \\<le> 0", "by (intro mult_nonneg_nonpos) simp_all"], ["proof (state)\nthis:\n  (1 - s) * Re u \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u", "also"], ["proof (state)\nthis:\n  (1 - s) * Re u \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u", "have \"\\<dots> \\<le> norm u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cmod u", "by simp"], ["proof (state)\nthis:\n  0 \\<le> cmod u\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> Re u \\<Longrightarrow> (1 - s) * Re u \\<le> cmod u", "finally"], ["proof (chain)\npicking this:\n  (1 - s) * Re u \\<le> cmod u", "show ?thesis"], ["proof (prove)\nusing this:\n  (1 - s) * Re u \\<le> cmod u\n\ngoal (1 subgoal):\n 1. (1 - s) * Re u \\<le> cmod u", "."], ["proof (state)\nthis:\n  (1 - s) * Re u \\<le> cmod u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (1 - s) * Re u \\<le> cmod u\n\ngoal (3 subgoals):\n 1. (\\<lambda>t. exp (u - t) * poly f t) contour_integrable_on linepath 0 u\n 2. 0 \\<le> exp (cmod u) * C\n 3. \\<And>x.\n       x \\<in> closed_segment 0 u \\<Longrightarrow>\n       cmod (exp (u - x) * poly f x) \\<le> exp (cmod u) * C", "finally"], ["proof (chain)\npicking this:\n  Re u - Re t \\<le> cmod u", "have \"exp (Re u - Re t) \\<le> exp (norm u)\""], ["proof (prove)\nusing this:\n  Re u - Re t \\<le> cmod u\n\ngoal (1 subgoal):\n 1. exp (Re u - Re t) \\<le> exp (cmod u)", "by simp"], ["proof (state)\nthis:\n  exp (Re u - Re t) \\<le> exp (cmod u)\n\ngoal (3 subgoals):\n 1. (\\<lambda>t. exp (u - t) * poly f t) contour_integrable_on linepath 0 u\n 2. 0 \\<le> exp (cmod u) * C\n 3. \\<And>x.\n       x \\<in> closed_segment 0 u \\<Longrightarrow>\n       cmod (exp (u - x) * poly f x) \\<le> exp (cmod u) * C", "hence \"exp (Re u - Re t) * norm (poly f t) \\<le> exp (norm u) * C\""], ["proof (prove)\nusing this:\n  exp (Re u - Re t) \\<le> exp (cmod u)\n\ngoal (1 subgoal):\n 1. exp (Re u - Re t) * cmod (poly f t) \\<le> exp (cmod u) * C", "using assms t norm_t"], ["proof (prove)\nusing this:\n  exp (Re u - Re t) \\<le> exp (cmod u)\n  0 \\<le> C\n  ?t \\<in> closed_segment 0 u \\<Longrightarrow> cmod (poly f ?t) \\<le> C\n  t \\<in> closed_segment 0 u\n  cmod t \\<le> cmod u\n\ngoal (1 subgoal):\n 1. exp (Re u - Re t) * cmod (poly f t) \\<le> exp (cmod u) * C", "by (intro mult_mono) simp_all"], ["proof (state)\nthis:\n  exp (Re u - Re t) * cmod (poly f t) \\<le> exp (cmod u) * C\n\ngoal (3 subgoals):\n 1. (\\<lambda>t. exp (u - t) * poly f t) contour_integrable_on linepath 0 u\n 2. 0 \\<le> exp (cmod u) * C\n 3. \\<And>x.\n       x \\<in> closed_segment 0 u \\<Longrightarrow>\n       cmod (exp (u - x) * poly f x) \\<le> exp (cmod u) * C", "thus \"norm (exp (u - t) * poly f t) \\<le> exp (norm u) * C\""], ["proof (prove)\nusing this:\n  exp (Re u - Re t) * cmod (poly f t) \\<le> exp (cmod u) * C\n\ngoal (1 subgoal):\n 1. cmod (exp (u - t) * poly f t) \\<le> exp (cmod u) * C", "by (simp add: norm_mult exp_diff norm_divide field_simps)"], ["proof (state)\nthis:\n  cmod (exp (u - t) * poly f t) \\<le> exp (cmod u) * C\n\ngoal (2 subgoals):\n 1. (\\<lambda>t. exp (u - t) * poly f t) contour_integrable_on linepath 0 u\n 2. 0 \\<le> exp (cmod u) * C", "qed (auto simp: intro!: mult_nonneg_nonneg contour_integrable_continuous_linepath\n                          continuous_intros assms)"], ["proof (state)\nthis:\n  cmod\n   (contour_integral (linepath 0 u) (\\<lambda>t. exp (u - t) * poly f t))\n  \\<le> exp (cmod u) * C * cmod (u - 0)\n\ngoal (1 subgoal):\n 1. cmod (I u) \\<le> cmod u * exp (cmod u) * C", "finally"], ["proof (chain)\npicking this:\n  cmod (I u) \\<le> exp (cmod u) * C * cmod (u - 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (I u) \\<le> exp (cmod u) * C * cmod (u - 0)\n\ngoal (1 subgoal):\n 1. cmod (I u) \\<le> cmod u * exp (cmod u) * C", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  cmod (I u) \\<le> cmod u * exp (cmod u) * C\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma poly_higher_pderiv_aux1:\n  fixes c :: \"'a :: idom\"\n  assumes \"k < n\"\n  shows   \"poly ((pderiv ^^ k) ([:-c, 1:] ^ n * p)) c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)", "proof (induction k arbitrary: n p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p.\n       0 < n \\<Longrightarrow>\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)\n 2. \\<And>k n p.\n       \\<lbrakk>\\<And>n p.\n                   k < n \\<Longrightarrow>\n                   poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * p)) c =\n                   (0::'a);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p))\n                          c =\n                         (0::'a)", "case (Suc k n p)"], ["proof (state)\nthis:\n  k < ?n \\<Longrightarrow>\n  poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ ?n * ?p)) c = (0::'a)\n  Suc k < n\n\ngoal (2 subgoals):\n 1. \\<And>n p.\n       0 < n \\<Longrightarrow>\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)\n 2. \\<And>k n p.\n       \\<lbrakk>\\<And>n p.\n                   k < n \\<Longrightarrow>\n                   poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * p)) c =\n                   (0::'a);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p))\n                          c =\n                         (0::'a)", "from Suc.prems"], ["proof (chain)\npicking this:\n  Suc k < n", "obtain n' where n: \"n = Suc n'\""], ["proof (prove)\nusing this:\n  Suc k < n\n\ngoal (1 subgoal):\n 1. (\\<And>n'. n = Suc n' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) auto"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (2 subgoals):\n 1. \\<And>n p.\n       0 < n \\<Longrightarrow>\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)\n 2. \\<And>k n p.\n       \\<lbrakk>\\<And>n p.\n                   k < n \\<Longrightarrow>\n                   poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * p)) c =\n                   (0::'a);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p))\n                          c =\n                         (0::'a)", "from Suc.prems n"], ["proof (chain)\npicking this:\n  Suc k < n\n  n = Suc n'", "have \"k < n'\""], ["proof (prove)\nusing this:\n  Suc k < n\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. k < n'", "by simp"], ["proof (state)\nthis:\n  k < n'\n\ngoal (2 subgoals):\n 1. \\<And>n p.\n       0 < n \\<Longrightarrow>\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)\n 2. \\<And>k n p.\n       \\<lbrakk>\\<And>n p.\n                   k < n \\<Longrightarrow>\n                   poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * p)) c =\n                   (0::'a);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p))\n                          c =\n                         (0::'a)", "have \"(pderiv ^^ Suc k) ([:- c, 1:] ^ n * p) =\n          (pderiv ^^ k) ([:- c, 1:] ^ n * pderiv p + [:- c, 1:] ^ n' * smult (of_nat n) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p) =\n    (pderiv ^^ k)\n     ([:- c, 1::'a:] ^ n * pderiv p +\n      [:- c, 1::'a:] ^ n' * Polynomial.smult (of_nat n) p)", "by (simp only: funpow_Suc_right o_def pderiv_mult n pderiv_power_Suc,\n        simp only: n [symmetric]) (simp add: pderiv_pCons mult_ac)"], ["proof (state)\nthis:\n  (pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p) =\n  (pderiv ^^ k)\n   ([:- c, 1::'a:] ^ n * pderiv p +\n    [:- c, 1::'a:] ^ n' * Polynomial.smult (of_nat n) p)\n\ngoal (2 subgoals):\n 1. \\<And>n p.\n       0 < n \\<Longrightarrow>\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)\n 2. \\<And>k n p.\n       \\<lbrakk>\\<And>n p.\n                   k < n \\<Longrightarrow>\n                   poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * p)) c =\n                   (0::'a);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p))\n                          c =\n                         (0::'a)", "also"], ["proof (state)\nthis:\n  (pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p) =\n  (pderiv ^^ k)\n   ([:- c, 1::'a:] ^ n * pderiv p +\n    [:- c, 1::'a:] ^ n' * Polynomial.smult (of_nat n) p)\n\ngoal (2 subgoals):\n 1. \\<And>n p.\n       0 < n \\<Longrightarrow>\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)\n 2. \\<And>k n p.\n       \\<lbrakk>\\<And>n p.\n                   k < n \\<Longrightarrow>\n                   poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * p)) c =\n                   (0::'a);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p))\n                          c =\n                         (0::'a)", "from Suc.prems \\<open>k < n'\\<close>"], ["proof (chain)\npicking this:\n  Suc k < n\n  k < n'", "have \"poly \\<dots> c = 0\""], ["proof (prove)\nusing this:\n  Suc k < n\n  k < n'\n\ngoal (1 subgoal):\n 1. poly\n     ((pderiv ^^ k)\n       ([:- c, 1::'a:] ^ n * pderiv p +\n        [:- c, 1::'a:] ^ n' * Polynomial.smult (of_nat n) p))\n     c =\n    (0::'a)", "by (simp add: higher_pderiv_add Suc.IH del: mult_smult_right)"], ["proof (state)\nthis:\n  poly\n   ((pderiv ^^ k)\n     ([:- c, 1::'a:] ^ n * pderiv p +\n      [:- c, 1::'a:] ^ n' * Polynomial.smult (of_nat n) p))\n   c =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>n p.\n       0 < n \\<Longrightarrow>\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)\n 2. \\<And>k n p.\n       \\<lbrakk>\\<And>n p.\n                   k < n \\<Longrightarrow>\n                   poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * p)) c =\n                   (0::'a);\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p))\n                          c =\n                         (0::'a)", "finally"], ["proof (chain)\npicking this:\n  poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)", "show ?case"], ["proof (prove)\nusing this:\n  poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)", "."], ["proof (state)\nthis:\n  poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       0 < n \\<Longrightarrow>\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ n * p)) c = (0::'a)", "qed simp_all"], ["", "lemma poly_higher_pderiv_aux1':\n  fixes c :: \"'a :: idom\"\n  assumes \"k < n\" \"[:-c, 1:] ^ n dvd p\"\n  shows   \"poly ((pderiv ^^ k) p) c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ k) p) c = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ k) p) c = (0::'a)", "from assms(2)"], ["proof (chain)\npicking this:\n  [:- c, 1::'a:] ^ n dvd p", "obtain q where \"p = [:-c, 1:] ^ n * q\""], ["proof (prove)\nusing this:\n  [:- c, 1::'a:] ^ n dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = [:- c, 1::'a:] ^ n * q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE)"], ["proof (state)\nthis:\n  p = [:- c, 1::'a:] ^ n * q\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ k) p) c = (0::'a)", "also"], ["proof (state)\nthis:\n  p = [:- c, 1::'a:] ^ n * q\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ k) p) c = (0::'a)", "from assms(1)"], ["proof (chain)\npicking this:\n  k < n", "have \"poly ((pderiv ^^ k) \\<dots>) c = 0\""], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * q)) c = (0::'a)", "by (rule poly_higher_pderiv_aux1)"], ["proof (state)\nthis:\n  poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * q)) c = (0::'a)\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ k) p) c = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  poly ((pderiv ^^ k) p) c = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly ((pderiv ^^ k) p) c = (0::'a)\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ k) p) c = (0::'a)", "."], ["proof (state)\nthis:\n  poly ((pderiv ^^ k) p) c = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_higher_pderiv_aux2:\n  fixes c :: \"'a :: {idom, semiring_char_0}\"\n  shows   \"poly ((pderiv ^^ n) ([:-c, 1:] ^ n * p)) c = fact n * poly p c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ n) ([:- c, 1::'a:] ^ n * p)) c = fact n * poly p c", "proof (induction n arbitrary: p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ 0 * p)) c = fact 0 * poly p c\n 2. \\<And>n p.\n       (\\<And>p.\n           poly ((pderiv ^^ n) ([:- c, 1::'a:] ^ n * p)) c =\n           fact n * poly p c) \\<Longrightarrow>\n       poly ((pderiv ^^ Suc n) ([:- c, 1::'a:] ^ Suc n * p)) c =\n       fact (Suc n) * poly p c", "case (Suc n p)"], ["proof (state)\nthis:\n  poly ((pderiv ^^ n) ([:- c, 1::'a:] ^ n * ?p)) c = fact n * poly ?p c\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ 0 * p)) c = fact 0 * poly p c\n 2. \\<And>n p.\n       (\\<And>p.\n           poly ((pderiv ^^ n) ([:- c, 1::'a:] ^ n * p)) c =\n           fact n * poly p c) \\<Longrightarrow>\n       poly ((pderiv ^^ Suc n) ([:- c, 1::'a:] ^ Suc n * p)) c =\n       fact (Suc n) * poly p c", "have \"(pderiv ^^ Suc n) ([:- c, 1:] ^ Suc n * p) =\n          (pderiv ^^ n) ([:- c, 1:] ^ Suc n * pderiv p) +\n            (pderiv ^^ n) ([:- c, 1:] ^ n * smult (1 + of_nat n) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ Suc n) ([:- c, 1::'a:] ^ Suc n * p) =\n    (pderiv ^^ n) ([:- c, 1::'a:] ^ Suc n * pderiv p) +\n    (pderiv ^^ n)\n     ([:- c, 1::'a:] ^ n * Polynomial.smult ((1::'a) + of_nat n) p)", "by (simp del: funpow.simps power_Suc add: funpow_Suc_right pderiv_mult\n          pderiv_power_Suc higher_pderiv_add pderiv_pCons mult_ac)"], ["proof (state)\nthis:\n  (pderiv ^^ Suc n) ([:- c, 1::'a:] ^ Suc n * p) =\n  (pderiv ^^ n) ([:- c, 1::'a:] ^ Suc n * pderiv p) +\n  (pderiv ^^ n)\n   ([:- c, 1::'a:] ^ n * Polynomial.smult ((1::'a) + of_nat n) p)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ 0 * p)) c = fact 0 * poly p c\n 2. \\<And>n p.\n       (\\<And>p.\n           poly ((pderiv ^^ n) ([:- c, 1::'a:] ^ n * p)) c =\n           fact n * poly p c) \\<Longrightarrow>\n       poly ((pderiv ^^ Suc n) ([:- c, 1::'a:] ^ Suc n * p)) c =\n       fact (Suc n) * poly p c", "also"], ["proof (state)\nthis:\n  (pderiv ^^ Suc n) ([:- c, 1::'a:] ^ Suc n * p) =\n  (pderiv ^^ n) ([:- c, 1::'a:] ^ Suc n * pderiv p) +\n  (pderiv ^^ n)\n   ([:- c, 1::'a:] ^ n * Polynomial.smult ((1::'a) + of_nat n) p)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ 0 * p)) c = fact 0 * poly p c\n 2. \\<And>n p.\n       (\\<And>p.\n           poly ((pderiv ^^ n) ([:- c, 1::'a:] ^ n * p)) c =\n           fact n * poly p c) \\<Longrightarrow>\n       poly ((pderiv ^^ Suc n) ([:- c, 1::'a:] ^ Suc n * p)) c =\n       fact (Suc n) * poly p c", "have \"[:- c, 1:] ^ Suc n * pderiv p = [:- c, 1:] ^ n * ([:-c, 1:] * pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- c, 1::'a:] ^ Suc n * pderiv p =\n    [:- c, 1::'a:] ^ n * ([:- c, 1::'a:] * pderiv p)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  [:- c, 1::'a:] ^ Suc n * pderiv p =\n  [:- c, 1::'a:] ^ n * ([:- c, 1::'a:] * pderiv p)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ 0 * p)) c = fact 0 * poly p c\n 2. \\<And>n p.\n       (\\<And>p.\n           poly ((pderiv ^^ n) ([:- c, 1::'a:] ^ n * p)) c =\n           fact n * poly p c) \\<Longrightarrow>\n       poly ((pderiv ^^ Suc n) ([:- c, 1::'a:] ^ Suc n * p)) c =\n       fact (Suc n) * poly p c", "finally"], ["proof (chain)\npicking this:\n  (pderiv ^^ Suc n) ([:- c, 1::'a:] ^ Suc n * p) =\n  (pderiv ^^ n) ([:- c, 1::'a:] ^ n * ([:- c, 1::'a:] * pderiv p)) +\n  (pderiv ^^ n)\n   ([:- c, 1::'a:] ^ n * Polynomial.smult ((1::'a) + of_nat n) p)", "show ?case"], ["proof (prove)\nusing this:\n  (pderiv ^^ Suc n) ([:- c, 1::'a:] ^ Suc n * p) =\n  (pderiv ^^ n) ([:- c, 1::'a:] ^ n * ([:- c, 1::'a:] * pderiv p)) +\n  (pderiv ^^ n)\n   ([:- c, 1::'a:] ^ n * Polynomial.smult ((1::'a) + of_nat n) p)\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ Suc n) ([:- c, 1::'a:] ^ Suc n * p)) c =\n    fact (Suc n) * poly p c", "by (simp add: Suc.IH del: mult_smult_right power_Suc)"], ["proof (state)\nthis:\n  poly ((pderiv ^^ Suc n) ([:- c, 1::'a:] ^ Suc n * p)) c =\n  fact (Suc n) * poly p c\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ 0 * p)) c = fact 0 * poly p c", "qed simp_all"], ["", "lemma poly_higher_pderiv_aux3:\n  fixes c :: \"'a :: {idom,semiring_char_0}\"\n  assumes \"k \\<ge> n\"\n  shows   \"\\<exists>q. poly ((pderiv ^^ k) ([:-c, 1:] ^ n * p)) c = fact n * poly q c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * p)) c = fact n * poly q c", "using assms"], ["proof (prove)\nusing this:\n  n \\<le> k\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * p)) c = fact n * poly q c", "proof (induction k arbitrary: n p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p.\n       n \\<le> 0 \\<Longrightarrow>\n       \\<exists>q.\n          poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ n * p)) c =\n          fact n * poly q c\n 2. \\<And>k n p.\n       \\<lbrakk>\\<And>n p.\n                   n \\<le> k \\<Longrightarrow>\n                   \\<exists>q.\n                      poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * p)) c =\n                      fact n * poly q c;\n        n \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            poly\n                             ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p))\n                             c =\n                            fact n * poly q c", "case (Suc k n p)"], ["proof (state)\nthis:\n  ?n \\<le> k \\<Longrightarrow>\n  \\<exists>q.\n     poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ ?n * ?p)) c = fact ?n * poly q c\n  n \\<le> Suc k\n\ngoal (2 subgoals):\n 1. \\<And>n p.\n       n \\<le> 0 \\<Longrightarrow>\n       \\<exists>q.\n          poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ n * p)) c =\n          fact n * poly q c\n 2. \\<And>k n p.\n       \\<lbrakk>\\<And>n p.\n                   n \\<le> k \\<Longrightarrow>\n                   \\<exists>q.\n                      poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * p)) c =\n                      fact n * poly q c;\n        n \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            poly\n                             ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p))\n                             c =\n                            fact n * poly q c", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n       fact n * poly q c", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>q.\n       poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n       fact n * poly q c\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>q.\n          poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n          fact n * poly q c", "fix n'"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>q.\n       poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n       fact n * poly q c\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>q.\n          poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n          fact n * poly q c", "assume n: \"n = Suc n'\""], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>q.\n       poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n       fact n * poly q c\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>q.\n          poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n          fact n * poly q c", "have \"poly ((pderiv ^^ Suc k) ([:-c, 1:] ^ n * p)) c =\n            poly ((pderiv ^^ k) ([:- c, 1:] ^ n * pderiv p)) c +\n              of_nat n * poly ((pderiv ^^ k) ([:-c, 1:] ^ n' * p)) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n    poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * pderiv p)) c +\n    of_nat n * poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n' * p)) c", "by (simp del: funpow.simps power_Suc add: funpow_Suc_right pderiv_power_Suc\n            pderiv_mult n pderiv_pCons higher_pderiv_add mult_ac higher_pderiv_smult)"], ["proof (state)\nthis:\n  poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n  poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * pderiv p)) c +\n  of_nat n * poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n' * p)) c\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>q.\n       poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n       fact n * poly q c\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>q.\n          poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n          fact n * poly q c", "also"], ["proof (state)\nthis:\n  poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n  poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * pderiv p)) c +\n  of_nat n * poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n' * p)) c\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>q.\n       poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n       fact n * poly q c\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>q.\n          poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n          fact n * poly q c", "have \"\\<exists>q1. poly ((pderiv ^^ k) ([:-c, 1:] ^ n * pderiv p)) c = fact n * poly q1 c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q1.\n       poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * pderiv p)) c =\n       fact n * poly q1 c", "using Suc.prems Suc.IH[of n \"pderiv p\"]"], ["proof (prove)\nusing this:\n  n \\<le> Suc k\n  n \\<le> k \\<Longrightarrow>\n  \\<exists>q.\n     poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * pderiv p)) c =\n     fact n * poly q c\n\ngoal (1 subgoal):\n 1. \\<exists>q1.\n       poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * pderiv p)) c =\n       fact n * poly q1 c", "by (cases \"n' = k\") (auto simp: n poly_higher_pderiv_aux1 simp del: power_Suc of_nat_Suc\n                                intro: exI[of _ \"0::'a poly\"])"], ["proof (state)\nthis:\n  \\<exists>q1.\n     poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * pderiv p)) c =\n     fact n * poly q1 c\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>q.\n       poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n       fact n * poly q c\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>q.\n          poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n          fact n * poly q c", "then"], ["proof (chain)\npicking this:\n  \\<exists>q1.\n     poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * pderiv p)) c =\n     fact n * poly q1 c", "obtain q1\n      where \"poly ((pderiv ^^ k) ([:-c, 1:] ^ n * pderiv p)) c = fact n * poly q1 c\""], ["proof (prove)\nusing this:\n  \\<exists>q1.\n     poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * pderiv p)) c =\n     fact n * poly q1 c\n\ngoal (1 subgoal):\n 1. (\\<And>q1.\n        poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * pderiv p)) c =\n        fact n * poly q1 c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * pderiv p)) c =\n  fact n * poly q1 c\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>q.\n       poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n       fact n * poly q c\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>q.\n          poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n          fact n * poly q c", "also"], ["proof (state)\nthis:\n  poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * pderiv p)) c =\n  fact n * poly q1 c\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>q.\n       poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n       fact n * poly q c\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>q.\n          poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n          fact n * poly q c", "from Suc.IH[of n' p] Suc.prems"], ["proof (chain)\npicking this:\n  n' \\<le> k \\<Longrightarrow>\n  \\<exists>q.\n     poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n' * p)) c = fact n' * poly q c\n  n \\<le> Suc k", "obtain q2\n      where \"poly ((pderiv ^^ k) ([:-c, 1:] ^ n' * p)) c = fact n' * poly q2 c\""], ["proof (prove)\nusing this:\n  n' \\<le> k \\<Longrightarrow>\n  \\<exists>q.\n     poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n' * p)) c = fact n' * poly q c\n  n \\<le> Suc k\n\ngoal (1 subgoal):\n 1. (\\<And>q2.\n        poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n' * p)) c =\n        fact n' * poly q2 c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: n)"], ["proof (state)\nthis:\n  poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n' * p)) c = fact n' * poly q2 c\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>q.\n       poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n       fact n * poly q c\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>q.\n          poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n          fact n * poly q c", "finally"], ["proof (chain)\npicking this:\n  poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n  fact n * poly q1 c + of_nat n * (fact n' * poly q2 c)", "show ?case"], ["proof (prove)\nusing this:\n  poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n  fact n * poly q1 c + of_nat n * (fact n' * poly q2 c)\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n       fact n * poly q c", "by (auto intro!: exI[of _ \"q1 + q2\"] simp: n algebra_simps)"], ["proof (state)\nthis:\n  \\<exists>q.\n     poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c = fact n * poly q c\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>q.\n       poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c =\n       fact n * poly q c", "qed auto"], ["proof (state)\nthis:\n  \\<exists>q.\n     poly ((pderiv ^^ Suc k) ([:- c, 1::'a:] ^ n * p)) c = fact n * poly q c\n\ngoal (1 subgoal):\n 1. \\<And>n p.\n       n \\<le> 0 \\<Longrightarrow>\n       \\<exists>q.\n          poly ((pderiv ^^ 0) ([:- c, 1::'a:] ^ n * p)) c =\n          fact n * poly q c", "qed auto"], ["", "lemma poly_higher_pderiv_aux3':\n  fixes c :: \"'a :: {idom, semiring_char_0}\"\n  assumes \"k \\<ge> n\" \"[:-c, 1:] ^ n dvd p\"\n  shows   \"fact n dvd poly ((pderiv ^^ k) p) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact n dvd poly ((pderiv ^^ k) p) c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fact n dvd poly ((pderiv ^^ k) p) c", "from assms(2)"], ["proof (chain)\npicking this:\n  [:- c, 1::'a:] ^ n dvd p", "obtain q where \"p = [:-c, 1:] ^ n * q\""], ["proof (prove)\nusing this:\n  [:- c, 1::'a:] ^ n dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = [:- c, 1::'a:] ^ n * q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE)"], ["proof (state)\nthis:\n  p = [:- c, 1::'a:] ^ n * q\n\ngoal (1 subgoal):\n 1. fact n dvd poly ((pderiv ^^ k) p) c", "with poly_higher_pderiv_aux3[OF assms(1), of c q]"], ["proof (chain)\npicking this:\n  \\<exists>qa.\n     poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * q)) c = fact n * poly qa c\n  p = [:- c, 1::'a:] ^ n * q", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>qa.\n     poly ((pderiv ^^ k) ([:- c, 1::'a:] ^ n * q)) c = fact n * poly qa c\n  p = [:- c, 1::'a:] ^ n * q\n\ngoal (1 subgoal):\n 1. fact n dvd poly ((pderiv ^^ k) p) c", "by auto"], ["proof (state)\nthis:\n  fact n dvd poly ((pderiv ^^ k) p) c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma e_transcendental_aux_bound:\n  obtains C where \"C \\<ge> 0\"\n    \"\\<And>x. x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n        norm (\\<Prod>k\\<in>{1..n}. (x - of_nat k :: complex)) \\<le> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?f = \"\\<lambda>x. (\\<Prod>k\\<in>{1..n}. (x - of_nat k))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define C where \"C = max 0 (Sup (cmod ` ?f ` closed_segment 0 (of_nat n)))\""], ["proof (state)\nthis:\n  C =\n  max 0\n   (Sup (cmod `\n         (\\<lambda>x. \\<Prod>k = 1..n. x - of_nat k) `\n         closed_segment 0 (of_nat n)))\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"C \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C", "by (simp add: C_def)"], ["proof (state)\nthis:\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix x :: complex"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"x \\<in> closed_segment 0 (of_nat n)\""], ["proof (state)\nthis:\n  x \\<in> closed_segment 0 (of_nat n)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"cmod (?f x) \\<le> Sup ((cmod \\<circ> ?f) ` closed_segment 0 (of_nat n))\""], ["proof (prove)\nusing this:\n  x \\<in> closed_segment 0 (of_nat n)\n\ngoal (1 subgoal):\n 1. cmod (\\<Prod>k = 1..n. x - of_nat k)\n    \\<le> Sup ((cmod \\<circ> (\\<lambda>x. \\<Prod>k = 1..n. x - of_nat k)) `\n               closed_segment 0 (of_nat n))", "by (intro cSup_upper bounded_imp_bdd_above compact_imp_bounded compact_continuous_image)\n         (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  cmod (\\<Prod>k = 1..n. x - of_nat k)\n  \\<le> Sup ((cmod \\<circ> (\\<lambda>x. \\<Prod>k = 1..n. x - of_nat k)) `\n             closed_segment 0 (of_nat n))\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  cmod (\\<Prod>k = 1..n. x - of_nat k)\n  \\<le> Sup ((cmod \\<circ> (\\<lambda>x. \\<Prod>k = 1..n. x - of_nat k)) `\n             closed_segment 0 (of_nat n))\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> \\<le> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup ((cmod \\<circ> (\\<lambda>x. \\<Prod>k = 1..n. x - of_nat k)) `\n         closed_segment 0 (of_nat n))\n    \\<le> C", "by (simp add: C_def image_comp)"], ["proof (state)\nthis:\n  Sup ((cmod \\<circ> (\\<lambda>x. \\<Prod>k = 1..n. x - of_nat k)) `\n       closed_segment 0 (of_nat n))\n  \\<le> C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C", "have \"cmod (?f x) \\<le> C\""], ["proof (prove)\nusing this:\n  cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\n\ngoal (1 subgoal):\n 1. cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C", "."], ["proof (state)\nthis:\n  cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  ?x3 \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n  cmod (\\<Prod>k = 1..n. ?x3 - of_nat k) \\<le> C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> C\n  ?x3 \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n  cmod (\\<Prod>k = 1..n. ?x3 - of_nat k) \\<le> C", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  ?x3 \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n  cmod (\\<Prod>k = 1..n. ?x3 - of_nat k) \\<le> C\n\ngoal (1 subgoal):\n 1. thesis", "by (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem e_transcendental_complex: \"\\<not> algebraic (exp 1 :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (exp 1)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "assume \"algebraic (exp 1 :: complex)\""], ["proof (state)\nthis:\n  algebraic (exp 1)\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  algebraic (exp 1)", "obtain q :: \"int poly\"\n    where q: \"q \\<noteq> 0\" \"coeff q 0 \\<noteq> 0\" \"poly (of_int_poly q) (exp 1 :: complex) = 0\""], ["proof (prove)\nusing this:\n  algebraic (exp 1)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<noteq> 0; poly.coeff q 0 \\<noteq> 0;\n         poly (of_int_poly q) (exp 1) = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim algebraicE'_nonzero) simp_all"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  poly.coeff q 0 \\<noteq> 0\n  poly (of_int_poly q) (exp 1) = 0\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "define n :: nat where \"n = degree q\""], ["proof (state)\nthis:\n  n = degree q\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "from q"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  poly.coeff q 0 \\<noteq> 0\n  poly (of_int_poly q) (exp 1) = 0", "have [simp]: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  poly.coeff q 0 \\<noteq> 0\n  poly (of_int_poly q) (exp 1) = 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by (intro notI) (auto simp: n_def elim!: degree_eq_zeroE)"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "define qmax where \"qmax = Max (insert 0 (abs ` set (coeffs q)))\""], ["proof (state)\nthis:\n  qmax = Max (insert 0 (abs ` set (coeffs q)))\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "have qmax_nonneg [simp]: \"qmax \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> qmax", "by (simp add: qmax_def)"], ["proof (state)\nthis:\n  0 \\<le> qmax\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "have qmax: \"\\<bar>coeff q k\\<bar> \\<le> qmax\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff q k\\<bar> \\<le> qmax", "by (cases \"k \\<le> degree q\")\n       (auto simp: qmax_def coeff_eq_0 coeffs_def simp del: upt_Suc intro: Max.coboundedI)"], ["proof (state)\nthis:\n  \\<bar>poly.coeff q ?k\\<bar> \\<le> qmax\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "obtain C where C: \"C \\<ge> 0\"\n    \"\\<And>x. x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow> norm (\\<Prod>k\\<in>{1..n}. (x - of_nat k :: complex)) \\<le> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>0 \\<le> C;\n         \\<And>x.\n            x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n            cmod (\\<Prod>k = 1..n. x - of_nat k) \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule e_transcendental_aux_bound)"], ["proof (state)\nthis:\n  0 \\<le> C\n  ?x \\<in> closed_segment 0 (of_nat n) \\<Longrightarrow>\n  cmod (\\<Prod>k = 1..n. ?x - of_nat k) \\<le> C\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "define E where \"E = (1 + real n) * real_of_int qmax * real n * exp (real n) / real n\""], ["proof (state)\nthis:\n  E = (1 + real n) * real_of_int qmax * real n * exp (real n) / real n\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "define F where \"F = real n * C\""], ["proof (state)\nthis:\n  F = real n * C\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "have ineq: \"fact (p - 1) \\<le> E * F ^ p\" if p: \"prime p\" \"p > n\" \"p > abs (coeff q 0)\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "from p(1)"], ["proof (chain)\npicking this:\n  prime p", "have p_pos: \"p > 0\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. 0 < p", "by (simp add: prime_gt_0_nat)"], ["proof (state)\nthis:\n  0 < p\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "define f :: \"int poly\"\n      where \"f = monom 1 (p - 1) * (\\<Prod>k\\<in>{1..n}. [:-of_nat k, 1:] ^ p)\""], ["proof (state)\nthis:\n  f = Polynomial.monom 1 (p - 1) * (\\<Prod>k = 1..n. [:- int k, 1:] ^ p)\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "have poly_f: \"poly (of_int_poly f) x = x ^ (p - 1) * (\\<Prod>k\\<in>{1..n}. (x - of_nat k)) ^ p\"\n      for x :: complex"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (of_int_poly f) x =\n    x ^ (p - 1) * (\\<Prod>k = 1..n. x - of_nat k) ^ p", "by (simp add: f_def poly_prod poly_monom prod_power_distrib)"], ["proof (state)\nthis:\n  poly (of_int_poly f) ?x =\n  ?x ^ (p - 1) * (\\<Prod>k = 1..n. ?x - of_nat k) ^ p\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "define m :: nat where \"m = degree f\""], ["proof (state)\nthis:\n  m = degree f\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "from p_pos"], ["proof (chain)\npicking this:\n  0 < p", "have m: \"m = (n + 1) * p - 1\""], ["proof (prove)\nusing this:\n  0 < p\n\ngoal (1 subgoal):\n 1. m = (n + 1) * p - 1", "by (simp add: m_def f_def degree_mult_eq degree_monom_eq degree_prod_sum_eq degree_linear_power)"], ["proof (state)\nthis:\n  m = (n + 1) * p - 1\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "define M :: int where \"M = (- 1) ^ (n * p) * fact n ^ p\""], ["proof (state)\nthis:\n  M = (- 1) ^ (n * p) * fact n ^ p\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "with p"], ["proof (chain)\npicking this:\n  prime p\n  n < p\n  \\<bar>poly.coeff q 0\\<bar> < int p\n  M = (- 1) ^ (n * p) * fact n ^ p", "have p_not_dvd_M: \"\\<not>int p dvd M\""], ["proof (prove)\nusing this:\n  prime p\n  n < p\n  \\<bar>poly.coeff q 0\\<bar> < int p\n  M = (- 1) ^ (n * p) * fact n ^ p\n\ngoal (1 subgoal):\n 1. \\<not> int p dvd M", "by (auto simp: M_def prime_elem_int_not_dvd_neg1_power prime_dvd_power_iff\n            prime_gt_0_nat prime_dvd_fact_iff_int prime_dvd_mult_iff)"], ["proof (state)\nthis:\n  \\<not> int p dvd M\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "interpret lindemann_weierstrass_aux \"of_int_poly f\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "define J :: complex where \"J = (\\<Sum>k\\<le>n. of_int (coeff q k) * I (of_nat k))\""], ["proof (state)\nthis:\n  J = (\\<Sum>k\\<le>n. of_int (poly.coeff q k) * I (of_nat k))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "define idxs where \"idxs = ({..n}\\<times>{..m}) - {(0, p - 1)}\""], ["proof (state)\nthis:\n  idxs = {..n} \\<times> {..m} - {(0, p - 1)}\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "hence \"J = (\\<Sum>k\\<le>n. of_int (coeff q k) * exp 1 ^ k) * (\\<Sum>n\\<le>m. of_int (poly ((pderiv ^^ n) f) 0)) -\n                 of_int (\\<Sum>k\\<le>n. \\<Sum>n\\<le>m. coeff q k * poly ((pderiv ^^ n) f) (int k))\""], ["proof (prove)\nusing this:\n  idxs = {..n} \\<times> {..m} - {(0, p - 1)}\n\ngoal (1 subgoal):\n 1. J =\n    (\\<Sum>k\\<le>n. of_int (poly.coeff q k) * exp 1 ^ k) *\n    (\\<Sum>n\\<le>m. of_int (poly ((pderiv ^^ n) f) 0)) -\n    of_int\n     (\\<Sum>k\\<le>n.\n         \\<Sum>n\\<le>m. poly.coeff q k * poly ((pderiv ^^ n) f) (int k))", "by (simp add: J_def I_def algebra_simps sum_subtractf sum_distrib_left m_def\n                    exp_of_nat_mult [symmetric])"], ["proof (state)\nthis:\n  J =\n  (\\<Sum>k\\<le>n. of_int (poly.coeff q k) * exp 1 ^ k) *\n  (\\<Sum>n\\<le>m. of_int (poly ((pderiv ^^ n) f) 0)) -\n  of_int\n   (\\<Sum>k\\<le>n.\n       \\<Sum>n\\<le>m. poly.coeff q k * poly ((pderiv ^^ n) f) (int k))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "also"], ["proof (state)\nthis:\n  J =\n  (\\<Sum>k\\<le>n. of_int (poly.coeff q k) * exp 1 ^ k) *\n  (\\<Sum>n\\<le>m. of_int (poly ((pderiv ^^ n) f) 0)) -\n  of_int\n   (\\<Sum>k\\<le>n.\n       \\<Sum>n\\<le>m. poly.coeff q k * poly ((pderiv ^^ n) f) (int k))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "have \"(\\<Sum>k\\<le>n. of_int (coeff q k) * exp 1 ^ k) = poly (of_int_poly q) (exp 1 :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n. of_int (poly.coeff q k) * exp 1 ^ k) =\n    poly (of_int_poly q) (exp 1)", "by (simp add: poly_altdef n_def)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n. of_int (poly.coeff q k) * exp 1 ^ k) =\n  poly (of_int_poly q) (exp 1)\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n. of_int (poly.coeff q k) * exp 1 ^ k) =\n  poly (of_int_poly q) (exp 1)\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (of_int_poly q) (exp 1) = 0", "by fact"], ["proof (state)\nthis:\n  poly (of_int_poly q) (exp 1) = 0\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "finally"], ["proof (chain)\npicking this:\n  J =\n  0 * (\\<Sum>n\\<le>m. of_int (poly ((pderiv ^^ n) f) 0)) -\n  of_int\n   (\\<Sum>k\\<le>n.\n       \\<Sum>n\\<le>m. poly.coeff q k * poly ((pderiv ^^ n) f) (int k))", "have \"J = of_int (-(\\<Sum>(k,n)\\<in>{..n}\\<times>{..m}. coeff q k * poly ((pderiv ^^ n) f) (int k)))\""], ["proof (prove)\nusing this:\n  J =\n  0 * (\\<Sum>n\\<le>m. of_int (poly ((pderiv ^^ n) f) 0)) -\n  of_int\n   (\\<Sum>k\\<le>n.\n       \\<Sum>n\\<le>m. poly.coeff q k * poly ((pderiv ^^ n) f) (int k))\n\ngoal (1 subgoal):\n 1. J =\n    of_int\n     (- (\\<Sum>(k, n)\\<in>{..n} \\<times> {..m}.\n           poly.coeff q k * poly ((pderiv ^^ n) f) (int k)))", "by (simp add: sum.cartesian_product)"], ["proof (state)\nthis:\n  J =\n  of_int\n   (- (\\<Sum>(k, n)\\<in>{..n} \\<times> {..m}.\n         poly.coeff q k * poly ((pderiv ^^ n) f) (int k)))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "also"], ["proof (state)\nthis:\n  J =\n  of_int\n   (- (\\<Sum>(k, n)\\<in>{..n} \\<times> {..m}.\n         poly.coeff q k * poly ((pderiv ^^ n) f) (int k)))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "have \"{..n}\\<times>{..m} = insert (0, p - 1) idxs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..n} \\<times> {..m} = insert (0, p - 1) idxs", "by (auto simp: m idxs_def)"], ["proof (state)\nthis:\n  {..n} \\<times> {..m} = insert (0, p - 1) idxs\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "also"], ["proof (state)\nthis:\n  {..n} \\<times> {..m} = insert (0, p - 1) idxs\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "have \"-(\\<Sum>(k,n)\\<in>\\<dots>. coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n       - (coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0) -\n         (\\<Sum>(k, n)\\<in>idxs. coeff q k * poly ((pderiv ^^ n) f) (of_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (\\<Sum>(k, n)\\<in>insert (0, p - 1) idxs.\n         poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n    - (poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0) -\n    (\\<Sum>(k, n)\\<in>idxs. poly.coeff q k * poly ((pderiv ^^ n) f) (int k))", "by (subst sum.insert) (simp_all add: idxs_def)"], ["proof (state)\nthis:\n  - (\\<Sum>(k, n)\\<in>insert (0, p - 1) idxs.\n       poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n  - (poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0) -\n  (\\<Sum>(k, n)\\<in>idxs. poly.coeff q k * poly ((pderiv ^^ n) f) (int k))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "also"], ["proof (state)\nthis:\n  - (\\<Sum>(k, n)\\<in>insert (0, p - 1) idxs.\n       poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n  - (poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0) -\n  (\\<Sum>(k, n)\\<in>idxs. poly.coeff q k * poly ((pderiv ^^ n) f) (int k))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "have \"coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0 = coeff q 0 * M * fact (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0 =\n    poly.coeff q 0 * M * fact (p - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0 =\n    poly.coeff q 0 * M * fact (p - 1)", "have \"f = [:-0, 1:] ^ (p - 1) * (\\<Prod>k = 1..n. [:- of_nat k, 1:] ^ p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = [:- 0, 1:] ^ (p - 1) * (\\<Prod>k = 1..n. [:- int k, 1:] ^ p)", "by (simp add: f_def monom_altdef)"], ["proof (state)\nthis:\n  f = [:- 0, 1:] ^ (p - 1) * (\\<Prod>k = 1..n. [:- int k, 1:] ^ p)\n\ngoal (1 subgoal):\n 1. poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0 =\n    poly.coeff q 0 * M * fact (p - 1)", "also"], ["proof (state)\nthis:\n  f = [:- 0, 1:] ^ (p - 1) * (\\<Prod>k = 1..n. [:- int k, 1:] ^ p)\n\ngoal (1 subgoal):\n 1. poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0 =\n    poly.coeff q 0 * M * fact (p - 1)", "have \"poly ((pderiv ^^ (p - 1)) \\<dots>) 0 =\n                   fact (p - 1) * poly (\\<Prod>k = 1..n. [:- of_nat k, 1:] ^ p) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     ((pderiv ^^ (p - 1))\n       ([:- 0, 1:] ^ (p - 1) * (\\<Prod>k = 1..n. [:- int k, 1:] ^ p)))\n     0 =\n    fact (p - 1) * poly (\\<Prod>k = 1..n. [:- int k, 1:] ^ p) 0", "by (rule poly_higher_pderiv_aux2)"], ["proof (state)\nthis:\n  poly\n   ((pderiv ^^ (p - 1))\n     ([:- 0, 1:] ^ (p - 1) * (\\<Prod>k = 1..n. [:- int k, 1:] ^ p)))\n   0 =\n  fact (p - 1) * poly (\\<Prod>k = 1..n. [:- int k, 1:] ^ p) 0\n\ngoal (1 subgoal):\n 1. poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0 =\n    poly.coeff q 0 * M * fact (p - 1)", "also"], ["proof (state)\nthis:\n  poly\n   ((pderiv ^^ (p - 1))\n     ([:- 0, 1:] ^ (p - 1) * (\\<Prod>k = 1..n. [:- int k, 1:] ^ p)))\n   0 =\n  fact (p - 1) * poly (\\<Prod>k = 1..n. [:- int k, 1:] ^ p) 0\n\ngoal (1 subgoal):\n 1. poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0 =\n    poly.coeff q 0 * M * fact (p - 1)", "have \"poly (\\<Prod>k = 1..n. [:- of_nat k :: int, 1:] ^ p) 0 = (-1)^(n*p) * fact n ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (\\<Prod>k = 1..n. [:- int k, 1:] ^ p) 0 =\n    (- 1) ^ (n * p) * fact n ^ p", "by (induction n) (simp_all add: prod.nat_ivl_Suc' power_mult_distrib mult_ac\n                            power_minus' power_add del: of_nat_Suc)"], ["proof (state)\nthis:\n  poly (\\<Prod>k = 1..n. [:- int k, 1:] ^ p) 0 =\n  (- 1) ^ (n * p) * fact n ^ p\n\ngoal (1 subgoal):\n 1. poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0 =\n    poly.coeff q 0 * M * fact (p - 1)", "finally"], ["proof (chain)\npicking this:\n  poly ((pderiv ^^ (p - 1)) f) 0 =\n  fact (p - 1) * ((- 1) ^ (n * p) * fact n ^ p)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly ((pderiv ^^ (p - 1)) f) 0 =\n  fact (p - 1) * ((- 1) ^ (n * p) * fact n ^ p)\n\ngoal (1 subgoal):\n 1. poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0 =\n    poly.coeff q 0 * M * fact (p - 1)", "by (simp add: mult_ac M_def)"], ["proof (state)\nthis:\n  poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0 =\n  poly.coeff q 0 * M * fact (p - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0 =\n  poly.coeff q 0 * M * fact (p - 1)\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "also"], ["proof (state)\nthis:\n  poly.coeff q 0 * poly ((pderiv ^^ (p - 1)) f) 0 =\n  poly.coeff q 0 * M * fact (p - 1)\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "have \"\\<exists>N. (\\<Sum>(k, n)\\<in>idxs. coeff q k * poly ((pderiv ^^ n) f) (int k)) = fact p * N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       (\\<Sum>(k, n)\\<in>idxs.\n          poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n       fact p * N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       (\\<Sum>(k, n)\\<in>idxs.\n          poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n       fact p * N", "have \"\\<forall>(k, n)\\<in>idxs. fact p dvd poly ((pderiv ^^ n) f) (of_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, n)\\<in>idxs. fact p dvd poly ((pderiv ^^ n) f) (int k)", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> idxs \\<Longrightarrow>\n       fact p dvd poly ((pderiv ^^ b) f) (int a)", "fix k j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> idxs \\<Longrightarrow>\n       fact p dvd poly ((pderiv ^^ b) f) (int a)", "assume idxs: \"(k, j) \\<in> idxs\""], ["proof (state)\nthis:\n  (k, j) \\<in> idxs\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> idxs \\<Longrightarrow>\n       fact p dvd poly ((pderiv ^^ b) f) (int a)", "then"], ["proof (chain)\npicking this:\n  (k, j) \\<in> idxs", "consider \"k = 0\" \"j < p - 1\" | \"k = 0\" \"j > p - 1\" | \"k \\<noteq> 0\" \"j < p\" | \"k \\<noteq> 0\" \"j \\<ge> p\""], ["proof (prove)\nusing this:\n  (k, j) \\<in> idxs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>k = 0; j < p - 1\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>k = 0; p - 1 < j\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>k \\<noteq> 0; j < p\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (fastforce simp: idxs_def)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>k = 0; j < p - 1\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>k = 0; p - 1 < j\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>k \\<noteq> 0; j < p\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> idxs \\<Longrightarrow>\n       fact p dvd poly ((pderiv ^^ b) f) (int a)", "thus \"fact p dvd poly ((pderiv ^^ j) f) (of_nat k)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>k = 0; j < p - 1\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>k = 0; p - 1 < j\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>k \\<noteq> 0; j < p\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. fact p dvd poly ((pderiv ^^ j) f) (int k)", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>k = 0; j < p - 1\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 2. \\<lbrakk>k = 0; p - 1 < j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 3. \\<lbrakk>k \\<noteq> 0; j < p\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 4. \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)", "case 1"], ["proof (state)\nthis:\n  k = 0\n  j < p - 1\n\ngoal (4 subgoals):\n 1. \\<lbrakk>k = 0; j < p - 1\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 2. \\<lbrakk>k = 0; p - 1 < j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 3. \\<lbrakk>k \\<noteq> 0; j < p\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 4. \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n  j < p - 1\n\ngoal (1 subgoal):\n 1. fact p dvd poly ((pderiv ^^ j) f) (int k)", "by (simp add: f_def poly_higher_pderiv_aux1' monom_altdef)"], ["proof (state)\nthis:\n  fact p dvd poly ((pderiv ^^ j) f) (int k)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>k = 0; p - 1 < j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 2. \\<lbrakk>k \\<noteq> 0; j < p\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 3. \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>k = 0; p - 1 < j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 2. \\<lbrakk>k \\<noteq> 0; j < p\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 3. \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)", "case 2"], ["proof (state)\nthis:\n  k = 0\n  p - 1 < j\n\ngoal (3 subgoals):\n 1. \\<lbrakk>k = 0; p - 1 < j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 2. \\<lbrakk>k \\<noteq> 0; j < p\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 3. \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n  p - 1 < j\n\ngoal (1 subgoal):\n 1. fact p dvd poly ((pderiv ^^ j) f) (int k)", "by (simp add: f_def poly_higher_pderiv_aux3' monom_altdef fact_dvd_poly_higher_pderiv_aux')"], ["proof (state)\nthis:\n  fact p dvd poly ((pderiv ^^ j) f) (int k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<noteq> 0; j < p\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 2. \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<noteq> 0; j < p\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 2. \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)", "case 3"], ["proof (state)\nthis:\n  k \\<noteq> 0\n  j < p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<noteq> 0; j < p\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)\n 2. \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  j < p\n\ngoal (1 subgoal):\n 1. fact p dvd poly ((pderiv ^^ j) f) (int k)", "unfolding f_def"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  j < p\n\ngoal (1 subgoal):\n 1. fact p dvd\n    poly\n     ((pderiv ^^ j)\n       (Polynomial.monom 1 (p - 1) * (\\<Prod>k = 1..n. [:- int k, 1:] ^ p)))\n     (int k)", "by (subst poly_higher_pderiv_aux1'[of _ p])\n               (insert idxs, auto simp: idxs_def intro!: dvd_mult)"], ["proof (state)\nthis:\n  fact p dvd poly ((pderiv ^^ j) f) (int k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)", "case 4"], ["proof (state)\nthis:\n  k \\<noteq> 0\n  p \\<le> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> 0; p \\<le> j\\<rbrakk>\n    \\<Longrightarrow> fact p dvd poly ((pderiv ^^ j) f) (int k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  p \\<le> j\n\ngoal (1 subgoal):\n 1. fact p dvd poly ((pderiv ^^ j) f) (int k)", "unfolding f_def"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  p \\<le> j\n\ngoal (1 subgoal):\n 1. fact p dvd\n    poly\n     ((pderiv ^^ j)\n       (Polynomial.monom 1 (p - 1) * (\\<Prod>k = 1..n. [:- int k, 1:] ^ p)))\n     (int k)", "by (intro poly_higher_pderiv_aux3') (insert idxs, auto intro!: dvd_mult simp: idxs_def)"], ["proof (state)\nthis:\n  fact p dvd poly ((pderiv ^^ j) f) (int k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fact p dvd poly ((pderiv ^^ j) f) (int k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(k, n)\\<in>idxs. fact p dvd poly ((pderiv ^^ n) f) (int k)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       (\\<Sum>(k, n)\\<in>idxs.\n          poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n       fact p * N", "hence \"fact p dvd (\\<Sum>(k, n)\\<in>idxs. coeff q k * poly ((pderiv ^^ n) f) (int k))\""], ["proof (prove)\nusing this:\n  \\<forall>(k, n)\\<in>idxs. fact p dvd poly ((pderiv ^^ n) f) (int k)\n\ngoal (1 subgoal):\n 1. fact p dvd\n    (\\<Sum>(k, n)\\<in>idxs. poly.coeff q k * poly ((pderiv ^^ n) f) (int k))", "by (auto intro!: dvd_sum dvd_mult simp del: of_int_fact)"], ["proof (state)\nthis:\n  fact p dvd\n  (\\<Sum>(k, n)\\<in>idxs. poly.coeff q k * poly ((pderiv ^^ n) f) (int k))\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       (\\<Sum>(k, n)\\<in>idxs.\n          poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n       fact p * N", "thus ?thesis"], ["proof (prove)\nusing this:\n  fact p dvd\n  (\\<Sum>(k, n)\\<in>idxs. poly.coeff q k * poly ((pderiv ^^ n) f) (int k))\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       (\\<Sum>(k, n)\\<in>idxs.\n          poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n       fact p * N", "by (blast elim: dvdE)"], ["proof (state)\nthis:\n  \\<exists>N.\n     (\\<Sum>(k, n)\\<in>idxs.\n        poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n     fact p * N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>N.\n     (\\<Sum>(k, n)\\<in>idxs.\n        poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n     fact p * N\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "then"], ["proof (chain)\npicking this:\n  \\<exists>N.\n     (\\<Sum>(k, n)\\<in>idxs.\n        poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n     fact p * N", "guess N"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     (\\<Sum>(k, n)\\<in>idxs.\n        poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n     fact p * N\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  (\\<Sum>(k, n)\\<in>idxs. poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n  fact p * N\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "note N = this"], ["proof (state)\nthis:\n  (\\<Sum>(k, n)\\<in>idxs. poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n  fact p * N\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "also"], ["proof (state)\nthis:\n  (\\<Sum>(k, n)\\<in>idxs. poly.coeff q k * poly ((pderiv ^^ n) f) (int k)) =\n  fact p * N\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "from p"], ["proof (chain)\npicking this:\n  prime p\n  n < p\n  \\<bar>poly.coeff q 0\\<bar> < int p", "have \"- (coeff q 0 * M * fact (p - 1)) - fact p * N =\n                        - fact (p - 1) * (coeff q 0 * M + p * N)\""], ["proof (prove)\nusing this:\n  prime p\n  n < p\n  \\<bar>poly.coeff q 0\\<bar> < int p\n\ngoal (1 subgoal):\n 1. - (poly.coeff q 0 * M * fact (p - 1)) - fact p * N =\n    - fact (p - 1) * (poly.coeff q 0 * M + int p * N)", "by (subst fact_reduce[of p]) (simp_all add: algebra_simps)"], ["proof (state)\nthis:\n  - (poly.coeff q 0 * M * fact (p - 1)) - fact p * N =\n  - fact (p - 1) * (poly.coeff q 0 * M + int p * N)\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "finally"], ["proof (chain)\npicking this:\n  J = of_int (- fact (p - 1) * (poly.coeff q 0 * M + int p * N))", "have J: \"J = -of_int (fact (p - 1) * (coeff q 0 * M + p * N))\""], ["proof (prove)\nusing this:\n  J = of_int (- fact (p - 1) * (poly.coeff q 0 * M + int p * N))\n\ngoal (1 subgoal):\n 1. J = - of_int (fact (p - 1) * (poly.coeff q 0 * M + int p * N))", "by simp"], ["proof (state)\nthis:\n  J = - of_int (fact (p - 1) * (poly.coeff q 0 * M + int p * N))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "from p q(2)"], ["proof (chain)\npicking this:\n  prime p\n  n < p\n  \\<bar>poly.coeff q 0\\<bar> < int p\n  poly.coeff q 0 \\<noteq> 0", "have \"\\<not>p dvd coeff q 0 * M + p * N\""], ["proof (prove)\nusing this:\n  prime p\n  n < p\n  \\<bar>poly.coeff q 0\\<bar> < int p\n  poly.coeff q 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> int p dvd poly.coeff q 0 * M + int p * N", "by (auto simp: dvd_add_left_iff p_not_dvd_M prime_dvd_fact_iff_int prime_dvd_mult_iff\n               dest: dvd_imp_le_int)"], ["proof (state)\nthis:\n  \\<not> int p dvd poly.coeff q 0 * M + int p * N\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "hence \"coeff q 0 * M + p * N \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> int p dvd poly.coeff q 0 * M + int p * N\n\ngoal (1 subgoal):\n 1. poly.coeff q 0 * M + int p * N \\<noteq> 0", "by (intro notI) simp_all"], ["proof (state)\nthis:\n  poly.coeff q 0 * M + int p * N \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "hence \"abs (coeff q 0 * M + p * N) \\<ge> 1\""], ["proof (prove)\nusing this:\n  poly.coeff q 0 * M + int p * N \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<bar>poly.coeff q 0 * M + int p * N\\<bar>", "by simp"], ["proof (state)\nthis:\n  1 \\<le> \\<bar>poly.coeff q 0 * M + int p * N\\<bar>\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "hence \"norm (of_int (coeff q 0 * M + p * N) :: complex) \\<ge> 1\""], ["proof (prove)\nusing this:\n  1 \\<le> \\<bar>poly.coeff q 0 * M + int p * N\\<bar>\n\ngoal (1 subgoal):\n 1. 1 \\<le> cmod (of_int (poly.coeff q 0 * M + int p * N))", "by (simp only: norm_of_int)"], ["proof (state)\nthis:\n  1 \\<le> cmod (of_int (poly.coeff q 0 * M + int p * N))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "hence \"fact (p - 1) * \\<dots> \\<ge> fact (p - 1) * 1\""], ["proof (prove)\nusing this:\n  1 \\<le> cmod (of_int (poly.coeff q 0 * M + int p * N))\n\ngoal (1 subgoal):\n 1. fact (p - 1) * 1\n    \\<le> fact (p - 1) * cmod (of_int (poly.coeff q 0 * M + int p * N))", "by (intro mult_left_mono) simp_all"], ["proof (state)\nthis:\n  fact (p - 1) * 1\n  \\<le> fact (p - 1) * cmod (of_int (poly.coeff q 0 * M + int p * N))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "hence J_lower: \"norm J \\<ge> fact (p - 1)\""], ["proof (prove)\nusing this:\n  fact (p - 1) * 1\n  \\<le> fact (p - 1) * cmod (of_int (poly.coeff q 0 * M + int p * N))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> cmod J", "unfolding J norm_minus_cancel of_int_mult of_int_fact"], ["proof (prove)\nusing this:\n  fact (p - 1) * 1\n  \\<le> fact (p - 1) * cmod (of_int (poly.coeff q 0 * M + int p * N))\n\ngoal (1 subgoal):\n 1. fact (p - 1)\n    \\<le> cmod (fact (p - 1) * of_int (poly.coeff q 0 * M + int p * N))", "by (simp add: norm_mult)"], ["proof (state)\nthis:\n  fact (p - 1) \\<le> cmod J\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "have \"norm J \\<le> (\\<Sum>k\\<le>n. norm (of_int (coeff q k) * I (of_nat k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod J\n    \\<le> (\\<Sum>k\\<le>n. cmod (of_int (poly.coeff q k) * I (of_nat k)))", "unfolding J_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<Sum>k\\<le>n. of_int (poly.coeff q k) * I (of_nat k))\n    \\<le> (\\<Sum>k\\<le>n. cmod (of_int (poly.coeff q k) * I (of_nat k)))", "by (rule norm_sum)"], ["proof (state)\nthis:\n  cmod J\n  \\<le> (\\<Sum>k\\<le>n. cmod (of_int (poly.coeff q k) * I (of_nat k)))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "also"], ["proof (state)\nthis:\n  cmod J\n  \\<le> (\\<Sum>k\\<le>n. cmod (of_int (poly.coeff q k) * I (of_nat k)))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "have \"\\<dots> \\<le> (\\<Sum>k\\<le>n. of_int qmax * (real n * exp (real n) * real n ^ (p - 1) * C ^ p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n. cmod (of_int (poly.coeff q k) * I (of_nat k)))\n    \\<le> (\\<Sum>k\\<le>n.\n              real_of_int qmax *\n              (real n * exp (real n) * real n ^ (p - 1) * C ^ p))", "proof (intro sum_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "assume k: \"k \\<in> {..n}\""], ["proof (state)\nthis:\n  k \\<in> {..n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "have \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "by (rule ccontr) simp"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "{"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "fix x :: complex"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "assume x: \"x \\<in> closed_segment 0 (of_nat k)\""], ["proof (state)\nthis:\n  x \\<in> closed_segment 0 (of_nat k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "then"], ["proof (chain)\npicking this:\n  x \\<in> closed_segment 0 (of_nat k)", "obtain t where t: \"t \\<ge> 0\" \"t \\<le> 1\" \"x = of_real t * of_nat k\""], ["proof (prove)\nusing this:\n  x \\<in> closed_segment 0 (of_nat k)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>0 \\<le> t; t \\<le> 1;\n         x = complex_of_real t * of_nat k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: closed_segment_def scaleR_conv_of_real)"], ["proof (state)\nthis:\n  0 \\<le> t\n  t \\<le> 1\n  x = complex_of_real t * of_nat k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "hence \"norm x = t * real k\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  t \\<le> 1\n  x = complex_of_real t * of_nat k\n\ngoal (1 subgoal):\n 1. cmod x = t * real k", "by (simp add: norm_mult)"], ["proof (state)\nthis:\n  cmod x = t * real k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "also"], ["proof (state)\nthis:\n  cmod x = t * real k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "from \\<open>t \\<le> 1\\<close> k"], ["proof (chain)\npicking this:\n  t \\<le> 1\n  k \\<in> {..n}", "have *: \"\\<dots> \\<le> 1 * real n\""], ["proof (prove)\nusing this:\n  t \\<le> 1\n  k \\<in> {..n}\n\ngoal (1 subgoal):\n 1. t * real k \\<le> 1 * real n", "by (intro mult_mono) simp_all"], ["proof (state)\nthis:\n  t * real k \\<le> 1 * real n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "finally"], ["proof (chain)\npicking this:\n  cmod x \\<le> 1 * real n", "have x': \"norm x \\<le> real n\""], ["proof (prove)\nusing this:\n  cmod x \\<le> 1 * real n\n\ngoal (1 subgoal):\n 1. cmod x \\<le> real n", "by simp"], ["proof (state)\nthis:\n  cmod x \\<le> real n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "from t \\<open>n > 0\\<close> *"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  t \\<le> 1\n  x = complex_of_real t * of_nat k\n  0 < n\n  t * real k \\<le> 1 * real n", "have x'': \"x \\<in> closed_segment 0 (of_nat n)\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  t \\<le> 1\n  x = complex_of_real t * of_nat k\n  0 < n\n  t * real k \\<le> 1 * real n\n\ngoal (1 subgoal):\n 1. x \\<in> closed_segment 0 (of_nat n)", "by (auto simp: closed_segment_def scaleR_conv_of_real field_simps\n                   intro!: exI[of _ \"t * real k / real n\"] )"], ["proof (state)\nthis:\n  x \\<in> closed_segment 0 (of_nat n)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "have \"norm (poly (of_int_poly f) x) =\n                norm x ^ (p - 1) * cmod (\\<Prod>i = 1..n. x - i) ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (poly (of_int_poly f) x) =\n    cmod x ^ (p - 1) * cmod (\\<Prod>i = 1..n. x - of_nat i) ^ p", "by (simp add: poly_f norm_mult norm_power)"], ["proof (state)\nthis:\n  cmod (poly (of_int_poly f) x) =\n  cmod x ^ (p - 1) * cmod (\\<Prod>i = 1..n. x - of_nat i) ^ p\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "also"], ["proof (state)\nthis:\n  cmod (poly (of_int_poly f) x) =\n  cmod x ^ (p - 1) * cmod (\\<Prod>i = 1..n. x - of_nat i) ^ p\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "from x x' x''"], ["proof (chain)\npicking this:\n  x \\<in> closed_segment 0 (of_nat k)\n  cmod x \\<le> real n\n  x \\<in> closed_segment 0 (of_nat n)", "have \"\\<dots> \\<le> of_nat n ^ (p - 1) * C ^ p\""], ["proof (prove)\nusing this:\n  x \\<in> closed_segment 0 (of_nat k)\n  cmod x \\<le> real n\n  x \\<in> closed_segment 0 (of_nat n)\n\ngoal (1 subgoal):\n 1. cmod x ^ (p - 1) * cmod (\\<Prod>i = 1..n. x - of_nat i) ^ p\n    \\<le> real n ^ (p - 1) * C ^ p", "by (intro mult_mono C power_mono) simp_all"], ["proof (state)\nthis:\n  cmod x ^ (p - 1) * cmod (\\<Prod>i = 1..n. x - of_nat i) ^ p\n  \\<le> real n ^ (p - 1) * C ^ p\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "finally"], ["proof (chain)\npicking this:\n  cmod (poly (of_int_poly f) x) \\<le> real n ^ (p - 1) * C ^ p", "have \"norm (poly (of_int_poly f) x) \\<le> real n ^ (p - 1) * C ^ p\""], ["proof (prove)\nusing this:\n  cmod (poly (of_int_poly f) x) \\<le> real n ^ (p - 1) * C ^ p\n\ngoal (1 subgoal):\n 1. cmod (poly (of_int_poly f) x) \\<le> real n ^ (p - 1) * C ^ p", "."], ["proof (state)\nthis:\n  cmod (poly (of_int_poly f) x) \\<le> real n ^ (p - 1) * C ^ p\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> closed_segment 0 (of_nat k) \\<Longrightarrow>\n  cmod (poly (of_int_poly f) ?x2) \\<le> real n ^ (p - 1) * C ^ p\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "note A = this"], ["proof (state)\nthis:\n  ?x2 \\<in> closed_segment 0 (of_nat k) \\<Longrightarrow>\n  cmod (poly (of_int_poly f) ?x2) \\<le> real n ^ (p - 1) * C ^ p\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "have \"norm (I (of_nat k)) \\<le>\n                      cmod (of_nat k) * exp (cmod (of_nat k)) * (of_nat n ^ (p - 1) * C ^ p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (I (of_nat k))\n    \\<le> cmod (of_nat k) * exp (cmod (of_nat k)) *\n          (real n ^ (p - 1) * C ^ p)", "by (intro lindemann_weierstrass_integral_bound[OF _ A]\n              C mult_nonneg_nonneg zero_le_power) auto"], ["proof (state)\nthis:\n  cmod (I (of_nat k))\n  \\<le> cmod (of_nat k) * exp (cmod (of_nat k)) * (real n ^ (p - 1) * C ^ p)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "also"], ["proof (state)\nthis:\n  cmod (I (of_nat k))\n  \\<le> cmod (of_nat k) * exp (cmod (of_nat k)) * (real n ^ (p - 1) * C ^ p)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "have \"\\<dots> \\<le> cmod (of_nat n) * exp (cmod (of_nat n)) * (of_nat n ^ (p - 1) * C ^ p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (of_nat k) * exp (cmod (of_nat k)) * (real n ^ (p - 1) * C ^ p)\n    \\<le> cmod (of_nat n) * exp (cmod (of_nat n)) *\n          (real n ^ (p - 1) * C ^ p)", "using k"], ["proof (prove)\nusing this:\n  k \\<in> {..n}\n\ngoal (1 subgoal):\n 1. cmod (of_nat k) * exp (cmod (of_nat k)) * (real n ^ (p - 1) * C ^ p)\n    \\<le> cmod (of_nat n) * exp (cmod (of_nat n)) *\n          (real n ^ (p - 1) * C ^ p)", "by (intro mult_mono zero_le_power mult_nonneg_nonneg C) simp_all"], ["proof (state)\nthis:\n  cmod (of_nat k) * exp (cmod (of_nat k)) * (real n ^ (p - 1) * C ^ p)\n  \\<le> cmod (of_nat n) * exp (cmod (of_nat n)) * (real n ^ (p - 1) * C ^ p)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> {..n} \\<Longrightarrow>\n       cmod (of_int (poly.coeff q k) * I (of_nat k))\n       \\<le> real_of_int qmax *\n             (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "finally"], ["proof (chain)\npicking this:\n  cmod (I (of_nat k))\n  \\<le> cmod (of_nat n) * exp (cmod (of_nat n)) * (real n ^ (p - 1) * C ^ p)", "show \"cmod (of_int (coeff q k) * I (of_nat k)) \\<le>\n                      of_int qmax * (real n * exp (real n) * real n ^ (p - 1) * C ^ p)\""], ["proof (prove)\nusing this:\n  cmod (I (of_nat k))\n  \\<le> cmod (of_nat n) * exp (cmod (of_nat n)) * (real n ^ (p - 1) * C ^ p)\n\ngoal (1 subgoal):\n 1. cmod (of_int (poly.coeff q k) * I (of_nat k))\n    \\<le> real_of_int qmax *\n          (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "unfolding norm_mult"], ["proof (prove)\nusing this:\n  cmod (I (of_nat k))\n  \\<le> cmod (of_nat n) * exp (cmod (of_nat n)) * (real n ^ (p - 1) * C ^ p)\n\ngoal (1 subgoal):\n 1. cmod (of_int (poly.coeff q k)) * cmod (I (of_nat k))\n    \\<le> real_of_int qmax *\n          (real n * exp (real n) * real n ^ (p - 1) * C ^ p)", "by (intro mult_mono) (simp_all add: qmax of_int_abs [symmetric] del: of_int_abs)"], ["proof (state)\nthis:\n  cmod (of_int (poly.coeff q k) * I (of_nat k))\n  \\<le> real_of_int qmax *\n        (real n * exp (real n) * real n ^ (p - 1) * C ^ p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n. cmod (of_int (poly.coeff q k) * I (of_nat k)))\n  \\<le> (\\<Sum>k\\<le>n.\n            real_of_int qmax *\n            (real n * exp (real n) * real n ^ (p - 1) * C ^ p))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n. cmod (of_int (poly.coeff q k) * I (of_nat k)))\n  \\<le> (\\<Sum>k\\<le>n.\n            real_of_int qmax *\n            (real n * exp (real n) * real n ^ (p - 1) * C ^ p))\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "have \"\\<dots> = E * F ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n.\n        real_of_int qmax *\n        (real n * exp (real n) * real n ^ (p - 1) * C ^ p)) =\n    E * F ^ p", "using p_pos"], ["proof (prove)\nusing this:\n  0 < p\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n.\n        real_of_int qmax *\n        (real n * exp (real n) * real n ^ (p - 1) * C ^ p)) =\n    E * F ^ p", "by (simp add: power_diff power_mult_distrib E_def F_def)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n.\n      real_of_int qmax *\n      (real n * exp (real n) * real n ^ (p - 1) * C ^ p)) =\n  E * F ^ p\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "finally"], ["proof (chain)\npicking this:\n  cmod J \\<le> E * F ^ p", "show \"fact (p - 1) \\<le> E * F ^ p\""], ["proof (prove)\nusing this:\n  cmod J \\<le> E * F ^ p\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "using J_lower"], ["proof (prove)\nusing this:\n  cmod J \\<le> E * F ^ p\n  fact (p - 1) \\<le> cmod J\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "by linarith"], ["proof (state)\nthis:\n  fact (p - 1) \\<le> E * F ^ p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>prime ?p; n < ?p; \\<bar>poly.coeff q 0\\<bar> < int ?p\\<rbrakk>\n  \\<Longrightarrow> fact (?p - 1) \\<le> E * F ^ ?p\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "have \"(\\<lambda>n. E * F * F ^ (n - 1) / fact (n - 1)) \\<longlonglongrightarrow> 0\" (is ?P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. E * F * F ^ (n - 1) / fact (n - 1))\n    \\<longlonglongrightarrow> 0", "by (intro filterlim_compose[OF power_over_fact_tendsto_0' filterlim_minus_nat_at_top])"], ["proof (state)\nthis:\n  (\\<lambda>n. E * F * F ^ (n - 1) / fact (n - 1))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. E * F * F ^ (n - 1) / fact (n - 1))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "have \"?P \\<longleftrightarrow> (\\<lambda>n. E * F ^ n / fact (n - 1)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. E * F * F ^ (n - 1) / fact (n - 1))\n    \\<longlonglongrightarrow> 0 =\n    (\\<lambda>n. E * F ^ n / fact (n - 1)) \\<longlonglongrightarrow> 0", "by (intro filterlim_cong refl eventually_mono[OF eventually_gt_at_top[of \"0::nat\"]])\n       (auto simp: power_Suc [symmetric] simp del: power_Suc)"], ["proof (state)\nthis:\n  (\\<lambda>n. E * F * F ^ (n - 1) / fact (n - 1))\n  \\<longlonglongrightarrow> 0 =\n  (\\<lambda>n. E * F ^ n / fact (n - 1)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>n. E * F ^ n / fact (n - 1)) \\<longlonglongrightarrow> 0", "have \"eventually (\\<lambda>n. E * F ^ n / fact (n - 1) < 1) at_top\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. E * F ^ n / fact (n - 1)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. E * F ^ n / fact (n - 1) < 1", "by (rule order_tendstoD) simp_all"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. E * F ^ n / fact (n - 1) < 1\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "hence \"eventually (\\<lambda>n. E * F ^ n < fact (n - 1)) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially. E * F ^ n / fact (n - 1) < 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. E * F ^ n < fact (n - 1)", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. E * F ^ n < fact (n - 1)\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially. E * F ^ n < fact (n - 1)", "obtain P where P: \"\\<And>n. n \\<ge> P \\<Longrightarrow> E * F ^ n < fact (n - 1)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially. E * F ^ n < fact (n - 1)\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        (\\<And>n.\n            P \\<le> n \\<Longrightarrow>\n            E * F ^ n < fact (n - 1)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: eventually_at_top_linorder)"], ["proof (state)\nthis:\n  P \\<le> ?n \\<Longrightarrow> E * F ^ ?n < fact (?n - 1)\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "have \"\\<exists>p. prime p \\<and> p > Max {nat (abs (coeff q 0)), n, P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       prime p \\<and> Max {nat \\<bar>poly.coeff q 0\\<bar>, n, P} < p", "by (rule bigger_prime)"], ["proof (state)\nthis:\n  \\<exists>p. prime p \\<and> Max {nat \\<bar>poly.coeff q 0\\<bar>, n, P} < p\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. prime p \\<and> Max {nat \\<bar>poly.coeff q 0\\<bar>, n, P} < p", "obtain p where \"prime p\" \"p > Max {nat (abs (coeff q 0)), n, P}\""], ["proof (prove)\nusing this:\n  \\<exists>p. prime p \\<and> Max {nat \\<bar>poly.coeff q 0\\<bar>, n, P} < p\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p;\n         Max {nat \\<bar>poly.coeff q 0\\<bar>, n, P} < p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prime p\n  Max {nat \\<bar>poly.coeff q 0\\<bar>, n, P} < p\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "hence \"int p > abs (coeff q 0)\" \"p > n\" \"p \\<ge> P\""], ["proof (prove)\nusing this:\n  prime p\n  Max {nat \\<bar>poly.coeff q 0\\<bar>, n, P} < p\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff q 0\\<bar> < int p &&& n < p &&& P \\<le> p", "by auto"], ["proof (state)\nthis:\n  \\<bar>poly.coeff q 0\\<bar> < int p\n  n < p\n  P \\<le> p\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "with ineq[of p] \\<open>prime p\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>prime p; n < p; \\<bar>poly.coeff q 0\\<bar> < int p\\<rbrakk>\n  \\<Longrightarrow> fact (p - 1) \\<le> E * F ^ p\n  prime p\n  \\<bar>poly.coeff q 0\\<bar> < int p\n  n < p\n  P \\<le> p", "have \"fact (p - 1) \\<le> E * F ^ p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>prime p; n < p; \\<bar>poly.coeff q 0\\<bar> < int p\\<rbrakk>\n  \\<Longrightarrow> fact (p - 1) \\<le> E * F ^ p\n  prime p\n  \\<bar>poly.coeff q 0\\<bar> < int p\n  n < p\n  P \\<le> p\n\ngoal (1 subgoal):\n 1. fact (p - 1) \\<le> E * F ^ p", "by simp"], ["proof (state)\nthis:\n  fact (p - 1) \\<le> E * F ^ p\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fact (p - 1) \\<le> E * F ^ p\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "from \\<open>p \\<ge> P\\<close>"], ["proof (chain)\npicking this:\n  P \\<le> p", "have \"fact (p - 1) > E * F ^ p\""], ["proof (prove)\nusing this:\n  P \\<le> p\n\ngoal (1 subgoal):\n 1. E * F ^ p < fact (p - 1)", "by (rule P)"], ["proof (state)\nthis:\n  E * F ^ p < fact (p - 1)\n\ngoal (1 subgoal):\n 1. algebraic (exp 1) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  fact (p - 1) \\<le> E * F ^ p\n  E * F ^ p < fact (p - 1)", "show False"], ["proof (prove)\nusing this:\n  fact (p - 1) \\<le> E * F ^ p\n  E * F ^ p < fact (p - 1)\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary e_transcendental_real: \"\\<not> algebraic (exp 1 :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (exp 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> algebraic (exp 1)", "have \"\\<not>algebraic (exp 1 :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (exp 1)", "by (rule e_transcendental_complex)"], ["proof (state)\nthis:\n  \\<not> algebraic (exp 1)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (exp 1)", "also"], ["proof (state)\nthis:\n  \\<not> algebraic (exp 1)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (exp 1)", "have \"(exp 1 :: complex) = of_real (exp 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp 1 = complex_of_real (exp 1)", "using exp_of_real[of 1]"], ["proof (prove)\nusing this:\n  exp (of_real 1) = of_real (exp 1)\n\ngoal (1 subgoal):\n 1. exp 1 = complex_of_real (exp 1)", "by simp"], ["proof (state)\nthis:\n  exp 1 = complex_of_real (exp 1)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (exp 1)", "also"], ["proof (state)\nthis:\n  exp 1 = complex_of_real (exp 1)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (exp 1)", "have \"algebraic \\<dots> \\<longleftrightarrow> algebraic (exp 1 :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (complex_of_real (exp 1)) = algebraic (exp 1)", "by simp"], ["proof (state)\nthis:\n  algebraic (complex_of_real (exp 1)) = algebraic (exp 1)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (exp 1)", "finally"], ["proof (chain)\npicking this:\n  \\<not> algebraic (exp 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> algebraic (exp 1)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (exp 1)", "."], ["proof (state)\nthis:\n  \\<not> algebraic (exp 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}