{"file_name": "/home/qj213/afp-2021-10-22/thys/Hermite/Hermite.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hermite", "problem_names": ["lemma coeff_dvd_poly: \"[:coeff a (degree a):] dvd (a::'a::{field} poly)\"", "lemma poly_dvd_antisym2:\n  fixes p q :: \"'a::field poly\"\n  assumes dvd1: \"p dvd q\" and dvd2: \"q dvd p\" \n  shows \"p div [:coeff p (degree p):] = q div [:coeff q (degree q):]\"", "lemma unit_prod:\n  assumes \"finite S\"\n  shows \"is_unit (prod (\\<lambda>i. U $ i $ i) S) = (\\<forall>i\\<in>S. is_unit (U $ i $ i))\"", "lemma is_unit_diagonal: \n  fixes U::\"'a::{comm_ring_1, algebraic_semidom}^'n::{finite, wellorder}^'n::{finite, wellorder}\"\n  assumes U: \"upper_triangular U\"\n  and det_U: \"is_unit (det U)\"\n  shows \"\\<forall>i. is_unit (U $ i $ i)\"", "lemma upper_triangular_mult:\n  fixes A::\"'a::{semiring_1}^'n::{mod_type}^'n::{mod_type}\"\n  assumes A: \"upper_triangular A\"\n  and B: \"upper_triangular B\"\n  shows \"upper_triangular (A**B)\"", "lemma upper_triangular_adjugate:\n  fixes A::\"(('a::comm_ring_1,'n::{wellorder, finite}) vec, 'n) vec\"\n  assumes A: \"upper_triangular A\"\n  shows \"upper_triangular (adjugate A)\"", "lemma upper_triangular_inverse:\n  fixes A::\"(('a::{euclidean_semiring,comm_ring_1},'n::{wellorder, finite}) vec, 'n) vec\"\n  assumes A: \"upper_triangular A\"\n  and inv_A: \"invertible A\"\n  shows \"upper_triangular (matrix_inv A)\"", "lemma upper_triangular_mult_diagonal:\n  fixes A::\"(('a::{semiring_1},'n::{wellorder, finite}) vec, 'n) vec\"\n  assumes A: \"upper_triangular A\"\n  and B: \"upper_triangular B\"\n  shows \"(A**B) $ i $ i = A $ i $ i * B $ i $ i\"", "lemma add_left_neutral:\n  fixes a::\"'n::mod_type\"\n  shows \"(a + b = a) = (b = 0)\"", "lemma from_nat_1: \"from_nat 1 = 1\"", "lemma dvd_minus_eq_mod:\n  fixes c::\"'a::unique_euclidean_ring\"\n  assumes \"c \\<noteq> 0\" and \"c dvd a - b\" shows \"a mod c = b mod c\"", "lemma eq_mod_dvd_minus:\n  fixes c::\"'a::unique_euclidean_ring\"\n  assumes \"c \\<noteq> 0\" and \"a mod c = b mod c\" \n  shows \"c dvd a - b\"", "lemma dvd_cong_not_eq_mod:\n  fixes c::\"'a::unique_euclidean_ring\"\n  assumes \"xa mod c \\<noteq> xb\" and \"c dvd xa mod c - xb\" and \"c \\<noteq> 0\"\n  shows \"xb mod c \\<noteq> xb\"", "lemma diff_mod_cong_0:\n  fixes c::\"'a::unique_euclidean_ring\"\n  assumes \"xa mod c \\<noteq> xb mod c\" and\" c dvd xa mod c - xb mod c\" shows \"c = 0\"", "lemma cong_diff_mod:\n  fixes c::\"'a::unique_euclidean_ring\"\n  assumes \"xa \\<noteq> xb\" and \"c dvd xa - xb\" and \"xa = xa mod c\" shows \"xb \\<noteq> xb mod c\"", "lemma exists_k_mod:\n  fixes c::\"'a::unique_euclidean_ring\"\n  shows \"\\<exists>k. a mod c = a + k * c\"", "lemma cong_eq: \"cong a c b = (b dvd (a - c))\"", "lemma Units_eq: \"Units = {x. x dvd 1}\"", "lemma normalize_Units: \"x \\<in> Units \\<Longrightarrow> normalize x = 1\"", "lemma associated_eq: \"(normalize a = normalize b) \\<longleftrightarrow> (\\<exists>u\\<in>Units. a = u*b)\"", "lemma equiv_associated: \n  shows \"equiv UNIV associated_rel\"", "lemma relf_congruent_rel: \"refl (congruent_rel b)\"", "lemma sym_congruent_rel: \"sym (congruent_rel b)\"", "lemma trans_congruent_rel: \"trans (congruent_rel b)\"", "lemma equiv_congruent: \"equiv UNIV (congruent_rel b)\"", "lemma ass_function_Complete_set_non_associates:\n  assumes f: \"ass_function f\"\n  shows \"Complete_set_non_associates (f`UNIV)\"", "lemma in_Ass_not_associated:\n  assumes Ass_S: \"Complete_set_non_associates S\" \n  and x: \"x\\<in>S\" and y: \"y\\<in>S\" and x_not_y: \"x\\<noteq>y\" \n  shows \"normalize x \\<noteq> normalize y\"", "lemma ass_function_0:\n  assumes r: \"ass_function ass\"\n  shows \"(ass x = 0) = (x = 0)\"", "lemma ass_function_0':\n  assumes r: \"ass_function ass\"\n  shows \"(ass x div x = 0) = (x=0)\"", "lemma res_function_Complete_set_residues:\n  assumes f: \"res_function f\"\n  shows \"Complete_set_residues (\\<lambda>c. (f c)`UNIV)\"", "lemma in_Res_not_congruent:\n  assumes res_g: \"Complete_set_residues g\" \n  and x: \"x \\<in> g b\" and y: \"y \\<in> g b\" and x_not_y: \"x\\<noteq>y\" \n  shows \"\\<not> cong x y b\"", "lemma ass_function_euclidean: \"ass_function ass_function_euclidean\"", "lemma res_function_euclidean: \n  \"res_function (res_function_euclidean :: 'a :: unique_euclidean_ring \\<Rightarrow> _)\"", "lemma ass_function_int: \"ass_function_int = ass_function_euclidean\"", "lemma ass_function_int_UNIV: \"(ass_function_int` UNIV) = {x. x\\<ge>0}\"", "lemma echelon_form_upt_row_condition1_explicit:\n  assumes \"echelon_form_upt_row A k\"\n  and \"to_nat i < k\" and \"is_zero_row i A\"\n  shows \"\\<not> (\\<exists>j. j>i \\<and> to_nat j < k \\<and> \\<not> is_zero_row j A)\"", "lemma echelon_form_upt_row_condition1_explicit':\n  assumes \"echelon_form_upt_row A k\"\n  and \"to_nat i < k\" and \"is_zero_row i A\" and \"i\\<le>j\" and \"to_nat j < k\"\n  shows \"is_zero_row j A\"", "lemma echelon_form_upt_row_condition1_explicit_neg:\n  assumes \"echelon_form_upt_row A k\"\n  and iA: \"\\<not> is_zero_row i A\" and ia_i: \"ia < i\"\n  and i: \"to_nat i < k\"\n  shows \"\\<not> is_zero_row ia A\"", "lemma echelon_form_upt_row_condition2_explicit:\n  assumes \"echelon_form_upt_row A k\"\n  and \"ia < j\" and \"to_nat j < k\" and \"\\<not> is_zero_row ia A\" and \"\\<not> is_zero_row j A\"\n  shows \"(LEAST n. A $ ia $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)\"", "lemma echelon_form_upt_row_intro:\n  assumes\"(\\<forall>i. to_nat i < k \\<and> is_zero_row i A \\<longrightarrow> \\<not> (\\<exists>j. i<j \\<and> to_nat j < k \\<and> \\<not> is_zero_row j A))\"\n  and \"(\\<forall>i j. i < j \\<and> to_nat j <  k \\<and> \\<not> is_zero_row i A \\<and> \\<not> is_zero_row j A \\<longrightarrow> (LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0))\"\n  shows \"echelon_form_upt_row A k\"", "lemma echelon_form_echelon_form_upt_row: \"echelon_form A = echelon_form_upt_row A (nrows A)\"", "lemma Hermite_Hermite_upt_row: \"Hermite ass res A = Hermite_upt_row A (nrows A) ass res\"", "lemma Hermite_intro:\n  assumes \"Complete_set_non_associates associates\"\n  and \"Complete_set_residues residues\"\n  and \"echelon_form A \"\n  and \"(\\<forall>i. \\<not> is_zero_row i A \\<longrightarrow> A $ i $ (LEAST n. A $ i $ n \\<noteq> 0) \\<in> associates)\"\n  and \"(\\<forall>i. \\<not> is_zero_row i A \\<longrightarrow> (\\<forall>j. j<i \\<longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) \\<in> residues (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))))\"\n  shows \"Hermite associates residues A\"", "lemma Hermite_reduce_above_preserves:\n  assumes n: \"n\\<le>to_nat a\"\n  shows \"(Hermite_reduce_above A n i j res) $ a $ b = A $ a $ b\"", "lemma Hermite_reduce_above_works:\n  assumes n: \"n \\<le> to_nat i\" and a: \"to_nat a < n\"\n  shows \"(Hermite_reduce_above A n i j res) $ a $ b \n         = row_add A a i ((res (A$i$j) (A$a$j) - (A$a$j)) div (A$i$j)) $ a $ b\"", "lemma Hermite_of_row_preserves_below:\nassumes i_a: \"i<a\"\nshows \"(Hermite_of_row_i ass res A i) $ a $ b = A $ a $ b\"", "lemma Hermite_of_row_preserves_previous_cols:\nassumes b: \"b<(LEAST n. A $ i $ n \\<noteq> 0)\"\nand not_zero_i_A: \"\\<not> is_zero_row i A\"\nand e: \"echelon_form A\"\nshows \"(Hermite_of_row_i ass res A i) $ a $ b = A $ a $ b\"", "lemma echelon_form_Hermite_of_condition1:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and not_zero_iA: \"\\<not> is_zero_row i A\"\n  and zero_ia_H: \"is_zero_row ia H\"\n  and ia_j: \"ia < j\"\n  shows \"is_zero_row j H\"", "lemma row_zero_A_imp_row_zero_H:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes e: \"echelon_form A\"\n  and not_zero_iA: \"\\<not> is_zero_row i A\"\n  and zero_j_A: \"is_zero_row j A\"\n  shows \"is_zero_row j H\"", "lemma Hermite_reduce_above_Least_eq_le:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes i_ia: \"i<ia\"\n  and not_zero_ia_H: \"\\<not> is_zero_row ia H\"\n  shows \"(LEAST n. A $ ia $ n \\<noteq> 0) = (LEAST n. H $ ia $ n \\<noteq> 0)\"", "lemma Hermite_reduce_above_Least_eq:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes a: \"ass_function ass\"\n  and not_zero_iA: \"\\<not> is_zero_row i A\"\n  shows \"(LEAST n. A $ i $ n \\<noteq> 0) = (LEAST n. H $ i $ n \\<noteq> 0)\"", "lemma Hermite_reduce_above_Least_eq_ge:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes e: \"echelon_form A\"\n  and not_zero_iA: \"\\<not> is_zero_row i A\"\n  and not_zero_ia_A: \"\\<not> is_zero_row ia A\"\n  and not_zero_ia_H: \"\\<not> is_zero_row ia H\"\n  and ia_less_i: \"ia < i\"\n  shows \"(LEAST n. H $ ia $ n \\<noteq> 0) = (LEAST n. A $ ia $ n \\<noteq> 0)\"", "lemma Hermite_reduce_above_Least:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) \n  div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and not_zero_iA: \"\\<not> is_zero_row i A\"\n  and not_zero_ia_A: \"\\<not> is_zero_row ia A\"\n  and not_zero_ia_H: \"\\<not> is_zero_row ia H\"\n  shows \"(LEAST n. H $ ia $ n \\<noteq> 0) = (LEAST n. A $ ia $ n \\<noteq> 0)\"", "lemma echelon_form_Hermite_of_condition2:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and not_zero_iA: \"\\<not> is_zero_row i A\"\n  and ia_less_j: \"ia < j\"\n  and not_zero_ia_H: \"\\<not> is_zero_row ia H\"\n  and not_zero_j_H: \"\\<not> is_zero_row j H\"\n  shows \"(LEAST n. H $ ia $ n \\<noteq> 0) < (LEAST n. H $ j $ n \\<noteq> 0)\"", "lemma echelon_form_Hermite_of_row:\n  assumes a: \"ass_function ass\"\n  and \"res_function res\"\n  and e: \"echelon_form A\"\n  shows \"echelon_form (Hermite_of_row_i ass res A i)\"", "lemma echelon_form_fold_Hermite_of_row_i:\n  assumes e: \"echelon_form A\" and a: \"ass_function ass\" and r: \"res_function res\"\n  shows \"echelon_form (foldl (Hermite_of_row_i ass res) A (map from_nat [0..<k]))\"", "lemma echelon_form_Hermite_of_upt_row_i:\n  assumes e: \"echelon_form A\" and a: \"ass_function ass\" and r: \"res_function res\"\n  shows \"echelon_form (Hermite_of_upt_row_i A k ass res)\"", "lemma echelon_form_Hermite_of:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  shows \"echelon_form (Hermite_of A ass res bezout)\"", "lemma in_ass_Hermite_of_row:\n  assumes a: \"ass_function ass\"\n  and \"res_function res\"\n  and not_zero_i_A: \"\\<not> is_zero_row i A\"\n  shows \"(Hermite_of_row_i ass res A i) $ i $ (LEAST n. (Hermite_of_row_i ass res A i) $ i $ n \\<noteq> 0) \\<in> range ass\"", "lemma Hermite_of_upt_row_preserves_below:\n  assumes i: \"to_nat a\\<ge>k\"\n  shows \"Hermite_of_upt_row_i A k ass res $ a $ b = A $ a $ b\"", "lemma not_zero_Hermite_reduce_above:\n  fixes ass i A\n  defines M: \"M\\<equiv>(mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)))\"\n  assumes not_zero_a_A: \"\\<not> is_zero_row a A\"\n  and not_zero_i_A: \"\\<not> is_zero_row i A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and n: \"n \\<le> to_nat i\"\n  shows \"\\<not> is_zero_row a (Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> 0) res)\"", "lemma Least_Hermite_of_row_i:\n  assumes i: \"\\<not> is_zero_row i A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  shows \"(LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> 0) = (LEAST n. A $ i $ n \\<noteq> 0)\"", "lemma Least_Hermite_of_row_i2:\n  assumes i: \"\\<not> is_zero_row i A\" and k: \"\\<not> is_zero_row k A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  shows \"(LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> 0) = (LEAST n. A $ i $ n \\<noteq> 0)\"", "lemma Hermite_of_row_i_works:\n  fixes i A ass\n  defines n:\"n \\<equiv>(LEAST n. A $ i $ n \\<noteq> 0)\"\n  defines M:\"M \\<equiv> (mult_row A i (ass (A $ i $ n) div A $ i $ n))\"\n  assumes ai: \"a < i\"\n  and i: \"\\<not> is_zero_row i A\"\n  shows \"Hermite_of_row_i ass res A i $ a $ b = \n  row_add M a i ((res (M $ i $ n) (M $ a $ n) \n  - M $ a $ n) div M $ i $ n) $ a $ b\"", "lemma Hermite_of_row_i_works2:\n  fixes i A ass\n  defines n:\"n \\<equiv>(LEAST n. A $ i $ n \\<noteq> 0)\"\n  defines M:\"M \\<equiv> (mult_row A i (ass (A $ i $ n) div A $ i $ n))\"\n  assumes i: \"\\<not> is_zero_row i A\"\n  shows \"Hermite_of_row_i ass res A i $ i $ b = M $ i $ b\"", "lemma Hermite_of_upt_row_preserves_nonzero_rows_ge:\n  assumes i: \"\\<not> is_zero_row i A\" and i2: \"to_nat i\\<ge>k\"\n  shows \"\\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\"", "lemma Hermite_of_upt_row_i_Least_ge:\n  assumes i: \"\\<not> is_zero_row i A\"\n  and i2: \"to_nat i\\<ge>k\"\n  shows \"(LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> 0) = (LEAST n. A $ i $ n \\<noteq> 0)\"", "lemma Hermite_of_upt_row_i_Least:\n  assumes iA: \"\\<not> is_zero_row i A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and k: \"k\\<le>nrows A\"\n  shows \"(LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> 0) = (LEAST n. A $ i $ n \\<noteq> 0)\"", "lemma Hermite_of_upt_row_preserves_nonzero_rows:\n  assumes i: \"\\<not> is_zero_row i A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and k: \"k\\<le>nrows A\"\n  shows \"\\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\"", "lemma Hermite_of_upt_row_i_in_range:\n  fixes k ass res\n  assumes not_zero_i_A: \"\\<not> is_zero_row i A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and k: \"to_nat i<k\"\n  and k2: \"k\\<le>nrows A\"\n  shows \"Hermite_of_upt_row_i A k ass res $ i $ (LEAST n. A $ i $ n \\<noteq> 0) \\<in> range ass\"", "lemma Hermite_of_upt_row_preserves_zero_rows_ge:\n  assumes i: \"is_zero_row i A\"\n  and k: \"k \\<le> nrows A\"\n  and ik: \"to_nat i\\<ge>k\"\n  shows \"is_zero_row i (Hermite_of_upt_row_i A k ass res)\"", "lemma Hermite_of_upt_row_preserves_zero_rows:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes i: \"is_zero_row i A\"\n  and e: \"echelon_form A\" and a: \"ass_function ass\" and r: \"res_function res\" and k: \"k \\<le> nrows A\"\n  shows \"is_zero_row i (Hermite_of_upt_row_i A k ass res)\"", "lemma Hermite_of_preserves_zero_rows:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes i: \"is_zero_row i (echelon_form_of A bezout)\"\n  and a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  shows \"is_zero_row i (Hermite_of A ass res bezout)\"", "lemma Hermite_of_Least:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes i: \"\\<not> is_zero_row i (Hermite_of A ass res bezout)\"\n  and a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  shows \"(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> 0) = (LEAST n. (echelon_form_of A bezout) $ i $ n \\<noteq> 0)\"", "lemma in_associates_Hermite_of:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  and i: \"\\<not> is_zero_row i (Hermite_of A ass res bezout)\"\n  shows \"Hermite_of A ass res bezout $ i $ (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> 0) \\<in> range ass\"", "lemma Hermite_of_row_i_range_res:\n  assumes ji: \"j<i\" and not_zero_i_A: \"\\<not> is_zero_row i A\" and r: \"res_function res\"\n  shows \"Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> 0) \n  \\<in> range (res (Hermite_of_row_i ass res A i $ i $ (LEAST n. A $ i $ n \\<noteq> 0)))\"", "lemma Hermite_of_upt_row_i_in_range_res:\n  fixes k ass res\n  assumes not_zero_i_A: \"\\<not> is_zero_row i A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and k: \"to_nat i<k\"\n  and k2: \"k\\<le>nrows A\"\n  and j: \"j<i\"\n  shows \"Hermite_of_upt_row_i A k ass res $ j $ (LEAST n. A $ i $ n \\<noteq> 0) \n  \\<in> range (res (Hermite_of_upt_row_i A k ass res $ i $ (LEAST n. A $ i $ n \\<noteq> 0)))\"", "lemma in_residues_Hermite_of:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  and i: \"\\<not> is_zero_row i (Hermite_of A ass res bezout)\"\n  and ji: \"j < i\"\n  shows \"Hermite_of A ass res bezout $ j $ (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> 0)\n  \\<in> range (res (Hermite_of A ass res bezout $ i $ (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> 0)))\"", "lemma Hermite_Hermite_of:\n  assumes a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  shows \"Hermite (range ass) (\\<lambda>c. range (res c)) (Hermite_of A ass res bezout)\"", "lemma invertible_Hermite_reduce_above:\n  assumes n: \"n \\<le> to_nat i\"\n  shows \"\\<exists>P. invertible P \\<and> Hermite_reduce_above A n i j res = P ** A\"", "lemma invertible_Hermite_of_row_i:\n  assumes a: \"ass_function ass\"\n  shows \"\\<exists>P. invertible P \\<and> Hermite_of_row_i ass res A i = P ** A\"", "lemma invertible_Hermite_of_upt_row_i:\n  assumes a: \"ass_function ass\"\n  shows \"\\<exists>P. invertible P \\<and> Hermite_of_upt_row_i A k ass res = P ** A\"", "lemma invertible_Hermite_of:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes a: \"ass_function ass\" \n  and b: \"is_bezout_ext bezout\"\n  shows \"\\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A\"", "lemma Hermite:\n  assumes a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  shows \"\\<exists>P. invertible P \\<and> (Hermite_of A ass res bezout) = P ** A \\<and> \n  Hermite (range ass) (\\<lambda>c. range (res c)) (Hermite_of A ass res bezout)\"", "lemma diagonal_least_nonzero:\n  fixes H :: \"(('a :: {bezout_ring_div, normalization_euclidean_semiring, unique_euclidean_ring}, 'b :: mod_type) vec, 'b) vec\"\n  assumes H: \"Hermite associates residues H\"\n  and inv_H: \"invertible H\" and up_H: \"upper_triangular H\"\n  shows \"(LEAST n. H $ i $ n \\<noteq> 0) = i\"", "lemma diagonal_in_associates:\n  fixes H :: \"(('a :: {bezout_ring_div, normalization_euclidean_semiring, unique_euclidean_ring}, 'b :: mod_type) vec, 'b) vec\"\n  assumes H: \"Hermite associates residues H\"\n  and inv_H: \"invertible H\" and up_H: \"upper_triangular H\"\n  shows \"H $ i $ i \\<in> associates\"", "lemma above_diagonal_in_residues:\n  fixes H :: \"(('a :: {bezout_ring_div, normalization_euclidean_semiring, unique_euclidean_ring}, 'b :: mod_type) vec, 'b) vec\"\n  assumes H: \"Hermite associates residues H\"\n  and inv_H: \"invertible H\" and up_H: \"upper_triangular H\"\n  and j_i: \"j<i\"\n  shows \"H $ j $ (LEAST n. H $ i $ n \\<noteq> 0) \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))\"", "lemma Hermite_unique:\n  fixes K::\"'a::{bezout_ring_div,normalization_euclidean_semiring,unique_euclidean_ring}^'n::mod_type^'n::mod_type\"\n  assumes A_PH: \"A = P ** H\" \n  and A_QK: \"A = Q ** K\"\n  and inv_A: \"invertible A\"\n  and inv_P: \"invertible P\"\n  and inv_Q: \"invertible Q\"\n  and H: \"Hermite associates residues H\"\n  and K: \"Hermite associates residues K\"\n  shows \"H = K\""], "translations": [["", "lemma coeff_dvd_poly: \"[:coeff a (degree a):] dvd (a::'a::{field} poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:lead_coeff a:] dvd a", "proof (cases \"a=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> [:lead_coeff a:] dvd a\n 2. a \\<noteq> 0 \\<Longrightarrow> [:lead_coeff a:] dvd a", "case True"], ["proof (state)\nthis:\n  a = 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> [:lead_coeff a:] dvd a\n 2. a \\<noteq> 0 \\<Longrightarrow> [:lead_coeff a:] dvd a", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = 0\n\ngoal (1 subgoal):\n 1. [:lead_coeff a:] dvd a", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  a = 0\n\ngoal (1 subgoal):\n 1. \\<exists>k. a = [:lead_coeff a:] * k", "by simp"], ["proof (state)\nthis:\n  [:lead_coeff a:] dvd a\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> [:lead_coeff a:] dvd a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> [:lead_coeff a:] dvd a", "case False"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> [:lead_coeff a:] dvd a", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [:lead_coeff a:] dvd a", "by (intro dvd_trans[OF is_unit_triv one_dvd]) simp"], ["proof (state)\nthis:\n  [:lead_coeff a:] dvd a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_dvd_antisym2:\n  fixes p q :: \"'a::field poly\"\n  assumes dvd1: \"p dvd q\" and dvd2: \"q dvd p\" \n  shows \"p div [:coeff p (degree p):] = q div [:coeff q (degree q):]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p div [:lead_coeff p:] = q div [:lead_coeff q:]", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> p div [:lead_coeff p:] = q div [:lead_coeff q:]\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p div [:lead_coeff p:] = q div [:lead_coeff q:]", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> p div [:lead_coeff p:] = q div [:lead_coeff q:]\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p div [:lead_coeff p:] = q div [:lead_coeff q:]", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. p div [:lead_coeff p:] = q div [:lead_coeff q:]", "by (metis dvd1 dvd_0_left_iff)"], ["proof (state)\nthis:\n  p div [:lead_coeff p:] = q div [:lead_coeff q:]\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p div [:lead_coeff p:] = q div [:lead_coeff q:]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p div [:lead_coeff p:] = q div [:lead_coeff q:]", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p div [:lead_coeff p:] = q div [:lead_coeff q:]", "have q: \"q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by (metis False dvd2 dvd_0_left_iff)"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p div [:lead_coeff p:] = q div [:lead_coeff q:]", "have degree: \"degree p = degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = degree q", "using \\<open>p dvd q\\<close> \\<open>q dvd p\\<close> \\<open>p \\<noteq> 0\\<close> \\<open>q \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  p dvd q\n  q dvd p\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p = degree q", "by (intro order_antisym dvd_imp_degree_le)"], ["proof (state)\nthis:\n  degree p = degree q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p div [:lead_coeff p:] = q div [:lead_coeff q:]", "from \\<open>p dvd q\\<close>"], ["proof (chain)\npicking this:\n  p dvd q", "obtain a where a: \"q = p * a\""], ["proof (prove)\nusing this:\n  p dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>a. q = p * a \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  q = p * a\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p div [:lead_coeff p:] = q div [:lead_coeff q:]", "with \\<open>q \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  q = p * a", "have \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  q = p * a\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p div [:lead_coeff p:] = q div [:lead_coeff q:]", "with degree a \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  degree p = degree q\n  q = p * a\n  p \\<noteq> 0\n  a \\<noteq> 0", "have \"degree a = 0\""], ["proof (prove)\nusing this:\n  degree p = degree q\n  q = p * a\n  p \\<noteq> 0\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree a = 0", "by (simp add: degree_mult_eq)"], ["proof (state)\nthis:\n  degree a = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    p div [:lead_coeff p:] = q div [:lead_coeff q:]", "with a"], ["proof (chain)\npicking this:\n  q = p * a\n  degree a = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  q = p * a\n  degree a = 0\n\ngoal (1 subgoal):\n 1. p div [:lead_coeff p:] = q div [:lead_coeff q:]", "proof (cases a, auto split: if_splits, metis \\<open>a \\<noteq> 0\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>a = [:aa:]; q = smult aa p; aa \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> p div [:lead_coeff p:] =\n                         smult aa p div [:aa * lead_coeff p:]", "fix aa :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>a = [:aa:]; q = smult aa p; aa \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> p div [:lead_coeff p:] =\n                         smult aa p div [:aa * lead_coeff p:]", "assume a1: \"aa \\<noteq> 0\""], ["proof (state)\nthis:\n  aa \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>a = [:aa:]; q = smult aa p; aa \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> p div [:lead_coeff p:] =\n                         smult aa p div [:aa * lead_coeff p:]", "assume \"q = smult aa p\""], ["proof (state)\nthis:\n  q = smult aa p\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>a = [:aa:]; q = smult aa p; aa \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> p div [:lead_coeff p:] =\n                         smult aa p div [:aa * lead_coeff p:]", "have \"[:aa * coeff p (degree p):] dvd smult aa p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:aa * lead_coeff p:] dvd smult aa p", "using a1"], ["proof (prove)\nusing this:\n  aa \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. [:aa * lead_coeff p:] dvd smult aa p", "by (metis (no_types) coeff_dvd_poly coeff_smult degree_smult_eq)"], ["proof (state)\nthis:\n  [:aa * lead_coeff p:] dvd smult aa p\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>a = [:aa:]; q = smult aa p; aa \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> p div [:lead_coeff p:] =\n                         smult aa p div [:aa * lead_coeff p:]", "thus \"p div [:coeff p (degree p):] = smult aa p div [:aa * coeff p (degree p):]\""], ["proof (prove)\nusing this:\n  [:aa * lead_coeff p:] dvd smult aa p\n\ngoal (1 subgoal):\n 1. p div [:lead_coeff p:] = smult aa p div [:aa * lead_coeff p:]", "using a1"], ["proof (prove)\nusing this:\n  [:aa * lead_coeff p:] dvd smult aa p\n  aa \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. p div [:lead_coeff p:] = smult aa p div [:aa * lead_coeff p:]", "by (simp add: False coeff_dvd_poly dvd_div_div_eq_mult)"], ["proof (state)\nthis:\n  p div [:lead_coeff p:] = smult aa p div [:aa * lead_coeff p:]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p div [:lead_coeff p:] = q div [:lead_coeff q:]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Units\\<close>"], ["", "lemma unit_prod:\n  assumes \"finite S\"\n  shows \"is_unit (prod (\\<lambda>i. U $ i $ i) S) = (\\<forall>i\\<in>S. is_unit (U $ i $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (\\<Prod>i\\<in>S. U $ i $ i) =\n    (\\<forall>i\\<in>S. is_unit (U $ i $ i))", "using assms"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. is_unit (\\<Prod>i\\<in>S. U $ i $ i) =\n    (\\<forall>i\\<in>S. is_unit (U $ i $ i))", "proof (induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_unit (\\<Prod>i\\<in>{}. U $ i $ i) =\n    (\\<forall>i\\<in>{}. is_unit (U $ i $ i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_unit (\\<Prod>i\\<in>F. U $ i $ i) =\n        (\\<forall>i\\<in>F. is_unit (U $ i $ i))\\<rbrakk>\n       \\<Longrightarrow> is_unit (\\<Prod>i\\<in>insert x F. U $ i $ i) =\n                         (\\<forall>i\\<in>insert x F. is_unit (U $ i $ i))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. is_unit (\\<Prod>i\\<in>{}. U $ i $ i) =\n    (\\<forall>i\\<in>{}. is_unit (U $ i $ i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_unit (\\<Prod>i\\<in>F. U $ i $ i) =\n        (\\<forall>i\\<in>F. is_unit (U $ i $ i))\\<rbrakk>\n       \\<Longrightarrow> is_unit (\\<Prod>i\\<in>insert x F. U $ i $ i) =\n                         (\\<forall>i\\<in>insert x F. is_unit (U $ i $ i))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (\\<Prod>i\\<in>{}. U $ i $ i) =\n    (\\<forall>i\\<in>{}. is_unit (U $ i $ i))", "by auto"], ["proof (state)\nthis:\n  is_unit (\\<Prod>i\\<in>{}. U $ i $ i) =\n  (\\<forall>i\\<in>{}. is_unit (U $ i $ i))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_unit (\\<Prod>i\\<in>F. U $ i $ i) =\n        (\\<forall>i\\<in>F. is_unit (U $ i $ i))\\<rbrakk>\n       \\<Longrightarrow> is_unit (\\<Prod>i\\<in>insert x F. U $ i $ i) =\n                         (\\<forall>i\\<in>insert x F. is_unit (U $ i $ i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_unit (\\<Prod>i\\<in>F. U $ i $ i) =\n        (\\<forall>i\\<in>F. is_unit (U $ i $ i))\\<rbrakk>\n       \\<Longrightarrow> is_unit (\\<Prod>i\\<in>insert x F. U $ i $ i) =\n                         (\\<forall>i\\<in>insert x F. is_unit (U $ i $ i))", "case (insert a S)"], ["proof (state)\nthis:\n  finite S\n  a \\<notin> S\n  is_unit (\\<Prod>i\\<in>S. U $ i $ i) =\n  (\\<forall>i\\<in>S. is_unit (U $ i $ i))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_unit (\\<Prod>i\\<in>F. U $ i $ i) =\n        (\\<forall>i\\<in>F. is_unit (U $ i $ i))\\<rbrakk>\n       \\<Longrightarrow> is_unit (\\<Prod>i\\<in>insert x F. U $ i $ i) =\n                         (\\<forall>i\\<in>insert x F. is_unit (U $ i $ i))", "have \"prod (\\<lambda>i. U $ i $ i) (insert a S) = U $ a $ a * prod (\\<lambda>i. U $ i $ i) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>insert a S. U $ i $ i) =\n    U $ a $ a * (\\<Prod>i\\<in>S. U $ i $ i)", "by (simp add: insert.hyps(2))"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>insert a S. U $ i $ i) =\n  U $ a $ a * (\\<Prod>i\\<in>S. U $ i $ i)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_unit (\\<Prod>i\\<in>F. U $ i $ i) =\n        (\\<forall>i\\<in>F. is_unit (U $ i $ i))\\<rbrakk>\n       \\<Longrightarrow> is_unit (\\<Prod>i\\<in>insert x F. U $ i $ i) =\n                         (\\<forall>i\\<in>insert x F. is_unit (U $ i $ i))", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<Prod>i\\<in>insert a S. U $ i $ i) =\n  U $ a $ a * (\\<Prod>i\\<in>S. U $ i $ i)\n\ngoal (1 subgoal):\n 1. is_unit (\\<Prod>i\\<in>insert a S. U $ i $ i) =\n    (\\<forall>i\\<in>insert a S. is_unit (U $ i $ i))", "using is_unit_mult_iff insert.hyps"], ["proof (prove)\nusing this:\n  (\\<Prod>i\\<in>insert a S. U $ i $ i) =\n  U $ a $ a * (\\<Prod>i\\<in>S. U $ i $ i)\n  is_unit (?a * ?b) = (is_unit ?a \\<and> is_unit ?b)\n  finite S\n  a \\<notin> S\n  is_unit (\\<Prod>i\\<in>S. U $ i $ i) =\n  (\\<forall>i\\<in>S. is_unit (U $ i $ i))\n\ngoal (1 subgoal):\n 1. is_unit (\\<Prod>i\\<in>insert a S. U $ i $ i) =\n    (\\<forall>i\\<in>insert a S. is_unit (U $ i $ i))", "by auto"], ["proof (state)\nthis:\n  is_unit (\\<Prod>i\\<in>insert a S. U $ i $ i) =\n  (\\<forall>i\\<in>insert a S. is_unit (U $ i $ i))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Upper triangular matrices\\<close>"], ["", "lemma is_unit_diagonal: \n  fixes U::\"'a::{comm_ring_1, algebraic_semidom}^'n::{finite, wellorder}^'n::{finite, wellorder}\"\n  assumes U: \"upper_triangular U\"\n  and det_U: \"is_unit (det U)\"\n  shows \"\\<forall>i. is_unit (U $ i $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. is_unit (U $ i $ i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i. is_unit (U $ i $ i)", "have \"is_unit (prod (\\<lambda>i. U $ i $ i) UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (\\<Prod>i\\<in>UNIV. U $ i $ i)", "using det_U  det_upperdiagonal[of U] U"], ["proof (prove)\nusing this:\n  is_unit (det U)\n  (\\<And>i j. j < i \\<Longrightarrow> U $ i $ j = (0::'a)) \\<Longrightarrow>\n  det U = (\\<Prod>i\\<in>UNIV. U $ i $ i)\n  upper_triangular U\n\ngoal (1 subgoal):\n 1. is_unit (\\<Prod>i\\<in>UNIV. U $ i $ i)", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  is_unit (det U)\n  (\\<And>i j. j < i \\<Longrightarrow> U $ i $ j = (0::'a)) \\<Longrightarrow>\n  det U = (\\<Prod>i\\<in>UNIV. U $ i $ i)\n  \\<forall>i j. j < i \\<longrightarrow> U $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. is_unit (\\<Prod>i\\<in>UNIV. U $ i $ i)", "by auto"], ["proof (state)\nthis:\n  is_unit (\\<Prod>i\\<in>UNIV. U $ i $ i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. is_unit (U $ i $ i)", "hence \"\\<forall>i\\<in>UNIV. is_unit (U $ i $ i)\""], ["proof (prove)\nusing this:\n  is_unit (\\<Prod>i\\<in>UNIV. U $ i $ i)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>UNIV. is_unit (U $ i $ i)", "using unit_prod[of UNIV U]"], ["proof (prove)\nusing this:\n  is_unit (\\<Prod>i\\<in>UNIV. U $ i $ i)\n  finite UNIV \\<Longrightarrow>\n  is_unit (\\<Prod>i\\<in>UNIV. U $ i $ i) =\n  (\\<forall>i\\<in>UNIV. is_unit (U $ i $ i))\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>UNIV. is_unit (U $ i $ i)", "by simp"], ["proof (state)\nthis:\n  \\<forall>i\\<in>UNIV. is_unit (U $ i $ i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. is_unit (U $ i $ i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>UNIV. is_unit (U $ i $ i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. is_unit (U $ i $ i)", "by simp"], ["proof (state)\nthis:\n  \\<forall>i. is_unit (U $ i $ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upper_triangular_mult:\n  fixes A::\"'a::{semiring_1}^'n::{mod_type}^'n::{mod_type}\"\n  assumes A: \"upper_triangular A\"\n  and B: \"upper_triangular B\"\n  shows \"upper_triangular (A**B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular (A ** B)", "proof (unfold upper_triangular_def matrix_matrix_mult_def, vector, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       j < i \\<Longrightarrow>\n       (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) = (0::'a)", "fix i j::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       j < i \\<Longrightarrow>\n       (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) = (0::'a)", "assume ji: \"j<i\""], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       j < i \\<Longrightarrow>\n       (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) = (0::'a)", "show \"(\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) = (0::'a)", "proof (rule sum.neutral, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> A $ i $ x * B $ x $ j = (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> A $ i $ x * B $ x $ j = (0::'a)", "show \"A $ i $ x * B $ x $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ j = (0::'a)", "proof (cases \"x<i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < i \\<Longrightarrow> A $ i $ x * B $ x $ j = (0::'a)\n 2. \\<not> x < i \\<Longrightarrow> A $ i $ x * B $ x $ j = (0::'a)", "case True"], ["proof (state)\nthis:\n  x < i\n\ngoal (2 subgoals):\n 1. x < i \\<Longrightarrow> A $ i $ x * B $ x $ j = (0::'a)\n 2. \\<not> x < i \\<Longrightarrow> A $ i $ x * B $ x $ j = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x < i\n\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ j = (0::'a)", "using A"], ["proof (prove)\nusing this:\n  x < i\n  upper_triangular A\n\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ j = (0::'a)", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  x < i\n  \\<forall>i j. j < i \\<longrightarrow> A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ j = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ i $ x * B $ x $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> A $ i $ x * B $ x $ j = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> A $ i $ x * B $ x $ j = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> x < i\n\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> A $ i $ x * B $ x $ j = (0::'a)", "hence \"x>j\""], ["proof (prove)\nusing this:\n  \\<not> x < i\n\ngoal (1 subgoal):\n 1. j < x", "using ji"], ["proof (prove)\nusing this:\n  \\<not> x < i\n  j < i\n\ngoal (1 subgoal):\n 1. j < x", "by auto"], ["proof (state)\nthis:\n  j < x\n\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> A $ i $ x * B $ x $ j = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < x\n\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ j = (0::'a)", "using A B ji"], ["proof (prove)\nusing this:\n  j < x\n  upper_triangular A\n  upper_triangular B\n  j < i\n\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ j = (0::'a)", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  j < x\n  \\<forall>i j. j < i \\<longrightarrow> A $ i $ j = (0::'a)\n  \\<forall>i j. j < i \\<longrightarrow> B $ i $ j = (0::'a)\n  j < i\n\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ j = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ i $ x * B $ x $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ i $ x * B $ x $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upper_triangular_adjugate:\n  fixes A::\"(('a::comm_ring_1,'n::{wellorder, finite}) vec, 'n) vec\"\n  assumes A: \"upper_triangular A\"\n  shows \"upper_triangular (adjugate A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular (adjugate A)", "proof (auto simp add: cofactor_def upper_triangular_def adjugate_def transpose_def cofactorM_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j. j < i \\<Longrightarrow> det (minorM A j i) = (0::'a)", "fix i j::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j. j < i \\<Longrightarrow> det (minorM A j i) = (0::'a)", "assume ji: \"j < i\""], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>i j. j < i \\<Longrightarrow> det (minorM A j i) = (0::'a)", "with A"], ["proof (chain)\npicking this:\n  upper_triangular A\n  j < i", "show \"det (minorM A j i) = 0\""], ["proof (prove)\nusing this:\n  upper_triangular A\n  j < i\n\ngoal (1 subgoal):\n 1. det (minorM A j i) = (0::'a)", "unfolding minorM_eq det_sq_matrix_eq[symmetric] from_vec_to_vec det_minor_row"], ["proof (prove)\nusing this:\n  upper_triangular A\n  j < i\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_row (from_vec A) j (axis i (1::'a))) = (0::'a)", "by (subst Square_Matrix.det_upperdiagonal)\n       (auto simp: upd_row.rep_eq from_vec.rep_eq row_def axis_def upper_triangular_def intro!: prod_zero)"], ["proof (state)\nthis:\n  det (minorM A j i) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upper_triangular_inverse:\n  fixes A::\"(('a::{euclidean_semiring,comm_ring_1},'n::{wellorder, finite}) vec, 'n) vec\"\n  assumes A: \"upper_triangular A\"\n  and inv_A: \"invertible A\"\n  shows \"upper_triangular (matrix_inv A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular (matrix_inv A)", "using upper_triangular_adjugate[OF A]"], ["proof (prove)\nusing this:\n  upper_triangular (adjugate A)\n\ngoal (1 subgoal):\n 1. upper_triangular (matrix_inv A)", "unfolding invertible_imp_matrix_inv[OF inv_A]"], ["proof (prove)\nusing this:\n  upper_triangular (adjugate A)\n\ngoal (1 subgoal):\n 1. upper_triangular ((1::'a) div det A *k adjugate A)", "unfolding matrix_scalar_mult_def upper_triangular_def"], ["proof (prove)\nusing this:\n  \\<forall>i j. j < i \\<longrightarrow> adjugate A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       j < i \\<longrightarrow>\n       (\\<chi>i j. (1::'a) div det A * adjugate A $ i $ j) $ i $ j = (0::'a)", "by auto"], ["", "lemma upper_triangular_mult_diagonal:\n  fixes A::\"(('a::{semiring_1},'n::{wellorder, finite}) vec, 'n) vec\"\n  assumes A: \"upper_triangular A\"\n  and B: \"upper_triangular B\"\n  shows \"(A**B) $ i $ i = A $ i $ i * B $ i $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ** B) $ i $ i = A $ i $ i * B $ i $ i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A ** B) $ i $ i = A $ i $ i * B $ i $ i", "have UNIV_rw: \"UNIV = (insert i (UNIV-{i}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = insert i (UNIV - {i})", "by auto"], ["proof (state)\nthis:\n  UNIV = insert i (UNIV - {i})\n\ngoal (1 subgoal):\n 1. (A ** B) $ i $ i = A $ i $ i * B $ i $ i", "have sum_0: \"(\\<Sum>k\\<in>UNIV-{i}. A $ i $ k * B $ k $ i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV - {i}. A $ i $ k * B $ k $ i) = (0::'a)", "proof (rule sum.neutral, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV - {i} \\<Longrightarrow> A $ i $ x * B $ x $ i = (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV - {i} \\<Longrightarrow> A $ i $ x * B $ x $ i = (0::'a)", "assume x: \"x \\<in> UNIV - {i}\""], ["proof (state)\nthis:\n  x \\<in> UNIV - {i}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV - {i} \\<Longrightarrow> A $ i $ x * B $ x $ i = (0::'a)", "show \"A $ i $ x * B $ x $ i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ i = (0::'a)", "proof (cases \"x<i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < i \\<Longrightarrow> A $ i $ x * B $ x $ i = (0::'a)\n 2. \\<not> x < i \\<Longrightarrow> A $ i $ x * B $ x $ i = (0::'a)", "case True"], ["proof (state)\nthis:\n  x < i\n\ngoal (2 subgoals):\n 1. x < i \\<Longrightarrow> A $ i $ x * B $ x $ i = (0::'a)\n 2. \\<not> x < i \\<Longrightarrow> A $ i $ x * B $ x $ i = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x < i\n\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ i = (0::'a)", "using A"], ["proof (prove)\nusing this:\n  x < i\n  upper_triangular A\n\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ i = (0::'a)", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  x < i\n  \\<forall>i j. j < i \\<longrightarrow> A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ i = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ i $ x * B $ x $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> A $ i $ x * B $ x $ i = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> A $ i $ x * B $ x $ i = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> x < i\n\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> A $ i $ x * B $ x $ i = (0::'a)", "hence \"x>i\""], ["proof (prove)\nusing this:\n  \\<not> x < i\n\ngoal (1 subgoal):\n 1. i < x", "using x"], ["proof (prove)\nusing this:\n  \\<not> x < i\n  x \\<in> UNIV - {i}\n\ngoal (1 subgoal):\n 1. i < x", "by auto"], ["proof (state)\nthis:\n  i < x\n\ngoal (1 subgoal):\n 1. \\<not> x < i \\<Longrightarrow> A $ i $ x * B $ x $ i = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < x\n\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ i = (0::'a)", "using B"], ["proof (prove)\nusing this:\n  i < x\n  upper_triangular B\n\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ i = (0::'a)", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  i < x\n  \\<forall>i j. j < i \\<longrightarrow> B $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ x * B $ x $ i = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ i $ x * B $ x $ i = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ i $ x * B $ x $ i = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV - {i}. A $ i $ k * B $ k $ i) = (0::'a)\n\ngoal (1 subgoal):\n 1. (A ** B) $ i $ i = A $ i $ i * B $ i $ i", "have \"(A**B) $ i $ i = (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ** B) $ i $ i = (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ i)", "unfolding matrix_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j. \\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) $ i $ i =\n    (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ i)", "by simp"], ["proof (state)\nthis:\n  (A ** B) $ i $ i = (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ i)\n\ngoal (1 subgoal):\n 1. (A ** B) $ i $ i = A $ i $ i * B $ i $ i", "also"], ["proof (state)\nthis:\n  (A ** B) $ i $ i = (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ i)\n\ngoal (1 subgoal):\n 1. (A ** B) $ i $ i = A $ i $ i * B $ i $ i", "have \"... = (\\<Sum>k\\<in>(insert i (UNIV-{i})). A $ i $ k * B $ k $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ i) =\n    (\\<Sum>k\\<in>insert i (UNIV - {i}). A $ i $ k * B $ k $ i)", "using UNIV_rw"], ["proof (prove)\nusing this:\n  UNIV = insert i (UNIV - {i})\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ i) =\n    (\\<Sum>k\\<in>insert i (UNIV - {i}). A $ i $ k * B $ k $ i)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ i) =\n  (\\<Sum>k\\<in>insert i (UNIV - {i}). A $ i $ k * B $ k $ i)\n\ngoal (1 subgoal):\n 1. (A ** B) $ i $ i = A $ i $ i * B $ i $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ i) =\n  (\\<Sum>k\\<in>insert i (UNIV - {i}). A $ i $ k * B $ k $ i)\n\ngoal (1 subgoal):\n 1. (A ** B) $ i $ i = A $ i $ i * B $ i $ i", "have \"... = (A $ i $ i * B $ i $ i) + (\\<Sum>k\\<in>UNIV-{i}. A $ i $ k * B $ k $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>insert i (UNIV - {i}). A $ i $ k * B $ k $ i) =\n    A $ i $ i * B $ i $ i + (\\<Sum>k\\<in>UNIV - {i}. A $ i $ k * B $ k $ i)", "by (rule sum.insert, simp_all)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert i (UNIV - {i}). A $ i $ k * B $ k $ i) =\n  A $ i $ i * B $ i $ i + (\\<Sum>k\\<in>UNIV - {i}. A $ i $ k * B $ k $ i)\n\ngoal (1 subgoal):\n 1. (A ** B) $ i $ i = A $ i $ i * B $ i $ i", "finally"], ["proof (chain)\npicking this:\n  (A ** B) $ i $ i =\n  A $ i $ i * B $ i $ i + (\\<Sum>k\\<in>UNIV - {i}. A $ i $ k * B $ k $ i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (A ** B) $ i $ i =\n  A $ i $ i * B $ i $ i + (\\<Sum>k\\<in>UNIV - {i}. A $ i $ k * B $ k $ i)\n\ngoal (1 subgoal):\n 1. (A ** B) $ i $ i = A $ i $ i * B $ i $ i", "unfolding sum_0"], ["proof (prove)\nusing this:\n  (A ** B) $ i $ i = A $ i $ i * B $ i $ i + (0::'a)\n\ngoal (1 subgoal):\n 1. (A ** B) $ i $ i = A $ i $ i * B $ i $ i", "by simp"], ["proof (state)\nthis:\n  (A ** B) $ i $ i = A $ i $ i * B $ i $ i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>More properties of mod type\\<close>"], ["", "lemma add_left_neutral:\n  fixes a::\"'n::mod_type\"\n  shows \"(a + b = a) = (b = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b = a) = (b = (0::'n))", "by (auto, metis add_left_cancel monoid_add_class.add.right_neutral)"], ["", "lemma from_nat_1: \"from_nat 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat 1 = (1::'a)", "unfolding from_nat_def o_def Abs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs (int 1 mod int CARD('a)) = (1::'a)", "by (metis Rep_1 Rep_mod of_nat_1 one_def)"], ["", "subsubsection\\<open>Div and Mod\\<close>"], ["", "lemma dvd_minus_eq_mod:\n  fixes c::\"'a::unique_euclidean_ring\"\n  assumes \"c \\<noteq> 0\" and \"c dvd a - b\" shows \"a mod c = b mod c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod c = b mod c", "using assms dvd_div_mult_self[of c]"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  c dvd a - b\n  c dvd ?b \\<Longrightarrow> ?b div c * c = ?b\n\ngoal (1 subgoal):\n 1. a mod c = b mod c", "by (metis add.commute diff_add_cancel mod_mult_self1)"], ["", "lemma eq_mod_dvd_minus:\n  fixes c::\"'a::unique_euclidean_ring\"\n  assumes \"c \\<noteq> 0\" and \"a mod c = b mod c\" \n  shows \"c dvd a - b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c dvd a - b", "using assms"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  a mod c = b mod c\n\ngoal (1 subgoal):\n 1. c dvd a - b", "by (simp add: mod_eq_dvd_iff)"], ["", "lemma dvd_cong_not_eq_mod:\n  fixes c::\"'a::unique_euclidean_ring\"\n  assumes \"xa mod c \\<noteq> xb\" and \"c dvd xa mod c - xb\" and \"c \\<noteq> 0\"\n  shows \"xb mod c \\<noteq> xb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xb mod c \\<noteq> xb", "using assms"], ["proof (prove)\nusing this:\n  xa mod c \\<noteq> xb\n  c dvd xa mod c - xb\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. xb mod c \\<noteq> xb", "by (metis (no_types, lifting) diff_add_cancel dvdE mod_mod_trivial  mod_mult_self4)"], ["", "lemma diff_mod_cong_0:\n  fixes c::\"'a::unique_euclidean_ring\"\n  assumes \"xa mod c \\<noteq> xb mod c\" and\" c dvd xa mod c - xb mod c\" shows \"c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = (0::'a)", "using assms dvd_cong_not_eq_mod mod_mod_trivial"], ["proof (prove)\nusing this:\n  xa mod c \\<noteq> xb mod c\n  c dvd xa mod c - xb mod c\n  \\<lbrakk>?xa mod ?c \\<noteq> ?xb; ?c dvd ?xa mod ?c - ?xb;\n   ?c \\<noteq> (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?xb mod ?c \\<noteq> ?xb\n  ?a mod ?b mod ?b = ?a mod ?b\n\ngoal (1 subgoal):\n 1. c = (0::'a)", "by blast"], ["", "lemma cong_diff_mod:\n  fixes c::\"'a::unique_euclidean_ring\"\n  assumes \"xa \\<noteq> xb\" and \"c dvd xa - xb\" and \"xa = xa mod c\" shows \"xb \\<noteq> xb mod c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xb \\<noteq> xb mod c", "by (metis assms diff_eq_diff_eq diff_numeral_special(12) dvd_0_left dvd_minus_eq_mod)"], ["", "lemma exists_k_mod:\n  fixes c::\"'a::unique_euclidean_ring\"\n  shows \"\\<exists>k. a mod c = a + k * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. a mod c = a + k * c", "by (metis add.commute diff_add_cancel diff_minus_eq_add\n      mult_div_mod_eq mult.commute mult_minus_left)"], ["", "subsection\\<open>Units, associated and congruent relations\\<close>"], ["", "context semiring_1\nbegin"], ["", "definition \"Units = {x::'a. (\\<exists>k. 1 = x * k)}\""], ["", "end"], ["", "context ring_1\nbegin"], ["", "definition cong::\"'a\\<Rightarrow>'a\\<Rightarrow>'a\\<Rightarrow>bool\"\n  where \"cong a c b = (\\<exists>k. (a - c) = b * k)\""], ["", "lemma cong_eq: \"cong a c b = (b dvd (a - c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cong a c b = (b dvd a - c)", "unfolding ring_1_class.cong_def dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>k. a - c = b * k) = (\\<exists>k. a - c = b * k)", "by simp"], ["", "end"], ["", "context normalization_semidom\nbegin"], ["", "lemma Units_eq: \"Units = {x. x dvd 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Units = {x. is_unit x}", "unfolding Units_def dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>k. (1::'a) = x * k} = {x. \\<exists>k. (1::'a) = x * k}", ".."], ["", "lemma normalize_Units: \"x \\<in> Units \\<Longrightarrow> normalize x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Units \\<Longrightarrow> normalize x = (1::'a)", "by (intro is_unit_normalize) (simp_all add: Units_eq)"], ["", "lemma associated_eq: \"(normalize a = normalize b) \\<longleftrightarrow> (\\<exists>u\\<in>Units. a = u*b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (normalize a = normalize b) = (\\<exists>u\\<in>Units. a = u * b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. normalize a = normalize b \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b\n 2. \\<exists>u\\<in>Units. a = u * b \\<Longrightarrow>\n    normalize a = normalize b", "assume A: \"normalize a = normalize b\""], ["proof (state)\nthis:\n  normalize a = normalize b\n\ngoal (2 subgoals):\n 1. normalize a = normalize b \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b\n 2. \\<exists>u\\<in>Units. a = u * b \\<Longrightarrow>\n    normalize a = normalize b", "show \"\\<exists>u\\<in>Units. a = u*b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>Units. a = u * b", "proof (cases \"a = 0 \\<or> b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b\n 2. \\<not> (a = (0::'a) \\<or> b = (0::'a)) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b", "case False"], ["proof (state)\nthis:\n  \\<not> (a = (0::'a) \\<or> b = (0::'a))\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b\n 2. \\<not> (a = (0::'a) \\<or> b = (0::'a)) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b", "from A"], ["proof (chain)\npicking this:\n  normalize a = normalize b", "have \"a = (unit_factor a div unit_factor b) * b\""], ["proof (prove)\nusing this:\n  normalize a = normalize b\n\ngoal (1 subgoal):\n 1. a = unit_factor a div unit_factor b * b", "by (metis mult_not_zero normalize_0 normalize_mult_unit_factor mult.left_commute \n           unit_div_mult_self unit_factor_is_unit)"], ["proof (state)\nthis:\n  a = unit_factor a div unit_factor b * b\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b\n 2. \\<not> (a = (0::'a) \\<or> b = (0::'a)) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b", "moreover"], ["proof (state)\nthis:\n  a = unit_factor a div unit_factor b * b\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b\n 2. \\<not> (a = (0::'a) \\<or> b = (0::'a)) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b", "from False"], ["proof (chain)\npicking this:\n  \\<not> (a = (0::'a) \\<or> b = (0::'a))", "have \"unit_factor a div unit_factor b \\<in> Units\""], ["proof (prove)\nusing this:\n  \\<not> (a = (0::'a) \\<or> b = (0::'a))\n\ngoal (1 subgoal):\n 1. unit_factor a div unit_factor b \\<in> Units", "by (simp add: Units_eq unit_div)"], ["proof (state)\nthis:\n  unit_factor a div unit_factor b \\<in> Units\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b\n 2. \\<not> (a = (0::'a) \\<or> b = (0::'a)) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b", "ultimately"], ["proof (chain)\npicking this:\n  a = unit_factor a div unit_factor b * b\n  unit_factor a div unit_factor b \\<in> Units", "show ?thesis"], ["proof (prove)\nusing this:\n  a = unit_factor a div unit_factor b * b\n  unit_factor a div unit_factor b \\<in> Units\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>Units. a = u * b", "by blast"], ["proof (state)\nthis:\n  \\<exists>u\\<in>Units. a = u * b\n\ngoal (1 subgoal):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b", "case True"], ["proof (state)\nthis:\n  a = (0::'a) \\<or> b = (0::'a)\n\ngoal (1 subgoal):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b", "with A normalize_eq_0_iff[of a] normalize_eq_0_iff[of b]"], ["proof (chain)\npicking this:\n  normalize a = normalize b\n  (normalize a = (0::'a)) = (a = (0::'a))\n  (normalize b = (0::'a)) = (b = (0::'a))\n  a = (0::'a) \\<or> b = (0::'a)", "have \"a = 0\" \"b = 0\""], ["proof (prove)\nusing this:\n  normalize a = normalize b\n  (normalize a = (0::'a)) = (a = (0::'a))\n  (normalize b = (0::'a)) = (b = (0::'a))\n  a = (0::'a) \\<or> b = (0::'a)\n\ngoal (1 subgoal):\n 1. a = (0::'a) &&& b = (0::'a)", "by auto"], ["proof (state)\nthis:\n  a = (0::'a)\n  b = (0::'a)\n\ngoal (1 subgoal):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    \\<exists>u\\<in>Units. a = u * b", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = (0::'a)\n  b = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>Units. a = u * b", "by (auto intro!: exI[of _ 1] simp: Units_def)"], ["proof (state)\nthis:\n  \\<exists>u\\<in>Units. a = u * b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u\\<in>Units. a = u * b\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>Units. a = u * b \\<Longrightarrow>\n    normalize a = normalize b", "qed (auto simp: normalize_Units Units_def)"], ["", "end"], ["", "context unique_euclidean_ring\nbegin"], ["", "definition \"associated_rel = {(a,b). normalize a = normalize b}\""], ["", "lemma equiv_associated: \n  shows \"equiv UNIV associated_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv UNIV associated_rel", "unfolding associated_rel_def equiv_def refl_on_def sym_def trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({(a, b). normalize a = normalize b}\n     \\<subseteq> UNIV \\<times> UNIV \\<and>\n     (\\<forall>x\\<in>UNIV.\n         (x, x) \\<in> {(a, b). normalize a = normalize b})) \\<and>\n    (\\<forall>x y.\n        (x, y) \\<in> {(a, b). normalize a = normalize b} \\<longrightarrow>\n        (y, x) \\<in> {(a, b). normalize a = normalize b}) \\<and>\n    (\\<forall>x y z.\n        (x, y) \\<in> {(a, b). normalize a = normalize b} \\<longrightarrow>\n        (y, z) \\<in> {(a, b). normalize a = normalize b} \\<longrightarrow>\n        (x, z) \\<in> {(a, b). normalize a = normalize b})", "by simp"], ["", "definition \"congruent_rel b = {(a,c). cong a c b}\""], ["", "lemma relf_congruent_rel: \"refl (congruent_rel b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl (congruent_rel b)", "unfolding refl_on_def congruent_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, c). cong a c b} \\<subseteq> UNIV \\<times> UNIV \\<and>\n    (\\<forall>x\\<in>UNIV. (x, x) \\<in> {(a, c). cong a c b})", "unfolding cong_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, c). \\<exists>k. a - c = b * k}\n    \\<subseteq> UNIV \\<times> UNIV \\<and>\n    (\\<forall>x\\<in>UNIV. (x, x) \\<in> {(a, c). \\<exists>k. a - c = b * k})", "by (auto, metis mult_zero_right)"], ["", "lemma sym_congruent_rel: \"sym (congruent_rel b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (congruent_rel b)", "unfolding sym_def congruent_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y) \\<in> {(a, c). cong a c b} \\<longrightarrow>\n       (y, x) \\<in> {(a, c). cong a c b}", "unfolding cong_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y) \\<in> {(a, c). \\<exists>k. a - c = b * k} \\<longrightarrow>\n       (y, x) \\<in> {(a, c). \\<exists>k. a - c = b * k}", "by (auto, metis add_commute add_minus_cancel diff_conv_add_uminus \n    minus_mult_commute mult.left_commute mult_1_left)"], ["", "lemma trans_congruent_rel: \"trans (congruent_rel b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (congruent_rel b)", "unfolding trans_def congruent_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> {(a, c). cong a c b} \\<longrightarrow>\n       (y, z) \\<in> {(a, c). cong a c b} \\<longrightarrow>\n       (x, z) \\<in> {(a, c). cong a c b}", "unfolding cong_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> {(a, c). \\<exists>k. a - c = b * k} \\<longrightarrow>\n       (y, z) \\<in> {(a, c). \\<exists>k. a - c = b * k} \\<longrightarrow>\n       (x, z) \\<in> {(a, c). \\<exists>k. a - c = b * k}", "by (auto, metis add_assoc diff_add_cancel \n    diff_conv_add_uminus distrib_left)"], ["", "lemma equiv_congruent: \"equiv UNIV (congruent_rel b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv UNIV (congruent_rel b)", "unfolding equiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. refl (congruent_rel b) \\<and>\n    sym (congruent_rel b) \\<and> trans (congruent_rel b)", "using relf_congruent_rel sym_congruent_rel trans_congruent_rel"], ["proof (prove)\nusing this:\n  refl (congruent_rel ?b)\n  sym (congruent_rel ?b)\n  trans (congruent_rel ?b)\n\ngoal (1 subgoal):\n 1. refl (congruent_rel b) \\<and>\n    sym (congruent_rel b) \\<and> trans (congruent_rel b)", "by auto"], ["", "end"], ["", "subsection\\<open>Associates and residues functions\\<close>"], ["", "context normalization_semidom\nbegin"], ["", "definition ass_function :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"ass_function f \n  = ((\\<forall>a. normalize a = normalize (f a)) \\<and> pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b) (range f))\""], ["", "definition \"Complete_set_non_associates S \n  = (\\<exists>f. ass_function f \\<and> f`UNIV = S \\<and> (pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b) S))\""], ["", "end"], ["", "context ring_1\nbegin"], ["", "definition res_function :: \"('a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"res_function f = (\\<forall>c. (\\<forall>a b. cong a b c \\<longleftrightarrow> f c a = f c b) \n  \\<and> pairwise (\\<lambda>a b. \\<not> cong a b c) (range (f c))\n  \\<and> (\\<forall>a. \\<exists>k. f c a = a + k*c))\""], ["", "definition \"Complete_set_residues g \n  = (\\<exists>f. res_function f \\<and> (\\<forall>c. (pairwise (\\<lambda>a b. \\<not> cong a b c) (f c`UNIV)) \\<and> g c = f c`UNIV))\""], ["", "end"], ["", "lemma ass_function_Complete_set_non_associates:\n  assumes f: \"ass_function f\"\n  shows \"Complete_set_non_associates (f`UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_set_non_associates (range f)", "unfolding Complete_set_non_associates_def ass_function_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fa.\n       ((\\<forall>a. normalize a = normalize (fa a)) \\<and>\n        pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b)\n         (range fa)) \\<and>\n       range fa = range f \\<and>\n       pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b) (range f)", "apply (rule exI[of _ f])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>a. normalize a = normalize (f a)) \\<and>\n     pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b)\n      (range f)) \\<and>\n    range f = range f \\<and>\n    pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b) (range f)", "using f"], ["proof (prove)\nusing this:\n  ass_function f\n\ngoal (1 subgoal):\n 1. ((\\<forall>a. normalize a = normalize (f a)) \\<and>\n     pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b)\n      (range f)) \\<and>\n    range f = range f \\<and>\n    pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b) (range f)", "unfolding ass_function_def"], ["proof (prove)\nusing this:\n  (\\<forall>a. normalize a = normalize (f a)) \\<and>\n  pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b) (range f)\n\ngoal (1 subgoal):\n 1. ((\\<forall>a. normalize a = normalize (f a)) \\<and>\n     pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b)\n      (range f)) \\<and>\n    range f = range f \\<and>\n    pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b) (range f)", "unfolding pairwise_def"], ["proof (prove)\nusing this:\n  (\\<forall>a. normalize a = normalize (f a)) \\<and>\n  (\\<forall>x\\<in>range f.\n      \\<forall>y\\<in>range f.\n         x \\<noteq> y \\<longrightarrow> normalize x \\<noteq> normalize y)\n\ngoal (1 subgoal):\n 1. ((\\<forall>a. normalize a = normalize (f a)) \\<and>\n     (\\<forall>x\\<in>range f.\n         \\<forall>y\\<in>range f.\n            x \\<noteq> y \\<longrightarrow>\n            normalize x \\<noteq> normalize y)) \\<and>\n    range f = range f \\<and>\n    (\\<forall>x\\<in>range f.\n        \\<forall>y\\<in>range f.\n           x \\<noteq> y \\<longrightarrow> normalize x \\<noteq> normalize y)", "by fast"], ["", "lemma in_Ass_not_associated:\n  assumes Ass_S: \"Complete_set_non_associates S\" \n  and x: \"x\\<in>S\" and y: \"y\\<in>S\" and x_not_y: \"x\\<noteq>y\" \n  shows \"normalize x \\<noteq> normalize y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize x \\<noteq> normalize y", "using assms"], ["proof (prove)\nusing this:\n  Complete_set_non_associates S\n  x \\<in> S\n  y \\<in> S\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. normalize x \\<noteq> normalize y", "unfolding Complete_set_non_associates_def pairwise_def"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     ass_function f \\<and>\n     range f = S \\<and>\n     (\\<forall>x\\<in>S.\n         \\<forall>y\\<in>S.\n            x \\<noteq> y \\<longrightarrow> normalize x \\<noteq> normalize y)\n  x \\<in> S\n  y \\<in> S\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. normalize x \\<noteq> normalize y", "by auto"], ["", "lemma ass_function_0:\n  assumes r: \"ass_function ass\"\n  shows \"(ass x = 0) = (x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ass x = (0::'a)) = (x = (0::'a))", "using assms"], ["proof (prove)\nusing this:\n  ass_function ass\n\ngoal (1 subgoal):\n 1. (ass x = (0::'a)) = (x = (0::'a))", "unfolding ass_function_def pairwise_def"], ["proof (prove)\nusing this:\n  (\\<forall>a. normalize a = normalize (ass a)) \\<and>\n  (\\<forall>x\\<in>range ass.\n      \\<forall>y\\<in>range ass.\n         x \\<noteq> y \\<longrightarrow> normalize x \\<noteq> normalize y)\n\ngoal (1 subgoal):\n 1. (ass x = (0::'a)) = (x = (0::'a))", "by (metis normalize_eq_0_iff)"], ["", "lemma ass_function_0':\n  assumes r: \"ass_function ass\"\n  shows \"(ass x div x = 0) = (x=0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ass x div x = (0::'a)) = (x = (0::'a))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. ass x div x = (0::'a) \\<Longrightarrow> x = (0::'a)\n 2. x = (0::'a) \\<Longrightarrow> ass (0::'a) div (0::'a) = (0::'a)", "assume *: \"ass x div x = 0\""], ["proof (state)\nthis:\n  ass x div x = (0::'a)\n\ngoal (2 subgoals):\n 1. ass x div x = (0::'a) \\<Longrightarrow> x = (0::'a)\n 2. x = (0::'a) \\<Longrightarrow> ass (0::'a) div (0::'a) = (0::'a)", "from r"], ["proof (chain)\npicking this:\n  ass_function ass", "have **: \"normalize (ass x) = normalize x\""], ["proof (prove)\nusing this:\n  ass_function ass\n\ngoal (1 subgoal):\n 1. normalize (ass x) = normalize x", "by (simp add: ass_function_def)"], ["proof (state)\nthis:\n  normalize (ass x) = normalize x\n\ngoal (2 subgoals):\n 1. ass x div x = (0::'a) \\<Longrightarrow> x = (0::'a)\n 2. x = (0::'a) \\<Longrightarrow> ass (0::'a) div (0::'a) = (0::'a)", "from associatedD2[OF this]"], ["proof (chain)\npicking this:\n  x dvd ass x", "have \"x dvd ass x\""], ["proof (prove)\nusing this:\n  x dvd ass x\n\ngoal (1 subgoal):\n 1. x dvd ass x", "by simp"], ["proof (state)\nthis:\n  x dvd ass x\n\ngoal (2 subgoals):\n 1. ass x div x = (0::'a) \\<Longrightarrow> x = (0::'a)\n 2. x = (0::'a) \\<Longrightarrow> ass (0::'a) div (0::'a) = (0::'a)", "with * **"], ["proof (chain)\npicking this:\n  ass x div x = (0::'a)\n  normalize (ass x) = normalize x\n  x dvd ass x", "show \"x = 0\""], ["proof (prove)\nusing this:\n  ass x div x = (0::'a)\n  normalize (ass x) = normalize x\n  x dvd ass x\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "by (auto simp: dvd_div_eq_0_iff)"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. x = (0::'a) \\<Longrightarrow> ass (0::'a) div (0::'a) = (0::'a)", "qed auto"], ["", "lemma res_function_Complete_set_residues:\n  assumes f: \"res_function f\"\n  shows \"Complete_set_residues (\\<lambda>c. (f c)`UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_set_residues (\\<lambda>c. range (f c))", "unfolding Complete_set_residues_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fa.\n       res_function fa \\<and>\n       (\\<forall>c.\n           pairwise (\\<lambda>a b. \\<not> cong a b c) (range (fa c)) \\<and>\n           range (f c) = range (fa c))", "apply (rule exI[of _ f])"], ["proof (prove)\ngoal (1 subgoal):\n 1. res_function f \\<and>\n    (\\<forall>c.\n        pairwise (\\<lambda>a b. \\<not> cong a b c) (range (f c)) \\<and>\n        range (f c) = range (f c))", "using f"], ["proof (prove)\nusing this:\n  res_function f\n\ngoal (1 subgoal):\n 1. res_function f \\<and>\n    (\\<forall>c.\n        pairwise (\\<lambda>a b. \\<not> cong a b c) (range (f c)) \\<and>\n        range (f c) = range (f c))", "unfolding res_function_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     (\\<forall>a b. cong a b c = (f c a = f c b)) \\<and>\n     pairwise (\\<lambda>a b. \\<not> cong a b c) (range (f c)) \\<and>\n     (\\<forall>a. \\<exists>k. f c a = a + k * c)\n\ngoal (1 subgoal):\n 1. (\\<forall>c.\n        (\\<forall>a b. cong a b c = (f c a = f c b)) \\<and>\n        pairwise (\\<lambda>a b. \\<not> cong a b c) (range (f c)) \\<and>\n        (\\<forall>a. \\<exists>k. f c a = a + k * c)) \\<and>\n    (\\<forall>c.\n        pairwise (\\<lambda>a b. \\<not> cong a b c) (range (f c)) \\<and>\n        range (f c) = range (f c))", "by blast"], ["", "lemma in_Res_not_congruent:\n  assumes res_g: \"Complete_set_residues g\" \n  and x: \"x \\<in> g b\" and y: \"y \\<in> g b\" and x_not_y: \"x\\<noteq>y\" \n  shows \"\\<not> cong x y b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> cong x y b", "using assms"], ["proof (prove)\nusing this:\n  Complete_set_residues g\n  x \\<in> g b\n  y \\<in> g b\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<not> cong x y b", "unfolding Complete_set_residues_def"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     res_function f \\<and>\n     (\\<forall>c.\n         pairwise (\\<lambda>a b. \\<not> cong a b c) (range (f c)) \\<and>\n         g c = range (f c))\n  x \\<in> g b\n  y \\<in> g b\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<not> cong x y b", "unfolding pairwise_def"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     res_function f \\<and>\n     (\\<forall>c.\n         (\\<forall>x\\<in>range (f c).\n             \\<forall>y\\<in>range (f c).\n                x \\<noteq> y \\<longrightarrow> \\<not> cong x y c) \\<and>\n         g c = range (f c))\n  x \\<in> g b\n  y \\<in> g b\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<not> cong x y b", "by auto"], ["", "subsubsection\\<open>Concrete instances in Euclidean rings\\<close>"], ["", "definition \"ass_function_euclidean (p::'a::{normalization_euclidean_semiring, euclidean_ring}) = normalize p\""], ["", "definition \"res_function_euclidean b (n::'a::{euclidean_ring}) = (if b = 0 then n else (n mod b))\""], ["", "lemma ass_function_euclidean: \"ass_function ass_function_euclidean\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ass_function ass_function_euclidean", "unfolding ass_function_def image_def ass_function_euclidean_def pairwise_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a. normalize a = normalize (normalize a)) \\<and>\n    (\\<forall>x\\<in>{y. \\<exists>x\\<in>UNIV. y = normalize x}.\n        \\<forall>y\\<in>{y. \\<exists>x\\<in>UNIV. y = normalize x}.\n           x \\<noteq> y \\<longrightarrow> normalize x \\<noteq> normalize y)", "by auto"], ["", "lemma res_function_euclidean: \n  \"res_function (res_function_euclidean :: 'a :: unique_euclidean_ring \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. res_function res_function_euclidean", "by (auto simp add: pairwise_def res_function_def cong_eq image_def res_function_euclidean_def dvd_minus_eq_mod)\n    (auto simp add: dvd_cong_not_eq_mod eq_mod_dvd_minus diff_mod_cong_0 cong_diff_mod exists_k_mod)"], ["", "subsubsection\\<open>Concrete case of the integer ring\\<close>"], ["", "definition \"ass_function_int (n::int) = abs n\""], ["", "lemma ass_function_int: \"ass_function_int = ass_function_euclidean\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ass_function_int = ass_function_euclidean", "by (unfold ass_function_int_def ass_function_euclidean_def) simp"], ["", "lemma ass_function_int_UNIV: \"(ass_function_int` UNIV) = {x. x\\<ge>0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range ass_function_int = {x. 0 \\<le> x}", "unfolding ass_function_int_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>UNIV. y = \\<bar>x\\<bar>} = {x. 0 \\<le> x}", "by (auto, metis abs_of_nonneg)"], ["", "subsection\\<open>Definition of Hermite Normal Form\\<close>"], ["", "text\\<open>\nIt is worth noting that there is not a single definition of Hermite Normal Form\nin the literature. For instance, some authors restrict their definitions to the case \nof square nonsingular matrices. Other authors just work with integer matrices.\nFurthermore, given a matrix $A$ its Hermite Normal Form $H$ can be defined to be upper triangular \nor lower triangular. In addition, the transformation from $A$ to $H$ can be made by means of \nelementary row operations or elementary column operations. In our case, we will work as general as \npossible, so our input will be any matrix (including nonsquare ones). The output will be an upper\ntriangular matrix obtained by means of elementary row operations.\n\nHence, given a complete set of nonassociates and a complete set of residues, \n$H$ is said to be in Hermite Normal Form if:\n\n\\begin{enumerate}\n\\item H is in Echelon Form\n\\item The first nonzero element of a nonzero row belongs to the complete set of nonassociates\n\\item Let $h$ be the first nonzero element of a nonzero row. Then each element above $h$\n  belongs to the corresponding complete set of residues of $h$\n\\end{enumerate}\n\nA matrix $H$ is the Hermite Normal Form of a matrix $A$ if:\n\\begin{enumerate}\n\\item There exists an invertible matrix $P$ such that $A = PH$\n\\item H is in Hermite Normal Form\n\\end{enumerate}\n\nThe Hermite Normal Form is usually applied to integer matrices. As we have already said, there is no\none single definition of it, so some authors impose different conditions. In the particular\ncase of integer matrices, leading coefficients (the first nonzero element of a nonzero row)\nare usually required to be positive, but it is also possible to impose them to be negative \nsince we would only have to multiply by $-1$.\n\nIn the case of the elements $h_{ik}$ above a leading coefficient $h_{ij}$, \nsome authors demand $0 \\leq h_{ik} < h_{ij}$, \nother ones impose the conditions $h_{ik} \\leq 0$ and \\mbox{$\\mid h_{ik} \\mid < h_{ij}$}, and other ones\n$- \\frac{h_{ij}}{2} < h_{ik} \\leq \\frac{h_{ij}}{2}$. More different options are also possible.\n\nAll the possibilities can be represented selecting a complete set of nonassociates and a \ncomplete set of residues. The algorithm to compute the Hermite Normal Form will be \nparameterised by functions which obtain the appropriate leading coefficient and the \nsuitable elements above them. We can execute the algorithm with different functions to get \nexactly which Hermite Normal Form we want. Once we fix such a complete set of nonassociates \nand the corresponding complete set of residues, the Hermite Normal Form is unique.\n\\<close>"], ["", "subsubsection\\<open>Echelon form up to row k\\<close>"], ["", "text\\<open>We present the definition of echelon form up to a row k (not included).\\<close>"], ["", "definition \"echelon_form_upt_row A k =\n  (\n    (\\<forall>i. to_nat i < k \\<and> is_zero_row i A \\<longrightarrow> \\<not> (\\<exists>j. j>i \\<and> to_nat j < k \\<and> \\<not> is_zero_row j A)) \\<and>  \n    (\\<forall>i j. i < j \\<and> to_nat j <  k \\<and> \\<not> is_zero_row i A \\<and> \\<not> is_zero_row j A \\<longrightarrow> (LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0))\n  )\""], ["", "lemma echelon_form_upt_row_condition1_explicit:\n  assumes \"echelon_form_upt_row A k\"\n  and \"to_nat i < k\" and \"is_zero_row i A\"\n  shows \"\\<not> (\\<exists>j. j>i \\<and> to_nat j < k \\<and> \\<not> is_zero_row j A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j>i.\n               mod_type_class.to_nat j < k \\<and> \\<not> is_zero_row j A)", "using assms"], ["proof (prove)\nusing this:\n  echelon_form_upt_row A k\n  mod_type_class.to_nat i < k\n  is_zero_row i A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j>i.\n               mod_type_class.to_nat j < k \\<and> \\<not> is_zero_row j A)", "unfolding echelon_form_upt_row_def"], ["proof (prove)\nusing this:\n  (\\<forall>i.\n      mod_type_class.to_nat i < k \\<and> is_zero_row i A \\<longrightarrow>\n      \\<not> (\\<exists>j>i.\n                 mod_type_class.to_nat j < k \\<and>\n                 \\<not> is_zero_row j A)) \\<and>\n  (\\<forall>i j.\n      i < j \\<and>\n      mod_type_class.to_nat j < k \\<and>\n      \\<not> is_zero_row i A \\<and> \\<not> is_zero_row j A \\<longrightarrow>\n      (LEAST n. A $ i $ n \\<noteq> (0::'a))\n      < (LEAST n. A $ j $ n \\<noteq> (0::'a)))\n  mod_type_class.to_nat i < k\n  is_zero_row i A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j>i.\n               mod_type_class.to_nat j < k \\<and> \\<not> is_zero_row j A)", "by blast"], ["", "lemma echelon_form_upt_row_condition1_explicit':\n  assumes \"echelon_form_upt_row A k\"\n  and \"to_nat i < k\" and \"is_zero_row i A\" and \"i\\<le>j\" and \"to_nat j < k\"\n  shows \"is_zero_row j A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row j A", "proof (cases \"i=j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> is_zero_row j A\n 2. i \\<noteq> j \\<Longrightarrow> is_zero_row j A", "case True"], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> is_zero_row j A\n 2. i \\<noteq> j \\<Longrightarrow> is_zero_row j A", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. is_zero_row j A", "using assms"], ["proof (prove)\nusing this:\n  i = j\n  echelon_form_upt_row A k\n  mod_type_class.to_nat i < k\n  is_zero_row i A\n  i \\<le> j\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. is_zero_row j A", "by auto"], ["proof (state)\nthis:\n  is_zero_row j A\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> is_zero_row j A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> is_zero_row j A", "case False"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> is_zero_row j A", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. is_zero_row j A", "using assms"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  echelon_form_upt_row A k\n  mod_type_class.to_nat i < k\n  is_zero_row i A\n  i \\<le> j\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. is_zero_row j A", "unfolding echelon_form_upt_row_def"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  (\\<forall>i.\n      mod_type_class.to_nat i < k \\<and> is_zero_row i A \\<longrightarrow>\n      \\<not> (\\<exists>j>i.\n                 mod_type_class.to_nat j < k \\<and>\n                 \\<not> is_zero_row j A)) \\<and>\n  (\\<forall>i j.\n      i < j \\<and>\n      mod_type_class.to_nat j < k \\<and>\n      \\<not> is_zero_row i A \\<and> \\<not> is_zero_row j A \\<longrightarrow>\n      (LEAST n. A $ i $ n \\<noteq> (0::'a))\n      < (LEAST n. A $ j $ n \\<noteq> (0::'a)))\n  mod_type_class.to_nat i < k\n  is_zero_row i A\n  i \\<le> j\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. is_zero_row j A", "by simp"], ["proof (state)\nthis:\n  is_zero_row j A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_form_upt_row_condition1_explicit_neg:\n  assumes \"echelon_form_upt_row A k\"\n  and iA: \"\\<not> is_zero_row i A\" and ia_i: \"ia < i\"\n  and i: \"to_nat i < k\"\n  shows \"\\<not> is_zero_row ia A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A", "have \"to_nat ia < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat ia < k", "by (metis ia_i i less_trans to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat ia < k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ia < k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A", "using assms"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ia < k\n  echelon_form_upt_row A k\n  \\<not> is_zero_row i A\n  ia < i\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A", "unfolding echelon_form_upt_row_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ia < k\n  (\\<forall>i.\n      mod_type_class.to_nat i < k \\<and> is_zero_row i A \\<longrightarrow>\n      \\<not> (\\<exists>j>i.\n                 mod_type_class.to_nat j < k \\<and>\n                 \\<not> is_zero_row j A)) \\<and>\n  (\\<forall>i j.\n      i < j \\<and>\n      mod_type_class.to_nat j < k \\<and>\n      \\<not> is_zero_row i A \\<and> \\<not> is_zero_row j A \\<longrightarrow>\n      (LEAST n. A $ i $ n \\<noteq> (0::'a))\n      < (LEAST n. A $ j $ n \\<noteq> (0::'a)))\n  \\<not> is_zero_row i A\n  ia < i\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A", "by blast"], ["proof (state)\nthis:\n  \\<not> is_zero_row ia A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_form_upt_row_condition2_explicit:\n  assumes \"echelon_form_upt_row A k\"\n  and \"ia < j\" and \"to_nat j < k\" and \"\\<not> is_zero_row ia A\" and \"\\<not> is_zero_row j A\"\n  shows \"(LEAST n. A $ ia $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "using assms"], ["proof (prove)\nusing this:\n  echelon_form_upt_row A k\n  ia < j\n  mod_type_class.to_nat j < k\n  \\<not> is_zero_row ia A\n  \\<not> is_zero_row j A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "unfolding echelon_form_upt_row_def"], ["proof (prove)\nusing this:\n  (\\<forall>i.\n      mod_type_class.to_nat i < k \\<and> is_zero_row i A \\<longrightarrow>\n      \\<not> (\\<exists>j>i.\n                 mod_type_class.to_nat j < k \\<and>\n                 \\<not> is_zero_row j A)) \\<and>\n  (\\<forall>i j.\n      i < j \\<and>\n      mod_type_class.to_nat j < k \\<and>\n      \\<not> is_zero_row i A \\<and> \\<not> is_zero_row j A \\<longrightarrow>\n      (LEAST n. A $ i $ n \\<noteq> (0::'a))\n      < (LEAST n. A $ j $ n \\<noteq> (0::'a)))\n  ia < j\n  mod_type_class.to_nat j < k\n  \\<not> is_zero_row ia A\n  \\<not> is_zero_row j A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by auto"], ["", "lemma echelon_form_upt_row_intro:\n  assumes\"(\\<forall>i. to_nat i < k \\<and> is_zero_row i A \\<longrightarrow> \\<not> (\\<exists>j. i<j \\<and> to_nat j < k \\<and> \\<not> is_zero_row j A))\"\n  and \"(\\<forall>i j. i < j \\<and> to_nat j <  k \\<and> \\<not> is_zero_row i A \\<and> \\<not> is_zero_row j A \\<longrightarrow> (LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0))\"\n  shows \"echelon_form_upt_row A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_upt_row A k", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     mod_type_class.to_nat i < k \\<and> is_zero_row i A \\<longrightarrow>\n     \\<not> (\\<exists>j>i.\n                mod_type_class.to_nat j < k \\<and> \\<not> is_zero_row j A)\n  \\<forall>i j.\n     i < j \\<and>\n     mod_type_class.to_nat j < k \\<and>\n     \\<not> is_zero_row i A \\<and> \\<not> is_zero_row j A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'b))\n     < (LEAST n. A $ j $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. echelon_form_upt_row A k", "unfolding echelon_form_upt_row_def"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     mod_type_class.to_nat i < k \\<and> is_zero_row i A \\<longrightarrow>\n     \\<not> (\\<exists>j>i.\n                mod_type_class.to_nat j < k \\<and> \\<not> is_zero_row j A)\n  \\<forall>i j.\n     i < j \\<and>\n     mod_type_class.to_nat j < k \\<and>\n     \\<not> is_zero_row i A \\<and> \\<not> is_zero_row j A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'b))\n     < (LEAST n. A $ j $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        mod_type_class.to_nat i < k \\<and> is_zero_row i A \\<longrightarrow>\n        \\<not> (\\<exists>j>i.\n                   mod_type_class.to_nat j < k \\<and>\n                   \\<not> is_zero_row j A)) \\<and>\n    (\\<forall>i j.\n        i < j \\<and>\n        mod_type_class.to_nat j < k \\<and>\n        \\<not> is_zero_row i A \\<and>\n        \\<not> is_zero_row j A \\<longrightarrow>\n        (LEAST n. A $ i $ n \\<noteq> (0::'b))\n        < (LEAST n. A $ j $ n \\<noteq> (0::'b)))", "by simp"], ["", "lemma echelon_form_echelon_form_upt_row: \"echelon_form A = echelon_form_upt_row A (nrows A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form A = echelon_form_upt_row A (nrows A)", "by (simp add: to_nat_less_card echelon_form_def echelon_form_upt_row_def ncols_def nrows_def \n      echelon_form_upt_k_def is_zero_row_upt_k_def is_zero_row_def)"], ["", "subsubsection\\<open>Hermite Normal Form up to row k\\<close>"], ["", "text\\<open>Predicate to check if a matrix is in Hermite Normal form up to row k (not included).\\<close>"], ["", "definition \"Hermite_upt_row A k associates residues = \n  (\n    Complete_set_non_associates associates \\<and>\n    Complete_set_residues residues \\<and>\n    echelon_form_upt_row A k \\<and>\n    (\\<forall>i. to_nat i < k \\<and> \\<not> is_zero_row i A \\<longrightarrow> A $ i $ (LEAST n. A $ i $ n \\<noteq> 0) \\<in> associates) \\<and>\n    (\\<forall>i. to_nat i < k \\<and> \\<not> is_zero_row i A \\<longrightarrow> (\\<forall>j<i. A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) \\<in> residues (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))))\n  )\""], ["", "text\\<open>The definition of Hermite Normal Form is now introduced:\\<close>"], ["", "definition Hermite::\"'a::{bezout_ring_div,normalization_semidom} set \\<Rightarrow> ('a \\<Rightarrow> 'a set) \\<Rightarrow> \n   (('a, 'b::{mod_type}) vec, 'c::{mod_type}) vec \\<Rightarrow> bool\"\nwhere  \"Hermite associates residues A = (\n  Complete_set_non_associates associates \n  \\<and> (Complete_set_residues residues) \n  \\<and> echelon_form A \n  \\<and> (\\<forall>i. \\<not> is_zero_row i A \\<longrightarrow> A $ i $ (LEAST n. A $ i $ n \\<noteq> 0) \\<in> associates) \n  \\<and> (\\<forall>i. \\<not> is_zero_row i A \\<longrightarrow> (\\<forall>j. j<i \\<longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) \\<in> residues (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))))\n  )\""], ["", "lemma Hermite_Hermite_upt_row: \"Hermite ass res A = Hermite_upt_row A (nrows A) ass res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite ass res A = Hermite_upt_row A (nrows A) ass res", "by (simp add: Hermite_def Hermite_upt_row_def to_nat_less_card is_zero_row_def \n    nrows_def ncols_def echelon_form_echelon_form_upt_row)"], ["", "lemma Hermite_intro:\n  assumes \"Complete_set_non_associates associates\"\n  and \"Complete_set_residues residues\"\n  and \"echelon_form A \"\n  and \"(\\<forall>i. \\<not> is_zero_row i A \\<longrightarrow> A $ i $ (LEAST n. A $ i $ n \\<noteq> 0) \\<in> associates)\"\n  and \"(\\<forall>i. \\<not> is_zero_row i A \\<longrightarrow> (\\<forall>j. j<i \\<longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) \\<in> residues (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))))\"\n  shows \"Hermite associates residues A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite associates residues A", "using assms"], ["proof (prove)\nusing this:\n  Complete_set_non_associates associates\n  Complete_set_residues residues\n  echelon_form A\n  \\<forall>i.\n     \\<not> is_zero_row i A \\<longrightarrow>\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<in> associates\n  \\<forall>i.\n     \\<not> is_zero_row i A \\<longrightarrow>\n     (\\<forall>j<i.\n         A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         \\<in> residues (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n\ngoal (1 subgoal):\n 1. Hermite associates residues A", "unfolding Hermite_def"], ["proof (prove)\nusing this:\n  Complete_set_non_associates associates\n  Complete_set_residues residues\n  echelon_form A\n  \\<forall>i.\n     \\<not> is_zero_row i A \\<longrightarrow>\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<in> associates\n  \\<forall>i.\n     \\<not> is_zero_row i A \\<longrightarrow>\n     (\\<forall>j<i.\n         A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         \\<in> residues (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n\ngoal (1 subgoal):\n 1. Complete_set_non_associates associates \\<and>\n    Complete_set_residues residues \\<and>\n    echelon_form A \\<and>\n    (\\<forall>i.\n        \\<not> is_zero_row i A \\<longrightarrow>\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        \\<in> associates) \\<and>\n    (\\<forall>i.\n        \\<not> is_zero_row i A \\<longrightarrow>\n        (\\<forall>j<i.\n            A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n            \\<in> residues (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))))", "by simp"], ["", "subsection\\<open>Definition of an algorithm to compute the Hermite Normal Form\\<close>"], ["", "text\\<open>\nThe algorithm is parameterised by three functions:\n\n\\begin{itemize}\n  \\item The function that computes de B\\'ezout identity (necessary to compute the echelon form).\n  \\item The function that given an element, it returns its representative element in the associated equivalent class,\n        which will be an element in the complete set of nonassociates.\n  \\item The function that given two elements $a$ and $b$, it returns its representative \n        element in the congruent equivalent class of $b$, which will be an element in the complete set of residues of $b$.\n\\end{itemize}\n\n\n\\<close>"], ["", "primrec Hermite_reduce_above :: \"'a::unique_euclidean_ring^'cols::mod_type^'rows::mod_type\\<Rightarrow>nat\n    \\<Rightarrow>'rows\\<Rightarrow>'cols\\<Rightarrow> ('a\\<Rightarrow>'a\\<Rightarrow>'a) \\<Rightarrow> 'a^'cols::mod_type^'rows::mod_type\"\nwhere \"Hermite_reduce_above A 0 i j res  = A\"\n    | \"Hermite_reduce_above A (Suc n) i j res  = (let i'=((from_nat n)::'rows); \n    Aij = A $ i $ j;\n    Ai'j = A $ i' $ j\n    in \n    Hermite_reduce_above (row_add A  i' i (((res Aij (Ai'j)) - (Ai'j)) div Aij)) n i j res)\""], ["", "definition \"Hermite_of_row_i ass res A i = (\n  if is_zero_row i A \n     then A \n  else\n    let j = (LEAST n. A $ i $ n \\<noteq> 0); Aij= (A $ i $ j);\n    A' = mult_row A i ((ass Aij) div Aij)\n    in Hermite_reduce_above A' (to_nat i) i j res)\""], ["", "definition \"Hermite_of_upt_row_i A i ass res = foldl (Hermite_of_row_i ass res) A (map from_nat [0..<i])\""], ["", "definition \"Hermite_of A ass res bezout = \n  (let A'= echelon_form_of A bezout in Hermite_of_upt_row_i A' (nrows A) ass res)\""], ["", "subsection\\<open>Proving the correctness of the algorithm\\<close>"], ["", "subsubsection\\<open>The proof\\<close>"], ["", "lemma Hermite_reduce_above_preserves:\n  assumes n: \"n\\<le>to_nat a\"\n  shows \"(Hermite_reduce_above A n i j res) $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above A n i j res $ a $ b = A $ a $ b", "using n"], ["proof (prove)\nusing this:\n  n \\<le> mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. Hermite_reduce_above A n i j res $ a $ b = A $ a $ b", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       0 \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n       Hermite_reduce_above A 0 i j res $ a $ b = A $ a $ b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n                   Hermite_reduce_above A n i j res $ a $ b = A $ a $ b;\n        Suc n \\<le> mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A (Suc n) i j res $ a $ b =\n                         A $ a $ b", "case 0"], ["proof (state)\nthis:\n  0 \\<le> mod_type_class.to_nat a\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       0 \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n       Hermite_reduce_above A 0 i j res $ a $ b = A $ a $ b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n                   Hermite_reduce_above A n i j res $ a $ b = A $ a $ b;\n        Suc n \\<le> mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A (Suc n) i j res $ a $ b =\n                         A $ a $ b", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le> mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. Hermite_reduce_above A 0 i j res $ a $ b = A $ a $ b", "by simp"], ["proof (state)\nthis:\n  Hermite_reduce_above A 0 i j res $ a $ b = A $ a $ b\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n                   Hermite_reduce_above A n i j res $ a $ b = A $ a $ b;\n        Suc n \\<le> mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A (Suc n) i j res $ a $ b =\n                         A $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n                   Hermite_reduce_above A n i j res $ a $ b = A $ a $ b;\n        Suc n \\<le> mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A (Suc n) i j res $ a $ b =\n                         A $ a $ b", "case (Suc n)"], ["proof (state)\nthis:\n  n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n  Hermite_reduce_above ?A n i j res $ a $ b = ?A $ a $ b\n  Suc n \\<le> mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n                   Hermite_reduce_above A n i j res $ a $ b = A $ a $ b;\n        Suc n \\<le> mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A (Suc n) i j res $ a $ b =\n                         A $ a $ b", "thus ?case"], ["proof (prove)\nusing this:\n  n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n  Hermite_reduce_above ?A n i j res $ a $ b = ?A $ a $ b\n  Suc n \\<le> mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. Hermite_reduce_above A (Suc n) i j res $ a $ b = A $ a $ b", "by (auto simp add: Let_def row_add_def)\n  (metis Suc_le_eq from_nat_mono from_nat_to_nat_id less_irrefl to_nat_less_card)"], ["proof (state)\nthis:\n  Hermite_reduce_above A (Suc n) i j res $ a $ b = A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_reduce_above_works:\n  assumes n: \"n \\<le> to_nat i\" and a: \"to_nat a < n\"\n  shows \"(Hermite_reduce_above A n i j res) $ a $ b \n         = row_add A a i ((res (A$i$j) (A$a$j) - (A$a$j)) div (A$i$j)) $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above A n i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "using n a"], ["proof (prove)\nusing this:\n  n \\<le> mod_type_class.to_nat i\n  mod_type_class.to_nat a < n\n\ngoal (1 subgoal):\n 1. Hermite_reduce_above A n i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>0 \\<le> mod_type_class.to_nat i;\n        mod_type_class.to_nat a < 0\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A 0 i j res $ a $ b =\n                         row_add A a i\n                          ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div\n                           A $ i $ j) $\n                         a $\n                         b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n \\<le> mod_type_class.to_nat i;\n                    mod_type_class.to_nat a < n\\<rbrakk>\n                   \\<Longrightarrow> Hermite_reduce_above A n i j res $ a $\n                                     b =\n                                     row_add A a i\n((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n                                     a $\n                                     b;\n        Suc n \\<le> mod_type_class.to_nat i;\n        mod_type_class.to_nat a < Suc n\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A (Suc n) i j res $ a $ b =\n                         row_add A a i\n                          ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div\n                           A $ i $ j) $\n                         a $\n                         b", "case 0"], ["proof (state)\nthis:\n  0 \\<le> mod_type_class.to_nat i\n  mod_type_class.to_nat a < 0\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>0 \\<le> mod_type_class.to_nat i;\n        mod_type_class.to_nat a < 0\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A 0 i j res $ a $ b =\n                         row_add A a i\n                          ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div\n                           A $ i $ j) $\n                         a $\n                         b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n \\<le> mod_type_class.to_nat i;\n                    mod_type_class.to_nat a < n\\<rbrakk>\n                   \\<Longrightarrow> Hermite_reduce_above A n i j res $ a $\n                                     b =\n                                     row_add A a i\n((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n                                     a $\n                                     b;\n        Suc n \\<le> mod_type_class.to_nat i;\n        mod_type_class.to_nat a < Suc n\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A (Suc n) i j res $ a $ b =\n                         row_add A a i\n                          ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div\n                           A $ i $ j) $\n                         a $\n                         b", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le> mod_type_class.to_nat i\n  mod_type_class.to_nat a < 0\n\ngoal (1 subgoal):\n 1. Hermite_reduce_above A 0 i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "by (simp add: row_add_def)"], ["proof (state)\nthis:\n  Hermite_reduce_above A 0 i j res $ a $ b =\n  row_add A a i ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n \\<le> mod_type_class.to_nat i;\n                    mod_type_class.to_nat a < n\\<rbrakk>\n                   \\<Longrightarrow> Hermite_reduce_above A n i j res $ a $\n                                     b =\n                                     row_add A a i\n((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n                                     a $\n                                     b;\n        Suc n \\<le> mod_type_class.to_nat i;\n        mod_type_class.to_nat a < Suc n\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A (Suc n) i j res $ a $ b =\n                         row_add A a i\n                          ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div\n                           A $ i $ j) $\n                         a $\n                         b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n \\<le> mod_type_class.to_nat i;\n                    mod_type_class.to_nat a < n\\<rbrakk>\n                   \\<Longrightarrow> Hermite_reduce_above A n i j res $ a $\n                                     b =\n                                     row_add A a i\n((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n                                     a $\n                                     b;\n        Suc n \\<le> mod_type_class.to_nat i;\n        mod_type_class.to_nat a < Suc n\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A (Suc n) i j res $ a $ b =\n                         row_add A a i\n                          ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div\n                           A $ i $ j) $\n                         a $\n                         b", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> mod_type_class.to_nat i;\n   mod_type_class.to_nat a < n\\<rbrakk>\n  \\<Longrightarrow> Hermite_reduce_above ?A n i j res $ a $ b =\n                    row_add ?A a i\n                     ((res (?A $ i $ j) (?A $ a $ j) - ?A $ a $ j) div\n                      ?A $ i $ j) $\n                    a $\n                    b\n  Suc n \\<le> mod_type_class.to_nat i\n  mod_type_class.to_nat a < Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n \\<le> mod_type_class.to_nat i;\n                    mod_type_class.to_nat a < n\\<rbrakk>\n                   \\<Longrightarrow> Hermite_reduce_above A n i j res $ a $\n                                     b =\n                                     row_add A a i\n((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n                                     a $\n                                     b;\n        Suc n \\<le> mod_type_class.to_nat i;\n        mod_type_class.to_nat a < Suc n\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A (Suc n) i j res $ a $ b =\n                         row_add A a i\n                          ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div\n                           A $ i $ j) $\n                         a $\n                         b", "define A' where \"A' = row_add A (from_nat n) i\n    ((res (A $ i $ j) (A $ from_nat n $ j) - A $ from_nat n $ j) div A $ i $ j)\""], ["proof (state)\nthis:\n  A' =\n  row_add A (mod_type_class.from_nat n) i\n   ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n     A $ mod_type_class.from_nat n $ j) div\n    A $ i $ j)\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n \\<le> mod_type_class.to_nat i;\n                    mod_type_class.to_nat a < n\\<rbrakk>\n                   \\<Longrightarrow> Hermite_reduce_above A n i j res $ a $\n                                     b =\n                                     row_add A a i\n((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n                                     a $\n                                     b;\n        Suc n \\<le> mod_type_class.to_nat i;\n        mod_type_class.to_nat a < Suc n\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A (Suc n) i j res $ a $ b =\n                         row_add A a i\n                          ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div\n                           A $ i $ j) $\n                         a $\n                         b", "have n: \"n < nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < nrows A", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < CARD('a)", "by (metis Suc.prems(1) Suc_le_eq less_trans to_nat_less_card)"], ["proof (state)\nthis:\n  n < nrows A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n \\<le> mod_type_class.to_nat i;\n                    mod_type_class.to_nat a < n\\<rbrakk>\n                   \\<Longrightarrow> Hermite_reduce_above A n i j res $ a $\n                                     b =\n                                     row_add A a i\n((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n                                     a $\n                                     b;\n        Suc n \\<le> mod_type_class.to_nat i;\n        mod_type_class.to_nat a < Suc n\\<rbrakk>\n       \\<Longrightarrow> Hermite_reduce_above A (Suc n) i j res $ a $ b =\n                         row_add A a i\n                          ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div\n                           A $ i $ j) $\n                         a $\n                         b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "proof (cases \"to_nat a = n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b\n 2. mod_type_class.to_nat a \\<noteq> n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "case False"], ["proof (state)\nthis:\n  mod_type_class.to_nat a \\<noteq> n\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b\n 2. mod_type_class.to_nat a \\<noteq> n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "have a_less_n: \"to_nat a < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < n", "by (metis False Suc.prems(2) less_antisym)"], ["proof (state)\nthis:\n  mod_type_class.to_nat a < n\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b\n 2. mod_type_class.to_nat a \\<noteq> n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "have \"Hermite_reduce_above A (Suc n) i j res $ a $ b = Hermite_reduce_above A' n i j res $ a $ b \""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    Hermite_reduce_above A' n i j res $ a $ b", "by (simp add: Let_def A'_def)"], ["proof (state)\nthis:\n  Hermite_reduce_above A (Suc n) i j res $ a $ b =\n  Hermite_reduce_above A' n i j res $ a $ b\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b\n 2. mod_type_class.to_nat a \\<noteq> n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "also"], ["proof (state)\nthis:\n  Hermite_reduce_above A (Suc n) i j res $ a $ b =\n  Hermite_reduce_above A' n i j res $ a $ b\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b\n 2. mod_type_class.to_nat a \\<noteq> n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "have \"... = row_add A' a i ((res (A' $ i $ j) (A' $ a $ j) - A' $ a $ j) div A' $ i $ j) $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above A' n i j res $ a $ b =\n    row_add A' a i\n     ((res (A' $ i $ j) (A' $ a $ j) - A' $ a $ j) div A' $ i $ j) $\n    a $\n    b", "by (rule Suc.hyps[OF _  a_less_n], simp add: Suc.prems(1) Suc_leD)"], ["proof (state)\nthis:\n  Hermite_reduce_above A' n i j res $ a $ b =\n  row_add A' a i\n   ((res (A' $ i $ j) (A' $ a $ j) - A' $ a $ j) div A' $ i $ j) $\n  a $\n  b\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b\n 2. mod_type_class.to_nat a \\<noteq> n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "also"], ["proof (state)\nthis:\n  Hermite_reduce_above A' n i j res $ a $ b =\n  row_add A' a i\n   ((res (A' $ i $ j) (A' $ a $ j) - A' $ a $ j) div A' $ i $ j) $\n  a $\n  b\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b\n 2. mod_type_class.to_nat a \\<noteq> n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "have \"... = row_add A a i ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add A' a i\n     ((res (A' $ i $ j) (A' $ a $ j) - A' $ a $ j) div A' $ i $ j) $\n    a $\n    b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "unfolding row_add_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = a\n        then (\\<chi>ia ja.\n                 if ia = mod_type_class.from_nat n\n                 then A $ mod_type_class.from_nat n $ ja +\n                      (res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n                       A $ mod_type_class.from_nat n $ j) div\n                      A $ i $ j *\n                      A $ i $ ja\n                 else A $ ia $ ja) $\n             a $\n             ja +\n             (res ((\\<chi>ia ja.\n                       if ia = mod_type_class.from_nat n\n                       then A $ mod_type_class.from_nat n $ ja +\n                            (res (A $ i $ j)\n                              (A $ mod_type_class.from_nat n $ j) -\n                             A $ mod_type_class.from_nat n $ j) div\n                            A $ i $ j *\n                            A $ i $ ja\n                       else A $ ia $ ja) $\n                   i $\n                   j)\n               ((\\<chi>ia ja.\n                    if ia = mod_type_class.from_nat n\n                    then A $ mod_type_class.from_nat n $ ja +\n                         (res (A $ i $ j)\n                           (A $ mod_type_class.from_nat n $ j) -\n                          A $ mod_type_class.from_nat n $ j) div\n                         A $ i $ j *\n                         A $ i $ ja\n                    else A $ ia $ ja) $\n                a $\n                j) -\n              (\\<chi>ia ja.\n                  if ia = mod_type_class.from_nat n\n                  then A $ mod_type_class.from_nat n $ ja +\n                       (res (A $ i $ j)\n                         (A $ mod_type_class.from_nat n $ j) -\n                        A $ mod_type_class.from_nat n $ j) div\n                       A $ i $ j *\n                       A $ i $ ja\n                  else A $ ia $ ja) $\n              a $\n              j) div\n             (\\<chi>ia ja.\n                 if ia = mod_type_class.from_nat n\n                 then A $ mod_type_class.from_nat n $ ja +\n                      (res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n                       A $ mod_type_class.from_nat n $ j) div\n                      A $ i $ j *\n                      A $ i $ ja\n                 else A $ ia $ ja) $\n             i $\n             j *\n             (\\<chi>ia ja.\n                 if ia = mod_type_class.from_nat n\n                 then A $ mod_type_class.from_nat n $ ja +\n                      (res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n                       A $ mod_type_class.from_nat n $ j) div\n                      A $ i $ j *\n                      A $ i $ ja\n                 else A $ ia $ ja) $\n             i $\n             ja\n        else (\\<chi>ia ja.\n                 if ia = mod_type_class.from_nat n\n                 then A $ mod_type_class.from_nat n $ ja +\n                      (res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n                       A $ mod_type_class.from_nat n $ j) div\n                      A $ i $ j *\n                      A $ i $ ja\n                 else A $ ia $ ja) $\n             ia $\n             ja) $\n    a $\n    b =\n    (\\<chi>ia ja.\n        if ia = a\n        then A $ a $ ja +\n             (res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j *\n             A $ i $ ja\n        else A $ ia $ ja) $\n    a $\n    b", "using a_less_n Suc.prems n to_nat_from_nat_id[OF n[unfolded nrows_def]]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a < n\n  Suc n \\<le> mod_type_class.to_nat i\n  mod_type_class.to_nat a < Suc n\n  n < nrows A\n  mod_type_class.to_nat (mod_type_class.from_nat n) = n\n\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = a\n        then (\\<chi>ia ja.\n                 if ia = mod_type_class.from_nat n\n                 then A $ mod_type_class.from_nat n $ ja +\n                      (res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n                       A $ mod_type_class.from_nat n $ j) div\n                      A $ i $ j *\n                      A $ i $ ja\n                 else A $ ia $ ja) $\n             a $\n             ja +\n             (res ((\\<chi>ia ja.\n                       if ia = mod_type_class.from_nat n\n                       then A $ mod_type_class.from_nat n $ ja +\n                            (res (A $ i $ j)\n                              (A $ mod_type_class.from_nat n $ j) -\n                             A $ mod_type_class.from_nat n $ j) div\n                            A $ i $ j *\n                            A $ i $ ja\n                       else A $ ia $ ja) $\n                   i $\n                   j)\n               ((\\<chi>ia ja.\n                    if ia = mod_type_class.from_nat n\n                    then A $ mod_type_class.from_nat n $ ja +\n                         (res (A $ i $ j)\n                           (A $ mod_type_class.from_nat n $ j) -\n                          A $ mod_type_class.from_nat n $ j) div\n                         A $ i $ j *\n                         A $ i $ ja\n                    else A $ ia $ ja) $\n                a $\n                j) -\n              (\\<chi>ia ja.\n                  if ia = mod_type_class.from_nat n\n                  then A $ mod_type_class.from_nat n $ ja +\n                       (res (A $ i $ j)\n                         (A $ mod_type_class.from_nat n $ j) -\n                        A $ mod_type_class.from_nat n $ j) div\n                       A $ i $ j *\n                       A $ i $ ja\n                  else A $ ia $ ja) $\n              a $\n              j) div\n             (\\<chi>ia ja.\n                 if ia = mod_type_class.from_nat n\n                 then A $ mod_type_class.from_nat n $ ja +\n                      (res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n                       A $ mod_type_class.from_nat n $ j) div\n                      A $ i $ j *\n                      A $ i $ ja\n                 else A $ ia $ ja) $\n             i $\n             j *\n             (\\<chi>ia ja.\n                 if ia = mod_type_class.from_nat n\n                 then A $ mod_type_class.from_nat n $ ja +\n                      (res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n                       A $ mod_type_class.from_nat n $ j) div\n                      A $ i $ j *\n                      A $ i $ ja\n                 else A $ ia $ ja) $\n             i $\n             ja\n        else (\\<chi>ia ja.\n                 if ia = mod_type_class.from_nat n\n                 then A $ mod_type_class.from_nat n $ ja +\n                      (res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n                       A $ mod_type_class.from_nat n $ j) div\n                      A $ i $ j *\n                      A $ i $ ja\n                 else A $ ia $ ja) $\n             ia $\n             ja) $\n    a $\n    b =\n    (\\<chi>ia ja.\n        if ia = a\n        then A $ a $ ja +\n             (res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j *\n             A $ i $ ja\n        else A $ ia $ ja) $\n    a $\n    b", "by auto"], ["proof (state)\nthis:\n  row_add A' a i\n   ((res (A' $ i $ j) (A' $ a $ j) - A' $ a $ j) div A' $ i $ j) $\n  a $\n  b =\n  row_add A a i ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n  a $\n  b\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b\n 2. mod_type_class.to_nat a \\<noteq> n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "finally"], ["proof (chain)\npicking this:\n  Hermite_reduce_above A (Suc n) i j res $ a $ b =\n  row_add A a i ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n  a $\n  b", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_reduce_above A (Suc n) i j res $ a $ b =\n  row_add A a i ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "."], ["proof (state)\nthis:\n  Hermite_reduce_above A (Suc n) i j res $ a $ b =\n  row_add A a i ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat a = n\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "hence a_eq_fn_n: \"a = from_nat n\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a = n\n\ngoal (1 subgoal):\n 1. a = mod_type_class.from_nat n", "by auto"], ["proof (state)\nthis:\n  a = mod_type_class.from_nat n\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "have \"Hermite_reduce_above A (Suc n) i j res $ a $ b = Hermite_reduce_above A' n i j res $ a $ b \""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    Hermite_reduce_above A' n i j res $ a $ b", "by (simp add: Let_def A'_def)"], ["proof (state)\nthis:\n  Hermite_reduce_above A (Suc n) i j res $ a $ b =\n  Hermite_reduce_above A' n i j res $ a $ b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "also"], ["proof (state)\nthis:\n  Hermite_reduce_above A (Suc n) i j res $ a $ b =\n  Hermite_reduce_above A' n i j res $ a $ b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "have \"... = A' $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above A' n i j res $ a $ b = A' $ a $ b", "by (rule Hermite_reduce_above_preserves, simp add: True)"], ["proof (state)\nthis:\n  Hermite_reduce_above A' n i j res $ a $ b = A' $ a $ b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a = n \\<Longrightarrow>\n    Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "finally"], ["proof (chain)\npicking this:\n  Hermite_reduce_above A (Suc n) i j res $ a $ b = A' $ a $ b", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_reduce_above A (Suc n) i j res $ a $ b = A' $ a $ b\n\ngoal (1 subgoal):\n 1. Hermite_reduce_above A (Suc n) i j res $ a $ b =\n    row_add A a i\n     ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n    a $\n    b", "unfolding A'_def a_eq_fn_n"], ["proof (prove)\nusing this:\n  Hermite_reduce_above A (Suc n) i j res $ mod_type_class.from_nat n $ b =\n  row_add A (mod_type_class.from_nat n) i\n   ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n     A $ mod_type_class.from_nat n $ j) div\n    A $ i $ j) $\n  mod_type_class.from_nat n $\n  b\n\ngoal (1 subgoal):\n 1. Hermite_reduce_above A (Suc n) i j res $ mod_type_class.from_nat n $ b =\n    row_add A (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j) $\n    mod_type_class.from_nat n $\n    b", "."], ["proof (state)\nthis:\n  Hermite_reduce_above A (Suc n) i j res $ a $ b =\n  row_add A a i ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n  a $\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Hermite_reduce_above A (Suc n) i j res $ a $ b =\n  row_add A a i ((res (A $ i $ j) (A $ a $ j) - A $ a $ j) div A $ i $ j) $\n  a $\n  b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_row_preserves_below:\nassumes i_a: \"i<a\"\nshows \"(Hermite_of_row_i ass res A i) $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ a $ b = A $ a $ b", "proof (auto simp add: Hermite_of_row_i_def Let_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "let ?M=\"(mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "let ?H=\"Hermite_reduce_above ?M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "have \"?H $ a $ b = ?M $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    a $\n    b", "by (rule Hermite_reduce_above_preserves) \n     (metis i_a not_le not_less_iff_gr_or_eq to_nat_mono')"], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "have \"... = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    a $\n    b =\n    A $ a $ b", "unfolding mult_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    a $\n    b =\n    A $ a $ b", "using i_a"], ["proof (prove)\nusing this:\n  i < a\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    a $\n    b =\n    A $ a $ b", "by fastforce"], ["proof (state)\nthis:\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n  a $\n  b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "finally"], ["proof (chain)\npicking this:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  A $ a $ b", "show \"?H $ a $ b = A $ a $ b\""], ["proof (prove)\nusing this:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "."], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_row_preserves_previous_cols:\nassumes b: \"b<(LEAST n. A $ i $ n \\<noteq> 0)\"\nand not_zero_i_A: \"\\<not> is_zero_row i A\"\nand e: \"echelon_form A\"\nshows \"(Hermite_of_row_i ass res A i) $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ a $ b = A $ a $ b", "proof (auto simp add: Hermite_of_row_i_def Let_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "let ?n=\"(LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "let ?M=\"(mult_row A i (ass (A $ i $ ?n) div A $ i $ ?n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "let ?H=\"Hermite_reduce_above ?M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "have Aib: \" A $ i $ b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ b = (0::'b)", "by (metis (mono_tags) b not_less_Least)"], ["proof (state)\nthis:\n  A $ i $ b = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "show \"?H $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "proof (cases \"a\\<ge>i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b\n 2. \\<not> i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "case True"], ["proof (state)\nthis:\n  i \\<le> a\n\ngoal (2 subgoals):\n 1. i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b\n 2. \\<not> i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "have \"?H $ a $ b = ?M $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    a $\n    b", "by (rule Hermite_reduce_above_preserves) (metis True to_nat_mono')"], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n  a $\n  b\n\ngoal (2 subgoals):\n 1. i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b\n 2. \\<not> i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n  a $\n  b\n\ngoal (2 subgoals):\n 1. i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b\n 2. \\<not> i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "have \"... = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    a $\n    b =\n    A $ a $ b", "using Aib"], ["proof (prove)\nusing this:\n  A $ i $ b = (0::'b)\n\ngoal (1 subgoal):\n 1. mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    a $\n    b =\n    A $ a $ b", "unfolding mult_row_def"], ["proof (prove)\nusing this:\n  A $ i $ b = (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    a $\n    b =\n    A $ a $ b", "by auto"], ["proof (state)\nthis:\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n  a $\n  b =\n  A $ a $ b\n\ngoal (2 subgoals):\n 1. i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b\n 2. \\<not> i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "finally"], ["proof (chain)\npicking this:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  A $ a $ b", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "."], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "let ?R=\"row_add ?M a i ((res (?M $ i $ ?n) (?M $ a $ ?n) - ?M $ a $ ?n) div ?M $ i $ ?n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "case False"], ["proof (state)\nthis:\n  \\<not> i \\<le> a\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "hence ia: \"i>a\""], ["proof (prove)\nusing this:\n  \\<not> i \\<le> a\n\ngoal (1 subgoal):\n 1. a < i", "by simp"], ["proof (state)\nthis:\n  a < i\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "have \"?H $ a $ b = ?R $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    row_add\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     a i\n     ((res (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n            i $\n            (LEAST n. A $ i $ n \\<noteq> (0::'b)))\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n         a $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))) -\n       mult_row A i\n        (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n         A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n       a $\n       (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n      i $\n      (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    a $\n    b", "by (rule Hermite_reduce_above_works, auto simp add: ia to_nat_mono)"], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  row_add\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   a i\n   ((res (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n          i $\n          (LEAST n. A $ i $ n \\<noteq> (0::'b)))\n      (mult_row A i\n        (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n         A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n       a $\n       (LEAST n. A $ i $ n \\<noteq> (0::'b))) -\n     mult_row A i\n      (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n       A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n     a $\n     (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n    mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "also"], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  row_add\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   a i\n   ((res (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n          i $\n          (LEAST n. A $ i $ n \\<noteq> (0::'b)))\n      (mult_row A i\n        (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n         A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n       a $\n       (LEAST n. A $ i $ n \\<noteq> (0::'b))) -\n     mult_row A i\n      (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n       A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n     a $\n     (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n    mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "have \"... = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     a i\n     ((res (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n            i $\n            (LEAST n. A $ i $ n \\<noteq> (0::'b)))\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n         a $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))) -\n       mult_row A i\n        (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n         A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n       a $\n       (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n      i $\n      (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    a $\n    b =\n    A $ a $ b", "using ia Aib"], ["proof (prove)\nusing this:\n  a < i\n  A $ i $ b = (0::'b)\n\ngoal (1 subgoal):\n 1. row_add\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     a i\n     ((res (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n            i $\n            (LEAST n. A $ i $ n \\<noteq> (0::'b)))\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n         a $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))) -\n       mult_row A i\n        (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n         A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n       a $\n       (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n      i $\n      (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    a $\n    b =\n    A $ a $ b", "unfolding row_add_def mult_row_def"], ["proof (prove)\nusing this:\n  a < i\n  A $ i $ b = (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = a\n        then (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             a $\n             j +\n             (res ((\\<chi>ia j.\n                       if ia = i\n                       then ass (A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n                            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) *\n                            A $ i $ j\n                       else A $ ia $ j) $\n                   i $\n                   (LEAST n. A $ i $ n \\<noteq> (0::'b)))\n               ((\\<chi>ia j.\n                    if ia = i\n                    then ass (A $ i $\n                              (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n                         A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) *\n                         A $ i $ j\n                    else A $ ia $ j) $\n                a $\n                (LEAST n. A $ i $ n \\<noteq> (0::'b))) -\n              (\\<chi>ia j.\n                  if ia = i\n                  then ass (A $ i $\n                            (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n                       A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) *\n                       A $ i $ j\n                  else A $ ia $ j) $\n              a $\n              (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n             (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             i $\n             (LEAST n. A $ i $ n \\<noteq> (0::'b)) *\n             (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             i $\n             j\n        else (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             ia $\n             j) $\n    a $\n    b =\n    A $ a $ b", "by auto"], ["proof (state)\nthis:\n  row_add\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   a i\n   ((res (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n          i $\n          (LEAST n. A $ i $ n \\<noteq> (0::'b)))\n      (mult_row A i\n        (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n         A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n       a $\n       (LEAST n. A $ i $ n \\<noteq> (0::'b))) -\n     mult_row A i\n      (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n       A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n     a $\n     (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n    mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n  a $\n  b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> a \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "finally"], ["proof (chain)\npicking this:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  A $ a $ b", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b =\n    A $ a $ b", "."], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n  a $\n  b =\n  A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_form_Hermite_of_condition1:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and not_zero_iA: \"\\<not> is_zero_row i A\"\n  and zero_ia_H: \"is_zero_row ia H\"\n  and ia_j: \"ia < j\"\n  shows \"is_zero_row j H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row j H", "proof (cases \"is_zero_row ia A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row ia A \\<Longrightarrow> is_zero_row j H\n 2. \\<not> is_zero_row ia A \\<Longrightarrow> is_zero_row j H", "case True"], ["proof (state)\nthis:\n  is_zero_row ia A\n\ngoal (2 subgoals):\n 1. is_zero_row ia A \\<Longrightarrow> is_zero_row j H\n 2. \\<not> is_zero_row ia A \\<Longrightarrow> is_zero_row j H", "have zero_jA: \"is_zero_row j A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row j A", "by (metis True e echelon_form_condition1 ia_j)"], ["proof (state)\nthis:\n  is_zero_row j A\n\ngoal (2 subgoals):\n 1. is_zero_row ia A \\<Longrightarrow> is_zero_row j H\n 2. \\<not> is_zero_row ia A \\<Longrightarrow> is_zero_row j H", "have ij: \"i<j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j", "by (metis e echelon_form_condition1 neq_iff not_zero_iA zero_jA)"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. is_zero_row ia A \\<Longrightarrow> is_zero_row j H\n 2. \\<not> is_zero_row ia A \\<Longrightarrow> is_zero_row j H", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row j H", "proof (auto simp add: is_zero_row_def is_zero_row_upt_k_def ncols_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. H $ j $ a = (0::'a)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. H $ j $ a = (0::'a)", "have \"H $ j $ a = M $ j $ a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ j $ a = M $ j $ a", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above M (mod_type_class.to_nat i) i\n     (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    j $\n    a =\n    M $ j $ a", "by (rule Hermite_reduce_above_preserves) (metis dual_order.strict_iff_order ij to_nat_mono')"], ["proof (state)\nthis:\n  H $ j $ a = M $ j $ a\n\ngoal (1 subgoal):\n 1. \\<And>a. H $ j $ a = (0::'a)", "also"], ["proof (state)\nthis:\n  H $ j $ a = M $ j $ a\n\ngoal (1 subgoal):\n 1. \\<And>a. H $ j $ a = (0::'a)", "have \"... = A $ j $ a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M $ j $ a = A $ j $ a", "unfolding M mult_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    j $\n    a =\n    A $ j $ a", "using ij"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    j $\n    a =\n    A $ j $ a", "by auto"], ["proof (state)\nthis:\n  M $ j $ a = A $ j $ a\n\ngoal (1 subgoal):\n 1. \\<And>a. H $ j $ a = (0::'a)", "also"], ["proof (state)\nthis:\n  M $ j $ a = A $ j $ a\n\ngoal (1 subgoal):\n 1. \\<And>a. H $ j $ a = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ a = (0::'a)", "using zero_jA"], ["proof (prove)\nusing this:\n  is_zero_row j A\n\ngoal (1 subgoal):\n 1. A $ j $ a = (0::'a)", "by (simp add: is_zero_row_def is_zero_row_upt_k_def ncols_def)"], ["proof (state)\nthis:\n  A $ j $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a. H $ j $ a = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  H $ j $ a = (0::'a)", "show \"H $ j $ a = 0\""], ["proof (prove)\nusing this:\n  H $ j $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. H $ j $ a = (0::'a)", "."], ["proof (state)\nthis:\n  H $ j $ a = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row j H\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A \\<Longrightarrow> is_zero_row j H", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A \\<Longrightarrow> is_zero_row j H", "case False"], ["proof (state)\nthis:\n  \\<not> is_zero_row ia A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A \\<Longrightarrow> is_zero_row j H", "note not_zero_ia_A=False"], ["proof (state)\nthis:\n  \\<not> is_zero_row ia A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A \\<Longrightarrow> is_zero_row j H", "let ?n=\"(LEAST n. A $ ia $ n \\<noteq> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A \\<Longrightarrow> is_zero_row j H", "have A_ia_n: \"A $ ia $ ?n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags, lifting) LeastI is_zero_row_def is_zero_row_upt_k_def not_zero_ia_A)"], ["proof (state)\nthis:\n  A $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A \\<Longrightarrow> is_zero_row j H", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row j H", "proof (cases \"i \\<le> ia\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> ia \\<Longrightarrow> is_zero_row j H\n 2. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "case True"], ["proof (state)\nthis:\n  i \\<le> ia\n\ngoal (2 subgoals):\n 1. i \\<le> ia \\<Longrightarrow> is_zero_row j H\n 2. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "have \"H $ ia $ ?n = M $ ia $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n    M $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above M (mod_type_class.to_nat i) i\n     (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n    M $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "by (rule Hermite_reduce_above_preserves, simp add: True to_nat_mono')"], ["proof (state)\nthis:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n  M $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. i \\<le> ia \\<Longrightarrow> is_zero_row j H\n 2. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "also"], ["proof (state)\nthis:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n  M $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. i \\<le> ia \\<Longrightarrow> is_zero_row j H\n 2. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "unfolding M mult_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using A_ia_n ass_function_0'[OF a]"], ["proof (prove)\nusing this:\n  A $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n  (ass ?x div ?x = (0::'a)) = (?x = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  M $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. i \\<le> ia \\<Longrightarrow> is_zero_row j H\n 2. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "finally"], ["proof (chain)\npicking this:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "have \"H $ ia $ ?n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. i \\<le> ia \\<Longrightarrow> is_zero_row j H\n 2. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "hence not_zero_ia_H: \"\\<not> is_zero_row ia H\""], ["proof (prove)\nusing this:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia H", "unfolding is_zero_row_def is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < CARD('b) \\<longrightarrow>\n               H $ ia $ j = (0::'a))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row ia H\n\ngoal (2 subgoals):\n 1. i \\<le> ia \\<Longrightarrow> is_zero_row j H\n 2. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row ia H\n\ngoal (1 subgoal):\n 1. is_zero_row j H", "using zero_ia_H"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row ia H\n  is_zero_row ia H\n\ngoal (1 subgoal):\n 1. is_zero_row j H", "by contradiction"], ["proof (state)\nthis:\n  is_zero_row j H\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "case False"], ["proof (state)\nthis:\n  \\<not> i \\<le> ia\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "let ?m=\"(LEAST m. A $ i $ m \\<noteq> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "let ?R=\"row_add M ia i ((res (M $ i $ ?m) (M $ ia $ ?m) - M $ ia $ ?m) div M $ i $ ?m)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "have ia_less_i: \"ia<i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia < i", "by (metis False not_less)"], ["proof (state)\nthis:\n  ia < i\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "have nm: \"?n<?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n    < (LEAST m. A $ i $ m \\<noteq> (0::'a))", "by (rule echelon_form_condition2_explicit[OF e ia_less_i not_zero_ia_A not_zero_iA])"], ["proof (state)\nthis:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST m. A $ i $ m \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "have A_im: \"A $ i $ ?n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) = (0::'a)", "by (metis (full_types) nm not_less_Least)"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "have \"H $ ia $ ?n = ?R $ ia $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n    row_add M ia i\n     ((res (M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a)))\n        (M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) -\n       M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) div\n      M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above M (mod_type_class.to_nat i) i\n     (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n    row_add M ia i\n     ((res (M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a)))\n        (M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) -\n       M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) div\n      M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "by (rule Hermite_reduce_above_works, auto simp add: ia_less_i to_nat_mono)"], ["proof (state)\nthis:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n  row_add M ia i\n   ((res (M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a)))\n      (M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) -\n     M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) div\n    M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) $\n  ia $\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "also"], ["proof (state)\nthis:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n  row_add M ia i\n   ((res (M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a)))\n      (M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) -\n     M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) div\n    M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) $\n  ia $\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add M ia i\n     ((res (M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a)))\n        (M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) -\n       M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) div\n      M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using ia_less_i A_im A_ia_n"], ["proof (prove)\nusing this:\n  ia < i\n  A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) = (0::'a)\n  A $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. row_add M ia i\n     ((res (M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a)))\n        (M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) -\n       M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) div\n      M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "unfolding row_add_def M mult_row_def"], ["proof (prove)\nusing this:\n  ia < i\n  A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) = (0::'a)\n  A $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<chi>ib j.\n        if ib = ia\n        then (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             ia $\n             j +\n             (res ((\\<chi>ia j.\n                       if ia = i\n                       then ass (A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                            A $ i $ j\n                       else A $ ia $ j) $\n                   i $\n                   (LEAST m. A $ i $ m \\<noteq> (0::'a)))\n               ((\\<chi>ia j.\n                    if ia = i\n                    then ass (A $ i $\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                         A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                         A $ i $ j\n                    else A $ ia $ j) $\n                ia $\n                (LEAST m. A $ i $ m \\<noteq> (0::'a))) -\n              (\\<chi>ia j.\n                  if ia = i\n                  then ass (A $ i $\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                       A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                       A $ i $ j\n                  else A $ ia $ j) $\n              ia $\n              (LEAST m. A $ i $ m \\<noteq> (0::'a))) div\n             (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             i $\n             (LEAST m. A $ i $ m \\<noteq> (0::'a)) *\n             (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             i $\n             j\n        else (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             ib $\n             j) $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  row_add M ia i\n   ((res (M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a)))\n      (M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) -\n     M $ ia $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) div\n    M $ i $ (LEAST m. A $ i $ m \\<noteq> (0::'a))) $\n  ia $\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "finally"], ["proof (chain)\npicking this:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "have \"H $ ia $ ?n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "hence not_zero_ia_H: \"\\<not> is_zero_row ia H\""], ["proof (prove)\nusing this:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia H", "unfolding is_zero_row_def is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < CARD('b) \\<longrightarrow>\n               H $ ia $ j = (0::'a))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row ia H\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> ia \\<Longrightarrow> is_zero_row j H", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row ia H\n\ngoal (1 subgoal):\n 1. is_zero_row j H", "using zero_ia_H"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row ia H\n  is_zero_row ia H\n\ngoal (1 subgoal):\n 1. is_zero_row j H", "by contradiction"], ["proof (state)\nthis:\n  is_zero_row j H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row j H\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma row_zero_A_imp_row_zero_H:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes e: \"echelon_form A\"\n  and not_zero_iA: \"\\<not> is_zero_row i A\"\n  and zero_j_A: \"is_zero_row j A\"\n  shows \"is_zero_row j H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row j H", "proof (auto simp add: is_zero_row_def is_zero_row_upt_k_def ncols_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. H $ j $ a = (0::'a)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. H $ j $ a = (0::'a)", "have A_ja: \"A $ j $ a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ a = (0::'a)", "using zero_j_A"], ["proof (prove)\nusing this:\n  is_zero_row j A\n\ngoal (1 subgoal):\n 1. A $ j $ a = (0::'a)", "by (simp add: is_zero_row_def is_zero_row_upt_k_def ncols_def)"], ["proof (state)\nthis:\n  A $ j $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a. H $ j $ a = (0::'a)", "show \"H $ j $ a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ j $ a = (0::'a)", "proof (cases \"i\\<le>j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)\n 2. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "case True"], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)\n 2. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "have \"H $ j $ a = M $ j $ a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ j $ a = M $ j $ a", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above M (mod_type_class.to_nat i) i\n     (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    j $\n    a =\n    M $ j $ a", "by (rule Hermite_reduce_above_preserves, simp add: True to_nat_mono')"], ["proof (state)\nthis:\n  H $ j $ a = M $ j $ a\n\ngoal (2 subgoals):\n 1. i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)\n 2. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "also"], ["proof (state)\nthis:\n  H $ j $ a = M $ j $ a\n\ngoal (2 subgoals):\n 1. i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)\n 2. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M $ j $ a = (0::'a)", "unfolding M mult_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    j $\n    a =\n    (0::'a)", "using True A_ja"], ["proof (prove)\nusing this:\n  i \\<le> j\n  A $ j $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    j $\n    a =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  M $ j $ a = (0::'a)\n\ngoal (2 subgoals):\n 1. i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)\n 2. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  H $ j $ a = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  H $ j $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. H $ j $ a = (0::'a)", "."], ["proof (state)\nthis:\n  H $ j $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "let ?n=\"(LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "let ?R=\"row_add M j i ((res (M $ i $ ?n) (M $ j $ ?n) - M $ j $ ?n) div M $ i $ ?n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "hence ji: \"j<i\""], ["proof (prove)\nusing this:\n  \\<not> i \\<le> j\n\ngoal (1 subgoal):\n 1. j < i", "by simp"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "have \"H $ j $ a = ?R $ j $ a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ j $ a =\n    row_add M j i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    j $\n    a", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above M (mod_type_class.to_nat i) i\n     (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    j $\n    a =\n    row_add M j i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    j $\n    a", "by (rule Hermite_reduce_above_works, auto simp add: ji to_nat_mono)"], ["proof (state)\nthis:\n  H $ j $ a =\n  row_add M j i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  j $\n  a\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "also"], ["proof (state)\nthis:\n  H $ j $ a =\n  row_add M j i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  j $\n  a\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add M j i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    j $\n    a =\n    (0::'a)", "using ji A_ja not_zero_iA e echelon_form_condition1 zero_j_A"], ["proof (prove)\nusing this:\n  j < i\n  A $ j $ a = (0::'a)\n  \\<not> is_zero_row i A\n  echelon_form A\n  echelon_form ?A \\<Longrightarrow>\n  \\<forall>i.\n     is_zero_row i ?A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row j ?A)\n  is_zero_row j A\n\ngoal (1 subgoal):\n 1. row_add M j i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    j $\n    a =\n    (0::'a)", "unfolding row_add_def M mult_row_def"], ["proof (prove)\nusing this:\n  j < i\n  A $ j $ a = (0::'a)\n  \\<not> is_zero_row i A\n  echelon_form A\n  echelon_form ?A \\<Longrightarrow>\n  \\<forall>i.\n     is_zero_row i ?A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row j ?A)\n  is_zero_row j A\n\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = j\n        then (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             j $\n             ja +\n             (res ((\\<chi>ia j.\n                       if ia = i\n                       then ass (A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                            A $ i $ j\n                       else A $ ia $ j) $\n                   i $\n                   (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n               ((\\<chi>ia j.\n                    if ia = i\n                    then ass (A $ i $\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                         A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                         A $ i $ j\n                    else A $ ia $ j) $\n                j $\n                (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n              (\\<chi>ia j.\n                  if ia = i\n                  then ass (A $ i $\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                       A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                       A $ i $ j\n                  else A $ ia $ j) $\n              j $\n              (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             i $\n             (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             i $\n             ja\n        else (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             ia $\n             ja) $\n    j $\n    a =\n    (0::'a)", "by blast"], ["proof (state)\nthis:\n  row_add M j i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  j $\n  a =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> H $ j $ a = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  H $ j $ a = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  H $ j $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. H $ j $ a = (0::'a)", "."], ["proof (state)\nthis:\n  H $ j $ a = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H $ j $ a = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_reduce_above_Least_eq_le:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes i_ia: \"i<ia\"\n  and not_zero_ia_H: \"\\<not> is_zero_row ia H\"\n  shows \"(LEAST n. A $ ia $ n \\<noteq> 0) = (LEAST n. H $ ia $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "let ?n=\"(LEAST n. H $ ia $ n \\<noteq> 0)\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "have \"A $ ia $ ?n = M $ ia $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    M $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))", "unfolding M mult_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    ia $\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))", "using i_ia"], ["proof (prove)\nusing this:\n  i < ia\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    ia $\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))", "by auto"], ["proof (state)\nthis:\n  A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n  M $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n  M $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "have \"... = H $ ia $ ?n \""], ["proof (prove)\ngoal (1 subgoal):\n 1. M $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    H $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. M $ ia $\n    (LEAST n.\n        Hermite_reduce_above M (mod_type_class.to_nat i) i\n         (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n        ia $\n        n \\<noteq>\n        (0::'a)) =\n    Hermite_reduce_above M (mod_type_class.to_nat i) i\n     (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    ia $\n    (LEAST n.\n        Hermite_reduce_above M (mod_type_class.to_nat i) i\n         (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n        ia $\n        n \\<noteq>\n        (0::'a))", "by (rule Hermite_reduce_above_preserves[symmetric]) \n  (metis i_ia dual_order.strict_iff_order to_nat_mono')"], ["proof (state)\nthis:\n  M $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n  H $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  M $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n  H $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags) LeastI is_zero_row_def' not_zero_ia_H)"], ["proof (state)\nthis:\n  H $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "finally"], ["proof (chain)\npicking this:\n  A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "show \"A $ ia $ (LEAST n. H $ ia $ n \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "assume A_ia_y: \"A $ ia $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  A $ ia $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "have \"H $ ia $ y = M $ ia $ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ ia $ y = M $ ia $ y", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above M (mod_type_class.to_nat i) i\n     (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    ia $\n    y =\n    M $ ia $ y", "by (rule Hermite_reduce_above_preserves) \n  (metis i_ia dual_order.strict_iff_order to_nat_mono')"], ["proof (state)\nthis:\n  H $ ia $ y = M $ ia $ y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  H $ ia $ y = M $ ia $ y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M $ ia $ y \\<noteq> (0::'a)", "unfolding M mult_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    ia $\n    y \\<noteq>\n    (0::'a)", "using i_ia A_ia_y"], ["proof (prove)\nusing this:\n  i < ia\n  A $ ia $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    ia $\n    y \\<noteq>\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  M $ ia $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ ia $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "finally"], ["proof (chain)\npicking this:\n  H $ ia $ y \\<noteq> (0::'a)", "show \"(LEAST n. H $ ia $ n \\<noteq> 0) \\<le> y\""], ["proof (prove)\nusing this:\n  H $ ia $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y", "by (rule Least_le)"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_reduce_above_Least_eq:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes a: \"ass_function ass\"\n  and not_zero_iA: \"\\<not> is_zero_row i A\"\n  shows \"(LEAST n. A $ i $ n \\<noteq> 0) = (LEAST n. H $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    (LEAST n. H $ i $ n \\<noteq> (0::'a))", "proof (rule Least_equality[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. H $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       H $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "let ?n=\"(LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (state)\ngoal (2 subgoals):\n 1. H $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       H $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "have Ain: \"A $ i $ ?n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags, lifting) LeastI is_zero_row_def' not_zero_iA)"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. H $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       H $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "have \"H $ i $ ?n = M $ i $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above M (mod_type_class.to_nat i) i\n     (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", "by (rule Hermite_reduce_above_preserves, simp)"], ["proof (state)\nthis:\n  H $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. H $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       H $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "also"], ["proof (state)\nthis:\n  H $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. H $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       H $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "unfolding M mult_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "by (auto simp add: Ain ass_function_0'[OF a])"], ["proof (state)\nthis:\n  M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. H $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n 2. \\<And>y.\n       H $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "finally"], ["proof (chain)\npicking this:\n  H $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "show \"H $ i $ ?n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  H $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. H $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  H $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       H $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       H $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "assume H_iy: \"H $ i $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  H $ i $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       H $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "show \"(LEAST n. A $ i $ n \\<noteq> 0) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "proof (rule Least_le, rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ i $ y = (0::'a) \\<Longrightarrow> False", "assume Aiy: \"A $ i $ y = 0\""], ["proof (state)\nthis:\n  A $ i $ y = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ y = (0::'a) \\<Longrightarrow> False", "have \"H $ i $ y = M $ i $ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ y = M $ i $ y", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above M (mod_type_class.to_nat i) i\n     (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    y =\n    M $ i $ y", "by (rule Hermite_reduce_above_preserves, simp)"], ["proof (state)\nthis:\n  H $ i $ y = M $ i $ y\n\ngoal (1 subgoal):\n 1. A $ i $ y = (0::'a) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  H $ i $ y = M $ i $ y\n\ngoal (1 subgoal):\n 1. A $ i $ y = (0::'a) \\<Longrightarrow> False", "have \"... = (ass (A $ i $ ?n) div A $ i $ ?n) * A $ i $ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M $ i $ y =\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    A $ i $ y", "unfolding M mult_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    i $\n    y =\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    A $ i $ y", "by auto"], ["proof (state)\nthis:\n  M $ i $ y =\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  A $ i $ y\n\ngoal (1 subgoal):\n 1. A $ i $ y = (0::'a) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  M $ i $ y =\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  A $ i $ y\n\ngoal (1 subgoal):\n 1. A $ i $ y = (0::'a) \\<Longrightarrow> False", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    A $ i $ y =\n    (0::'a)", "unfolding Aiy"], ["proof (prove)\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    (0::'a) =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  A $ i $ y =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ y = (0::'a) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  H $ i $ y = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  H $ i $ y = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using H_iy"], ["proof (prove)\nusing this:\n  H $ i $ y = (0::'a)\n  H $ i $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_reduce_above_Least_eq_ge:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes e: \"echelon_form A\"\n  and not_zero_iA: \"\\<not> is_zero_row i A\"\n  and not_zero_ia_A: \"\\<not> is_zero_row ia A\"\n  and not_zero_ia_H: \"\\<not> is_zero_row ia H\"\n  and ia_less_i: \"ia < i\"\n  shows \"(LEAST n. H $ ia $ n \\<noteq> 0) = (LEAST n. A $ ia $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "let ?least_H = \"(LEAST n. H $ ia $ n \\<noteq> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "let ?least_A = \"(LEAST n. A $ ia $ n \\<noteq> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "let ?n= \"(LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "let ?Ain =\"A $ i $ ?n\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "let ?R=\"row_add M ia i ((res (M $ i $ ?n) (M $ ia $ ?n) - M $ ia $ ?n) div M $ i $ ?n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "have A_ia_least_A: \"A $ ia $ ?least_A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags, lifting) LeastI is_zero_row_def' not_zero_ia_A)"], ["proof (state)\nthis:\n  A $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "have H_ia_least_H: \"H $ ia $ ?least_H \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags, lifting) LeastI is_zero_row_def' not_zero_ia_H)"], ["proof (state)\nthis:\n  H $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "have A_i_least_ia_0: \"A $ i $ (LEAST n. A $ ia $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) = (0::'a)", "have \"(LEAST n. A $ ia $ n \\<noteq> 0) < (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ i $ n \\<noteq> (0::'a))", "using e echelon_form_condition1 echelon_form_condition2_explicit \n        ia_less_i not_zero_iA"], ["proof (prove)\nusing this:\n  echelon_form A\n  echelon_form ?A \\<Longrightarrow>\n  \\<forall>i.\n     is_zero_row i ?A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row j ?A)\n  \\<lbrakk>echelon_form ?A; ?i < ?j; \\<not> is_zero_row ?i ?A;\n   \\<not> is_zero_row ?j ?A\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. ?A $ ?i $ n \\<noteq> (0::?'a))\n                    < (LEAST n. ?A $ ?j $ n \\<noteq> (0::?'a))\n  ia < i\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ i $ n \\<noteq> (0::'a))", "by blast"], ["proof (state)\nthis:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) = (0::'a)", "using not_less_Least"], ["proof (prove)\nusing this:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  ?k < (LEAST x. ?P x) \\<Longrightarrow> \\<not> ?P ?k\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "have H_ia_least_A: \"H $ ia $ ?least_A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "have \"H $ ia $ ?least_A = ?R $ ia $ ?least_A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n    row_add M ia i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above M (mod_type_class.to_nat i) i\n     (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n    row_add M ia i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "by (rule Hermite_reduce_above_works, simp_all add: ia_less_i to_nat_mono)"], ["proof (state)\nthis:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n  row_add M ia i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  ia $\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "also"], ["proof (state)\nthis:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n  row_add M ia i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  ia $\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add M ia i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using ia_less_i"], ["proof (prove)\nusing this:\n  ia < i\n\ngoal (1 subgoal):\n 1. row_add M ia i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "unfolding row_add_def M mult_row_def"], ["proof (prove)\nusing this:\n  ia < i\n\ngoal (1 subgoal):\n 1. (\\<chi>ib j.\n        if ib = ia\n        then (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             ia $\n             j +\n             (res ((\\<chi>ia j.\n                       if ia = i\n                       then ass (A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                            A $ i $ j\n                       else A $ ia $ j) $\n                   i $\n                   (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n               ((\\<chi>ia j.\n                    if ia = i\n                    then ass (A $ i $\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                         A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                         A $ i $ j\n                    else A $ ia $ j) $\n                ia $\n                (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n              (\\<chi>ia j.\n                  if ia = i\n                  then ass (A $ i $\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                       A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                       A $ i $ j\n                  else A $ ia $ j) $\n              ia $\n              (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             i $\n             (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             i $\n             j\n        else (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             ib $\n             j) $\n    ia $\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "by (auto simp add: A_i_least_ia_0 A_ia_least_A)"], ["proof (state)\nthis:\n  row_add M ia i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  ia $\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "finally"], ["proof (chain)\npicking this:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "hence least_H_le_least_A: \"?least_H \\<le> ?least_A\""], ["proof (prove)\nusing this:\n  H $ ia $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    \\<le> (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "by (metis (mono_tags) not_less not_less_Least)"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  \\<le> (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "have A_i_least_H: \"A $ i $ ?least_H = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) = (0::'a)", "have \"(LEAST n. A $ ia $ n \\<noteq> 0) < (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ i $ n \\<noteq> (0::'a))", "using e echelon_form_condition1 echelon_form_condition2_explicit \n        ia_less_i not_zero_iA"], ["proof (prove)\nusing this:\n  echelon_form A\n  echelon_form ?A \\<Longrightarrow>\n  \\<forall>i.\n     is_zero_row i ?A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row j ?A)\n  \\<lbrakk>echelon_form ?A; ?i < ?j; \\<not> is_zero_row ?i ?A;\n   \\<not> is_zero_row ?j ?A\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. ?A $ ?i $ n \\<noteq> (0::?'a))\n                    < (LEAST n. ?A $ ?j $ n \\<noteq> (0::?'a))\n  ia < i\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ i $ n \\<noteq> (0::'a))", "by blast"], ["proof (state)\nthis:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) = (0::'a)", "using not_less_Least least_H_le_least_A"], ["proof (prove)\nusing this:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  ?k < (LEAST x. ?P x) \\<Longrightarrow> \\<not> ?P ?k\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  \\<le> (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) = (0::'a)", "by (metis (mono_tags) dual_order.strict_trans2)"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "have \"A $ ia $ ?least_H \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "have ia_not_i: \"ia \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia \\<noteq> i", "using ia_less_i"], ["proof (prove)\nusing this:\n  ia < i\n\ngoal (1 subgoal):\n 1. ia \\<noteq> i", "by simp"], ["proof (state)\nthis:\n  ia \\<noteq> i\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "have \"?R $ ia $ ?least_H = H $ ia $ ?least_H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add M ia i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    ia $\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    H $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add M ia i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    ia $\n    (LEAST n.\n        Hermite_reduce_above M (mod_type_class.to_nat i) i\n         (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n        ia $\n        n \\<noteq>\n        (0::'a)) =\n    Hermite_reduce_above M (mod_type_class.to_nat i) i\n     (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    ia $\n    (LEAST n.\n        Hermite_reduce_above M (mod_type_class.to_nat i) i\n         (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n        ia $\n        n \\<noteq>\n        (0::'a))", "by (rule Hermite_reduce_above_works[symmetric], simp_all add: ia_less_i to_nat_mono)"], ["proof (state)\nthis:\n  row_add M ia i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  ia $\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n  H $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "also"], ["proof (state)\nthis:\n  row_add M ia i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  ia $\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n  H $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (rule H_ia_least_H)"], ["proof (state)\nthis:\n  H $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "finally"], ["proof (chain)\npicking this:\n  row_add M ia i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  ia $\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)", "have R_ia_least_H: \"?R $ ia $ ?least_H \\<noteq> 0\""], ["proof (prove)\nusing this:\n  row_add M ia i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  ia $\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. row_add M ia i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    ia $\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "."], ["proof (state)\nthis:\n  row_add M ia i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  ia $\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "hence \"A $ ia $ ?least_H + (res (ass (?Ain) div ?Ain * ?Ain) \n      (A $ ia $ (LEAST n. A $ i $ n \\<noteq> 0)) - A $ ia $ (LEAST n. A $ i $ n \\<noteq> 0)) \n      div (ass (?Ain) div ?Ain * ?Ain) * (ass (?Ain) div ?Ain * A $ i $ ?least_H) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  row_add M ia i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  ia $\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) +\n    (res (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n     A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))) \\<noteq>\n    (0::'a)", "using ia_not_i"], ["proof (prove)\nusing this:\n  row_add M ia i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  ia $\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n  ia \\<noteq> i\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) +\n    (res (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n     A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))) \\<noteq>\n    (0::'a)", "unfolding row_add_def M mult_row_def"], ["proof (prove)\nusing this:\n  (\\<chi>ib j.\n      if ib = ia\n      then (\\<chi>ia j.\n               if ia = i\n               then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                    A $ i $ j\n               else A $ ia $ j) $\n           ia $\n           j +\n           (res ((\\<chi>ia j.\n                     if ia = i\n                     then ass (A $ i $\n                               (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                          A $ i $ j\n                     else A $ ia $ j) $\n                 i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n             ((\\<chi>ia j.\n                  if ia = i\n                  then ass (A $ i $\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                       A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                       A $ i $ j\n                  else A $ ia $ j) $\n              ia $\n              (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n            (\\<chi>ia j.\n                if ia = i\n                then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                     A $ i $ j\n                else A $ ia $ j) $\n            ia $\n            (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           (\\<chi>ia j.\n               if ia = i\n               then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                    A $ i $ j\n               else A $ ia $ j) $\n           i $\n           (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n           (\\<chi>ia j.\n               if ia = i\n               then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                    A $ i $ j\n               else A $ ia $ j) $\n           i $\n           j\n      else (\\<chi>ia j.\n               if ia = i\n               then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                    A $ i $ j\n               else A $ ia $ j) $\n           ib $\n           j) $\n  ia $\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n  ia \\<noteq> i\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) +\n    (res (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n     A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))) \\<noteq>\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) +\n  (res (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n    (A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n   A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n  (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n   A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) +\n  (res (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n    (A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n   A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n  (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n   A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "using ia_less_i A_i_least_H"], ["proof (prove)\nusing this:\n  A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) +\n  (res (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n    (A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n   A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n  (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n   A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))) \\<noteq>\n  (0::'a)\n  ia < i\n  A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "unfolding row_add_def M mult_row_def"], ["proof (prove)\nusing this:\n  A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) +\n  (res (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n    (A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n   A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n  (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n   A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a))) \\<noteq>\n  (0::'a)\n  ia < i\n  A $ i $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "hence least_A_le_least_H: \"?least_A \\<le> ?least_H\""], ["proof (prove)\nusing this:\n  A $ ia $ (LEAST n. H $ ia $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n    \\<le> (LEAST n. H $ ia $ n \\<noteq> (0::'a))", "by (metis (poly_guards_query) Least_le)"], ["proof (state)\nthis:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  \\<le> (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "using least_A_le_least_H least_H_le_least_A"], ["proof (prove)\nusing this:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  \\<le> (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  \\<le> (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_reduce_above_Least:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) \n  div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and not_zero_iA: \"\\<not> is_zero_row i A\"\n  and not_zero_ia_A: \"\\<not> is_zero_row ia A\"\n  and not_zero_ia_H: \"\\<not> is_zero_row ia H\"\n  shows \"(LEAST n. H $ ia $ n \\<noteq> 0) = (LEAST n. A $ ia $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "proof (cases \"ia<i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ia < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n 2. \\<not> ia < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "case True"], ["proof (state)\nthis:\n  ia < i\n\ngoal (2 subgoals):\n 1. ia < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n 2. \\<not> ia < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "unfolding H M"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        ia $\n        n \\<noteq>\n        (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "by (rule Hermite_reduce_above_Least_eq_ge[OF e not_zero_iA not_zero_ia_A _ True]) \n       (metis H M not_zero_ia_H)"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "case False"], ["proof (state)\nthis:\n  \\<not> ia < i\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "hence i_le_ia: \"i\\<le>ia\""], ["proof (prove)\nusing this:\n  \\<not> ia < i\n\ngoal (1 subgoal):\n 1. i \\<le> ia", "by simp"], ["proof (state)\nthis:\n  i \\<le> ia\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "proof (cases \"ia=i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ia = i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n 2. ia \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "case True"], ["proof (state)\nthis:\n  ia = i\n\ngoal (2 subgoals):\n 1. ia = i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n 2. ia \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "unfolding True H M"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'a))", "by (rule Hermite_reduce_above_Least_eq[symmetric, OF a not_zero_iA])"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. ia \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ia \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "case False"], ["proof (state)\nthis:\n  ia \\<noteq> i\n\ngoal (1 subgoal):\n 1. ia \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "hence i_ia: \"i<ia\""], ["proof (prove)\nusing this:\n  ia \\<noteq> i\n\ngoal (1 subgoal):\n 1. i < ia", "using i_le_ia"], ["proof (prove)\nusing this:\n  ia \\<noteq> i\n  i \\<le> ia\n\ngoal (1 subgoal):\n 1. i < ia", "by simp"], ["proof (state)\nthis:\n  i < ia\n\ngoal (1 subgoal):\n 1. ia \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "unfolding H M"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        ia $\n        n \\<noteq>\n        (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "by (rule Hermite_reduce_above_Least_eq_le[symmetric, OF i_ia], metis H M not_zero_ia_H)"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_form_Hermite_of_condition2:\n  fixes res ass i A\n  defines M: \"M \\<equiv> mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\"\n  defines H: \"H \\<equiv> Hermite_reduce_above M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\"\n  assumes e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and not_zero_iA: \"\\<not> is_zero_row i A\"\n  and ia_less_j: \"ia < j\"\n  and not_zero_ia_H: \"\\<not> is_zero_row ia H\"\n  and not_zero_j_H: \"\\<not> is_zero_row j H\"\n  shows \"(LEAST n. H $ ia $ n \\<noteq> 0) < (LEAST n. H $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "let ?n= \"(LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "have Ain: \"A $ i $ ?n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags) LeastI is_zero_row_def' not_zero_iA)"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "have not_zero_j_A: \"\\<not> is_zero_row j A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row j A", "using row_zero_A_imp_row_zero_H[OF e not_zero_iA] not_zero_j_H"], ["proof (prove)\nusing this:\n  is_zero_row ?j A \\<Longrightarrow>\n  is_zero_row ?j\n   (Hermite_reduce_above\n     (mult_row A i\n       (?ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) ?res)\n  \\<not> is_zero_row j H\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row j A", "unfolding H M"], ["proof (prove)\nusing this:\n  is_zero_row ?j A \\<Longrightarrow>\n  is_zero_row ?j\n   (Hermite_reduce_above\n     (mult_row A i\n       (?ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) ?res)\n  \\<not> is_zero_row j\n          (Hermite_reduce_above\n            (mult_row A i\n              (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n               A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n            (mod_type_class.to_nat i) i\n            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row j A", "by blast"], ["proof (state)\nthis:\n  \\<not> is_zero_row j A\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "have not_zero_ia_A: \"\\<not> is_zero_row ia A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A", "using row_zero_A_imp_row_zero_H[OF e not_zero_iA] not_zero_ia_H"], ["proof (prove)\nusing this:\n  is_zero_row ?j A \\<Longrightarrow>\n  is_zero_row ?j\n   (Hermite_reduce_above\n     (mult_row A i\n       (?ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) ?res)\n  \\<not> is_zero_row ia H\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A", "unfolding H M"], ["proof (prove)\nusing this:\n  is_zero_row ?j A \\<Longrightarrow>\n  is_zero_row ?j\n   (Hermite_reduce_above\n     (mult_row A i\n       (?ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) ?res)\n  \\<not> is_zero_row ia\n          (Hermite_reduce_above\n            (mult_row A i\n              (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n               A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n            (mod_type_class.to_nat i) i\n            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row ia A", "by blast"], ["proof (state)\nthis:\n  \\<not> is_zero_row ia A\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "have Least_le_A: \"(LEAST n. A $ ia $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by (rule echelon_form_condition2_explicit[OF e ia_less_j not_zero_ia_A not_zero_j_A])"], ["proof (state)\nthis:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "proof (cases \"i<ia\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. \\<not> i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "case True"], ["proof (state)\nthis:\n  i < ia\n\ngoal (2 subgoals):\n 1. i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. \\<not> i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "have ij: \"i<j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j", "by (metis True ia_less_j less_trans)"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. \\<not> i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "have Least_A_ia_H_ia: \"(LEAST n. A $ ia $ n \\<noteq> 0) = (LEAST n. H $ ia $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))", "unfolding H M"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        ia $\n        n \\<noteq>\n        (0::'a))", "by (rule Hermite_reduce_above_Least_eq_le[OF True], metis H M not_zero_ia_H)"], ["proof (state)\nthis:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. \\<not> i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "moreover"], ["proof (state)\nthis:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. \\<not> i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "have Least_A_ia_H_ia: \"(LEAST n. A $ j $ n \\<noteq> 0) = (LEAST n. H $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ j $ n \\<noteq> (0::'a)) =\n    (LEAST n. H $ j $ n \\<noteq> (0::'a))", "unfolding H M"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ j $ n \\<noteq> (0::'a)) =\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        j $\n        n \\<noteq>\n        (0::'a))", "by (rule Hermite_reduce_above_Least_eq_le[OF ij], metis H M not_zero_j_H)"], ["proof (state)\nthis:\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. H $ j $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. \\<not> i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "ultimately"], ["proof (chain)\npicking this:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. H $ j $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. H $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "using Least_le_A"], ["proof (prove)\nusing this:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a)) =\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  (LEAST n. A $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. H $ j $ n \\<noteq> (0::'a))\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "case False"], ["proof (state)\nthis:\n  \\<not> i < ia\n\ngoal (1 subgoal):\n 1. \\<not> i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "hence ia_le_i: \"ia\\<le>i\""], ["proof (prove)\nusing this:\n  \\<not> i < ia\n\ngoal (1 subgoal):\n 1. ia \\<le> i", "by simp"], ["proof (state)\nthis:\n  ia \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> i < ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "proof (cases \"i=ia\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. i \\<noteq> ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "case True"], ["proof (state)\nthis:\n  i = ia\n\ngoal (2 subgoals):\n 1. i = ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. i \\<noteq> ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = ia\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "using Hermite_reduce_above_Least_eq[OF a not_zero_iA] Least_le_A"], ["proof (prove)\nusing this:\n  i = ia\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       ?res $\n      i $\n      n \\<noteq>\n      (0::'a))\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "using Hermite_reduce_above_Least_eq_le[OF ia_less_j]"], ["proof (prove)\nusing this:\n  i = ia\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       ?res $\n      i $\n      n \\<noteq>\n      (0::'a))\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n  \\<not> is_zero_row j\n          (Hermite_reduce_above\n            (mult_row ?A ia\n              (?ass (?A $ ia $ (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a))) div\n               ?A $ ia $ (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a))))\n            (mod_type_class.to_nat ia) ia\n            (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a)) ?res) \\<Longrightarrow>\n  (LEAST n. ?A $ j $ n \\<noteq> (0::?'a)) =\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row ?A ia\n         (?ass (?A $ ia $ (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a))) div\n          ?A $ ia $ (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a))))\n       (mod_type_class.to_nat ia) ia\n       (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a)) ?res $\n      j $\n      n \\<noteq>\n      (0::?'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "using not_zero_j_H"], ["proof (prove)\nusing this:\n  i = ia\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       ?res $\n      i $\n      n \\<noteq>\n      (0::'a))\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n  \\<not> is_zero_row j\n          (Hermite_reduce_above\n            (mult_row ?A ia\n              (?ass (?A $ ia $ (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a))) div\n               ?A $ ia $ (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a))))\n            (mod_type_class.to_nat ia) ia\n            (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a)) ?res) \\<Longrightarrow>\n  (LEAST n. ?A $ j $ n \\<noteq> (0::?'a)) =\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row ?A ia\n         (?ass (?A $ ia $ (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a))) div\n          ?A $ ia $ (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a))))\n       (mod_type_class.to_nat ia) ia\n       (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a)) ?res $\n      j $\n      n \\<noteq>\n      (0::?'a))\n  \\<not> is_zero_row j H\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "unfolding H M"], ["proof (prove)\nusing this:\n  i = ia\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       ?res $\n      i $\n      n \\<noteq>\n      (0::'a))\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n  \\<not> is_zero_row j\n          (Hermite_reduce_above\n            (mult_row ?A ia\n              (?ass (?A $ ia $ (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a))) div\n               ?A $ ia $ (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a))))\n            (mod_type_class.to_nat ia) ia\n            (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a)) ?res) \\<Longrightarrow>\n  (LEAST n. ?A $ j $ n \\<noteq> (0::?'a)) =\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row ?A ia\n         (?ass (?A $ ia $ (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a))) div\n          ?A $ ia $ (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a))))\n       (mod_type_class.to_nat ia) ia\n       (LEAST n. ?A $ ia $ n \\<noteq> (0::?'a)) ?res $\n      j $\n      n \\<noteq>\n      (0::?'a))\n  \\<not> is_zero_row j\n          (Hermite_reduce_above\n            (mult_row A i\n              (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n               A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n            (mod_type_class.to_nat i) i\n            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        ia $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res $\n          j $\n          n \\<noteq>\n          (0::'a))", "by fastforce"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> ia\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "hence ia_less_i: \"ia<i\""], ["proof (prove)\nusing this:\n  i \\<noteq> ia\n\ngoal (1 subgoal):\n 1. ia < i", "using ia_le_i"], ["proof (prove)\nusing this:\n  i \\<noteq> ia\n  ia \\<le> i\n\ngoal (1 subgoal):\n 1. ia < i", "by simp"], ["proof (state)\nthis:\n  ia < i\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "have Least_H_ia_A_ia: \"(LEAST n. H $ ia $ n \\<noteq> 0) = (LEAST n. A $ ia $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "unfolding H M"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        ia $\n        n \\<noteq>\n        (0::'a)) =\n    (LEAST n. A $ ia $ n \\<noteq> (0::'a))", "by (rule Hermite_reduce_above_Least_eq_ge[OF e not_zero_iA not_zero_ia_A _ ia_less_i]) \n      (metis H M not_zero_ia_H)"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "proof (cases \"j<i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. \\<not> j < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "case True"], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. \\<not> j < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "have \"(LEAST n. H $ j $ n \\<noteq> 0) = (LEAST n. A $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ j $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ j $ n \\<noteq> (0::'a))", "unfolding H M"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        j $\n        n \\<noteq>\n        (0::'a)) =\n    (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by (rule Hermite_reduce_above_Least_eq_ge[OF e not_zero_iA not_zero_j_A _ True])\n        (metis H M not_zero_j_H)"], ["proof (state)\nthis:\n  (LEAST n. H $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. \\<not> j < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. H $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "by (simp add: Least_H_ia_A_ia Least_le_A)"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "case False"], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "hence j_ge_i: \"j\\<ge>i\""], ["proof (prove)\nusing this:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. i \\<le> j", "by auto"], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "proof (cases \"j=i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. j \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "case True"], ["proof (state)\nthis:\n  j = i\n\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. j \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "have \"(LEAST n. H $ j $ n \\<noteq> 0) = (LEAST n. A $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ j $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ j $ n \\<noteq> (0::'a))", "unfolding H M"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        j $\n        n \\<noteq>\n        (0::'a)) =\n    (LEAST n. A $ j $ n \\<noteq> (0::'a))", "using Hermite_reduce_above_Least_eq True a not_zero_iA"], ["proof (prove)\nusing this:\n  \\<lbrakk>ass_function ?ass; \\<not> is_zero_row ?i ?A\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. ?A $ ?i $ n \\<noteq> (0::?'a)) =\n                    (LEAST n.\n                        Hermite_reduce_above\n                         (mult_row ?A ?i\n                           (?ass\n                             (?A $ ?i $\n                              (LEAST n. ?A $ ?i $ n \\<noteq> (0::?'a))) div\n                            ?A $ ?i $\n                            (LEAST n. ?A $ ?i $ n \\<noteq> (0::?'a))))\n                         (mod_type_class.to_nat ?i) ?i\n                         (LEAST n. ?A $ ?i $ n \\<noteq> (0::?'a)) ?res $\n                        ?i $\n                        n \\<noteq>\n                        (0::?'a))\n  j = i\n  ass_function ass\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        j $\n        n \\<noteq>\n        (0::'a)) =\n    (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by fastforce"], ["proof (state)\nthis:\n  (LEAST n. H $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n 2. j \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. H $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "by (simp add: Least_H_ia_A_ia Least_le_A)"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "case False"], ["proof (state)\nthis:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "hence j_sg_i: \"j>i\""], ["proof (prove)\nusing this:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. i < j", "using j_ge_i"], ["proof (prove)\nusing this:\n  j \\<noteq> i\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. i < j", "by simp"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "have \"(LEAST n. H $ j $ n \\<noteq> 0) = (LEAST n. A $ j $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ j $ n \\<noteq> (0::'a)) =\n    (LEAST n. A $ j $ n \\<noteq> (0::'a))", "unfolding H M"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        j $\n        n \\<noteq>\n        (0::'a)) =\n    (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by (rule Hermite_reduce_above_Least_eq_le[symmetric, OF j_sg_i])\n          (metis H M not_zero_j_H)"], ["proof (state)\nthis:\n  (LEAST n. H $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow>\n    (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. H $ j $ n \\<noteq> (0::'a)) =\n  (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. H $ j $ n \\<noteq> (0::'a))", "by (simp add: Least_H_ia_A_ia Least_le_A)"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. H $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. H $ j $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_form_Hermite_of_row:\n  assumes a: \"ass_function ass\"\n  and \"res_function res\"\n  and e: \"echelon_form A\"\n  shows \"echelon_form (Hermite_of_row_i ass res A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (Hermite_of_row_i ass res A i)", "proof (rule echelon_form_intro, auto simp add: Hermite_of_row_i_def Let_def)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>is_zero_row i A; is_zero_row ia A; ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j A\n 2. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A;\n        is_zero_row ia\n         (Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j\n                          (Hermite_reduce_above\n                            (mult_row A i\n                              (ass (A $ i $\n                                    (LEAST n.\n  A $ i $ n \\<noteq> (0::'a))) div\n                               A $ i $\n                               (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                            (mod_type_class.to_nat i) i\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 3. \\<And>ia j.\n       \\<lbrakk>is_zero_row i A; ia < j; \\<not> is_zero_row ia A;\n        \\<not> is_zero_row j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n 4. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "fix ia j"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>is_zero_row i A; is_zero_row ia A; ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j A\n 2. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A;\n        is_zero_row ia\n         (Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j\n                          (Hermite_reduce_above\n                            (mult_row A i\n                              (ass (A $ i $\n                                    (LEAST n.\n  A $ i $ n \\<noteq> (0::'a))) div\n                               A $ i $\n                               (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                            (mod_type_class.to_nat i) i\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 3. \\<And>ia j.\n       \\<lbrakk>is_zero_row i A; ia < j; \\<not> is_zero_row ia A;\n        \\<not> is_zero_row j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n 4. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "assume \"is_zero_row i A\" and \"is_zero_row ia A\" and \"ia < j\""], ["proof (state)\nthis:\n  is_zero_row i A\n  is_zero_row ia A\n  ia < j\n\ngoal (4 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>is_zero_row i A; is_zero_row ia A; ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j A\n 2. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A;\n        is_zero_row ia\n         (Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j\n                          (Hermite_reduce_above\n                            (mult_row A i\n                              (ass (A $ i $\n                                    (LEAST n.\n  A $ i $ n \\<noteq> (0::'a))) div\n                               A $ i $\n                               (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                            (mod_type_class.to_nat i) i\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 3. \\<And>ia j.\n       \\<lbrakk>is_zero_row i A; ia < j; \\<not> is_zero_row ia A;\n        \\<not> is_zero_row j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n 4. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "thus \"is_zero_row j A\""], ["proof (prove)\nusing this:\n  is_zero_row i A\n  is_zero_row ia A\n  ia < j\n\ngoal (1 subgoal):\n 1. is_zero_row j A", "using echelon_form_condition1[OF e]"], ["proof (prove)\nusing this:\n  is_zero_row i A\n  is_zero_row ia A\n  ia < j\n  \\<forall>i.\n     is_zero_row i A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row j A)\n\ngoal (1 subgoal):\n 1. is_zero_row j A", "by blast"], ["proof (state)\nthis:\n  is_zero_row j A\n\ngoal (3 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A;\n        is_zero_row ia\n         (Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j\n                          (Hermite_reduce_above\n                            (mult_row A i\n                              (ass (A $ i $\n                                    (LEAST n.\n  A $ i $ n \\<noteq> (0::'a))) div\n                               A $ i $\n                               (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                            (mod_type_class.to_nat i) i\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 2. \\<And>ia j.\n       \\<lbrakk>is_zero_row i A; ia < j; \\<not> is_zero_row ia A;\n        \\<not> is_zero_row j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n 3. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A;\n        is_zero_row ia\n         (Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j\n                          (Hermite_reduce_above\n                            (mult_row A i\n                              (ass (A $ i $\n                                    (LEAST n.\n  A $ i $ n \\<noteq> (0::'a))) div\n                               A $ i $\n                               (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                            (mod_type_class.to_nat i) i\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 2. \\<And>ia j.\n       \\<lbrakk>is_zero_row i A; ia < j; \\<not> is_zero_row ia A;\n        \\<not> is_zero_row j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n 3. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "fix ia j"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A;\n        is_zero_row ia\n         (Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j\n                          (Hermite_reduce_above\n                            (mult_row A i\n                              (ass (A $ i $\n                                    (LEAST n.\n  A $ i $ n \\<noteq> (0::'a))) div\n                               A $ i $\n                               (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                            (mod_type_class.to_nat i) i\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 2. \\<And>ia j.\n       \\<lbrakk>is_zero_row i A; ia < j; \\<not> is_zero_row ia A;\n        \\<not> is_zero_row j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n 3. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "assume \"is_zero_row i A\" and \"ia < j\" and \"\\<not> is_zero_row ia A\" and \"\\<not> is_zero_row j A\""], ["proof (state)\nthis:\n  is_zero_row i A\n  ia < j\n  \\<not> is_zero_row ia A\n  \\<not> is_zero_row j A\n\ngoal (3 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A;\n        is_zero_row ia\n         (Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j\n                          (Hermite_reduce_above\n                            (mult_row A i\n                              (ass (A $ i $\n                                    (LEAST n.\n  A $ i $ n \\<noteq> (0::'a))) div\n                               A $ i $\n                               (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                            (mod_type_class.to_nat i) i\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 2. \\<And>ia j.\n       \\<lbrakk>is_zero_row i A; ia < j; \\<not> is_zero_row ia A;\n        \\<not> is_zero_row j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n 3. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "thus \"(LEAST n. A $ ia $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  is_zero_row i A\n  ia < j\n  \\<not> is_zero_row ia A\n  \\<not> is_zero_row j A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "using echelon_form_condition2[OF e]"], ["proof (prove)\nusing this:\n  is_zero_row i A\n  ia < j\n  \\<not> is_zero_row ia A\n  \\<not> is_zero_row j A\n  \\<forall>i.\n     i < ?j \\<and>\n     \\<not> is_zero_row i A \\<and> \\<not> is_zero_row ?j A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'a))\n     < (LEAST n. A $ ?j $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by blast"], ["proof (state)\nthis:\n  (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A;\n        is_zero_row ia\n         (Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j\n                          (Hermite_reduce_above\n                            (mult_row A i\n                              (ass (A $ i $\n                                    (LEAST n.\n  A $ i $ n \\<noteq> (0::'a))) div\n                               A $ i $\n                               (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                            (mod_type_class.to_nat i) i\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 2. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A;\n        is_zero_row ia\n         (Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j\n                          (Hermite_reduce_above\n                            (mult_row A i\n                              (ass (A $ i $\n                                    (LEAST n.\n  A $ i $ n \\<noteq> (0::'a))) div\n                               A $ i $\n                               (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                            (mod_type_class.to_nat i) i\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 2. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "fix ia j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A;\n        is_zero_row ia\n         (Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j\n                          (Hermite_reduce_above\n                            (mult_row A i\n                              (ass (A $ i $\n                                    (LEAST n.\n  A $ i $ n \\<noteq> (0::'a))) div\n                               A $ i $\n                               (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                            (mod_type_class.to_nat i) i\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 2. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "assume \"\\<not> is_zero_row i A\"\n    and \"is_zero_row ia (Hermite_reduce_above \n    (mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)))\n    (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res)\"\n    and \"ia < j\""], ["proof (state)\nthis:\n  \\<not> is_zero_row i A\n  is_zero_row ia\n   (Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n  ia < j\n\ngoal (2 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A;\n        is_zero_row ia\n         (Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res);\n        ia < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j\n                          (Hermite_reduce_above\n                            (mult_row A i\n                              (ass (A $ i $\n                                    (LEAST n.\n  A $ i $ n \\<noteq> (0::'a))) div\n                               A $ i $\n                               (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                            (mod_type_class.to_nat i) i\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 2. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "thus \"is_zero_row j (Hermite_reduce_above \n    (mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)))\n    (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res)\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i A\n  is_zero_row ia\n   (Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n  ia < j\n\ngoal (1 subgoal):\n 1. is_zero_row j\n     (Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       res)", "using echelon_form_Hermite_of_condition1[OF e a]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i A\n  is_zero_row ia\n   (Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n  ia < j\n  \\<lbrakk>\\<not> is_zero_row ?i A;\n   is_zero_row ?ia\n    (Hermite_reduce_above\n      (mult_row A ?i\n        (ass (A $ ?i $ (LEAST n. A $ ?i $ n \\<noteq> (0::'a))) div\n         A $ ?i $ (LEAST n. A $ ?i $ n \\<noteq> (0::'a))))\n      (mod_type_class.to_nat ?i) ?i (LEAST n. A $ ?i $ n \\<noteq> (0::'a))\n      ?res);\n   ?ia < ?j\\<rbrakk>\n  \\<Longrightarrow> is_zero_row ?j\n                     (Hermite_reduce_above\n                       (mult_row A ?i\n                         (ass (A $ ?i $\n                               (LEAST n. A $ ?i $ n \\<noteq> (0::'a))) div\n                          A $ ?i $ (LEAST n. A $ ?i $ n \\<noteq> (0::'a))))\n                       (mod_type_class.to_nat ?i) ?i\n                       (LEAST n. A $ ?i $ n \\<noteq> (0::'a)) ?res)\n\ngoal (1 subgoal):\n 1. is_zero_row j\n     (Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       res)", "by blast"], ["proof (state)\nthis:\n  is_zero_row j\n   (Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "fix ia j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "let ?H=\"(Hermite_reduce_above (mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) \n    div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))) (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "assume \"\\<not> is_zero_row i A\"\n    and \"ia < j\"\n    and \"\\<not> is_zero_row ia ?H\"\n    and \"\\<not> is_zero_row j ?H\""], ["proof (state)\nthis:\n  \\<not> is_zero_row i A\n  ia < j\n  \\<not> is_zero_row ia\n          (Hermite_reduce_above\n            (mult_row A i\n              (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n               A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n            (mod_type_class.to_nat i) i\n            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n  \\<not> is_zero_row j\n          (Hermite_reduce_above\n            (mult_row A i\n              (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n               A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n            (mod_type_class.to_nat i) i\n            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>\\<not> is_zero_row i A; ia < j;\n        \\<not> is_zero_row ia\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res);\n        \\<not> is_zero_row j\n                (Hermite_reduce_above\n                  (mult_row A i\n                    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                  (mod_type_class.to_nat i) i\n                  (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_reduce_above\n                              (mult_row A i\n                                (ass (A $ i $\n(LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                 A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                              (mod_type_class.to_nat i) i\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                             ia $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Hermite_reduce_above\n                                (mult_row A i\n                                  (ass (A $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                                   A $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n                                (mod_type_class.to_nat i) i\n                                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n                               j $\n                               n \\<noteq>\n                               (0::'a))", "thus \"(LEAST n. ?H $ ia $ n \\<noteq> 0) < (LEAST n. ?H $ j $ n \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i A\n  ia < j\n  \\<not> is_zero_row ia\n          (Hermite_reduce_above\n            (mult_row A i\n              (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n               A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n            (mod_type_class.to_nat i) i\n            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n  \\<not> is_zero_row j\n          (Hermite_reduce_above\n            (mult_row A i\n              (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n               A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n            (mod_type_class.to_nat i) i\n            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        ia $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res $\n          j $\n          n \\<noteq>\n          (0::'a))", "using echelon_form_Hermite_of_condition2[OF e a]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i A\n  ia < j\n  \\<not> is_zero_row ia\n          (Hermite_reduce_above\n            (mult_row A i\n              (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n               A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n            (mod_type_class.to_nat i) i\n            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n  \\<not> is_zero_row j\n          (Hermite_reduce_above\n            (mult_row A i\n              (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n               A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n            (mod_type_class.to_nat i) i\n            (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n  \\<lbrakk>\\<not> is_zero_row ?i A; ?ia < ?j;\n   \\<not> is_zero_row ?ia\n           (Hermite_reduce_above\n             (mult_row A ?i\n               (ass (A $ ?i $ (LEAST n. A $ ?i $ n \\<noteq> (0::'a))) div\n                A $ ?i $ (LEAST n. A $ ?i $ n \\<noteq> (0::'a))))\n             (mod_type_class.to_nat ?i) ?i\n             (LEAST n. A $ ?i $ n \\<noteq> (0::'a)) ?res);\n   \\<not> is_zero_row ?j\n           (Hermite_reduce_above\n             (mult_row A ?i\n               (ass (A $ ?i $ (LEAST n. A $ ?i $ n \\<noteq> (0::'a))) div\n                A $ ?i $ (LEAST n. A $ ?i $ n \\<noteq> (0::'a))))\n             (mod_type_class.to_nat ?i) ?i\n             (LEAST n. A $ ?i $ n \\<noteq> (0::'a)) ?res)\\<rbrakk>\n  \\<Longrightarrow> (LEAST n.\n                        Hermite_reduce_above\n                         (mult_row A ?i\n                           (ass (A $ ?i $\n                                 (LEAST n. A $ ?i $ n \\<noteq> (0::'a))) div\n                            A $ ?i $\n                            (LEAST n. A $ ?i $ n \\<noteq> (0::'a))))\n                         (mod_type_class.to_nat ?i) ?i\n                         (LEAST n. A $ ?i $ n \\<noteq> (0::'a)) ?res $\n                        ?ia $\n                        n \\<noteq>\n                        (0::'a))\n                    < (LEAST n.\n                          Hermite_reduce_above\n                           (mult_row A ?i\n                             (ass (A $ ?i $\n                                   (LEAST n.\n A $ ?i $ n \\<noteq> (0::'a))) div\n                              A $ ?i $\n                              (LEAST n. A $ ?i $ n \\<noteq> (0::'a))))\n                           (mod_type_class.to_nat ?i) ?i\n                           (LEAST n. A $ ?i $ n \\<noteq> (0::'a)) ?res $\n                          ?j $\n                          n \\<noteq>\n                          (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        ia $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           res $\n          j $\n          n \\<noteq>\n          (0::'a))", "by blast"], ["proof (state)\nthis:\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       res $\n      ia $\n      n \\<noteq>\n      (0::'a))\n  < (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        j $\n        n \\<noteq>\n        (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_form_fold_Hermite_of_row_i:\n  assumes e: \"echelon_form A\" and a: \"ass_function ass\" and r: \"res_function res\"\n  shows \"echelon_form (foldl (Hermite_of_row_i ass res) A (map from_nat [0..<k]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<k]))", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. echelon_form\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<0]))\n 2. \\<And>k.\n       echelon_form\n        (foldl (Hermite_of_row_i ass res) A\n          (map mod_type_class.from_nat [0..<k])) \\<Longrightarrow>\n       echelon_form\n        (foldl (Hermite_of_row_i ass res) A\n          (map mod_type_class.from_nat [0..<Suc k]))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. echelon_form\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<0]))\n 2. \\<And>k.\n       echelon_form\n        (foldl (Hermite_of_row_i ass res) A\n          (map mod_type_class.from_nat [0..<k])) \\<Longrightarrow>\n       echelon_form\n        (foldl (Hermite_of_row_i ass res) A\n          (map mod_type_class.from_nat [0..<Suc k]))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<0]))", "by (simp add: e)"], ["proof (state)\nthis:\n  echelon_form\n   (foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<0]))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       echelon_form\n        (foldl (Hermite_of_row_i ass res) A\n          (map mod_type_class.from_nat [0..<k])) \\<Longrightarrow>\n       echelon_form\n        (foldl (Hermite_of_row_i ass res) A\n          (map mod_type_class.from_nat [0..<Suc k]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       echelon_form\n        (foldl (Hermite_of_row_i ass res) A\n          (map mod_type_class.from_nat [0..<k])) \\<Longrightarrow>\n       echelon_form\n        (foldl (Hermite_of_row_i ass res) A\n          (map mod_type_class.from_nat [0..<Suc k]))", "case (Suc k)"], ["proof (state)\nthis:\n  echelon_form\n   (foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<k]))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       echelon_form\n        (foldl (Hermite_of_row_i ass res) A\n          (map mod_type_class.from_nat [0..<k])) \\<Longrightarrow>\n       echelon_form\n        (foldl (Hermite_of_row_i ass res) A\n          (map mod_type_class.from_nat [0..<Suc k]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<Suc k]))", "by (simp, rule echelon_form_Hermite_of_row[OF a r Suc.hyps])"], ["proof (state)\nthis:\n  echelon_form\n   (foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<Suc k]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma echelon_form_Hermite_of_upt_row_i:\n  assumes e: \"echelon_form A\" and a: \"ass_function ass\" and r: \"res_function res\"\n  shows \"echelon_form (Hermite_of_upt_row_i A k ass res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (Hermite_of_upt_row_i A k ass res)", "unfolding Hermite_of_upt_row_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<k]))", "using echelon_form_fold_Hermite_of_row_i assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>echelon_form ?A; ass_function ?ass; res_function ?res\\<rbrakk>\n  \\<Longrightarrow> echelon_form\n                     (foldl (Hermite_of_row_i ?ass ?res) ?A\n                       (map mod_type_class.from_nat [0..<?k]))\n  echelon_form A\n  ass_function ass\n  res_function res\n\ngoal (1 subgoal):\n 1. echelon_form\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<k]))", "by auto"], ["", "lemma echelon_form_Hermite_of:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  shows \"echelon_form (Hermite_of A ass res bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (Hermite_of A ass res bezout)", "unfolding Hermite_of_def Hermite_of_upt_row_i_def Let_def nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form\n     (foldl (Hermite_of_row_i ass res) (echelon_form_of A bezout)\n       (map mod_type_class.from_nat [0..<CARD('rows)]))", "by (rule echelon_form_fold_Hermite_of_row_i[OF echelon_form_echelon_form_of[OF b] a r])"], ["", "lemma in_ass_Hermite_of_row:\n  assumes a: \"ass_function ass\"\n  and \"res_function res\"\n  and not_zero_i_A: \"\\<not> is_zero_row i A\"\n  shows \"(Hermite_of_row_i ass res A i) $ i $ (LEAST n. (Hermite_of_row_i ass res A i) $ i $ n \\<noteq> 0) \\<in> range ass\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ i $\n    (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'a))\n    \\<in> range ass", "unfolding Hermite_of_row_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if is_zero_row i A then A\n     else let j = LEAST n. A $ i $ n \\<noteq> (0::'a); Aij = A $ i $ j;\n              A' = mult_row A i (ass Aij div Aij)\n          in Hermite_reduce_above A' (mod_type_class.to_nat i) i j res) $\n    i $\n    (LEAST n.\n        (if is_zero_row i A then A\n         else let j = LEAST n. A $ i $ n \\<noteq> (0::'a); Aij = A $ i $ j;\n                  A' = mult_row A i (ass Aij div Aij)\n              in Hermite_reduce_above A' (mod_type_class.to_nat i) i j\n                  res) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "using not_zero_i_A"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. (if is_zero_row i A then A\n     else let j = LEAST n. A $ i $ n \\<noteq> (0::'a); Aij = A $ i $ j;\n              A' = mult_row A i (ass Aij div Aij)\n          in Hermite_reduce_above A' (mod_type_class.to_nat i) i j res) $\n    i $\n    (LEAST n.\n        (if is_zero_row i A then A\n         else let j = LEAST n. A $ i $ n \\<noteq> (0::'a); Aij = A $ i $ j;\n                  A' = mult_row A i (ass Aij div Aij)\n              in Hermite_reduce_above A' (mod_type_class.to_nat i) i j\n                  res) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "proof (auto simp add: Let_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "let ?M=\"(mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))) \""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "let ?H=\"Hermite_reduce_above ?M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "let ?Ain=\"A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "have Ain: \"?Ain \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags) LeastI is_zero_row_def' not_zero_i_A)"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "have least_eq: \"(LEAST n. ?H $ i $ n \\<noteq> 0) = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'a))", "by (rule Hermite_reduce_above_Least_eq[OF a not_zero_i_A, symmetric])"], ["proof (state)\nthis:\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       res $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "have \"?H $ i $ (LEAST n. ?H $ i $ n \\<noteq> 0) = ?M $ i $ (LEAST n. ?H $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))", "by (rule Hermite_reduce_above_preserves, simp)"], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n  i $\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       res $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  i $\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       res $\n      i $\n      n \\<noteq>\n      (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "also"], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n  i $\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       res $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  i $\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       res $\n      i $\n      n \\<noteq>\n      (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "have \"... =  ass (?Ain) div ?Ain * ?Ain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", "unfolding mult_row_def least_eq[unfolded mult_row_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  i $\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       res $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "also"], ["proof (state)\nthis:\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  i $\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       res $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "have \"... = ass ?Ain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))", "proof (rule dvd_div_mult_self)"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) dvd\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))", "show \"?Ain dvd ass ?Ain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) dvd\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))", "using a"], ["proof (prove)\nusing this:\n  ass_function ass\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) dvd\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))", "unfolding ass_function_def"], ["proof (prove)\nusing this:\n  (\\<forall>a. normalize a = normalize (ass a)) \\<and>\n  pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b) (range ass)\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) dvd\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))", "by (simp add: associatedD2)"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) dvd\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "also"], ["proof (state)\nthis:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "have \"... \\<in> range ass\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) \\<in> range ass", "by simp"], ["proof (state)\nthis:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) \\<in> range ass\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "finally"], ["proof (chain)\npicking this:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n  i $\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       res $\n      i $\n      n \\<noteq>\n      (0::'a))\n  \\<in> range ass", "show \"?H $ i $ (LEAST n. ?H $ i $ n \\<noteq> 0) \\<in> range ass\""], ["proof (prove)\nusing this:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n  i $\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       res $\n      i $\n      n \\<noteq>\n      (0::'a))\n  \\<in> range ass\n\ngoal (1 subgoal):\n 1. Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    i $\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n         res $\n        i $\n        n \\<noteq>\n        (0::'a))\n    \\<in> range ass", "."], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n  i $\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       res $\n      i $\n      n \\<noteq>\n      (0::'a))\n  \\<in> range ass\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_upt_row_preserves_below:\n  assumes i: \"to_nat a\\<ge>k\"\n  shows \"Hermite_of_upt_row_i A k ass res $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A k ass res $ a $ b = A $ a $ b", "using i"], ["proof (prove)\nusing this:\n  k \\<le> mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A k ass res $ a $ b = A $ a $ b", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    Hermite_of_upt_row_i A 0 ass res $ a $ b = A $ a $ b\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n                Hermite_of_upt_row_i A k ass res $ a $ b = A $ a $ b;\n        Suc k \\<le> mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ a $ b =\n                         A $ a $ b", "case 0"], ["proof (state)\nthis:\n  0 \\<le> mod_type_class.to_nat a\n\ngoal (2 subgoals):\n 1. 0 \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    Hermite_of_upt_row_i A 0 ass res $ a $ b = A $ a $ b\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n                Hermite_of_upt_row_i A k ass res $ a $ b = A $ a $ b;\n        Suc k \\<le> mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ a $ b =\n                         A $ a $ b", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le> mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A 0 ass res $ a $ b = A $ a $ b", "unfolding Hermite_of_upt_row_i_def"], ["proof (prove)\nusing this:\n  0 \\<le> mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<0]) $\n    a $\n    b =\n    A $ a $ b", "by auto"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A 0 ass res $ a $ b = A $ a $ b\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n                Hermite_of_upt_row_i A k ass res $ a $ b = A $ a $ b;\n        Suc k \\<le> mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ a $ b =\n                         A $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n                Hermite_of_upt_row_i A k ass res $ a $ b = A $ a $ b;\n        Suc k \\<le> mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ a $ b =\n                         A $ a $ b", "case (Suc k)"], ["proof (state)\nthis:\n  k \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n  Hermite_of_upt_row_i A k ass res $ a $ b = A $ a $ b\n  Suc k \\<le> mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n                Hermite_of_upt_row_i A k ass res $ a $ b = A $ a $ b;\n        Suc k \\<le> mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ a $ b =\n                         A $ a $ b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ a $ b = A $ a $ b", "by (simp add: Hermite_of_upt_row_i_def, \n      metis Hermite_of_upt_row_i_def Hermite_of_row_preserves_below Suc.hyps Suc.prems \n      Suc_leD Suc_le_eq from_nat_mono from_nat_to_nat_id to_nat_less_card)"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ a $ b = A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_zero_Hermite_reduce_above:\n  fixes ass i A\n  defines M: \"M\\<equiv>(mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)))\"\n  assumes not_zero_a_A: \"\\<not> is_zero_row a A\"\n  and not_zero_i_A: \"\\<not> is_zero_row i A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and n: \"n \\<le> to_nat i\"\n  shows \"\\<not> is_zero_row a (Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> 0) res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "let ?H = \"(Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> 0) res)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "let ?n=\"LEAST n. A $ a $ n \\<noteq> 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "let ?m=\"LEAST n. A $ i $ n \\<noteq> 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "have Aan: \"A $ a $ ?n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags) LeastI not_zero_a_A is_zero_row_def')"], ["proof (state)\nthis:\n  A $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "have Aim: \"A $ i $ ?m \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags) LeastI not_zero_i_A is_zero_row_def')"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "proof (cases \"n\\<le>to_nat a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 2. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "case True"], ["proof (state)\nthis:\n  n \\<le> mod_type_class.to_nat a\n\ngoal (2 subgoals):\n 1. n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 2. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "have \"?H $ a $ ?n = M $ a $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    a $\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) =\n    M $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a))", "by (metis Hermite_reduce_above_preserves True)"], ["proof (state)\nthis:\n  Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $ a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) =\n  M $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 2. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "also"], ["proof (state)\nthis:\n  Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $ a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) =\n  M $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 2. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "unfolding M mult_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    a $\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using ass_function_0'[OF a] Aan"], ["proof (prove)\nusing this:\n  (ass ?x div ?x = (0::'a)) = (?x = (0::'a))\n  A $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             A $ i $ j\n        else A $ ia $ j) $\n    a $\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  M $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)\n 2. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "finally"], ["proof (chain)\npicking this:\n  Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $ a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $ a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "unfolding is_zero_row_def is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $ a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < CARD('b) \\<longrightarrow>\n               Hermite_reduce_above M n i\n                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n               a $\n               j =\n               (0::'a))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row a\n          (Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n            res)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "let ?R=\"row_add M a i\n      ((res (M $ i $ ?m) (M $ a $ ?m) - M $ a $ ?m) div M $ i $ ?m)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "case False"], ["proof (state)\nthis:\n  \\<not> n \\<le> mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "hence a_n: \"to_nat a < n\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < n", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat a < n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "have ai: \"a < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < i", "by (metis False dual_order.trans n nat_less_le not_less_iff_gr_or_eq to_nat_mono)"], ["proof (state)\nthis:\n  a < i\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "have \"(LEAST n. A $ a $ n \\<noteq> 0) < ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ a $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ i $ n \\<noteq> (0::'a))", "by (rule echelon_form_condition2_explicit[OF e ai not_zero_a_A not_zero_i_A])"], ["proof (state)\nthis:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "hence Ain: \"A $ i $ (LEAST n. A $ a $ n \\<noteq> 0) = 0\""], ["proof (prove)\nusing this:\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) = (0::'a)", "by (metis (full_types) not_less_Least)"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "have a_not_i: \"a \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> i", "by (metis False n)"], ["proof (state)\nthis:\n  a \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "have \"?H $ a $ ?n = ?R $ a $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n    a $\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) =\n    row_add M a i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ a $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ a $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    a $\n    (LEAST n. A $ a $ n \\<noteq> (0::'a))", "by (rule Hermite_reduce_above_works[OF n a_n])"], ["proof (state)\nthis:\n  Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $ a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) =\n  row_add M a i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ a $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ a $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "also"], ["proof (state)\nthis:\n  Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $ a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) =\n  row_add M a i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ a $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ a $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add M a i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ a $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ a $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    a $\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using a_not_i Aan Ain"], ["proof (prove)\nusing this:\n  a \\<noteq> i\n  A $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n  A $ i $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. row_add M a i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n        (M $ a $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n       M $ a $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n    a $\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "unfolding row_add_def M mult_row_def"], ["proof (prove)\nusing this:\n  a \\<noteq> i\n  A $ a $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n  A $ i $ (LEAST n. A $ a $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = a\n        then (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             a $\n             j +\n             (res ((\\<chi>ia j.\n                       if ia = i\n                       then ass (A $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                            A $ i $ j\n                       else A $ ia $ j) $\n                   i $\n                   (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n               ((\\<chi>ia j.\n                    if ia = i\n                    then ass (A $ i $\n                              (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                         A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                         A $ i $ j\n                    else A $ ia $ j) $\n                a $\n                (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n              (\\<chi>ia j.\n                  if ia = i\n                  then ass (A $ i $\n                            (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                       A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                       A $ i $ j\n                  else A $ ia $ j) $\n              a $\n              (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             i $\n             (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n             (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             i $\n             j\n        else (\\<chi>ia j.\n                 if ia = i\n                 then ass (A $ i $\n                           (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n                      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n                      A $ i $ j\n                 else A $ ia $ j) $\n             ia $\n             j) $\n    a $\n    (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  row_add M a i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n      (M $ a $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) -\n     M $ a $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $\n  a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> mod_type_class.to_nat a \\<Longrightarrow>\n    \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "finally"], ["proof (chain)\npicking this:\n  Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $ a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $ a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row a\n            (Hermite_reduce_above M n i\n              (LEAST n. A $ i $ n \\<noteq> (0::'a)) res)", "unfolding is_zero_row_def is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $ a $\n  (LEAST n. A $ a $ n \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < CARD('b) \\<longrightarrow>\n               Hermite_reduce_above M n i\n                (LEAST n. A $ i $ n \\<noteq> (0::'a)) res $\n               a $\n               j =\n               (0::'a))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row a\n          (Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n            res)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row a\n          (Hermite_reduce_above M n i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n            res)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Least_Hermite_of_row_i:\n  assumes i: \"\\<not> is_zero_row i A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  shows \"(LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> 0) = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "let ?M=\"mult_row A i (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) div A $ i $ (LEAST n. A $ i $ n \\<noteq> 0))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "let ?H=\"Hermite_reduce_above ?M (to_nat i) i (LEAST n. A $ i $ n \\<noteq> 0) res\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have \"(LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> 0) = (LEAST n. ?H $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b))\n         res $\n        i $\n        n \\<noteq>\n        (0::'b))", "using i"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b))\n         res $\n        i $\n        n \\<noteq>\n        (0::'b))", "unfolding Hermite_of_row_i_def"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        (if is_zero_row i A then A\n         else let j = LEAST n. A $ i $ n \\<noteq> (0::'b); Aij = A $ i $ j;\n                  A' = mult_row A i (ass Aij div Aij)\n              in Hermite_reduce_above A' (mod_type_class.to_nat i) i j\n                  res) $\n        i $\n        n \\<noteq>\n        (0::'b)) =\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b))\n         res $\n        i $\n        n \\<noteq>\n        (0::'b))", "unfolding Let_def"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        (if is_zero_row i A then A\n         else Hermite_reduce_above\n               (mult_row A i\n                 (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n                  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n               (mod_type_class.to_nat i) i\n               (LEAST n. A $ i $ n \\<noteq> (0::'b)) res) $\n        i $\n        n \\<noteq>\n        (0::'b)) =\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b))\n         res $\n        i $\n        n \\<noteq>\n        (0::'b))", "by auto"], ["proof (state)\nthis:\n  (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b))\n       res $\n      i $\n      n \\<noteq>\n      (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "also"], ["proof (state)\nthis:\n  (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b))\n       res $\n      i $\n      n \\<noteq>\n      (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have \"... = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A i\n           (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n            A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n         (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b))\n         res $\n        i $\n        n \\<noteq>\n        (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Hermite_reduce_above_Least[OF e a i i])\n       (rule not_zero_Hermite_reduce_above[OF i i e a], simp)"], ["proof (state)\nthis:\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A i\n         (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n          A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n       (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b))\n       res $\n      i $\n      n \\<noteq>\n      (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "finally"], ["proof (chain)\npicking this:\n  (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "."], ["proof (state)\nthis:\n  (LEAST n. Hermite_of_row_i ass res A i $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Least_Hermite_of_row_i2:\n  assumes i: \"\\<not> is_zero_row i A\" and k: \"\\<not> is_zero_row k A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  shows \"(LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> 0) = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "let ?M=\"mult_row A k (ass (A $ k $ (LEAST n. A $ k $ n \\<noteq> 0)) div A $ k $ (LEAST n. A $ k $ n \\<noteq> 0))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "let ?H=\"Hermite_reduce_above ?M (to_nat k) k (LEAST n. A $ k $ n \\<noteq> 0) res\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have \"(LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> 0) = (LEAST n. ?H $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A k\n           (ass (A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))) div\n            A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))))\n         (mod_type_class.to_nat k) k (LEAST n. A $ k $ n \\<noteq> (0::'b))\n         res $\n        i $\n        n \\<noteq>\n        (0::'b))", "using k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row k A\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A k\n           (ass (A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))) div\n            A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))))\n         (mod_type_class.to_nat k) k (LEAST n. A $ k $ n \\<noteq> (0::'b))\n         res $\n        i $\n        n \\<noteq>\n        (0::'b))", "unfolding Hermite_of_row_i_def"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row k A\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        (if is_zero_row k A then A\n         else let j = LEAST n. A $ k $ n \\<noteq> (0::'b); Aij = A $ k $ j;\n                  A' = mult_row A k (ass Aij div Aij)\n              in Hermite_reduce_above A' (mod_type_class.to_nat k) k j\n                  res) $\n        i $\n        n \\<noteq>\n        (0::'b)) =\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A k\n           (ass (A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))) div\n            A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))))\n         (mod_type_class.to_nat k) k (LEAST n. A $ k $ n \\<noteq> (0::'b))\n         res $\n        i $\n        n \\<noteq>\n        (0::'b))", "unfolding Let_def"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row k A\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        (if is_zero_row k A then A\n         else Hermite_reduce_above\n               (mult_row A k\n                 (ass (A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))) div\n                  A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))))\n               (mod_type_class.to_nat k) k\n               (LEAST n. A $ k $ n \\<noteq> (0::'b)) res) $\n        i $\n        n \\<noteq>\n        (0::'b)) =\n    (LEAST n.\n        Hermite_reduce_above\n         (mult_row A k\n           (ass (A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))) div\n            A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))))\n         (mod_type_class.to_nat k) k (LEAST n. A $ k $ n \\<noteq> (0::'b))\n         res $\n        i $\n        n \\<noteq>\n        (0::'b))", "by auto"], ["proof (state)\nthis:\n  (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A k\n         (ass (A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))) div\n          A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))))\n       (mod_type_class.to_nat k) k (LEAST n. A $ k $ n \\<noteq> (0::'b))\n       res $\n      i $\n      n \\<noteq>\n      (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "also"], ["proof (state)\nthis:\n  (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A k\n         (ass (A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))) div\n          A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))))\n       (mod_type_class.to_nat k) k (LEAST n. A $ k $ n \\<noteq> (0::'b))\n       res $\n      i $\n      n \\<noteq>\n      (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have \"... = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_reduce_above\n         (mult_row A k\n           (ass (A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))) div\n            A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))))\n         (mod_type_class.to_nat k) k (LEAST n. A $ k $ n \\<noteq> (0::'b))\n         res $\n        i $\n        n \\<noteq>\n        (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Hermite_reduce_above_Least[OF e a k i])\n       (simp add: a e i k not_zero_Hermite_reduce_above)"], ["proof (state)\nthis:\n  (LEAST n.\n      Hermite_reduce_above\n       (mult_row A k\n         (ass (A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))) div\n          A $ k $ (LEAST n. A $ k $ n \\<noteq> (0::'b))))\n       (mod_type_class.to_nat k) k (LEAST n. A $ k $ n \\<noteq> (0::'b))\n       res $\n      i $\n      n \\<noteq>\n      (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "finally"], ["proof (chain)\npicking this:\n  (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "."], ["proof (state)\nthis:\n  (LEAST n. Hermite_of_row_i ass res A k $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_row_i_works:\n  fixes i A ass\n  defines n:\"n \\<equiv>(LEAST n. A $ i $ n \\<noteq> 0)\"\n  defines M:\"M \\<equiv> (mult_row A i (ass (A $ i $ n) div A $ i $ n))\"\n  assumes ai: \"a < i\"\n  and i: \"\\<not> is_zero_row i A\"\n  shows \"Hermite_of_row_i ass res A i $ a $ b = \n  row_add M a i ((res (M $ i $ n) (M $ a $ n) \n  - M $ a $ n) div M $ i $ n) $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ a $ b =\n    row_add M a i\n     ((res (M $ i $ n) (M $ a $ n) - M $ a $ n) div M $ i $ n) $\n    a $\n    b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ a $ b =\n    row_add M a i\n     ((res (M $ i $ n) (M $ a $ n) - M $ a $ n) div M $ i $ n) $\n    a $\n    b", "let ?H=\"Hermite_reduce_above M (to_nat i) i n res\""], ["proof (state)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ a $ b =\n    row_add M a i\n     ((res (M $ i $ n) (M $ a $ n) - M $ a $ n) div M $ i $ n) $\n    a $\n    b", "have \"Hermite_of_row_i ass res A i $ a $ b = ?H $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ a $ b =\n    Hermite_reduce_above M (mod_type_class.to_nat i) i n res $ a $ b", "unfolding Hermite_of_row_i_def Let_def M n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if is_zero_row i A then A\n     else Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b))\n           res) $\n    a $\n    b =\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b", "using i"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. (if is_zero_row i A then A\n     else Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b))\n           res) $\n    a $\n    b =\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    a $\n    b", "by simp"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A i $ a $ b =\n  Hermite_reduce_above M (mod_type_class.to_nat i) i n res $ a $ b\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ a $ b =\n    row_add M a i\n     ((res (M $ i $ n) (M $ a $ n) - M $ a $ n) div M $ i $ n) $\n    a $\n    b", "also"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A i $ a $ b =\n  Hermite_reduce_above M (mod_type_class.to_nat i) i n res $ a $ b\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ a $ b =\n    row_add M a i\n     ((res (M $ i $ n) (M $ a $ n) - M $ a $ n) div M $ i $ n) $\n    a $\n    b", "have \"... =   row_add M a i ((res (M $ i $ n) (M $ a $ n) \n    - M $ a $ n) div M $ i $ n) $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above M (mod_type_class.to_nat i) i n res $ a $ b =\n    row_add M a i\n     ((res (M $ i $ n) (M $ a $ n) - M $ a $ n) div M $ i $ n) $\n    a $\n    b", "by (rule Hermite_reduce_above_works, auto simp add: ai to_nat_mono)"], ["proof (state)\nthis:\n  Hermite_reduce_above M (mod_type_class.to_nat i) i n res $ a $ b =\n  row_add M a i ((res (M $ i $ n) (M $ a $ n) - M $ a $ n) div M $ i $ n) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ a $ b =\n    row_add M a i\n     ((res (M $ i $ n) (M $ a $ n) - M $ a $ n) div M $ i $ n) $\n    a $\n    b", "finally"], ["proof (chain)\npicking this:\n  Hermite_of_row_i ass res A i $ a $ b =\n  row_add M a i ((res (M $ i $ n) (M $ a $ n) - M $ a $ n) div M $ i $ n) $\n  a $\n  b", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_of_row_i ass res A i $ a $ b =\n  row_add M a i ((res (M $ i $ n) (M $ a $ n) - M $ a $ n) div M $ i $ n) $\n  a $\n  b\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ a $ b =\n    row_add M a i\n     ((res (M $ i $ n) (M $ a $ n) - M $ a $ n) div M $ i $ n) $\n    a $\n    b", "."], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A i $ a $ b =\n  row_add M a i ((res (M $ i $ n) (M $ a $ n) - M $ a $ n) div M $ i $ n) $\n  a $\n  b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_row_i_works2:\n  fixes i A ass\n  defines n:\"n \\<equiv>(LEAST n. A $ i $ n \\<noteq> 0)\"\n  defines M:\"M \\<equiv> (mult_row A i (ass (A $ i $ n) div A $ i $ n))\"\n  assumes i: \"\\<not> is_zero_row i A\"\n  shows \"Hermite_of_row_i ass res A i $ i $ b = M $ i $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ i $ b = M $ i $ b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ i $ b = M $ i $ b", "let ?H=\"Hermite_reduce_above M (to_nat i) i n res\""], ["proof (state)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ i $ b = M $ i $ b", "have \"Hermite_of_row_i ass res A i $ i $ b = ?H $ i $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ i $ b =\n    Hermite_reduce_above M (mod_type_class.to_nat i) i n res $ i $ b", "unfolding Hermite_of_row_i_def Let_def M n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if is_zero_row i A then A\n     else Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b))\n           res) $\n    i $\n    b =\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    i $\n    b", "using i"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. (if is_zero_row i A then A\n     else Hermite_reduce_above\n           (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n           (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b))\n           res) $\n    i $\n    b =\n    Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'b)) res $\n    i $\n    b", "by simp"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A i $ i $ b =\n  Hermite_reduce_above M (mod_type_class.to_nat i) i n res $ i $ b\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ i $ b = M $ i $ b", "also"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A i $ i $ b =\n  Hermite_reduce_above M (mod_type_class.to_nat i) i n res $ i $ b\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ i $ b = M $ i $ b", "have \"... = M $ i $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above M (mod_type_class.to_nat i) i n res $ i $ b =\n    M $ i $ b", "by (rule Hermite_reduce_above_preserves, simp)"], ["proof (state)\nthis:\n  Hermite_reduce_above M (mod_type_class.to_nat i) i n res $ i $ b =\n  M $ i $ b\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ i $ b = M $ i $ b", "finally"], ["proof (chain)\npicking this:\n  Hermite_of_row_i ass res A i $ i $ b = M $ i $ b", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_of_row_i ass res A i $ i $ b = M $ i $ b\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ i $ b = M $ i $ b", "."], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A i $ i $ b = M $ i $ b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_upt_row_preserves_nonzero_rows_ge:\n  assumes i: \"\\<not> is_zero_row i A\" and i2: \"to_nat i\\<ge>k\"\n  shows \"\\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "let ?n=\"LEAST n. A $ i $ n \\<noteq> 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "have Ain: \"A $ i $ ?n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)", "by (metis (mono_tags) LeastI i is_zero_row_def')"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "have \"Hermite_of_upt_row_i A k ass res $ i $ ?n = A $ i $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A k ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Hermite_of_upt_row_preserves_below[OF i2])"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A k ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "also"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A k ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)", "by (metis (mono_tags) LeastI i is_zero_row_def')"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "finally"], ["proof (chain)\npicking this:\n  Hermite_of_upt_row_i A k ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)", "have \"Hermite_of_upt_row_i A k ass res $ i $ (LEAST n. A $ i $ n \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A k ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A k ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)", "."], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A k ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A k ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "unfolding is_zero_row_def is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A k ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < CARD('c) \\<longrightarrow>\n               Hermite_of_upt_row_i A k ass res $ i $ j = (0::'b))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_upt_row_i_Least_ge:\n  assumes i: \"\\<not> is_zero_row i A\"\n  and i2: \"to_nat i\\<ge>k\"\n  shows \"(LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> 0) = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Hermite_of_upt_row_i A k ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)\n 2. \\<And>y.\n       Hermite_of_upt_row_i A k ass res $ i $ y \\<noteq>\n       (0::'b) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<le> y", "let ?n=\"LEAST n. A $ i $ n \\<noteq> 0\""], ["proof (state)\ngoal (2 subgoals):\n 1. Hermite_of_upt_row_i A k ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)\n 2. \\<And>y.\n       Hermite_of_upt_row_i A k ass res $ i $ y \\<noteq>\n       (0::'b) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<le> y", "have Ain: \"A $ i $ ?n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)", "by (metis (mono_tags) LeastI i is_zero_row_def')"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. Hermite_of_upt_row_i A k ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)\n 2. \\<And>y.\n       Hermite_of_upt_row_i A k ass res $ i $ y \\<noteq>\n       (0::'b) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<le> y", "have \"Hermite_of_upt_row_i A k ass res $ i $ ?n = A $ i $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A k ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Hermite_of_upt_row_preserves_below[OF i2])"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A k ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. Hermite_of_upt_row_i A k ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)\n 2. \\<And>y.\n       Hermite_of_upt_row_i A k ass res $ i $ y \\<noteq>\n       (0::'b) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<le> y", "also"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A k ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. Hermite_of_upt_row_i A k ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)\n 2. \\<And>y.\n       Hermite_of_upt_row_i A k ass res $ i $ y \\<noteq>\n       (0::'b) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<le> y", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)", "by (metis (mono_tags) LeastI i is_zero_row_def')"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. Hermite_of_upt_row_i A k ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)\n 2. \\<And>y.\n       Hermite_of_upt_row_i A k ass res $ i $ y \\<noteq>\n       (0::'b) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<le> y", "finally"], ["proof (chain)\npicking this:\n  Hermite_of_upt_row_i A k ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)", "show \"Hermite_of_upt_row_i A k ass res $ i $ (LEAST n. A $ i $ n \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A k ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A k ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)", "."], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A k ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Hermite_of_upt_row_i A k ass res $ i $ y \\<noteq>\n       (0::'b) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Hermite_of_upt_row_i A k ass res $ i $ y \\<noteq>\n       (0::'b) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<le> y", "assume H: \"Hermite_of_upt_row_i A k ass res $ i $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A k ass res $ i $ y \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Hermite_of_upt_row_i A k ass res $ i $ y \\<noteq>\n       (0::'b) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<le> y", "show \"(LEAST n. A $ i $ n \\<noteq> 0) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<le> y", "by (rule Least_le, metis Hermite_of_upt_row_preserves_below H i2)"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_upt_row_i_Least:\n  assumes iA: \"\\<not> is_zero_row i A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and k: \"k\\<le>nrows A\"\n  shows \"(LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> 0) = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "proof (cases \"to_nat i\\<ge>k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "case True"], ["proof (state)\nthis:\n  k \\<le> mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "using Hermite_of_upt_row_i_Least_ge iA"], ["proof (prove)\nusing this:\n  k \\<le> mod_type_class.to_nat i\n  \\<lbrakk>\\<not> is_zero_row ?i ?A;\n   ?k \\<le> mod_type_class.to_nat ?i\\<rbrakk>\n  \\<Longrightarrow> (LEAST n.\n                        Hermite_of_upt_row_i ?A ?k ?ass ?res $ ?i $\n                        n \\<noteq>\n                        (0::?'b)) =\n                    (LEAST n. ?A $ ?i $ n \\<noteq> (0::?'b))\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by blast"], ["proof (state)\nthis:\n  (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "case False"], ["proof (state)\nthis:\n  \\<not> k \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "hence i_less_k: \"to_nat i<k\""], ["proof (prove)\nusing this:\n  \\<not> k \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "using e iA k"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n  echelon_form A\n  \\<not> is_zero_row i A\n  k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "proof (induct k arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>mod_type_class.to_nat i < 0; echelon_form A;\n        \\<not> is_zero_row i A; 0 \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_of_upt_row_i A 0 ass res $ i $\n                             n \\<noteq>\n                             (0::'b)) =\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>mod_type_class.to_nat i < k; echelon_form A;\n                    \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                   \\<Longrightarrow> (LEAST n.\n   Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n                                     (LEAST n. A $ i $ n \\<noteq> (0::'b));\n        mod_type_class.to_nat i < Suc k; echelon_form A;\n        \\<not> is_zero_row i A; Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                             n \\<noteq>\n                             (0::'b)) =\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))", "case 0"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < 0\n  echelon_form A\n  \\<not> is_zero_row i A\n  0 \\<le> nrows A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>mod_type_class.to_nat i < 0; echelon_form A;\n        \\<not> is_zero_row i A; 0 \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_of_upt_row_i A 0 ass res $ i $\n                             n \\<noteq>\n                             (0::'b)) =\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>mod_type_class.to_nat i < k; echelon_form A;\n                    \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                   \\<Longrightarrow> (LEAST n.\n   Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n                                     (LEAST n. A $ i $ n \\<noteq> (0::'b));\n        mod_type_class.to_nat i < Suc k; echelon_form A;\n        \\<not> is_zero_row i A; Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                             n \\<noteq>\n                             (0::'b)) =\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))", "thus ?case"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < 0\n  echelon_form A\n  \\<not> is_zero_row i A\n  0 \\<le> nrows A\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_upt_row_i A 0 ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding Hermite_of_upt_row_i_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < 0\n  echelon_form A\n  \\<not> is_zero_row i A\n  0 \\<le> nrows A\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        foldl (Hermite_of_row_i ass res) A\n         (map mod_type_class.from_nat [0..<0]) $\n        i $\n        n \\<noteq>\n        (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by simp"], ["proof (state)\nthis:\n  (LEAST n. Hermite_of_upt_row_i A 0 ass res $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>mod_type_class.to_nat i < k; echelon_form A;\n                    \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                   \\<Longrightarrow> (LEAST n.\n   Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n                                     (LEAST n. A $ i $ n \\<noteq> (0::'b));\n        mod_type_class.to_nat i < Suc k; echelon_form A;\n        \\<not> is_zero_row i A; Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                             n \\<noteq>\n                             (0::'b)) =\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>mod_type_class.to_nat i < k; echelon_form A;\n                    \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                   \\<Longrightarrow> (LEAST n.\n   Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n                                     (LEAST n. A $ i $ n \\<noteq> (0::'b));\n        mod_type_class.to_nat i < Suc k; echelon_form A;\n        \\<not> is_zero_row i A; Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                             n \\<noteq>\n                             (0::'b)) =\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>mod_type_class.to_nat i < k; echelon_form ?A;\n   \\<not> is_zero_row i ?A; k \\<le> nrows ?A\\<rbrakk>\n  \\<Longrightarrow> (LEAST n.\n                        Hermite_of_upt_row_i ?A k ass res $ i $ n \\<noteq>\n                        (0::'b)) =\n                    (LEAST n. ?A $ i $ n \\<noteq> (0::'b))\n  mod_type_class.to_nat i < Suc k\n  echelon_form A\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>mod_type_class.to_nat i < k; echelon_form A;\n                    \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                   \\<Longrightarrow> (LEAST n.\n   Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n                                     (LEAST n. A $ i $ n \\<noteq> (0::'b));\n        mod_type_class.to_nat i < Suc k; echelon_form A;\n        \\<not> is_zero_row i A; Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                             n \\<noteq>\n                             (0::'b)) =\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have k: \"k\\<le>nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> nrows A", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  echelon_form A\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. k \\<le> nrows A", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  echelon_form A\n  \\<not> is_zero_row i A\n  Suc k \\<le> CARD('a)\n\ngoal (1 subgoal):\n 1. k \\<le> CARD('a)", "by simp"], ["proof (state)\nthis:\n  k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>mod_type_class.to_nat i < k; echelon_form A;\n                    \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                   \\<Longrightarrow> (LEAST n.\n   Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n                                     (LEAST n. A $ i $ n \\<noteq> (0::'b));\n        mod_type_class.to_nat i < Suc k; echelon_form A;\n        \\<not> is_zero_row i A; Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                             n \\<noteq>\n                             (0::'b)) =\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have k2: \"k<nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < nrows A", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  echelon_form A\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. k < nrows A", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  echelon_form A\n  \\<not> is_zero_row i A\n  Suc k \\<le> CARD('a)\n\ngoal (1 subgoal):\n 1. k < CARD('a)", "by simp"], ["proof (state)\nthis:\n  k < nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>mod_type_class.to_nat i < k; echelon_form A;\n                    \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                   \\<Longrightarrow> (LEAST n.\n   Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n                                     (LEAST n. A $ i $ n \\<noteq> (0::'b));\n        mod_type_class.to_nat i < Suc k; echelon_form A;\n        \\<not> is_zero_row i A; Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                             n \\<noteq>\n                             (0::'b)) =\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))", "define A' where \"A' = foldl (Hermite_of_row_i ass res) A (map from_nat [0..<k])\""], ["proof (state)\nthis:\n  A' =\n  foldl (Hermite_of_row_i ass res) A (map mod_type_class.from_nat [0..<k])\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>mod_type_class.to_nat i < k; echelon_form A;\n                    \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                   \\<Longrightarrow> (LEAST n.\n   Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n                                     (LEAST n. A $ i $ n \\<noteq> (0::'b));\n        mod_type_class.to_nat i < Suc k; echelon_form A;\n        \\<not> is_zero_row i A; Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                             n \\<noteq>\n                             (0::'b)) =\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have A'_def2: \"A' = Hermite_of_upt_row_i A k ass res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = Hermite_of_upt_row_i A k ass res", "unfolding Hermite_of_upt_row_i_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<k]) =\n    foldl (Hermite_of_row_i ass res) A (map mod_type_class.from_nat [0..<k])", ".."], ["proof (state)\nthis:\n  A' = Hermite_of_upt_row_i A k ass res\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>mod_type_class.to_nat i < k; echelon_form A;\n                    \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                   \\<Longrightarrow> (LEAST n.\n   Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n                                     (LEAST n. A $ i $ n \\<noteq> (0::'b));\n        mod_type_class.to_nat i < Suc k; echelon_form A;\n        \\<not> is_zero_row i A; Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                             n \\<noteq>\n                             (0::'b)) =\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have e: \"echelon_form A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form A'", "unfolding A'_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (Hermite_of_upt_row_i A k ass res)", "by (rule echelon_form_Hermite_of_upt_row_i[OF _ a r], auto simp add: Suc.prems)"], ["proof (state)\nthis:\n  echelon_form A'\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>mod_type_class.to_nat i < k; echelon_form A;\n                    \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                   \\<Longrightarrow> (LEAST n.\n   Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n                                     (LEAST n. A $ i $ n \\<noteq> (0::'b));\n        mod_type_class.to_nat i < Suc k; echelon_form A;\n        \\<not> is_zero_row i A; Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                             n \\<noteq>\n                             (0::'b)) =\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "proof (cases \"to_nat i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat i = k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have i_fn_k: \"from_nat k = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = i", "by (metis True from_nat_to_nat_id)"], ["proof (state)\nthis:\n  mod_type_class.from_nat k = i\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have not_zero_i_A':  \"\\<not> is_zero_row i A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A'", "unfolding A'_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "by (rule Hermite_of_upt_row_preserves_nonzero_rows_ge, auto simp add: Suc.prems True)"], ["proof (state)\nthis:\n  \\<not> is_zero_row i A'\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have \"Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_row_i ass res A' (from_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res =\n    Hermite_of_row_i ass res A' (mod_type_class.from_nat k)", "unfolding Hermite_of_upt_row_i_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<Suc k]) =\n    Hermite_of_row_i ass res\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<k]))\n     (mod_type_class.from_nat k)", "by auto"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res =\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "also"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res =\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have \"(LEAST n. ... $ i $ n \\<noteq> 0) = (LEAST n. A' $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'b)) =\n    (LEAST n. A' $ i $ n \\<noteq> (0::'b))", "unfolding i_fn_k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A' i $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A' $ i $ n \\<noteq> (0::'b))", "by (rule Least_Hermite_of_row_i[OF not_zero_i_A' e a])"], ["proof (state)\nthis:\n  (LEAST n.\n      Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n      n \\<noteq>\n      (0::'b)) =\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "also"], ["proof (state)\nthis:\n  (LEAST n.\n      Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n      n \\<noteq>\n      (0::'b)) =\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have \"... = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A' $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding A'_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Hermite_of_upt_row_i_Least_ge, auto simp add: True Suc.prems)"], ["proof (state)\nthis:\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "finally"], ["proof (chain)\npicking this:\n  (LEAST n.\n      Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n.\n      Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "."], ["proof (state)\nthis:\n  (LEAST n.\n      Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "case False"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<noteq> k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "hence i_less_k: \"to_nat i < k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<noteq> k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < k", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<noteq> k\n  mod_type_class.to_nat i < Suc k\n  echelon_form A\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "hence i_less_k2: \"i < from_nat k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id k2 nrows_def)"], ["proof (state)\nthis:\n  i < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "proof (cases \"is_zero_row (from_nat k) A'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "case True"], ["proof (state)\nthis:\n  is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have H: \"Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res =\n    Hermite_of_upt_row_i A k ass res", "using True"], ["proof (prove)\nusing this:\n  is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res =\n    Hermite_of_upt_row_i A k ass res", "by (simp add:  Hermite_of_upt_row_i_def Hermite_of_row_i_def A'_def Let_def )"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Suc.hyps[OF i_less_k], auto simp add: Suc.prems k)"], ["proof (state)\nthis:\n  (LEAST n.\n      Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "case False"], ["proof (state)\nthis:\n  \\<not> is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have not_zero_i_A': \"\\<not> is_zero_row i A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A'", "using e False i_less_k2 echelon_form_condition1"], ["proof (prove)\nusing this:\n  echelon_form A'\n  \\<not> is_zero_row (mod_type_class.from_nat k) A'\n  i < mod_type_class.from_nat k\n  echelon_form ?A \\<Longrightarrow>\n  \\<forall>i.\n     is_zero_row i ?A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row j ?A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A'", "by blast"], ["proof (state)\nthis:\n  \\<not> is_zero_row i A'\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have \"Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_row_i ass res A' (from_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res =\n    Hermite_of_row_i ass res A' (mod_type_class.from_nat k)", "unfolding Hermite_of_upt_row_i_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<Suc k]) =\n    Hermite_of_row_i ass res\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<k]))\n     (mod_type_class.from_nat k)", "by auto"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res =\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "also"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res =\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have \"(LEAST n. ... $ i $ n \\<noteq> 0) = (LEAST n. A' $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'b)) =\n    (LEAST n. A' $ i $ n \\<noteq> (0::'b))", "by (rule Least_Hermite_of_row_i2[OF not_zero_i_A' False e a])"], ["proof (state)\nthis:\n  (LEAST n.\n      Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n      n \\<noteq>\n      (0::'b)) =\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "also"], ["proof (state)\nthis:\n  (LEAST n.\n      Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n      n \\<noteq>\n      (0::'b)) =\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "have \"... = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A' $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding A'_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Suc.hyps[OF i_less_k], auto simp add: Suc.prems k)"], ["proof (state)\nthis:\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "finally"], ["proof (chain)\npicking this:\n  (LEAST n.\n      Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n.\n      Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "."], ["proof (state)\nthis:\n  (LEAST n.\n      Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n.\n      Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n.\n      Hermite_of_upt_row_i A (Suc k) ass res $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_upt_row_preserves_nonzero_rows:\n  assumes i: \"\\<not> is_zero_row i A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and k: \"k\\<le>nrows A\"\n  shows \"\\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "let ?n=\"LEAST n. A $ i $ n \\<noteq> 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "have Ain: \"A $ i $ ?n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)", "by (metis (mono_tags) LeastI i is_zero_row_def')"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "proof (cases \"to_nat i\\<ge>k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\n 2. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "case True"], ["proof (state)\nthis:\n  k \\<le> mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\n 2. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "using Hermite_of_upt_row_preserves_nonzero_rows_ge i"], ["proof (prove)\nusing this:\n  k \\<le> mod_type_class.to_nat i\n  \\<lbrakk>\\<not> is_zero_row ?i ?A;\n   ?k \\<le> mod_type_class.to_nat ?i\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_zero_row ?i\n                            (Hermite_of_upt_row_i ?A ?k ?ass ?res)\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "by blast"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "case False"], ["proof (state)\nthis:\n  \\<not> k \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "hence i_less_k: \"to_nat i<k\""], ["proof (prove)\nusing this:\n  \\<not> k \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < k", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "using i k"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n  \\<not> is_zero_row i A\n  k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>mod_type_class.to_nat i < 0; \\<not> is_zero_row i A;\n     0 \\<le> nrows A\\<rbrakk>\n    \\<Longrightarrow> \\<not> is_zero_row i\n                              (Hermite_of_upt_row_i A 0 ass res)\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> \\<not> is_zero_row i\n    (Hermite_of_upt_row_i A k ass res);\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_zero_row i\n                                 (Hermite_of_upt_row_i A (Suc k) ass res)", "case 0"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < 0\n  \\<not> is_zero_row i A\n  0 \\<le> nrows A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mod_type_class.to_nat i < 0; \\<not> is_zero_row i A;\n     0 \\<le> nrows A\\<rbrakk>\n    \\<Longrightarrow> \\<not> is_zero_row i\n                              (Hermite_of_upt_row_i A 0 ass res)\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> \\<not> is_zero_row i\n    (Hermite_of_upt_row_i A k ass res);\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_zero_row i\n                                 (Hermite_of_upt_row_i A (Suc k) ass res)", "thus ?case"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < 0\n  \\<not> is_zero_row i A\n  0 \\<le> nrows A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A 0 ass res)", "by (metis less_nat_zero_code)"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A 0 ass res)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> \\<not> is_zero_row i\n    (Hermite_of_upt_row_i A k ass res);\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_zero_row i\n                                 (Hermite_of_upt_row_i A (Suc k) ass res)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> \\<not> is_zero_row i\n    (Hermite_of_upt_row_i A k ass res);\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_zero_row i\n                                 (Hermite_of_upt_row_i A (Suc k) ass res)", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>mod_type_class.to_nat i < k; \\<not> is_zero_row i A;\n   k \\<le> nrows A\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> \\<not> is_zero_row i\n    (Hermite_of_upt_row_i A k ass res);\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_zero_row i\n                                 (Hermite_of_upt_row_i A (Suc k) ass res)", "have k_nrows: \"k \\<le> nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> nrows A", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. k \\<le> nrows A", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> CARD('a)\n\ngoal (1 subgoal):\n 1. k \\<le> CARD('a)", "by auto"], ["proof (state)\nthis:\n  k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> \\<not> is_zero_row i\n    (Hermite_of_upt_row_i A k ass res);\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_zero_row i\n                                 (Hermite_of_upt_row_i A (Suc k) ass res)", "have k_nrows2: \"k < nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < nrows A", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. k < nrows A", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> CARD('a)\n\ngoal (1 subgoal):\n 1. k < CARD('a)", "by auto"], ["proof (state)\nthis:\n  k < nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> \\<not> is_zero_row i\n    (Hermite_of_upt_row_i A k ass res);\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_zero_row i\n                                 (Hermite_of_upt_row_i A (Suc k) ass res)", "define A' where \"A' = foldl (Hermite_of_row_i ass res) A (map from_nat [0..<k])\""], ["proof (state)\nthis:\n  A' =\n  foldl (Hermite_of_row_i ass res) A (map mod_type_class.from_nat [0..<k])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> \\<not> is_zero_row i\n    (Hermite_of_upt_row_i A k ass res);\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_zero_row i\n                                 (Hermite_of_upt_row_i A (Suc k) ass res)", "have A'_def2: \"A' = Hermite_of_upt_row_i A k ass res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = Hermite_of_upt_row_i A k ass res", "unfolding Hermite_of_upt_row_i_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<k]) =\n    foldl (Hermite_of_row_i ass res) A (map mod_type_class.from_nat [0..<k])", ".."], ["proof (state)\nthis:\n  A' = Hermite_of_upt_row_i A k ass res\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> \\<not> is_zero_row i\n    (Hermite_of_upt_row_i A k ass res);\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_zero_row i\n                                 (Hermite_of_upt_row_i A (Suc k) ass res)", "have least_A'_A: \"(LEAST n. A' $ i $ n \\<noteq> 0) = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A' $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding A'_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Hermite_of_upt_row_i_Least[OF _ e a r], auto simp add: k_nrows Suc.prems)"], ["proof (state)\nthis:\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> \\<not> is_zero_row i\n    (Hermite_of_upt_row_i A k ass res);\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_zero_row i\n                                 (Hermite_of_upt_row_i A (Suc k) ass res)", "have e: \"echelon_form A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form A'", "unfolding A'_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (Hermite_of_upt_row_i A k ass res)", "by (simp add: a e echelon_form_Hermite_of_upt_row_i r)"], ["proof (state)\nthis:\n  echelon_form A'\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> \\<not> is_zero_row i\n    (Hermite_of_upt_row_i A k ass res);\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_zero_row i\n                                 (Hermite_of_upt_row_i A (Suc k) ass res)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "proof (cases \"to_nat i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "let ?M=\"mult_row A' i (ass (A' $ i $ (LEAST n. A' $ i $ n \\<noteq> 0)) div A' $ i $ (LEAST n. A' $ i $ n \\<noteq> 0))\""], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat i = k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "hence fn_k_i: \"from_nat k = i\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i = k\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = i", "by (metis from_nat_to_nat_id)"], ["proof (state)\nthis:\n  mod_type_class.from_nat k = i\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "have not_zero_i_A': \"\\<not> is_zero_row i A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A'", "by (unfold A'_def2) \n        (rule Hermite_of_upt_row_preserves_nonzero_rows_ge, auto simp add: True Suc.prems)"], ["proof (state)\nthis:\n  \\<not> is_zero_row i A'\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "have A'_i_l: \"(A' $ i $ (LEAST n. A' $ i $ n \\<noteq> 0)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)", "by (metis (mono_tags) LeastI is_zero_row_def' not_zero_i_A')"], ["proof (state)\nthis:\n  A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "have \"Hermite_of_upt_row_i A (Suc k) ass res $ i $ ?n =\n          Hermite_of_row_i ass res A' (from_nat k) $ i $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding Hermite_of_upt_row_i_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<Suc k]) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<k]))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by simp"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "also"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "have \"... = ?M $ i $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    mult_row A' i\n     (ass (A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) div\n      A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding fn_k_i"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A' i $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    mult_row A' i\n     (ass (A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) div\n      A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Hermite_of_row_i_works2[OF not_zero_i_A'])"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  mult_row A' i\n   (ass (A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) div\n    A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) $\n  i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "also"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  mult_row A' i\n   (ass (A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) div\n    A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) $\n  i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_row A' i\n     (ass (A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) div\n      A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)", "using A'_i_l"], ["proof (prove)\nusing this:\n  A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. mult_row A' i\n     (ass (A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) div\n      A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)", "unfolding mult_row_def"], ["proof (prove)\nusing this:\n  A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then ass (A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) div\n             A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b)) *\n             A' $ i $ j\n        else A' $ ia $ j) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)", "by (simp add:  ass_function_0'[OF a]  least_A'_A)"], ["proof (state)\nthis:\n  mult_row A' i\n   (ass (A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) div\n    A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) $\n  i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "finally"], ["proof (chain)\npicking this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "unfolding is_zero_row_def is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < CARD('c) \\<longrightarrow>\n               Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'b))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "case False"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<noteq> k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "hence i_k: \"to_nat i < k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<noteq> k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < k", "by (metis Suc.prems(1) less_antisym)"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "hence i_k2: \"i< from_nat k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat k", "using i_k Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n  mod_type_class.to_nat i < k\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id k_nrows2 nrows_def)"], ["proof (state)\nthis:\n  i < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "have not_zero_i_A': \"\\<not> is_zero_row i A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A'", "unfolding A'_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "by (rule Suc.hyps[OF i_k Suc.prems(2) k_nrows])"], ["proof (state)\nthis:\n  \\<not> is_zero_row i A'\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "proof (cases \"is_zero_row (from_nat k) A'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "case False"], ["proof (state)\nthis:\n  \\<not> is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "have Ain: \"A' $ i $ (LEAST n. A $ i $ n \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)", "unfolding least_A'_A[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)", "by (metis (mono_tags) LeastI is_zero_row_def' not_zero_i_A')"], ["proof (state)\nthis:\n  A' $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "have Akn: \"A' $ (from_nat k) $ (LEAST n. A $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $ mod_type_class.from_nat k $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    (0::'b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A' $ mod_type_class.from_nat k $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    (0::'b)", "have \"(LEAST n. A' $ i $ n \\<noteq> 0) < (LEAST n. A' $ (from_nat k) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))", "by (rule echelon_form_condition2_explicit[OF e i_k2 not_zero_i_A' False])"], ["proof (state)\nthis:\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n  < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. A' $ mod_type_class.from_nat k $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    (0::'b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n  < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. A' $ mod_type_class.from_nat k $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    (0::'b)", "by (metis (mono_tags)  least_A'_A not_less_Least)"], ["proof (state)\nthis:\n  A' $ mod_type_class.from_nat k $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A' $ mod_type_class.from_nat k $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  (0::'b)\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "let ?m=\"(LEAST n. A' $ from_nat k $ n \\<noteq> 0)\""], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "let ?M=\"mult_row A' (from_nat k)\n            (ass (A' $ from_nat k $ ?m) div\n            A' $ from_nat k $ ?m)\""], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "have \"Hermite_of_upt_row_i A (Suc k) ass res $ i $ ?n =\n            Hermite_of_row_i ass res A' (from_nat k) $ i $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding Hermite_of_upt_row_i_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<Suc k]) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<k]))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by simp"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "also"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "have \"... = row_add (mult_row A' (from_nat k)\n            (ass (A' $ from_nat k $ ?m) div A' $ from_nat k $ ?m)) i (from_nat k)\n            ((res (?M $ from_nat k $ ?m) (?M $ i $ ?m) - ?M $ i $ ?m) div ?M $ from_nat k $ ?m) $ i $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    row_add\n     (mult_row A' (mod_type_class.from_nat k)\n       (ass (A' $ mod_type_class.from_nat k $\n             (LEAST n.\n                 A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n        A' $ mod_type_class.from_nat k $\n        (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))))\n     i (mod_type_class.from_nat k)\n     ((res (mult_row A' (mod_type_class.from_nat k)\n             (ass (A' $ mod_type_class.from_nat k $\n                   (LEAST n.\n                       A' $ mod_type_class.from_nat k $ n \\<noteq>\n                       (0::'b))) div\n              A' $ mod_type_class.from_nat k $\n              (LEAST n.\n                  A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n            mod_type_class.from_nat k $\n            (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b)))\n        (mult_row A' (mod_type_class.from_nat k)\n          (ass (A' $ mod_type_class.from_nat k $\n                (LEAST n.\n                    A' $ mod_type_class.from_nat k $ n \\<noteq>\n                    (0::'b))) div\n           A' $ mod_type_class.from_nat k $\n           (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n         i $\n         (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) -\n       mult_row A' (mod_type_class.from_nat k)\n        (ass (A' $ mod_type_class.from_nat k $\n              (LEAST n.\n                  A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n         A' $ mod_type_class.from_nat k $\n         (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n       i $\n       (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n      mult_row A' (mod_type_class.from_nat k)\n       (ass (A' $ mod_type_class.from_nat k $\n             (LEAST n.\n                 A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n        A' $ mod_type_class.from_nat k $\n        (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n      mod_type_class.from_nat k $\n      (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Hermite_of_row_i_works[OF i_k2 False])"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  row_add\n   (mult_row A' (mod_type_class.from_nat k)\n     (ass (A' $ mod_type_class.from_nat k $\n           (LEAST n.\n               A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n      A' $ mod_type_class.from_nat k $\n      (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))))\n   i (mod_type_class.from_nat k)\n   ((res (mult_row A' (mod_type_class.from_nat k)\n           (ass (A' $ mod_type_class.from_nat k $\n                 (LEAST n.\n                     A' $ mod_type_class.from_nat k $ n \\<noteq>\n                     (0::'b))) div\n            A' $ mod_type_class.from_nat k $\n            (LEAST n.\n                A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n          mod_type_class.from_nat k $\n          (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b)))\n      (mult_row A' (mod_type_class.from_nat k)\n        (ass (A' $ mod_type_class.from_nat k $\n              (LEAST n.\n                  A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n         A' $ mod_type_class.from_nat k $\n         (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n       i $\n       (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) -\n     mult_row A' (mod_type_class.from_nat k)\n      (ass (A' $ mod_type_class.from_nat k $\n            (LEAST n.\n                A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n       A' $ mod_type_class.from_nat k $\n       (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n     i $\n     (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n    mult_row A' (mod_type_class.from_nat k)\n     (ass (A' $ mod_type_class.from_nat k $\n           (LEAST n.\n               A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n      A' $ mod_type_class.from_nat k $\n      (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n    mod_type_class.from_nat k $\n    (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n  i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "also"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  row_add\n   (mult_row A' (mod_type_class.from_nat k)\n     (ass (A' $ mod_type_class.from_nat k $\n           (LEAST n.\n               A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n      A' $ mod_type_class.from_nat k $\n      (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))))\n   i (mod_type_class.from_nat k)\n   ((res (mult_row A' (mod_type_class.from_nat k)\n           (ass (A' $ mod_type_class.from_nat k $\n                 (LEAST n.\n                     A' $ mod_type_class.from_nat k $ n \\<noteq>\n                     (0::'b))) div\n            A' $ mod_type_class.from_nat k $\n            (LEAST n.\n                A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n          mod_type_class.from_nat k $\n          (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b)))\n      (mult_row A' (mod_type_class.from_nat k)\n        (ass (A' $ mod_type_class.from_nat k $\n              (LEAST n.\n                  A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n         A' $ mod_type_class.from_nat k $\n         (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n       i $\n       (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) -\n     mult_row A' (mod_type_class.from_nat k)\n      (ass (A' $ mod_type_class.from_nat k $\n            (LEAST n.\n                A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n       A' $ mod_type_class.from_nat k $\n       (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n     i $\n     (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n    mult_row A' (mod_type_class.from_nat k)\n     (ass (A' $ mod_type_class.from_nat k $\n           (LEAST n.\n               A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n      A' $ mod_type_class.from_nat k $\n      (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n    mod_type_class.from_nat k $\n    (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n  i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add\n     (mult_row A' (mod_type_class.from_nat k)\n       (ass (A' $ mod_type_class.from_nat k $\n             (LEAST n.\n                 A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n        A' $ mod_type_class.from_nat k $\n        (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))))\n     i (mod_type_class.from_nat k)\n     ((res (mult_row A' (mod_type_class.from_nat k)\n             (ass (A' $ mod_type_class.from_nat k $\n                   (LEAST n.\n                       A' $ mod_type_class.from_nat k $ n \\<noteq>\n                       (0::'b))) div\n              A' $ mod_type_class.from_nat k $\n              (LEAST n.\n                  A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n            mod_type_class.from_nat k $\n            (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b)))\n        (mult_row A' (mod_type_class.from_nat k)\n          (ass (A' $ mod_type_class.from_nat k $\n                (LEAST n.\n                    A' $ mod_type_class.from_nat k $ n \\<noteq>\n                    (0::'b))) div\n           A' $ mod_type_class.from_nat k $\n           (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n         i $\n         (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) -\n       mult_row A' (mod_type_class.from_nat k)\n        (ass (A' $ mod_type_class.from_nat k $\n              (LEAST n.\n                  A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n         A' $ mod_type_class.from_nat k $\n         (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n       i $\n       (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n      mult_row A' (mod_type_class.from_nat k)\n       (ass (A' $ mod_type_class.from_nat k $\n             (LEAST n.\n                 A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n        A' $ mod_type_class.from_nat k $\n        (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n      mod_type_class.from_nat k $\n      (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)", "using i_k2 Ain Akn"], ["proof (prove)\nusing this:\n  i < mod_type_class.from_nat k\n  A' $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)\n  A' $ mod_type_class.from_nat k $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  (0::'b)\n\ngoal (1 subgoal):\n 1. row_add\n     (mult_row A' (mod_type_class.from_nat k)\n       (ass (A' $ mod_type_class.from_nat k $\n             (LEAST n.\n                 A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n        A' $ mod_type_class.from_nat k $\n        (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))))\n     i (mod_type_class.from_nat k)\n     ((res (mult_row A' (mod_type_class.from_nat k)\n             (ass (A' $ mod_type_class.from_nat k $\n                   (LEAST n.\n                       A' $ mod_type_class.from_nat k $ n \\<noteq>\n                       (0::'b))) div\n              A' $ mod_type_class.from_nat k $\n              (LEAST n.\n                  A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n            mod_type_class.from_nat k $\n            (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b)))\n        (mult_row A' (mod_type_class.from_nat k)\n          (ass (A' $ mod_type_class.from_nat k $\n                (LEAST n.\n                    A' $ mod_type_class.from_nat k $ n \\<noteq>\n                    (0::'b))) div\n           A' $ mod_type_class.from_nat k $\n           (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n         i $\n         (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) -\n       mult_row A' (mod_type_class.from_nat k)\n        (ass (A' $ mod_type_class.from_nat k $\n              (LEAST n.\n                  A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n         A' $ mod_type_class.from_nat k $\n         (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n       i $\n       (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n      mult_row A' (mod_type_class.from_nat k)\n       (ass (A' $ mod_type_class.from_nat k $\n             (LEAST n.\n                 A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n        A' $ mod_type_class.from_nat k $\n        (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n      mod_type_class.from_nat k $\n      (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)", "unfolding row_add_def mult_row_def"], ["proof (prove)\nusing this:\n  i < mod_type_class.from_nat k\n  A' $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq> (0::'b)\n  A' $ mod_type_class.from_nat k $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia j.\n        if ia = i\n        then (\\<chi>i j.\n                 if i = mod_type_class.from_nat k\n                 then ass (A' $ mod_type_class.from_nat k $\n                           (LEAST n.\n                               A' $ mod_type_class.from_nat k $ n \\<noteq>\n                               (0::'b))) div\n                      A' $ mod_type_class.from_nat k $\n                      (LEAST n.\n                          A' $ mod_type_class.from_nat k $ n \\<noteq>\n                          (0::'b)) *\n                      A' $ mod_type_class.from_nat k $ j\n                 else A' $ i $ j) $\n             i $\n             j +\n             (res ((\\<chi>i j.\n                       if i = mod_type_class.from_nat k\n                       then ass (A' $ mod_type_class.from_nat k $\n                                 (LEAST n.\n                                     A' $ mod_type_class.from_nat k $\n                                     n \\<noteq>\n                                     (0::'b))) div\n                            A' $ mod_type_class.from_nat k $\n                            (LEAST n.\n                                A' $ mod_type_class.from_nat k $ n \\<noteq>\n                                (0::'b)) *\n                            A' $ mod_type_class.from_nat k $ j\n                       else A' $ i $ j) $\n                   mod_type_class.from_nat k $\n                   (LEAST n.\n                       A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b)))\n               ((\\<chi>i j.\n                    if i = mod_type_class.from_nat k\n                    then ass (A' $ mod_type_class.from_nat k $\n                              (LEAST n.\n                                  A' $ mod_type_class.from_nat k $\n                                  n \\<noteq>\n                                  (0::'b))) div\n                         A' $ mod_type_class.from_nat k $\n                         (LEAST n.\n                             A' $ mod_type_class.from_nat k $ n \\<noteq>\n                             (0::'b)) *\n                         A' $ mod_type_class.from_nat k $ j\n                    else A' $ i $ j) $\n                i $\n                (LEAST n.\n                    A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) -\n              (\\<chi>i j.\n                  if i = mod_type_class.from_nat k\n                  then ass (A' $ mod_type_class.from_nat k $\n                            (LEAST n.\n                                A' $ mod_type_class.from_nat k $ n \\<noteq>\n                                (0::'b))) div\n                       A' $ mod_type_class.from_nat k $\n                       (LEAST n.\n                           A' $ mod_type_class.from_nat k $ n \\<noteq>\n                           (0::'b)) *\n                       A' $ mod_type_class.from_nat k $ j\n                  else A' $ i $ j) $\n              i $\n              (LEAST n.\n                  A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n             (\\<chi>i j.\n                 if i = mod_type_class.from_nat k\n                 then ass (A' $ mod_type_class.from_nat k $\n                           (LEAST n.\n                               A' $ mod_type_class.from_nat k $ n \\<noteq>\n                               (0::'b))) div\n                      A' $ mod_type_class.from_nat k $\n                      (LEAST n.\n                          A' $ mod_type_class.from_nat k $ n \\<noteq>\n                          (0::'b)) *\n                      A' $ mod_type_class.from_nat k $ j\n                 else A' $ i $ j) $\n             mod_type_class.from_nat k $\n             (LEAST n.\n                 A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b)) *\n             (\\<chi>i j.\n                 if i = mod_type_class.from_nat k\n                 then ass (A' $ mod_type_class.from_nat k $\n                           (LEAST n.\n                               A' $ mod_type_class.from_nat k $ n \\<noteq>\n                               (0::'b))) div\n                      A' $ mod_type_class.from_nat k $\n                      (LEAST n.\n                          A' $ mod_type_class.from_nat k $ n \\<noteq>\n                          (0::'b)) *\n                      A' $ mod_type_class.from_nat k $ j\n                 else A' $ i $ j) $\n             mod_type_class.from_nat k $\n             j\n        else (\\<chi>i j.\n                 if i = mod_type_class.from_nat k\n                 then ass (A' $ mod_type_class.from_nat k $\n                           (LEAST n.\n                               A' $ mod_type_class.from_nat k $ n \\<noteq>\n                               (0::'b))) div\n                      A' $ mod_type_class.from_nat k $\n                      (LEAST n.\n                          A' $ mod_type_class.from_nat k $ n \\<noteq>\n                          (0::'b)) *\n                      A' $ mod_type_class.from_nat k $ j\n                 else A' $ i $ j) $\n             ia $\n             j) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n    (0::'b)", "by auto"], ["proof (state)\nthis:\n  row_add\n   (mult_row A' (mod_type_class.from_nat k)\n     (ass (A' $ mod_type_class.from_nat k $\n           (LEAST n.\n               A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n      A' $ mod_type_class.from_nat k $\n      (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))))\n   i (mod_type_class.from_nat k)\n   ((res (mult_row A' (mod_type_class.from_nat k)\n           (ass (A' $ mod_type_class.from_nat k $\n                 (LEAST n.\n                     A' $ mod_type_class.from_nat k $ n \\<noteq>\n                     (0::'b))) div\n            A' $ mod_type_class.from_nat k $\n            (LEAST n.\n                A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n          mod_type_class.from_nat k $\n          (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b)))\n      (mult_row A' (mod_type_class.from_nat k)\n        (ass (A' $ mod_type_class.from_nat k $\n              (LEAST n.\n                  A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n         A' $ mod_type_class.from_nat k $\n         (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n       i $\n       (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) -\n     mult_row A' (mod_type_class.from_nat k)\n      (ass (A' $ mod_type_class.from_nat k $\n            (LEAST n.\n                A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n       A' $ mod_type_class.from_nat k $\n       (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n     i $\n     (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n    mult_row A' (mod_type_class.from_nat k)\n     (ass (A' $ mod_type_class.from_nat k $\n           (LEAST n.\n               A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) div\n      A' $ mod_type_class.from_nat k $\n      (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n    mod_type_class.from_nat k $\n    (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))) $\n  i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "finally"], ["proof (chain)\npicking this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "unfolding is_zero_row_def is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < CARD('c) \\<longrightarrow>\n               Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'b))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n\ngoal (1 subgoal):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "case True"], ["proof (state)\nthis:\n  is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (1 subgoal):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "have \"Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res =\n    Hermite_of_upt_row_i A k ass res", "using True"], ["proof (prove)\nusing this:\n  is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res =\n    Hermite_of_upt_row_i A k ass res", "by (simp add:  Hermite_of_upt_row_i_def Hermite_of_row_i_def A'_def Let_def)"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\n\ngoal (1 subgoal):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "using not_zero_i_A'"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\n  \\<not> is_zero_row i A'\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "unfolding A'_def2"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "by simp"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_upt_row_i_in_range:\n  fixes k ass res\n  assumes not_zero_i_A: \"\\<not> is_zero_row i A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and k: \"to_nat i<k\"\n  and k2: \"k\\<le>nrows A\"\n  shows \"Hermite_of_upt_row_i A k ass res $ i $ (LEAST n. A $ i $ n \\<noteq> 0) \\<in> range ass\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A k ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "using k not_zero_i_A k2"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n  \\<not> is_zero_row i A\n  k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A k ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>mod_type_class.to_nat i < 0; \\<not> is_zero_row i A;\n     0 \\<le> nrows A\\<rbrakk>\n    \\<Longrightarrow> Hermite_of_upt_row_i A 0 ass res $ i $\n                      (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                      \\<in> range ass\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "case 0"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < 0\n  \\<not> is_zero_row i A\n  0 \\<le> nrows A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mod_type_class.to_nat i < 0; \\<not> is_zero_row i A;\n     0 \\<le> nrows A\\<rbrakk>\n    \\<Longrightarrow> Hermite_of_upt_row_i A 0 ass res $ i $\n                      (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                      \\<in> range ass\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "thus ?case"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < 0\n  \\<not> is_zero_row i A\n  0 \\<le> nrows A\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A 0 ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "by auto"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A 0 ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range ass\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>mod_type_class.to_nat i < k; \\<not> is_zero_row i A;\n   k \\<le> nrows A\\<rbrakk>\n  \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                    \\<in> range ass\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "have k: \"k\\<le>nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> nrows A", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. k \\<le> nrows A", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> CARD('a)\n\ngoal (1 subgoal):\n 1. k \\<le> CARD('a)", "by simp"], ["proof (state)\nthis:\n  k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "have k2: \"k<nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < nrows A", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. k < nrows A", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> CARD('a)\n\ngoal (1 subgoal):\n 1. k < CARD('a)", "by simp"], ["proof (state)\nthis:\n  k < nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "define A' where \"A' = foldl (Hermite_of_row_i ass res) A (map from_nat [0..<k])\""], ["proof (state)\nthis:\n  A' =\n  foldl (Hermite_of_row_i ass res) A (map mod_type_class.from_nat [0..<k])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "have A'_def2: \"A' = Hermite_of_upt_row_i A k ass res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = Hermite_of_upt_row_i A k ass res", "unfolding Hermite_of_upt_row_i_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<k]) =\n    foldl (Hermite_of_row_i ass res) A (map mod_type_class.from_nat [0..<k])", ".."], ["proof (state)\nthis:\n  A' = Hermite_of_upt_row_i A k ass res\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "define M where \"M = mult_row A' i (ass (A' $ i $ (LEAST n. A' $ i $ n \\<noteq> 0)) div A' $ i $ (LEAST n. A' $ i $ n \\<noteq> 0))\""], ["proof (state)\nthis:\n  M =\n  mult_row A' i\n   (ass (A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) div\n    A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "have not_zero_A': \"\\<not> is_zero_row i A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A'", "using Hermite_of_upt_row_preserves_nonzero_rows[OF not_zero_i_A e a r k]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A'", "unfolding A'_def Hermite_of_upt_row_i_def"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i\n          (foldl (Hermite_of_row_i ass res) A\n            (map mod_type_class.from_nat [0..<k]))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i\n            (foldl (Hermite_of_row_i ass res) A\n              (map mod_type_class.from_nat [0..<k]))", "by simp"], ["proof (state)\nthis:\n  \\<not> is_zero_row i A'\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "have e_A': \"echelon_form A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form A'", "by (metis A'_def a e echelon_form_fold_Hermite_of_row_i r)"], ["proof (state)\nthis:\n  echelon_form A'\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "have least_eq: \"(LEAST n. (Hermite_of_row_i ass res A' i) $ i $ n \\<noteq> 0) = (LEAST n. A' $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A' i $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A' $ i $ n \\<noteq> (0::'b))", "by (rule Least_Hermite_of_row_i[OF not_zero_A' e_A' a])"], ["proof (state)\nthis:\n  (LEAST n. Hermite_of_row_i ass res A' i $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "have least_eq2: \"(LEAST n. A' $ i $ n \\<noteq> 0) = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A' $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding A'_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Hermite_of_upt_row_i_Least[OF not_zero_i_A e a r k])"], ["proof (state)\nthis:\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range ass;\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range ass", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "proof (cases \"to_nat i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat i = k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "have fn_k_i: \"from_nat k = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = i", "by (metis True from_nat_to_nat_id)"], ["proof (state)\nthis:\n  mod_type_class.from_nat k = i\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "have \"(Hermite_of_upt_row_i A (Suc k) ass res) $ i $ (LEAST n. A $ i $ n \\<noteq> 0) = \n      (Hermite_of_row_i ass res A' i) $ i $ (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res A' i $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding Hermite_of_upt_row_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<Suc k]) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res A' i $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (simp add: A'_def fn_k_i)"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' i $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "also"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' i $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "have \"... = (Hermite_of_row_i ass res A' i) $ i $ (LEAST n. (Hermite_of_row_i ass res A' i) $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A' i $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res A' i $ i $\n    (LEAST n. Hermite_of_row_i ass res A' i $ i $ n \\<noteq> (0::'b))", "unfolding least_eq least_eq2"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A' i $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res A' i $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", ".."], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' i $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' i $ i $\n  (LEAST n. Hermite_of_row_i ass res A' i $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "also"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' i $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' i $ i $\n  (LEAST n. Hermite_of_row_i ass res A' i $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "have \"... \\<in> range ass\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A' i $ i $\n    (LEAST n. Hermite_of_row_i ass res A' i $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "by (rule in_ass_Hermite_of_row[OF a r not_zero_A'])"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' i $ i $\n  (LEAST n. Hermite_of_row_i ass res A' i $ i $ n \\<noteq> (0::'b))\n  \\<in> range ass\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "finally"], ["proof (chain)\npicking this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range ass", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range ass\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "."], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range ass\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "case False"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<noteq> k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "hence i_less_k: \"to_nat i < k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<noteq> k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < k", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<noteq> k\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < k", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "hence i_less_k2: \"i < from_nat k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat k", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id k2 nrows_def)"], ["proof (state)\nthis:\n  i < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "proof (cases \"is_zero_row (from_nat k) A'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "case True"], ["proof (state)\nthis:\n  is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "have \"Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res =\n    Hermite_of_upt_row_i A k ass res", "using True"], ["proof (prove)\nusing this:\n  is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res =\n    Hermite_of_upt_row_i A k ass res", "by (simp add:  Hermite_of_upt_row_i_def Hermite_of_row_i_def A'_def Let_def )"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "thus ?thesis"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "using Suc.hyps not_zero_i_A k i_less_k"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\n  \\<lbrakk>mod_type_class.to_nat i < k; \\<not> is_zero_row i A;\n   k \\<le> nrows A\\<rbrakk>\n  \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                    \\<in> range ass\n  \\<not> is_zero_row i A\n  k \\<le> nrows A\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "by auto"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range ass\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "case False"], ["proof (state)\nthis:\n  \\<not> is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "have \"(Hermite_of_upt_row_i A (Suc k) ass res) $ i $ (LEAST n. A $ i $ n \\<noteq> 0)\n        = (Hermite_of_row_i ass res A' (from_nat k)) $ i $ (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding Hermite_of_upt_row_i_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<Suc k]) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<k]))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by auto"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "also"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "have \"... = A' $ i $ (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    A' $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))", "proof (rule Hermite_of_row_preserves_previous_cols[OF _ False e_A'])"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))", "show \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))", "unfolding least_eq2[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))", "by (rule echelon_form_condition2_explicit[OF e_A' i_less_k2 not_zero_A' False])"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  A' $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "also"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  A' $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "have \"... \\<in> range ass\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<in> range ass", "unfolding A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<k]) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "using Suc.prems Suc.hyps"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n  \\<lbrakk>mod_type_class.to_nat i < k; \\<not> is_zero_row i A;\n   k \\<le> nrows A\\<rbrakk>\n  \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ i $\n                    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                    \\<in> range ass\n\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<k]) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "unfolding Hermite_of_upt_row_i_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n  \\<lbrakk>mod_type_class.to_nat i < k; \\<not> is_zero_row i A;\n   k \\<le> nrows A\\<rbrakk>\n  \\<Longrightarrow> foldl (Hermite_of_row_i ass res) A\n                     (map mod_type_class.from_nat [0..<k]) $\n                    i $\n                    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                    \\<in> range ass\n\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<k]) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "using i_less_k"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n  \\<lbrakk>mod_type_class.to_nat i < k; \\<not> is_zero_row i A;\n   k \\<le> nrows A\\<rbrakk>\n  \\<Longrightarrow> foldl (Hermite_of_row_i ass res) A\n                     (map mod_type_class.from_nat [0..<k]) $\n                    i $\n                    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                    \\<in> range ass\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<k]) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "by auto"], ["proof (state)\nthis:\n  A' $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) \\<in> range ass\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "finally"], ["proof (chain)\npicking this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range ass", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range ass\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range ass", "."], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range ass\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range ass\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range ass\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_upt_row_preserves_zero_rows_ge:\n  assumes i: \"is_zero_row i A\"\n  and k: \"k \\<le> nrows A\"\n  and ik: \"to_nat i\\<ge>k\"\n  shows \"is_zero_row i (Hermite_of_upt_row_i A k ass res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row i (Hermite_of_upt_row_i A k ass res)", "proof (unfold is_zero_row_def', clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. Hermite_of_upt_row_i A k ass res $ i $ j = (0::'b)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. Hermite_of_upt_row_i A k ass res $ i $ j = (0::'b)", "have \"Hermite_of_upt_row_i A k ass res $ i $ j = A $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A k ass res $ i $ j = A $ i $ j", "by (metis Hermite_of_upt_row_preserves_below ik)"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A k ass res $ i $ j = A $ i $ j\n\ngoal (1 subgoal):\n 1. \\<And>j. Hermite_of_upt_row_i A k ass res $ i $ j = (0::'b)", "also"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A k ass res $ i $ j = A $ i $ j\n\ngoal (1 subgoal):\n 1. \\<And>j. Hermite_of_upt_row_i A k ass res $ i $ j = (0::'b)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'b)", "using i"], ["proof (prove)\nusing this:\n  is_zero_row i A\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'b)", "unfolding is_zero_row_def is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < CARD('c) \\<longrightarrow>\n     A $ i $ j = (0::'b)\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'b)", "by simp"], ["proof (state)\nthis:\n  A $ i $ j = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>j. Hermite_of_upt_row_i A k ass res $ i $ j = (0::'b)", "finally"], ["proof (chain)\npicking this:\n  Hermite_of_upt_row_i A k ass res $ i $ j = (0::'b)", "show \"Hermite_of_upt_row_i A k ass res $ i $ j = 0\""], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A k ass res $ i $ j = (0::'b)\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A k ass res $ i $ j = (0::'b)", "."], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A k ass res $ i $ j = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_upt_row_preserves_zero_rows:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes i: \"is_zero_row i A\"\n  and e: \"echelon_form A\" and a: \"ass_function ass\" and r: \"res_function res\" and k: \"k \\<le> nrows A\"\n  shows \"is_zero_row i (Hermite_of_upt_row_i A k ass res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row i (Hermite_of_upt_row_i A k ass res)", "proof (cases \"to_nat i\\<ge>k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    is_zero_row i (Hermite_of_upt_row_i A k ass res)\n 2. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    is_zero_row i (Hermite_of_upt_row_i A k ass res)", "case True"], ["proof (state)\nthis:\n  k \\<le> mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    is_zero_row i (Hermite_of_upt_row_i A k ass res)\n 2. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    is_zero_row i (Hermite_of_upt_row_i A k ass res)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row i (Hermite_of_upt_row_i A k ass res)", "by (rule Hermite_of_upt_row_preserves_zero_rows_ge[OF i k True])"], ["proof (state)\nthis:\n  is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    is_zero_row i (Hermite_of_upt_row_i A k ass res)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    is_zero_row i (Hermite_of_upt_row_i A k ass res)", "case False"], ["proof (state)\nthis:\n  \\<not> k \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    is_zero_row i (Hermite_of_upt_row_i A k ass res)", "hence i_k: \"to_nat i < k\""], ["proof (prove)\nusing this:\n  \\<not> k \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n    is_zero_row i (Hermite_of_upt_row_i A k ass res)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row i (Hermite_of_upt_row_i A k ass res)", "using k i_k"], ["proof (prove)\nusing this:\n  k \\<le> nrows A\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. is_zero_row i (Hermite_of_upt_row_i A k ass res)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> nrows A; mod_type_class.to_nat i < 0\\<rbrakk>\n    \\<Longrightarrow> is_zero_row i (Hermite_of_upt_row_i A 0 ass res)\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k \\<le> nrows A;\n                 mod_type_class.to_nat i < k\\<rbrakk>\n                \\<Longrightarrow> is_zero_row i\n                                   (Hermite_of_upt_row_i A k ass res);\n        Suc k \\<le> nrows A; mod_type_class.to_nat i < Suc k\\<rbrakk>\n       \\<Longrightarrow> is_zero_row i\n                          (Hermite_of_upt_row_i A (Suc k) ass res)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> nrows A\n  mod_type_class.to_nat i < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> nrows A; mod_type_class.to_nat i < 0\\<rbrakk>\n    \\<Longrightarrow> is_zero_row i (Hermite_of_upt_row_i A 0 ass res)\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k \\<le> nrows A;\n                 mod_type_class.to_nat i < k\\<rbrakk>\n                \\<Longrightarrow> is_zero_row i\n                                   (Hermite_of_upt_row_i A k ass res);\n        Suc k \\<le> nrows A; mod_type_class.to_nat i < Suc k\\<rbrakk>\n       \\<Longrightarrow> is_zero_row i\n                          (Hermite_of_upt_row_i A (Suc k) ass res)", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le> nrows A\n  mod_type_class.to_nat i < 0\n\ngoal (1 subgoal):\n 1. is_zero_row i (Hermite_of_upt_row_i A 0 ass res)", "unfolding Hermite_of_upt_row_i_def"], ["proof (prove)\nusing this:\n  0 \\<le> nrows A\n  mod_type_class.to_nat i < 0\n\ngoal (1 subgoal):\n 1. is_zero_row i\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<0]))", "by (simp add: i)"], ["proof (state)\nthis:\n  is_zero_row i (Hermite_of_upt_row_i A 0 ass res)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k \\<le> nrows A;\n                 mod_type_class.to_nat i < k\\<rbrakk>\n                \\<Longrightarrow> is_zero_row i\n                                   (Hermite_of_upt_row_i A k ass res);\n        Suc k \\<le> nrows A; mod_type_class.to_nat i < Suc k\\<rbrakk>\n       \\<Longrightarrow> is_zero_row i\n                          (Hermite_of_upt_row_i A (Suc k) ass res)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k \\<le> nrows A;\n                 mod_type_class.to_nat i < k\\<rbrakk>\n                \\<Longrightarrow> is_zero_row i\n                                   (Hermite_of_upt_row_i A k ass res);\n        Suc k \\<le> nrows A; mod_type_class.to_nat i < Suc k\\<rbrakk>\n       \\<Longrightarrow> is_zero_row i\n                          (Hermite_of_upt_row_i A (Suc k) ass res)", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>k \\<le> nrows A; mod_type_class.to_nat i < k\\<rbrakk>\n  \\<Longrightarrow> is_zero_row i (Hermite_of_upt_row_i A k ass res)\n  Suc k \\<le> nrows A\n  mod_type_class.to_nat i < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k \\<le> nrows A;\n                 mod_type_class.to_nat i < k\\<rbrakk>\n                \\<Longrightarrow> is_zero_row i\n                                   (Hermite_of_upt_row_i A k ass res);\n        Suc k \\<le> nrows A; mod_type_class.to_nat i < Suc k\\<rbrakk>\n       \\<Longrightarrow> is_zero_row i\n                          (Hermite_of_upt_row_i A (Suc k) ass res)", "have k: \"k\\<le>nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> nrows A", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc k \\<le> nrows A\n  mod_type_class.to_nat i < Suc k\n\ngoal (1 subgoal):\n 1. k \\<le> nrows A", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  Suc k \\<le> CARD('rows)\n  mod_type_class.to_nat i < Suc k\n\ngoal (1 subgoal):\n 1. k \\<le> CARD('rows)", "by auto"], ["proof (state)\nthis:\n  k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k \\<le> nrows A;\n                 mod_type_class.to_nat i < k\\<rbrakk>\n                \\<Longrightarrow> is_zero_row i\n                                   (Hermite_of_upt_row_i A k ass res);\n        Suc k \\<le> nrows A; mod_type_class.to_nat i < Suc k\\<rbrakk>\n       \\<Longrightarrow> is_zero_row i\n                          (Hermite_of_upt_row_i A (Suc k) ass res)", "have k2: \"k<nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < nrows A", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc k \\<le> nrows A\n  mod_type_class.to_nat i < Suc k\n\ngoal (1 subgoal):\n 1. k < nrows A", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  Suc k \\<le> CARD('rows)\n  mod_type_class.to_nat i < Suc k\n\ngoal (1 subgoal):\n 1. k < CARD('rows)", "by simp"], ["proof (state)\nthis:\n  k < nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k \\<le> nrows A;\n                 mod_type_class.to_nat i < k\\<rbrakk>\n                \\<Longrightarrow> is_zero_row i\n                                   (Hermite_of_upt_row_i A k ass res);\n        Suc k \\<le> nrows A; mod_type_class.to_nat i < Suc k\\<rbrakk>\n       \\<Longrightarrow> is_zero_row i\n                          (Hermite_of_upt_row_i A (Suc k) ass res)", "define A' where \"A' = foldl (Hermite_of_row_i ass res) A (map from_nat [0..<k])\""], ["proof (state)\nthis:\n  A' =\n  foldl (Hermite_of_row_i ass res) A (map mod_type_class.from_nat [0..<k])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k \\<le> nrows A;\n                 mod_type_class.to_nat i < k\\<rbrakk>\n                \\<Longrightarrow> is_zero_row i\n                                   (Hermite_of_upt_row_i A k ass res);\n        Suc k \\<le> nrows A; mod_type_class.to_nat i < Suc k\\<rbrakk>\n       \\<Longrightarrow> is_zero_row i\n                          (Hermite_of_upt_row_i A (Suc k) ass res)", "have A'_def2: \"A' = Hermite_of_upt_row_i A k ass res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = Hermite_of_upt_row_i A k ass res", "unfolding Hermite_of_upt_row_i_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<k]) =\n    foldl (Hermite_of_row_i ass res) A (map mod_type_class.from_nat [0..<k])", ".."], ["proof (state)\nthis:\n  A' = Hermite_of_upt_row_i A k ass res\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k \\<le> nrows A;\n                 mod_type_class.to_nat i < k\\<rbrakk>\n                \\<Longrightarrow> is_zero_row i\n                                   (Hermite_of_upt_row_i A k ass res);\n        Suc k \\<le> nrows A; mod_type_class.to_nat i < Suc k\\<rbrakk>\n       \\<Longrightarrow> is_zero_row i\n                          (Hermite_of_upt_row_i A (Suc k) ass res)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)", "unfolding is_zero_row_def'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j. Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "proof (clarify, cases \"to_nat i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       mod_type_class.to_nat i = k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n 2. \\<And>j.\n       mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       mod_type_class.to_nat i = k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n 2. \\<And>j.\n       mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat i = k\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       mod_type_class.to_nat i = k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n 2. \\<And>j.\n       mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "have fn_k_i: \"from_nat k = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = i", "by (metis True from_nat_to_nat_id)"], ["proof (state)\nthis:\n  mod_type_class.from_nat k = i\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       mod_type_class.to_nat i = k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n 2. \\<And>j.\n       mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "have \"(Hermite_of_upt_row_i A (Suc k) ass res) = \n        (Hermite_of_row_i ass res A' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_row_i ass res A' i", "unfolding Hermite_of_upt_row_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<Suc k]) =\n    Hermite_of_row_i ass res A' i", "by (simp add: A'_def fn_k_i)"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_row_i ass res A' i\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       mod_type_class.to_nat i = k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n 2. \\<And>j.\n       mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "moreover"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_row_i ass res A' i\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       mod_type_class.to_nat i = k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n 2. \\<And>j.\n       mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "have \"is_zero_row i (Hermite_of_upt_row_i A k ass res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row i (Hermite_of_upt_row_i A k ass res)", "by (rule Hermite_of_upt_row_preserves_zero_rows_ge[OF i k], simp add: True)"], ["proof (state)\nthis:\n  is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       mod_type_class.to_nat i = k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n 2. \\<And>j.\n       mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_row_i ass res A' i\n  is_zero_row i (Hermite_of_upt_row_i A k ass res)", "show \"(Hermite_of_upt_row_i A (Suc k) ass res) $ i $ j = 0\""], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_row_i ass res A' i\n  is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "unfolding is_zero_row_def' A'_def2 Hermite_of_row_i_def"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res =\n  (if \\<forall>j. Hermite_of_upt_row_i A k ass res $ i $ j = (0::'a)\n   then Hermite_of_upt_row_i A k ass res\n   else let j = LEAST n.\n                   Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq>\n                   (0::'a);\n            Aij = Hermite_of_upt_row_i A k ass res $ i $ j;\n            A' = mult_row (Hermite_of_upt_row_i A k ass res) i\n                  (ass Aij div Aij)\n        in Hermite_reduce_above A' (mod_type_class.to_nat i) i j res)\n  \\<forall>j. Hermite_of_upt_row_i A k ass res $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "by auto"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "case False"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<noteq> k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "hence i_less_k: \"to_nat i < k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<noteq> k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < k", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<noteq> k\n  Suc k \\<le> nrows A\n  mod_type_class.to_nat i < Suc k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < k", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "hence i_less_k2: \"i < from_nat k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat k", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n  Suc k \\<le> nrows A\n  mod_type_class.to_nat i < Suc k\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id k2 nrows_def)"], ["proof (state)\nthis:\n  i < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n       Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "show \"(Hermite_of_upt_row_i A (Suc k) ass res) $ i $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "proof (cases \"is_zero_row (from_nat k) A'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "case True"], ["proof (state)\nthis:\n  is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "have \"is_zero_row i (Hermite_of_upt_row_i A k ass res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row i (Hermite_of_upt_row_i A k ass res)", "by (metis Suc.hyps i_less_k k)"], ["proof (state)\nthis:\n  is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "moreover"], ["proof (state)\nthis:\n  is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "have \"Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = Hermite_of_upt_row_i A k ass res $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $ j =\n    Hermite_of_upt_row_i A k ass res $ i $ j", "using True"], ["proof (prove)\nusing this:\n  is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $ j =\n    Hermite_of_upt_row_i A k ass res $ i $ j", "by (simp add:  Hermite_of_upt_row_i_def Hermite_of_row_i_def A'_def Let_def)"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $ j =\n  Hermite_of_upt_row_i A k ass res $ i $ j\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  is_zero_row i (Hermite_of_upt_row_i A k ass res)\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $ j =\n  Hermite_of_upt_row_i A k ass res $ i $ j", "show ?thesis"], ["proof (prove)\nusing this:\n  is_zero_row i (Hermite_of_upt_row_i A k ass res)\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $ j =\n  Hermite_of_upt_row_i A k ass res $ i $ j\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "unfolding is_zero_row_def'"], ["proof (prove)\nusing this:\n  \\<forall>j. Hermite_of_upt_row_i A k ass res $ i $ j = (0::'a)\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $ j =\n  Hermite_of_upt_row_i A k ass res $ i $ j\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "by auto"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "have \"is_zero_row i (Hermite_of_upt_row_i A k ass res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row i (Hermite_of_upt_row_i A k ass res)", "by (metis Suc.hyps i_less_k k)"], ["proof (state)\nthis:\n  is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "moreover"], ["proof (state)\nthis:\n  is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "have \"\\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "using echelon_form_condition1"], ["proof (prove)\nusing this:\n  echelon_form ?A \\<Longrightarrow>\n  \\<forall>i.\n     is_zero_row i ?A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row j ?A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "by (metis A'_def2 False e a r echelon_form_Hermite_of_upt_row_i i_less_k2)"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  is_zero_row i (Hermite_of_upt_row_i A k ass res)\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_zero_row i (Hermite_of_upt_row_i A k ass res)\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)", "by contradiction"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row i (Hermite_of_upt_row_i A (Suc k) ass res)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_preserves_zero_rows:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes i: \"is_zero_row i (echelon_form_of A bezout)\"\n  and a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  shows \"is_zero_row i (Hermite_of A ass res bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row i (Hermite_of A ass res bezout)", "unfolding Hermite_of_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row i\n     (Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res)", "by (rule Hermite_of_upt_row_preserves_zero_rows[OF i echelon_form_echelon_form_of[OF b] a r]) \n(auto simp add: nrows_def)"], ["", "lemma Hermite_of_Least:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes i: \"\\<not> is_zero_row i (Hermite_of A ass res bezout)\"\n  and a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  shows \"(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> 0) = (LEAST n. (echelon_form_of A bezout) $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a)) =\n    (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a)) =\n    (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))", "have non_zero_i_eA: \"\\<not> is_zero_row i (echelon_form_of A bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (echelon_form_of A bezout)", "using Hermite_of_preserves_zero_rows[OF _ a r b] i"], ["proof (prove)\nusing this:\n  is_zero_row ?i (echelon_form_of ?A bezout) \\<Longrightarrow>\n  is_zero_row ?i (Hermite_of ?A ass res bezout)\n  \\<not> is_zero_row i (Hermite_of A ass res bezout)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (echelon_form_of A bezout)", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (echelon_form_of A bezout)\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a)) =\n    (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))", "have e: \"echelon_form (echelon_form_of A bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (echelon_form_of A bezout)", "by (rule echelon_form_echelon_form_of[OF b])"], ["proof (state)\nthis:\n  echelon_form (echelon_form_of A bezout)\n\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a)) =\n    (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a)) =\n    (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))", "unfolding Hermite_of_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))", "by (rule Hermite_of_upt_row_i_Least[OF non_zero_i_eA e a r], simp add: nrows_def)"], ["proof (state)\nthis:\n  (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a)) =\n  (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_associates_Hermite_of:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  and i: \"\\<not> is_zero_row i (Hermite_of A ass res bezout)\"\n  shows \"Hermite_of A ass res bezout $ i $ (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> 0) \\<in> range ass\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ i $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range ass", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ i $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range ass", "have non_zero_i_eA: \"\\<not> is_zero_row i (echelon_form_of A bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (echelon_form_of A bezout)", "using Hermite_of_preserves_zero_rows[OF _ a r b] i"], ["proof (prove)\nusing this:\n  is_zero_row ?i (echelon_form_of ?A bezout) \\<Longrightarrow>\n  is_zero_row ?i (Hermite_of ?A ass res bezout)\n  \\<not> is_zero_row i (Hermite_of A ass res bezout)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (echelon_form_of A bezout)", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (echelon_form_of A bezout)\n\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ i $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range ass", "have e: \"echelon_form (echelon_form_of A bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (echelon_form_of A bezout)", "by (rule echelon_form_echelon_form_of[OF b])"], ["proof (state)\nthis:\n  echelon_form (echelon_form_of A bezout)\n\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ i $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range ass", "have least: \"(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> 0) = (LEAST n. (echelon_form_of A bezout) $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a)) =\n    (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))", "by (rule Hermite_of_Least[OF i a r b])"], ["proof (state)\nthis:\n  (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a)) =\n  (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ i $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range ass", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ i $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range ass", "unfolding least"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ i $\n    (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range ass", "unfolding Hermite_of_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res $ i $\n    (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range ass", "by (rule Hermite_of_upt_row_i_in_range[OF non_zero_i_eA e a r])\n       (auto simp add: to_nat_less_card nrows_def)"], ["proof (state)\nthis:\n  Hermite_of A ass res bezout $ i $\n  (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n  \\<in> range ass\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_row_i_range_res:\n  assumes ji: \"j<i\" and not_zero_i_A: \"\\<not> is_zero_row i A\" and r: \"res_function res\"\n  shows \"Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> 0) \n  \\<in> range (res (Hermite_of_row_i ass res A i $ i $ (LEAST n. A $ i $ n \\<noteq> 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_row_i ass res A i $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_row_i ass res A i $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "let ?n=\"(LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_row_i ass res A i $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "define M where \"M = mult_row A i (ass (A $ i $ ?n) div A $ i $ ?n)\""], ["proof (state)\nthis:\n  M =\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)))\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_row_i ass res A i $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "let ?R=\"row_add M j i ((res (M $ i $ ?n) (M $ j $ ?n) \n    - M $ j $ ?n) div M $ i $ ?n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_row_i ass res A i $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have Hii: \"Hermite_of_row_i ass res A i $ i $ ?n = M $ i $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Hermite_of_row_i_works2[OF not_zero_i_A])"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A i $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_row_i ass res A i $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have rw: \"Hermite_of_row_i ass res A i $ j $ ?n = ?R $ j $ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    row_add M j i\n     ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)))\n        (M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) -\n       M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    row_add\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n     j i\n     ((res (mult_row A i\n             (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n              A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n            i $\n            (LEAST n. A $ i $ n \\<noteq> (0::'b)))\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n         j $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))) -\n       mult_row A i\n        (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n         A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n       j $\n       (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n      mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n      i $\n      (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n    j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Hermite_of_row_i_works[OF ji not_zero_i_A])"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  row_add M j i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)))\n      (M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) -\n     M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n  j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_row_i ass res A i $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_row_i ass res A i $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_row_i ass res A i $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have \"\\<forall>b ba. \\<exists>bb. ba + bb * b = res b ba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b ba. \\<exists>bb. ba + bb * b = res b ba", "using r"], ["proof (prove)\nusing this:\n  res_function res\n\ngoal (1 subgoal):\n 1. \\<forall>b ba. \\<exists>bb. ba + bb * b = res b ba", "unfolding res_function_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     (\\<forall>a b. cong a b c = (res c a = res c b)) \\<and>\n     pairwise (\\<lambda>a b. \\<not> cong a b c) (range (res c)) \\<and>\n     (\\<forall>a. \\<exists>k. res c a = a + k * c)\n\ngoal (1 subgoal):\n 1. \\<forall>b ba. \\<exists>bb. ba + bb * b = res b ba", "by metis"], ["proof (state)\nthis:\n  \\<forall>b ba. \\<exists>bb. ba + bb * b = res b ba\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_row_i ass res A i $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>b ba. \\<exists>bb. ba + bb * b = res b ba\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_row_i ass res A i $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "using rw"], ["proof (prove)\nusing this:\n  \\<forall>b ba. \\<exists>bb. ba + bb * b = res b ba\n  Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  row_add M j i\n   ((res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)))\n      (M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) -\n     M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n    M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) $\n  j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_row_i ass res A i $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "unfolding image_def Hii row_add_def"], ["proof (prove)\nusing this:\n  \\<forall>b ba. \\<exists>bb. ba + bb * b = res b ba\n  Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  (\\<chi>ia ja.\n      if ia = j\n      then M $ j $ ja +\n           (res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)))\n             (M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) -\n            M $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) div\n           M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b)) *\n           M $ i $ ja\n      else M $ ia $ ja) $\n  j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> {y. \\<exists>x\\<in>UNIV.\n                 y = res (M $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))) x}", "by auto\n      (metis (lifting) add_diff_cancel_left' nonzero_mult_div_cancel_left mult.commute mult_eq_0_iff)"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_row_i ass res A i $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_row_i ass res A i $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_of_upt_row_i_in_range_res:\n  fixes k ass res\n  assumes not_zero_i_A: \"\\<not> is_zero_row i A\"\n  and e: \"echelon_form A\"\n  and a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and k: \"to_nat i<k\"\n  and k2: \"k\\<le>nrows A\"\n  and j: \"j<i\"\n  shows \"Hermite_of_upt_row_i A k ass res $ j $ (LEAST n. A $ i $ n \\<noteq> 0) \n  \\<in> range (res (Hermite_of_upt_row_i A k ass res $ i $ (LEAST n. A $ i $ n \\<noteq> 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A k ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A k ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "using k not_zero_i_A k2"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n  \\<not> is_zero_row i A\n  k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A k ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A k ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>mod_type_class.to_nat i < 0; \\<not> is_zero_row i A;\n     0 \\<le> nrows A\\<rbrakk>\n    \\<Longrightarrow> Hermite_of_upt_row_i A 0 ass res $ j $\n                      (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                      \\<in> range\n                             (res (Hermite_of_upt_row_i A 0 ass res $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "case 0"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < 0\n  \\<not> is_zero_row i A\n  0 \\<le> nrows A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mod_type_class.to_nat i < 0; \\<not> is_zero_row i A;\n     0 \\<le> nrows A\\<rbrakk>\n    \\<Longrightarrow> Hermite_of_upt_row_i A 0 ass res $ j $\n                      (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                      \\<in> range\n                             (res (Hermite_of_upt_row_i A 0 ass res $ i $\n                                   (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "thus ?case"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < 0\n  \\<not> is_zero_row i A\n  0 \\<le> nrows A\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A 0 ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A 0 ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "by auto"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A 0 ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_upt_row_i A 0 ass res $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>mod_type_class.to_nat i < k; \\<not> is_zero_row i A;\n   k \\<le> nrows A\\<rbrakk>\n  \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                    \\<in> range\n                           (res (Hermite_of_upt_row_i A k ass res $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "let ?n=\"(LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have k: \"k\\<le>nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> nrows A", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. k \\<le> nrows A", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> CARD('a)\n\ngoal (1 subgoal):\n 1. k \\<le> CARD('a)", "by simp"], ["proof (state)\nthis:\n  k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have k2: \"k<nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < nrows A", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. k < nrows A", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> CARD('a)\n\ngoal (1 subgoal):\n 1. k < CARD('a)", "by simp"], ["proof (state)\nthis:\n  k < nrows A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "define A' where \"A' = foldl (Hermite_of_row_i ass res) A (map from_nat [0..<k])\""], ["proof (state)\nthis:\n  A' =\n  foldl (Hermite_of_row_i ass res) A (map mod_type_class.from_nat [0..<k])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have A'_def2: \"A' = Hermite_of_upt_row_i A k ass res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = Hermite_of_upt_row_i A k ass res", "unfolding Hermite_of_upt_row_i_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<k]) =\n    foldl (Hermite_of_row_i ass res) A (map mod_type_class.from_nat [0..<k])", ".."], ["proof (state)\nthis:\n  A' = Hermite_of_upt_row_i A k ass res\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "define M where \"M = mult_row A' i (ass (A' $ i $ (LEAST n. A' $ i $ n \\<noteq> 0)) div A' $ i $ (LEAST n. A' $ i $ n \\<noteq> 0))\""], ["proof (state)\nthis:\n  M =\n  mult_row A' i\n   (ass (A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))) div\n    A' $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have not_zero_A': \"\\<not> is_zero_row i A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A'", "using Hermite_of_upt_row_preserves_nonzero_rows[OF not_zero_i_A e a r k]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i (Hermite_of_upt_row_i A k ass res)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A'", "unfolding A'_def Hermite_of_upt_row_i_def"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i\n          (foldl (Hermite_of_row_i ass res) A\n            (map mod_type_class.from_nat [0..<k]))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i\n            (foldl (Hermite_of_row_i ass res) A\n              (map mod_type_class.from_nat [0..<k]))", "by simp"], ["proof (state)\nthis:\n  \\<not> is_zero_row i A'\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have e_A': \"echelon_form A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form A'", "by (metis A'_def a e echelon_form_fold_Hermite_of_row_i r)"], ["proof (state)\nthis:\n  echelon_form A'\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have least_eq: \"(LEAST n. (Hermite_of_row_i ass res A' i) $ i $ n \\<noteq> 0) = (LEAST n. A' $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_row_i ass res A' i $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A' $ i $ n \\<noteq> (0::'b))", "by (rule Least_Hermite_of_row_i[OF not_zero_A' e_A' a])"], ["proof (state)\nthis:\n  (LEAST n. Hermite_of_row_i ass res A' i $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have least_eq2: \"(LEAST n. A' $ i $ n \\<noteq> 0) = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A' $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding A'_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of_upt_row_i A k ass res $ i $ n \\<noteq> (0::'b)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (rule Hermite_of_upt_row_i_Least[OF not_zero_i_A e a r k])"], ["proof (state)\nthis:\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>mod_type_class.to_nat i < k;\n                 \\<not> is_zero_row i A; k \\<le> nrows A\\<rbrakk>\n                \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                                  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                                  \\<in> range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))));\n        mod_type_class.to_nat i < Suc k; \\<not> is_zero_row i A;\n        Suc k \\<le> nrows A\\<rbrakk>\n       \\<Longrightarrow> Hermite_of_upt_row_i A (Suc k) ass res $ j $\n                         (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                         \\<in> range\n                                (res (Hermite_of_upt_row_i A (Suc k) ass\n res $\ni $\n(LEAST n. A $ i $ n \\<noteq> (0::'b))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "proof (cases \"to_nat i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat i = k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have fn_k_i: \"from_nat k = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = i", "by (metis True from_nat_to_nat_id)"], ["proof (state)\nthis:\n  mod_type_class.from_nat k = i\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have H_rw: \"(Hermite_of_upt_row_i A (Suc k) ass res $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) \n      = (Hermite_of_row_i ass res A' i $ i $ (LEAST n. A' $ i $ n \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res A' i $ i $\n    (LEAST n. A' $ i $ n \\<noteq> (0::'b))", "by (simp add: Hermite_of_upt_row_i_def A'_def fn_k_i least_eq2[unfolded A'_def])"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' i $ i $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have \"(Hermite_of_upt_row_i A (Suc k) ass res) $ j $ (LEAST n. A $ i $ n \\<noteq> 0) = \n      (Hermite_of_row_i ass res A' i) $ j $ (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res A' i $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding Hermite_of_upt_row_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<Suc k]) $\n    j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res A' i $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by (simp add: A'_def fn_k_i)"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "also"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' i $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have \"... = (Hermite_of_row_i ass res A' i) $ j $ (LEAST n. A' $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A' i $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res A' i $ j $\n    (LEAST n. A' $ i $ n \\<noteq> (0::'b))", "unfolding least_eq2"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A' i $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res A' i $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", ".."], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' i $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' i $ j $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "also"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' i $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' i $ j $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have \"... \\<in> range (res (Hermite_of_row_i ass res A' i $ i $ (LEAST n. A' $ i $ n \\<noteq> 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A' i $ j $\n    (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_row_i ass res A' i $ i $\n                 (LEAST n. A' $ i $ n \\<noteq> (0::'b))))", "by (rule Hermite_of_row_i_range_res[OF j not_zero_A' r])"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' i $ j $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_row_i ass res A' i $ i $\n               (LEAST n. A' $ i $ n \\<noteq> (0::'b))))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "also"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' i $ j $ (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_row_i ass res A' i $ i $\n               (LEAST n. A' $ i $ n \\<noteq> (0::'b))))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have \"... = range ((res (Hermite_of_upt_row_i A (Suc k) ass res $ i $ (LEAST n. A $ i $ n \\<noteq> 0))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range\n     (res (Hermite_of_row_i ass res A' i $ i $\n           (LEAST n. A' $ i $ n \\<noteq> (0::'b)))) =\n    range\n     (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n           (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "unfolding H_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. range\n     (res (Hermite_of_row_i ass res A' i $ i $\n           (LEAST n. A' $ i $ n \\<noteq> (0::'b)))) =\n    range\n     (res (Hermite_of_row_i ass res A' i $ i $\n           (LEAST n. A' $ i $ n \\<noteq> (0::'b))))", ".."], ["proof (state)\nthis:\n  range\n   (res (Hermite_of_row_i ass res A' i $ i $\n         (LEAST n. A' $ i $ n \\<noteq> (0::'b)))) =\n  range\n   (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i = k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "finally"], ["proof (chain)\npicking this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "."], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "case False"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<noteq> k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "hence i_less_k: \"to_nat i < k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<noteq> k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < k", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<noteq> k\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < k", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "hence i_less_k2: \"i < from_nat k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat k", "using Suc.prems"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n  mod_type_class.to_nat i < Suc k\n  \\<not> is_zero_row i A\n  Suc k \\<le> nrows A\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat k", "by (metis from_nat_mono from_nat_to_nat_id k2 nrows_def)"], ["proof (state)\nthis:\n  i < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<noteq> k \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "proof (cases \"is_zero_row (from_nat k) A'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "case True"], ["proof (state)\nthis:\n  is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have \"Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res =\n    Hermite_of_upt_row_i A k ass res", "using True"], ["proof (prove)\nusing this:\n  is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res =\n    Hermite_of_upt_row_i A k ass res", "by (simp add:  Hermite_of_upt_row_i_def Hermite_of_row_i_def A'_def Let_def )"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\n\ngoal (2 subgoals):\n 1. is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n 2. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "using Suc.hyps not_zero_i_A k i_less_k"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res = Hermite_of_upt_row_i A k ass res\n  \\<lbrakk>mod_type_class.to_nat i < k; \\<not> is_zero_row i A;\n   k \\<le> nrows A\\<rbrakk>\n  \\<Longrightarrow> Hermite_of_upt_row_i A k ass res $ j $\n                    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n                    \\<in> range\n                           (res (Hermite_of_upt_row_i A k ass res $ i $\n                                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n  \\<not> is_zero_row i A\n  k \\<le> nrows A\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "by auto"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "case False"], ["proof (state)\nthis:\n  \\<not> is_zero_row (mod_type_class.from_nat k) A'\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have H_rw: \"(Hermite_of_upt_row_i A (Suc k) ass res $ i $ (LEAST n. A $ i $ n \\<noteq> 0)) = \n        A' $ i $ (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    A' $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))", "proof (auto simp add: Hermite_of_upt_row_i_def A'_def[symmetric],\n          rule Hermite_of_row_preserves_previous_cols[OF _ False e_A'])"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))", "have \"(LEAST n. A' $ i $ n \\<noteq> 0) < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))", "by (rule echelon_form_condition2_explicit[OF e_A' i_less_k2 not_zero_A' False])"], ["proof (state)\nthis:\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n  < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))", "thus \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n  < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))", "unfolding least_eq2"], ["proof (prove)\nusing this:\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))", "."], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ i $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  A' $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have \"(Hermite_of_upt_row_i A (Suc k) ass res) $ j $ (LEAST n. A $ i $ n \\<noteq> 0)\n        = (Hermite_of_row_i ass res A' (from_nat k)) $ j $ (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "unfolding Hermite_of_upt_row_i_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<Suc k]) $\n    j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    Hermite_of_row_i ass res\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<k]))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))", "by auto"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "also"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have \"... = A' $ j $ (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n    A' $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))", "proof (rule Hermite_of_row_preserves_previous_cols[OF _ False e_A'])"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))", "show \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))", "unfolding least_eq2[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A' $ i $ n \\<noteq> (0::'b))\n    < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))", "by (rule echelon_form_condition2_explicit[OF e_A' i_less_k2 not_zero_A' False])"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  < (LEAST n. A' $ mod_type_class.from_nat k $ n \\<noteq> (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  A' $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "also"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res A' (mod_type_class.from_nat k) $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b)) =\n  A' $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have \"... \\<in> range (res (Hermite_of_upt_row_i A k ass res $ i $ (LEAST n. A $ i $ n \\<noteq> 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A k ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "unfolding A'_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A k ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A k ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "by (rule Suc.hyps[OF i_less_k], auto simp add: Suc.prems k)"], ["proof (state)\nthis:\n  A' $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_upt_row_i A k ass res $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "also"], ["proof (state)\nthis:\n  A' $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_upt_row_i A k ass res $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "have \"... = range (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $ (LEAST n. A $ i $ n \\<noteq> 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range\n     (res (Hermite_of_upt_row_i A k ass res $ i $\n           (LEAST n. A $ i $ n \\<noteq> (0::'b)))) =\n    range\n     (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n           (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "unfolding H_rw A'_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. range\n     (res (Hermite_of_upt_row_i A k ass res $ i $\n           (LEAST n. A $ i $ n \\<noteq> (0::'b)))) =\n    range\n     (res (Hermite_of_upt_row_i A k ass res $ i $\n           (LEAST n. A $ i $ n \\<noteq> (0::'b))))", ".."], ["proof (state)\nthis:\n  range\n   (res (Hermite_of_upt_row_i A k ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b)))) =\n  range\n   (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n         (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat k) A' \\<Longrightarrow>\n    Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "finally"], ["proof (chain)\npicking this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res $ j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'b))\n    \\<in> range\n           (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n                 (LEAST n. A $ i $ n \\<noteq> (0::'b))))", "."], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res $ j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'b))\n  \\<in> range\n         (res (Hermite_of_upt_row_i A (Suc k) ass res $ i $\n               (LEAST n. A $ i $ n \\<noteq> (0::'b))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_residues_Hermite_of:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  and i: \"\\<not> is_zero_row i (Hermite_of A ass res bezout)\"\n  and ji: \"j < i\"\n  shows \"Hermite_of A ass res bezout $ j $ (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> 0)\n  \\<in> range (res (Hermite_of A ass res bezout $ i $ (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ j $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range\n           (res (Hermite_of A ass res bezout $ i $\n                 (LEAST n.\n                     Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ j $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range\n           (res (Hermite_of A ass res bezout $ i $\n                 (LEAST n.\n                     Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "have non_zero_i_eA: \"\\<not> is_zero_row i (echelon_form_of A bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (echelon_form_of A bezout)", "using Hermite_of_preserves_zero_rows[OF _ a r b] i"], ["proof (prove)\nusing this:\n  is_zero_row ?i (echelon_form_of ?A bezout) \\<Longrightarrow>\n  is_zero_row ?i (Hermite_of ?A ass res bezout)\n  \\<not> is_zero_row i (Hermite_of A ass res bezout)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (echelon_form_of A bezout)", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (echelon_form_of A bezout)\n\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ j $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range\n           (res (Hermite_of A ass res bezout $ i $\n                 (LEAST n.\n                     Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "have e: \"echelon_form (echelon_form_of A bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (echelon_form_of A bezout)", "by (rule echelon_form_echelon_form_of[OF b])"], ["proof (state)\nthis:\n  echelon_form (echelon_form_of A bezout)\n\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ j $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range\n           (res (Hermite_of A ass res bezout $ i $\n                 (LEAST n.\n                     Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "have least: \"(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> 0) = (LEAST n. (echelon_form_of A bezout) $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a)) =\n    (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))", "by (rule Hermite_of_Least[OF i a r b])"], ["proof (state)\nthis:\n  (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a)) =\n  (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ j $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range\n           (res (Hermite_of A ass res bezout $ i $\n                 (LEAST n.\n                     Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ j $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range\n           (res (Hermite_of A ass res bezout $ i $\n                 (LEAST n.\n                     Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "unfolding least"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ j $\n    (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range\n           (res (Hermite_of A ass res bezout $ i $\n                 (LEAST n.\n                     echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))))", "unfolding Hermite_of_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res $ j $\n    (LEAST n. echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range\n           (res (Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A)\n                  ass res $\n                 i $\n                 (LEAST n.\n                     echelon_form_of A bezout $ i $ n \\<noteq> (0::'a))))", "by (rule Hermite_of_upt_row_i_in_range_res[OF non_zero_i_eA e a r _ _ ji])\n  (auto simp add: to_nat_less_card nrows_def)"], ["proof (state)\nthis:\n  Hermite_of A ass res bezout $ j $\n  (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n  \\<in> range\n         (res (Hermite_of A ass res bezout $ i $\n               (LEAST n.\n                   Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_Hermite_of:\n  assumes a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  shows \"Hermite (range ass) (\\<lambda>c. range (res c)) (Hermite_of A ass res bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite (range ass) (\\<lambda>c. range (res c))\n     (Hermite_of A ass res bezout)", "proof (rule Hermite_intro, auto)"], ["proof (state)\ngoal (5 subgoals):\n 1. Complete_set_non_associates (range ass)\n 2. Complete_set_residues (\\<lambda>c. range (res c))\n 3. echelon_form (Hermite_of A ass res bezout)\n 4. \\<And>i.\n       \\<not> is_zero_row i (Hermite_of A ass res bezout) \\<Longrightarrow>\n       Hermite_of A ass res bezout $ i $\n       (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n       \\<in> range ass\n 5. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i (Hermite_of A ass res bezout);\n        j < i\\<rbrakk>\n       \\<Longrightarrow> Hermite_of A ass res bezout $ j $\n                         (LEAST n.\n                             Hermite_of A ass res bezout $ i $ n \\<noteq>\n                             (0::'a))\n                         \\<in> range\n                                (res (Hermite_of A ass res bezout $ i $\n(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "show \"Complete_set_non_associates (range ass)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_set_non_associates (range ass)", "by (simp add: ass_function_Complete_set_non_associates a)"], ["proof (state)\nthis:\n  Complete_set_non_associates (range ass)\n\ngoal (4 subgoals):\n 1. Complete_set_residues (\\<lambda>c. range (res c))\n 2. echelon_form (Hermite_of A ass res bezout)\n 3. \\<And>i.\n       \\<not> is_zero_row i (Hermite_of A ass res bezout) \\<Longrightarrow>\n       Hermite_of A ass res bezout $ i $\n       (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n       \\<in> range ass\n 4. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i (Hermite_of A ass res bezout);\n        j < i\\<rbrakk>\n       \\<Longrightarrow> Hermite_of A ass res bezout $ j $\n                         (LEAST n.\n                             Hermite_of A ass res bezout $ i $ n \\<noteq>\n                             (0::'a))\n                         \\<in> range\n                                (res (Hermite_of A ass res bezout $ i $\n(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "show \"Complete_set_residues (\\<lambda>c. range (res c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_set_residues (\\<lambda>c. range (res c))", "by (simp add: r res_function_Complete_set_residues)"], ["proof (state)\nthis:\n  Complete_set_residues (\\<lambda>c. range (res c))\n\ngoal (3 subgoals):\n 1. echelon_form (Hermite_of A ass res bezout)\n 2. \\<And>i.\n       \\<not> is_zero_row i (Hermite_of A ass res bezout) \\<Longrightarrow>\n       Hermite_of A ass res bezout $ i $\n       (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n       \\<in> range ass\n 3. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i (Hermite_of A ass res bezout);\n        j < i\\<rbrakk>\n       \\<Longrightarrow> Hermite_of A ass res bezout $ j $\n                         (LEAST n.\n                             Hermite_of A ass res bezout $ i $ n \\<noteq>\n                             (0::'a))\n                         \\<in> range\n                                (res (Hermite_of A ass res bezout $ i $\n(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "show \"echelon_form (Hermite_of A ass res bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form (Hermite_of A ass res bezout)", "by (simp add: a b echelon_form_Hermite_of r)"], ["proof (state)\nthis:\n  echelon_form (Hermite_of A ass res bezout)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<not> is_zero_row i (Hermite_of A ass res bezout) \\<Longrightarrow>\n       Hermite_of A ass res bezout $ i $\n       (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n       \\<in> range ass\n 2. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i (Hermite_of A ass res bezout);\n        j < i\\<rbrakk>\n       \\<Longrightarrow> Hermite_of A ass res bezout $ j $\n                         (LEAST n.\n                             Hermite_of A ass res bezout $ i $ n \\<noteq>\n                             (0::'a))\n                         \\<in> range\n                                (res (Hermite_of A ass res bezout $ i $\n(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<not> is_zero_row i (Hermite_of A ass res bezout) \\<Longrightarrow>\n       Hermite_of A ass res bezout $ i $\n       (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n       \\<in> range ass\n 2. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i (Hermite_of A ass res bezout);\n        j < i\\<rbrakk>\n       \\<Longrightarrow> Hermite_of A ass res bezout $ j $\n                         (LEAST n.\n                             Hermite_of A ass res bezout $ i $ n \\<noteq>\n                             (0::'a))\n                         \\<in> range\n                                (res (Hermite_of A ass res bezout $ i $\n(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "assume i: \"\\<not> is_zero_row i (Hermite_of A ass res bezout)\""], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Hermite_of A ass res bezout)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<not> is_zero_row i (Hermite_of A ass res bezout) \\<Longrightarrow>\n       Hermite_of A ass res bezout $ i $\n       (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n       \\<in> range ass\n 2. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i (Hermite_of A ass res bezout);\n        j < i\\<rbrakk>\n       \\<Longrightarrow> Hermite_of A ass res bezout $ j $\n                         (LEAST n.\n                             Hermite_of A ass res bezout $ i $ n \\<noteq>\n                             (0::'a))\n                         \\<in> range\n                                (res (Hermite_of A ass res bezout $ i $\n(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "show \"Hermite_of A ass res bezout $ i $ (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> 0) \\<in> range ass\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ i $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range ass", "by (rule in_associates_Hermite_of[OF a r b i])"], ["proof (state)\nthis:\n  Hermite_of A ass res bezout $ i $\n  (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n  \\<in> range ass\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i (Hermite_of A ass res bezout);\n        j < i\\<rbrakk>\n       \\<Longrightarrow> Hermite_of A ass res bezout $ j $\n                         (LEAST n.\n                             Hermite_of A ass res bezout $ i $ n \\<noteq>\n                             (0::'a))\n                         \\<in> range\n                                (res (Hermite_of A ass res bezout $ i $\n(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i (Hermite_of A ass res bezout);\n        j < i\\<rbrakk>\n       \\<Longrightarrow> Hermite_of A ass res bezout $ j $\n                         (LEAST n.\n                             Hermite_of A ass res bezout $ i $ n \\<noteq>\n                             (0::'a))\n                         \\<in> range\n                                (res (Hermite_of A ass res bezout $ i $\n(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i (Hermite_of A ass res bezout);\n        j < i\\<rbrakk>\n       \\<Longrightarrow> Hermite_of A ass res bezout $ j $\n                         (LEAST n.\n                             Hermite_of A ass res bezout $ i $ n \\<noteq>\n                             (0::'a))\n                         \\<in> range\n                                (res (Hermite_of A ass res bezout $ i $\n(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "assume i: \"\\<not> is_zero_row i (Hermite_of A ass res bezout)\" and j: \"j < i\""], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Hermite_of A ass res bezout)\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i (Hermite_of A ass res bezout);\n        j < i\\<rbrakk>\n       \\<Longrightarrow> Hermite_of A ass res bezout $ j $\n                         (LEAST n.\n                             Hermite_of A ass res bezout $ i $ n \\<noteq>\n                             (0::'a))\n                         \\<in> range\n                                (res (Hermite_of A ass res bezout $ i $\n(LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "show \"Hermite_of A ass res bezout $ j $ (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> 0)\n    \\<in> range (res (Hermite_of A ass res bezout $ i $ (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout $ j $\n    (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n    \\<in> range\n           (res (Hermite_of A ass res bezout $ i $\n                 (LEAST n.\n                     Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))", "by (rule in_residues_Hermite_of[OF a r b i j])"], ["proof (state)\nthis:\n  Hermite_of A ass res bezout $ j $\n  (LEAST n. Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))\n  \\<in> range\n         (res (Hermite_of A ass res bezout $ i $\n               (LEAST n.\n                   Hermite_of A ass res bezout $ i $ n \\<noteq> (0::'a))))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Proving that the Hermite Normal Form is computed by means of elementary operations\\<close>"], ["", "lemma invertible_Hermite_reduce_above:\n  assumes n: \"n \\<le> to_nat i\"\n  shows \"\\<exists>P. invertible P \\<and> Hermite_reduce_above A n i j res = P ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> Hermite_reduce_above A n i j res = P ** A", "using n"], ["proof (prove)\nusing this:\n  n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> Hermite_reduce_above A n i j res = P ** A", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       0 \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and> Hermite_reduce_above A 0 i j res = P ** A\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "case 0"], ["proof (state)\nthis:\n  0 \\<le> mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       0 \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and> Hermite_reduce_above A 0 i j res = P ** A\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> Hermite_reduce_above A 0 i j res = P ** A", "by (auto, metis invertible_def matrix_mul_lid)"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> Hermite_reduce_above A 0 i j res = P ** A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "case (Suc n)"], ["proof (state)\nthis:\n  n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n  \\<exists>P.\n     invertible P \\<and> Hermite_reduce_above ?A n i j res = P ** ?A\n  Suc n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "let ?R=\"(row_add A (from_nat n) i ((res (A $ i $ j) (A $ from_nat n $ j) - A $ from_nat n $ j) div A $ i $ j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "obtain Q where inv_Q: \"invertible Q\" and H_QR: \"Hermite_reduce_above ?R n i j res = Q ** ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>invertible Q;\n         Hermite_reduce_above\n          (row_add A (mod_type_class.from_nat n) i\n            ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n              A $ mod_type_class.from_nat n $ j) div\n             A $ i $ j))\n          n i j res =\n         Q **\n         row_add A (mod_type_class.from_nat n) i\n          ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n            A $ mod_type_class.from_nat n $ j) div\n           A $ i $ j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.hyps Suc.prems"], ["proof (prove)\nusing this:\n  n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n  \\<exists>P.\n     invertible P \\<and> Hermite_reduce_above ?A n i j res = P ** ?A\n  Suc n \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>invertible Q;\n         Hermite_reduce_above\n          (row_add A (mod_type_class.from_nat n) i\n            ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n              A $ mod_type_class.from_nat n $ j) div\n             A $ i $ j))\n          n i j res =\n         Q **\n         row_add A (mod_type_class.from_nat n) i\n          ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n            A $ mod_type_class.from_nat n $ j) div\n           A $ i $ j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  invertible Q\n  Hermite_reduce_above\n   (row_add A (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j))\n   n i j res =\n  Q **\n  row_add A (mod_type_class.from_nat n) i\n   ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n     A $ mod_type_class.from_nat n $ j) div\n    A $ i $ j)\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "let ?P=\"(row_add (mat 1) (from_nat n) i ((res (A $ i $ j) (A $ from_nat n $ j) - A $ from_nat n $ j) div A $ i $ j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "have inv_P: \"invertible ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n       ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n         A $ mod_type_class.from_nat n $ j) div\n        A $ i $ j))", "proof (rule invertible_row_add)"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat n \\<noteq> i", "show \"mod_type_class.from_nat n \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat n \\<noteq> i", "by (metis Suc.prems Suc_le_eq add_to_nat_def from_nat_mono less_irrefl \n          monoid_add_class.add.right_neutral to_nat_0 to_nat_less_card)"], ["proof (state)\nthis:\n  mod_type_class.from_nat n \\<noteq> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invertible\n   (row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j))\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "have inv_QP: \"invertible (Q ** ?P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (Q **\n      row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n       ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n         A $ mod_type_class.from_nat n $ j) div\n        A $ i $ j))", "by (metis inv_P inv_Q invertible_mult)"], ["proof (state)\nthis:\n  invertible\n   (Q **\n    row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j))\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "have \"Hermite_reduce_above A (Suc n) i j res = Hermite_reduce_above ?R n i j res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above A (Suc n) i j res =\n    Hermite_reduce_above\n     (row_add A (mod_type_class.from_nat n) i\n       ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n         A $ mod_type_class.from_nat n $ j) div\n        A $ i $ j))\n     n i j res", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  Hermite_reduce_above A (Suc n) i j res =\n  Hermite_reduce_above\n   (row_add A (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j))\n   n i j res\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "also"], ["proof (state)\nthis:\n  Hermite_reduce_above A (Suc n) i j res =\n  Hermite_reduce_above\n   (row_add A (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j))\n   n i j res\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "have \"... = Q ** ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above\n     (row_add A (mod_type_class.from_nat n) i\n       ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n         A $ mod_type_class.from_nat n $ j) div\n        A $ i $ j))\n     n i j res =\n    Q **\n    row_add A (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j)", "unfolding H_QR"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q **\n    row_add A (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j) =\n    Q **\n    row_add A (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j)", ".."], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (row_add A (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j))\n   n i j res =\n  Q **\n  row_add A (mod_type_class.from_nat n) i\n   ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n     A $ mod_type_class.from_nat n $ j) div\n    A $ i $ j)\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "also"], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (row_add A (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j))\n   n i j res =\n  Q **\n  row_add A (mod_type_class.from_nat n) i\n   ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n     A $ mod_type_class.from_nat n $ j) div\n    A $ i $ j)\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "have \"... = Q ** (?P ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q **\n    row_add A (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j) =\n    Q **\n    (row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n      ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n        A $ mod_type_class.from_nat n $ j) div\n       A $ i $ j) **\n     A)", "by (subst row_add_mat_1[symmetric], rule refl)"], ["proof (state)\nthis:\n  Q **\n  row_add A (mod_type_class.from_nat n) i\n   ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n     A $ mod_type_class.from_nat n $ j) div\n    A $ i $ j) =\n  Q **\n  (row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n    ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n      A $ mod_type_class.from_nat n $ j) div\n     A $ i $ j) **\n   A)\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "also"], ["proof (state)\nthis:\n  Q **\n  row_add A (mod_type_class.from_nat n) i\n   ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n     A $ mod_type_class.from_nat n $ j) div\n    A $ i $ j) =\n  Q **\n  (row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n    ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n      A $ mod_type_class.from_nat n $ j) div\n     A $ i $ j) **\n   A)\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "have \"... = (Q ** ?P) ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q **\n    (row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n      ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n        A $ mod_type_class.from_nat n $ j) div\n       A $ i $ j) **\n     A) =\n    Q **\n    row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j) **\n    A", "by (simp add: matrix_mul_assoc)"], ["proof (state)\nthis:\n  Q **\n  (row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n    ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n      A $ mod_type_class.from_nat n $ j) div\n     A $ i $ j) **\n   A) =\n  Q **\n  row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n   ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n     A $ mod_type_class.from_nat n $ j) div\n    A $ i $ j) **\n  A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and>\n                      Hermite_reduce_above A n i j res = P ** A;\n        Suc n \\<le> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Hermite_reduce_above A (Suc n) i j res = P ** A", "finally"], ["proof (chain)\npicking this:\n  Hermite_reduce_above A (Suc n) i j res =\n  Q **\n  row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n   ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n     A $ mod_type_class.from_nat n $ j) div\n    A $ i $ j) **\n  A", "show ?case"], ["proof (prove)\nusing this:\n  Hermite_reduce_above A (Suc n) i j res =\n  Q **\n  row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n   ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n     A $ mod_type_class.from_nat n $ j) div\n    A $ i $ j) **\n  A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> Hermite_reduce_above A (Suc n) i j res = P ** A", "using inv_QP"], ["proof (prove)\nusing this:\n  Hermite_reduce_above A (Suc n) i j res =\n  Q **\n  row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n   ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n     A $ mod_type_class.from_nat n $ j) div\n    A $ i $ j) **\n  A\n  invertible\n   (Q **\n    row_add (mat (1::'b)) (mod_type_class.from_nat n) i\n     ((res (A $ i $ j) (A $ mod_type_class.from_nat n $ j) -\n       A $ mod_type_class.from_nat n $ j) div\n      A $ i $ j))\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> Hermite_reduce_above A (Suc n) i j res = P ** A", "by auto"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and> Hermite_reduce_above A (Suc n) i j res = P ** A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invertible_Hermite_of_row_i:\n  assumes a: \"ass_function ass\"\n  shows \"\\<exists>P. invertible P \\<and> Hermite_of_row_i ass res A i = P ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Hermite_of_row_i ass res A i = P ** A", "unfolding Hermite_of_row_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       (if is_zero_row i A then A\n        else let j = LEAST n. A $ i $ n \\<noteq> (0::'a); Aij = A $ i $ j;\n                 A' = mult_row A i (ass Aij div Aij)\n             in Hermite_reduce_above A' (mod_type_class.to_nat i) i j res) =\n       P ** A", "proof (auto simp add: Let_def, metis invertible_def matrix_mul_lid)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "let ?n=\"LEAST n. A $ i $ n \\<noteq> 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "let ?M=\"mult_row A i (ass (A $ i $ ?n) div A $ i $ ?n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "let ?P=\"mult_row (mat 1) i (ass (A $ i $ ?n) div A $ i $ ?n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "let ?Ain=\"A $ i $ ?n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "have ass_dvd: \"ass ?Ain dvd ?Ain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) dvd\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", "using a"], ["proof (prove)\nusing this:\n  ass_function ass\n\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) dvd\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", "unfolding ass_function_def"], ["proof (prove)\nusing this:\n  (\\<forall>a. normalize a = normalize (ass a)) \\<and>\n  pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b) (range ass)\n\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) dvd\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", "by (simp add: associatedD1)"], ["proof (state)\nthis:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) dvd\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "have ass_dvd': \"?Ain dvd ass ?Ain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) dvd\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))", "using a"], ["proof (prove)\nusing this:\n  ass_function ass\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) dvd\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))", "unfolding ass_function_def"], ["proof (prove)\nusing this:\n  (\\<forall>a. normalize a = normalize (ass a)) \\<and>\n  pairwise (\\<lambda>a b. normalize a \\<noteq> normalize b) (range ass)\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) dvd\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))", "by (simp add: associatedD1)"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) dvd\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "assume iA: \"\\<not> is_zero_row i A\""], ["proof (state)\nthis:\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "have Ain_0: \"A $ i $ ?n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags) LeastI iA is_zero_row_def')"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "have ass_Ain_0: \"ass (A $ i $ ?n) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) \\<noteq> (0::'a)", "by (metis Ain_0 ass_dvd dvd_0_left_iff)"], ["proof (state)\nthis:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "have inv_P: \"invertible ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (mult_row (mat (1::'a)) i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))", "proof (rule invertible_mult_row[of _ \"A $ i $ ?n div ass (A $ i $ ?n)\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n     ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))) =\n    (1::'a)\n 2. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "have \"ass ?Ain div ?Ain * (?Ain div ass ?Ain) = (ass ?Ain div ?Ain * ?Ain) div ass ?Ain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n     ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))) =\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))", "by (rule div_mult_swap[OF ass_dvd])"], ["proof (state)\nthis:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n   ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))) =\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n\ngoal (2 subgoals):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n     ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))) =\n    (1::'a)\n 2. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "also"], ["proof (state)\nthis:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n   ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))) =\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n\ngoal (2 subgoals):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n     ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))) =\n    (1::'a)\n 2. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "have \"... = (ass ?Ain) div ass ?Ain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))", "unfolding dvd_div_mult_self[OF ass_dvd']"], ["proof (prove)\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))", ".."], ["proof (state)\nthis:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n\ngoal (2 subgoals):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n     ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))) =\n    (1::'a)\n 2. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "also"], ["proof (state)\nthis:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n\ngoal (2 subgoals):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n     ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))) =\n    (1::'a)\n 2. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "have \"... = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "using ass_Ain_0"], ["proof (prove)\nusing this:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "by auto"], ["proof (state)\nthis:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n  (1::'a)\n\ngoal (2 subgoals):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n     ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))) =\n    (1::'a)\n 2. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "finally"], ["proof (chain)\npicking this:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n   ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))) =\n  (1::'a)", "show \"ass ?Ain div ?Ain * (?Ain div ass ?Ain) = 1\""], ["proof (prove)\nusing this:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n   ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n    (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n     ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))) =\n    (1::'a)", "."], ["proof (state)\nthis:\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) *\n  (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n   ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "have \"?Ain div ass (?Ain) * (ass (?Ain) div ?Ain) = (?Ain div ass (?Ain) * ass (?Ain)) div ?Ain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", "by (rule div_mult_swap[OF ass_dvd'])"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n  (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "also"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n  (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "have \"... = ?Ain div ?Ain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", "unfolding dvd_div_mult_self[OF ass_dvd]"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", ".."], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "also"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "have \"... = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    (1::'a)", "using Ain_0"], ["proof (prove)\nusing this:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    (1::'a)", "by simp"], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "finally"], ["proof (chain)\npicking this:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n  (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n  (1::'a)", "show \"?Ain div ass (?Ain) * (ass (?Ain) div ?Ain) = 1\""], ["proof (prove)\nusing this:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n  (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n    ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (1::'a)", "."], ["proof (state)\nthis:\n  A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) div\n  ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) *\n  (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n   A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n  (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invertible\n   (mult_row (mat (1::'a)) i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "obtain Q where inv_Q: \"invertible Q\" and H_QM: \"Hermite_reduce_above ?M (to_nat i) i ?n res = Q ** ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>invertible Q;\n         Hermite_reduce_above\n          (mult_row A i\n            (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n          (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n          res =\n         Q **\n         mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using invertible_Hermite_reduce_above"], ["proof (prove)\nusing this:\n  ?n \\<le> mod_type_class.to_nat ?i \\<Longrightarrow>\n  \\<exists>P.\n     invertible P \\<and> Hermite_reduce_above ?A ?n ?i ?j ?res = P ** ?A\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>invertible Q;\n         Hermite_reduce_above\n          (mult_row A i\n            (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n             A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n          (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n          res =\n         Q **\n         mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  invertible Q\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res =\n  Q **\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "have inv_QP: \"invertible (Q**?P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (Q **\n      mult_row (mat (1::'a)) i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))", "by (metis inv_P inv_Q invertible_mult)"], ["proof (state)\nthis:\n  invertible\n   (Q **\n    mult_row (mat (1::'a)) i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "have \"Hermite_reduce_above ?M (to_nat i) i ?n res = Q ** ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_reduce_above\n     (mult_row A i\n       (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n        A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n     (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res =\n    Q **\n    mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))", "by (rule H_QM)"], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res =\n  Q **\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "also"], ["proof (state)\nthis:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res =\n  Q **\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "have \"... = Q ** (?P ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q **\n    mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    Q **\n    (mult_row (mat (1::'a)) i\n      (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n       A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) **\n     A)", "by (subst mult_row_mat_1[symmetric], rule refl)"], ["proof (state)\nthis:\n  Q **\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n  Q **\n  (mult_row (mat (1::'a)) i\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) **\n   A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "also"], ["proof (state)\nthis:\n  Q **\n  mult_row A i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n  Q **\n  (mult_row (mat (1::'a)) i\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) **\n   A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "have \"... = (Q ** ?P) ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q **\n    (mult_row (mat (1::'a)) i\n      (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n       A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) **\n     A) =\n    Q **\n    mult_row (mat (1::'a)) i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) **\n    A", "by (simp add: matrix_mul_assoc)"], ["proof (state)\nthis:\n  Q **\n  (mult_row (mat (1::'a)) i\n    (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n     A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) **\n   A) =\n  Q **\n  mult_row (mat (1::'a)) i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) **\n  A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "finally"], ["proof (chain)\npicking this:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res =\n  Q **\n  mult_row (mat (1::'a)) i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) **\n  A", "show \"\\<exists>P. invertible P \\<and> Hermite_reduce_above ?M (to_nat i) i ?n res = P ** A\""], ["proof (prove)\nusing this:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res =\n  Q **\n  mult_row (mat (1::'a)) i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) **\n  A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "using inv_QP"], ["proof (prove)\nusing this:\n  Hermite_reduce_above\n   (mult_row A i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n   (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a)) res =\n  Q **\n  mult_row (mat (1::'a)) i\n   (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n    A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) **\n  A\n  invertible\n   (Q **\n    mult_row (mat (1::'a)) i\n     (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n      A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       Hermite_reduce_above\n        (mult_row A i\n          (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n           A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n        (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        res =\n       P ** A", "by auto"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and>\n     Hermite_reduce_above\n      (mult_row A i\n        (ass (A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) div\n         A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))))\n      (mod_type_class.to_nat i) i (LEAST n. A $ i $ n \\<noteq> (0::'a))\n      res =\n     P ** A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invertible_Hermite_of_upt_row_i:\n  assumes a: \"ass_function ass\"\n  shows \"\\<exists>P. invertible P \\<and> Hermite_of_upt_row_i A k ass res = P ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> Hermite_of_upt_row_i A k ass res = P ** A", "proof (induct k arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<exists>P.\n          invertible P \\<and> Hermite_of_upt_row_i A 0 ass res = P ** A\n 2. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<exists>P.\n          invertible P \\<and> Hermite_of_upt_row_i A 0 ass res = P ** A\n 2. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> Hermite_of_upt_row_i A 0 ass res = P ** A", "unfolding Hermite_of_upt_row_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       foldl (Hermite_of_row_i ass res) A\n        (map mod_type_class.from_nat [0..<0]) =\n       P ** A", "by (auto, metis invertible_def matrix_mul_lid)"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> Hermite_of_upt_row_i A 0 ass res = P ** A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "case (Suc k)"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and> Hermite_of_upt_row_i ?A k ass res = P ** ?A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "obtain Q where inv_Q: \"invertible Q\" and H_QA: \"Hermite_of_upt_row_i A k ass res = Q ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>invertible Q;\n         Hermite_of_upt_row_i A k ass res = Q ** A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.hyps"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and> Hermite_of_upt_row_i ?A k ass res = P ** ?A\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>invertible Q;\n         Hermite_of_upt_row_i A k ass res = Q ** A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  invertible Q\n  Hermite_of_upt_row_i A k ass res = Q ** A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "obtain P where inv_P: \"invertible P\" \n    and H_PH: \"Hermite_of_row_i ass res (Hermite_of_upt_row_i A k ass res) (from_nat k) \n    = P ** (Hermite_of_upt_row_i A k ass res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         Hermite_of_row_i ass res (Hermite_of_upt_row_i A k ass res)\n          (mod_type_class.from_nat k) =\n         P ** Hermite_of_upt_row_i A k ass res\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using invertible_Hermite_of_row_i[OF a]"], ["proof (prove)\nusing this:\n  \\<exists>P. invertible P \\<and> Hermite_of_row_i ass ?res ?A ?i = P ** ?A\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         Hermite_of_row_i ass res (Hermite_of_upt_row_i A k ass res)\n          (mod_type_class.from_nat k) =\n         P ** Hermite_of_upt_row_i A k ass res\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  invertible P\n  Hermite_of_row_i ass res (Hermite_of_upt_row_i A k ass res)\n   (mod_type_class.from_nat k) =\n  P ** Hermite_of_upt_row_i A k ass res\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "have inv_PQ: \"invertible (P**Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (P ** Q)", "by (simp add: inv_P inv_Q invertible_mult)"], ["proof (state)\nthis:\n  invertible (P ** Q)\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "have \"Hermite_of_upt_row_i A (Suc k) ass res \n    = Hermite_of_row_i ass res (Hermite_of_upt_row_i A k ass res) (from_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i A (Suc k) ass res =\n    Hermite_of_row_i ass res (Hermite_of_upt_row_i A k ass res)\n     (mod_type_class.from_nat k)", "unfolding Hermite_of_upt_row_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (Hermite_of_row_i ass res) A\n     (map mod_type_class.from_nat [0..<Suc k]) =\n    Hermite_of_row_i ass res\n     (foldl (Hermite_of_row_i ass res) A\n       (map mod_type_class.from_nat [0..<k]))\n     (mod_type_class.from_nat k)", "by auto"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res =\n  Hermite_of_row_i ass res (Hermite_of_upt_row_i A k ass res)\n   (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "also"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i A (Suc k) ass res =\n  Hermite_of_row_i ass res (Hermite_of_upt_row_i A k ass res)\n   (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "have \"... =  P ** (Hermite_of_upt_row_i A k ass res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_row_i ass res (Hermite_of_upt_row_i A k ass res)\n     (mod_type_class.from_nat k) =\n    P ** Hermite_of_upt_row_i A k ass res", "unfolding H_PH"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ** Hermite_of_upt_row_i A k ass res =\n    P ** Hermite_of_upt_row_i A k ass res", ".."], ["proof (state)\nthis:\n  Hermite_of_row_i ass res (Hermite_of_upt_row_i A k ass res)\n   (mod_type_class.from_nat k) =\n  P ** Hermite_of_upt_row_i A k ass res\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "also"], ["proof (state)\nthis:\n  Hermite_of_row_i ass res (Hermite_of_upt_row_i A k ass res)\n   (mod_type_class.from_nat k) =\n  P ** Hermite_of_upt_row_i A k ass res\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "have \"... = P ** (Q ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ** Hermite_of_upt_row_i A k ass res = P ** (Q ** A)", "unfolding H_QA"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ** (Q ** A) = P ** (Q ** A)", ".."], ["proof (state)\nthis:\n  P ** Hermite_of_upt_row_i A k ass res = P ** (Q ** A)\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "also"], ["proof (state)\nthis:\n  P ** Hermite_of_upt_row_i A k ass res = P ** (Q ** A)\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "have \"... = (P ** Q) ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ** (Q ** A) = P ** Q ** A", "by (simp add: matrix_mul_assoc)"], ["proof (state)\nthis:\n  P ** (Q ** A) = P ** Q ** A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       (\\<And>A.\n           \\<exists>P.\n              invertible P \\<and>\n              Hermite_of_upt_row_i A k ass res = P ** A) \\<Longrightarrow>\n       \\<exists>P.\n          invertible P \\<and>\n          Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "finally"], ["proof (chain)\npicking this:\n  Hermite_of_upt_row_i A (Suc k) ass res = P ** Q ** A", "show ?case"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res = P ** Q ** A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "using inv_PQ"], ["proof (prove)\nusing this:\n  Hermite_of_upt_row_i A (Suc k) ass res = P ** Q ** A\n  invertible (P ** Q)\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> Hermite_of_upt_row_i A (Suc k) ass res = P ** A", "by blast"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and> Hermite_of_upt_row_i A (Suc k) ass res = P ** A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invertible_Hermite_of:\n  fixes A::\"'a::{bezout_ring_div,normalization_semidom,unique_euclidean_ring}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes a: \"ass_function ass\" \n  and b: \"is_bezout_ext bezout\"\n  shows \"\\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A", "obtain P where inv_P: \"invertible P\" \n    and H_PH: \"Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res \n    = P ** (echelon_form_of A bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res =\n         P ** echelon_form_of A bezout\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using invertible_Hermite_of_upt_row_i[OF a]"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and> Hermite_of_upt_row_i ?A ?k ass ?res = P ** ?A\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res =\n         P ** echelon_form_of A bezout\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  invertible P\n  Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res =\n  P ** echelon_form_of A bezout\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A", "obtain Q where inv_Q: \"invertible Q\" and E_QA: \"(echelon_form_of A bezout) = Q ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>invertible Q; echelon_form_of A bezout = Q ** A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using echelon_form_of_invertible[OF b, of A]"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and>\n     P ** A = echelon_form_of A bezout \\<and>\n     echelon_form (echelon_form_of A bezout)\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>invertible Q; echelon_form_of A bezout = Q ** A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  invertible Q\n  echelon_form_of A bezout = Q ** A\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A", "have inv_PQ: \"invertible (P**Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (P ** Q)", "by (simp add: inv_P inv_Q invertible_mult)"], ["proof (state)\nthis:\n  invertible (P ** Q)\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A", "have \"Hermite_of A ass res bezout \n    = Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of A ass res bezout =\n    Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res", "unfolding Hermite_of_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res =\n    Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res", ".."], ["proof (state)\nthis:\n  Hermite_of A ass res bezout =\n  Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A", "also"], ["proof (state)\nthis:\n  Hermite_of A ass res bezout =\n  Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A", "have \"... = P ** (Q ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res =\n    P ** (Q ** A)", "unfolding H_PH"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ** echelon_form_of A bezout = P ** (Q ** A)", "unfolding E_QA"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ** (Q ** A) = P ** (Q ** A)", ".."], ["proof (state)\nthis:\n  Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res =\n  P ** (Q ** A)\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A", "also"], ["proof (state)\nthis:\n  Hermite_of_upt_row_i (echelon_form_of A bezout) (nrows A) ass res =\n  P ** (Q ** A)\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A", "have \"... = (P ** Q) ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ** (Q ** A) = P ** Q ** A", "by (simp add: matrix_mul_assoc)"], ["proof (state)\nthis:\n  P ** (Q ** A) = P ** Q ** A\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A", "finally"], ["proof (chain)\npicking this:\n  Hermite_of A ass res bezout = P ** Q ** A", "show ?thesis"], ["proof (prove)\nusing this:\n  Hermite_of A ass res bezout = P ** Q ** A\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A", "using inv_PQ"], ["proof (prove)\nusing this:\n  Hermite_of A ass res bezout = P ** Q ** A\n  invertible (P ** Q)\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A", "by blast"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> Hermite_of A ass res bezout = P ** A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>The final theorem\\<close>"], ["", "lemma Hermite:\n  assumes a: \"ass_function ass\"\n  and r: \"res_function res\"\n  and b: \"is_bezout_ext bezout\"\n  shows \"\\<exists>P. invertible P \\<and> (Hermite_of A ass res bezout) = P ** A \\<and> \n  Hermite (range ass) (\\<lambda>c. range (res c)) (Hermite_of A ass res bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       Hermite_of A ass res bezout = P ** A \\<and>\n       Hermite (range ass) (\\<lambda>c. range (res c))\n        (Hermite_of A ass res bezout)", "using invertible_Hermite_of[OF a b] Hermite_Hermite_of[OF a r b]"], ["proof (prove)\nusing this:\n  \\<exists>P. invertible P \\<and> Hermite_of ?A ass ?res bezout = P ** ?A\n  Hermite (range ass) (\\<lambda>c. range (res c))\n   (Hermite_of ?A ass res bezout)\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       Hermite_of A ass res bezout = P ** A \\<and>\n       Hermite (range ass) (\\<lambda>c. range (res c))\n        (Hermite_of A ass res bezout)", "by fast"], ["", "subsection\\<open>Proving the uniqueness of the Hermite Normal Form\\<close>"], ["", "lemma diagonal_least_nonzero:\n  fixes H :: \"(('a :: {bezout_ring_div, normalization_euclidean_semiring, unique_euclidean_ring}, 'b :: mod_type) vec, 'b) vec\"\n  assumes H: \"Hermite associates residues H\"\n  and inv_H: \"invertible H\" and up_H: \"upper_triangular H\"\n  shows \"(LEAST n. H $ i $ n \\<noteq> 0) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ i $ n \\<noteq> (0::'a)) = i", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. H $ i $ i \\<noteq> (0::'a)\n 2. \\<And>y. H $ i $ y \\<noteq> (0::'a) \\<Longrightarrow> i \\<le> y", "show \"H $ i $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i \\<noteq> (0::'a)", "by (metis (full_types) inv_H invertible_iff_is_unit is_unit_diagonal not_is_unit_0 up_H)"], ["proof (state)\nthis:\n  H $ i $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y. H $ i $ y \\<noteq> (0::'a) \\<Longrightarrow> i \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. H $ i $ y \\<noteq> (0::'a) \\<Longrightarrow> i \\<le> y", "assume Hiy: \"H $ i $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  H $ i $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y. H $ i $ y \\<noteq> (0::'a) \\<Longrightarrow> i \\<le> y", "show \"i \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> y", "using up_H"], ["proof (prove)\nusing this:\n  upper_triangular H\n\ngoal (1 subgoal):\n 1. i \\<le> y", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  \\<forall>i j. j < i \\<longrightarrow> H $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<le> y", "by (metis (poly_guards_query) Hiy not_less)"], ["proof (state)\nthis:\n  i \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diagonal_in_associates:\n  fixes H :: \"(('a :: {bezout_ring_div, normalization_euclidean_semiring, unique_euclidean_ring}, 'b :: mod_type) vec, 'b) vec\"\n  assumes H: \"Hermite associates residues H\"\n  and inv_H: \"invertible H\" and up_H: \"upper_triangular H\"\n  shows \"H $ i $ i \\<in> associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "have \"H $ i $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i \\<noteq> (0::'a)", "by (metis (full_types) inv_H invertible_iff_is_unit is_unit_diagonal not_is_unit_0 up_H)"], ["proof (state)\nthis:\n  H $ i $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "hence \"\\<not> is_zero_row i H\""], ["proof (prove)\nusing this:\n  H $ i $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i H", "unfolding is_zero_row_def is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  H $ i $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < CARD('b) \\<longrightarrow>\n               H $ i $ j = (0::'a))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row i H\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "using H"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n  Hermite associates residues H\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "unfolding Hermite_def"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues residues \\<and>\n  echelon_form H \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)) \\<in> associates) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      (\\<forall>j<i.\n          H $ j $ (LEAST n. H $ i $ n \\<noteq> (0::'a))\n          \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)))))\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "unfolding diagonal_least_nonzero[OF H inv_H up_H]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues residues \\<and>\n  echelon_form H \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      H $ i $ i \\<in> associates) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      (\\<forall>j<i. H $ j $ i \\<in> residues (H $ i $ i)))\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "by auto"], ["proof (state)\nthis:\n  H $ i $ i \\<in> associates\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma above_diagonal_in_residues:\n  fixes H :: \"(('a :: {bezout_ring_div, normalization_euclidean_semiring, unique_euclidean_ring}, 'b :: mod_type) vec, 'b) vec\"\n  assumes H: \"Hermite associates residues H\"\n  and inv_H: \"invertible H\" and up_H: \"upper_triangular H\"\n  and j_i: \"j<i\"\n  shows \"H $ j $ (LEAST n. H $ i $ n \\<noteq> 0) \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> (0::'a))\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> (0::'a))\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)))", "have \"H $ i $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i \\<noteq> (0::'a)", "by (metis (full_types) inv_H invertible_iff_is_unit is_unit_diagonal not_is_unit_0 up_H)"], ["proof (state)\nthis:\n  H $ i $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> (0::'a))\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)))", "hence \"\\<not> is_zero_row i H\""], ["proof (prove)\nusing this:\n  H $ i $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i H", "unfolding is_zero_row_def is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  H $ i $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < CARD('b) \\<longrightarrow>\n               H $ i $ j = (0::'a))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row i H\n\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> (0::'a))\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> (0::'a))\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)))", "using H j_i"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n  Hermite associates residues H\n  j < i\n\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> (0::'a))\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)))", "unfolding Hermite_def"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues residues \\<and>\n  echelon_form H \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)) \\<in> associates) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      (\\<forall>j<i.\n          H $ j $ (LEAST n. H $ i $ n \\<noteq> (0::'a))\n          \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)))))\n  j < i\n\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> (0::'a))\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)))", "unfolding diagonal_least_nonzero[OF H inv_H up_H]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues residues \\<and>\n  echelon_form H \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      H $ i $ i \\<in> associates) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      (\\<forall>j<i. H $ j $ i \\<in> residues (H $ i $ i)))\n  j < i\n\ngoal (1 subgoal):\n 1. H $ j $ i \\<in> residues (H $ i $ i)", "by auto"], ["proof (state)\nthis:\n  H $ j $ (LEAST n. H $ i $ n \\<noteq> (0::'a))\n  \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The uniqueness of the Hermite Normal Form is proven following the proof presented in the book\n  Integral Matrices (1972) by Morris Newman.\\<close>"], ["", "lemma Hermite_unique:\n  fixes K::\"'a::{bezout_ring_div,normalization_euclidean_semiring,unique_euclidean_ring}^'n::mod_type^'n::mod_type\"\n  assumes A_PH: \"A = P ** H\" \n  and A_QK: \"A = Q ** K\"\n  and inv_A: \"invertible A\"\n  and inv_P: \"invertible P\"\n  and inv_Q: \"invertible Q\"\n  and H: \"Hermite associates residues H\"\n  and K: \"Hermite associates residues K\"\n  shows \"H = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H = K", "have cs_residues: \"Complete_set_residues residues\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_set_residues residues", "using H"], ["proof (prove)\nusing this:\n  Hermite associates residues H\n\ngoal (1 subgoal):\n 1. Complete_set_residues residues", "unfolding Hermite_def"], ["proof (prove)\nusing this:\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues residues \\<and>\n  echelon_form H \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)) \\<in> associates) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      (\\<forall>j<i.\n          H $ j $ (LEAST n. H $ i $ n \\<noteq> (0::'a))\n          \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> (0::'a)))))\n\ngoal (1 subgoal):\n 1. Complete_set_residues residues", "by simp"], ["proof (state)\nthis:\n  Complete_set_residues residues\n\ngoal (1 subgoal):\n 1. H = K", "have inv_H: \"invertible H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible H", "by (metis A_PH inv_A inv_P invertible_def invertible_mult matrix_mul_assoc matrix_mul_lid)"], ["proof (state)\nthis:\n  invertible H\n\ngoal (1 subgoal):\n 1. H = K", "have inv_K: \"invertible K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible K", "by (metis A_QK inv_A inv_Q invertible_def invertible_mult matrix_mul_assoc matrix_mul_lid)"], ["proof (state)\nthis:\n  invertible K\n\ngoal (1 subgoal):\n 1. H = K", "define U where \"U = (matrix_inv P)**Q\""], ["proof (state)\nthis:\n  U = matrix_inv P ** Q\n\ngoal (1 subgoal):\n 1. H = K", "have inv_U: \"invertible U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible U", "by (metis U_def inv_P inv_Q invertible_def invertible_mult matrix_inv_left matrix_inv_right)"], ["proof (state)\nthis:\n  invertible U\n\ngoal (1 subgoal):\n 1. H = K", "have H_UK: \"H = U ** K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = U ** K", "using A_PH A_QK inv_P"], ["proof (prove)\nusing this:\n  A = P ** H\n  A = Q ** K\n  invertible P\n\ngoal (1 subgoal):\n 1. H = U ** K", "by (metis U_def matrix_inv_left matrix_mul_assoc matrix_mul_lid)"], ["proof (state)\nthis:\n  H = U ** K\n\ngoal (1 subgoal):\n 1. H = K", "have \"det K *k U = H ** adjugate K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det K *k U = H ** adjugate K", "unfolding H_UK matrix_mul_assoc[symmetric] mult_adjugate_det matrix_mul_mat"], ["proof (prove)\ngoal (1 subgoal):\n 1. det K *k U = det K *k U", ".."], ["proof (state)\nthis:\n  det K *k U = H ** adjugate K\n\ngoal (1 subgoal):\n 1. H = K", "have upper_triangular_H: \"upper_triangular H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular H", "by (metis H Hermite_def echelon_form_imp_upper_triagular)"], ["proof (state)\nthis:\n  upper_triangular H\n\ngoal (1 subgoal):\n 1. H = K", "have upper_triangular_K: \"upper_triangular K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular K", "by (metis K Hermite_def echelon_form_imp_upper_triagular)"], ["proof (state)\nthis:\n  upper_triangular K\n\ngoal (1 subgoal):\n 1. H = K", "have upper_triangular_U: \"upper_triangular U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular U", "by (metis H_UK inv_K matrix_inv_right matrix_mul_assoc matrix_mul_rid upper_triangular_H \n      upper_triangular_K upper_triangular_inverse upper_triangular_mult)"], ["proof (state)\nthis:\n  upper_triangular U\n\ngoal (1 subgoal):\n 1. H = K", "have unit_det_U: \"is_unit (det U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (det U)", "by (metis inv_U invertible_iff_is_unit)"], ["proof (state)\nthis:\n  is_unit (det U)\n\ngoal (1 subgoal):\n 1. H = K", "have is_unit_diagonal_U: \"(\\<forall>i. is_unit (U $ i $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. is_unit (U $ i $ i)", "by (rule is_unit_diagonal[OF upper_triangular_U unit_det_U])"], ["proof (state)\nthis:\n  \\<forall>i. is_unit (U $ i $ i)\n\ngoal (1 subgoal):\n 1. H = K", "have Uii_1: \"(\\<forall>i. (U $ i $ i) = 1)\" and Hii_Kii: \"(\\<forall>i. (H $ i $ i) = (K $ i $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. U $ i $ i = (1::'a) &&& \\<forall>i. H $ i $ i = K $ i $ i", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. U $ i $ i = (1::'a)\n 2. \\<And>i. H $ i $ i = K $ i $ i", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. U $ i $ i = (1::'a)\n 2. \\<And>i. H $ i $ i = K $ i $ i", "have Hii: \"H $ i $ i \\<in> associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "by (rule diagonal_in_associates[OF H inv_H upper_triangular_H])"], ["proof (state)\nthis:\n  H $ i $ i \\<in> associates\n\ngoal (2 subgoals):\n 1. \\<And>i. U $ i $ i = (1::'a)\n 2. \\<And>i. H $ i $ i = K $ i $ i", "have Kii: \"K $ i $ i \\<in> associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K $ i $ i \\<in> associates", "by (rule diagonal_in_associates[OF K inv_K upper_triangular_K])"], ["proof (state)\nthis:\n  K $ i $ i \\<in> associates\n\ngoal (2 subgoals):\n 1. \\<And>i. U $ i $ i = (1::'a)\n 2. \\<And>i. H $ i $ i = K $ i $ i", "have ass_Hii_Kii: \"normalize (H $ i $ i) = normalize (K $ i $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (H $ i $ i) = normalize (K $ i $ i)", "by (meson associatedI inv_H inv_K invertible_iff_is_unit is_unit_diagonal\n                unit_imp_dvd upper_triangular_H upper_triangular_K)"], ["proof (state)\nthis:\n  normalize (H $ i $ i) = normalize (K $ i $ i)\n\ngoal (2 subgoals):\n 1. \\<And>i. U $ i $ i = (1::'a)\n 2. \\<And>i. H $ i $ i = K $ i $ i", "show Hii_eq_Kii: \"H $ i $ i = K $ i $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i = K $ i $ i", "by (metis Hermite_def Hii K Kii ass_Hii_Kii in_Ass_not_associated)"], ["proof (state)\nthis:\n  H $ i $ i = K $ i $ i\n\ngoal (1 subgoal):\n 1. \\<And>i. U $ i $ i = (1::'a)", "have \"H $ i $ i = U $ i $ i * K $ i $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i = U $ i $ i * K $ i $ i", "by (metis H_UK upper_triangular_K upper_triangular_U upper_triangular_mult_diagonal)"], ["proof (state)\nthis:\n  H $ i $ i = U $ i $ i * K $ i $ i\n\ngoal (1 subgoal):\n 1. \\<And>i. U $ i $ i = (1::'a)", "thus \"U $ i $ i = 1\""], ["proof (prove)\nusing this:\n  H $ i $ i = U $ i $ i * K $ i $ i\n\ngoal (1 subgoal):\n 1. U $ i $ i = (1::'a)", "unfolding Hii_eq_Kii mult_cancel_right1"], ["proof (prove)\nusing this:\n  K $ i $ i = (0::'a) \\<or> U $ i $ i = (1::'a)\n\ngoal (1 subgoal):\n 1. U $ i $ i = (1::'a)", "by (metis Hii_eq_Kii inv_H invertible_iff_is_unit\n        is_unit_diagonal not_is_unit_0 upper_triangular_H)"], ["proof (state)\nthis:\n  U $ i $ i = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i. U $ i $ i = (1::'a)\n  \\<forall>i. H $ i $ i = K $ i $ i\n\ngoal (1 subgoal):\n 1. H = K", "have zero_above: \"\\<forall>j s. j\\<ge>1 \\<and> j < ncols A - to_nat s \\<longrightarrow> U $ s $ (s + from_nat j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j s.\n       1 \\<le> j \\<and>\n       j < ncols A - mod_type_class.to_nat s \\<longrightarrow>\n       U $ s $ (s + mod_type_class.from_nat j) = (0::'a)", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j s.\n       \\<lbrakk>1 \\<le> j; j < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat j) = (0::'a)", "fix j s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j s.\n       \\<lbrakk>1 \\<le> j; j < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat j) = (0::'a)", "assume  \"1 \\<le> j\" and \"j < ncols A - (to_nat (s::'n))\""], ["proof (state)\nthis:\n  1 \\<le> j\n  j < ncols A - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. \\<And>j s.\n       \\<lbrakk>1 \\<le> j; j < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat j) = (0::'a)", "thus \"U $ s $ (s + from_nat j) = 0\""], ["proof (prove)\nusing this:\n  1 \\<le> j\n  j < ncols A - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat j) = (0::'a)", "proof (induct j rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    y < ncols A - mod_type_class.to_nat s\\<rbrakk>\n                   \\<Longrightarrow> U $ s $\n                                     (s + mod_type_class.from_nat y) =\n                                     (0::'a);\n        1 \\<le> x; x < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat x) = (0::'a)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    y < ncols A - mod_type_class.to_nat s\\<rbrakk>\n                   \\<Longrightarrow> U $ s $\n                                     (s + mod_type_class.from_nat y) =\n                                     (0::'a);\n        1 \\<le> x; x < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat x) = (0::'a)", "assume induct_step: \"(\\<And>y. y < p \\<Longrightarrow> 1 \\<le> y \\<Longrightarrow> y < ncols A - to_nat s \\<Longrightarrow> U $ s $ (s + from_nat y) = 0)\"\n        and p1: \"1 \\<le> p\" and p2: \"p < ncols A - to_nat s\""], ["proof (state)\nthis:\n  \\<lbrakk>?y < p; 1 \\<le> ?y;\n   ?y < ncols A - mod_type_class.to_nat s\\<rbrakk>\n  \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat ?y) = (0::'a)\n  1 \\<le> p\n  p < ncols A - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    y < ncols A - mod_type_class.to_nat s\\<rbrakk>\n                   \\<Longrightarrow> U $ s $\n                                     (s + mod_type_class.from_nat y) =\n                                     (0::'a);\n        1 \\<le> x; x < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat x) = (0::'a)", "have s_less: \"s < s + from_nat p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s < s + mod_type_class.from_nat p", "using p1 p2"], ["proof (prove)\nusing this:\n  1 \\<le> p\n  p < ncols A - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. s < s + mod_type_class.from_nat p", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  1 \\<le> p\n  p < CARD('n) - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. s < s + mod_type_class.from_nat p", "by (metis One_nat_def add.commute add_diff_cancel_right' add_lessD1 add_to_nat_def \n          from_nat_to_nat_id less_diff_conv neq_iff not_le\n          to_nat_from_nat_id to_nat_le zero_less_Suc)"], ["proof (state)\nthis:\n  s < s + mod_type_class.from_nat p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    y < ncols A - mod_type_class.to_nat s\\<rbrakk>\n                   \\<Longrightarrow> U $ s $\n                                     (s + mod_type_class.from_nat y) =\n                                     (0::'a);\n        1 \\<le> x; x < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat x) = (0::'a)", "show \"U $ s $ (s + from_nat p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "have UNIV_rw: \"UNIV = insert s (UNIV-{s})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = insert s (UNIV - {s})", "by auto"], ["proof (state)\nthis:\n  UNIV = insert s (UNIV - {s})\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "have UNIV_s_rw: \"UNIV-{s} = insert (s + from_nat p) ((UNIV-{s}) - {s + from_nat p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV - {s} =\n    insert (s + mod_type_class.from_nat p)\n     (UNIV - {s} - {s + mod_type_class.from_nat p})", "using p1 p2 s_less"], ["proof (prove)\nusing this:\n  1 \\<le> p\n  p < ncols A - mod_type_class.to_nat s\n  s < s + mod_type_class.from_nat p\n\ngoal (1 subgoal):\n 1. UNIV - {s} =\n    insert (s + mod_type_class.from_nat p)\n     (UNIV - {s} - {s + mod_type_class.from_nat p})", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  1 \\<le> p\n  p < CARD('n) - mod_type_class.to_nat s\n  s < s + mod_type_class.from_nat p\n\ngoal (1 subgoal):\n 1. UNIV - {s} =\n    insert (s + mod_type_class.from_nat p)\n     (UNIV - {s} - {s + mod_type_class.from_nat p})", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  UNIV - {s} =\n  insert (s + mod_type_class.from_nat p)\n   (UNIV - {s} - {s + mod_type_class.from_nat p})\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "have sum_rw: \"(\\<Sum>k\\<in>UNIV-{s}. U $ s $ k * K $ k $ (s + from_nat p)) \n          = U $ s $ (s + from_nat p) * K $ (s + from_nat p) $ (s + from_nat p) \n          + (\\<Sum>k\\<in>(UNIV-{s})-{s + from_nat p}. U $ s $ k * K $ k $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV - {s}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    U $ s $ (s + mod_type_class.from_nat p) *\n    K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n    (\\<Sum>k\\<in>UNIV - {s} - {s + mod_type_class.from_nat p}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "using UNIV_s_rw sum.insert"], ["proof (prove)\nusing this:\n  UNIV - {s} =\n  insert (s + mod_type_class.from_nat p)\n   (UNIV - {s} - {s + mod_type_class.from_nat p})\n  \\<lbrakk>finite ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> sum ?g (insert ?x ?A) = ?g ?x + sum ?g ?A\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV - {s}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    U $ s $ (s + mod_type_class.from_nat p) *\n    K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n    (\\<Sum>k\\<in>UNIV - {s} - {s + mod_type_class.from_nat p}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "by (metis (erased, lifting) Diff_iff finite singletonI)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV - {s}.\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n  (\\<Sum>k\\<in>UNIV - {s} - {s + mod_type_class.from_nat p}.\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "have sum_0: \"(\\<Sum>k\\<in>(UNIV-{s})-{s + from_nat p}. U $ s $ k * K $ k $ (s + from_nat p)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV - {s} - {s + mod_type_class.from_nat p}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    (0::'a)", "proof (rule sum.neutral, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV - {s} -\n               {s + mod_type_class.from_nat p} \\<Longrightarrow>\n       U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV - {s} -\n               {s + mod_type_class.from_nat p} \\<Longrightarrow>\n       U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "assume x: \"x \\<in> UNIV - {s} - {s + from_nat p}\""], ["proof (state)\nthis:\n  x \\<in> UNIV - {s} - {s + mod_type_class.from_nat p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV - {s} -\n               {s + mod_type_class.from_nat p} \\<Longrightarrow>\n       U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "show \"U $ s $ x * K $ x $ (s + from_nat p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "proof (cases \"x<s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)\n 2. \\<not> x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "case True"], ["proof (state)\nthis:\n  x < s\n\ngoal (2 subgoals):\n 1. x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)\n 2. \\<not> x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x < s\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "using upper_triangular_U"], ["proof (prove)\nusing this:\n  x < s\n  upper_triangular U\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  x < s\n  \\<forall>i j. j < i \\<longrightarrow> U $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> x < s\n\ngoal (1 subgoal):\n 1. \\<not> x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "hence x_g_s: \"x>s\""], ["proof (prove)\nusing this:\n  \\<not> x < s\n\ngoal (1 subgoal):\n 1. s < x", "using x"], ["proof (prove)\nusing this:\n  \\<not> x < s\n  x \\<in> UNIV - {s} - {s + mod_type_class.from_nat p}\n\ngoal (1 subgoal):\n 1. s < x", "by (metis Diff_iff neq_iff singletonI)"], ["proof (state)\nthis:\n  s < x\n\ngoal (1 subgoal):\n 1. \\<not> x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "proof (cases \"x<s+from_nat p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)\n 2. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "case True"], ["proof (state)\nthis:\n  x < s + mod_type_class.from_nat p\n\ngoal (2 subgoals):\n 1. x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)\n 2. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "define a where \"a = to_nat x - to_nat s\""], ["proof (state)\nthis:\n  a = mod_type_class.to_nat x - mod_type_class.to_nat s\n\ngoal (2 subgoals):\n 1. x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)\n 2. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "from x_g_s"], ["proof (chain)\npicking this:\n  s < x", "have \"to_nat s < to_nat x\""], ["proof (prove)\nusing this:\n  s < x\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat s < mod_type_class.to_nat x", "by (rule to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat s < mod_type_class.to_nat x\n\ngoal (2 subgoals):\n 1. x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)\n 2. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "hence xa: \"x=s+(from_nat a)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat s < mod_type_class.to_nat x\n\ngoal (1 subgoal):\n 1. x = s + mod_type_class.from_nat a", "unfolding a_def add_to_nat_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat s < mod_type_class.to_nat x\n\ngoal (1 subgoal):\n 1. x =\n    mod_type_class.from_nat\n     (mod_type_class.to_nat s +\n      mod_type_class.to_nat\n       (mod_type_class.from_nat\n         (mod_type_class.to_nat x - mod_type_class.to_nat s)))", "by (simp add: less_imp_diff_less to_nat_less_card algebra_simps to_nat_from_nat_id)"], ["proof (state)\nthis:\n  x = s + mod_type_class.from_nat a\n\ngoal (2 subgoals):\n 1. x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)\n 2. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "have \"U $ s $ x =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ s $ x = (0::'a)", "proof (unfold xa, rule induct_step)"], ["proof (state)\ngoal (3 subgoals):\n 1. a < p\n 2. 1 \\<le> a\n 3. a < ncols A - mod_type_class.to_nat s", "show a_p: \"a<p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < p", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x - mod_type_class.to_nat s < p", "using p2"], ["proof (prove)\nusing this:\n  p < ncols A - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x - mod_type_class.to_nat s < p", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  p < CARD('n) - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x - mod_type_class.to_nat s < p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p < CARD('n) - mod_type_class.to_nat s \\<Longrightarrow>\n    mod_type_class.to_nat x - mod_type_class.to_nat s < p", "have \"x < from_nat (to_nat s + to_nat (from_nat p::'n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < mod_type_class.from_nat\n         (mod_type_class.to_nat s +\n          mod_type_class.to_nat (mod_type_class.from_nat p))", "by (metis (no_types) True add_to_nat_def)"], ["proof (state)\nthis:\n  x < mod_type_class.from_nat\n       (mod_type_class.to_nat s +\n        mod_type_class.to_nat (mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. p < CARD('n) - mod_type_class.to_nat s \\<Longrightarrow>\n    mod_type_class.to_nat x - mod_type_class.to_nat s < p", "hence \"to_nat x - to_nat s < to_nat (from_nat p::'n)\""], ["proof (prove)\nusing this:\n  x < mod_type_class.from_nat\n       (mod_type_class.to_nat s +\n        mod_type_class.to_nat (mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x - mod_type_class.to_nat s\n    < mod_type_class.to_nat (mod_type_class.from_nat p)", "by (simp add: add.commute less_diff_conv2 less_imp_le to_nat_le x_g_s)"], ["proof (state)\nthis:\n  mod_type_class.to_nat x - mod_type_class.to_nat s\n  < mod_type_class.to_nat (mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. p < CARD('n) - mod_type_class.to_nat s \\<Longrightarrow>\n    mod_type_class.to_nat x - mod_type_class.to_nat s < p", "thus \"to_nat x - to_nat s < p\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat x - mod_type_class.to_nat s\n  < mod_type_class.to_nat (mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x - mod_type_class.to_nat s < p", "by (metis (no_types) from_nat_eq_imp_eq from_nat_to_nat_id le_less_trans \n                        less_imp_le not_le to_nat_less_card)"], ["proof (state)\nthis:\n  mod_type_class.to_nat x - mod_type_class.to_nat s < p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < p\n\ngoal (2 subgoals):\n 1. 1 \\<le> a\n 2. a < ncols A - mod_type_class.to_nat s", "show \"1 \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> a", "by (auto simp add: a_def p1 p2) (metis Suc_leI to_nat_mono x_g_s zero_less_diff)"], ["proof (state)\nthis:\n  1 \\<le> a\n\ngoal (1 subgoal):\n 1. a < ncols A - mod_type_class.to_nat s", "show \"a < ncols A - to_nat s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < ncols A - mod_type_class.to_nat s", "using a_p p2"], ["proof (prove)\nusing this:\n  a < p\n  p < ncols A - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. a < ncols A - mod_type_class.to_nat s", "by auto"], ["proof (state)\nthis:\n  a < ncols A - mod_type_class.to_nat s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U $ s $ x = (0::'a)\n\ngoal (2 subgoals):\n 1. x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)\n 2. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  U $ s $ x = (0::'a)\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> x < s + mod_type_class.from_nat p\n\ngoal (1 subgoal):\n 1. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "hence \"x>s+from_nat p\""], ["proof (prove)\nusing this:\n  \\<not> x < s + mod_type_class.from_nat p\n\ngoal (1 subgoal):\n 1. s + mod_type_class.from_nat p < x", "using x_g_s x"], ["proof (prove)\nusing this:\n  \\<not> x < s + mod_type_class.from_nat p\n  s < x\n  x \\<in> UNIV - {s} - {s + mod_type_class.from_nat p}\n\ngoal (1 subgoal):\n 1. s + mod_type_class.from_nat p < x", "by auto"], ["proof (state)\nthis:\n  s + mod_type_class.from_nat p < x\n\ngoal (1 subgoal):\n 1. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  s + mod_type_class.from_nat p < x\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "using upper_triangular_K"], ["proof (prove)\nusing this:\n  s + mod_type_class.from_nat p < x\n  upper_triangular K\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  s + mod_type_class.from_nat p < x\n  \\<forall>i j. j < i \\<longrightarrow> K $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV - {s} - {s + mod_type_class.from_nat p}.\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "have \"H $ s $ (s + from_nat p) = (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p) =\n    (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "unfolding H_UK matrix_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j. \\<Sum>k\\<in>UNIV. U $ i $ k * K $ k $ j) $ s $\n    (s + mod_type_class.from_nat p) =\n    (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "by auto"], ["proof (state)\nthis:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "also"], ["proof (state)\nthis:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "have \"... = (\\<Sum>k\\<in>insert s (UNIV-{s}). U $ s $ k * K $ k $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    (\\<Sum>k\\<in>insert s (UNIV - {s}).\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "using UNIV_rw"], ["proof (prove)\nusing this:\n  UNIV = insert s (UNIV - {s})\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    (\\<Sum>k\\<in>insert s (UNIV - {s}).\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  (\\<Sum>k\\<in>insert s (UNIV - {s}).\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  (\\<Sum>k\\<in>insert s (UNIV - {s}).\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "have \"... = U $ s $ s * K $ s $ (s + from_nat p) \n          + (\\<Sum>k\\<in>UNIV-{s}. U $ s $ k * K $ k $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>insert s (UNIV - {s}).\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n    (\\<Sum>k\\<in>UNIV - {s}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "by (rule sum.insert, simp_all)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert s (UNIV - {s}).\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  (\\<Sum>k\\<in>UNIV - {s}.\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert s (UNIV - {s}).\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  (\\<Sum>k\\<in>UNIV - {s}.\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "have \"... = U $ s $ s * K $ s $ (s + from_nat p) \n          + U $ s $ (s + from_nat p) * K $ (s + from_nat p) $ (s + from_nat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n    (\\<Sum>k\\<in>UNIV - {s}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n    U $ s $ (s + mod_type_class.from_nat p) *\n    K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p)", "unfolding sum_rw sum_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n    (U $ s $ (s + mod_type_class.from_nat p) *\n     K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n     (0::'a)) =\n    U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n    U $ s $ (s + mod_type_class.from_nat p) *\n    K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p)", "by simp"], ["proof (state)\nthis:\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  (\\<Sum>k\\<in>UNIV - {s}.\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p)", "have H_s_sp: \"H $ s $ (s + from_nat p) \n          = U $ s $ (s + from_nat p) * K $ (s + from_nat p) $ (s + from_nat p) + K $ s $ (s + from_nat p)\""], ["proof (prove)\nusing this:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p) =\n    U $ s $ (s + mod_type_class.from_nat p) *\n    K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n    K $ s $ (s + mod_type_class.from_nat p)", "using Uii_1"], ["proof (prove)\nusing this:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p)\n  \\<forall>i. U $ i $ i = (1::'a)\n\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p) =\n    U $ s $ (s + mod_type_class.from_nat p) *\n    K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n    K $ s $ (s + mod_type_class.from_nat p)", "by auto"], ["proof (state)\nthis:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n  K $ s $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "hence cong_HK: \"cong (H $ s $ (s + from_nat p)) (K $ s $ (s + from_nat p)) (K $ (s+from_nat p) $ (s + from_nat p))\""], ["proof (prove)\nusing this:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n  K $ s $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. cong (H $ s $ (s + mod_type_class.from_nat p))\n     (K $ s $ (s + mod_type_class.from_nat p))\n     (K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p))", "unfolding cong_def"], ["proof (prove)\nusing this:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n  K $ s $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       H $ s $ (s + mod_type_class.from_nat p) -\n       K $ s $ (s + mod_type_class.from_nat p) =\n       K $ (s + mod_type_class.from_nat p) $\n       (s + mod_type_class.from_nat p) *\n       k", "by auto"], ["proof (state)\nthis:\n  cong (H $ s $ (s + mod_type_class.from_nat p))\n   (K $ s $ (s + mod_type_class.from_nat p))\n   (K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "have H_s_sp_residues: \"(H $ s $ (s + from_nat p)) \\<in> residues (K $ (s+from_nat p) $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p)\n    \\<in> residues\n           (K $ (s + mod_type_class.from_nat p) $\n            (s + mod_type_class.from_nat p))", "using above_diagonal_in_residues[OF H inv_H upper_triangular_H s_less]"], ["proof (prove)\nusing this:\n  H $ s $\n  (LEAST n. H $ (s + mod_type_class.from_nat p) $ n \\<noteq> (0::'a))\n  \\<in> residues\n         (H $ (s + mod_type_class.from_nat p) $\n          (LEAST n.\n              H $ (s + mod_type_class.from_nat p) $ n \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p)\n    \\<in> residues\n           (K $ (s + mod_type_class.from_nat p) $\n            (s + mod_type_class.from_nat p))", "unfolding diagonal_least_nonzero[OF H inv_H upper_triangular_H]"], ["proof (prove)\nusing this:\n  H $ s $ (s + mod_type_class.from_nat p)\n  \\<in> residues\n         (H $ (s + mod_type_class.from_nat p) $\n          (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p)\n    \\<in> residues\n           (K $ (s + mod_type_class.from_nat p) $\n            (s + mod_type_class.from_nat p))", "by (metis Hii_Kii)"], ["proof (state)\nthis:\n  H $ s $ (s + mod_type_class.from_nat p)\n  \\<in> residues\n         (K $ (s + mod_type_class.from_nat p) $\n          (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "have K_s_sp_residues: \"(K $ s $ (s + from_nat p)) \\<in> residues (K $ (s+from_nat p) $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K $ s $ (s + mod_type_class.from_nat p)\n    \\<in> residues\n           (K $ (s + mod_type_class.from_nat p) $\n            (s + mod_type_class.from_nat p))", "using above_diagonal_in_residues[OF K inv_K upper_triangular_K s_less]"], ["proof (prove)\nusing this:\n  K $ s $\n  (LEAST n. K $ (s + mod_type_class.from_nat p) $ n \\<noteq> (0::'a))\n  \\<in> residues\n         (K $ (s + mod_type_class.from_nat p) $\n          (LEAST n.\n              K $ (s + mod_type_class.from_nat p) $ n \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. K $ s $ (s + mod_type_class.from_nat p)\n    \\<in> residues\n           (K $ (s + mod_type_class.from_nat p) $\n            (s + mod_type_class.from_nat p))", "unfolding diagonal_least_nonzero[OF K inv_K upper_triangular_K]"], ["proof (prove)\nusing this:\n  K $ s $ (s + mod_type_class.from_nat p)\n  \\<in> residues\n         (K $ (s + mod_type_class.from_nat p) $\n          (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. K $ s $ (s + mod_type_class.from_nat p)\n    \\<in> residues\n           (K $ (s + mod_type_class.from_nat p) $\n            (s + mod_type_class.from_nat p))", "."], ["proof (state)\nthis:\n  K $ s $ (s + mod_type_class.from_nat p)\n  \\<in> residues\n         (K $ (s + mod_type_class.from_nat p) $\n          (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "have Hs_sp_Ks_sp: \"(H $ s $ (s + from_nat p)) = (K $ s $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p) =\n    K $ s $ (s + mod_type_class.from_nat p)", "using cong_HK in_Res_not_congruent[OF cs_residues H_s_sp_residues K_s_sp_residues]"], ["proof (prove)\nusing this:\n  cong (H $ s $ (s + mod_type_class.from_nat p))\n   (K $ s $ (s + mod_type_class.from_nat p))\n   (K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p))\n  H $ s $ (s + mod_type_class.from_nat p) \\<noteq>\n  K $ s $ (s + mod_type_class.from_nat p) \\<Longrightarrow>\n  \\<not> cong (H $ s $ (s + mod_type_class.from_nat p))\n          (K $ s $ (s + mod_type_class.from_nat p))\n          (K $ (s + mod_type_class.from_nat p) $\n           (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p) =\n    K $ s $ (s + mod_type_class.from_nat p)", "by fast"], ["proof (state)\nthis:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  K $ s $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "have \"is_unit (K $ (s + from_nat p) $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit\n     (K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p))", "by (metis Hii_Kii inv_H invertible_iff_is_unit is_unit_diagonal upper_triangular_H)"], ["proof (state)\nthis:\n  is_unit\n   (K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "hence \"K $ (s + from_nat p) $ (s + from_nat p) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  is_unit\n   (K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. K $ (s + mod_type_class.from_nat p) $\n    (s + mod_type_class.from_nat p) \\<noteq>\n    (0::'a)", "by (metis not_is_unit_0)"], ["proof (state)\nthis:\n  K $ (s + mod_type_class.from_nat p) $\n  (s + mod_type_class.from_nat p) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  K $ (s + mod_type_class.from_nat p) $\n  (s + mod_type_class.from_nat p) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "unfolding from_nat_1"], ["proof (prove)\nusing this:\n  K $ (s + mod_type_class.from_nat p) $\n  (s + mod_type_class.from_nat p) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "using H_s_sp"], ["proof (prove)\nusing this:\n  K $ (s + mod_type_class.from_nat p) $\n  (s + mod_type_class.from_nat p) \\<noteq>\n  (0::'a)\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n  K $ s $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "unfolding Hs_sp_Ks_sp"], ["proof (prove)\nusing this:\n  K $ (s + mod_type_class.from_nat p) $\n  (s + mod_type_class.from_nat p) \\<noteq>\n  (0::'a)\n  K $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n  K $ s $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  U $ s $ (s + mod_type_class.from_nat p) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U $ s $ (s + mod_type_class.from_nat p) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U $ s $ (s + mod_type_class.from_nat j) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j s.\n     1 \\<le> j \\<and>\n     j < ncols A - mod_type_class.to_nat s \\<longrightarrow>\n     U $ s $ (s + mod_type_class.from_nat j) = (0::'a)\n\ngoal (1 subgoal):\n 1. H = K", "have \"U = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U = mat (1::'a)", "proof (unfold mat_def vec_eq_iff, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia. U $ ia $ ia = (1::'a)\n 2. \\<And>i ia. i \\<noteq> ia \\<Longrightarrow> U $ i $ ia = (0::'a)", "fix ia"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia. U $ ia $ ia = (1::'a)\n 2. \\<And>i ia. i \\<noteq> ia \\<Longrightarrow> U $ i $ ia = (0::'a)", "show \"U $ ia $ ia = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ ia $ ia = (1::'a)", "using Uii_1"], ["proof (prove)\nusing this:\n  \\<forall>i. U $ i $ i = (1::'a)\n\ngoal (1 subgoal):\n 1. U $ ia $ ia = (1::'a)", "by simp"], ["proof (state)\nthis:\n  U $ ia $ ia = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i ia. i \\<noteq> ia \\<Longrightarrow> U $ i $ ia = (0::'a)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia. i \\<noteq> ia \\<Longrightarrow> U $ i $ ia = (0::'a)", "assume i_ia: \"i \\<noteq> ia\""], ["proof (state)\nthis:\n  i \\<noteq> ia\n\ngoal (1 subgoal):\n 1. \\<And>i ia. i \\<noteq> ia \\<Longrightarrow> U $ i $ ia = (0::'a)", "show \"U $ i $ ia = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ i $ ia = (0::'a)", "proof (cases \"ia<i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ia < i \\<Longrightarrow> U $ i $ ia = (0::'a)\n 2. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = (0::'a)", "case True"], ["proof (state)\nthis:\n  ia < i\n\ngoal (2 subgoals):\n 1. ia < i \\<Longrightarrow> U $ i $ ia = (0::'a)\n 2. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ia < i\n\ngoal (1 subgoal):\n 1. U $ i $ ia = (0::'a)", "using upper_triangular_U"], ["proof (prove)\nusing this:\n  ia < i\n  upper_triangular U\n\ngoal (1 subgoal):\n 1. U $ i $ ia = (0::'a)", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  ia < i\n  \\<forall>i j. j < i \\<longrightarrow> U $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. U $ i $ ia = (0::'a)", "by auto"], ["proof (state)\nthis:\n  U $ i $ ia = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> ia < i\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = (0::'a)", "hence i_less_ia: \"i<ia\""], ["proof (prove)\nusing this:\n  \\<not> ia < i\n\ngoal (1 subgoal):\n 1. i < ia", "using i_ia"], ["proof (prove)\nusing this:\n  \\<not> ia < i\n  i \\<noteq> ia\n\ngoal (1 subgoal):\n 1. i < ia", "by auto"], ["proof (state)\nthis:\n  i < ia\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = (0::'a)", "define a where \"a = to_nat ia - to_nat i\""], ["proof (state)\nthis:\n  a = mod_type_class.to_nat ia - mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = (0::'a)", "have ia_eq: \"ia = i + from_nat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia = i + mod_type_class.from_nat a", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ia =\n    i +\n    mod_type_class.from_nat\n     (mod_type_class.to_nat ia - mod_type_class.to_nat i)", "by (metis i_less_ia a_def add_to_nat_def dual_order.strict_iff_order from_nat_to_nat_id \n            le_add_diff_inverse less_imp_diff_less to_nat_from_nat_id to_nat_less_card to_nat_mono)"], ["proof (state)\nthis:\n  ia = i + mod_type_class.from_nat a\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = (0::'a)", "have \"1 \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> a", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> mod_type_class.to_nat ia - mod_type_class.to_nat i", "by (metis diff_is_0_eq i_less_ia less_one not_less to_nat_mono)"], ["proof (state)\nthis:\n  1 \\<le> a\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = (0::'a)", "moreover"], ["proof (state)\nthis:\n  1 \\<le> a\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = (0::'a)", "have \"a < ncols A - to_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < ncols A - mod_type_class.to_nat i", "unfolding a_def ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat ia - mod_type_class.to_nat i\n    < CARD('n) - mod_type_class.to_nat i", "by (metis False diff_less_mono not_less to_nat_less_card to_nat_mono')"], ["proof (state)\nthis:\n  a < ncols A - mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  1 \\<le> a\n  a < ncols A - mod_type_class.to_nat i", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> a\n  a < ncols A - mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. U $ i $ ia = (0::'a)", "using zero_above"], ["proof (prove)\nusing this:\n  1 \\<le> a\n  a < ncols A - mod_type_class.to_nat i\n  \\<forall>j s.\n     1 \\<le> j \\<and>\n     j < ncols A - mod_type_class.to_nat s \\<longrightarrow>\n     U $ s $ (s + mod_type_class.from_nat j) = (0::'a)\n\ngoal (1 subgoal):\n 1. U $ i $ ia = (0::'a)", "unfolding ia_eq"], ["proof (prove)\nusing this:\n  1 \\<le> a\n  a < ncols A - mod_type_class.to_nat i\n  \\<forall>j s.\n     1 \\<le> j \\<and>\n     j < ncols A - mod_type_class.to_nat s \\<longrightarrow>\n     U $ s $ (s + mod_type_class.from_nat j) = (0::'a)\n\ngoal (1 subgoal):\n 1. U $ i $ (i + mod_type_class.from_nat a) = (0::'a)", "by blast"], ["proof (state)\nthis:\n  U $ i $ ia = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U $ i $ ia = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U = mat (1::'a)\n\ngoal (1 subgoal):\n 1. H = K", "thus ?thesis"], ["proof (prove)\nusing this:\n  U = mat (1::'a)\n\ngoal (1 subgoal):\n 1. H = K", "using H_UK matrix_mul_lid"], ["proof (prove)\nusing this:\n  U = mat (1::'a)\n  H = U ** K\n  mat (1::?'a) ** ?A = ?A\n\ngoal (1 subgoal):\n 1. H = K", "by fast"], ["proof (state)\nthis:\n  H = K\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Examples of execution\\<close>"], ["", "value[code] \"let A = list_of_list_to_matrix ([[37,8,6],[5,4,-8],[3,24,-7]])::int^3^3\n  in matrix_to_list_of_list (Hermite_of A ass_function_euclidean res_function_euclidean euclid_ext2)\""], ["", "value[code] \"let A = list_of_list_to_matrix ([[[:3,4,5:],[:-2,1:]],[[:-1,0,2:],[:0,1,4,1:]]])::real poly^2^2\n  in matrix_to_list_of_list (Hermite_of A ass_function_euclidean res_function_euclidean euclid_ext2)\""], ["", "end"]]}