{"file_name": "/home/qj213/afp-2021-10-22/thys/FOL_Seq_Calc1/Sequent.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FOL_Seq_Calc1", "problem_names": ["lemma Shift: \\<open>\\<turnstile> rotate1 G \\<Longrightarrow> \\<turnstile> G\\<close>", "lemma Swap: \\<open>\\<turnstile> B # A # G \\<Longrightarrow> \\<turnstile> A # B # G\\<close>", "lemma \\<open>\\<turnstile> [Neg (Pred ''A'' []), Pred ''A'' []]\\<close>", "lemma \\<open>\\<turnstile> [And (Pred ''A'' []) (Pred ''B'' []), Neg (And (Pred ''B'' []) (Pred ''A'' []))]\\<close>", "lemma SC_soundness: \\<open>\\<turnstile> G \\<Longrightarrow> \\<exists>p \\<in> set G. eval e f g p\\<close>", "lemma compl: \\<open>compl p = Neg p \\<or> (\\<exists>q. compl p = q \\<and> p = Neg q)\\<close>", "lemma new_compl: \\<open>new n p \\<Longrightarrow> new n (compl p)\\<close>", "lemma news_compl: \\<open>news n G \\<Longrightarrow> news n (map compl G)\\<close>", "theorem TC_SC: \\<open>\\<stileturn> G \\<Longrightarrow> \\<turnstile> map compl G\\<close>", "theorem SC_completeness:\n  fixes p :: \\<open>(nat, nat) form\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. list_all (eval e f g) ps \\<longrightarrow> eval e f g p\\<close>\n  shows \\<open>\\<turnstile> p # map compl ps\\<close>"], "translations": [["", "lemma Shift: \\<open>\\<turnstile> rotate1 G \\<Longrightarrow> \\<turnstile> G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> rotate1 G \\<Longrightarrow> \\<turnstile> G", "by (simp add: Order)"], ["", "lemma Swap: \\<open>\\<turnstile> B # A # G \\<Longrightarrow> \\<turnstile> A # B # G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> B # A # G \\<Longrightarrow> \\<turnstile> A # B # G", "by (simp add: Order insert_commute)"], ["", "lemma \\<open>\\<turnstile> [Neg (Pred ''A'' []), Pred ''A'' []]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> [Neg (Pred ''A'' []), Pred ''A'' []]", "by (rule Shift, simp) (rule Basic)"], ["", "lemma \\<open>\\<turnstile> [And (Pred ''A'' []) (Pred ''B'' []), Neg (And (Pred ''B'' []) (Pred ''A'' []))]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> [And (Pred ''A'' []) (Pred ''B'' []),\n                  Neg (And (Pred ''B'' []) (Pred ''A'' []))]", "apply (rule BetaAnd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<turnstile> [Pred ''A'' [], Neg (And (Pred ''B'' []) (Pred ''A'' []))]\n 2. \\<turnstile> [Pred ''B'' [], Neg (And (Pred ''B'' []) (Pred ''A'' []))]", "apply (rule Swap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<turnstile> [Neg (And (Pred ''B'' []) (Pred ''A'' [])), Pred ''A'' []]\n 2. \\<turnstile> [Pred ''B'' [], Neg (And (Pred ''B'' []) (Pred ''A'' []))]", "apply (rule AlphaNegAnd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<turnstile> [Neg (Pred ''B'' []), Neg (Pred ''A'' []), Pred ''A'' []]\n 2. \\<turnstile> [Pred ''B'' [], Neg (And (Pred ''B'' []) (Pred ''A'' []))]", "apply (rule Shift, simp, rule Swap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<turnstile> [Pred ''A'' [], Neg (Pred ''A'' []), Neg (Pred ''B'' [])]\n 2. \\<turnstile> [Pred ''B'' [], Neg (And (Pred ''B'' []) (Pred ''A'' []))]", "apply (rule Basic)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> [Pred ''B'' [], Neg (And (Pred ''B'' []) (Pred ''A'' []))]", "apply (rule Swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> [Neg (And (Pred ''B'' []) (Pred ''A'' [])), Pred ''B'' []]", "apply (rule AlphaNegAnd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> [Neg (Pred ''B'' []), Neg (Pred ''A'' []), Pred ''B'' []]", "apply (rule Shift, rule Shift, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> [Pred ''B'' [], Neg (Pred ''B'' []), Neg (Pred ''A'' [])]", "apply (rule Basic)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Soundness\\<close>"], ["", "lemma SC_soundness: \\<open>\\<turnstile> G \\<Longrightarrow> \\<exists>p \\<in> set G. eval e f g p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> G \\<Longrightarrow> \\<exists>p\\<in>set G. eval e f g p", "proof (induct G arbitrary: f rule: SC.induct)"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>i l G f. Bex (set (Pred i l # Neg (Pred i l) # G)) (eval e f g)\n 2. \\<And>G f. Bex (set (Neg \\<bottom> # G)) (eval e f g)\n 3. \\<And>G f. Bex (set (\\<top> # G)) (eval e f g)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<turnstile> A # G;\n        \\<And>f. Bex (set (A # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Neg A) # G)) (eval e f g)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # Neg B # G;\n        \\<And>f. Bex (set (Neg A # Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (And A B) # G)) (eval e f g)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> A # B # G;\n        \\<And>f. Bex (set (A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Or A B # G)) (eval e f g)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # B # G;\n        \\<And>f. Bex (set (Neg A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Impl A B # G)) (eval e f g)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> A # G; \\<And>f. Bex (set (A # G)) (eval e f g);\n        \\<turnstile> B # G; \\<And>f. Bex (set (B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (And A B # G)) (eval e f g)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> Neg A # G;\n        \\<And>f. Bex (set (Neg A # G)) (eval e f g); \\<turnstile> Neg B # G;\n        \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Or A B) # G)) (eval e f g)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<turnstile> A # G;\n         \\<And>f. Bex (set (A # G)) (eval e f g); \\<turnstile> Neg B # G;\n         \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n        \\<Longrightarrow> Bex (set (Neg (Impl A B) # G)) (eval e f g)\nA total of 15 subgoals...", "case (DeltaForall A n G)"], ["proof (state)\nthis:\n  \\<turnstile> A[App n []/0] # G\n  \\<exists>a\\<in>set (A[App n []/0] # G). eval e ?f g a\n  news n (A # G)\n\ngoal (15 subgoals):\n 1. \\<And>i l G f. Bex (set (Pred i l # Neg (Pred i l) # G)) (eval e f g)\n 2. \\<And>G f. Bex (set (Neg \\<bottom> # G)) (eval e f g)\n 3. \\<And>G f. Bex (set (\\<top> # G)) (eval e f g)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<turnstile> A # G;\n        \\<And>f. Bex (set (A # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Neg A) # G)) (eval e f g)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # Neg B # G;\n        \\<And>f. Bex (set (Neg A # Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (And A B) # G)) (eval e f g)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> A # B # G;\n        \\<And>f. Bex (set (A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Or A B # G)) (eval e f g)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # B # G;\n        \\<And>f. Bex (set (Neg A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Impl A B # G)) (eval e f g)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> A # G; \\<And>f. Bex (set (A # G)) (eval e f g);\n        \\<turnstile> B # G; \\<And>f. Bex (set (B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (And A B # G)) (eval e f g)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> Neg A # G;\n        \\<And>f. Bex (set (Neg A # G)) (eval e f g); \\<turnstile> Neg B # G;\n        \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Or A B) # G)) (eval e f g)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<turnstile> A # G;\n         \\<And>f. Bex (set (A # G)) (eval e f g); \\<turnstile> Neg B # G;\n         \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n        \\<Longrightarrow> Bex (set (Neg (Impl A B) # G)) (eval e f g)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> A[App n []/0] # G\n  \\<exists>a\\<in>set (A[App n []/0] # G). eval e ?f g a\n  news n (A # G)", "consider\n    \\<open>\\<forall>x. eval e (f(n := \\<lambda>w. x)) g (subst A (App n []) 0)\\<close> |\n    \\<open>\\<exists>x. \\<exists>p \\<in> set G. eval e (f(n := \\<lambda>w. x)) g p\\<close>"], ["proof (prove)\nusing this:\n  \\<turnstile> A[App n []/0] # G\n  \\<exists>a\\<in>set (A[App n []/0] # G). eval e ?f g a\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                eval e (f(n := \\<lambda>w. x)) g\n                 (A[App n []/0]) \\<Longrightarrow>\n             thesis;\n     \\<exists>x.\n        \\<exists>p\\<in>set G.\n           eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x.\n              eval e (f(n := \\<lambda>w. x)) g\n               (A[App n []/0]) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>x.\n      \\<exists>p\\<in>set G.\n         eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (15 subgoals):\n 1. \\<And>i l G f. Bex (set (Pred i l # Neg (Pred i l) # G)) (eval e f g)\n 2. \\<And>G f. Bex (set (Neg \\<bottom> # G)) (eval e f g)\n 3. \\<And>G f. Bex (set (\\<top> # G)) (eval e f g)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<turnstile> A # G;\n        \\<And>f. Bex (set (A # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Neg A) # G)) (eval e f g)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # Neg B # G;\n        \\<And>f. Bex (set (Neg A # Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (And A B) # G)) (eval e f g)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> A # B # G;\n        \\<And>f. Bex (set (A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Or A B # G)) (eval e f g)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # B # G;\n        \\<And>f. Bex (set (Neg A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Impl A B # G)) (eval e f g)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> A # G; \\<And>f. Bex (set (A # G)) (eval e f g);\n        \\<turnstile> B # G; \\<And>f. Bex (set (B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (And A B # G)) (eval e f g)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> Neg A # G;\n        \\<And>f. Bex (set (Neg A # G)) (eval e f g); \\<turnstile> Neg B # G;\n        \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Or A B) # G)) (eval e f g)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<turnstile> A # G;\n         \\<And>f. Bex (set (A # G)) (eval e f g); \\<turnstile> Neg B # G;\n         \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n        \\<Longrightarrow> Bex (set (Neg (Impl A B) # G)) (eval e f g)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>x.\n              eval e (f(n := \\<lambda>w. x)) g\n               (A[App n []/0]) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>x.\n      \\<exists>p\\<in>set G.\n         eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x.\n              eval e (f(n := \\<lambda>w. x)) g\n               (A[App n []/0]) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>x.\n      \\<exists>p\\<in>set G.\n         eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (Forall A # G). eval e f g a", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       eval e (f(n := \\<lambda>w. x)) g (A[App n []/0]) \\<Longrightarrow>\n    \\<exists>a\\<in>set (Forall A # G). eval e f g a\n 2. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Forall A # G). eval e f g a", "case 1"], ["proof (state)\nthis:\n  \\<forall>x. eval e (f(n := \\<lambda>w. x)) g (A[App n []/0])\n\ngoal (2 subgoals):\n 1. \\<forall>x.\n       eval e (f(n := \\<lambda>w. x)) g (A[App n []/0]) \\<Longrightarrow>\n    \\<exists>a\\<in>set (Forall A # G). eval e f g a\n 2. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Forall A # G). eval e f g a", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. eval e (f(n := \\<lambda>w. x)) g (A[App n []/0])", "have \\<open>\\<forall>x. eval (shift e 0 x) (f(n := \\<lambda>w. x)) g A\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x. eval e (f(n := \\<lambda>w. x)) g (A[App n []/0])\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g A", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g A\n\ngoal (2 subgoals):\n 1. \\<forall>x.\n       eval e (f(n := \\<lambda>w. x)) g (A[App n []/0]) \\<Longrightarrow>\n    \\<exists>a\\<in>set (Forall A # G). eval e f g a\n 2. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Forall A # G). eval e f g a", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g A", "have \\<open>\\<forall>x. eval (shift e 0 x) f g A\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x. eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g A\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval (e\\<langle>0:x\\<rangle>) f g A", "using \\<open>news n (A # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x. eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g A\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval (e\\<langle>0:x\\<rangle>) f g A", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. eval (e\\<langle>0:x\\<rangle>) f g A\n\ngoal (2 subgoals):\n 1. \\<forall>x.\n       eval e (f(n := \\<lambda>w. x)) g (A[App n []/0]) \\<Longrightarrow>\n    \\<exists>a\\<in>set (Forall A # G). eval e f g a\n 2. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Forall A # G). eval e f g a", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. eval (e\\<langle>0:x\\<rangle>) f g A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. eval (e\\<langle>0:x\\<rangle>) f g A\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (Forall A # G). eval e f g a", "by simp"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set (Forall A # G). eval e f g a\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Forall A # G). eval e f g a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Forall A # G). eval e f g a", "case 2"], ["proof (state)\nthis:\n  \\<exists>x. \\<exists>p\\<in>set G. eval e (f(n := \\<lambda>w. x)) g p\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Forall A # G). eval e f g a", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. \\<exists>p\\<in>set G. eval e (f(n := \\<lambda>w. x)) g p", "have \\<open>\\<exists>p \\<in> set G. eval e f g p\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x. \\<exists>p\\<in>set G. eval e (f(n := \\<lambda>w. x)) g p\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G. eval e f g p", "using \\<open>news n (A # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x. \\<exists>p\\<in>set G. eval e (f(n := \\<lambda>w. x)) g p\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G. eval e f g p", "using Ball_set insert_iff list.set(2) upd_lemma"], ["proof (prove)\nusing this:\n  \\<exists>x. \\<exists>p\\<in>set G. eval e (f(n := \\<lambda>w. x)) g p\n  news n (A # G)\n  Ball (set ?xs) ?P = list_all ?P ?xs\n  (?a \\<in> insert ?b ?A) = (?a = ?b \\<or> ?a \\<in> ?A)\n  set (?x21.0 # ?x22.0) = insert ?x21.0 (set ?x22.0)\n  new ?n ?p \\<Longrightarrow>\n  eval ?e (?f(?n := ?x)) ?g ?p = eval ?e ?f ?g ?p\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G. eval e f g p", "by metis"], ["proof (state)\nthis:\n  \\<exists>p\\<in>set G. eval e f g p\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Forall A # G). eval e f g a", "then"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>set G. eval e f g p", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>set G. eval e f g p\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (Forall A # G). eval e f g a", "by simp"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set (Forall A # G). eval e f g a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set (Forall A # G). eval e f g a\n\ngoal (14 subgoals):\n 1. \\<And>i l G f. Bex (set (Pred i l # Neg (Pred i l) # G)) (eval e f g)\n 2. \\<And>G f. Bex (set (Neg \\<bottom> # G)) (eval e f g)\n 3. \\<And>G f. Bex (set (\\<top> # G)) (eval e f g)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<turnstile> A # G;\n        \\<And>f. Bex (set (A # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Neg A) # G)) (eval e f g)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # Neg B # G;\n        \\<And>f. Bex (set (Neg A # Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (And A B) # G)) (eval e f g)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> A # B # G;\n        \\<And>f. Bex (set (A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Or A B # G)) (eval e f g)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # B # G;\n        \\<And>f. Bex (set (Neg A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Impl A B # G)) (eval e f g)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> A # G; \\<And>f. Bex (set (A # G)) (eval e f g);\n        \\<turnstile> B # G; \\<And>f. Bex (set (B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (And A B # G)) (eval e f g)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> Neg A # G;\n        \\<And>f. Bex (set (Neg A # G)) (eval e f g); \\<turnstile> Neg B # G;\n        \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Or A B) # G)) (eval e f g)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<turnstile> A # G;\n         \\<And>f. Bex (set (A # G)) (eval e f g); \\<turnstile> Neg B # G;\n         \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n        \\<Longrightarrow> Bex (set (Neg (Impl A B) # G)) (eval e f g)\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>i l G f. Bex (set (Pred i l # Neg (Pred i l) # G)) (eval e f g)\n 2. \\<And>G f. Bex (set (Neg \\<bottom> # G)) (eval e f g)\n 3. \\<And>G f. Bex (set (\\<top> # G)) (eval e f g)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<turnstile> A # G;\n        \\<And>f. Bex (set (A # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Neg A) # G)) (eval e f g)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # Neg B # G;\n        \\<And>f. Bex (set (Neg A # Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (And A B) # G)) (eval e f g)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> A # B # G;\n        \\<And>f. Bex (set (A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Or A B # G)) (eval e f g)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # B # G;\n        \\<And>f. Bex (set (Neg A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Impl A B # G)) (eval e f g)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> A # G; \\<And>f. Bex (set (A # G)) (eval e f g);\n        \\<turnstile> B # G; \\<And>f. Bex (set (B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (And A B # G)) (eval e f g)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> Neg A # G;\n        \\<And>f. Bex (set (Neg A # G)) (eval e f g); \\<turnstile> Neg B # G;\n        \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Or A B) # G)) (eval e f g)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<turnstile> A # G;\n         \\<And>f. Bex (set (A # G)) (eval e f g); \\<turnstile> Neg B # G;\n         \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n        \\<Longrightarrow> Bex (set (Neg (Impl A B) # G)) (eval e f g)\nA total of 14 subgoals...", "case (DeltaNegExists A n G)"], ["proof (state)\nthis:\n  \\<turnstile> Neg (A[App n []/0]) # G\n  \\<exists>a\\<in>set (Neg (A[App n []/0]) # G). eval e ?f g a\n  news n (A # G)\n\ngoal (14 subgoals):\n 1. \\<And>i l G f. Bex (set (Pred i l # Neg (Pred i l) # G)) (eval e f g)\n 2. \\<And>G f. Bex (set (Neg \\<bottom> # G)) (eval e f g)\n 3. \\<And>G f. Bex (set (\\<top> # G)) (eval e f g)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<turnstile> A # G;\n        \\<And>f. Bex (set (A # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Neg A) # G)) (eval e f g)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # Neg B # G;\n        \\<And>f. Bex (set (Neg A # Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (And A B) # G)) (eval e f g)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> A # B # G;\n        \\<And>f. Bex (set (A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Or A B # G)) (eval e f g)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # B # G;\n        \\<And>f. Bex (set (Neg A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Impl A B # G)) (eval e f g)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> A # G; \\<And>f. Bex (set (A # G)) (eval e f g);\n        \\<turnstile> B # G; \\<And>f. Bex (set (B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (And A B # G)) (eval e f g)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> Neg A # G;\n        \\<And>f. Bex (set (Neg A # G)) (eval e f g); \\<turnstile> Neg B # G;\n        \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Or A B) # G)) (eval e f g)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<turnstile> A # G;\n         \\<And>f. Bex (set (A # G)) (eval e f g); \\<turnstile> Neg B # G;\n         \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n        \\<Longrightarrow> Bex (set (Neg (Impl A B) # G)) (eval e f g)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> Neg (A[App n []/0]) # G\n  \\<exists>a\\<in>set (Neg (A[App n []/0]) # G). eval e ?f g a\n  news n (A # G)", "consider\n    \\<open>\\<forall>x. eval e (f(n := \\<lambda>w. x)) g (Neg (subst A (App n []) 0))\\<close> |\n    \\<open>\\<exists>x. \\<exists>p \\<in> set G. eval e (f(n := \\<lambda>w. x)) g p\\<close>"], ["proof (prove)\nusing this:\n  \\<turnstile> Neg (A[App n []/0]) # G\n  \\<exists>a\\<in>set (Neg (A[App n []/0]) # G). eval e ?f g a\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                eval e (f(n := \\<lambda>w. x)) g\n                 (Neg (A[App n []/0])) \\<Longrightarrow>\n             thesis;\n     \\<exists>x.\n        \\<exists>p\\<in>set G.\n           eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x.\n              eval e (f(n := \\<lambda>w. x)) g\n               (Neg (A[App n []/0])) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>x.\n      \\<exists>p\\<in>set G.\n         eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (14 subgoals):\n 1. \\<And>i l G f. Bex (set (Pred i l # Neg (Pred i l) # G)) (eval e f g)\n 2. \\<And>G f. Bex (set (Neg \\<bottom> # G)) (eval e f g)\n 3. \\<And>G f. Bex (set (\\<top> # G)) (eval e f g)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<turnstile> A # G;\n        \\<And>f. Bex (set (A # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Neg A) # G)) (eval e f g)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # Neg B # G;\n        \\<And>f. Bex (set (Neg A # Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (And A B) # G)) (eval e f g)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> A # B # G;\n        \\<And>f. Bex (set (A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Or A B # G)) (eval e f g)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # B # G;\n        \\<And>f. Bex (set (Neg A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Impl A B # G)) (eval e f g)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> A # G; \\<And>f. Bex (set (A # G)) (eval e f g);\n        \\<turnstile> B # G; \\<And>f. Bex (set (B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (And A B # G)) (eval e f g)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> Neg A # G;\n        \\<And>f. Bex (set (Neg A # G)) (eval e f g); \\<turnstile> Neg B # G;\n        \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Or A B) # G)) (eval e f g)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<turnstile> A # G;\n         \\<And>f. Bex (set (A # G)) (eval e f g); \\<turnstile> Neg B # G;\n         \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n        \\<Longrightarrow> Bex (set (Neg (Impl A B) # G)) (eval e f g)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>x.\n              eval e (f(n := \\<lambda>w. x)) g\n               (Neg (A[App n []/0])) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>x.\n      \\<exists>p\\<in>set G.\n         eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x.\n              eval e (f(n := \\<lambda>w. x)) g\n               (Neg (A[App n []/0])) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>x.\n      \\<exists>p\\<in>set G.\n         eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       eval e (f(n := \\<lambda>w. x)) g\n        (Neg (A[App n []/0])) \\<Longrightarrow>\n    \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a\n 2. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a", "case 1"], ["proof (state)\nthis:\n  \\<forall>x. eval e (f(n := \\<lambda>w. x)) g (Neg (A[App n []/0]))\n\ngoal (2 subgoals):\n 1. \\<forall>x.\n       eval e (f(n := \\<lambda>w. x)) g\n        (Neg (A[App n []/0])) \\<Longrightarrow>\n    \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a\n 2. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. eval e (f(n := \\<lambda>w. x)) g (Neg (A[App n []/0]))", "have \\<open>\\<forall>x. eval (shift e 0 x) (f(n := \\<lambda>w. x)) g (Neg A)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x. eval e (f(n := \\<lambda>w. x)) g (Neg (A[App n []/0]))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g (Neg A)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x.\n     eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g (Neg A)\n\ngoal (2 subgoals):\n 1. \\<forall>x.\n       eval e (f(n := \\<lambda>w. x)) g\n        (Neg (A[App n []/0])) \\<Longrightarrow>\n    \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a\n 2. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g (Neg A)", "have \\<open>\\<forall>x. eval (shift e 0 x) f g (Neg A)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g (Neg A)\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval (e\\<langle>0:x\\<rangle>) f g (Neg A)", "using \\<open>news n (A # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g (Neg A)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval (e\\<langle>0:x\\<rangle>) f g (Neg A)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. eval (e\\<langle>0:x\\<rangle>) f g (Neg A)\n\ngoal (2 subgoals):\n 1. \\<forall>x.\n       eval e (f(n := \\<lambda>w. x)) g\n        (Neg (A[App n []/0])) \\<Longrightarrow>\n    \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a\n 2. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. eval (e\\<langle>0:x\\<rangle>) f g (Neg A)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. eval (e\\<langle>0:x\\<rangle>) f g (Neg A)\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a", "by simp"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a", "case 2"], ["proof (state)\nthis:\n  \\<exists>x. \\<exists>p\\<in>set G. eval e (f(n := \\<lambda>w. x)) g p\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. \\<exists>p\\<in>set G. eval e (f(n := \\<lambda>w. x)) g p", "have \\<open>\\<exists>p \\<in> set G. eval e f g p\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x. \\<exists>p\\<in>set G. eval e (f(n := \\<lambda>w. x)) g p\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G. eval e f g p", "using \\<open>news n (A # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x. \\<exists>p\\<in>set G. eval e (f(n := \\<lambda>w. x)) g p\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G. eval e f g p", "using Ball_set insert_iff list.set(2) upd_lemma"], ["proof (prove)\nusing this:\n  \\<exists>x. \\<exists>p\\<in>set G. eval e (f(n := \\<lambda>w. x)) g p\n  news n (A # G)\n  Ball (set ?xs) ?P = list_all ?P ?xs\n  (?a \\<in> insert ?b ?A) = (?a = ?b \\<or> ?a \\<in> ?A)\n  set (?x21.0 # ?x22.0) = insert ?x21.0 (set ?x22.0)\n  new ?n ?p \\<Longrightarrow>\n  eval ?e (?f(?n := ?x)) ?g ?p = eval ?e ?f ?g ?p\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G. eval e f g p", "by metis"], ["proof (state)\nthis:\n  \\<exists>p\\<in>set G. eval e f g p\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<exists>p\\<in>set G.\n          eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a", "then"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>set G. eval e f g p", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>set G. eval e f g p\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a", "by simp"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set (Neg (Exists A) # G). eval e f g a\n\ngoal (13 subgoals):\n 1. \\<And>i l G f. Bex (set (Pred i l # Neg (Pred i l) # G)) (eval e f g)\n 2. \\<And>G f. Bex (set (Neg \\<bottom> # G)) (eval e f g)\n 3. \\<And>G f. Bex (set (\\<top> # G)) (eval e f g)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<turnstile> A # G;\n        \\<And>f. Bex (set (A # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Neg A) # G)) (eval e f g)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # Neg B # G;\n        \\<And>f. Bex (set (Neg A # Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (And A B) # G)) (eval e f g)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> A # B # G;\n        \\<And>f. Bex (set (A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Or A B # G)) (eval e f g)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<turnstile> Neg A # B # G;\n        \\<And>f. Bex (set (Neg A # B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Impl A B # G)) (eval e f g)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> A # G; \\<And>f. Bex (set (A # G)) (eval e f g);\n        \\<turnstile> B # G; \\<And>f. Bex (set (B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (And A B # G)) (eval e f g)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<turnstile> Neg A # G;\n        \\<And>f. Bex (set (Neg A # G)) (eval e f g); \\<turnstile> Neg B # G;\n        \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n       \\<Longrightarrow> Bex (set (Neg (Or A B) # G)) (eval e f g)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<turnstile> A # G;\n         \\<And>f. Bex (set (A # G)) (eval e f g); \\<turnstile> Neg B # G;\n         \\<And>f. Bex (set (Neg B # G)) (eval e f g)\\<rbrakk>\n        \\<Longrightarrow> Bex (set (Neg (Impl A B) # G)) (eval e f g)\nA total of 13 subgoals...", "qed auto"], ["", "subsection \\<open>Tableau Calculus Equivalence\\<close>"], ["", "fun compl :: \\<open>('a, 'b) form \\<Rightarrow> ('a, 'b) form\\<close> where\n  \\<open>compl (Neg p) = p\\<close>\n| \\<open>compl p = Neg p\\<close>"], ["", "lemma compl: \\<open>compl p = Neg p \\<or> (\\<exists>q. compl p = q \\<and> p = Neg q)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. compl p = Neg p \\<or> (\\<exists>q. compl p = q \\<and> p = Neg q)", "by (cases p rule: compl.cases) simp_all"], ["", "lemma new_compl: \\<open>new n p \\<Longrightarrow> new n (compl p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new n p \\<Longrightarrow> new n (compl p)", "by (cases p rule: compl.cases) simp_all"], ["", "lemma news_compl: \\<open>news n G \\<Longrightarrow> news n (map compl G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news n G \\<Longrightarrow> news n (map compl G)", "using new_compl"], ["proof (prove)\nusing this:\n  new ?n ?p \\<Longrightarrow> new ?n (compl ?p)\n\ngoal (1 subgoal):\n 1. news n G \\<Longrightarrow> news n (map compl G)", "by (induct G) fastforce+"], ["", "theorem TC_SC: \\<open>\\<stileturn> G \\<Longrightarrow> \\<turnstile> map compl G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> G \\<Longrightarrow> \\<turnstile> map compl G", "proof (induct G rule: TC.induct)"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>i l G. \\<turnstile> map compl (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 3. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 4. \\<And>A G.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Neg A) # G)\n 5. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<turnstile> map compl (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (And A B # G)\n 6. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 7. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 8. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 9. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 10. \\<And>A G B.\n        \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n         \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\nA total of 15 subgoals...", "case (Basic i l G)"], ["proof (state)\nthis:\n  \n\ngoal (15 subgoals):\n 1. \\<And>i l G. \\<turnstile> map compl (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 3. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 4. \\<And>A G.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Neg A) # G)\n 5. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<turnstile> map compl (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (And A B # G)\n 6. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 7. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 8. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 9. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 10. \\<And>A G B.\n        \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n         \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Pred i l # Neg (Pred i l) # G)", "using SC.Basic Swap"], ["proof (prove)\nusing this:\n  \\<turnstile> Pred ?i ?l # Neg (Pred ?i ?l) # ?G\n  \\<turnstile> ?B # ?A # ?G \\<Longrightarrow> \\<turnstile> ?A # ?B # ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Pred i l # Neg (Pred i l) # G)", "by fastforce"], ["proof (state)\nthis:\n  \\<turnstile> map compl (Pred i l # Neg (Pred i l) # G)\n\ngoal (14 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A G.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Neg A) # G)\n 4. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<turnstile> map compl (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (And A B # G)\n 5. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 6. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 7. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 8. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 9. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 10. \\<And>A t G.\n        \\<lbrakk>\\<stileturn> A[t/0] # G;\n         \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A G.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Neg A) # G)\n 4. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<turnstile> map compl (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (And A B # G)\n 5. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 6. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 7. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 8. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 9. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 10. \\<And>A t G.\n        \\<lbrakk>\\<stileturn> A[t/0] # G;\n         \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\nA total of 14 subgoals...", "case (AlphaNegNeg A G)"], ["proof (state)\nthis:\n  \\<stileturn> A # G\n  \\<turnstile> map compl (A # G)\n\ngoal (14 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A G.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Neg A) # G)\n 4. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<turnstile> map compl (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (And A B # G)\n 5. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 6. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 7. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 8. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 9. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 10. \\<And>A t G.\n        \\<lbrakk>\\<stileturn> A[t/0] # G;\n         \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> A # G\n  \\<turnstile> map compl (A # G)", "show ?case"], ["proof (prove)\nusing this:\n  \\<stileturn> A # G\n  \\<turnstile> map compl (A # G)\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Neg (Neg A) # G)", "using SC.AlphaNegNeg compl"], ["proof (prove)\nusing this:\n  \\<stileturn> A # G\n  \\<turnstile> map compl (A # G)\n  \\<turnstile> ?A # ?G \\<Longrightarrow> \\<turnstile> Neg (Neg ?A) # ?G\n  compl ?p = Neg ?p \\<or> (\\<exists>q. compl ?p = q \\<and> ?p = Neg q)\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Neg (Neg A) # G)", "by (metis compl.simps(1) list.simps(9))"], ["proof (state)\nthis:\n  \\<turnstile> map compl (Neg (Neg A) # G)\n\ngoal (13 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<turnstile> map compl (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (And A B # G)\n 4. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 5. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 7. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 8. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 9. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 10. \\<And>A t G.\n        \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n         \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<turnstile> map compl (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (And A B # G)\n 4. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 5. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 7. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 8. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 9. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 10. \\<And>A t G.\n        \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n         \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\nA total of 13 subgoals...", "case (AlphaAnd A B G)"], ["proof (state)\nthis:\n  \\<stileturn> A # B # G\n  \\<turnstile> map compl (A # B # G)\n\ngoal (13 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<turnstile> map compl (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (And A B # G)\n 4. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 5. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 7. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 8. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 9. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 10. \\<And>A t G.\n        \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n         \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> A # B # G\n  \\<turnstile> map compl (A # B # G)", "have *: \\<open>\\<turnstile> compl A # compl B # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> A # B # G\n  \\<turnstile> map compl (A # B # G)\n\ngoal (1 subgoal):\n 1. \\<turnstile> compl A # compl B # map compl G", "by simp"], ["proof (state)\nthis:\n  \\<turnstile> compl A # compl B # map compl G\n\ngoal (13 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<turnstile> map compl (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (And A B # G)\n 4. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 5. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 7. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 8. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 9. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 10. \\<And>A t G.\n        \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n         \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> compl A # compl B # map compl G", "have \\<open>\\<turnstile> Neg A # Neg B # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<turnstile> compl A # compl B # map compl G\n\ngoal (1 subgoal):\n 1. \\<turnstile> Neg A # Neg B # map compl G", "using compl AlphaNegNeg Swap"], ["proof (prove)\nusing this:\n  \\<turnstile> compl A # compl B # map compl G\n  compl ?p = Neg ?p \\<or> (\\<exists>q. compl ?p = q \\<and> ?p = Neg q)\n  \\<turnstile> ?A # ?G \\<Longrightarrow> \\<turnstile> Neg (Neg ?A) # ?G\n  \\<turnstile> ?B # ?A # ?G \\<Longrightarrow> \\<turnstile> ?A # ?B # ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> Neg A # Neg B # map compl G", "by metis"], ["proof (state)\nthis:\n  \\<turnstile> Neg A # Neg B # map compl G\n\ngoal (13 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<turnstile> map compl (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (And A B # G)\n 4. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 5. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 7. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 8. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 9. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 10. \\<And>A t G.\n        \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n         \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> Neg A # Neg B # map compl G", "show ?case"], ["proof (prove)\nusing this:\n  \\<turnstile> Neg A # Neg B # map compl G\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (And A B # G)", "using AlphaNegAnd"], ["proof (prove)\nusing this:\n  \\<turnstile> Neg A # Neg B # map compl G\n  \\<turnstile> Neg ?A # Neg ?B # ?G \\<Longrightarrow>\n  \\<turnstile> Neg (And ?A ?B) # ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (And A B # G)", "by simp"], ["proof (state)\nthis:\n  \\<turnstile> map compl (And A B # G)\n\ngoal (12 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 7. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 8. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 9. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 10. \\<And>A n G.\n        \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n         \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 7. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 8. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 9. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 10. \\<And>A n G.\n        \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n         \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\nA total of 12 subgoals...", "case (AlphaNegImpl A B G)"], ["proof (state)\nthis:\n  \\<stileturn> A # Neg B # G\n  \\<turnstile> map compl (A # Neg B # G)\n\ngoal (12 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 7. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 8. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 9. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 10. \\<And>A n G.\n        \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n         \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> A # Neg B # G\n  \\<turnstile> map compl (A # Neg B # G)", "have \\<open>\\<turnstile> compl A # B # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> A # Neg B # G\n  \\<turnstile> map compl (A # Neg B # G)\n\ngoal (1 subgoal):\n 1. \\<turnstile> compl A # B # map compl G", "by simp"], ["proof (state)\nthis:\n  \\<turnstile> compl A # B # map compl G\n\ngoal (12 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 7. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 8. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 9. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 10. \\<And>A n G.\n        \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n         \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> compl A # B # map compl G", "have \\<open>\\<turnstile> Neg A # B # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<turnstile> compl A # B # map compl G\n\ngoal (1 subgoal):\n 1. \\<turnstile> Neg A # B # map compl G", "using compl AlphaNegNeg"], ["proof (prove)\nusing this:\n  \\<turnstile> compl A # B # map compl G\n  compl ?p = Neg ?p \\<or> (\\<exists>q. compl ?p = q \\<and> ?p = Neg q)\n  \\<turnstile> ?A # ?G \\<Longrightarrow> \\<turnstile> Neg (Neg ?A) # ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> Neg A # B # map compl G", "by metis"], ["proof (state)\nthis:\n  \\<turnstile> Neg A # B # map compl G\n\ngoal (12 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<turnstile> map compl (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Impl A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 7. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 8. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 9. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 10. \\<And>A n G.\n        \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n         \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> Neg A # B # map compl G", "show ?case"], ["proof (prove)\nusing this:\n  \\<turnstile> Neg A # B # map compl G\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Neg (Impl A B) # G)", "using AlphaImpl"], ["proof (prove)\nusing this:\n  \\<turnstile> Neg A # B # map compl G\n  \\<turnstile> Neg ?A # ?B # ?G \\<Longrightarrow>\n  \\<turnstile> Impl ?A ?B # ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Neg (Impl A B) # G)", "by simp"], ["proof (state)\nthis:\n  \\<turnstile> map compl (Neg (Impl A B) # G)\n\ngoal (11 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 7. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 8. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 9. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 10. \\<And>A n G.\n        \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n         \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n         news n (A # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 7. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 8. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 9. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 10. \\<And>A n G.\n        \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n         \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n         news n (A # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\nA total of 11 subgoals...", "case (BetaOr A G B)"], ["proof (state)\nthis:\n  \\<stileturn> A # G\n  \\<turnstile> map compl (A # G)\n  \\<stileturn> B # G\n  \\<turnstile> map compl (B # G)\n\ngoal (11 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 7. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 8. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 9. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 10. \\<And>A n G.\n        \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n         \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n         news n (A # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> A # G\n  \\<turnstile> map compl (A # G)\n  \\<stileturn> B # G\n  \\<turnstile> map compl (B # G)", "have \\<open>\\<turnstile> compl A # map compl G\\<close> \\<open>\\<turnstile> compl B # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> A # G\n  \\<turnstile> map compl (A # G)\n  \\<stileturn> B # G\n  \\<turnstile> map compl (B # G)\n\ngoal (1 subgoal):\n 1. \\<turnstile> compl A # map compl G &&&\n    \\<turnstile> compl B # map compl G", "by simp_all"], ["proof (state)\nthis:\n  \\<turnstile> compl A # map compl G\n  \\<turnstile> compl B # map compl G\n\ngoal (11 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 7. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 8. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 9. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 10. \\<And>A n G.\n        \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n         \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n         news n (A # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> compl A # map compl G\n  \\<turnstile> compl B # map compl G", "have \\<open>\\<turnstile> Neg A # map compl G\\<close> \\<open>\\<turnstile> Neg B # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<turnstile> compl A # map compl G\n  \\<turnstile> compl B # map compl G\n\ngoal (1 subgoal):\n 1. \\<turnstile> Neg A # map compl G &&& \\<turnstile> Neg B # map compl G", "using compl AlphaNegNeg"], ["proof (prove)\nusing this:\n  \\<turnstile> compl A # map compl G\n  \\<turnstile> compl B # map compl G\n  compl ?p = Neg ?p \\<or> (\\<exists>q. compl ?p = q \\<and> ?p = Neg q)\n  \\<turnstile> ?A # ?G \\<Longrightarrow> \\<turnstile> Neg (Neg ?A) # ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> Neg A # map compl G &&& \\<turnstile> Neg B # map compl G", "by metis+"], ["proof (state)\nthis:\n  \\<turnstile> Neg A # map compl G\n  \\<turnstile> Neg B # map compl G\n\ngoal (11 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> A # G; \\<turnstile> map compl (A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Or A B # G)\n 6. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 7. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 8. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 9. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 10. \\<And>A n G.\n        \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n         \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n         news n (A # G)\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> Neg A # map compl G\n  \\<turnstile> Neg B # map compl G", "show ?case"], ["proof (prove)\nusing this:\n  \\<turnstile> Neg A # map compl G\n  \\<turnstile> Neg B # map compl G\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Or A B # G)", "using BetaNegOr"], ["proof (prove)\nusing this:\n  \\<turnstile> Neg A # map compl G\n  \\<turnstile> Neg B # map compl G\n  \\<lbrakk>\\<turnstile> Neg ?A # ?G; \\<turnstile> Neg ?B # ?G\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile> Neg (Or ?A ?B) # ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Or A B # G)", "by simp"], ["proof (state)\nthis:\n  \\<turnstile> map compl (Or A B # G)\n\ngoal (10 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 6. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 7. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 8. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 9. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 10. \\<And>G G'.\n        \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n         set G = set G'\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl G'", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 6. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 7. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 8. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 9. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 10. \\<And>G G'.\n        \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n         set G = set G'\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl G'", "case (BetaImpl A G B)"], ["proof (state)\nthis:\n  \\<stileturn> Neg A # G\n  \\<turnstile> map compl (Neg A # G)\n  \\<stileturn> B # G\n  \\<turnstile> map compl (B # G)\n\ngoal (10 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 6. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 7. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 8. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 9. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 10. \\<And>G G'.\n        \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n         set G = set G'\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl G'", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> Neg A # G\n  \\<turnstile> map compl (Neg A # G)\n  \\<stileturn> B # G\n  \\<turnstile> map compl (B # G)", "have \\<open>\\<turnstile> A # map compl G\\<close> \\<open>\\<turnstile> compl B # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg A # G\n  \\<turnstile> map compl (Neg A # G)\n  \\<stileturn> B # G\n  \\<turnstile> map compl (B # G)\n\ngoal (1 subgoal):\n 1. \\<turnstile> A # map compl G &&& \\<turnstile> compl B # map compl G", "by simp_all"], ["proof (state)\nthis:\n  \\<turnstile> A # map compl G\n  \\<turnstile> compl B # map compl G\n\ngoal (10 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 6. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 7. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 8. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 9. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 10. \\<And>G G'.\n        \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n         set G = set G'\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl G'", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> A # map compl G\n  \\<turnstile> compl B # map compl G", "have \\<open>\\<turnstile> A # map compl G\\<close> \\<open>\\<turnstile> Neg B # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<turnstile> A # map compl G\n  \\<turnstile> compl B # map compl G\n\ngoal (1 subgoal):\n 1. \\<turnstile> A # map compl G &&& \\<turnstile> Neg B # map compl G", "by - (assumption, metis compl AlphaNegNeg)"], ["proof (state)\nthis:\n  \\<turnstile> A # map compl G\n  \\<turnstile> Neg B # map compl G\n\ngoal (10 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 6. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 7. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 8. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 9. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 10. \\<And>G G'.\n        \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n         set G = set G'\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl G'", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> A # map compl G\n  \\<turnstile> Neg B # map compl G", "have \\<open>\\<turnstile> Neg (Impl A B) # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<turnstile> A # map compl G\n  \\<turnstile> Neg B # map compl G\n\ngoal (1 subgoal):\n 1. \\<turnstile> Neg (Impl A B) # map compl G", "using BetaNegImpl"], ["proof (prove)\nusing this:\n  \\<turnstile> A # map compl G\n  \\<turnstile> Neg B # map compl G\n  \\<lbrakk>\\<turnstile> ?A # ?G; \\<turnstile> Neg ?B # ?G\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile> Neg (Impl ?A ?B) # ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> Neg (Impl A B) # map compl G", "by blast"], ["proof (state)\nthis:\n  \\<turnstile> Neg (Impl A B) # map compl G\n\ngoal (10 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 6. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 7. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 8. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 9. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 10. \\<And>G G'.\n        \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n         set G = set G'\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl G'", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> Neg (Impl A B) # map compl G", "have \\<open>\\<turnstile> compl (Impl A B) # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<turnstile> Neg (Impl A B) # map compl G\n\ngoal (1 subgoal):\n 1. \\<turnstile> compl (Impl A B) # map compl G", "using \\<open>\\<turnstile> A # map compl G\\<close> compl"], ["proof (prove)\nusing this:\n  \\<turnstile> Neg (Impl A B) # map compl G\n  \\<turnstile> A # map compl G\n  compl ?p = Neg ?p \\<or> (\\<exists>q. compl ?p = q \\<and> ?p = Neg q)\n\ngoal (1 subgoal):\n 1. \\<turnstile> compl (Impl A B) # map compl G", "by simp"], ["proof (state)\nthis:\n  \\<turnstile> compl (Impl A B) # map compl G\n\ngoal (10 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> B # G; \\<turnstile> map compl (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Impl A B # G)\n 6. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 7. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 8. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 9. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 10. \\<And>G G'.\n        \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n         set G = set G'\\<rbrakk>\n        \\<Longrightarrow> \\<turnstile> map compl G'", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> compl (Impl A B) # map compl G", "show ?case"], ["proof (prove)\nusing this:\n  \\<turnstile> compl (Impl A B) # map compl G\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Impl A B # G)", "by simp"], ["proof (state)\nthis:\n  \\<turnstile> map compl (Impl A B # G)\n\ngoal (9 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 6. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 7. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 8. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 9. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 6. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 7. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 8. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 9. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "case (GammaForall A t G)"], ["proof (state)\nthis:\n  \\<stileturn> A[t/0] # G\n  \\<turnstile> map compl (A[t/0] # G)\n\ngoal (9 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 6. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 7. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 8. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 9. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> A[t/0] # G\n  \\<turnstile> map compl (A[t/0] # G)", "have \\<open>\\<turnstile> compl (subst A t 0) # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> A[t/0] # G\n  \\<turnstile> map compl (A[t/0] # G)\n\ngoal (1 subgoal):\n 1. \\<turnstile> compl (A[t/0]) # map compl G", "by simp"], ["proof (state)\nthis:\n  \\<turnstile> compl (A[t/0]) # map compl G\n\ngoal (9 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 6. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 7. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 8. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 9. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> compl (A[t/0]) # map compl G", "have \\<open>\\<turnstile> Neg (subst A t 0) # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<turnstile> compl (A[t/0]) # map compl G\n\ngoal (1 subgoal):\n 1. \\<turnstile> Neg (A[t/0]) # map compl G", "using compl AlphaNegNeg"], ["proof (prove)\nusing this:\n  \\<turnstile> compl (A[t/0]) # map compl G\n  compl ?p = Neg ?p \\<or> (\\<exists>q. compl ?p = q \\<and> ?p = Neg q)\n  \\<turnstile> ?A # ?G \\<Longrightarrow> \\<turnstile> Neg (Neg ?A) # ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> Neg (A[t/0]) # map compl G", "by metis"], ["proof (state)\nthis:\n  \\<turnstile> Neg (A[t/0]) # map compl G\n\ngoal (9 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> A[t/0] # G;\n        \\<turnstile> map compl (A[t/0] # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Forall A # G)\n 6. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 7. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 8. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 9. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> Neg (A[t/0]) # map compl G", "show ?case"], ["proof (prove)\nusing this:\n  \\<turnstile> Neg (A[t/0]) # map compl G\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Forall A # G)", "using GammaNegForall"], ["proof (prove)\nusing this:\n  \\<turnstile> Neg (A[t/0]) # map compl G\n  \\<turnstile> Neg (?A[?t/0]) # ?G \\<Longrightarrow>\n  \\<turnstile> Neg (Forall ?A) # ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Forall A # G)", "by simp"], ["proof (state)\nthis:\n  \\<turnstile> map compl (Forall A # G)\n\ngoal (8 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 7. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 8. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 7. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 8. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "case (DeltaExists A n G)"], ["proof (state)\nthis:\n  \\<stileturn> A[App n []/0] # G\n  \\<turnstile> map compl (A[App n []/0] # G)\n  news n (A # G)\n\ngoal (8 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 7. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 8. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> A[App n []/0] # G\n  \\<turnstile> map compl (A[App n []/0] # G)\n  news n (A # G)", "have \\<open>\\<turnstile> compl (subst A (App n []) 0) # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> A[App n []/0] # G\n  \\<turnstile> map compl (A[App n []/0] # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<turnstile> compl (A[App n []/0]) # map compl G", "by simp"], ["proof (state)\nthis:\n  \\<turnstile> compl (A[App n []/0]) # map compl G\n\ngoal (8 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 7. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 8. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "then"], ["proof (chain)\npicking this:\n  \\<turnstile> compl (A[App n []/0]) # map compl G", "have \\<open>\\<turnstile> Neg (subst A (App n []) 0) # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<turnstile> compl (A[App n []/0]) # map compl G\n\ngoal (1 subgoal):\n 1. \\<turnstile> Neg (A[App n []/0]) # map compl G", "using compl AlphaNegNeg"], ["proof (prove)\nusing this:\n  \\<turnstile> compl (A[App n []/0]) # map compl G\n  compl ?p = Neg ?p \\<or> (\\<exists>q. compl ?p = q \\<and> ?p = Neg q)\n  \\<turnstile> ?A # ?G \\<Longrightarrow> \\<turnstile> Neg (Neg ?A) # ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> Neg (A[App n []/0]) # map compl G", "by metis"], ["proof (state)\nthis:\n  \\<turnstile> Neg (A[App n []/0]) # map compl G\n\ngoal (8 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 7. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 8. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "moreover"], ["proof (state)\nthis:\n  \\<turnstile> Neg (A[App n []/0]) # map compl G\n\ngoal (8 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 7. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 8. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "have \\<open>news n (A # map compl G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news n (A # map compl G)", "using DeltaExists news_compl"], ["proof (prove)\nusing this:\n  \\<stileturn> A[App n []/0] # G\n  \\<turnstile> map compl (A[App n []/0] # G)\n  news n (A # G)\n  news ?n ?G \\<Longrightarrow> news ?n (map compl ?G)\n\ngoal (1 subgoal):\n 1. news n (A # map compl G)", "by fastforce"], ["proof (state)\nthis:\n  news n (A # map compl G)\n\ngoal (8 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n        \\<turnstile> map compl (A[App n []/0] # G); news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Exists A # G)\n 7. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 8. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "ultimately"], ["proof (chain)\npicking this:\n  \\<turnstile> Neg (A[App n []/0]) # map compl G\n  news n (A # map compl G)", "show ?case"], ["proof (prove)\nusing this:\n  \\<turnstile> Neg (A[App n []/0]) # map compl G\n  news n (A # map compl G)\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Exists A # G)", "using DeltaNegExists"], ["proof (prove)\nusing this:\n  \\<turnstile> Neg (A[App n []/0]) # map compl G\n  news n (A # map compl G)\n  \\<lbrakk>\\<turnstile> Neg (?A[App ?n []/0]) # ?G;\n   news ?n (?A # ?G)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile> Neg (Exists ?A) # ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Exists A # G)", "by simp"], ["proof (state)\nthis:\n  \\<turnstile> map compl (Exists A # G)\n\ngoal (7 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 7. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 7. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "case (DeltaNegForall A n G)"], ["proof (state)\nthis:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<turnstile> map compl (Neg (A[App n []/0]) # G)\n  news n (A # G)\n\ngoal (7 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 7. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<turnstile> map compl (Neg (A[App n []/0]) # G)\n  news n (A # G)", "have \\<open>\\<turnstile> subst A (App n []) 0 # map compl G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<turnstile> map compl (Neg (A[App n []/0]) # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<turnstile> A[App n []/0] # map compl G", "by simp"], ["proof (state)\nthis:\n  \\<turnstile> A[App n []/0] # map compl G\n\ngoal (7 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 7. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "moreover"], ["proof (state)\nthis:\n  \\<turnstile> A[App n []/0] # map compl G\n\ngoal (7 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 7. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "have \\<open>news n (A # map compl G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news n (A # map compl G)", "using DeltaNegForall news_compl"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<turnstile> map compl (Neg (A[App n []/0]) # G)\n  news n (A # G)\n  news ?n ?G \\<Longrightarrow> news ?n (map compl ?G)\n\ngoal (1 subgoal):\n 1. news n (A # map compl G)", "by fastforce"], ["proof (state)\nthis:\n  news n (A # map compl G)\n\ngoal (7 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>A n G.\n       \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n        \\<turnstile> map compl (Neg (A[App n []/0]) # G);\n        news n (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Forall A) # G)\n 7. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "ultimately"], ["proof (chain)\npicking this:\n  \\<turnstile> A[App n []/0] # map compl G\n  news n (A # map compl G)", "show ?case"], ["proof (prove)\nusing this:\n  \\<turnstile> A[App n []/0] # map compl G\n  news n (A # map compl G)\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Neg (Forall A) # G)", "using DeltaForall"], ["proof (prove)\nusing this:\n  \\<turnstile> A[App n []/0] # map compl G\n  news n (A # map compl G)\n  \\<lbrakk>\\<turnstile> ?A[App ?n []/0] # ?G; news ?n (?A # ?G)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile> Forall ?A # ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> map compl (Neg (Forall A) # G)", "by simp"], ["proof (state)\nthis:\n  \\<turnstile> map compl (Neg (Forall A) # G)\n\ngoal (6 subgoals):\n 1. \\<And>G. \\<turnstile> map compl (\\<bottom> # G)\n 2. \\<And>G. \\<turnstile> map compl (Neg \\<top> # G)\n 3. \\<And>A B G.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<turnstile> map compl (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Or A B) # G)\n 4. \\<And>A G B.\n       \\<lbrakk>\\<stileturn> Neg A # G; \\<turnstile> map compl (Neg A # G);\n        \\<stileturn> Neg B # G; \\<turnstile> map compl (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (And A B) # G)\n 5. \\<And>A t G.\n       \\<lbrakk>\\<stileturn> Neg (A[t/0]) # G;\n        \\<turnstile> map compl (Neg (A[t/0]) # G)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl (Neg (Exists A) # G)\n 6. \\<And>G G'.\n       \\<lbrakk>\\<stileturn> G; \\<turnstile> map compl G;\n        set G = set G'\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile> map compl G'", "qed (simp_all add: SC.intros)"], ["", "subsection \\<open>Completeness\\<close>"], ["", "theorem SC_completeness:\n  fixes p :: \\<open>(nat, nat) form\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. list_all (eval e f g) ps \\<longrightarrow> eval e f g p\\<close>\n  shows \\<open>\\<turnstile> p # map compl ps\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> p # map compl ps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile> p # map compl ps", "have \\<open>\\<stileturn> Neg p # ps\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> Neg p # ps", "using assms tableau_completeness"], ["proof (prove)\nusing this:\n  \\<forall>e f g. list_all (eval e f g) ps \\<longrightarrow> eval e f g p\n  \\<forall>e f g.\n     list_all (eval e f g) ?G \\<longrightarrow>\n     eval e f g ?p \\<Longrightarrow>\n  tableauproof ?G ?p\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg p # ps", "unfolding tableauproof_def"], ["proof (prove)\nusing this:\n  \\<forall>e f g. list_all (eval e f g) ps \\<longrightarrow> eval e f g p\n  \\<forall>e f g.\n     list_all (eval e f g) ?G \\<longrightarrow>\n     eval e f g ?p \\<Longrightarrow>\n  \\<stileturn> Neg ?p # ?G\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg p # ps", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> Neg p # ps\n\ngoal (1 subgoal):\n 1. \\<turnstile> p # map compl ps", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> Neg p # ps", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg p # ps\n\ngoal (1 subgoal):\n 1. \\<turnstile> p # map compl ps", "using TC_SC"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg p # ps\n  \\<stileturn> ?G \\<Longrightarrow> \\<turnstile> map compl ?G\n\ngoal (1 subgoal):\n 1. \\<turnstile> p # map compl ps", "by fastforce"], ["proof (state)\nthis:\n  \\<turnstile> p # map compl ps\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary\n  fixes p :: \\<open>(nat, nat) form\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. eval e f g p\\<close>\n  shows \\<open>\\<turnstile> [p]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> [p]", "using assms SC_completeness list.map(1)"], ["proof (prove)\nusing this:\n  valid p\n  \\<forall>e f g.\n     list_all (eval e f g) ?ps \\<longrightarrow>\n     eval e f g ?p \\<Longrightarrow>\n  \\<turnstile> ?p # map compl ?ps\n  map ?f [] = []\n\ngoal (1 subgoal):\n 1. \\<turnstile> [p]", "by metis"], ["", "end"]]}