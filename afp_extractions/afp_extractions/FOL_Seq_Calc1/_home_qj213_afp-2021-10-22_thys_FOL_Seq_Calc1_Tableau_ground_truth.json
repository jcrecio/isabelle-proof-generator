{"file_name": "/home/qj213/afp-2021-10-22/thys/FOL_Seq_Calc1/Tableau.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FOL_Seq_Calc1", "problem_names": ["lemma Shift: \\<open>\\<stileturn> rotate1 G \\<Longrightarrow> \\<stileturn> G\\<close>", "lemma Swap: \\<open>\\<stileturn> B # A # G \\<Longrightarrow> \\<stileturn> A # B # G\\<close>", "theorem tableauNotAA: \\<open>\\<stileturn> [Neg (Pred ''A'' []), Pred ''A'' []]\\<close>", "theorem AndAnd:\n  \\<open>\\<stileturn> [And (Pred ''A'' []) (Pred ''B'' []), Neg (And (Pred ''B'' []) (Pred ''A'' []))]\\<close>", "lemma TC_soundness:\n  \\<open>\\<stileturn> G \\<Longrightarrow> \\<exists>p \\<in> set G. \\<not> eval e f g p\\<close>", "theorem tableau_soundness:\n  \\<open>tableauproof ps p \\<Longrightarrow> list_all (eval e f g) ps \\<Longrightarrow> eval e f g p\\<close>", "theorem infinite_nonempty: \\<open>infinite A \\<Longrightarrow> \\<exists>x. x \\<in> A\\<close>", "theorem TCd_consistency:\n  assumes inf_param: \\<open>infinite (UNIV::'a set)\\<close>\n  shows \\<open>consistency {S::('a, 'b) form set. \\<exists>G. S = set G \\<and> \\<not> (\\<stileturn> G)}\\<close>", "theorem tableau_completeness':\n  fixes p :: \\<open>(nat, nat) form\\<close>\n  assumes \\<open>closed 0 p\\<close>\n    and \\<open>list_all (closed 0) ps\\<close>\n    and mod: \\<open>\\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. list_all (eval e f g) ps \\<longrightarrow> eval e f g p\\<close>\n  shows \\<open>tableauproof ps p\\<close>", "lemma TC_psubst:\n  fixes f :: \\<open>'a \\<Rightarrow> 'a\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<stileturn> G \\<Longrightarrow> \\<stileturn> map (psubst f) G\\<close>", "lemma subcs_map: \\<open>subcs c s G = map (subc c s) G\\<close>", "lemma TC_subcs:\n  fixes G :: \\<open>('a, 'b) form list\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<stileturn> G \\<Longrightarrow> \\<stileturn> subcs c s G\\<close>", "lemma TC_map_subc:\n  fixes G :: \\<open>('a, 'b) form list\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<stileturn> G \\<Longrightarrow> \\<stileturn> map (subc c s) G\\<close>", "lemma ex_all_closed: \\<open>\\<exists>m. list_all (closed m) G\\<close>", "lemma valid_sub_consts:\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> 'a) f g. eval e f g p\\<close>\n  shows \\<open>eval (e :: nat => 'a) f g (sub_consts cs p)\\<close>", "lemma closed_sub' [simp]:\n  assumes \\<open>k \\<le> m\\<close> shows\n    \\<open>closedt (Suc m) t = closedt m (substt t (App c []) k)\\<close>\n    \\<open>closedts (Suc m) l = closedts m (substts l (App c []) k)\\<close>", "lemma closed_sub: \\<open>k \\<le> m \\<Longrightarrow> closed (Suc m) p = closed m (subst p (App c []) k)\\<close>", "lemma closed_sub_consts: \\<open>length cs = k \\<Longrightarrow> closed m (sub_consts cs p) = closed (m + k) p\\<close>", "lemma map_sub_consts_Nil: \\<open>map (sub_consts []) G = G\\<close>", "lemma eval_conjoin: \\<open>list_all (eval e f g) G = eval e f g (conjoin G)\\<close>", "lemma valid_sub:\n  fixes e :: \\<open>nat \\<Rightarrow> 'a\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> 'a) f g. eval e f g p \\<longrightarrow> eval e f g q\\<close>\n  shows \\<open>eval e f g (subst p t m) \\<longrightarrow> eval e f g (subst q t m)\\<close>", "lemma eval_sub_consts:\n  fixes e :: \\<open>nat \\<Rightarrow> 'a\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> 'a) f g. eval e f g p \\<longrightarrow> eval e f g q\\<close>\n    and \\<open>eval e f g (sub_consts cs p)\\<close>\n  shows \\<open>eval e f g (sub_consts cs q)\\<close>", "lemma sub_consts_And [simp]: \\<open>sub_consts cs (And p q) = And (sub_consts cs p) (sub_consts cs q)\\<close>", "lemma sub_consts_conjoin:\n  \\<open>eval e f g (sub_consts cs (conjoin G)) = eval e f g (conjoin (map (sub_consts cs) G))\\<close>", "lemma all_sub_consts_conjoin:\n  \\<open>list_all (eval e f g) (map (sub_consts cs) G) = eval e f g (sub_consts cs (conjoin G))\\<close>", "lemma valid_all_sub_consts:\n  fixes e :: \\<open>nat \\<Rightarrow> 'a\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> 'a) f g. list_all (eval e f g) G \\<longrightarrow> eval e f g p\\<close>\n  shows \\<open>list_all (eval e f g) (map (sub_consts cs) G) \\<longrightarrow> eval e f g (sub_consts cs p)\\<close>", "lemma TC_vars_for_consts:\n  fixes G :: \\<open>('a, 'b) form list\\<close>\n  assumes \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<stileturn> G \\<Longrightarrow> \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G\\<close>", "lemma vars_for_consts_sub_consts:\n  \\<open>closed (length cs) p \\<Longrightarrow> list_all (\\<lambda>c. new c p) cs \\<Longrightarrow> distinct cs \\<Longrightarrow>\n   vars_for_consts (sub_consts cs p) cs = p\\<close>", "lemma all_vars_for_consts_sub_consts:\n  \\<open>list_all (closed (length cs)) G \\<Longrightarrow> list_all (\\<lambda>c. list_all (new c) G) cs \\<Longrightarrow> distinct cs \\<Longrightarrow>\n   map (\\<lambda>p. vars_for_consts p cs) (map (sub_consts cs) G) = G\\<close>", "lemma new_conjoin: \\<open>new c (conjoin G) \\<Longrightarrow> list_all (new c) G\\<close>", "lemma all_fresh_constants:\n  fixes G :: \\<open>('a, 'b) form list\\<close>\n  assumes \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<exists>cs. length cs = m \\<and> list_all (\\<lambda>c. list_all (new c) G) cs \\<and> distinct cs\\<close>", "lemma sub_consts_Neg: \\<open>sub_consts cs (Neg p) = Neg (sub_consts cs p)\\<close>", "theorem tableau_completeness:\n  fixes G :: \\<open>(nat, nat) form list\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. list_all (eval e f g) G \\<longrightarrow> eval e f g p\\<close>\n  shows \\<open>tableauproof G p\\<close>"], "translations": [["", "lemma Shift: \\<open>\\<stileturn> rotate1 G \\<Longrightarrow> \\<stileturn> G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> rotate1 G \\<Longrightarrow> \\<stileturn> G", "by (simp add: Order)"], ["", "lemma Swap: \\<open>\\<stileturn> B # A # G \\<Longrightarrow> \\<stileturn> A # B # G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> B # A # G \\<Longrightarrow> \\<stileturn> A # B # G", "by (simp add: Order insert_commute)"], ["", "definition tableauproof :: \\<open>('a, 'b) form list \\<Rightarrow> ('a, 'b) form \\<Rightarrow> bool\\<close> where\n  \\<open>tableauproof ps p \\<equiv> (\\<stileturn> Neg p # ps)\\<close>"], ["", "theorem tableauNotAA: \\<open>\\<stileturn> [Neg (Pred ''A'' []), Pred ''A'' []]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> [Neg (Pred ''A'' []), Pred ''A'' []]", "by (rule Shift, simp) (rule Basic)"], ["", "theorem AndAnd:\n  \\<open>\\<stileturn> [And (Pred ''A'' []) (Pred ''B'' []), Neg (And (Pred ''B'' []) (Pred ''A'' []))]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> [And (Pred ''A'' []) (Pred ''B'' []),\n                  Neg (And (Pred ''B'' []) (Pred ''A'' []))]", "apply (rule AlphaAnd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> [Pred ''A'' [], Pred ''B'' [],\n                  Neg (And (Pred ''B'' []) (Pred ''A'' []))]", "apply (rule Shift, rule Shift, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> [Neg (And (Pred ''B'' []) (Pred ''A'' [])), Pred ''A'' [],\n                  Pred ''B'' []]", "apply (rule BetaNegAnd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<stileturn> [Neg (Pred ''B'' []), Pred ''A'' [], Pred ''B'' []]\n 2. \\<stileturn> [Neg (Pred ''A'' []), Pred ''A'' [], Pred ''B'' []]", "apply (rule Shift, rule Shift, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<stileturn> [Pred ''B'' [], Neg (Pred ''B'' []), Pred ''A'' []]\n 2. \\<stileturn> [Neg (Pred ''A'' []), Pred ''A'' [], Pred ''B'' []]", "apply (rule Basic)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> [Neg (Pred ''A'' []), Pred ''A'' [], Pred ''B'' []]", "apply (rule Swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> [Pred ''A'' [], Neg (Pred ''A'' []), Pred ''B'' []]", "apply (rule Basic)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Soundness\\<close>"], ["", "lemma TC_soundness:\n  \\<open>\\<stileturn> G \\<Longrightarrow> \\<exists>p \\<in> set G. \\<not> eval e f g p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> G \\<Longrightarrow>\n    \\<exists>p\\<in>set G. \\<not> eval e f g p", "proof (induct G arbitrary: f rule: TC.induct)"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<exists>p\\<in>set (Pred i l # Neg (Pred i l) # G).\n          \\<not> eval e f g p\n 2. \\<And>G f. \\<exists>p\\<in>set (\\<bottom> # G). \\<not> eval e f g p\n 3. \\<And>G f. \\<exists>p\\<in>set (Neg \\<top> # G). \\<not> eval e f g p\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<exists>p\\<in>set (A # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Neg A) # G).\n                            \\<not> eval e f g p\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (A # B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (And A B # G).\n                            \\<not> eval e f g p\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (Neg A # Neg B # G).\n              \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Or A B) # G).\n                            \\<not> eval e f g p\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (A # Neg B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Impl A B) # G).\n                            \\<not> eval e f g p\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<exists>p\\<in>set (Neg A # G). \\<not> eval e f g p;\n        \\<stileturn> Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (Neg B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (And A B) # G).\n                            \\<not> eval e f g p\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<exists>p\\<in>set (A # G). \\<not> eval e f g p;\n        \\<stileturn> B # G;\n        \\<And>f. \\<exists>p\\<in>set (B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Or A B # G).\n                            \\<not> eval e f g p\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<exists>p\\<in>set (Neg A # G). \\<not> eval e f g p;\n         \\<stileturn> B # G;\n         \\<And>f. \\<exists>p\\<in>set (B # G). \\<not> eval e f g p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p\\<in>set (Impl A B # G).\n                             \\<not> eval e f g p\nA total of 15 subgoals...", "case (DeltaExists A n G)"], ["proof (state)\nthis:\n  \\<stileturn> A[App n []/0] # G\n  \\<exists>p\\<in>set (A[App n []/0] # G). \\<not> eval e ?f g p\n  news n (A # G)\n\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<exists>p\\<in>set (Pred i l # Neg (Pred i l) # G).\n          \\<not> eval e f g p\n 2. \\<And>G f. \\<exists>p\\<in>set (\\<bottom> # G). \\<not> eval e f g p\n 3. \\<And>G f. \\<exists>p\\<in>set (Neg \\<top> # G). \\<not> eval e f g p\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<exists>p\\<in>set (A # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Neg A) # G).\n                            \\<not> eval e f g p\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (A # B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (And A B # G).\n                            \\<not> eval e f g p\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (Neg A # Neg B # G).\n              \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Or A B) # G).\n                            \\<not> eval e f g p\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (A # Neg B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Impl A B) # G).\n                            \\<not> eval e f g p\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<exists>p\\<in>set (Neg A # G). \\<not> eval e f g p;\n        \\<stileturn> Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (Neg B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (And A B) # G).\n                            \\<not> eval e f g p\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<exists>p\\<in>set (A # G). \\<not> eval e f g p;\n        \\<stileturn> B # G;\n        \\<And>f. \\<exists>p\\<in>set (B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Or A B # G).\n                            \\<not> eval e f g p\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<exists>p\\<in>set (Neg A # G). \\<not> eval e f g p;\n         \\<stileturn> B # G;\n         \\<And>f. \\<exists>p\\<in>set (B # G). \\<not> eval e f g p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p\\<in>set (Impl A B # G).\n                             \\<not> eval e f g p\nA total of 15 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set (Exists A # G). \\<not> eval e f g p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Exists A # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "assume \\<open>\\<not> (\\<exists>p \\<in> set (Exists A # G). \\<not> eval e f g p)\\<close>"], ["proof (state)\nthis:\n  \\<not> (\\<exists>p\\<in>set (Exists A # G). \\<not> eval e f g p)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Exists A # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>p\\<in>set (Exists A # G). \\<not> eval e f g p)", "have *: \\<open>\\<forall>p \\<in> set (Exists A # G). eval e f g p\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>p\\<in>set (Exists A # G). \\<not> eval e f g p)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (Exists A # G). eval e f g p", "by simp"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (Exists A # G). eval e f g p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Exists A # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set (Exists A # G). eval e f g p", "obtain x where \\<open>eval (shift e 0 x) (f(n := \\<lambda>w. x)) g A\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (Exists A # G). eval e f g p\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g\n         A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>news n (A # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (Exists A # G). eval e f g p\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g\n         A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Exists A # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g A", "have **: \\<open>eval e (f(n := \\<lambda>w. x)) g (subst A (App n []) 0)\\<close>"], ["proof (prove)\nusing this:\n  eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g A\n\ngoal (1 subgoal):\n 1. eval e (f(n := \\<lambda>w. x)) g (A[App n []/0])", "by simp"], ["proof (state)\nthis:\n  eval e (f(n := \\<lambda>w. x)) g (A[App n []/0])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Exists A # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "have \\<open>\\<exists>p \\<in> set (subst A (App n []) 0 # G). \\<not> eval e (f(n := \\<lambda>w. x)) g p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set (A[App n []/0] # G).\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p", "using DeltaExists"], ["proof (prove)\nusing this:\n  \\<stileturn> A[App n []/0] # G\n  \\<exists>p\\<in>set (A[App n []/0] # G). \\<not> eval e ?f g p\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set (A[App n []/0] # G).\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p", "by fast"], ["proof (state)\nthis:\n  \\<exists>p\\<in>set (A[App n []/0] # G).\n     \\<not> eval e (f(n := \\<lambda>w. x)) g p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Exists A # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>set (A[App n []/0] # G).\n     \\<not> eval e (f(n := \\<lambda>w. x)) g p", "consider\n      \\<open>\\<not> eval e (f(n := \\<lambda>w. x)) g (subst A (App n []) 0)\\<close> |\n      \\<open>\\<exists>p \\<in> set G. \\<not> eval e (f(n := \\<lambda>w. x)) g p\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>set (A[App n []/0] # G).\n     \\<not> eval e (f(n := \\<lambda>w. x)) g p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> eval e (f(n := \\<lambda>w. x)) g\n                     (A[App n []/0]) \\<Longrightarrow>\n             thesis;\n     \\<exists>p\\<in>set G.\n        \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> eval e (f(n := \\<lambda>w. x)) g\n                   (A[App n []/0]) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>p\\<in>set G.\n      \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Exists A # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> eval e (f(n := \\<lambda>w. x)) g\n                   (A[App n []/0]) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>p\\<in>set G.\n      \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> eval e (f(n := \\<lambda>w. x)) g\n                   (A[App n []/0]) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>p\\<in>set G.\n      \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> eval e (f(n := \\<lambda>w. x)) g\n            (A[App n []/0]) \\<Longrightarrow>\n    False\n 2. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "case 1"], ["proof (state)\nthis:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g (A[App n []/0])\n\ngoal (2 subgoals):\n 1. \\<not> eval e (f(n := \\<lambda>w. x)) g\n            (A[App n []/0]) \\<Longrightarrow>\n    False\n 2. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g (A[App n []/0])", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g (A[App n []/0])\n\ngoal (1 subgoal):\n 1. False", "using **"], ["proof (prove)\nusing this:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g (A[App n []/0])\n  eval e (f(n := \\<lambda>w. x)) g (A[App n []/0])\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "case 2"], ["proof (state)\nthis:\n  \\<exists>p\\<in>set G. \\<not> eval e (f(n := \\<lambda>w. x)) g p\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>set G. \\<not> eval e (f(n := \\<lambda>w. x)) g p", "obtain p where \\<open>\\<not> eval e (f(n := \\<lambda>w. x)) g p\\<close> \\<open>p \\<in> set G\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>set G. \\<not> eval e (f(n := \\<lambda>w. x)) g p\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>\\<not> eval e (f(n := \\<lambda>w. x)) g p;\n         p \\<in> set G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g p\n  p \\<in> set G\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g p\n  p \\<in> set G", "have \\<open>\\<not> eval e f g p\\<close>"], ["proof (prove)\nusing this:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g p\n  p \\<in> set G\n\ngoal (1 subgoal):\n 1. \\<not> eval e f g p", "using \\<open>news n (A # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g p\n  p \\<in> set G\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<not> eval e f g p", "by (metis Ball_set set_subset_Cons subsetCE upd_lemma)"], ["proof (state)\nthis:\n  \\<not> eval e f g p\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> eval e f g p", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> eval e f g p\n\ngoal (1 subgoal):\n 1. False", "using * \\<open>p \\<in> set G\\<close>"], ["proof (prove)\nusing this:\n  \\<not> eval e f g p\n  \\<forall>p\\<in>set (Exists A # G). eval e f g p\n  p \\<in> set G\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p\\<in>set (Exists A # G). \\<not> eval e f g p\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<exists>p\\<in>set (Pred i l # Neg (Pred i l) # G).\n          \\<not> eval e f g p\n 2. \\<And>G f. \\<exists>p\\<in>set (\\<bottom> # G). \\<not> eval e f g p\n 3. \\<And>G f. \\<exists>p\\<in>set (Neg \\<top> # G). \\<not> eval e f g p\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<exists>p\\<in>set (A # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Neg A) # G).\n                            \\<not> eval e f g p\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (A # B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (And A B # G).\n                            \\<not> eval e f g p\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (Neg A # Neg B # G).\n              \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Or A B) # G).\n                            \\<not> eval e f g p\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (A # Neg B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Impl A B) # G).\n                            \\<not> eval e f g p\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<exists>p\\<in>set (Neg A # G). \\<not> eval e f g p;\n        \\<stileturn> Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (Neg B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (And A B) # G).\n                            \\<not> eval e f g p\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<exists>p\\<in>set (A # G). \\<not> eval e f g p;\n        \\<stileturn> B # G;\n        \\<And>f. \\<exists>p\\<in>set (B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Or A B # G).\n                            \\<not> eval e f g p\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<exists>p\\<in>set (Neg A # G). \\<not> eval e f g p;\n         \\<stileturn> B # G;\n         \\<And>f. \\<exists>p\\<in>set (B # G). \\<not> eval e f g p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p\\<in>set (Impl A B # G).\n                             \\<not> eval e f g p\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<exists>p\\<in>set (Pred i l # Neg (Pred i l) # G).\n          \\<not> eval e f g p\n 2. \\<And>G f. \\<exists>p\\<in>set (\\<bottom> # G). \\<not> eval e f g p\n 3. \\<And>G f. \\<exists>p\\<in>set (Neg \\<top> # G). \\<not> eval e f g p\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<exists>p\\<in>set (A # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Neg A) # G).\n                            \\<not> eval e f g p\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (A # B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (And A B # G).\n                            \\<not> eval e f g p\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (Neg A # Neg B # G).\n              \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Or A B) # G).\n                            \\<not> eval e f g p\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (A # Neg B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Impl A B) # G).\n                            \\<not> eval e f g p\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<exists>p\\<in>set (Neg A # G). \\<not> eval e f g p;\n        \\<stileturn> Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (Neg B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (And A B) # G).\n                            \\<not> eval e f g p\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<exists>p\\<in>set (A # G). \\<not> eval e f g p;\n        \\<stileturn> B # G;\n        \\<And>f. \\<exists>p\\<in>set (B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Or A B # G).\n                            \\<not> eval e f g p\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<exists>p\\<in>set (Neg A # G). \\<not> eval e f g p;\n         \\<stileturn> B # G;\n         \\<And>f. \\<exists>p\\<in>set (B # G). \\<not> eval e f g p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p\\<in>set (Impl A B # G).\n                             \\<not> eval e f g p\nA total of 14 subgoals...", "case (DeltaNegForall A n G)"], ["proof (state)\nthis:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<exists>p\\<in>set (Neg (A[App n []/0]) # G). \\<not> eval e ?f g p\n  news n (A # G)\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<exists>p\\<in>set (Pred i l # Neg (Pred i l) # G).\n          \\<not> eval e f g p\n 2. \\<And>G f. \\<exists>p\\<in>set (\\<bottom> # G). \\<not> eval e f g p\n 3. \\<And>G f. \\<exists>p\\<in>set (Neg \\<top> # G). \\<not> eval e f g p\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<exists>p\\<in>set (A # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Neg A) # G).\n                            \\<not> eval e f g p\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (A # B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (And A B # G).\n                            \\<not> eval e f g p\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (Neg A # Neg B # G).\n              \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Or A B) # G).\n                            \\<not> eval e f g p\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (A # Neg B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Impl A B) # G).\n                            \\<not> eval e f g p\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<exists>p\\<in>set (Neg A # G). \\<not> eval e f g p;\n        \\<stileturn> Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (Neg B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (And A B) # G).\n                            \\<not> eval e f g p\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<exists>p\\<in>set (A # G). \\<not> eval e f g p;\n        \\<stileturn> B # G;\n        \\<And>f. \\<exists>p\\<in>set (B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Or A B # G).\n                            \\<not> eval e f g p\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<exists>p\\<in>set (Neg A # G). \\<not> eval e f g p;\n         \\<stileturn> B # G;\n         \\<And>f. \\<exists>p\\<in>set (B # G). \\<not> eval e f g p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p\\<in>set (Impl A B # G).\n                             \\<not> eval e f g p\nA total of 14 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set (Neg (Forall A) # G). \\<not> eval e f g p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Neg (Forall A) # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "assume \\<open>\\<not> (\\<exists>p \\<in> set (Neg (Forall A) # G). \\<not> eval e f g p)\\<close>"], ["proof (state)\nthis:\n  \\<not> (\\<exists>p\\<in>set (Neg (Forall A) # G). \\<not> eval e f g p)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Neg (Forall A) # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>p\\<in>set (Neg (Forall A) # G). \\<not> eval e f g p)", "have *: \\<open>\\<forall>p \\<in> set (Neg (Forall A) # G). eval e f g p\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>p\\<in>set (Neg (Forall A) # G). \\<not> eval e f g p)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (Neg (Forall A) # G). eval e f g p", "by simp"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (Neg (Forall A) # G). eval e f g p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Neg (Forall A) # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set (Neg (Forall A) # G). eval e f g p", "obtain x where \\<open>eval (shift e 0 x) (f(n := \\<lambda>w. x)) g (Neg A)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (Neg (Forall A) # G). eval e f g p\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g\n         (Neg A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>news n (A # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (Neg (Forall A) # G). eval e f g p\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g\n         (Neg A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g (Neg A)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Neg (Forall A) # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g (Neg A)", "have **: \\<open>eval e (f(n := \\<lambda>w. x)) g (Neg (subst A (App n []) 0))\\<close>"], ["proof (prove)\nusing this:\n  eval (e\\<langle>0:x\\<rangle>) (f(n := \\<lambda>w. x)) g (Neg A)\n\ngoal (1 subgoal):\n 1. eval e (f(n := \\<lambda>w. x)) g (Neg (A[App n []/0]))", "by simp"], ["proof (state)\nthis:\n  eval e (f(n := \\<lambda>w. x)) g (Neg (A[App n []/0]))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Neg (Forall A) # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "have \\<open>\\<exists>p \\<in> set (Neg (subst A (App n []) 0) # G). \\<not> eval e (f(n := \\<lambda>w. x)) g p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set (Neg (A[App n []/0]) # G).\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p", "using DeltaNegForall"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<exists>p\\<in>set (Neg (A[App n []/0]) # G). \\<not> eval e ?f g p\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set (Neg (A[App n []/0]) # G).\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p", "by fast"], ["proof (state)\nthis:\n  \\<exists>p\\<in>set (Neg (A[App n []/0]) # G).\n     \\<not> eval e (f(n := \\<lambda>w. x)) g p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Neg (Forall A) # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>set (Neg (A[App n []/0]) # G).\n     \\<not> eval e (f(n := \\<lambda>w. x)) g p", "consider\n      \\<open>\\<not> eval e (f(n := \\<lambda>w. x)) g (Neg (subst A (App n []) 0))\\<close> |\n      \\<open>\\<exists>p \\<in> set G. \\<not> eval e (f(n := \\<lambda>w. x)) g p\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>set (Neg (A[App n []/0]) # G).\n     \\<not> eval e (f(n := \\<lambda>w. x)) g p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> eval e (f(n := \\<lambda>w. x)) g\n                     (Neg (A[App n []/0])) \\<Longrightarrow>\n             thesis;\n     \\<exists>p\\<in>set G.\n        \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> eval e (f(n := \\<lambda>w. x)) g\n                   (Neg (A[App n []/0])) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>p\\<in>set G.\n      \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>p\\<in>set (Neg (Forall A) # G).\n               \\<not> eval e f g p) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> eval e (f(n := \\<lambda>w. x)) g\n                   (Neg (A[App n []/0])) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>p\\<in>set G.\n      \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> eval e (f(n := \\<lambda>w. x)) g\n                   (Neg (A[App n []/0])) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>p\\<in>set G.\n      \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> eval e (f(n := \\<lambda>w. x)) g\n            (Neg (A[App n []/0])) \\<Longrightarrow>\n    False\n 2. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "case 1"], ["proof (state)\nthis:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g (Neg (A[App n []/0]))\n\ngoal (2 subgoals):\n 1. \\<not> eval e (f(n := \\<lambda>w. x)) g\n            (Neg (A[App n []/0])) \\<Longrightarrow>\n    False\n 2. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g (Neg (A[App n []/0]))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g (Neg (A[App n []/0]))\n\ngoal (1 subgoal):\n 1. False", "using **"], ["proof (prove)\nusing this:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g (Neg (A[App n []/0]))\n  eval e (f(n := \\<lambda>w. x)) g (Neg (A[App n []/0]))\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "case 2"], ["proof (state)\nthis:\n  \\<exists>p\\<in>set G. \\<not> eval e (f(n := \\<lambda>w. x)) g p\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>set G. \\<not> eval e (f(n := \\<lambda>w. x)) g p", "obtain p where \\<open>\\<not> eval e (f(n := \\<lambda>w. x)) g p\\<close> \\<open>p \\<in> set G\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>set G. \\<not> eval e (f(n := \\<lambda>w. x)) g p\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>\\<not> eval e (f(n := \\<lambda>w. x)) g p;\n         p \\<in> set G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g p\n  p \\<in> set G\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g p\n  p \\<in> set G", "have \\<open>\\<not> eval e f g p\\<close>"], ["proof (prove)\nusing this:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g p\n  p \\<in> set G\n\ngoal (1 subgoal):\n 1. \\<not> eval e f g p", "using \\<open>news n (A # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> eval e (f(n := \\<lambda>w. x)) g p\n  p \\<in> set G\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<not> eval e f g p", "by (metis Ball_set set_subset_Cons subsetCE upd_lemma)"], ["proof (state)\nthis:\n  \\<not> eval e f g p\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set G.\n       \\<not> eval e (f(n := \\<lambda>w. x)) g p \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> eval e f g p", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> eval e f g p\n\ngoal (1 subgoal):\n 1. False", "using * \\<open>p \\<in> set G\\<close>"], ["proof (prove)\nusing this:\n  \\<not> eval e f g p\n  \\<forall>p\\<in>set (Neg (Forall A) # G). eval e f g p\n  p \\<in> set G\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p\\<in>set (Neg (Forall A) # G). \\<not> eval e f g p\n\ngoal (13 subgoals):\n 1. \\<And>i l G f.\n       \\<exists>p\\<in>set (Pred i l # Neg (Pred i l) # G).\n          \\<not> eval e f g p\n 2. \\<And>G f. \\<exists>p\\<in>set (\\<bottom> # G). \\<not> eval e f g p\n 3. \\<And>G f. \\<exists>p\\<in>set (Neg \\<top> # G). \\<not> eval e f g p\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<exists>p\\<in>set (A # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Neg A) # G).\n                            \\<not> eval e f g p\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (A # B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (And A B # G).\n                            \\<not> eval e f g p\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (Neg A # Neg B # G).\n              \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Or A B) # G).\n                            \\<not> eval e f g p\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (A # Neg B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (Impl A B) # G).\n                            \\<not> eval e f g p\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<exists>p\\<in>set (Neg A # G). \\<not> eval e f g p;\n        \\<stileturn> Neg B # G;\n        \\<And>f.\n           \\<exists>p\\<in>set (Neg B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Neg (And A B) # G).\n                            \\<not> eval e f g p\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<exists>p\\<in>set (A # G). \\<not> eval e f g p;\n        \\<stileturn> B # G;\n        \\<And>f. \\<exists>p\\<in>set (B # G). \\<not> eval e f g p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p\\<in>set (Or A B # G).\n                            \\<not> eval e f g p\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<exists>p\\<in>set (Neg A # G). \\<not> eval e f g p;\n         \\<stileturn> B # G;\n         \\<And>f. \\<exists>p\\<in>set (B # G). \\<not> eval e f g p\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p\\<in>set (Impl A B # G).\n                             \\<not> eval e f g p\nA total of 13 subgoals...", "qed auto"], ["", "theorem tableau_soundness:\n  \\<open>tableauproof ps p \\<Longrightarrow> list_all (eval e f g) ps \\<Longrightarrow> eval e f g p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tableauproof ps p; list_all (eval e f g) ps\\<rbrakk>\n    \\<Longrightarrow> eval e f g p", "using TC_soundness"], ["proof (prove)\nusing this:\n  \\<stileturn> ?G \\<Longrightarrow>\n  \\<exists>p\\<in>set ?G. \\<not> eval ?e ?f ?g p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tableauproof ps p; list_all (eval e f g) ps\\<rbrakk>\n    \\<Longrightarrow> eval e f g p", "unfolding tableauproof_def list_all_def"], ["proof (prove)\nusing this:\n  \\<stileturn> ?G \\<Longrightarrow>\n  \\<exists>p\\<in>set ?G. \\<not> eval ?e ?f ?g p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg p # ps; Ball (set ps) (eval e f g)\\<rbrakk>\n    \\<Longrightarrow> eval e f g p", "by fastforce"], ["", "subsection \\<open>Completeness for Closed Formulas\\<close>"], ["", "theorem infinite_nonempty: \\<open>infinite A \\<Longrightarrow> \\<exists>x. x \\<in> A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> \\<exists>x. x \\<in> A", "by (simp add: ex_in_conv infinite_imp_nonempty)"], ["", "theorem TCd_consistency:\n  assumes inf_param: \\<open>infinite (UNIV::'a set)\\<close>\n  shows \\<open>consistency {S::('a, 'b) form set. \\<exists>G. S = set G \\<and> \\<not> (\\<stileturn> G)}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistency {set G |G. \\<not> (\\<stileturn> G)}", "unfolding consistency_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S.\n       S \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<longrightarrow>\n       (\\<forall>p ts.\n           \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n       \\<bottom> \\<notin> S \\<and>\n       Neg \\<top> \\<notin> S \\<and>\n       (\\<forall>Z.\n           Neg (Neg Z) \\<in> S \\<longrightarrow>\n           S \\<union> {Z} \\<in> {set G |G. \\<not> (\\<stileturn> G)}) \\<and>\n       (\\<forall>A B.\n           And A B \\<in> S \\<longrightarrow>\n           S \\<union> {A, B}\n           \\<in> {set G |G. \\<not> (\\<stileturn> G)}) \\<and>\n       (\\<forall>A B.\n           Neg (Or A B) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A, Neg B}\n           \\<in> {set G |G. \\<not> (\\<stileturn> G)}) \\<and>\n       (\\<forall>A B.\n           Or A B \\<in> S \\<longrightarrow>\n           S \\<union> {A} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n           S \\<union> {B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}) \\<and>\n       (\\<forall>A B.\n           Neg (And A B) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A}\n           \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n           S \\<union> {Neg B}\n           \\<in> {set G |G. \\<not> (\\<stileturn> G)}) \\<and>\n       (\\<forall>A B.\n           Impl A B \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A}\n           \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n           S \\<union> {B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}) \\<and>\n       (\\<forall>A B.\n           Neg (Impl A B) \\<in> S \\<longrightarrow>\n           S \\<union> {A, Neg B}\n           \\<in> {set G |G. \\<not> (\\<stileturn> G)}) \\<and>\n       (\\<forall>P t.\n           closedt 0 t \\<longrightarrow>\n           Forall P \\<in> S \\<longrightarrow>\n           S \\<union> {P[t/0]}\n           \\<in> {set G |G. \\<not> (\\<stileturn> G)}) \\<and>\n       (\\<forall>P t.\n           closedt 0 t \\<longrightarrow>\n           Neg (Exists P) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg (P[t/0])}\n           \\<in> {set G |G. \\<not> (\\<stileturn> G)}) \\<and>\n       (\\<forall>P.\n           Exists P \\<in> S \\<longrightarrow>\n           (\\<exists>x.\n               S \\<union> {P[App x []/0]}\n               \\<in> {set G |G. \\<not> (\\<stileturn> G)})) \\<and>\n       (\\<forall>P.\n           Neg (Forall P) \\<in> S \\<longrightarrow>\n           (\\<exists>x.\n               S \\<union> {Neg (P[App x []/0])}\n               \\<in> {set G |G. \\<not> (\\<stileturn> G)}))", "proof (intro conjI allI impI notI)"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        \\<bottom> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 14 subgoals...", "fix S :: \\<open>('a, 'b) form set\\<close>"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        \\<bottom> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 14 subgoals...", "assume \\<open>S \\<in> {set G | G. \\<not> (\\<stileturn> G)}\\<close> (is \\<open>S \\<in> ?C\\<close>)"], ["proof (state)\nthis:\n  S \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        \\<bottom> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  S \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "obtain G :: \\<open>('a, 'b) form list\\<close>\n    where *: \\<open>S = set G\\<close> and \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  S \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>S = set G; \\<not> (\\<stileturn> G)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  S = set G\n  \\<not> (\\<stileturn> G)\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        \\<bottom> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 14 subgoals...", "{"], ["proof (state)\nthis:\n  S = set G\n  \\<not> (\\<stileturn> G)\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        \\<bottom> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 14 subgoals...", "fix p ts"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        \\<bottom> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 14 subgoals...", "assume \\<open>Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        \\<bottom> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S", "show False"], ["proof (prove)\nusing this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n\ngoal (1 subgoal):\n 1. False", "using * Basic Order \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n  S = set G\n  \\<stileturn> Pred ?i ?l # Neg (Pred ?i ?l) # ?G\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (13 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        \\<bottom> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n         Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 13 subgoals...", "}"], ["proof (state)\nthis:\n  Pred ?p2 ?ts2 \\<in> S \\<and> Neg (Pred ?p2 ?ts2) \\<in> S \\<Longrightarrow>\n  False\n\ngoal (13 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        \\<bottom> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n         Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 13 subgoals...", "{"], ["proof (state)\nthis:\n  Pred ?p2 ?ts2 \\<in> S \\<and> Neg (Pred ?p2 ?ts2) \\<in> S \\<Longrightarrow>\n  False\n\ngoal (13 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        \\<bottom> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n         Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 13 subgoals...", "assume \\<open>\\<bottom> \\<in> S\\<close>"], ["proof (state)\nthis:\n  \\<bottom> \\<in> S\n\ngoal (13 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        \\<bottom> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n         Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<bottom> \\<in> S", "show False"], ["proof (prove)\nusing this:\n  \\<bottom> \\<in> S\n\ngoal (1 subgoal):\n 1. False", "using * BasicFF Order \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  \\<bottom> \\<in> S\n  S = set G\n  \\<stileturn> \\<bottom> # ?G\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (12 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 12 subgoals...", "}"], ["proof (state)\nthis:\n  \\<bottom> \\<in> S \\<Longrightarrow> False\n\ngoal (12 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 12 subgoals...", "{"], ["proof (state)\nthis:\n  \\<bottom> \\<in> S \\<Longrightarrow> False\n\ngoal (12 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 12 subgoals...", "assume \\<open>Neg \\<top> \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg \\<top> \\<in> S\n\ngoal (12 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg \\<top> \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                          \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg \\<top> \\<in> S", "show False"], ["proof (prove)\nusing this:\n  Neg \\<top> \\<in> S\n\ngoal (1 subgoal):\n 1. False", "using * BasicNegTT Order \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  Neg \\<top> \\<in> S\n  S = set G\n  \\<stileturn> Neg \\<top> # ?G\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 11 subgoals...", "}"], ["proof (state)\nthis:\n  Neg \\<top> \\<in> S \\<Longrightarrow> False\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 11 subgoals...", "{"], ["proof (state)\nthis:\n  Neg \\<top> \\<in> S \\<Longrightarrow> False\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 11 subgoals...", "fix Z"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 11 subgoals...", "assume \\<open>Neg (Neg Z) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Neg Z) \\<in> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg (Neg Z) \\<in> S", "have \\<open>\\<not> (\\<stileturn> Z # G)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> Z # G)", "using * AlphaNegNeg Order \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> S\n  S = set G\n  \\<stileturn> ?A # ?G \\<Longrightarrow> \\<stileturn> Neg (Neg ?A) # ?G\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> Z # G)", "by (metis insert_absorb list.set(2))"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> Z # G)\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 11 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> Z # G)\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 11 subgoals...", "have \\<open>S \\<union> {Z} = set (Z # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Z} = set (Z # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {Z} = set (Z # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {Z} = set (Z # G)\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}\nA total of 11 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<stileturn> Z # G)\n  S \\<union> {Z} = set (Z # G)", "show \\<open>S \\<union> {Z} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> Z # G)\n  S \\<union> {Z} = set (Z # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {Z} \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Z} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "}"], ["proof (state)\nthis:\n  Neg (Neg ?Z2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?Z2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "{"], ["proof (state)\nthis:\n  Neg (Neg ?Z2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?Z2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "fix A B"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "assume \\<open>And A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  And A B \\<in> S\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  And A B \\<in> S", "have \\<open>\\<not> (\\<stileturn> A # B # G)\\<close>"], ["proof (prove)\nusing this:\n  And A B \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> A # B # G)", "using * AlphaAnd Order \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  And A B \\<in> S\n  S = set G\n  \\<stileturn> ?A # ?B # ?G \\<Longrightarrow> \\<stileturn> And ?A ?B # ?G\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> A # B # G)", "by (metis insert_absorb list.set(2))"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> A # B # G)\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> A # B # G)\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "have \\<open>S \\<union> {A, B} = set (A # B # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {A, B} = set (A # B # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {A, B} = set (A # B # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {A, B} = set (A # B # G)\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<stileturn> A # B # G)\n  S \\<union> {A, B} = set (A # B # G)", "show \\<open>S \\<union> {A, B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> A # B # G)\n  S \\<union> {A, B} = set (A # B # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {A, B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {A, B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "}"], ["proof (state)\nthis:\n  And ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, ?B2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "{"], ["proof (state)\nthis:\n  And ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, ?B2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "fix A B"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "assume \\<open>Neg (Or A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Or A B) \\<in> S\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  Neg (Or A B) \\<in> S", "have \\<open>\\<not> (\\<stileturn> Neg A # Neg B # G)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> Neg A # Neg B # G)", "using * AlphaNegOr Order \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> S\n  S = set G\n  \\<stileturn> Neg ?A # Neg ?B # ?G \\<Longrightarrow>\n  \\<stileturn> Neg (Or ?A ?B) # ?G\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> Neg A # Neg B # G)", "by (metis insert_absorb list.set(2))"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> Neg A # Neg B # G)\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> Neg A # Neg B # G)\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "have \\<open>S \\<union> {Neg A, Neg B} = set (Neg A # Neg B # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg A, Neg B} = set (Neg A # Neg B # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A, Neg B} = set (Neg A # Neg B # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {Neg A, Neg B} = set (Neg A # Neg B # G)\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<stileturn> Neg A # Neg B # G)\n  S \\<union> {Neg A, Neg B} = set (Neg A # Neg B # G)", "show \\<open>S \\<union> {Neg A, Neg B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> Neg A # Neg B # G)\n  S \\<union> {Neg A, Neg B} = set (Neg A # Neg B # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A, Neg B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg A, Neg B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "}"], ["proof (state)\nthis:\n  Neg (Or ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2, Neg ?B2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "{"], ["proof (state)\nthis:\n  Neg (Or ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2, Neg ?B2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "fix A B"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "assume \\<open>Neg (Impl A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Impl A B) \\<in> S\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  Neg (Impl A B) \\<in> S", "have \\<open>\\<not> (\\<stileturn> A # Neg B # G)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> A # Neg B # G)", "using * AlphaNegImpl Order \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> S\n  S = set G\n  \\<stileturn> ?A # Neg ?B # ?G \\<Longrightarrow>\n  \\<stileturn> Neg (Impl ?A ?B) # ?G\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> A # Neg B # G)", "by (metis insert_absorb list.set(2))"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> A # Neg B # G)\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> A # Neg B # G)\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "have \\<open>{A, Neg B} \\<union> S = set (A # Neg B # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {A, Neg B} \\<union> S = set (A # Neg B # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. {A, Neg B} \\<union> S = set (A # Neg B # G)", "by simp"], ["proof (state)\nthis:\n  {A, Neg B} \\<union> S = set (A # Neg B # G)\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<stileturn> A # Neg B # G)\n  {A, Neg B} \\<union> S = set (A # Neg B # G)", "show \\<open>S \\<union> {A, Neg B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> A # Neg B # G)\n  {A, Neg B} \\<union> S = set (A # Neg B # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {A, Neg B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {A, Neg B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "}"], ["proof (state)\nthis:\n  Neg (Impl ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, Neg ?B2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "{"], ["proof (state)\nthis:\n  Neg (Impl ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, Neg ?B2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "fix A B"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "assume \\<open>Or A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  Or A B \\<in> S\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  Or A B \\<in> S", "have \\<open>\\<not> (\\<stileturn> A # G) \\<or> \\<not> (\\<stileturn> B # G)\\<close>"], ["proof (prove)\nusing this:\n  Or A B \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> A # G) \\<or> \\<not> (\\<stileturn> B # G)", "using * BetaOr Order \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  Or A B \\<in> S\n  S = set G\n  \\<lbrakk>\\<stileturn> ?A # ?G; \\<stileturn> ?B # ?G\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> Or ?A ?B # ?G\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> A # G) \\<or> \\<not> (\\<stileturn> B # G)", "by (metis insert_absorb list.set(2))"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> A # G) \\<or> \\<not> (\\<stileturn> B # G)\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<stileturn> A # G) \\<or> \\<not> (\\<stileturn> B # G)", "show \\<open>S \\<union> {A} \\<in> ?C \\<or> S \\<union> {B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> A # G) \\<or> \\<not> (\\<stileturn> B # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {A} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n    S \\<union> {B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "using *"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> A # G) \\<or> \\<not> (\\<stileturn> B # G)\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {A} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n    S \\<union> {B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "by auto"], ["proof (state)\nthis:\n  S \\<union> {A} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n  S \\<union> {B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "}"], ["proof (state)\nthis:\n  Or ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n  S \\<union> {?B2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "{"], ["proof (state)\nthis:\n  Or ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n  S \\<union> {?B2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "fix A B"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "assume \\<open>Neg (And A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (And A B) \\<in> S\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  Neg (And A B) \\<in> S", "have \\<open>\\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> Neg B # G)\\<close>"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> Neg B # G)", "using * BetaNegAnd Order \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> S\n  S = set G\n  \\<lbrakk>\\<stileturn> Neg ?A # ?G; \\<stileturn> Neg ?B # ?G\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> Neg (And ?A ?B) # ?G\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> Neg B # G)", "by (metis insert_absorb list.set(2))"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> Neg B # G)\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> Neg B # G)", "show \\<open>S \\<union> {Neg A} \\<in> ?C \\<or> S \\<union> {Neg B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> Neg B # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n    S \\<union> {Neg B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "using *"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> Neg B # G)\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n    S \\<union> {Neg B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "by auto"], ["proof (state)\nthis:\n  S \\<union> {Neg A} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n  S \\<union> {Neg B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "}"], ["proof (state)\nthis:\n  Neg (And ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n  S \\<union> {Neg ?B2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "{"], ["proof (state)\nthis:\n  Neg (And ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n  S \\<union> {Neg ?B2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "fix A B"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "assume \\<open>Impl A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  Impl A B \\<in> S\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  Impl A B \\<in> S", "have \\<open>\\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> B # G)\\<close>"], ["proof (prove)\nusing this:\n  Impl A B \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> B # G)", "using * BetaImpl Order \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  Impl A B \\<in> S\n  S = set G\n  \\<lbrakk>\\<stileturn> Neg ?A # ?G; \\<stileturn> ?B # ?G\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> Impl ?A ?B # ?G\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> B # G)", "by (metis insert_absorb list.set(2))"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> B # G)\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> B # G)", "show \\<open>S \\<union> {Neg A} \\<in> ?C \\<or> S \\<union> {B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> B # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n    S \\<union> {B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "using *"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> Neg A # G) \\<or> \\<not> (\\<stileturn> B # G)\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n    S \\<union> {B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "by auto"], ["proof (state)\nthis:\n  S \\<union> {Neg A} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n  S \\<union> {B} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "}"], ["proof (state)\nthis:\n  Impl ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n  S \\<union> {?B2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "{"], ["proof (state)\nthis:\n  Impl ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> {set G |G. \\<not> (\\<stileturn> G)} \\<or>\n  S \\<union> {?B2} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "fix P and t :: \\<open>'a term\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "assume \\<open>Forall P \\<in> S\\<close>"], ["proof (state)\nthis:\n  Forall P \\<in> S\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  Forall P \\<in> S", "have \\<open>\\<not> (\\<stileturn> subst P t 0 # G)\\<close>"], ["proof (prove)\nusing this:\n  Forall P \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> P[t/0] # G)", "using * GammaForall Order\\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  Forall P \\<in> S\n  S = set G\n  \\<stileturn> ?A[?t/0] # ?G \\<Longrightarrow> \\<stileturn> Forall ?A # ?G\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> P[t/0] # G)", "by (metis insert_absorb list.set(2))"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> P[t/0] # G)\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> P[t/0] # G)\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "have \\<open>S \\<union> {subst P t 0} = set (subst P t 0 # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {P[t/0]} = set (P[t/0] # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {P[t/0]} = set (P[t/0] # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {P[t/0]} = set (P[t/0] # G)\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<stileturn> P[t/0] # G)\n  S \\<union> {P[t/0]} = set (P[t/0] # G)", "show \\<open>S \\<union> {subst P t 0} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> P[t/0] # G)\n  S \\<union> {P[t/0]} = set (P[t/0] # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {P[t/0]} \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {P[t/0]} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "}"], ["proof (state)\nthis:\n  Forall ?P2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?P2[?t2/0]} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "{"], ["proof (state)\nthis:\n  Forall ?P2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?P2[?t2/0]} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "fix P and t :: \\<open>'a term\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "assume \\<open>Neg (Exists P) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Exists P) \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  Neg (Exists P) \\<in> S", "have \\<open>\\<not> (\\<stileturn> Neg (subst P t 0) # G)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Exists P) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> Neg (P[t/0]) # G)", "using * GammaNegExists Order \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Exists P) \\<in> S\n  S = set G\n  \\<stileturn> Neg (?A[?t/0]) # ?G \\<Longrightarrow>\n  \\<stileturn> Neg (Exists ?A) # ?G\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> Neg (P[t/0]) # G)", "by (metis insert_absorb list.set(2))"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> Neg (P[t/0]) # G)\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> Neg (P[t/0]) # G)\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "have \\<open>S \\<union> {Neg (subst P t 0)} = set (Neg (subst P t 0) # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[t/0])} = set (Neg (P[t/0]) # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[t/0])} = set (Neg (P[t/0]) # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {Neg (P[t/0])} = set (Neg (P[t/0]) # G)\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<stileturn> Neg (P[t/0]) # G)\n  S \\<union> {Neg (P[t/0])} = set (Neg (P[t/0]) # G)", "show \\<open>S \\<union> {Neg (subst P t 0)} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> Neg (P[t/0]) # G)\n  S \\<union> {Neg (P[t/0])} = set (Neg (P[t/0]) # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[t/0])} \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg (P[t/0])} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "}"], ["proof (state)\nthis:\n  Neg (Exists ?P2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg (?P2[?t2/0])} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "{"], ["proof (state)\nthis:\n  Neg (Exists ?P2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg (?P2[?t2/0])} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "fix P"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "assume \\<open>Exists P \\<in> S\\<close>"], ["proof (state)\nthis:\n  Exists P \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "have \\<open>finite ((\\<Union>p \\<in> set G. params p) \\<union> params P)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (params ` set G) \\<union> params P)", "by simp"], ["proof (state)\nthis:\n  finite (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  finite (\\<Union> (params ` set G) \\<union> params P)", "have \\<open>infinite (- ((\\<Union>p \\<in> set G. params p) \\<union> params P))\\<close>"], ["proof (prove)\nusing this:\n  finite (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. infinite (- (\\<Union> (params ` set G) \\<union> params P))", "using inf_param Diff_infinite_finite finite_compl infinite_UNIV_listI"], ["proof (prove)\nusing this:\n  finite (\\<Union> (params ` set G) \\<union> params P)\n  infinite UNIV\n  \\<lbrakk>finite ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite (?S - ?T)\n  finite ?A \\<Longrightarrow> finite (- ?A) = finite UNIV\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. infinite (- (\\<Union> (params ` set G) \\<union> params P))", "by blast"], ["proof (state)\nthis:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))", "obtain x where **: \\<open>x \\<in> - ((\\<Union>p \\<in> set G. params p) \\<union> params P)\\<close>"], ["proof (prove)\nusing this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - (\\<Union> (params ` set G) \\<union>\n                   params P) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using infinite_imp_nonempty"], ["proof (prove)\nusing this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n  infinite ?S \\<Longrightarrow> ?S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - (\\<Union> (params ` set G) \\<union>\n                   params P) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)", "have \\<open>news x (P # G)\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. news x (P # G)", "using Ball_set_list_all"], ["proof (prove)\nusing this:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n  Ball (set ?xs) ?P = list_all ?P ?xs\n\ngoal (1 subgoal):\n 1. news x (P # G)", "by auto"], ["proof (state)\nthis:\n  news x (P # G)\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  news x (P # G)", "have \\<open>\\<not> (\\<stileturn> subst P (App x []) 0 # G)\\<close>"], ["proof (prove)\nusing this:\n  news x (P # G)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> P[App x []/0] # G)", "using * \\<open>Exists P \\<in> S\\<close> Order DeltaExists \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  news x (P # G)\n  S = set G\n  Exists P \\<in> S\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<lbrakk>\\<stileturn> ?A[App ?n []/0] # ?G; news ?n (?A # ?G)\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> Exists ?A # ?G\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> P[App x []/0] # G)", "by (metis insert_absorb list.set(2))"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> P[App x []/0] # G)\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> P[App x []/0] # G)\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "have \\<open>S \\<union> {subst P (App x []) 0} = set (subst P (App x []) 0 # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {P[App x []/0]} = set (P[App x []/0] # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {P[App x []/0]} = set (P[App x []/0] # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {P[App x []/0]} = set (P[App x []/0] # G)\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<stileturn> P[App x []/0] # G)\n  S \\<union> {P[App x []/0]} = set (P[App x []/0] # G)", "show \\<open>\\<exists>x. S \\<union> {subst P (App x []) 0} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> P[App x []/0] # G)\n  S \\<union> {P[App x []/0]} = set (P[App x []/0] # G)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       S \\<union> {P[App x []/0]} \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "by blast"], ["proof (state)\nthis:\n  \\<exists>x.\n     S \\<union> {P[App x []/0]} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "}"], ["proof (state)\nthis:\n  Exists ?P2 \\<in> S \\<Longrightarrow>\n  \\<exists>x.\n     S \\<union> {?P2[App x []/0]} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "{"], ["proof (state)\nthis:\n  Exists ?P2 \\<in> S \\<Longrightarrow>\n  \\<exists>x.\n     S \\<union> {?P2[App x []/0]} \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "assume \\<open>Neg (Forall P) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Forall P) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "have \\<open>finite ((\\<Union>p \\<in> set G. params p) \\<union> params P)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (params ` set G) \\<union> params P)", "by simp"], ["proof (state)\nthis:\n  finite (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  finite (\\<Union> (params ` set G) \\<union> params P)", "have \\<open>infinite (- ((\\<Union>p \\<in> set G. params p) \\<union> params P))\\<close>"], ["proof (prove)\nusing this:\n  finite (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. infinite (- (\\<Union> (params ` set G) \\<union> params P))", "using inf_param Diff_infinite_finite finite_compl infinite_UNIV_listI"], ["proof (prove)\nusing this:\n  finite (\\<Union> (params ` set G) \\<union> params P)\n  infinite UNIV\n  \\<lbrakk>finite ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite (?S - ?T)\n  finite ?A \\<Longrightarrow> finite (- ?A) = finite UNIV\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. infinite (- (\\<Union> (params ` set G) \\<union> params P))", "by blast"], ["proof (state)\nthis:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))", "obtain x where **: \\<open>x \\<in> - ((\\<Union>p \\<in> set G. params p) \\<union> params P)\\<close>"], ["proof (prove)\nusing this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - (\\<Union> (params ` set G) \\<union>\n                   params P) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using infinite_imp_nonempty"], ["proof (prove)\nusing this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n  infinite ?S \\<Longrightarrow> ?S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - (\\<Union> (params ` set G) \\<union>\n                   params P) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)", "have \\<open>news x (P # G)\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. news x (P # G)", "using Ball_set_list_all"], ["proof (prove)\nusing this:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n  Ball (set ?xs) ?P = list_all ?P ?xs\n\ngoal (1 subgoal):\n 1. news x (P # G)", "by auto"], ["proof (state)\nthis:\n  news x (P # G)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "then"], ["proof (chain)\npicking this:\n  news x (P # G)", "have \\<open>\\<not> (\\<stileturn> Neg (subst P (App x []) 0) # G)\\<close>"], ["proof (prove)\nusing this:\n  news x (P # G)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> Neg (P[App x []/0]) # G)", "using * \\<open>Neg (Forall P) \\<in> S\\<close> Order DeltaNegForall \\<open>\\<not> (\\<stileturn> G)\\<close>"], ["proof (prove)\nusing this:\n  news x (P # G)\n  S = set G\n  Neg (Forall P) \\<in> S\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  \\<lbrakk>\\<stileturn> Neg (?A[App ?n []/0]) # ?G;\n   news ?n (?A # ?G)\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> Neg (Forall ?A) # ?G\n  \\<not> (\\<stileturn> G)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<stileturn> Neg (P[App x []/0]) # G)", "by (metis insert_absorb list.set(2))"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> Neg (P[App x []/0]) # G)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<stileturn> Neg (P[App x []/0]) # G)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "have \\<open>S \\<union> {Neg (subst P (App x []) 0)} = set (Neg (subst P (App x []) 0) # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[App x []/0])} = set (Neg (P[App x []/0]) # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[App x []/0])} = set (Neg (P[App x []/0]) # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {Neg (P[App x []/0])} = set (Neg (P[App x []/0]) # G)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> (\\<stileturn> G)};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<stileturn> Neg (P[App x []/0]) # G)\n  S \\<union> {Neg (P[App x []/0])} = set (Neg (P[App x []/0]) # G)", "show \\<open>\\<exists>x. S \\<union> {Neg (subst P (App x []) 0)} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> Neg (P[App x []/0]) # G)\n  S \\<union> {Neg (P[App x []/0])} = set (Neg (P[App x []/0]) # G)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       S \\<union> {Neg (P[App x []/0])}\n       \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "by blast"], ["proof (state)\nthis:\n  \\<exists>x.\n     S \\<union> {Neg (P[App x []/0])}\n     \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  Neg (Forall ?P2) \\<in> S \\<Longrightarrow>\n  \\<exists>x.\n     S \\<union> {Neg (?P2[App x []/0])}\n     \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem tableau_completeness':\n  fixes p :: \\<open>(nat, nat) form\\<close>\n  assumes \\<open>closed 0 p\\<close>\n    and \\<open>list_all (closed 0) ps\\<close>\n    and mod: \\<open>\\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. list_all (eval e f g) ps \\<longrightarrow> eval e f g p\\<close>\n  shows \\<open>tableauproof ps p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. tableauproof ps p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "assume \\<open>\\<not> tableauproof ps p\\<close>"], ["proof (state)\nthis:\n  \\<not> tableauproof ps p\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "let ?S = \\<open>set (Neg p # ps)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "let ?C = \\<open>{set (G :: (nat, nat) form list) | G. \\<not> (\\<stileturn> G)}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "let ?f = HApp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "let ?g = \\<open>(\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> Extend ?S\n              (mk_finite_char (mk_alt_consistency (close ?C))) from_nat)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "from \\<open>list_all (closed 0) ps\\<close>"], ["proof (chain)\npicking this:\n  list_all (closed 0) ps", "have \\<open>\\<forall>p \\<in> set ps. closed 0 p\\<close>"], ["proof (prove)\nusing this:\n  list_all (closed 0) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set ps. closed 0 p", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. closed 0 p\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. closed 0 p\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "assume \\<open>x \\<in> ?S\\<close>"], ["proof (state)\nthis:\n  x \\<in> set (Neg p # ps)\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  x \\<in> set (Neg p # ps)\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "have \\<open>consistency ?C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistency {set G |G. \\<not> (\\<stileturn> G)}", "using TCd_consistency"], ["proof (prove)\nusing this:\n  infinite UNIV \\<Longrightarrow>\n  consistency {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (1 subgoal):\n 1. consistency {set G |G. \\<not> (\\<stileturn> G)}", "by blast"], ["proof (state)\nthis:\n  consistency {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  consistency {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "have \\<open>?S \\<in> ?C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Neg p # ps) \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "using \\<open>\\<not> tableauproof ps p\\<close>"], ["proof (prove)\nusing this:\n  \\<not> tableauproof ps p\n\ngoal (1 subgoal):\n 1. set (Neg p # ps) \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "unfolding tableauproof_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<stileturn> Neg p # ps)\n\ngoal (1 subgoal):\n 1. set (Neg p # ps) \\<in> {set G |G. \\<not> (\\<stileturn> G)}", "by blast"], ["proof (state)\nthis:\n  set (Neg p # ps) \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  set (Neg p # ps) \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "have \\<open>infinite (- (\\<Union>p \\<in> ?S. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` set (Neg p # ps)))", "by (simp add: Compl_eq_Diff_UNIV infinite_UNIV_listI)"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` set (Neg p # ps)))\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` set (Neg p # ps)))\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "note \\<open>closed 0 p\\<close> \\<open>\\<forall>p \\<in> set ps. closed 0 p\\<close> \\<open>x \\<in> ?S\\<close>"], ["proof (state)\nthis:\n  closed 0 p\n  \\<forall>p\\<in>set ps. closed 0 p\n  x \\<in> set (Neg p # ps)\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  closed 0 p\n  \\<forall>p\\<in>set ps. closed 0 p\n  x \\<in> set (Neg p # ps)", "have \\<open>closed 0 x\\<close>"], ["proof (prove)\nusing this:\n  closed 0 p\n  \\<forall>p\\<in>set ps. closed 0 p\n  x \\<in> set (Neg p # ps)\n\ngoal (1 subgoal):\n 1. closed 0 x", "by auto"], ["proof (state)\nthis:\n  closed 0 x\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set (Neg p # ps)\n  consistency {set G |G. \\<not> (\\<stileturn> G)}\n  set (Neg p # ps) \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n  infinite (- \\<Union> (params ` set (Neg p # ps)))\n  closed 0 x", "have \\<open>eval e ?f ?g x\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> set (Neg p # ps)\n  consistency {set G |G. \\<not> (\\<stileturn> G)}\n  set (Neg p # ps) \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n  infinite (- \\<Union> (params ` set (Neg p # ps)))\n  closed 0 x\n\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat)\n     x", "using model_existence"], ["proof (prove)\nusing this:\n  x \\<in> set (Neg p # ps)\n  consistency {set G |G. \\<not> (\\<stileturn> G)}\n  set (Neg p # ps) \\<in> {set G |G. \\<not> (\\<stileturn> G)}\n  infinite (- \\<Union> (params ` set (Neg p # ps)))\n  closed 0 x\n  \\<lbrakk>consistency ?C; ?S \\<in> ?C; infinite (- \\<Union> (params ` ?S));\n   ?p \\<in> ?S; closed 0 ?p\\<rbrakk>\n  \\<Longrightarrow> eval ?e HApp\n                     (\\<lambda>a ts.\n                         Pred a (terms_of_hterms ts)\n                         \\<in> Extend ?S\n                                (mk_finite_char\n                                  (mk_alt_consistency (close ?C)))\n                                from_nat)\n                     ?p\n\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat)\n     x", "by blast"], ["proof (state)\nthis:\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> (\\<stileturn> G)})))\n              from_nat)\n   x\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  ?x3 \\<in> set (Neg p # ps) \\<Longrightarrow>\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> (\\<stileturn> G)})))\n              from_nat)\n   ?x3\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ?x3 \\<in> set (Neg p # ps) \\<Longrightarrow>\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> (\\<stileturn> G)})))\n              from_nat)\n   ?x3", "have \\<open>list_all (eval e ?f ?g) (Neg p # ps)\\<close>"], ["proof (prove)\nusing this:\n  ?x3 \\<in> set (Neg p # ps) \\<Longrightarrow>\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> (\\<stileturn> G)})))\n              from_nat)\n   ?x3\n\ngoal (1 subgoal):\n 1. list_all\n     (eval e HApp\n       (\\<lambda>a ts.\n           Pred a (terms_of_hterms ts)\n           \\<in> Extend (set (Neg p # ps))\n                  (mk_finite_char\n                    (mk_alt_consistency\n                      (close {set G |G. \\<not> (\\<stileturn> G)})))\n                  from_nat))\n     (Neg p # ps)", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat))\n   (Neg p # ps)\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat))\n   (Neg p # ps)\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "have \\<open>eval e ?f ?g (Neg p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat)\n     (Neg p)", "using calculation"], ["proof (prove)\nusing this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat))\n   (Neg p # ps)\n\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat)\n     (Neg p)", "by simp"], ["proof (state)\nthis:\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> (\\<stileturn> G)})))\n              from_nat)\n   (Neg p)\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> (\\<stileturn> G)})))\n              from_nat)\n   (Neg p)\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "have \\<open>list_all (eval e ?f ?g) ps\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (eval e HApp\n       (\\<lambda>a ts.\n           Pred a (terms_of_hterms ts)\n           \\<in> Extend (set (Neg p # ps))\n                  (mk_finite_char\n                    (mk_alt_consistency\n                      (close {set G |G. \\<not> (\\<stileturn> G)})))\n                  from_nat))\n     ps", "using calculation"], ["proof (prove)\nusing this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat))\n   (Neg p # ps)\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> (\\<stileturn> G)})))\n              from_nat)\n   (Neg p)\n\ngoal (1 subgoal):\n 1. list_all\n     (eval e HApp\n       (\\<lambda>a ts.\n           Pred a (terms_of_hterms ts)\n           \\<in> Extend (set (Neg p # ps))\n                  (mk_finite_char\n                    (mk_alt_consistency\n                      (close {set G |G. \\<not> (\\<stileturn> G)})))\n                  from_nat))\n     ps", "by simp"], ["proof (state)\nthis:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat))\n   ps\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat))\n   ps", "have \\<open>eval e ?f ?g p\\<close>"], ["proof (prove)\nusing this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat))\n   ps\n\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat)\n     p", "using mod"], ["proof (prove)\nusing this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat))\n   ps\n  \\<forall>e f g. list_all (eval e f g) ps \\<longrightarrow> eval e f g p\n\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat)\n     p", "by blast"], ["proof (state)\nthis:\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> (\\<stileturn> G)})))\n              from_nat)\n   p\n\ngoal (1 subgoal):\n 1. \\<not> tableauproof ps p \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat))\n   (Neg p # ps)\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> (\\<stileturn> G)})))\n              from_nat)\n   (Neg p)\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> (\\<stileturn> G)})))\n              from_nat)\n   p", "show False"], ["proof (prove)\nusing this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> (\\<stileturn> G)})))\n                from_nat))\n   (Neg p # ps)\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> (\\<stileturn> G)})))\n              from_nat)\n   (Neg p)\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> (\\<stileturn> G)})))\n              from_nat)\n   p\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Open Formulas\\<close>"], ["", "lemma TC_psubst:\n  fixes f :: \\<open>'a \\<Rightarrow> 'a\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<stileturn> G \\<Longrightarrow> \\<stileturn> map (psubst f) G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> G \\<Longrightarrow> \\<stileturn> map (psubst f) G", "proof (induct G arbitrary: f rule: TC.induct)"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "case (DeltaExists A n G)"], ["proof (state)\nthis:\n  \\<stileturn> A[App n []/0] # G\n  \\<stileturn> map (psubst ?f) (A[App n []/0] # G)\n  news n (A # G)\n\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "let ?params = \\<open>params A \\<union> (\\<Union>p \\<in> set G. params p)\\<close>"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (params A \\<union> \\<Union> (params ` set G))", "by simp"], ["proof (state)\nthis:\n  finite (params A \\<union> \\<Union> (params ` set G))\n\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  finite (params A \\<union> \\<Union> (params ` set G))", "obtain fresh where *: \\<open>fresh \\<notin> ?params \\<union> {n} \\<union> image f ?params\\<close>"], ["proof (prove)\nusing this:\n  finite (params A \\<union> \\<Union> (params ` set G))\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n                 {n} \\<union>\n                 f `\n                 (params A \\<union>\n                  \\<Union> (params ` set G)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_new_if_finite inf_params"], ["proof (prove)\nusing this:\n  finite (params A \\<union> \\<Union> (params ` set G))\n  \\<lbrakk>infinite UNIV; finite ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. a \\<notin> ?A\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n                 {n} \\<union>\n                 f `\n                 (params A \\<union>\n                  \\<Union> (params ` set G)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis finite.emptyI finite.insertI finite_UnI finite_imageI)"], ["proof (state)\nthis:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union> {n} \\<union>\n           f ` (params A \\<union> \\<Union> (params ` set G))\n\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "let ?f = \\<open>f(n := fresh)\\<close>"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "have \\<open>news n (A # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news n (A # G)", "using DeltaExists"], ["proof (prove)\nusing this:\n  \\<stileturn> A[App n []/0] # G\n  \\<stileturn> map (psubst ?f) (A[App n []/0] # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. news n (A # G)", "by blast"], ["proof (state)\nthis:\n  news n (A # G)\n\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  news n (A # G)", "have \\<open>new fresh (psubst ?f A)\\<close> \\<open>news fresh (map (psubst ?f) G)\\<close>"], ["proof (prove)\nusing this:\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. new fresh (psubst (f(n := fresh)) A) &&&\n    news fresh (map (psubst (f(n := fresh))) G)", "using * new_psubst_image news_psubst"], ["proof (prove)\nusing this:\n  news n (A # G)\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union> {n} \\<union>\n           f ` (params A \\<union> \\<Union> (params ` set G))\n  \\<lbrakk>new ?c ?p; ?d \\<notin> ?f ` params ?p\\<rbrakk>\n  \\<Longrightarrow> new ?d (psubst (?f(?c := ?d)) ?p)\n  \\<lbrakk>news ?c ?z; ?d \\<notin> ?f ` \\<Union> (params ` set ?z)\\<rbrakk>\n  \\<Longrightarrow> news ?d (map (psubst (?f(?c := ?d))) ?z)\n\ngoal (1 subgoal):\n 1. new fresh (psubst (f(n := fresh)) A) &&&\n    news fresh (map (psubst (f(n := fresh))) G)", "by (fastforce simp add: image_Un)+"], ["proof (state)\nthis:\n  new fresh (psubst (f(n := fresh)) A)\n  news fresh (map (psubst (f(n := fresh))) G)\n\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  new fresh (psubst (f(n := fresh)) A)\n  news fresh (map (psubst (f(n := fresh))) G)", "have G: \\<open>map (psubst ?f) G = map (psubst f) G\\<close>"], ["proof (prove)\nusing this:\n  new fresh (psubst (f(n := fresh)) A)\n  news fresh (map (psubst (f(n := fresh))) G)\n\ngoal (1 subgoal):\n 1. map (psubst (f(n := fresh))) G = map (psubst f) G", "using DeltaExists"], ["proof (prove)\nusing this:\n  new fresh (psubst (f(n := fresh)) A)\n  news fresh (map (psubst (f(n := fresh))) G)\n  \\<stileturn> A[App n []/0] # G\n  \\<stileturn> map (psubst ?f) (A[App n []/0] # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. map (psubst (f(n := fresh))) G = map (psubst f) G", "by (metis (mono_tags, lifting) Ball_set insertCI list.set(2) map_eq_conv psubst_upd)"], ["proof (state)\nthis:\n  map (psubst (f(n := fresh))) G = map (psubst f) G\n\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "have \\<open>\\<stileturn> psubst ?f (subst A (App n []) 0) # map (psubst ?f) G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> psubst (f(n := fresh)) (A[App n []/0]) #\n                 map (psubst (f(n := fresh))) G", "using DeltaExists"], ["proof (prove)\nusing this:\n  \\<stileturn> A[App n []/0] # G\n  \\<stileturn> map (psubst ?f) (A[App n []/0] # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> psubst (f(n := fresh)) (A[App n []/0]) #\n                 map (psubst (f(n := fresh))) G", "by (metis list.simps(9))"], ["proof (state)\nthis:\n  \\<stileturn> psubst (f(n := fresh)) (A[App n []/0]) #\n               map (psubst (f(n := fresh))) G\n\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> psubst (f(n := fresh)) (A[App n []/0]) #\n               map (psubst (f(n := fresh))) G", "have \\<open>\\<stileturn> subst (psubst ?f A) (App fresh []) 0 # map (psubst ?f) G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> psubst (f(n := fresh)) (A[App n []/0]) #\n               map (psubst (f(n := fresh))) G\n\ngoal (1 subgoal):\n 1. \\<stileturn> psubst (f(n := fresh)) A[App fresh []/0] #\n                 map (psubst (f(n := fresh))) G", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> psubst (f(n := fresh)) A[App fresh []/0] #\n               map (psubst (f(n := fresh))) G\n\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<stileturn> psubst (f(n := fresh)) A[App fresh []/0] #\n               map (psubst (f(n := fresh))) G\n\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "have \\<open>news fresh (map (psubst ?f) (A # G))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news fresh (map (psubst (f(n := fresh))) (A # G))", "using \\<open>new fresh (psubst ?f A)\\<close> \\<open>news fresh (map (psubst ?f) G)\\<close>"], ["proof (prove)\nusing this:\n  new fresh (psubst (f(n := fresh)) A)\n  news fresh (map (psubst (f(n := fresh))) G)\n\ngoal (1 subgoal):\n 1. news fresh (map (psubst (f(n := fresh))) (A # G))", "by simp"], ["proof (state)\nthis:\n  news fresh (map (psubst (f(n := fresh))) (A # G))\n\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  news fresh (map (psubst (f(n := fresh))) (A # G))", "have \\<open>news fresh (psubst ?f A # map (psubst ?f) G)\\<close>"], ["proof (prove)\nusing this:\n  news fresh (map (psubst (f(n := fresh))) (A # G))\n\ngoal (1 subgoal):\n 1. news fresh (psubst (f(n := fresh)) A # map (psubst (f(n := fresh))) G)", "by simp"], ["proof (state)\nthis:\n  news fresh (psubst (f(n := fresh)) A # map (psubst (f(n := fresh))) G)\n\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  \\<stileturn> psubst (f(n := fresh)) A[App fresh []/0] #\n               map (psubst (f(n := fresh))) G\n  news fresh (psubst (f(n := fresh)) A # map (psubst (f(n := fresh))) G)", "have \\<open>\\<stileturn> map (psubst ?f) (Exists A # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> psubst (f(n := fresh)) A[App fresh []/0] #\n               map (psubst (f(n := fresh))) G\n  news fresh (psubst (f(n := fresh)) A # map (psubst (f(n := fresh))) G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst (f(n := fresh))) (Exists A # G)", "using TC.DeltaExists"], ["proof (prove)\nusing this:\n  \\<stileturn> psubst (f(n := fresh)) A[App fresh []/0] #\n               map (psubst (f(n := fresh))) G\n  news fresh (psubst (f(n := fresh)) A # map (psubst (f(n := fresh))) G)\n  \\<lbrakk>\\<stileturn> ?A[App ?n []/0] # ?G; news ?n (?A # ?G)\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> Exists ?A # ?G\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst (f(n := fresh))) (Exists A # G)", "by fastforce"], ["proof (state)\nthis:\n  \\<stileturn> map (psubst (f(n := fresh))) (Exists A # G)\n\ngoal (15 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> map (psubst (f(n := fresh))) (Exists A # G)", "show ?case"], ["proof (prove)\nusing this:\n  \\<stileturn> map (psubst (f(n := fresh))) (Exists A # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst f) (Exists A # G)", "using DeltaExists G"], ["proof (prove)\nusing this:\n  \\<stileturn> map (psubst (f(n := fresh))) (Exists A # G)\n  \\<stileturn> A[App n []/0] # G\n  \\<stileturn> map (psubst ?f) (A[App n []/0] # G)\n  news n (A # G)\n  map (psubst (f(n := fresh))) G = map (psubst f) G\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst f) (Exists A # G)", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> map (psubst f) (Exists A # G)\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "case (DeltaNegForall A n G)"], ["proof (state)\nthis:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<stileturn> map (psubst ?f) (Neg (A[App n []/0]) # G)\n  news n (A # G)\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "let ?params = \\<open>params A \\<union> (\\<Union>p \\<in> set G. params p)\\<close>"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (params A \\<union> \\<Union> (params ` set G))", "by simp"], ["proof (state)\nthis:\n  finite (params A \\<union> \\<Union> (params ` set G))\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  finite (params A \\<union> \\<Union> (params ` set G))", "obtain fresh where *: \\<open>fresh \\<notin> ?params \\<union> {n} \\<union> image f ?params\\<close>"], ["proof (prove)\nusing this:\n  finite (params A \\<union> \\<Union> (params ` set G))\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n                 {n} \\<union>\n                 f `\n                 (params A \\<union>\n                  \\<Union> (params ` set G)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_new_if_finite inf_params"], ["proof (prove)\nusing this:\n  finite (params A \\<union> \\<Union> (params ` set G))\n  \\<lbrakk>infinite UNIV; finite ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. a \\<notin> ?A\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n                 {n} \\<union>\n                 f `\n                 (params A \\<union>\n                  \\<Union> (params ` set G)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis finite.emptyI finite.insertI finite_UnI finite_imageI)"], ["proof (state)\nthis:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union> {n} \\<union>\n           f ` (params A \\<union> \\<Union> (params ` set G))\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "let ?f = \\<open>f(n := fresh)\\<close>"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "have \\<open>news n (A # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news n (A # G)", "using DeltaNegForall"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<stileturn> map (psubst ?f) (Neg (A[App n []/0]) # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. news n (A # G)", "by blast"], ["proof (state)\nthis:\n  news n (A # G)\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  news n (A # G)", "have \\<open>new fresh (psubst ?f A)\\<close> \\<open>news fresh (map (psubst ?f) G)\\<close>"], ["proof (prove)\nusing this:\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. new fresh (psubst (f(n := fresh)) A) &&&\n    news fresh (map (psubst (f(n := fresh))) G)", "using * new_psubst_image news_psubst"], ["proof (prove)\nusing this:\n  news n (A # G)\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union> {n} \\<union>\n           f ` (params A \\<union> \\<Union> (params ` set G))\n  \\<lbrakk>new ?c ?p; ?d \\<notin> ?f ` params ?p\\<rbrakk>\n  \\<Longrightarrow> new ?d (psubst (?f(?c := ?d)) ?p)\n  \\<lbrakk>news ?c ?z; ?d \\<notin> ?f ` \\<Union> (params ` set ?z)\\<rbrakk>\n  \\<Longrightarrow> news ?d (map (psubst (?f(?c := ?d))) ?z)\n\ngoal (1 subgoal):\n 1. new fresh (psubst (f(n := fresh)) A) &&&\n    news fresh (map (psubst (f(n := fresh))) G)", "by (fastforce simp add: image_Un)+"], ["proof (state)\nthis:\n  new fresh (psubst (f(n := fresh)) A)\n  news fresh (map (psubst (f(n := fresh))) G)\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  new fresh (psubst (f(n := fresh)) A)\n  news fresh (map (psubst (f(n := fresh))) G)", "have G: \\<open>map (psubst ?f) G = map (psubst f) G\\<close>"], ["proof (prove)\nusing this:\n  new fresh (psubst (f(n := fresh)) A)\n  news fresh (map (psubst (f(n := fresh))) G)\n\ngoal (1 subgoal):\n 1. map (psubst (f(n := fresh))) G = map (psubst f) G", "using DeltaNegForall"], ["proof (prove)\nusing this:\n  new fresh (psubst (f(n := fresh)) A)\n  news fresh (map (psubst (f(n := fresh))) G)\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<stileturn> map (psubst ?f) (Neg (A[App n []/0]) # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. map (psubst (f(n := fresh))) G = map (psubst f) G", "by (metis (mono_tags, lifting) Ball_set insertCI list.set(2) map_eq_conv psubst_upd)"], ["proof (state)\nthis:\n  map (psubst (f(n := fresh))) G = map (psubst f) G\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "have \\<open>\\<stileturn> psubst ?f (Neg (subst A (App n []) 0)) # map (psubst ?f) G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> psubst (f(n := fresh)) (Neg (A[App n []/0])) #\n                 map (psubst (f(n := fresh))) G", "using DeltaNegForall"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<stileturn> map (psubst ?f) (Neg (A[App n []/0]) # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> psubst (f(n := fresh)) (Neg (A[App n []/0])) #\n                 map (psubst (f(n := fresh))) G", "by (metis list.simps(9))"], ["proof (state)\nthis:\n  \\<stileturn> psubst (f(n := fresh)) (Neg (A[App n []/0])) #\n               map (psubst (f(n := fresh))) G\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> psubst (f(n := fresh)) (Neg (A[App n []/0])) #\n               map (psubst (f(n := fresh))) G", "have \\<open>\\<stileturn> Neg (subst (psubst ?f A) (App fresh []) 0) # map (psubst ?f) G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> psubst (f(n := fresh)) (Neg (A[App n []/0])) #\n               map (psubst (f(n := fresh))) G\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg (psubst (f(n := fresh)) A[App fresh []/0]) #\n                 map (psubst (f(n := fresh))) G", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> Neg (psubst (f(n := fresh)) A[App fresh []/0]) #\n               map (psubst (f(n := fresh))) G\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<stileturn> Neg (psubst (f(n := fresh)) A[App fresh []/0]) #\n               map (psubst (f(n := fresh))) G\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "have \\<open>news fresh (map (psubst ?f) (A # G))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news fresh (map (psubst (f(n := fresh))) (A # G))", "using \\<open>new fresh (psubst ?f A)\\<close> \\<open>news fresh (map (psubst ?f) G)\\<close>"], ["proof (prove)\nusing this:\n  new fresh (psubst (f(n := fresh)) A)\n  news fresh (map (psubst (f(n := fresh))) G)\n\ngoal (1 subgoal):\n 1. news fresh (map (psubst (f(n := fresh))) (A # G))", "by simp"], ["proof (state)\nthis:\n  news fresh (map (psubst (f(n := fresh))) (A # G))\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  news fresh (map (psubst (f(n := fresh))) (A # G))", "have \\<open>news fresh (psubst ?f A # map (psubst ?f) G)\\<close>"], ["proof (prove)\nusing this:\n  news fresh (map (psubst (f(n := fresh))) (A # G))\n\ngoal (1 subgoal):\n 1. news fresh (psubst (f(n := fresh)) A # map (psubst (f(n := fresh))) G)", "by simp"], ["proof (state)\nthis:\n  news fresh (psubst (f(n := fresh)) A # map (psubst (f(n := fresh))) G)\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  \\<stileturn> Neg (psubst (f(n := fresh)) A[App fresh []/0]) #\n               map (psubst (f(n := fresh))) G\n  news fresh (psubst (f(n := fresh)) A # map (psubst (f(n := fresh))) G)", "have \\<open>\\<stileturn> map (psubst ?f) (Neg (Forall A) # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (psubst (f(n := fresh)) A[App fresh []/0]) #\n               map (psubst (f(n := fresh))) G\n  news fresh (psubst (f(n := fresh)) A # map (psubst (f(n := fresh))) G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst (f(n := fresh))) (Neg (Forall A) # G)", "using TC.DeltaNegForall"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (psubst (f(n := fresh)) A[App fresh []/0]) #\n               map (psubst (f(n := fresh))) G\n  news fresh (psubst (f(n := fresh)) A # map (psubst (f(n := fresh))) G)\n  \\<lbrakk>\\<stileturn> Neg (?A[App ?n []/0]) # ?G;\n   news ?n (?A # ?G)\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> Neg (Forall ?A) # ?G\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst (f(n := fresh))) (Neg (Forall A) # G)", "by fastforce"], ["proof (state)\nthis:\n  \\<stileturn> map (psubst (f(n := fresh))) (Neg (Forall A) # G)\n\ngoal (14 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> map (psubst (f(n := fresh))) (Neg (Forall A) # G)", "show ?case"], ["proof (prove)\nusing this:\n  \\<stileturn> map (psubst (f(n := fresh))) (Neg (Forall A) # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst f) (Neg (Forall A) # G)", "using DeltaNegForall G"], ["proof (prove)\nusing this:\n  \\<stileturn> map (psubst (f(n := fresh))) (Neg (Forall A) # G)\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<stileturn> map (psubst ?f) (Neg (A[App n []/0]) # G)\n  news n (A # G)\n  map (psubst (f(n := fresh))) G = map (psubst f) G\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst f) (Neg (Forall A) # G)", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> map (psubst f) (Neg (Forall A) # G)\n\ngoal (13 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 13 subgoals...", "case (Order G G')"], ["proof (state)\nthis:\n  \\<stileturn> G\n  \\<stileturn> map (psubst ?f) G\n  set G = set G'\n\ngoal (13 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> G\n  \\<stileturn> map (psubst ?f) G\n  set G = set G'", "show ?case"], ["proof (prove)\nusing this:\n  \\<stileturn> G\n  \\<stileturn> map (psubst ?f) G\n  set G = set G'\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst f) G'", "using Order TC.Order set_map"], ["proof (prove)\nusing this:\n  \\<stileturn> G\n  \\<stileturn> map (psubst ?f) G\n  set G = set G'\n  \\<stileturn> G\n  \\<stileturn> map (psubst ?f) G\n  set G = set G'\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst f) G'", "by metis"], ["proof (state)\nthis:\n  \\<stileturn> map (psubst f) G'\n\ngoal (12 subgoals):\n 1. \\<And>i l G f.\n       \\<stileturn> map (psubst f) (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G f. \\<stileturn> map (psubst f) (\\<bottom> # G)\n 3. \\<And>G f. \\<stileturn> map (psubst f) (Neg \\<top> # G)\n 4. \\<And>A G f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Neg A) # G)\n 5. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (And A B # G)\n 6. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Or A B) # G)\n 7. \\<And>A B G f.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (Impl A B) # G)\n 8. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Neg (And A B) # G)\n 9. \\<And>A G B f.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>f. \\<stileturn> map (psubst f) (A # G); \\<stileturn> B # G;\n        \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map (psubst f) (Or A B # G)\n 10. \\<And>A G B f.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>f. \\<stileturn> map (psubst f) (Neg A # G);\n         \\<stileturn> B # G;\n         \\<And>f. \\<stileturn> map (psubst f) (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> map (psubst f) (Impl A B # G)\nA total of 12 subgoals...", "qed (auto intro: TC.intros)"], ["", "lemma subcs_map: \\<open>subcs c s G = map (subc c s) G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcs c s G = map (subc c s) G", "by (induct G) simp_all"], ["", "lemma TC_subcs:\n  fixes G :: \\<open>('a, 'b) form list\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<stileturn> G \\<Longrightarrow> \\<stileturn> subcs c s G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> G \\<Longrightarrow> \\<stileturn> subcs c s G", "proof (induct G arbitrary: c s rule: TC.induct)"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "case (GammaForall A t G)"], ["proof (state)\nthis:\n  \\<stileturn> A[t/0] # G\n  \\<stileturn> subcs ?c ?s (A[t/0] # G)\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "let ?params = \\<open>params A \\<union> (\\<Union>p \\<in> set G. params p) \\<union> paramst s \\<union> paramst t \\<union> {c}\\<close>"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (params A \\<union> \\<Union> (params ` set G) \\<union>\n      paramst s \\<union>\n      paramst t \\<union>\n      {c})", "by simp"], ["proof (state)\nthis:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})", "obtain fresh where fresh: \\<open>fresh \\<notin> ?params\\<close>"], ["proof (prove)\nusing this:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n                 paramst s \\<union>\n                 paramst t \\<union>\n                 {c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_new_if_finite inf_params"], ["proof (prove)\nusing this:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})\n  \\<lbrakk>infinite UNIV; finite ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. a \\<notin> ?A\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n                 paramst s \\<union>\n                 paramst t \\<union>\n                 {c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "let ?f = \\<open>id(c := fresh)\\<close>"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "let ?g = \\<open>id(fresh := c)\\<close>"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "let ?s = \\<open>psubstt ?f s\\<close>"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "have s: \\<open>psubstt ?g ?s = s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s", "using fresh psubst_new_away'"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n  new_term ?fresh ?t \\<Longrightarrow>\n  psubstt (id(?fresh := ?c)) (psubstt (id(?c := ?fresh)) ?t) = ?t\n  new_list ?fresh ?l \\<Longrightarrow>\n  psubstts (id(?fresh := ?c)) (psubstts (id(?c := ?fresh)) ?l) = ?l\n\ngoal (1 subgoal):\n 1. psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s", "by simp"], ["proof (state)\nthis:\n  psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "have \\<open>subc (?g c) (psubstt ?g ?s) (psubst ?g (Forall A)) = subc c s (Forall A)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subc ((id(fresh := c)) c)\n     (psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s))\n     (psubst (id(fresh := c)) (Forall A)) =\n    subc c s (Forall A)", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. subc ((id(fresh := c)) c)\n     (psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s))\n     (psubst (id(fresh := c)) (Forall A)) =\n    subc c s (Forall A)", "by simp"], ["proof (state)\nthis:\n  subc ((id(fresh := c)) c)\n   (psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s))\n   (psubst (id(fresh := c)) (Forall A)) =\n  subc c s (Forall A)\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  subc ((id(fresh := c)) c)\n   (psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s))\n   (psubst (id(fresh := c)) (Forall A)) =\n  subc c s (Forall A)", "have A: \\<open>psubst ?g (subc c ?s (Forall A)) = subc c s (Forall A)\\<close>"], ["proof (prove)\nusing this:\n  subc ((id(fresh := c)) c)\n   (psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s))\n   (psubst (id(fresh := c)) (Forall A)) =\n  subc c s (Forall A)\n\ngoal (1 subgoal):\n 1. psubst (id(fresh := c))\n     (subc c (psubstt (id(c := fresh)) s) (Forall A)) =\n    subc c s (Forall A)", "using fun_upd_apply id_def subc_psubst UnCI fresh params.simps(8)"], ["proof (prove)\nusing this:\n  subc ((id(fresh := c)) c)\n   (psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s))\n   (psubst (id(fresh := c)) (Forall A)) =\n  subc c s (Forall A)\n  (?f(?x := ?y)) ?z = (if ?z = ?x then ?y else ?f ?z)\n  id = (\\<lambda>x. x)\n  \\<forall>x\\<in>params ?p.\n     x \\<noteq> ?c \\<longrightarrow> ?f x \\<noteq> ?f ?c \\<Longrightarrow>\n  psubst ?f (subc ?c ?s ?p) = subc (?f ?c) (psubstt ?f ?s) (psubst ?f ?p)\n  (?c \\<notin> ?B \\<Longrightarrow> ?c \\<in> ?A) \\<Longrightarrow>\n  ?c \\<in> ?A \\<union> ?B\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n  params (Forall ?p) = params ?p\n\ngoal (1 subgoal):\n 1. psubst (id(fresh := c))\n     (subc c (psubstt (id(c := fresh)) s) (Forall A)) =\n    subc c s (Forall A)", "by metis"], ["proof (state)\nthis:\n  psubst (id(fresh := c)) (subc c (psubstt (id(c := fresh)) s) (Forall A)) =\n  subc c s (Forall A)\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "have \\<open>\\<forall>x \\<in> (\\<Union>p \\<in> set (Forall A # G). params p). x \\<noteq> c \\<longrightarrow> ?g x \\<noteq> ?g c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (params ` set (Forall A # G)).\n       x \\<noteq> c \\<longrightarrow>\n       (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (params ` set (Forall A # G)).\n       x \\<noteq> c \\<longrightarrow>\n       (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<Union> (params ` set (Forall A # G)).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<Union> (params ` set (Forall A # G)).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "have \\<open>map (psubst ?g) (Forall A # G) = Forall A # G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) (Forall A # G) = Forall A # G", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) (Forall A # G) = Forall A # G", "by (induct G) simp_all"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c))) (Forall A # G) = Forall A # G\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>\\<Union> (params ` set (Forall A # G)).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  map (psubst (id(fresh := c))) (Forall A # G) = Forall A # G", "have G: \\<open>map (psubst ?g) (subcs c ?s (Forall A # G)) = subcs c s (Forall A # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<Union> (params ` set (Forall A # G)).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  map (psubst (id(fresh := c))) (Forall A # G) = Forall A # G\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c)))\n     (subcs c (psubstt (id(c := fresh)) s) (Forall A # G)) =\n    subcs c s (Forall A # G)", "using s A"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<Union> (params ` set (Forall A # G)).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  map (psubst (id(fresh := c))) (Forall A # G) = Forall A # G\n  psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s\n  psubst (id(fresh := c)) (subc c (psubstt (id(c := fresh)) s) (Forall A)) =\n  subc c s (Forall A)\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c)))\n     (subcs c (psubstt (id(c := fresh)) s) (Forall A # G)) =\n    subcs c s (Forall A # G)", "by (simp add: subcs_psubst)"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s) (Forall A # G)) =\n  subcs c s (Forall A # G)\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "have \\<open>new_term c ?s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term c (psubstt (id(c := fresh)) s)", "using fresh psubst_new_free'"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n  ?c \\<noteq> ?n \\<Longrightarrow> new_term ?n (psubstt (id(?n := ?c)) ?t)\n  ?c \\<noteq> ?n \\<Longrightarrow> new_list ?n (psubstts (id(?n := ?c)) ?l)\n\ngoal (1 subgoal):\n 1. new_term c (psubstt (id(c := fresh)) s)", "by fast"], ["proof (state)\nthis:\n  new_term c (psubstt (id(c := fresh)) s)\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  new_term c (psubstt (id(c := fresh)) s)", "have \\<open>\\<stileturn> subc c ?s (subst A (subc_term c ?s t) 0) # subcs c ?s G\\<close>"], ["proof (prove)\nusing this:\n  new_term c (psubstt (id(c := fresh)) s)\n\ngoal (1 subgoal):\n 1. \\<stileturn> subc c (psubstt (id(c := fresh)) s)\n                  (A[subc_term c (psubstt (id(c := fresh)) s) t/0]) #\n                 subcs c (psubstt (id(c := fresh)) s) G", "using GammaForall"], ["proof (prove)\nusing this:\n  new_term c (psubstt (id(c := fresh)) s)\n  \\<stileturn> A[t/0] # G\n  \\<stileturn> subcs ?c ?s (A[t/0] # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> subc c (psubstt (id(c := fresh)) s)\n                  (A[subc_term c (psubstt (id(c := fresh)) s) t/0]) #\n                 subcs c (psubstt (id(c := fresh)) s) G", "by (metis new_subc_put subcs.simps(2))"], ["proof (state)\nthis:\n  \\<stileturn> subc c (psubstt (id(c := fresh)) s)\n                (A[subc_term c (psubstt (id(c := fresh)) s) t/0]) #\n               subcs c (psubstt (id(c := fresh)) s) G\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<stileturn> subc c (psubstt (id(c := fresh)) s)\n                (A[subc_term c (psubstt (id(c := fresh)) s) t/0]) #\n               subcs c (psubstt (id(c := fresh)) s) G\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "have \\<open>new_term c (subc_term c ?s t)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term c (subc_term c (psubstt (id(c := fresh)) s) t)", "using \\<open>new_term c ?s\\<close> new_subc_same'"], ["proof (prove)\nusing this:\n  new_term c (psubstt (id(c := fresh)) s)\n  new_term ?c ?s \\<Longrightarrow> new_term ?c (subc_term ?c ?s ?t)\n  new_term ?c ?s \\<Longrightarrow> new_list ?c (subc_list ?c ?s ?l)\n\ngoal (1 subgoal):\n 1. new_term c (subc_term c (psubstt (id(c := fresh)) s) t)", "by simp"], ["proof (state)\nthis:\n  new_term c (subc_term c (psubstt (id(c := fresh)) s) t)\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  \\<stileturn> subc c (psubstt (id(c := fresh)) s)\n                (A[subc_term c (psubstt (id(c := fresh)) s) t/0]) #\n               subcs c (psubstt (id(c := fresh)) s) G\n  new_term c (subc_term c (psubstt (id(c := fresh)) s) t)", "have \\<open>\\<stileturn> subst (subc c (liftt ?s) A) (subc_term c ?s t) 0 # subcs c ?s G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> subc c (psubstt (id(c := fresh)) s)\n                (A[subc_term c (psubstt (id(c := fresh)) s) t/0]) #\n               subcs c (psubstt (id(c := fresh)) s) G\n  new_term c (subc_term c (psubstt (id(c := fresh)) s) t)\n\ngoal (1 subgoal):\n 1. \\<stileturn> subc c (liftt (psubstt (id(c := fresh)) s))\n                  A[subc_term c (psubstt (id(c := fresh)) s) t/0] #\n                 subcs c (psubstt (id(c := fresh)) s) G", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> subc c (liftt (psubstt (id(c := fresh)) s))\n                A[subc_term c (psubstt (id(c := fresh)) s) t/0] #\n               subcs c (psubstt (id(c := fresh)) s) G\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<stileturn> subc c (liftt (psubstt (id(c := fresh)) s))\n                A[subc_term c (psubstt (id(c := fresh)) s) t/0] #\n               subcs c (psubstt (id(c := fresh)) s) G\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "have \\<open>Forall (subc c (liftt ?s) A) \\<in> set (subcs c ?s (Forall A # G))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Forall (subc c (liftt (psubstt (id(c := fresh)) s)) A)\n    \\<in> set (subcs c (psubstt (id(c := fresh)) s) (Forall A # G))", "by simp"], ["proof (state)\nthis:\n  Forall (subc c (liftt (psubstt (id(c := fresh)) s)) A)\n  \\<in> set (subcs c (psubstt (id(c := fresh)) s) (Forall A # G))\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  \\<stileturn> subc c (liftt (psubstt (id(c := fresh)) s))\n                A[subc_term c (psubstt (id(c := fresh)) s) t/0] #\n               subcs c (psubstt (id(c := fresh)) s) G\n  Forall (subc c (liftt (psubstt (id(c := fresh)) s)) A)\n  \\<in> set (subcs c (psubstt (id(c := fresh)) s) (Forall A # G))", "have \\<open>\\<stileturn> subcs c ?s (Forall A # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> subc c (liftt (psubstt (id(c := fresh)) s))\n                A[subc_term c (psubstt (id(c := fresh)) s) t/0] #\n               subcs c (psubstt (id(c := fresh)) s) G\n  Forall (subc c (liftt (psubstt (id(c := fresh)) s)) A)\n  \\<in> set (subcs c (psubstt (id(c := fresh)) s) (Forall A # G))\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c (psubstt (id(c := fresh)) s) (Forall A # G)", "using TC.GammaForall"], ["proof (prove)\nusing this:\n  \\<stileturn> subc c (liftt (psubstt (id(c := fresh)) s))\n                A[subc_term c (psubstt (id(c := fresh)) s) t/0] #\n               subcs c (psubstt (id(c := fresh)) s) G\n  Forall (subc c (liftt (psubstt (id(c := fresh)) s)) A)\n  \\<in> set (subcs c (psubstt (id(c := fresh)) s) (Forall A # G))\n  \\<stileturn> ?A[?t/0] # ?G \\<Longrightarrow> \\<stileturn> Forall ?A # ?G\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c (psubstt (id(c := fresh)) s) (Forall A # G)", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> subcs c (psubstt (id(c := fresh)) s) (Forall A # G)\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> subcs c (psubstt (id(c := fresh)) s) (Forall A # G)", "have \\<open>\\<stileturn> map (psubst ?g) (subcs c ?s (Forall A # G))\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> subcs c (psubstt (id(c := fresh)) s) (Forall A # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst (id(fresh := c)))\n                  (subcs c (psubstt (id(c := fresh)) s) (Forall A # G))", "using TC_psubst inf_params"], ["proof (prove)\nusing this:\n  \\<stileturn> subcs c (psubstt (id(c := fresh)) s) (Forall A # G)\n  \\<lbrakk>infinite UNIV; \\<stileturn> ?G\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> map (psubst ?f) ?G\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst (id(fresh := c)))\n                  (subcs c (psubstt (id(c := fresh)) s) (Forall A # G))", "by blast"], ["proof (state)\nthis:\n  \\<stileturn> map (psubst (id(fresh := c)))\n                (subcs c (psubstt (id(c := fresh)) s) (Forall A # G))\n\ngoal (15 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> map (psubst (id(fresh := c)))\n                (subcs c (psubstt (id(c := fresh)) s) (Forall A # G))", "show \\<open>\\<stileturn> subcs c s (Forall A # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> map (psubst (id(fresh := c)))\n                (subcs c (psubstt (id(c := fresh)) s) (Forall A # G))\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s (Forall A # G)", "using G"], ["proof (prove)\nusing this:\n  \\<stileturn> map (psubst (id(fresh := c)))\n                (subcs c (psubstt (id(c := fresh)) s) (Forall A # G))\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s) (Forall A # G)) =\n  subcs c s (Forall A # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s (Forall A # G)", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> subcs c s (Forall A # G)\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "case (GammaNegExists A t G)"], ["proof (state)\nthis:\n  \\<stileturn> Neg (A[t/0]) # G\n  \\<stileturn> subcs ?c ?s (Neg (A[t/0]) # G)\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "let ?params = \\<open>params A \\<union> (\\<Union>p \\<in> set G. params p) \\<union> paramst s \\<union> paramst t \\<union> {c}\\<close>"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (params A \\<union> \\<Union> (params ` set G) \\<union>\n      paramst s \\<union>\n      paramst t \\<union>\n      {c})", "by simp"], ["proof (state)\nthis:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})", "obtain fresh where fresh: \\<open>fresh \\<notin> ?params\\<close>"], ["proof (prove)\nusing this:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n                 paramst s \\<union>\n                 paramst t \\<union>\n                 {c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_new_if_finite inf_params"], ["proof (prove)\nusing this:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})\n  \\<lbrakk>infinite UNIV; finite ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. a \\<notin> ?A\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n                 paramst s \\<union>\n                 paramst t \\<union>\n                 {c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "let ?f = \\<open>id(c := fresh)\\<close>"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "let ?g = \\<open>id(fresh := c)\\<close>"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "let ?s = \\<open>psubstt ?f s\\<close>"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "have s: \\<open>psubstt ?g ?s = s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s", "using fresh psubst_new_away'"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n  new_term ?fresh ?t \\<Longrightarrow>\n  psubstt (id(?fresh := ?c)) (psubstt (id(?c := ?fresh)) ?t) = ?t\n  new_list ?fresh ?l \\<Longrightarrow>\n  psubstts (id(?fresh := ?c)) (psubstts (id(?c := ?fresh)) ?l) = ?l\n\ngoal (1 subgoal):\n 1. psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s", "by simp"], ["proof (state)\nthis:\n  psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "have \\<open>subc (?g c) (psubstt ?g ?s) (psubst ?g (Neg (Exists A))) = subc c s (Neg (Exists A))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subc ((id(fresh := c)) c)\n     (psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s))\n     (psubst (id(fresh := c)) (Neg (Exists A))) =\n    subc c s (Neg (Exists A))", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. subc ((id(fresh := c)) c)\n     (psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s))\n     (psubst (id(fresh := c)) (Neg (Exists A))) =\n    subc c s (Neg (Exists A))", "by simp"], ["proof (state)\nthis:\n  subc ((id(fresh := c)) c)\n   (psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s))\n   (psubst (id(fresh := c)) (Neg (Exists A))) =\n  subc c s (Neg (Exists A))\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  subc ((id(fresh := c)) c)\n   (psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s))\n   (psubst (id(fresh := c)) (Neg (Exists A))) =\n  subc c s (Neg (Exists A))", "have A: \\<open>psubst ?g (subc c ?s (Neg (Exists A))) = subc c s (Neg (Exists A))\\<close>"], ["proof (prove)\nusing this:\n  subc ((id(fresh := c)) c)\n   (psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s))\n   (psubst (id(fresh := c)) (Neg (Exists A))) =\n  subc c s (Neg (Exists A))\n\ngoal (1 subgoal):\n 1. psubst (id(fresh := c))\n     (subc c (psubstt (id(c := fresh)) s) (Neg (Exists A))) =\n    subc c s (Neg (Exists A))", "using fun_upd_apply id_def subc_psubst UnCI fresh params.simps(7,9)"], ["proof (prove)\nusing this:\n  subc ((id(fresh := c)) c)\n   (psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s))\n   (psubst (id(fresh := c)) (Neg (Exists A))) =\n  subc c s (Neg (Exists A))\n  (?f(?x := ?y)) ?z = (if ?z = ?x then ?y else ?f ?z)\n  id = (\\<lambda>x. x)\n  \\<forall>x\\<in>params ?p.\n     x \\<noteq> ?c \\<longrightarrow> ?f x \\<noteq> ?f ?c \\<Longrightarrow>\n  psubst ?f (subc ?c ?s ?p) = subc (?f ?c) (psubstt ?f ?s) (psubst ?f ?p)\n  (?c \\<notin> ?B \\<Longrightarrow> ?c \\<in> ?A) \\<Longrightarrow>\n  ?c \\<in> ?A \\<union> ?B\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n  params (Neg ?p) = params ?p\n  params (Exists ?p) = params ?p\n\ngoal (1 subgoal):\n 1. psubst (id(fresh := c))\n     (subc c (psubstt (id(c := fresh)) s) (Neg (Exists A))) =\n    subc c s (Neg (Exists A))", "by metis"], ["proof (state)\nthis:\n  psubst (id(fresh := c))\n   (subc c (psubstt (id(c := fresh)) s) (Neg (Exists A))) =\n  subc c s (Neg (Exists A))\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "have \\<open>\\<forall>x \\<in> (\\<Union>p \\<in> set (Neg (Exists A) # G). params p). x \\<noteq> c \\<longrightarrow> ?g x \\<noteq> ?g c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (params ` set (Neg (Exists A) # G)).\n       x \\<noteq> c \\<longrightarrow>\n       (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (params ` set (Neg (Exists A) # G)).\n       x \\<noteq> c \\<longrightarrow>\n       (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<Union> (params ` set (Neg (Exists A) # G)).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<Union> (params ` set (Neg (Exists A) # G)).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "have \\<open>map (psubst ?g) (Neg (Exists A) # G) = Neg (Exists A) # G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) (Neg (Exists A) # G) = Neg (Exists A) # G", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) (Neg (Exists A) # G) = Neg (Exists A) # G", "by (induct G) simp_all"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c))) (Neg (Exists A) # G) = Neg (Exists A) # G\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>\\<Union> (params ` set (Neg (Exists A) # G)).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  map (psubst (id(fresh := c))) (Neg (Exists A) # G) = Neg (Exists A) # G", "have G: \\<open>map (psubst ?g) (subcs c ?s (Neg (Exists A) # G)) =\n      subcs c s (Neg (Exists A) # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<Union> (params ` set (Neg (Exists A) # G)).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  map (psubst (id(fresh := c))) (Neg (Exists A) # G) = Neg (Exists A) # G\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c)))\n     (subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G)) =\n    subcs c s (Neg (Exists A) # G)", "using s A"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<Union> (params ` set (Neg (Exists A) # G)).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  map (psubst (id(fresh := c))) (Neg (Exists A) # G) = Neg (Exists A) # G\n  psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s\n  psubst (id(fresh := c))\n   (subc c (psubstt (id(c := fresh)) s) (Neg (Exists A))) =\n  subc c s (Neg (Exists A))\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c)))\n     (subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G)) =\n    subcs c s (Neg (Exists A) # G)", "by (simp add: subcs_psubst)"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G)) =\n  subcs c s (Neg (Exists A) # G)\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "have \\<open>new_term c ?s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term c (psubstt (id(c := fresh)) s)", "using fresh psubst_new_free'"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n  ?c \\<noteq> ?n \\<Longrightarrow> new_term ?n (psubstt (id(?n := ?c)) ?t)\n  ?c \\<noteq> ?n \\<Longrightarrow> new_list ?n (psubstts (id(?n := ?c)) ?l)\n\ngoal (1 subgoal):\n 1. new_term c (psubstt (id(c := fresh)) s)", "by fast"], ["proof (state)\nthis:\n  new_term c (psubstt (id(c := fresh)) s)\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  new_term c (psubstt (id(c := fresh)) s)", "have \\<open>\\<stileturn> Neg (subc c ?s (subst A (subc_term c ?s t) 0)) # subcs c ?s G\\<close>"], ["proof (prove)\nusing this:\n  new_term c (psubstt (id(c := fresh)) s)\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg (subc c (psubstt (id(c := fresh)) s)\n                       (A[subc_term c (psubstt (id(c := fresh)) s) t/0])) #\n                 subcs c (psubstt (id(c := fresh)) s) G", "using GammaNegExists"], ["proof (prove)\nusing this:\n  new_term c (psubstt (id(c := fresh)) s)\n  \\<stileturn> Neg (A[t/0]) # G\n  \\<stileturn> subcs ?c ?s (Neg (A[t/0]) # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg (subc c (psubstt (id(c := fresh)) s)\n                       (A[subc_term c (psubstt (id(c := fresh)) s) t/0])) #\n                 subcs c (psubstt (id(c := fresh)) s) G", "by (metis new_subc_put subc.simps(4) subcs.simps(2))"], ["proof (state)\nthis:\n  \\<stileturn> Neg (subc c (psubstt (id(c := fresh)) s)\n                     (A[subc_term c (psubstt (id(c := fresh)) s) t/0])) #\n               subcs c (psubstt (id(c := fresh)) s) G\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<stileturn> Neg (subc c (psubstt (id(c := fresh)) s)\n                     (A[subc_term c (psubstt (id(c := fresh)) s) t/0])) #\n               subcs c (psubstt (id(c := fresh)) s) G\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "have \\<open>new_term c (subc_term c ?s t)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term c (subc_term c (psubstt (id(c := fresh)) s) t)", "using \\<open>new_term c ?s\\<close> new_subc_same'"], ["proof (prove)\nusing this:\n  new_term c (psubstt (id(c := fresh)) s)\n  new_term ?c ?s \\<Longrightarrow> new_term ?c (subc_term ?c ?s ?t)\n  new_term ?c ?s \\<Longrightarrow> new_list ?c (subc_list ?c ?s ?l)\n\ngoal (1 subgoal):\n 1. new_term c (subc_term c (psubstt (id(c := fresh)) s) t)", "by simp"], ["proof (state)\nthis:\n  new_term c (subc_term c (psubstt (id(c := fresh)) s) t)\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  \\<stileturn> Neg (subc c (psubstt (id(c := fresh)) s)\n                     (A[subc_term c (psubstt (id(c := fresh)) s) t/0])) #\n               subcs c (psubstt (id(c := fresh)) s) G\n  new_term c (subc_term c (psubstt (id(c := fresh)) s) t)", "have \\<open>\\<stileturn> Neg (subst (subc c (liftt ?s) A) (subc_term c ?s t) 0) # subcs c ?s G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (subc c (psubstt (id(c := fresh)) s)\n                     (A[subc_term c (psubstt (id(c := fresh)) s) t/0])) #\n               subcs c (psubstt (id(c := fresh)) s) G\n  new_term c (subc_term c (psubstt (id(c := fresh)) s) t)\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg (subc c (liftt (psubstt (id(c := fresh)) s))\n                       A[subc_term c (psubstt (id(c := fresh)) s) t/0]) #\n                 subcs c (psubstt (id(c := fresh)) s) G", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> Neg (subc c (liftt (psubstt (id(c := fresh)) s))\n                     A[subc_term c (psubstt (id(c := fresh)) s) t/0]) #\n               subcs c (psubstt (id(c := fresh)) s) G\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<stileturn> Neg (subc c (liftt (psubstt (id(c := fresh)) s))\n                     A[subc_term c (psubstt (id(c := fresh)) s) t/0]) #\n               subcs c (psubstt (id(c := fresh)) s) G\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "have \\<open>Neg (Exists (subc c (liftt ?s) A)) \\<in> set (subcs c ?s (Neg (Exists A) # G))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg (Exists (subc c (liftt (psubstt (id(c := fresh)) s)) A))\n    \\<in> set (subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G))", "by simp"], ["proof (state)\nthis:\n  Neg (Exists (subc c (liftt (psubstt (id(c := fresh)) s)) A))\n  \\<in> set (subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G))\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  \\<stileturn> Neg (subc c (liftt (psubstt (id(c := fresh)) s))\n                     A[subc_term c (psubstt (id(c := fresh)) s) t/0]) #\n               subcs c (psubstt (id(c := fresh)) s) G\n  Neg (Exists (subc c (liftt (psubstt (id(c := fresh)) s)) A))\n  \\<in> set (subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G))", "have \\<open>\\<stileturn> subcs c ?s (Neg (Exists A) # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (subc c (liftt (psubstt (id(c := fresh)) s))\n                     A[subc_term c (psubstt (id(c := fresh)) s) t/0]) #\n               subcs c (psubstt (id(c := fresh)) s) G\n  Neg (Exists (subc c (liftt (psubstt (id(c := fresh)) s)) A))\n  \\<in> set (subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G))\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G)", "using TC.GammaNegExists"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (subc c (liftt (psubstt (id(c := fresh)) s))\n                     A[subc_term c (psubstt (id(c := fresh)) s) t/0]) #\n               subcs c (psubstt (id(c := fresh)) s) G\n  Neg (Exists (subc c (liftt (psubstt (id(c := fresh)) s)) A))\n  \\<in> set (subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G))\n  \\<stileturn> Neg (?A[?t/0]) # ?G \\<Longrightarrow>\n  \\<stileturn> Neg (Exists ?A) # ?G\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G)", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G)\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G)", "have \\<open>\\<stileturn> map (psubst ?g) (subcs c ?s (Neg (Exists A) # G))\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst (id(fresh := c)))\n                  (subcs c (psubstt (id(c := fresh)) s)\n                    (Neg (Exists A) # G))", "using TC_psubst inf_params"], ["proof (prove)\nusing this:\n  \\<stileturn> subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G)\n  \\<lbrakk>infinite UNIV; \\<stileturn> ?G\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> map (psubst ?f) ?G\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (psubst (id(fresh := c)))\n                  (subcs c (psubstt (id(c := fresh)) s)\n                    (Neg (Exists A) # G))", "by blast"], ["proof (state)\nthis:\n  \\<stileturn> map (psubst (id(fresh := c)))\n                (subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G))\n\ngoal (14 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> map (psubst (id(fresh := c)))\n                (subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G))", "show \\<open>\\<stileturn> subcs c s (Neg (Exists A) # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> map (psubst (id(fresh := c)))\n                (subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G))\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s (Neg (Exists A) # G)", "using G"], ["proof (prove)\nusing this:\n  \\<stileturn> map (psubst (id(fresh := c)))\n                (subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G))\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s) (Neg (Exists A) # G)) =\n  subcs c s (Neg (Exists A) # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s (Neg (Exists A) # G)", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> subcs c s (Neg (Exists A) # G)\n\ngoal (13 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 13 subgoals...", "case (DeltaExists A n G)"], ["proof (state)\nthis:\n  \\<stileturn> A[App n []/0] # G\n  \\<stileturn> subcs ?c ?s (A[App n []/0] # G)\n  news n (A # G)\n\ngoal (13 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> A[App n []/0] # G\n  \\<stileturn> subcs ?c ?s (A[App n []/0] # G)\n  news n (A # G)", "show ?case"], ["proof (prove)\nusing this:\n  \\<stileturn> A[App n []/0] # G\n  \\<stileturn> subcs ?c ?s (A[App n []/0] # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s (Exists A # G)", "proof (cases \\<open>c = n\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c = n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)\n 2. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "case True"], ["proof (state)\nthis:\n  c = n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c = n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)\n 2. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "then"], ["proof (chain)\npicking this:\n  c = n", "have \\<open>\\<stileturn> Exists A # G\\<close>"], ["proof (prove)\nusing this:\n  c = n\n\ngoal (1 subgoal):\n 1. \\<stileturn> Exists A # G", "using DeltaExists TC.DeltaExists"], ["proof (prove)\nusing this:\n  c = n\n  \\<stileturn> A[App n []/0] # G\n  \\<stileturn> subcs ?c ?s (A[App n []/0] # G)\n  news n (A # G)\n  \\<lbrakk>\\<stileturn> ?A[App ?n []/0] # ?G; news ?n (?A # ?G)\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> Exists ?A # ?G\n\ngoal (1 subgoal):\n 1. \\<stileturn> Exists A # G", "by metis"], ["proof (state)\nthis:\n  \\<stileturn> Exists A # G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c = n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)\n 2. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "moreover"], ["proof (state)\nthis:\n  \\<stileturn> Exists A # G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c = n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)\n 2. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have \\<open>new c A\\<close> and \\<open>news c G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new c A &&& news c G", "using DeltaExists True"], ["proof (prove)\nusing this:\n  \\<stileturn> A[App n []/0] # G\n  \\<stileturn> subcs ?c ?s (A[App n []/0] # G)\n  news n (A # G)\n  c = n\n\ngoal (1 subgoal):\n 1. new c A &&& news c G", "by simp_all"], ["proof (state)\nthis:\n  new c A\n  news c G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c = n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)\n 2. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "ultimately"], ["proof (chain)\npicking this:\n  \\<stileturn> Exists A # G\n  new c A\n  news c G", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<stileturn> Exists A # G\n  new c A\n  news c G\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s (Exists A # G)", "by (simp add: subcs_news)"], ["proof (state)\nthis:\n  \\<stileturn> subcs c s (Exists A # G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "case False"], ["proof (state)\nthis:\n  c \\<noteq> n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "let ?params = \\<open>params A \\<union> (\\<Union>p \\<in> set G. params p) \\<union> paramst s \\<union> {c} \\<union> {n}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (params A \\<union> \\<Union> (params ` set G) \\<union>\n      paramst s \\<union>\n      {c} \\<union>\n      {n})", "by simp"], ["proof (state)\nthis:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    {c} \\<union>\n    {n})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "then"], ["proof (chain)\npicking this:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    {c} \\<union>\n    {n})", "obtain fresh where fresh: \\<open>fresh \\<notin> ?params\\<close>"], ["proof (prove)\nusing this:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    {c} \\<union>\n    {n})\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {n} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_new_if_finite inf_params"], ["proof (prove)\nusing this:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    {c} \\<union>\n    {n})\n  \\<lbrakk>infinite UNIV; finite ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. a \\<notin> ?A\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {n} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "let ?s = \\<open>psubstt (id(n := fresh)) s\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "let ?f = \\<open>id(n := fresh, fresh := n)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have f: \\<open>\\<forall>x \\<in> ?params. x \\<noteq> c \\<longrightarrow> ?f x \\<noteq> ?f c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params A \\<union> \\<Union> (params ` set G) \\<union>\n                   paramst s \\<union>\n                   {c} \\<union>\n                   {n}.\n       x \\<noteq> c \\<longrightarrow>\n       (id(n := fresh, fresh := n)) x \\<noteq>\n       (id(n := fresh, fresh := n)) c", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params A \\<union> \\<Union> (params ` set G) \\<union>\n                   paramst s \\<union>\n                   {c} \\<union>\n                   {n}.\n       x \\<noteq> c \\<longrightarrow>\n       (id(n := fresh, fresh := n)) x \\<noteq>\n       (id(n := fresh, fresh := n)) c", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>params A \\<union> \\<Union> (params ` set G) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {n}.\n     x \\<noteq> c \\<longrightarrow>\n     (id(n := fresh, fresh := n)) x \\<noteq> (id(n := fresh, fresh := n)) c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have \\<open>new_term n ?s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term n (psubstt (id(n := fresh)) s)", "using fresh psubst_new_free'"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n  ?c \\<noteq> ?n \\<Longrightarrow> new_term ?n (psubstt (id(?n := ?c)) ?t)\n  ?c \\<noteq> ?n \\<Longrightarrow> new_list ?n (psubstts (id(?n := ?c)) ?l)\n\ngoal (1 subgoal):\n 1. new_term n (psubstt (id(n := fresh)) s)", "by fast"], ["proof (state)\nthis:\n  new_term n (psubstt (id(n := fresh)) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "then"], ["proof (chain)\npicking this:\n  new_term n (psubstt (id(n := fresh)) s)", "have \\<open>psubstt ?f ?s = psubstt (id(fresh := n)) ?s\\<close>"], ["proof (prove)\nusing this:\n  new_term n (psubstt (id(n := fresh)) s)\n\ngoal (1 subgoal):\n 1. psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) =\n    psubstt (id(fresh := n)) (psubstt (id(n := fresh)) s)", "by (metis fun_upd_twist psubstt_upd(1))"], ["proof (state)\nthis:\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) =\n  psubstt (id(fresh := n)) (psubstt (id(n := fresh)) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "then"], ["proof (chain)\npicking this:\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) =\n  psubstt (id(fresh := n)) (psubstt (id(n := fresh)) s)", "have psubst_s: \\<open>psubstt ?f ?s = s\\<close>"], ["proof (prove)\nusing this:\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) =\n  psubstt (id(fresh := n)) (psubstt (id(n := fresh)) s)\n\ngoal (1 subgoal):\n 1. psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) = s", "using fresh psubst_new_away'"], ["proof (prove)\nusing this:\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) =\n  psubstt (id(fresh := n)) (psubstt (id(n := fresh)) s)\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n  new_term ?fresh ?t \\<Longrightarrow>\n  psubstt (id(?fresh := ?c)) (psubstt (id(?c := ?fresh)) ?t) = ?t\n  new_list ?fresh ?l \\<Longrightarrow>\n  psubstts (id(?fresh := ?c)) (psubstts (id(?c := ?fresh)) ?l) = ?l\n\ngoal (1 subgoal):\n 1. psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) = s", "by simp"], ["proof (state)\nthis:\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have \\<open>?f c = c\\<close> and \\<open>new_term c (App fresh [])\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id(n := fresh, fresh := n)) c = c &&& new_term c (App fresh [])", "using False fresh"], ["proof (prove)\nusing this:\n  c \\<noteq> n\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n\ngoal (1 subgoal):\n 1. (id(n := fresh, fresh := n)) c = c &&& new_term c (App fresh [])", "by auto"], ["proof (state)\nthis:\n  (id(n := fresh, fresh := n)) c = c\n  new_term c (App fresh [])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have \\<open>psubst ?f (subc c ?s (subst A (App n []) 0)) =\n      subc (?f c) (psubstt ?f ?s) (psubst ?f (subst A (App n []) 0))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst (id(n := fresh, fresh := n))\n     (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) =\n    subc ((id(n := fresh, fresh := n)) c)\n     (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n     (psubst (id(n := fresh, fresh := n)) (A[App n []/0]))", "by (simp add: subc_psubst)"], ["proof (state)\nthis:\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) =\n  subc ((id(n := fresh, fresh := n)) c)\n   (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n   (psubst (id(n := fresh, fresh := n)) (A[App n []/0]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "also"], ["proof (state)\nthis:\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) =\n  subc ((id(n := fresh, fresh := n)) c)\n   (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n   (psubst (id(n := fresh, fresh := n)) (A[App n []/0]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have \\<open>\\<dots> = subc c s (subst (psubst ?f A) (App fresh []) 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subc ((id(n := fresh, fresh := n)) c)\n     (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n     (psubst (id(n := fresh, fresh := n)) (A[App n []/0])) =\n    subc c s (psubst (id(n := fresh, fresh := n)) A[App fresh []/0])", "using \\<open>?f c = c\\<close> psubst_subst psubst_s"], ["proof (prove)\nusing this:\n  (id(n := fresh, fresh := n)) c = c\n  psubst ?f (?P[?t/?i]) = psubst ?f ?P[psubstt ?f ?t/?i]\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. subc ((id(n := fresh, fresh := n)) c)\n     (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n     (psubst (id(n := fresh, fresh := n)) (A[App n []/0])) =\n    subc c s (psubst (id(n := fresh, fresh := n)) A[App fresh []/0])", "by simp"], ["proof (state)\nthis:\n  subc ((id(n := fresh, fresh := n)) c)\n   (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n   (psubst (id(n := fresh, fresh := n)) (A[App n []/0])) =\n  subc c s (psubst (id(n := fresh, fresh := n)) A[App fresh []/0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "also"], ["proof (state)\nthis:\n  subc ((id(n := fresh, fresh := n)) c)\n   (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n   (psubst (id(n := fresh, fresh := n)) (A[App n []/0])) =\n  subc c s (psubst (id(n := fresh, fresh := n)) A[App fresh []/0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have \\<open>\\<dots> = subc c s (subst A (App fresh []) 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subc c s (psubst (id(n := fresh, fresh := n)) A[App fresh []/0]) =\n    subc c s (A[App fresh []/0])", "using DeltaExists fresh"], ["proof (prove)\nusing this:\n  \\<stileturn> A[App n []/0] # G\n  \\<stileturn> subcs ?c ?s (A[App n []/0] # G)\n  news n (A # G)\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n\ngoal (1 subgoal):\n 1. subc c s (psubst (id(n := fresh, fresh := n)) A[App fresh []/0]) =\n    subc c s (A[App fresh []/0])", "by simp"], ["proof (state)\nthis:\n  subc c s (psubst (id(n := fresh, fresh := n)) A[App fresh []/0]) =\n  subc c s (A[App fresh []/0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "finally"], ["proof (chain)\npicking this:\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) =\n  subc c s (A[App fresh []/0])", "have psubst_A: \\<open>psubst ?f (subc c ?s (subst A (App n []) 0)) =\n        subst (subc c (liftt s) A) (App fresh []) 0\\<close>"], ["proof (prove)\nusing this:\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) =\n  subc c s (A[App fresh []/0])\n\ngoal (1 subgoal):\n 1. psubst (id(n := fresh, fresh := n))\n     (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) =\n    subc c (liftt s) A[App fresh []/0]", "using \\<open>new_term c (App fresh [])\\<close>"], ["proof (prove)\nusing this:\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) =\n  subc c s (A[App fresh []/0])\n  new_term c (App fresh [])\n\ngoal (1 subgoal):\n 1. psubst (id(n := fresh, fresh := n))\n     (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) =\n    subc c (liftt s) A[App fresh []/0]", "by simp"], ["proof (state)\nthis:\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) =\n  subc c (liftt s) A[App fresh []/0]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have \\<open>news n G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news n G", "using DeltaExists"], ["proof (prove)\nusing this:\n  \\<stileturn> A[App n []/0] # G\n  \\<stileturn> subcs ?c ?s (A[App n []/0] # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. news n G", "by simp"], ["proof (state)\nthis:\n  news n G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "moreover"], ["proof (state)\nthis:\n  news n G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have \\<open>news fresh G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news fresh G", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n\ngoal (1 subgoal):\n 1. news fresh G", "by (induct G) simp_all"], ["proof (state)\nthis:\n  news fresh G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "ultimately"], ["proof (chain)\npicking this:\n  news n G\n  news fresh G", "have \\<open>map (psubst ?f) G = G\\<close>"], ["proof (prove)\nusing this:\n  news n G\n  news fresh G\n\ngoal (1 subgoal):\n 1. map (psubst (id(n := fresh, fresh := n))) G = G", "by (induct G) simp_all"], ["proof (state)\nthis:\n  map (psubst (id(n := fresh, fresh := n))) G = G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "moreover"], ["proof (state)\nthis:\n  map (psubst (id(n := fresh, fresh := n))) G = G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have \\<open>\\<forall>x \\<in> \\<Union>p \\<in> set G. params p. x \\<noteq> c \\<longrightarrow> ?f x \\<noteq> ?f c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (params ` set G).\n       x \\<noteq> c \\<longrightarrow>\n       (id(n := fresh, fresh := n)) x \\<noteq>\n       (id(n := fresh, fresh := n)) c", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<Union> (params ` set G).\n     x \\<noteq> c \\<longrightarrow>\n     (id(n := fresh, fresh := n)) x \\<noteq> (id(n := fresh, fresh := n)) c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "ultimately"], ["proof (chain)\npicking this:\n  map (psubst (id(n := fresh, fresh := n))) G = G\n  \\<forall>x\\<in>\\<Union> (params ` set G).\n     x \\<noteq> c \\<longrightarrow>\n     (id(n := fresh, fresh := n)) x \\<noteq> (id(n := fresh, fresh := n)) c", "have psubst_G: \\<open>map (psubst ?f) (subcs c ?s G) = subcs c s G\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (id(n := fresh, fresh := n))) G = G\n  \\<forall>x\\<in>\\<Union> (params ` set G).\n     x \\<noteq> c \\<longrightarrow>\n     (id(n := fresh, fresh := n)) x \\<noteq> (id(n := fresh, fresh := n)) c\n\ngoal (1 subgoal):\n 1. map (psubst (id(n := fresh, fresh := n)))\n     (subcs c (psubstt (id(n := fresh)) s) G) =\n    subcs c s G", "using \\<open>?f c = c\\<close> psubst_s"], ["proof (prove)\nusing this:\n  map (psubst (id(n := fresh, fresh := n))) G = G\n  \\<forall>x\\<in>\\<Union> (params ` set G).\n     x \\<noteq> c \\<longrightarrow>\n     (id(n := fresh, fresh := n)) x \\<noteq> (id(n := fresh, fresh := n)) c\n  (id(n := fresh, fresh := n)) c = c\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. map (psubst (id(n := fresh, fresh := n)))\n     (subcs c (psubstt (id(n := fresh)) s) G) =\n    subcs c s G", "by (simp add: subcs_psubst)"], ["proof (state)\nthis:\n  map (psubst (id(n := fresh, fresh := n)))\n   (subcs c (psubstt (id(n := fresh)) s) G) =\n  subcs c s G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have \\<open>\\<stileturn> subc c ?s (subst A (App n []) 0) # subcs c ?s G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> subc c (psubstt (id(n := fresh)) s) (A[App n []/0]) #\n                 subcs c (psubstt (id(n := fresh)) s) G", "using DeltaExists"], ["proof (prove)\nusing this:\n  \\<stileturn> A[App n []/0] # G\n  \\<stileturn> subcs ?c ?s (A[App n []/0] # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> subc c (psubstt (id(n := fresh)) s) (A[App n []/0]) #\n                 subcs c (psubstt (id(n := fresh)) s) G", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> subc c (psubstt (id(n := fresh)) s) (A[App n []/0]) #\n               subcs c (psubstt (id(n := fresh)) s) G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> subc c (psubstt (id(n := fresh)) s) (A[App n []/0]) #\n               subcs c (psubstt (id(n := fresh)) s) G", "have \\<open>\\<stileturn> psubst ?f (subc c ?s (subst A (App n []) 0)) # map (psubst ?f) (subcs c ?s G)\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> subc c (psubstt (id(n := fresh)) s) (A[App n []/0]) #\n               subcs c (psubstt (id(n := fresh)) s) G\n\ngoal (1 subgoal):\n 1. \\<stileturn> psubst (id(n := fresh, fresh := n))\n                  (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) #\n                 map (psubst (id(n := fresh, fresh := n)))\n                  (subcs c (psubstt (id(n := fresh)) s) G)", "using TC_psubst inf_params DeltaExists.hyps(3)"], ["proof (prove)\nusing this:\n  \\<stileturn> subc c (psubstt (id(n := fresh)) s) (A[App n []/0]) #\n               subcs c (psubstt (id(n := fresh)) s) G\n  \\<lbrakk>infinite UNIV; \\<stileturn> ?G\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> map (psubst ?f) ?G\n  infinite UNIV\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> psubst (id(n := fresh, fresh := n))\n                  (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) #\n                 map (psubst (id(n := fresh, fresh := n)))\n                  (subcs c (psubstt (id(n := fresh)) s) G)", "by fastforce"], ["proof (state)\nthis:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) #\n               map (psubst (id(n := fresh, fresh := n)))\n                (subcs c (psubstt (id(n := fresh)) s) G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) #\n               map (psubst (id(n := fresh, fresh := n)))\n                (subcs c (psubstt (id(n := fresh)) s) G)", "have \\<open>\\<stileturn> psubst ?f (subc c ?s (subst A (App n []) 0)) # subcs c s G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) #\n               map (psubst (id(n := fresh, fresh := n)))\n                (subcs c (psubstt (id(n := fresh)) s) G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> psubst (id(n := fresh, fresh := n))\n                  (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) #\n                 subcs c s G", "using psubst_G"], ["proof (prove)\nusing this:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) #\n               map (psubst (id(n := fresh, fresh := n)))\n                (subcs c (psubstt (id(n := fresh)) s) G)\n  map (psubst (id(n := fresh, fresh := n)))\n   (subcs c (psubstt (id(n := fresh)) s) G) =\n  subcs c s G\n\ngoal (1 subgoal):\n 1. \\<stileturn> psubst (id(n := fresh, fresh := n))\n                  (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) #\n                 subcs c s G", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) #\n               subcs c s G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) #\n               subcs c s G", "have sub_A: \\<open>\\<stileturn> subst (subc c (liftt s) A) (App fresh []) 0 # subcs c s G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) #\n               subcs c s G\n\ngoal (1 subgoal):\n 1. \\<stileturn> subc c (liftt s) A[App fresh []/0] # subcs c s G", "using psubst_A"], ["proof (prove)\nusing this:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) #\n               subcs c s G\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (A[App n []/0])) =\n  subc c (liftt s) A[App fresh []/0]\n\ngoal (1 subgoal):\n 1. \\<stileturn> subc c (liftt s) A[App fresh []/0] # subcs c s G", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> subc c (liftt s) A[App fresh []/0] # subcs c s G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have \\<open>new_term fresh s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term fresh s", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n\ngoal (1 subgoal):\n 1. new_term fresh s", "by simp"], ["proof (state)\nthis:\n  new_term fresh s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "then"], ["proof (chain)\npicking this:\n  new_term fresh s", "have \\<open>new_term fresh (liftt s)\\<close>"], ["proof (prove)\nusing this:\n  new_term fresh s\n\ngoal (1 subgoal):\n 1. new_term fresh (liftt s)", "by simp"], ["proof (state)\nthis:\n  new_term fresh (liftt s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "then"], ["proof (chain)\npicking this:\n  new_term fresh (liftt s)", "have \\<open>new fresh (subc c (liftt s) A)\\<close>"], ["proof (prove)\nusing this:\n  new_term fresh (liftt s)\n\ngoal (1 subgoal):\n 1. new fresh (subc c (liftt s) A)", "using fresh new_subc"], ["proof (prove)\nusing this:\n  new_term fresh (liftt s)\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n  \\<lbrakk>new_term ?d ?s; new ?d ?p\\<rbrakk>\n  \\<Longrightarrow> new ?d (subc ?c ?s ?p)\n\ngoal (1 subgoal):\n 1. new fresh (subc c (liftt s) A)", "by simp"], ["proof (state)\nthis:\n  new fresh (subc c (liftt s) A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "moreover"], ["proof (state)\nthis:\n  new fresh (subc c (liftt s) A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "have \\<open>news fresh (subcs c s G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news fresh (subcs c s G)", "using \\<open>news fresh G\\<close> \\<open>new_term fresh s\\<close> news_subcs"], ["proof (prove)\nusing this:\n  news fresh G\n  new_term fresh s\n  \\<lbrakk>new_term ?d ?s; news ?d ?z\\<rbrakk>\n  \\<Longrightarrow> news ?d (subcs ?c ?s ?z)\n\ngoal (1 subgoal):\n 1. news fresh (subcs c s G)", "by fast"], ["proof (state)\nthis:\n  news fresh (subcs c s G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> A[App n []/0] # G;\n     \\<And>c s. \\<stileturn> subcs c s (A[App n []/0] # G); news n (A # G);\n     c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Exists A # G)", "ultimately"], ["proof (chain)\npicking this:\n  new fresh (subc c (liftt s) A)\n  news fresh (subcs c s G)", "show \\<open>\\<stileturn> subcs c s (Exists A # G)\\<close>"], ["proof (prove)\nusing this:\n  new fresh (subc c (liftt s) A)\n  news fresh (subcs c s G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s (Exists A # G)", "using TC.DeltaExists sub_A"], ["proof (prove)\nusing this:\n  new fresh (subc c (liftt s) A)\n  news fresh (subcs c s G)\n  \\<lbrakk>\\<stileturn> ?A[App ?n []/0] # ?G; news ?n (?A # ?G)\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> Exists ?A # ?G\n  \\<stileturn> subc c (liftt s) A[App fresh []/0] # subcs c s G\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s (Exists A # G)", "by fastforce"], ["proof (state)\nthis:\n  \\<stileturn> subcs c s (Exists A # G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<stileturn> subcs c s (Exists A # G)\n\ngoal (12 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 12 subgoals...", "case (DeltaNegForall A n G)"], ["proof (state)\nthis:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<stileturn> subcs ?c ?s (Neg (A[App n []/0]) # G)\n  news n (A # G)\n\ngoal (12 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<stileturn> subcs ?c ?s (Neg (A[App n []/0]) # G)\n  news n (A # G)", "show ?case"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<stileturn> subcs ?c ?s (Neg (A[App n []/0]) # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s (Neg (Forall A) # G)", "proof (cases \\<open>c = n\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c = n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)\n 2. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "case True"], ["proof (state)\nthis:\n  c = n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c = n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)\n 2. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "then"], ["proof (chain)\npicking this:\n  c = n", "have \\<open>\\<stileturn> Neg (Forall A) # G\\<close>"], ["proof (prove)\nusing this:\n  c = n\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg (Forall A) # G", "using DeltaNegForall TC.DeltaNegForall"], ["proof (prove)\nusing this:\n  c = n\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<stileturn> subcs ?c ?s (Neg (A[App n []/0]) # G)\n  news n (A # G)\n  \\<lbrakk>\\<stileturn> Neg (?A[App ?n []/0]) # ?G;\n   news ?n (?A # ?G)\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> Neg (Forall ?A) # ?G\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg (Forall A) # G", "by metis"], ["proof (state)\nthis:\n  \\<stileturn> Neg (Forall A) # G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c = n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)\n 2. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "moreover"], ["proof (state)\nthis:\n  \\<stileturn> Neg (Forall A) # G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c = n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)\n 2. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have \\<open>new c A\\<close> and \\<open>news c G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new c A &&& news c G", "using DeltaNegForall True"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<stileturn> subcs ?c ?s (Neg (A[App n []/0]) # G)\n  news n (A # G)\n  c = n\n\ngoal (1 subgoal):\n 1. new c A &&& news c G", "by simp_all"], ["proof (state)\nthis:\n  new c A\n  news c G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c = n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)\n 2. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "ultimately"], ["proof (chain)\npicking this:\n  \\<stileturn> Neg (Forall A) # G\n  new c A\n  news c G", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (Forall A) # G\n  new c A\n  news c G\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s (Neg (Forall A) # G)", "by (simp add: subcs_news)"], ["proof (state)\nthis:\n  \\<stileturn> subcs c s (Neg (Forall A) # G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "case False"], ["proof (state)\nthis:\n  c \\<noteq> n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "let ?params = \\<open>params A \\<union> (\\<Union>p \\<in> set G. params p) \\<union> paramst s \\<union> {c} \\<union> {n}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (params A \\<union> \\<Union> (params ` set G) \\<union>\n      paramst s \\<union>\n      {c} \\<union>\n      {n})", "by simp"], ["proof (state)\nthis:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    {c} \\<union>\n    {n})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "then"], ["proof (chain)\npicking this:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    {c} \\<union>\n    {n})", "obtain fresh where fresh: \\<open>fresh \\<notin> ?params\\<close>"], ["proof (prove)\nusing this:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    {c} \\<union>\n    {n})\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {n} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_new_if_finite inf_params"], ["proof (prove)\nusing this:\n  finite\n   (params A \\<union> \\<Union> (params ` set G) \\<union> paramst s \\<union>\n    {c} \\<union>\n    {n})\n  \\<lbrakk>infinite UNIV; finite ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. a \\<notin> ?A\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {n} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "let ?s = \\<open>psubstt (id(n := fresh)) s\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "let ?f = \\<open>id(n := fresh, fresh := n)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have f: \\<open>\\<forall>x \\<in> ?params. x \\<noteq> c \\<longrightarrow> ?f x \\<noteq> ?f c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params A \\<union> \\<Union> (params ` set G) \\<union>\n                   paramst s \\<union>\n                   {c} \\<union>\n                   {n}.\n       x \\<noteq> c \\<longrightarrow>\n       (id(n := fresh, fresh := n)) x \\<noteq>\n       (id(n := fresh, fresh := n)) c", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params A \\<union> \\<Union> (params ` set G) \\<union>\n                   paramst s \\<union>\n                   {c} \\<union>\n                   {n}.\n       x \\<noteq> c \\<longrightarrow>\n       (id(n := fresh, fresh := n)) x \\<noteq>\n       (id(n := fresh, fresh := n)) c", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>params A \\<union> \\<Union> (params ` set G) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {n}.\n     x \\<noteq> c \\<longrightarrow>\n     (id(n := fresh, fresh := n)) x \\<noteq> (id(n := fresh, fresh := n)) c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have \\<open>new_term n ?s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term n (psubstt (id(n := fresh)) s)", "using fresh psubst_new_free'"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n  ?c \\<noteq> ?n \\<Longrightarrow> new_term ?n (psubstt (id(?n := ?c)) ?t)\n  ?c \\<noteq> ?n \\<Longrightarrow> new_list ?n (psubstts (id(?n := ?c)) ?l)\n\ngoal (1 subgoal):\n 1. new_term n (psubstt (id(n := fresh)) s)", "by fast"], ["proof (state)\nthis:\n  new_term n (psubstt (id(n := fresh)) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "then"], ["proof (chain)\npicking this:\n  new_term n (psubstt (id(n := fresh)) s)", "have \\<open>psubstt ?f ?s = psubstt (id(fresh := n)) ?s\\<close>"], ["proof (prove)\nusing this:\n  new_term n (psubstt (id(n := fresh)) s)\n\ngoal (1 subgoal):\n 1. psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) =\n    psubstt (id(fresh := n)) (psubstt (id(n := fresh)) s)", "using fun_upd_twist psubstt_upd(1)"], ["proof (prove)\nusing this:\n  new_term n (psubstt (id(n := fresh)) s)\n  ?a \\<noteq> ?c \\<Longrightarrow>\n  ?m(?a := ?b, ?c := ?d) = ?m(?c := ?d, ?a := ?b)\n  new_term ?x ?t \\<Longrightarrow> psubstt (?f(?x := ?y)) ?t = psubstt ?f ?t\n\ngoal (1 subgoal):\n 1. psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) =\n    psubstt (id(fresh := n)) (psubstt (id(n := fresh)) s)", "by metis"], ["proof (state)\nthis:\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) =\n  psubstt (id(fresh := n)) (psubstt (id(n := fresh)) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "then"], ["proof (chain)\npicking this:\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) =\n  psubstt (id(fresh := n)) (psubstt (id(n := fresh)) s)", "have psubst_s: \\<open>psubstt ?f ?s = s\\<close>"], ["proof (prove)\nusing this:\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) =\n  psubstt (id(fresh := n)) (psubstt (id(n := fresh)) s)\n\ngoal (1 subgoal):\n 1. psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) = s", "using fresh psubst_new_away'"], ["proof (prove)\nusing this:\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) =\n  psubstt (id(fresh := n)) (psubstt (id(n := fresh)) s)\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n  new_term ?fresh ?t \\<Longrightarrow>\n  psubstt (id(?fresh := ?c)) (psubstt (id(?c := ?fresh)) ?t) = ?t\n  new_list ?fresh ?l \\<Longrightarrow>\n  psubstts (id(?fresh := ?c)) (psubstts (id(?c := ?fresh)) ?l) = ?l\n\ngoal (1 subgoal):\n 1. psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) = s", "by simp"], ["proof (state)\nthis:\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have \\<open>?f c = c\\<close> and \\<open>new_term c (App fresh [])\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id(n := fresh, fresh := n)) c = c &&& new_term c (App fresh [])", "using False fresh"], ["proof (prove)\nusing this:\n  c \\<noteq> n\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n\ngoal (1 subgoal):\n 1. (id(n := fresh, fresh := n)) c = c &&& new_term c (App fresh [])", "by auto"], ["proof (state)\nthis:\n  (id(n := fresh, fresh := n)) c = c\n  new_term c (App fresh [])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have \\<open>psubst ?f (subc c ?s (Neg (subst A (App n []) 0))) =\n      subc (?f c) (psubstt ?f ?s) (psubst ?f (Neg (subst A (App n []) 0)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst (id(n := fresh, fresh := n))\n     (subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0]))) =\n    subc ((id(n := fresh, fresh := n)) c)\n     (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n     (psubst (id(n := fresh, fresh := n)) (Neg (A[App n []/0])))", "by (simp add: subc_psubst)"], ["proof (state)\nthis:\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0]))) =\n  subc ((id(n := fresh, fresh := n)) c)\n   (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n   (psubst (id(n := fresh, fresh := n)) (Neg (A[App n []/0])))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "also"], ["proof (state)\nthis:\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0]))) =\n  subc ((id(n := fresh, fresh := n)) c)\n   (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n   (psubst (id(n := fresh, fresh := n)) (Neg (A[App n []/0])))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have \\<open>\\<dots> = subc c s (Neg (subst (psubst ?f A)(App fresh []) 0))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subc ((id(n := fresh, fresh := n)) c)\n     (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n     (psubst (id(n := fresh, fresh := n)) (Neg (A[App n []/0]))) =\n    subc c s (Neg (psubst (id(n := fresh, fresh := n)) A[App fresh []/0]))", "using \\<open>?f c = c\\<close> psubst_subst psubst_s"], ["proof (prove)\nusing this:\n  (id(n := fresh, fresh := n)) c = c\n  psubst ?f (?P[?t/?i]) = psubst ?f ?P[psubstt ?f ?t/?i]\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. subc ((id(n := fresh, fresh := n)) c)\n     (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n     (psubst (id(n := fresh, fresh := n)) (Neg (A[App n []/0]))) =\n    subc c s (Neg (psubst (id(n := fresh, fresh := n)) A[App fresh []/0]))", "by simp"], ["proof (state)\nthis:\n  subc ((id(n := fresh, fresh := n)) c)\n   (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n   (psubst (id(n := fresh, fresh := n)) (Neg (A[App n []/0]))) =\n  subc c s (Neg (psubst (id(n := fresh, fresh := n)) A[App fresh []/0]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "also"], ["proof (state)\nthis:\n  subc ((id(n := fresh, fresh := n)) c)\n   (psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s))\n   (psubst (id(n := fresh, fresh := n)) (Neg (A[App n []/0]))) =\n  subc c s (Neg (psubst (id(n := fresh, fresh := n)) A[App fresh []/0]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have \\<open>\\<dots> = subc c s (Neg (subst A (App fresh []) 0))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subc c s (Neg (psubst (id(n := fresh, fresh := n)) A[App fresh []/0])) =\n    subc c s (Neg (A[App fresh []/0]))", "using DeltaNegForall fresh"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<stileturn> subcs ?c ?s (Neg (A[App n []/0]) # G)\n  news n (A # G)\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n\ngoal (1 subgoal):\n 1. subc c s (Neg (psubst (id(n := fresh, fresh := n)) A[App fresh []/0])) =\n    subc c s (Neg (A[App fresh []/0]))", "by simp"], ["proof (state)\nthis:\n  subc c s (Neg (psubst (id(n := fresh, fresh := n)) A[App fresh []/0])) =\n  subc c s (Neg (A[App fresh []/0]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "finally"], ["proof (chain)\npicking this:\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0]))) =\n  subc c s (Neg (A[App fresh []/0]))", "have psubst_A: \\<open>psubst ?f (subc c ?s (Neg (subst A (App n []) 0))) =\n        Neg (subst (subc c (liftt s) A) (App fresh []) 0)\\<close>"], ["proof (prove)\nusing this:\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0]))) =\n  subc c s (Neg (A[App fresh []/0]))\n\ngoal (1 subgoal):\n 1. psubst (id(n := fresh, fresh := n))\n     (subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0]))) =\n    Neg (subc c (liftt s) A[App fresh []/0])", "using \\<open>new_term c (App fresh [])\\<close>"], ["proof (prove)\nusing this:\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0]))) =\n  subc c s (Neg (A[App fresh []/0]))\n  new_term c (App fresh [])\n\ngoal (1 subgoal):\n 1. psubst (id(n := fresh, fresh := n))\n     (subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0]))) =\n    Neg (subc c (liftt s) A[App fresh []/0])", "by simp"], ["proof (state)\nthis:\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0]))) =\n  Neg (subc c (liftt s) A[App fresh []/0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have \\<open>news n G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news n G", "using DeltaNegForall"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<stileturn> subcs ?c ?s (Neg (A[App n []/0]) # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. news n G", "by simp"], ["proof (state)\nthis:\n  news n G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "moreover"], ["proof (state)\nthis:\n  news n G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have \\<open>news fresh G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news fresh G", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n\ngoal (1 subgoal):\n 1. news fresh G", "by (induct G) simp_all"], ["proof (state)\nthis:\n  news fresh G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "ultimately"], ["proof (chain)\npicking this:\n  news n G\n  news fresh G", "have \\<open>map (psubst ?f) G = G\\<close>"], ["proof (prove)\nusing this:\n  news n G\n  news fresh G\n\ngoal (1 subgoal):\n 1. map (psubst (id(n := fresh, fresh := n))) G = G", "by (induct G) simp_all"], ["proof (state)\nthis:\n  map (psubst (id(n := fresh, fresh := n))) G = G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "moreover"], ["proof (state)\nthis:\n  map (psubst (id(n := fresh, fresh := n))) G = G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have \\<open>\\<forall>x \\<in> \\<Union>p \\<in> set G. params p. x \\<noteq> c \\<longrightarrow> ?f x \\<noteq> ?f c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (params ` set G).\n       x \\<noteq> c \\<longrightarrow>\n       (id(n := fresh, fresh := n)) x \\<noteq>\n       (id(n := fresh, fresh := n)) c", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<Union> (params ` set G).\n     x \\<noteq> c \\<longrightarrow>\n     (id(n := fresh, fresh := n)) x \\<noteq> (id(n := fresh, fresh := n)) c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "ultimately"], ["proof (chain)\npicking this:\n  map (psubst (id(n := fresh, fresh := n))) G = G\n  \\<forall>x\\<in>\\<Union> (params ` set G).\n     x \\<noteq> c \\<longrightarrow>\n     (id(n := fresh, fresh := n)) x \\<noteq> (id(n := fresh, fresh := n)) c", "have psubst_G: \\<open>map (psubst ?f) (subcs c ?s G) = subcs c s G\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (id(n := fresh, fresh := n))) G = G\n  \\<forall>x\\<in>\\<Union> (params ` set G).\n     x \\<noteq> c \\<longrightarrow>\n     (id(n := fresh, fresh := n)) x \\<noteq> (id(n := fresh, fresh := n)) c\n\ngoal (1 subgoal):\n 1. map (psubst (id(n := fresh, fresh := n)))\n     (subcs c (psubstt (id(n := fresh)) s) G) =\n    subcs c s G", "using \\<open>?f c = c\\<close> psubst_s"], ["proof (prove)\nusing this:\n  map (psubst (id(n := fresh, fresh := n))) G = G\n  \\<forall>x\\<in>\\<Union> (params ` set G).\n     x \\<noteq> c \\<longrightarrow>\n     (id(n := fresh, fresh := n)) x \\<noteq> (id(n := fresh, fresh := n)) c\n  (id(n := fresh, fresh := n)) c = c\n  psubstt (id(n := fresh, fresh := n)) (psubstt (id(n := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. map (psubst (id(n := fresh, fresh := n)))\n     (subcs c (psubstt (id(n := fresh)) s) G) =\n    subcs c s G", "by (simp add: subcs_psubst)"], ["proof (state)\nthis:\n  map (psubst (id(n := fresh, fresh := n)))\n   (subcs c (psubstt (id(n := fresh)) s) G) =\n  subcs c s G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have \\<open>\\<stileturn> subc c ?s (Neg (subst A (App n []) 0)) # subcs c ?s G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0])) #\n                 subcs c (psubstt (id(n := fresh)) s) G", "using DeltaNegForall"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (A[App n []/0]) # G\n  \\<stileturn> subcs ?c ?s (Neg (A[App n []/0]) # G)\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0])) #\n                 subcs c (psubstt (id(n := fresh)) s) G", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0])) #\n               subcs c (psubstt (id(n := fresh)) s) G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0])) #\n               subcs c (psubstt (id(n := fresh)) s) G", "have \\<open>\\<stileturn> psubst ?f (subc c ?s (Neg (subst A (App n []) 0)))\n                # map (psubst ?f) (subcs c ?s G)\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0])) #\n               subcs c (psubstt (id(n := fresh)) s) G\n\ngoal (1 subgoal):\n 1. \\<stileturn> psubst (id(n := fresh, fresh := n))\n                  (subc c (psubstt (id(n := fresh)) s)\n                    (Neg (A[App n []/0]))) #\n                 map (psubst (id(n := fresh, fresh := n)))\n                  (subcs c (psubstt (id(n := fresh)) s) G)", "using TC_psubst inf_params DeltaNegForall.hyps(3)"], ["proof (prove)\nusing this:\n  \\<stileturn> subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0])) #\n               subcs c (psubstt (id(n := fresh)) s) G\n  \\<lbrakk>infinite UNIV; \\<stileturn> ?G\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> map (psubst ?f) ?G\n  infinite UNIV\n  news n (A # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> psubst (id(n := fresh, fresh := n))\n                  (subc c (psubstt (id(n := fresh)) s)\n                    (Neg (A[App n []/0]))) #\n                 map (psubst (id(n := fresh, fresh := n)))\n                  (subcs c (psubstt (id(n := fresh)) s) G)", "by fastforce"], ["proof (state)\nthis:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s)\n                  (Neg (A[App n []/0]))) #\n               map (psubst (id(n := fresh, fresh := n)))\n                (subcs c (psubstt (id(n := fresh)) s) G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s)\n                  (Neg (A[App n []/0]))) #\n               map (psubst (id(n := fresh, fresh := n)))\n                (subcs c (psubstt (id(n := fresh)) s) G)", "have \\<open>\\<stileturn> psubst ?f (subc c ?s (Neg (subst A (App n []) 0))) # subcs c s G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s)\n                  (Neg (A[App n []/0]))) #\n               map (psubst (id(n := fresh, fresh := n)))\n                (subcs c (psubstt (id(n := fresh)) s) G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> psubst (id(n := fresh, fresh := n))\n                  (subc c (psubstt (id(n := fresh)) s)\n                    (Neg (A[App n []/0]))) #\n                 subcs c s G", "using psubst_G"], ["proof (prove)\nusing this:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s)\n                  (Neg (A[App n []/0]))) #\n               map (psubst (id(n := fresh, fresh := n)))\n                (subcs c (psubstt (id(n := fresh)) s) G)\n  map (psubst (id(n := fresh, fresh := n)))\n   (subcs c (psubstt (id(n := fresh)) s) G) =\n  subcs c s G\n\ngoal (1 subgoal):\n 1. \\<stileturn> psubst (id(n := fresh, fresh := n))\n                  (subc c (psubstt (id(n := fresh)) s)\n                    (Neg (A[App n []/0]))) #\n                 subcs c s G", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s)\n                  (Neg (A[App n []/0]))) #\n               subcs c s G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s)\n                  (Neg (A[App n []/0]))) #\n               subcs c s G", "have sub_A: \\<open>\\<stileturn> Neg (subst (subc c (liftt s) A) (App fresh []) 0) # subcs c s G\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s)\n                  (Neg (A[App n []/0]))) #\n               subcs c s G\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg (subc c (liftt s) A[App fresh []/0]) # subcs c s G", "using psubst_A"], ["proof (prove)\nusing this:\n  \\<stileturn> psubst (id(n := fresh, fresh := n))\n                (subc c (psubstt (id(n := fresh)) s)\n                  (Neg (A[App n []/0]))) #\n               subcs c s G\n  psubst (id(n := fresh, fresh := n))\n   (subc c (psubstt (id(n := fresh)) s) (Neg (A[App n []/0]))) =\n  Neg (subc c (liftt s) A[App fresh []/0])\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg (subc c (liftt s) A[App fresh []/0]) # subcs c s G", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> Neg (subc c (liftt s) A[App fresh []/0]) # subcs c s G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have \\<open>new_term fresh s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term fresh s", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n\ngoal (1 subgoal):\n 1. new_term fresh s", "by simp"], ["proof (state)\nthis:\n  new_term fresh s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "then"], ["proof (chain)\npicking this:\n  new_term fresh s", "have \\<open>new_term fresh (liftt s)\\<close>"], ["proof (prove)\nusing this:\n  new_term fresh s\n\ngoal (1 subgoal):\n 1. new_term fresh (liftt s)", "by simp"], ["proof (state)\nthis:\n  new_term fresh (liftt s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "then"], ["proof (chain)\npicking this:\n  new_term fresh (liftt s)", "have \\<open>new fresh (subc c (liftt s) A)\\<close>"], ["proof (prove)\nusing this:\n  new_term fresh (liftt s)\n\ngoal (1 subgoal):\n 1. new fresh (subc c (liftt s) A)", "using fresh new_subc"], ["proof (prove)\nusing this:\n  new_term fresh (liftt s)\n  fresh\n  \\<notin> params A \\<union> \\<Union> (params ` set G) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {n}\n  \\<lbrakk>new_term ?d ?s; new ?d ?p\\<rbrakk>\n  \\<Longrightarrow> new ?d (subc ?c ?s ?p)\n\ngoal (1 subgoal):\n 1. new fresh (subc c (liftt s) A)", "by simp"], ["proof (state)\nthis:\n  new fresh (subc c (liftt s) A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "moreover"], ["proof (state)\nthis:\n  new fresh (subc c (liftt s) A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "have \\<open>news fresh (subcs c s G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news fresh (subcs c s G)", "using \\<open>news fresh G\\<close> \\<open>new_term fresh s\\<close> news_subcs"], ["proof (prove)\nusing this:\n  news fresh G\n  new_term fresh s\n  \\<lbrakk>new_term ?d ?s; news ?d ?z\\<rbrakk>\n  \\<Longrightarrow> news ?d (subcs ?c ?s ?z)\n\ngoal (1 subgoal):\n 1. news fresh (subcs c s G)", "by fast"], ["proof (state)\nthis:\n  news fresh (subcs c s G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<stileturn> Neg (A[App n []/0]) # G;\n     \\<And>c s. \\<stileturn> subcs c s (Neg (A[App n []/0]) # G);\n     news n (A # G); c \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Forall A) # G)", "ultimately"], ["proof (chain)\npicking this:\n  new fresh (subc c (liftt s) A)\n  news fresh (subcs c s G)", "show \\<open>\\<stileturn> subcs c s (Neg (Forall A) # G)\\<close>"], ["proof (prove)\nusing this:\n  new fresh (subc c (liftt s) A)\n  news fresh (subcs c s G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s (Neg (Forall A) # G)", "using TC.DeltaNegForall sub_A"], ["proof (prove)\nusing this:\n  new fresh (subc c (liftt s) A)\n  news fresh (subcs c s G)\n  \\<lbrakk>\\<stileturn> Neg (?A[App ?n []/0]) # ?G;\n   news ?n (?A # ?G)\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> Neg (Forall ?A) # ?G\n  \\<stileturn> Neg (subc c (liftt s) A[App fresh []/0]) # subcs c s G\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s (Neg (Forall A) # G)", "by fastforce"], ["proof (state)\nthis:\n  \\<stileturn> subcs c s (Neg (Forall A) # G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<stileturn> subcs c s (Neg (Forall A) # G)\n\ngoal (11 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 11 subgoals...", "case (Order G G')"], ["proof (state)\nthis:\n  \\<stileturn> G\n  \\<stileturn> subcs ?c ?s G\n  set G = set G'\n\ngoal (11 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> G\n  \\<stileturn> subcs ?c ?s G\n  set G = set G'", "show ?case"], ["proof (prove)\nusing this:\n  \\<stileturn> G\n  \\<stileturn> subcs ?c ?s G\n  set G = set G'\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s G'", "using TC.Order set_map subcs_map"], ["proof (prove)\nusing this:\n  \\<stileturn> G\n  \\<stileturn> subcs ?c ?s G\n  set G = set G'\n  \\<lbrakk>\\<stileturn> ?G; set ?G = set ?G'\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> ?G'\n  set (map ?f ?xs) = ?f ` set ?xs\n  subcs ?c ?s ?G = map (subc ?c ?s) ?G\n\ngoal (1 subgoal):\n 1. \\<stileturn> subcs c s G'", "by metis"], ["proof (state)\nthis:\n  \\<stileturn> subcs c s G'\n\ngoal (10 subgoals):\n 1. \\<And>i l G c s. \\<stileturn> subcs c s (Pred i l # Neg (Pred i l) # G)\n 2. \\<And>G c s. \\<stileturn> subcs c s (\\<bottom> # G)\n 3. \\<And>G c s. \\<stileturn> subcs c s (Neg \\<top> # G)\n 4. \\<And>A G c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Neg A) # G)\n 5. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (And A B # G)\n 6. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> Neg A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Or A B) # G)\n 7. \\<And>A B G c s.\n       \\<lbrakk>\\<stileturn> A # Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (Impl A B) # G)\n 8. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> Neg A # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg A # G);\n        \\<stileturn> Neg B # G;\n        \\<And>c s. \\<stileturn> subcs c s (Neg B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Neg (And A B) # G)\n 9. \\<And>A G B c s.\n       \\<lbrakk>\\<stileturn> A # G;\n        \\<And>c s. \\<stileturn> subcs c s (A # G); \\<stileturn> B # G;\n        \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> subcs c s (Or A B # G)\n 10. \\<And>A G B c s.\n        \\<lbrakk>\\<stileturn> Neg A # G;\n         \\<And>c s. \\<stileturn> subcs c s (Neg A # G); \\<stileturn> B # G;\n         \\<And>c s. \\<stileturn> subcs c s (B # G)\\<rbrakk>\n        \\<Longrightarrow> \\<stileturn> subcs c s (Impl A B # G)", "qed (auto intro: TC.intros)"], ["", "lemma TC_map_subc:\n  fixes G :: \\<open>('a, 'b) form list\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<stileturn> G \\<Longrightarrow> \\<stileturn> map (subc c s) G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> G \\<Longrightarrow> \\<stileturn> map (subc c s) G", "using assms TC_subcs subcs_map"], ["proof (prove)\nusing this:\n  infinite UNIV\n  \\<lbrakk>infinite UNIV; \\<stileturn> ?G\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> subcs ?c ?s ?G\n  subcs ?c ?s ?G = map (subc ?c ?s) ?G\n\ngoal (1 subgoal):\n 1. \\<stileturn> G \\<Longrightarrow> \\<stileturn> map (subc c s) G", "by metis"], ["", "lemma ex_all_closed: \\<open>\\<exists>m. list_all (closed m) G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. list_all (closed m) G", "proof (induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>m. list_all (closed m) []\n 2. \\<And>a G.\n       \\<exists>m. list_all (closed m) G \\<Longrightarrow>\n       \\<exists>m. list_all (closed m) (a # G)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>m. list_all (closed m) []\n 2. \\<And>a G.\n       \\<exists>m. list_all (closed m) G \\<Longrightarrow>\n       \\<exists>m. list_all (closed m) (a # G)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. list_all (closed m) []", "by simp"], ["proof (state)\nthis:\n  \\<exists>m. list_all (closed m) []\n\ngoal (1 subgoal):\n 1. \\<And>a G.\n       \\<exists>m. list_all (closed m) G \\<Longrightarrow>\n       \\<exists>m. list_all (closed m) (a # G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a G.\n       \\<exists>m. list_all (closed m) G \\<Longrightarrow>\n       \\<exists>m. list_all (closed m) (a # G)", "case (Cons a G)"], ["proof (state)\nthis:\n  \\<exists>m. list_all (closed m) G\n\ngoal (1 subgoal):\n 1. \\<And>a G.\n       \\<exists>m. list_all (closed m) G \\<Longrightarrow>\n       \\<exists>m. list_all (closed m) (a # G)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. list_all (closed m) G", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>m. list_all (closed m) G\n\ngoal (1 subgoal):\n 1. \\<exists>m. list_all (closed m) (a # G)", "unfolding list_all_def"], ["proof (prove)\nusing this:\n  \\<exists>m. Ball (set G) (closed m)\n\ngoal (1 subgoal):\n 1. \\<exists>m. Ball (set (a # G)) (closed m)", "using ex_closed closed_mono"], ["proof (prove)\nusing this:\n  \\<exists>m. Ball (set G) (closed m)\n  \\<exists>m. closed m ?p\n  \\<lbrakk>?i \\<le> ?j; closed ?i ?p\\<rbrakk> \\<Longrightarrow> closed ?j ?p\n\ngoal (1 subgoal):\n 1. \\<exists>m. Ball (set (a # G)) (closed m)", "by (metis Ball_set list_all_simps(1) nat_le_linear)"], ["proof (state)\nthis:\n  \\<exists>m. list_all (closed m) (a # G)\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec sub_consts :: \\<open>'a list \\<Rightarrow> ('a, 'b) form \\<Rightarrow> ('a, 'b) form\\<close> where\n  \\<open>sub_consts [] p = p\\<close>\n| \\<open>sub_consts (c # cs) p = sub_consts cs (subst p (App c []) (length cs))\\<close>"], ["", "lemma valid_sub_consts:\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> 'a) f g. eval e f g p\\<close>\n  shows \\<open>eval (e :: nat => 'a) f g (sub_consts cs p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval e f g (sub_consts cs p)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>e f g. eval e f g p\n\ngoal (1 subgoal):\n 1. eval e f g (sub_consts cs p)", "by (induct cs arbitrary: p) simp_all"], ["", "lemma closed_sub' [simp]:\n  assumes \\<open>k \\<le> m\\<close> shows\n    \\<open>closedt (Suc m) t = closedt m (substt t (App c []) k)\\<close>\n    \\<open>closedts (Suc m) l = closedts m (substts l (App c []) k)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closedt (Suc m) t = closedt m (t[App c []/k]) &&&\n    closedts (Suc m) l = closedts m (l[App c []/k])", "using assms"], ["proof (prove)\nusing this:\n  k \\<le> m\n\ngoal (1 subgoal):\n 1. closedt (Suc m) t = closedt m (t[App c []/k]) &&&\n    closedts (Suc m) l = closedts m (l[App c []/k])", "by (induct t and l rule: closedt.induct closedts.induct) auto"], ["", "lemma closed_sub: \\<open>k \\<le> m \\<Longrightarrow> closed (Suc m) p = closed m (subst p (App c []) k)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> m \\<Longrightarrow> closed (Suc m) p = closed m (p[App c []/k])", "by (induct p arbitrary: m k) simp_all"], ["", "lemma closed_sub_consts: \\<open>length cs = k \\<Longrightarrow> closed m (sub_consts cs p) = closed (m + k) p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. length cs = k \\<Longrightarrow>\n    closed m (sub_consts cs p) = closed (m + k) p", "proof (induct cs arbitrary: k p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k p.\n       length [] = k \\<Longrightarrow>\n       closed m (sub_consts [] p) = closed (m + k) p\n 2. \\<And>a cs k p.\n       \\<lbrakk>\\<And>k p.\n                   length cs = k \\<Longrightarrow>\n                   closed m (sub_consts cs p) = closed (m + k) p;\n        length (a # cs) = k\\<rbrakk>\n       \\<Longrightarrow> closed m (sub_consts (a # cs) p) = closed (m + k) p", "case Nil"], ["proof (state)\nthis:\n  length [] = k\n\ngoal (2 subgoals):\n 1. \\<And>k p.\n       length [] = k \\<Longrightarrow>\n       closed m (sub_consts [] p) = closed (m + k) p\n 2. \\<And>a cs k p.\n       \\<lbrakk>\\<And>k p.\n                   length cs = k \\<Longrightarrow>\n                   closed m (sub_consts cs p) = closed (m + k) p;\n        length (a # cs) = k\\<rbrakk>\n       \\<Longrightarrow> closed m (sub_consts (a # cs) p) = closed (m + k) p", "then"], ["proof (chain)\npicking this:\n  length [] = k", "show ?case"], ["proof (prove)\nusing this:\n  length [] = k\n\ngoal (1 subgoal):\n 1. closed m (sub_consts [] p) = closed (m + k) p", "by simp"], ["proof (state)\nthis:\n  closed m (sub_consts [] p) = closed (m + k) p\n\ngoal (1 subgoal):\n 1. \\<And>a cs k p.\n       \\<lbrakk>\\<And>k p.\n                   length cs = k \\<Longrightarrow>\n                   closed m (sub_consts cs p) = closed (m + k) p;\n        length (a # cs) = k\\<rbrakk>\n       \\<Longrightarrow> closed m (sub_consts (a # cs) p) = closed (m + k) p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a cs k p.\n       \\<lbrakk>\\<And>k p.\n                   length cs = k \\<Longrightarrow>\n                   closed m (sub_consts cs p) = closed (m + k) p;\n        length (a # cs) = k\\<rbrakk>\n       \\<Longrightarrow> closed m (sub_consts (a # cs) p) = closed (m + k) p", "case (Cons c cs)"], ["proof (state)\nthis:\n  length cs = ?k \\<Longrightarrow>\n  closed m (sub_consts cs ?p) = closed (m + ?k) ?p\n  length (c # cs) = k\n\ngoal (1 subgoal):\n 1. \\<And>a cs k p.\n       \\<lbrakk>\\<And>k p.\n                   length cs = k \\<Longrightarrow>\n                   closed m (sub_consts cs p) = closed (m + k) p;\n        length (a # cs) = k\\<rbrakk>\n       \\<Longrightarrow> closed m (sub_consts (a # cs) p) = closed (m + k) p", "then"], ["proof (chain)\npicking this:\n  length cs = ?k \\<Longrightarrow>\n  closed m (sub_consts cs ?p) = closed (m + ?k) ?p\n  length (c # cs) = k", "show ?case"], ["proof (prove)\nusing this:\n  length cs = ?k \\<Longrightarrow>\n  closed m (sub_consts cs ?p) = closed (m + ?k) ?p\n  length (c # cs) = k\n\ngoal (1 subgoal):\n 1. closed m (sub_consts (c # cs) p) = closed (m + k) p", "using closed_sub"], ["proof (prove)\nusing this:\n  length cs = ?k \\<Longrightarrow>\n  closed m (sub_consts cs ?p) = closed (m + ?k) ?p\n  length (c # cs) = k\n  ?k \\<le> ?m \\<Longrightarrow>\n  closed (Suc ?m) ?p = closed ?m (?p[App ?c []/?k])\n\ngoal (1 subgoal):\n 1. closed m (sub_consts (c # cs) p) = closed (m + k) p", "by fastforce"], ["proof (state)\nthis:\n  closed m (sub_consts (c # cs) p) = closed (m + k) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_sub_consts_Nil: \\<open>map (sub_consts []) G = G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sub_consts []) G = G", "by (induct G) simp_all"], ["", "primrec conjoin :: \\<open>('a, 'b) form list \\<Rightarrow> ('a, 'b) form\\<close> where\n  \\<open>conjoin [] = Neg \\<bottom>\\<close>\n| \\<open>conjoin (p # ps) = And p (conjoin ps)\\<close>"], ["", "lemma eval_conjoin: \\<open>list_all (eval e f g) G = eval e f g (conjoin G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (eval e f g) G = eval e f g (conjoin G)", "by (induct G) simp_all"], ["", "lemma valid_sub:\n  fixes e :: \\<open>nat \\<Rightarrow> 'a\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> 'a) f g. eval e f g p \\<longrightarrow> eval e f g q\\<close>\n  shows \\<open>eval e f g (subst p t m) \\<longrightarrow> eval e f g (subst q t m)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval e f g (p[t/m]) \\<longrightarrow> eval e f g (q[t/m])", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q\n\ngoal (1 subgoal):\n 1. eval e f g (p[t/m]) \\<longrightarrow> eval e f g (q[t/m])", "by simp"], ["", "lemma eval_sub_consts:\n  fixes e :: \\<open>nat \\<Rightarrow> 'a\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> 'a) f g. eval e f g p \\<longrightarrow> eval e f g q\\<close>\n    and \\<open>eval e f g (sub_consts cs p)\\<close>\n  shows \\<open>eval e f g (sub_consts cs q)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval e f g (sub_consts cs q)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q\n  eval e f g (sub_consts cs p)\n\ngoal (1 subgoal):\n 1. eval e f g (sub_consts cs q)", "proof (induct cs arbitrary: p q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q;\n        eval e f g (sub_consts [] p)\\<rbrakk>\n       \\<Longrightarrow> eval e f g (sub_consts [] q)\n 2. \\<And>a cs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>\\<forall>e f g.\n                               eval e f g p \\<longrightarrow> eval e f g q;\n                    eval e f g (sub_consts cs p)\\<rbrakk>\n                   \\<Longrightarrow> eval e f g (sub_consts cs q);\n        \\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q;\n        eval e f g (sub_consts (a # cs) p)\\<rbrakk>\n       \\<Longrightarrow> eval e f g (sub_consts (a # cs) q)", "case Nil"], ["proof (state)\nthis:\n  \\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q\n  eval e f g (sub_consts [] p)\n\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q;\n        eval e f g (sub_consts [] p)\\<rbrakk>\n       \\<Longrightarrow> eval e f g (sub_consts [] q)\n 2. \\<And>a cs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>\\<forall>e f g.\n                               eval e f g p \\<longrightarrow> eval e f g q;\n                    eval e f g (sub_consts cs p)\\<rbrakk>\n                   \\<Longrightarrow> eval e f g (sub_consts cs q);\n        \\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q;\n        eval e f g (sub_consts (a # cs) p)\\<rbrakk>\n       \\<Longrightarrow> eval e f g (sub_consts (a # cs) q)", "then"], ["proof (chain)\npicking this:\n  \\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q\n  eval e f g (sub_consts [] p)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q\n  eval e f g (sub_consts [] p)\n\ngoal (1 subgoal):\n 1. eval e f g (sub_consts [] q)", "by simp"], ["proof (state)\nthis:\n  eval e f g (sub_consts [] q)\n\ngoal (1 subgoal):\n 1. \\<And>a cs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>\\<forall>e f g.\n                               eval e f g p \\<longrightarrow> eval e f g q;\n                    eval e f g (sub_consts cs p)\\<rbrakk>\n                   \\<Longrightarrow> eval e f g (sub_consts cs q);\n        \\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q;\n        eval e f g (sub_consts (a # cs) p)\\<rbrakk>\n       \\<Longrightarrow> eval e f g (sub_consts (a # cs) q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a cs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>\\<forall>e f g.\n                               eval e f g p \\<longrightarrow> eval e f g q;\n                    eval e f g (sub_consts cs p)\\<rbrakk>\n                   \\<Longrightarrow> eval e f g (sub_consts cs q);\n        \\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q;\n        eval e f g (sub_consts (a # cs) p)\\<rbrakk>\n       \\<Longrightarrow> eval e f g (sub_consts (a # cs) q)", "case (Cons c cs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>e f g. eval e f g ?p \\<longrightarrow> eval e f g ?q;\n   eval e f g (sub_consts cs ?p)\\<rbrakk>\n  \\<Longrightarrow> eval e f g (sub_consts cs ?q)\n  \\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q\n  eval e f g (sub_consts (c # cs) p)\n\ngoal (1 subgoal):\n 1. \\<And>a cs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>\\<forall>e f g.\n                               eval e f g p \\<longrightarrow> eval e f g q;\n                    eval e f g (sub_consts cs p)\\<rbrakk>\n                   \\<Longrightarrow> eval e f g (sub_consts cs q);\n        \\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q;\n        eval e f g (sub_consts (a # cs) p)\\<rbrakk>\n       \\<Longrightarrow> eval e f g (sub_consts (a # cs) q)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>e f g. eval e f g ?p \\<longrightarrow> eval e f g ?q;\n   eval e f g (sub_consts cs ?p)\\<rbrakk>\n  \\<Longrightarrow> eval e f g (sub_consts cs ?q)\n  \\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q\n  eval e f g (sub_consts (c # cs) p)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>e f g. eval e f g ?p \\<longrightarrow> eval e f g ?q;\n   eval e f g (sub_consts cs ?p)\\<rbrakk>\n  \\<Longrightarrow> eval e f g (sub_consts cs ?q)\n  \\<forall>e f g. eval e f g p \\<longrightarrow> eval e f g q\n  eval e f g (sub_consts (c # cs) p)\n\ngoal (1 subgoal):\n 1. eval e f g (sub_consts (c # cs) q)", "by (metis sub_consts.simps(2) subst_lemma)"], ["proof (state)\nthis:\n  eval e f g (sub_consts (c # cs) q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sub_consts_And [simp]: \\<open>sub_consts cs (And p q) = And (sub_consts cs p) (sub_consts cs q)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sub_consts cs (And p q) = And (sub_consts cs p) (sub_consts cs q)", "by (induct cs arbitrary: p q) simp_all"], ["", "lemma sub_consts_conjoin:\n  \\<open>eval e f g (sub_consts cs (conjoin G)) = eval e f g (conjoin (map (sub_consts cs) G))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval e f g (sub_consts cs (conjoin G)) =\n    eval e f g (conjoin (map (sub_consts cs) G))", "proof (induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval e f g (sub_consts cs (conjoin [])) =\n    eval e f g (conjoin (map (sub_consts cs) []))\n 2. \\<And>a G.\n       eval e f g (sub_consts cs (conjoin G)) =\n       eval e f g (conjoin (map (sub_consts cs) G)) \\<Longrightarrow>\n       eval e f g (sub_consts cs (conjoin (a # G))) =\n       eval e f g (conjoin (map (sub_consts cs) (a # G)))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. eval e f g (sub_consts cs (conjoin [])) =\n    eval e f g (conjoin (map (sub_consts cs) []))\n 2. \\<And>a G.\n       eval e f g (sub_consts cs (conjoin G)) =\n       eval e f g (conjoin (map (sub_consts cs) G)) \\<Longrightarrow>\n       eval e f g (sub_consts cs (conjoin (a # G))) =\n       eval e f g (conjoin (map (sub_consts cs) (a # G)))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval e f g (sub_consts cs (conjoin [])) =\n    eval e f g (conjoin (map (sub_consts cs) []))", "by (induct cs) simp_all"], ["proof (state)\nthis:\n  eval e f g (sub_consts cs (conjoin [])) =\n  eval e f g (conjoin (map (sub_consts cs) []))\n\ngoal (1 subgoal):\n 1. \\<And>a G.\n       eval e f g (sub_consts cs (conjoin G)) =\n       eval e f g (conjoin (map (sub_consts cs) G)) \\<Longrightarrow>\n       eval e f g (sub_consts cs (conjoin (a # G))) =\n       eval e f g (conjoin (map (sub_consts cs) (a # G)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a G.\n       eval e f g (sub_consts cs (conjoin G)) =\n       eval e f g (conjoin (map (sub_consts cs) G)) \\<Longrightarrow>\n       eval e f g (sub_consts cs (conjoin (a # G))) =\n       eval e f g (conjoin (map (sub_consts cs) (a # G)))", "case (Cons p G)"], ["proof (state)\nthis:\n  eval e f g (sub_consts cs (conjoin G)) =\n  eval e f g (conjoin (map (sub_consts cs) G))\n\ngoal (1 subgoal):\n 1. \\<And>a G.\n       eval e f g (sub_consts cs (conjoin G)) =\n       eval e f g (conjoin (map (sub_consts cs) G)) \\<Longrightarrow>\n       eval e f g (sub_consts cs (conjoin (a # G))) =\n       eval e f g (conjoin (map (sub_consts cs) (a # G)))", "then"], ["proof (chain)\npicking this:\n  eval e f g (sub_consts cs (conjoin G)) =\n  eval e f g (conjoin (map (sub_consts cs) G))", "show ?case"], ["proof (prove)\nusing this:\n  eval e f g (sub_consts cs (conjoin G)) =\n  eval e f g (conjoin (map (sub_consts cs) G))\n\ngoal (1 subgoal):\n 1. eval e f g (sub_consts cs (conjoin (p # G))) =\n    eval e f g (conjoin (map (sub_consts cs) (p # G)))", "using sub_consts_And"], ["proof (prove)\nusing this:\n  eval e f g (sub_consts cs (conjoin G)) =\n  eval e f g (conjoin (map (sub_consts cs) G))\n  sub_consts ?cs (And ?p ?q) = And (sub_consts ?cs ?p) (sub_consts ?cs ?q)\n\ngoal (1 subgoal):\n 1. eval e f g (sub_consts cs (conjoin (p # G))) =\n    eval e f g (conjoin (map (sub_consts cs) (p # G)))", "by simp"], ["proof (state)\nthis:\n  eval e f g (sub_consts cs (conjoin (p # G))) =\n  eval e f g (conjoin (map (sub_consts cs) (p # G)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_sub_consts_conjoin:\n  \\<open>list_all (eval e f g) (map (sub_consts cs) G) = eval e f g (sub_consts cs (conjoin G))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (eval e f g) (map (sub_consts cs) G) =\n    eval e f g (sub_consts cs (conjoin G))", "by (induct G) (simp_all add: valid_sub_consts)"], ["", "lemma valid_all_sub_consts:\n  fixes e :: \\<open>nat \\<Rightarrow> 'a\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> 'a) f g. list_all (eval e f g) G \\<longrightarrow> eval e f g p\\<close>\n  shows \\<open>list_all (eval e f g) (map (sub_consts cs) G) \\<longrightarrow> eval e f g (sub_consts cs p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (eval e f g) (map (sub_consts cs) G) \\<longrightarrow>\n    eval e f g (sub_consts cs p)", "using assms eval_conjoin eval_sub_consts all_sub_consts_conjoin"], ["proof (prove)\nusing this:\n  \\<forall>e f g. list_all (eval e f g) G \\<longrightarrow> eval e f g p\n  list_all (eval ?e ?f ?g) ?G = eval ?e ?f ?g (conjoin ?G)\n  \\<lbrakk>\\<forall>e f g. eval e f g ?p \\<longrightarrow> eval e f g ?q;\n   eval ?e ?f ?g (sub_consts ?cs ?p)\\<rbrakk>\n  \\<Longrightarrow> eval ?e ?f ?g (sub_consts ?cs ?q)\n  list_all (eval ?e ?f ?g) (map (sub_consts ?cs) ?G) =\n  eval ?e ?f ?g (sub_consts ?cs (conjoin ?G))\n\ngoal (1 subgoal):\n 1. list_all (eval e f g) (map (sub_consts cs) G) \\<longrightarrow>\n    eval e f g (sub_consts cs p)", "by metis"], ["", "lemma TC_vars_for_consts:\n  fixes G :: \\<open>('a, 'b) form list\\<close>\n  assumes \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<stileturn> G \\<Longrightarrow> \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> G \\<Longrightarrow>\n    \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G", "proof (induct cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<stileturn> G \\<Longrightarrow>\n    \\<stileturn> map (\\<lambda>p. vars_for_consts p []) G\n 2. \\<And>a cs.\n       \\<lbrakk>\\<stileturn> G \\<Longrightarrow>\n                \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G;\n        \\<stileturn> G\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map\n (\\<lambda>p. vars_for_consts p (a # cs)) G", "case Nil"], ["proof (state)\nthis:\n  \\<stileturn> G\n\ngoal (2 subgoals):\n 1. \\<stileturn> G \\<Longrightarrow>\n    \\<stileturn> map (\\<lambda>p. vars_for_consts p []) G\n 2. \\<And>a cs.\n       \\<lbrakk>\\<stileturn> G \\<Longrightarrow>\n                \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G;\n        \\<stileturn> G\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map\n (\\<lambda>p. vars_for_consts p (a # cs)) G", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> G", "show ?case"], ["proof (prove)\nusing this:\n  \\<stileturn> G\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (\\<lambda>p. vars_for_consts p []) G", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> map (\\<lambda>p. vars_for_consts p []) G\n\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<stileturn> G \\<Longrightarrow>\n                \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G;\n        \\<stileturn> G\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map\n (\\<lambda>p. vars_for_consts p (a # cs)) G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<stileturn> G \\<Longrightarrow>\n                \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G;\n        \\<stileturn> G\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map\n (\\<lambda>p. vars_for_consts p (a # cs)) G", "case (Cons c cs)"], ["proof (state)\nthis:\n  \\<stileturn> G \\<Longrightarrow>\n  \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G\n  \\<stileturn> G\n\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<stileturn> G \\<Longrightarrow>\n                \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G;\n        \\<stileturn> G\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map\n (\\<lambda>p. vars_for_consts p (a # cs)) G", "have \\<open>(\\<stileturn> map (\\<lambda>p. vars_for_consts p (c # cs)) G) =\n      (\\<stileturn> map (\\<lambda>p. subc c (Var (length cs)) (vars_for_consts p cs)) G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<stileturn> map (\\<lambda>p. vars_for_consts p (c # cs)) G) =\n    (\\<stileturn> map (\\<lambda>p.\n                          subc c (Var (length cs)) (vars_for_consts p cs))\n                   G)", "by simp"], ["proof (state)\nthis:\n  (\\<stileturn> map (\\<lambda>p. vars_for_consts p (c # cs)) G) =\n  (\\<stileturn> map (\\<lambda>p.\n                        subc c (Var (length cs)) (vars_for_consts p cs))\n                 G)\n\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<stileturn> G \\<Longrightarrow>\n                \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G;\n        \\<stileturn> G\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map\n (\\<lambda>p. vars_for_consts p (a # cs)) G", "also"], ["proof (state)\nthis:\n  (\\<stileturn> map (\\<lambda>p. vars_for_consts p (c # cs)) G) =\n  (\\<stileturn> map (\\<lambda>p.\n                        subc c (Var (length cs)) (vars_for_consts p cs))\n                 G)\n\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<stileturn> G \\<Longrightarrow>\n                \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G;\n        \\<stileturn> G\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map\n (\\<lambda>p. vars_for_consts p (a # cs)) G", "have \\<open>\\<dots> = (\\<stileturn> map (subc c (Var (length cs)) o (\\<lambda>p. vars_for_consts p cs)) G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<stileturn> map (\\<lambda>p.\n                          subc c (Var (length cs)) (vars_for_consts p cs))\n                   G) =\n    (\\<stileturn> map (subc c (Var (length cs)) \\<circ>\n                       (\\<lambda>p. vars_for_consts p cs))\n                   G)", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<stileturn> map (\\<lambda>p.\n                          subc c (Var (length cs)) (vars_for_consts p cs))\n                   G) =\n    (\\<stileturn> map (\\<lambda>x.\n                          subc c (Var (length cs)) (vars_for_consts x cs))\n                   G)", "by simp"], ["proof (state)\nthis:\n  (\\<stileturn> map (\\<lambda>p.\n                        subc c (Var (length cs)) (vars_for_consts p cs))\n                 G) =\n  (\\<stileturn> map (subc c (Var (length cs)) \\<circ>\n                     (\\<lambda>p. vars_for_consts p cs))\n                 G)\n\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<stileturn> G \\<Longrightarrow>\n                \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G;\n        \\<stileturn> G\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map\n (\\<lambda>p. vars_for_consts p (a # cs)) G", "also"], ["proof (state)\nthis:\n  (\\<stileturn> map (\\<lambda>p.\n                        subc c (Var (length cs)) (vars_for_consts p cs))\n                 G) =\n  (\\<stileturn> map (subc c (Var (length cs)) \\<circ>\n                     (\\<lambda>p. vars_for_consts p cs))\n                 G)\n\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<stileturn> G \\<Longrightarrow>\n                \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G;\n        \\<stileturn> G\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map\n (\\<lambda>p. vars_for_consts p (a # cs)) G", "have \\<open>\\<dots> = (\\<stileturn> map (subc c (Var (length cs))) (map (\\<lambda>p. vars_for_consts p cs) G))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<stileturn> map (subc c (Var (length cs)) \\<circ>\n                       (\\<lambda>p. vars_for_consts p cs))\n                   G) =\n    (\\<stileturn> map (subc c (Var (length cs)))\n                   (map (\\<lambda>p. vars_for_consts p cs) G))", "by simp"], ["proof (state)\nthis:\n  (\\<stileturn> map (subc c (Var (length cs)) \\<circ>\n                     (\\<lambda>p. vars_for_consts p cs))\n                 G) =\n  (\\<stileturn> map (subc c (Var (length cs)))\n                 (map (\\<lambda>p. vars_for_consts p cs) G))\n\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<stileturn> G \\<Longrightarrow>\n                \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G;\n        \\<stileturn> G\\<rbrakk>\n       \\<Longrightarrow> \\<stileturn> map\n (\\<lambda>p. vars_for_consts p (a # cs)) G", "finally"], ["proof (chain)\npicking this:\n  (\\<stileturn> map (\\<lambda>p. vars_for_consts p (c # cs)) G) =\n  (\\<stileturn> map (subc c (Var (length cs)))\n                 (map (\\<lambda>p. vars_for_consts p cs) G))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<stileturn> map (\\<lambda>p. vars_for_consts p (c # cs)) G) =\n  (\\<stileturn> map (subc c (Var (length cs)))\n                 (map (\\<lambda>p. vars_for_consts p cs) G))\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (\\<lambda>p. vars_for_consts p (c # cs)) G", "using Cons TC_map_subc assms"], ["proof (prove)\nusing this:\n  (\\<stileturn> map (\\<lambda>p. vars_for_consts p (c # cs)) G) =\n  (\\<stileturn> map (subc c (Var (length cs)))\n                 (map (\\<lambda>p. vars_for_consts p cs) G))\n  \\<stileturn> G \\<Longrightarrow>\n  \\<stileturn> map (\\<lambda>p. vars_for_consts p cs) G\n  \\<stileturn> G\n  \\<lbrakk>infinite UNIV; \\<stileturn> ?G\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> map (subc ?c ?s) ?G\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (\\<lambda>p. vars_for_consts p (c # cs)) G", "by metis"], ["proof (state)\nthis:\n  \\<stileturn> map (\\<lambda>p. vars_for_consts p (c # cs)) G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_for_consts_sub_consts:\n  \\<open>closed (length cs) p \\<Longrightarrow> list_all (\\<lambda>c. new c p) cs \\<Longrightarrow> distinct cs \\<Longrightarrow>\n   vars_for_consts (sub_consts cs p) cs = p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed (length cs) p; list_all (\\<lambda>c. new c p) cs;\n     distinct cs\\<rbrakk>\n    \\<Longrightarrow> vars_for_consts (sub_consts cs p) cs = p", "proof (induct cs arbitrary: p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>closed (length []) p; list_all (\\<lambda>c. new c p) [];\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> vars_for_consts (sub_consts [] p) [] = p\n 2. \\<And>a cs p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>closed (length cs) p;\n                    list_all (\\<lambda>c. new c p) cs; distinct cs\\<rbrakk>\n                   \\<Longrightarrow> vars_for_consts (sub_consts cs p) cs =\n                                     p;\n        closed (length (a # cs)) p; list_all (\\<lambda>c. new c p) (a # cs);\n        distinct (a # cs)\\<rbrakk>\n       \\<Longrightarrow> vars_for_consts (sub_consts (a # cs) p) (a # cs) =\n                         p", "case (Cons c cs)"], ["proof (state)\nthis:\n  \\<lbrakk>closed (length cs) ?p; list_all (\\<lambda>c. new c ?p) cs;\n   distinct cs\\<rbrakk>\n  \\<Longrightarrow> vars_for_consts (sub_consts cs ?p) cs = ?p\n  closed (length (c # cs)) p\n  list_all (\\<lambda>c. new c p) (c # cs)\n  distinct (c # cs)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>closed (length []) p; list_all (\\<lambda>c. new c p) [];\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> vars_for_consts (sub_consts [] p) [] = p\n 2. \\<And>a cs p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>closed (length cs) p;\n                    list_all (\\<lambda>c. new c p) cs; distinct cs\\<rbrakk>\n                   \\<Longrightarrow> vars_for_consts (sub_consts cs p) cs =\n                                     p;\n        closed (length (a # cs)) p; list_all (\\<lambda>c. new c p) (a # cs);\n        distinct (a # cs)\\<rbrakk>\n       \\<Longrightarrow> vars_for_consts (sub_consts (a # cs) p) (a # cs) =\n                         p", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>closed (length cs) ?p; list_all (\\<lambda>c. new c ?p) cs;\n   distinct cs\\<rbrakk>\n  \\<Longrightarrow> vars_for_consts (sub_consts cs ?p) cs = ?p\n  closed (length (c # cs)) p\n  list_all (\\<lambda>c. new c p) (c # cs)\n  distinct (c # cs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed (length cs) ?p; list_all (\\<lambda>c. new c ?p) cs;\n   distinct cs\\<rbrakk>\n  \\<Longrightarrow> vars_for_consts (sub_consts cs ?p) cs = ?p\n  closed (length (c # cs)) p\n  list_all (\\<lambda>c. new c p) (c # cs)\n  distinct (c # cs)\n\ngoal (1 subgoal):\n 1. vars_for_consts (sub_consts (c # cs) p) (c # cs) = p", "using subst_new_all closed_sub"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed (length cs) ?p; list_all (\\<lambda>c. new c ?p) cs;\n   distinct cs\\<rbrakk>\n  \\<Longrightarrow> vars_for_consts (sub_consts cs ?p) cs = ?p\n  closed (length (c # cs)) p\n  list_all (\\<lambda>c. new c p) (c # cs)\n  distinct (c # cs)\n  \\<lbrakk>?a \\<notin> set ?cs; list_all (\\<lambda>c. new c ?p) ?cs\\<rbrakk>\n  \\<Longrightarrow> list_all (\\<lambda>c. new c (?p[App ?a []/?m])) ?cs\n  ?k \\<le> ?m \\<Longrightarrow>\n  closed (Suc ?m) ?p = closed ?m (?p[App ?c []/?k])\n\ngoal (1 subgoal):\n 1. vars_for_consts (sub_consts (c # cs) p) (c # cs) = p", "by force"], ["proof (state)\nthis:\n  vars_for_consts (sub_consts (c # cs) p) (c # cs) = p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>closed (length []) p; list_all (\\<lambda>c. new c p) [];\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> vars_for_consts (sub_consts [] p) [] = p", "qed simp"], ["", "lemma all_vars_for_consts_sub_consts:\n  \\<open>list_all (closed (length cs)) G \\<Longrightarrow> list_all (\\<lambda>c. list_all (new c) G) cs \\<Longrightarrow> distinct cs \\<Longrightarrow>\n   map (\\<lambda>p. vars_for_consts p cs) (map (sub_consts cs) G) = G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (closed (length cs)) G;\n     list_all (\\<lambda>c. news c G) cs; distinct cs\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>p. vars_for_consts p cs)\n                       (map (sub_consts cs) G) =\n                      G", "using vars_for_consts_sub_consts"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed (length ?cs) ?p; list_all (\\<lambda>c. new c ?p) ?cs;\n   distinct ?cs\\<rbrakk>\n  \\<Longrightarrow> vars_for_consts (sub_consts ?cs ?p) ?cs = ?p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (closed (length cs)) G;\n     list_all (\\<lambda>c. news c G) cs; distinct cs\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>p. vars_for_consts p cs)\n                       (map (sub_consts cs) G) =\n                      G", "unfolding list_all_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed (length ?cs) ?p; \\<forall>c\\<in>set ?cs. new c ?p;\n   distinct ?cs\\<rbrakk>\n  \\<Longrightarrow> vars_for_consts (sub_consts ?cs ?p) ?cs = ?p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball (set G) (closed (length cs));\n     \\<forall>c\\<in>set cs. \\<forall>p\\<in>set G. new c p;\n     distinct cs\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>p. vars_for_consts p cs)\n                       (map (sub_consts cs) G) =\n                      G", "by (induct G) fastforce+"], ["", "lemma new_conjoin: \\<open>new c (conjoin G) \\<Longrightarrow> list_all (new c) G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new c (conjoin G) \\<Longrightarrow> news c G", "by (induct G) simp_all"], ["", "lemma all_fresh_constants:\n  fixes G :: \\<open>('a, 'b) form list\\<close>\n  assumes \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<exists>cs. length cs = m \\<and> list_all (\\<lambda>c. list_all (new c) G) cs \\<and> distinct cs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       length cs = m \\<and>\n       list_all (\\<lambda>c. news c G) cs \\<and> distinct cs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       length cs = m \\<and>\n       list_all (\\<lambda>c. news c G) cs \\<and> distinct cs", "obtain cs where \\<open>length cs = m\\<close> \\<open>list_all (\\<lambda>c. new c (conjoin G)) cs\\<close> \\<open>distinct cs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>length cs = m; list_all (\\<lambda>c. new c (conjoin G)) cs;\n         distinct cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms fresh_constants"], ["proof (prove)\nusing this:\n  infinite UNIV\n  infinite UNIV \\<Longrightarrow>\n  \\<exists>cs.\n     length cs = ?m \\<and>\n     list_all (\\<lambda>c. new c ?p) cs \\<and> distinct cs\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>length cs = m; list_all (\\<lambda>c. new c (conjoin G)) cs;\n         distinct cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length cs = m\n  list_all (\\<lambda>c. new c (conjoin G)) cs\n  distinct cs\n\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       length cs = m \\<and>\n       list_all (\\<lambda>c. news c G) cs \\<and> distinct cs", "then"], ["proof (chain)\npicking this:\n  length cs = m\n  list_all (\\<lambda>c. new c (conjoin G)) cs\n  distinct cs", "show ?thesis"], ["proof (prove)\nusing this:\n  length cs = m\n  list_all (\\<lambda>c. new c (conjoin G)) cs\n  distinct cs\n\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       length cs = m \\<and>\n       list_all (\\<lambda>c. news c G) cs \\<and> distinct cs", "using new_conjoin"], ["proof (prove)\nusing this:\n  length cs = m\n  list_all (\\<lambda>c. new c (conjoin G)) cs\n  distinct cs\n  new ?c (conjoin ?G) \\<Longrightarrow> news ?c ?G\n\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       length cs = m \\<and>\n       list_all (\\<lambda>c. news c G) cs \\<and> distinct cs", "unfolding list_all_def"], ["proof (prove)\nusing this:\n  length cs = m\n  \\<forall>c\\<in>set cs. new c (conjoin G)\n  distinct cs\n  new ?c (conjoin ?G) \\<Longrightarrow> \\<forall>p\\<in>set ?G. new ?c p\n\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       length cs = m \\<and>\n       (\\<forall>c\\<in>set cs. \\<forall>p\\<in>set G. new c p) \\<and>\n       distinct cs", "by metis"], ["proof (state)\nthis:\n  \\<exists>cs.\n     length cs = m \\<and>\n     list_all (\\<lambda>c. news c G) cs \\<and> distinct cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sub_consts_Neg: \\<open>sub_consts cs (Neg p) = Neg (sub_consts cs p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sub_consts cs (Neg p) = Neg (sub_consts cs p)", "by (induct cs arbitrary: p) simp_all"], ["", "subsection \\<open>Completeness\\<close>"], ["", "theorem tableau_completeness:\n  fixes G :: \\<open>(nat, nat) form list\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. list_all (eval e f g) G \\<longrightarrow> eval e f g p\\<close>\n  shows \\<open>tableauproof G p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. tableauproof G p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tableauproof G p", "obtain m where *: \\<open>list_all (closed m) (p # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        list_all (closed m) (p # G) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_all_closed"], ["proof (prove)\nusing this:\n  \\<exists>m. list_all (closed m) ?G\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        list_all (closed m) (p # G) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  list_all (closed m) (p # G)\n\ngoal (1 subgoal):\n 1. tableauproof G p", "moreover"], ["proof (state)\nthis:\n  list_all (closed m) (p # G)\n\ngoal (1 subgoal):\n 1. tableauproof G p", "obtain cs where **:\n    \\<open>length cs = m\\<close>\n    \\<open>distinct cs\\<close>\n    \\<open>list_all (\\<lambda>c. list_all (new c) (p # G)) cs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>length cs = m; distinct cs;\n         list_all (\\<lambda>c. news c (p # G)) cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using all_fresh_constants"], ["proof (prove)\nusing this:\n  infinite UNIV \\<Longrightarrow>\n  \\<exists>cs.\n     length cs = ?m \\<and>\n     list_all (\\<lambda>c. news c ?G) cs \\<and> distinct cs\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>length cs = m; distinct cs;\n         list_all (\\<lambda>c. news c (p # G)) cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length cs = m\n  distinct cs\n  list_all (\\<lambda>c. news c (p # G)) cs\n\ngoal (1 subgoal):\n 1. tableauproof G p", "ultimately"], ["proof (chain)\npicking this:\n  list_all (closed m) (p # G)\n  length cs = m\n  distinct cs\n  list_all (\\<lambda>c. news c (p # G)) cs", "have \\<open>closed 0 (sub_consts cs p)\\<close>"], ["proof (prove)\nusing this:\n  list_all (closed m) (p # G)\n  length cs = m\n  distinct cs\n  list_all (\\<lambda>c. news c (p # G)) cs\n\ngoal (1 subgoal):\n 1. closed 0 (sub_consts cs p)", "using closed_sub_consts"], ["proof (prove)\nusing this:\n  list_all (closed m) (p # G)\n  length cs = m\n  distinct cs\n  list_all (\\<lambda>c. news c (p # G)) cs\n  length ?cs = ?k \\<Longrightarrow>\n  closed ?m (sub_consts ?cs ?p) = closed (?m + ?k) ?p\n\ngoal (1 subgoal):\n 1. closed 0 (sub_consts cs p)", "by fastforce"], ["proof (state)\nthis:\n  closed 0 (sub_consts cs p)\n\ngoal (1 subgoal):\n 1. tableauproof G p", "moreover"], ["proof (state)\nthis:\n  closed 0 (sub_consts cs p)\n\ngoal (1 subgoal):\n 1. tableauproof G p", "have \\<open>list_all (closed 0) (map (sub_consts cs) G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (closed 0) (map (sub_consts cs) G)", "using closed_sub_consts * \\<open>length cs = m\\<close>"], ["proof (prove)\nusing this:\n  length ?cs = ?k \\<Longrightarrow>\n  closed ?m (sub_consts ?cs ?p) = closed (?m + ?k) ?p\n  list_all (closed m) (p # G)\n  length cs = m\n\ngoal (1 subgoal):\n 1. list_all (closed 0) (map (sub_consts cs) G)", "by (induct G) fastforce+"], ["proof (state)\nthis:\n  list_all (closed 0) (map (sub_consts cs) G)\n\ngoal (1 subgoal):\n 1. tableauproof G p", "moreover"], ["proof (state)\nthis:\n  list_all (closed 0) (map (sub_consts cs) G)\n\ngoal (1 subgoal):\n 1. tableauproof G p", "have \\<open>\\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. list_all (eval e f g) (map (sub_consts cs) G) \\<longrightarrow>\n    eval e f g (sub_consts cs p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e f g.\n       list_all (eval e f g) (map (sub_consts cs) G) \\<longrightarrow>\n       eval e f g (sub_consts cs p)", "using assms valid_all_sub_consts"], ["proof (prove)\nusing this:\n  \\<forall>e f g. list_all (eval e f g) G \\<longrightarrow> eval e f g p\n  \\<forall>e f g.\n     list_all (eval e f g) ?G \\<longrightarrow>\n     eval e f g ?p \\<Longrightarrow>\n  list_all (eval ?e ?f ?g) (map (sub_consts ?cs) ?G) \\<longrightarrow>\n  eval ?e ?f ?g (sub_consts ?cs ?p)\n\ngoal (1 subgoal):\n 1. \\<forall>e f g.\n       list_all (eval e f g) (map (sub_consts cs) G) \\<longrightarrow>\n       eval e f g (sub_consts cs p)", "by blast"], ["proof (state)\nthis:\n  \\<forall>e f g.\n     list_all (eval e f g) (map (sub_consts cs) G) \\<longrightarrow>\n     eval e f g (sub_consts cs p)\n\ngoal (1 subgoal):\n 1. tableauproof G p", "ultimately"], ["proof (chain)\npicking this:\n  closed 0 (sub_consts cs p)\n  list_all (closed 0) (map (sub_consts cs) G)\n  \\<forall>e f g.\n     list_all (eval e f g) (map (sub_consts cs) G) \\<longrightarrow>\n     eval e f g (sub_consts cs p)", "have \\<open>\\<stileturn> Neg (sub_consts cs p) # map (sub_consts cs) G\\<close>"], ["proof (prove)\nusing this:\n  closed 0 (sub_consts cs p)\n  list_all (closed 0) (map (sub_consts cs) G)\n  \\<forall>e f g.\n     list_all (eval e f g) (map (sub_consts cs) G) \\<longrightarrow>\n     eval e f g (sub_consts cs p)\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg (sub_consts cs p) # map (sub_consts cs) G", "using tableau_completeness'"], ["proof (prove)\nusing this:\n  closed 0 (sub_consts cs p)\n  list_all (closed 0) (map (sub_consts cs) G)\n  \\<forall>e f g.\n     list_all (eval e f g) (map (sub_consts cs) G) \\<longrightarrow>\n     eval e f g (sub_consts cs p)\n  \\<lbrakk>closed 0 ?p; list_all (closed 0) ?ps;\n   \\<forall>e f g.\n      list_all (eval e f g) ?ps \\<longrightarrow> eval e f g ?p\\<rbrakk>\n  \\<Longrightarrow> tableauproof ?ps ?p\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg (sub_consts cs p) # map (sub_consts cs) G", "unfolding tableauproof_def"], ["proof (prove)\nusing this:\n  closed 0 (sub_consts cs p)\n  list_all (closed 0) (map (sub_consts cs) G)\n  \\<forall>e f g.\n     list_all (eval e f g) (map (sub_consts cs) G) \\<longrightarrow>\n     eval e f g (sub_consts cs p)\n  \\<lbrakk>closed 0 ?p; list_all (closed 0) ?ps;\n   \\<forall>e f g.\n      list_all (eval e f g) ?ps \\<longrightarrow> eval e f g ?p\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> Neg ?p # ?ps\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg (sub_consts cs p) # map (sub_consts cs) G", "by simp"], ["proof (state)\nthis:\n  \\<stileturn> Neg (sub_consts cs p) # map (sub_consts cs) G\n\ngoal (1 subgoal):\n 1. tableauproof G p", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> Neg (sub_consts cs p) # map (sub_consts cs) G", "have \\<open>\\<stileturn> map (sub_consts cs) (Neg p # G)\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> Neg (sub_consts cs p) # map (sub_consts cs) G\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (sub_consts cs) (Neg p # G)", "by (simp add: sub_consts_Neg)"], ["proof (state)\nthis:\n  \\<stileturn> map (sub_consts cs) (Neg p # G)\n\ngoal (1 subgoal):\n 1. tableauproof G p", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> map (sub_consts cs) (Neg p # G)", "have \\<open>\\<stileturn> map (\\<lambda>p. vars_for_consts p cs) (map (sub_consts cs) (Neg p # G))\\<close>"], ["proof (prove)\nusing this:\n  \\<stileturn> map (sub_consts cs) (Neg p # G)\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (\\<lambda>p. vars_for_consts p cs)\n                  (map (sub_consts cs) (Neg p # G))", "using TC_vars_for_consts"], ["proof (prove)\nusing this:\n  \\<stileturn> map (sub_consts cs) (Neg p # G)\n  \\<lbrakk>infinite UNIV; \\<stileturn> ?G\\<rbrakk>\n  \\<Longrightarrow> \\<stileturn> map (\\<lambda>p. vars_for_consts p ?cs) ?G\n\ngoal (1 subgoal):\n 1. \\<stileturn> map (\\<lambda>p. vars_for_consts p cs)\n                  (map (sub_consts cs) (Neg p # G))", "by blast"], ["proof (state)\nthis:\n  \\<stileturn> map (\\<lambda>p. vars_for_consts p cs)\n                (map (sub_consts cs) (Neg p # G))\n\ngoal (1 subgoal):\n 1. tableauproof G p", "then"], ["proof (chain)\npicking this:\n  \\<stileturn> map (\\<lambda>p. vars_for_consts p cs)\n                (map (sub_consts cs) (Neg p # G))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<stileturn> map (\\<lambda>p. vars_for_consts p cs)\n                (map (sub_consts cs) (Neg p # G))\n\ngoal (1 subgoal):\n 1. tableauproof G p", "unfolding tableauproof_def"], ["proof (prove)\nusing this:\n  \\<stileturn> map (\\<lambda>p. vars_for_consts p cs)\n                (map (sub_consts cs) (Neg p # G))\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg p # G", "using all_vars_for_consts_sub_consts[where G=\\<open>Neg p # G\\<close>] * **"], ["proof (prove)\nusing this:\n  \\<stileturn> map (\\<lambda>p. vars_for_consts p cs)\n                (map (sub_consts cs) (Neg p # G))\n  \\<lbrakk>list_all (closed (length ?cs)) (Neg p # G);\n   list_all (\\<lambda>c. news c (Neg p # G)) ?cs; distinct ?cs\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>p. vars_for_consts p ?cs)\n                     (map (sub_consts ?cs) (Neg p # G)) =\n                    Neg p # G\n  list_all (closed m) (p # G)\n  length cs = m\n  distinct cs\n  list_all (\\<lambda>c. news c (p # G)) cs\n\ngoal (1 subgoal):\n 1. \\<stileturn> Neg p # G", "by simp"], ["proof (state)\nthis:\n  tableauproof G p\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary\n  fixes p :: \\<open>(nat, nat) form\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. eval e f g p\\<close>\n  shows \\<open>\\<stileturn> [Neg p]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<stileturn> [Neg p]", "using assms tableau_completeness"], ["proof (prove)\nusing this:\n  valid p\n  \\<forall>e f g.\n     list_all (eval e f g) ?G \\<longrightarrow>\n     eval e f g ?p \\<Longrightarrow>\n  tableauproof ?G ?p\n\ngoal (1 subgoal):\n 1. \\<stileturn> [Neg p]", "unfolding tableauproof_def"], ["proof (prove)\nusing this:\n  valid p\n  \\<forall>e f g.\n     list_all (eval e f g) ?G \\<longrightarrow>\n     eval e f g ?p \\<Longrightarrow>\n  \\<stileturn> Neg ?p # ?G\n\ngoal (1 subgoal):\n 1. \\<stileturn> [Neg p]", "by simp"], ["", "end"]]}