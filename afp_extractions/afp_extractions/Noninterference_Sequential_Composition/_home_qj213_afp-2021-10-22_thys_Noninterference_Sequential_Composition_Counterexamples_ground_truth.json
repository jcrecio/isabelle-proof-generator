{"file_name": "/home/qj213/afp-2021-10-22/thys/Noninterference_Sequential_Composition/Counterexamples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Noninterference_Sequential_Composition", "problem_names": ["lemma trace_set_snd:\n \"trace_set {[], [Some b]}\"", "lemmas failures_snd = ts_process_failures [OF trace_set_snd]", "lemmas traces_snd = ts_process_traces [OF trace_set_snd]", "lemmas next_events_snd = ts_process_next_events [OF trace_set_snd]", "lemmas unwinding_snd = ts_ipurge_unwinding [OF trace_set_snd]", "lemma trace_set_fst_1:\n \"trace_set {[], [Some a], [Some a, None]}\"", "lemmas failures_fst_1 = ts_process_failures [OF trace_set_fst_1]", "lemmas traces_fst_1 = ts_process_traces [OF trace_set_fst_1]", "lemmas next_events_fst_1 = ts_process_next_events [OF trace_set_fst_1]", "lemmas unwinding_fst_1 = ts_ipurge_unwinding [OF trace_set_fst_1]", "lemma not_secure_termination_1:\n \"\\<not> secure_termination I\\<^sub>1 id\"", "lemma ref_union_closed_fst_1:\n \"ref_union_closed P\\<^sub>1\"", "lemma sequential_fst_1:\n \"sequential P\\<^sub>1\"", "lemma secure_fst_1:\n \"secure P\\<^sub>1 I\\<^sub>1 id\"", "lemma secure_snd_1:\n \"secure Q I\\<^sub>1 id\"", "lemma traces_comp_1:\n \"traces (P\\<^sub>1 ; Q) = Domain (seq_comp_failures P\\<^sub>1 Q)\"", "lemma ref_union_closed_comp_1:\n \"ref_union_closed (P\\<^sub>1 ; Q)\"", "lemma not_secure_comp_1_aux_aux_1:\n \"(xs, X) \\<in> seq_comp_failures P\\<^sub>1 Q \\<Longrightarrow> xs \\<noteq> [Some b]\"", "lemma not_secure_comp_1_aux_1:\n \"[Some b] \\<notin> traces (P\\<^sub>1 ; Q)\"", "lemma not_secure_comp_1_aux_2:\n \"[Some a, Some b] \\<in> traces (P\\<^sub>1 ; Q)\"", "lemma not_secure_comp_1:\n \"\\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id\"", "lemma counterexample_1:\n \"\\<not> (ref_union_closed P\\<^sub>1 \\<and>\n     sequential P\\<^sub>1 \\<and>\n     secure P\\<^sub>1 I\\<^sub>1 id \\<and>\n     secure Q I\\<^sub>1 id \\<longrightarrow>\n   secure (P\\<^sub>1 ; Q) I\\<^sub>1 id)\"", "lemma trace_set_fst_2:\n \"trace_set {[], [None], [Some a], [Some a, None]}\"", "lemmas failures_fst_2 = ts_process_failures [OF trace_set_fst_2]", "lemmas traces_fst_2 = ts_process_traces [OF trace_set_fst_2]", "lemmas next_events_fst_2 = ts_process_next_events [OF trace_set_fst_2]", "lemmas unwinding_fst_2 = ts_ipurge_unwinding [OF trace_set_fst_2]", "lemma secure_termination_2:\n \"secure_termination I\\<^sub>2 id\"", "lemma ref_union_closed_fst_2:\n \"ref_union_closed P\\<^sub>2\"", "lemma weakly_sequential_fst_2:\n \"weakly_sequential P\\<^sub>2\"", "lemma not_sequential_fst_2:\n \"\\<not> sequential P\\<^sub>2\"", "lemma secure_fst_2:\n \"secure P\\<^sub>2 I\\<^sub>2 id\"", "lemma secure_snd_2:\n \"secure Q I\\<^sub>2 id\"", "lemma traces_comp_2:\n \"traces (P\\<^sub>2 ; Q) = Domain (seq_comp_failures P\\<^sub>2 Q)\"", "lemma ref_union_closed_comp_2:\n \"ref_union_closed (P\\<^sub>2 ; Q)\"", "lemma not_secure_comp_2_aux_aux_1:\n \"(xs, X) \\<in> seq_comp_failures P\\<^sub>2 Q \\<Longrightarrow> xs \\<noteq> [Some b, Some a]\"", "lemma not_secure_comp_2_aux_1:\n \"[Some b, Some a] \\<notin> traces (P\\<^sub>2 ; Q)\"", "lemma not_secure_comp_2_aux_2:\n \"[Some a] \\<in> traces (P\\<^sub>2 ; Q)\"", "lemma not_secure_comp_2_aux_3:\n \"[Some b] \\<in> traces (P\\<^sub>2 ; Q)\"", "lemma not_secure_comp_2:\n \"\\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id\"", "lemma counterexample_2:\n \"\\<not> (secure_termination I\\<^sub>2 id \\<and>\n     ref_union_closed P\\<^sub>2 \\<and>\n     weakly_sequential P\\<^sub>2 \\<and>\n     secure P\\<^sub>2 I\\<^sub>2 id \\<and>\n     secure Q I\\<^sub>2 id \\<longrightarrow>\n   secure (P\\<^sub>2 ; Q) I\\<^sub>2 id)\""], "translations": [["", "lemma trace_set_snd:\n \"trace_set {[], [Some b]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_set {[], [Some b]}", "by (simp add: trace_set_def)"], ["", "lemmas failures_snd = ts_process_failures [OF trace_set_snd]"], ["", "lemmas traces_snd = ts_process_traces [OF trace_set_snd]"], ["", "lemmas next_events_snd = ts_process_next_events [OF trace_set_snd]"], ["", "lemmas unwinding_snd = ts_ipurge_unwinding [OF trace_set_snd]"], ["", "subsection \"Necessity of termination security\""], ["", "text \\<open>\nThe reason why the conservation of noninterference security under sequential composition requires\nthe security policy to satisfy predicate @{term secure_termination} is that the second input process\ncannot engage in its events unless the first process has terminated successfully. Thus, the ordinary\nevents of the first process can indirectly affect the events of the second process by affecting the\nsuccessful termination of the first process. Therefore, if an ordinary event is allowed to affect\nsuccessful termination, then the policy must allow it to affect any other event as well, which is\nexactly what predicate @{term secure_termination} states.\n\nA counterexample showing the necessity of this assumption can then be constructed by defining a\nreflexive policy @{term I\\<^sub>1} that allows event @{term \"Some a\"} to affect @{term None}, but not\n@{term \"Some b\"}, and a deterministic process @{term P\\<^sub>1} that can engage in @{term None} only after\nengaging in @{term \"Some a\"}. The resulting process @{term \"P\\<^sub>1 ; Q\"} will number\n@{term \"[Some a, Some b]\"}, but not @{term \"[Some b]\"}, among its traces, so that event\n@{term \"Some a\"} affects the occurrence of event @{term \"Some b\"} in contrast with policy\n@{term I\\<^sub>1}, viz. @{term \"P\\<^sub>1 ; Q\"} is not secure with respect to @{term I\\<^sub>1}.\n\nHere below are the definitions of constants @{term I\\<^sub>1} and @{term P\\<^sub>1}, followed by few useful lemmas\non process @{term P\\<^sub>1}.\n\n\\null\n\\<close>"], ["", "definition I\\<^sub>1 :: \"(event option \\<times> event option) set\" where\n\"I\\<^sub>1 \\<equiv> {(Some a, None)}\\<^sup>=\""], ["", "definition P\\<^sub>1 :: \"event option process\" where\n\"P\\<^sub>1 \\<equiv> ts_process {[], [Some a], [Some a, None]}\""], ["", "lemma trace_set_fst_1:\n \"trace_set {[], [Some a], [Some a, None]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_set {[], [Some a], [Some a, None]}", "by (simp add: trace_set_def)"], ["", "lemmas failures_fst_1 = ts_process_failures [OF trace_set_fst_1]"], ["", "lemmas traces_fst_1 = ts_process_traces [OF trace_set_fst_1]"], ["", "lemmas next_events_fst_1 = ts_process_next_events [OF trace_set_fst_1]"], ["", "lemmas unwinding_fst_1 = ts_ipurge_unwinding [OF trace_set_fst_1]"], ["", "text \\<open>\n\\null\n\nHere below is the proof that policy @{term I\\<^sub>1} does not satisfy predicate\n@{term secure_termination}, whereas the remaining assumptions of the security conservation theorem\nkeep being satisfied. For the sake of simplicity, the identity function is used as event-domain map.\n\n\\null\n\\<close>"], ["", "lemma not_secure_termination_1:\n \"\\<not> secure_termination I\\<^sub>1 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> secure_termination I\\<^sub>1 id", "proof (simp add: secure_termination_def I\\<^sub>1_def, rule exI [where x = \"Some a\"],\n simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u. (\\<exists>y. u = Some y) \\<and> Some a \\<noteq> u", "qed (rule exI [where x = \"Some b\"], simp)"], ["", "lemma ref_union_closed_fst_1:\n \"ref_union_closed P\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref_union_closed P\\<^sub>1", "by (rule d_implies_ruc, subst P\\<^sub>1_def, rule ts_process_d, rule trace_set_fst_1)"], ["", "lemma sequential_fst_1:\n \"sequential P\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sequential P\\<^sub>1", "proof (simp add: sequential_def sentences_def P\\<^sub>1_def traces_fst_1)"], ["proof (state)\ngoal (1 subgoal):\n 1. next_events (ts_process {[], [Some a], [Some a, None]}) [Some a] =\n    {None}", "qed (simp add: set_eq_iff next_events_fst_1)"], ["", "lemma secure_fst_1:\n \"secure P\\<^sub>1 I\\<^sub>1 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure P\\<^sub>1 I\\<^sub>1 id", "proof (simp add: P\\<^sub>1_def unwinding_fst_1 dfc_equals_dwfc_rel_ipurge [symmetric]\n d_future_consistent_def rel_ipurge_def traces_fst_1, (rule allI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       next_dom_events (ts_process {[], [Some a], [Some a, None]}) id u xs =\n       next_dom_events (ts_process {[], [Some a], [Some a, None]}) id u ys", "fix u xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       next_dom_events (ts_process {[], [Some a], [Some a, None]}) id u xs =\n       next_dom_events (ts_process {[], [Some a], [Some a, None]}) id u ys", "show\n   \"(xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n    (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n    ipurge_tr_rev I\\<^sub>1 id u xs = ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n      next_dom_events (ts_process {[], [Some a], [Some a, None]}) id u xs =\n      next_dom_events (ts_process {[], [Some a], [Some a, None]}) id u ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n    (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n    ipurge_tr_rev I\\<^sub>1 id u xs =\n    ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n    next_dom_events (ts_process {[], [Some a], [Some a, None]}) id u xs =\n    next_dom_events (ts_process {[], [Some a], [Some a, None]}) id u ys", "proof (simp add: next_dom_events_def next_events_fst_1, cases u)"], ["proof (state)\ngoal (2 subgoals):\n 1. u = None \\<Longrightarrow>\n    (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n    (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n    ipurge_tr_rev I\\<^sub>1 id u xs =\n    ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n    {x. u = x \\<and>\n        (xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n    {x. u = x \\<and>\n        (ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}\n 2. \\<And>aa.\n       u = Some aa \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       {x. u = x \\<and>\n           (xs = [] \\<and> x = Some a \\<or>\n            xs = [Some a] \\<and> x = None)} =\n       {x. u = x \\<and>\n           (ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "case None"], ["proof (state)\nthis:\n  u = None\n\ngoal (2 subgoals):\n 1. u = None \\<Longrightarrow>\n    (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n    (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n    ipurge_tr_rev I\\<^sub>1 id u xs =\n    ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n    {x. u = x \\<and>\n        (xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n    {x. u = x \\<and>\n        (ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}\n 2. \\<And>aa.\n       u = Some aa \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       {x. u = x \\<and>\n           (xs = [] \\<and> x = Some a \\<or>\n            xs = [Some a] \\<and> x = None)} =\n       {x. u = x \\<and>\n           (ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "show\n     \"(xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n      (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n      ipurge_tr_rev I\\<^sub>1 id u xs = ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n        {x. u = x \\<and> (xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n        {x. u = x \\<and> (ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n    (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n    ipurge_tr_rev I\\<^sub>1 id u xs =\n    ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n    {x. u = x \\<and>\n        (xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n    {x. u = x \\<and>\n        (ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "by (simp add: I\\<^sub>1_def None, rule impI, (erule conjE)+,\n      (((erule disjE)+)?, simp)+)"], ["proof (state)\nthis:\n  (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n  (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n  ipurge_tr_rev I\\<^sub>1 id u xs =\n  ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n  {x. u = x \\<and>\n      (xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n  {x. u = x \\<and>\n      (ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       u = Some aa \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       {x. u = x \\<and>\n           (xs = [] \\<and> x = Some a \\<or>\n            xs = [Some a] \\<and> x = None)} =\n       {x. u = x \\<and>\n           (ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       u = Some aa \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       {x. u = x \\<and>\n           (xs = [] \\<and> x = Some a \\<or>\n            xs = [Some a] \\<and> x = None)} =\n       {x. u = x \\<and>\n           (ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "case (Some v)"], ["proof (state)\nthis:\n  u = Some v\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       u = Some aa \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       {x. u = x \\<and>\n           (xs = [] \\<and> x = Some a \\<or>\n            xs = [Some a] \\<and> x = None)} =\n       {x. u = x \\<and>\n           (ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "show\n     \"(xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n      (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n      ipurge_tr_rev I\\<^sub>1 id u xs = ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n        {x. u = x \\<and> (xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n        {x. u = x \\<and> (ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n    (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n    ipurge_tr_rev I\\<^sub>1 id u xs =\n    ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n    {x. u = x \\<and>\n        (xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n    {x. u = x \\<and>\n        (ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "by (simp add: I\\<^sub>1_def Some, rule impI, (erule conjE)+, cases v,\n      (((erule disjE)+)?, simp, blast?)+)"], ["proof (state)\nthis:\n  (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n  (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n  ipurge_tr_rev I\\<^sub>1 id u xs =\n  ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n  {x. u = x \\<and>\n      (xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n  {x. u = x \\<and>\n      (ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs = [] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n  (ys = [] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n  ipurge_tr_rev I\\<^sub>1 id u xs =\n  ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n  next_dom_events (ts_process {[], [Some a], [Some a, None]}) id u xs =\n  next_dom_events (ts_process {[], [Some a], [Some a, None]}) id u ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma secure_snd_1:\n \"secure Q I\\<^sub>1 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure Q I\\<^sub>1 id", "proof (simp add: Q_def unwinding_snd dfc_equals_dwfc_rel_ipurge [symmetric]\n d_future_consistent_def rel_ipurge_def traces_snd, (rule allI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       next_dom_events (ts_process {[], [Some b]}) id u xs =\n       next_dom_events (ts_process {[], [Some b]}) id u ys", "fix u xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       next_dom_events (ts_process {[], [Some b]}) id u xs =\n       next_dom_events (ts_process {[], [Some b]}) id u ys", "show\n   \"(xs = [] \\<or> xs = [Some b]) \\<and>\n    (ys = [] \\<or> ys = [Some b]) \\<and>\n    ipurge_tr_rev I\\<^sub>1 id u xs = ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n      next_dom_events (ts_process {[], [Some b]}) id u xs =\n      next_dom_events (ts_process {[], [Some b]}) id u ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = [] \\<or> xs = [Some b]) \\<and>\n    (ys = [] \\<or> ys = [Some b]) \\<and>\n    ipurge_tr_rev I\\<^sub>1 id u xs =\n    ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n    next_dom_events (ts_process {[], [Some b]}) id u xs =\n    next_dom_events (ts_process {[], [Some b]}) id u ys", "proof (simp add: next_dom_events_def next_events_snd, cases u)"], ["proof (state)\ngoal (2 subgoals):\n 1. u = None \\<Longrightarrow>\n    (xs = [] \\<or> xs = [Some b]) \\<and>\n    (ys = [] \\<or> ys = [Some b]) \\<and>\n    ipurge_tr_rev I\\<^sub>1 id u xs =\n    ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n    {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n    {x. u = x \\<and> ys = [] \\<and> x = Some b}\n 2. \\<And>a.\n       u = Some a \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n       {x. u = x \\<and> ys = [] \\<and> x = Some b}", "case None"], ["proof (state)\nthis:\n  u = None\n\ngoal (2 subgoals):\n 1. u = None \\<Longrightarrow>\n    (xs = [] \\<or> xs = [Some b]) \\<and>\n    (ys = [] \\<or> ys = [Some b]) \\<and>\n    ipurge_tr_rev I\\<^sub>1 id u xs =\n    ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n    {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n    {x. u = x \\<and> ys = [] \\<and> x = Some b}\n 2. \\<And>a.\n       u = Some a \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n       {x. u = x \\<and> ys = [] \\<and> x = Some b}", "show\n     \"(xs = [] \\<or> xs = [Some b]) \\<and>\n      (ys = [] \\<or> ys = [Some b]) \\<and>\n      ipurge_tr_rev I\\<^sub>1 id u xs = ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n        {x. u = x \\<and> xs = [] \\<and> x = Some b} = {x. u = x \\<and> ys = [] \\<and> x = Some b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = [] \\<or> xs = [Some b]) \\<and>\n    (ys = [] \\<or> ys = [Some b]) \\<and>\n    ipurge_tr_rev I\\<^sub>1 id u xs =\n    ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n    {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n    {x. u = x \\<and> ys = [] \\<and> x = Some b}", "by (simp add: None, rule impI, (erule conjE)+,\n      (((erule disjE)+)?, simp)+)"], ["proof (state)\nthis:\n  (xs = [] \\<or> xs = [Some b]) \\<and>\n  (ys = [] \\<or> ys = [Some b]) \\<and>\n  ipurge_tr_rev I\\<^sub>1 id u xs =\n  ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n  {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n  {x. u = x \\<and> ys = [] \\<and> x = Some b}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       u = Some a \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n       {x. u = x \\<and> ys = [] \\<and> x = Some b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       u = Some a \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n       {x. u = x \\<and> ys = [] \\<and> x = Some b}", "case (Some v)"], ["proof (state)\nthis:\n  u = Some v\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       u = Some a \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id u xs =\n       ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n       {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n       {x. u = x \\<and> ys = [] \\<and> x = Some b}", "show\n     \"(xs = [] \\<or> xs = [Some b]) \\<and>\n      (ys = [] \\<or> ys = [Some b]) \\<and>\n      ipurge_tr_rev I\\<^sub>1 id u xs = ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n        {x. u = x \\<and> xs = [] \\<and> x = Some b} = {x. u = x \\<and> ys = [] \\<and> x = Some b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = [] \\<or> xs = [Some b]) \\<and>\n    (ys = [] \\<or> ys = [Some b]) \\<and>\n    ipurge_tr_rev I\\<^sub>1 id u xs =\n    ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n    {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n    {x. u = x \\<and> ys = [] \\<and> x = Some b}", "by (simp add: I\\<^sub>1_def Some, rule impI, (erule conjE)+, cases v,\n      (((erule disjE)+)?, simp)+)"], ["proof (state)\nthis:\n  (xs = [] \\<or> xs = [Some b]) \\<and>\n  (ys = [] \\<or> ys = [Some b]) \\<and>\n  ipurge_tr_rev I\\<^sub>1 id u xs =\n  ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n  {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n  {x. u = x \\<and> ys = [] \\<and> x = Some b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs = [] \\<or> xs = [Some b]) \\<and>\n  (ys = [] \\<or> ys = [Some b]) \\<and>\n  ipurge_tr_rev I\\<^sub>1 id u xs =\n  ipurge_tr_rev I\\<^sub>1 id u ys \\<longrightarrow>\n  next_dom_events (ts_process {[], [Some b]}) id u xs =\n  next_dom_events (ts_process {[], [Some b]}) id u ys\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nIn what follows, the insecurity of process @{term \"P\\<^sub>1 ; Q\"} is demonstrated by proving that event\nlist @{term \"[Some a, Some b]\"} is a trace of the process, whereas @{term \"[Some b]\"} is not.\n\n\\null\n\\<close>"], ["", "lemma traces_comp_1:\n \"traces (P\\<^sub>1 ; Q) = Domain (seq_comp_failures P\\<^sub>1 Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traces (P\\<^sub>1 ; Q) = Domain (seq_comp_failures P\\<^sub>1 Q)", "by (subst seq_comp_traces, rule seq_implies_weakly_seq, rule sequential_fst_1, simp)"], ["", "lemma ref_union_closed_comp_1:\n \"ref_union_closed (P\\<^sub>1 ; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref_union_closed (P\\<^sub>1 ; Q)", "proof (rule seq_comp_ref_union_closed, rule seq_implies_weakly_seq,\n rule sequential_fst_1, rule ref_union_closed_fst_1)"], ["proof (state)\ngoal (1 subgoal):\n 1. ref_union_closed Q", "qed (rule d_implies_ruc, subst Q_def, rule ts_process_d, rule trace_set_snd)"], ["", "lemma not_secure_comp_1_aux_aux_1:\n \"(xs, X) \\<in> seq_comp_failures P\\<^sub>1 Q \\<Longrightarrow> xs \\<noteq> [Some b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, X) \\<in> seq_comp_failures P\\<^sub>1 Q \\<Longrightarrow>\n    xs \\<noteq> [Some b]", "proof (rule notI, erule rev_mp, erule seq_comp_failures.induct, (rule_tac [!] impI)+,\n simp_all add: P\\<^sub>1_def Q_def sentences_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs X.\n       \\<lbrakk>[Some b, None]\n                \\<notin> traces (ts_process {[], [Some a], [Some a, None]});\n        ([Some b], X)\n        \\<in> failures (ts_process {[], [Some a], [Some a, None]});\n        xs = [Some b]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xs X Y.\n       \\<lbrakk>[Some b, None]\n                \\<in> traces (ts_process {[], [Some a], [Some a, None]});\n        ([Some b], X)\n        \\<in> failures (ts_process {[], [Some a], [Some a, None]});\n        ([], Y) \\<in> failures (ts_process {[], [Some b]});\n        xs = [Some b]\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>xs ys Y.\n       \\<lbrakk>xs @ [None]\n                \\<in> traces (ts_process {[], [Some a], [Some a, None]});\n        (ys, Y) \\<in> failures (ts_process {[], [Some b]}); ys \\<noteq> [];\n        xs @ ys = [Some b]\\<rbrakk>\n       \\<Longrightarrow> False", "qed (simp_all add: failures_fst_1 traces_fst_1)"], ["", "lemma not_secure_comp_1_aux_1:\n \"[Some b] \\<notin> traces (P\\<^sub>1 ; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Some b] \\<notin> traces (P\\<^sub>1 ; Q)", "proof (simp add: traces_comp_1 Domain_iff, rule allI, rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ([Some b], y) \\<in> seq_comp_failures P\\<^sub>1 Q \\<Longrightarrow>\n       False", "qed (drule not_secure_comp_1_aux_aux_1, simp)"], ["", "lemma not_secure_comp_1_aux_2:\n \"[Some a, Some b] \\<in> traces (P\\<^sub>1 ; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Some a, Some b] \\<in> traces (P\\<^sub>1 ; Q)", "proof (simp add: traces_comp_1 Domain_iff, rule exI [where x = \"{}\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. ([Some a, Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q", "have \"[Some a] \\<in> sentences P\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Some a] \\<in> sentences P\\<^sub>1", "by (simp add: P\\<^sub>1_def sentences_def traces_fst_1)"], ["proof (state)\nthis:\n  [Some a] \\<in> sentences P\\<^sub>1\n\ngoal (1 subgoal):\n 1. ([Some a, Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q", "moreover"], ["proof (state)\nthis:\n  [Some a] \\<in> sentences P\\<^sub>1\n\ngoal (1 subgoal):\n 1. ([Some a, Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q", "have \"([Some b], {}) \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([Some b], {}) \\<in> failures Q", "by (simp add: Q_def failures_snd)"], ["proof (state)\nthis:\n  ([Some b], {}) \\<in> failures Q\n\ngoal (1 subgoal):\n 1. ([Some a, Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q", "moreover"], ["proof (state)\nthis:\n  ([Some b], {}) \\<in> failures Q\n\ngoal (1 subgoal):\n 1. ([Some a, Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q", "have \"[Some b] \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Some b] \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  [Some b] \\<noteq> []\n\ngoal (1 subgoal):\n 1. ([Some a, Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q", "ultimately"], ["proof (chain)\npicking this:\n  [Some a] \\<in> sentences P\\<^sub>1\n  ([Some b], {}) \\<in> failures Q\n  [Some b] \\<noteq> []", "have \"([Some a] @ [Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q\""], ["proof (prove)\nusing this:\n  [Some a] \\<in> sentences P\\<^sub>1\n  ([Some b], {}) \\<in> failures Q\n  [Some b] \\<noteq> []\n\ngoal (1 subgoal):\n 1. ([Some a] @ [Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q", "by (rule SCF_R3)"], ["proof (state)\nthis:\n  ([Some a] @ [Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q\n\ngoal (1 subgoal):\n 1. ([Some a, Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q", "thus \"([Some a, Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q\""], ["proof (prove)\nusing this:\n  ([Some a] @ [Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q\n\ngoal (1 subgoal):\n 1. ([Some a, Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q", "by simp"], ["proof (state)\nthis:\n  ([Some a, Some b], {}) \\<in> seq_comp_failures P\\<^sub>1 Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_secure_comp_1:\n \"\\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id", "proof (subst ipurge_unwinding, rule ref_union_closed_comp_1, simp\n add: fc_equals_wfc_rel_ipurge [symmetric] future_consistent_def rel_ipurge_def\n del: disj_not1, rule exI [where x = \"Some b\"], rule exI [where x = \"[]\"], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> traces (P\\<^sub>1 ; Q)\n 2. \\<exists>ys.\n       ys \\<in> traces (P\\<^sub>1 ; Q) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id (Some b) [] =\n       ipurge_tr_rev I\\<^sub>1 id (Some b) ys \\<and>\n       (next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n        next_dom_events (P\\<^sub>1 ; Q) id (Some b) ys \\<or>\n        ref_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n        ref_dom_events (P\\<^sub>1 ; Q) id (Some b) ys)", "show \"[] \\<in> traces (P\\<^sub>1 ; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> traces (P\\<^sub>1 ; Q)", "by (rule failures_traces [where X = \"{}\"], rule process_rule_1)"], ["proof (state)\nthis:\n  [] \\<in> traces (P\\<^sub>1 ; Q)\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       ys \\<in> traces (P\\<^sub>1 ; Q) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id (Some b) [] =\n       ipurge_tr_rev I\\<^sub>1 id (Some b) ys \\<and>\n       (next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n        next_dom_events (P\\<^sub>1 ; Q) id (Some b) ys \\<or>\n        ref_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n        ref_dom_events (P\\<^sub>1 ; Q) id (Some b) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       ys \\<in> traces (P\\<^sub>1 ; Q) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id (Some b) [] =\n       ipurge_tr_rev I\\<^sub>1 id (Some b) ys \\<and>\n       (next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n        next_dom_events (P\\<^sub>1 ; Q) id (Some b) ys \\<or>\n        ref_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n        ref_dom_events (P\\<^sub>1 ; Q) id (Some b) ys)", "show \"\\<exists>ys. ys \\<in> traces (P\\<^sub>1 ; Q) \\<and>\n    ipurge_tr_rev I\\<^sub>1 id (Some b) [] = ipurge_tr_rev I\\<^sub>1 id (Some b) ys \\<and>\n    (next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n       next_dom_events (P\\<^sub>1 ; Q) id (Some b) ys \\<or>\n     ref_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n       ref_dom_events (P\\<^sub>1 ; Q) id (Some b) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       ys \\<in> traces (P\\<^sub>1 ; Q) \\<and>\n       ipurge_tr_rev I\\<^sub>1 id (Some b) [] =\n       ipurge_tr_rev I\\<^sub>1 id (Some b) ys \\<and>\n       (next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n        next_dom_events (P\\<^sub>1 ; Q) id (Some b) ys \\<or>\n        ref_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n        ref_dom_events (P\\<^sub>1 ; Q) id (Some b) ys)", "proof (rule exI [where x = \"[Some a]\"], rule conjI, rule_tac [2] conjI,\n   rule_tac [3] disjI1)"], ["proof (state)\ngoal (3 subgoals):\n 1. [Some a] \\<in> traces (P\\<^sub>1 ; Q)\n 2. ipurge_tr_rev I\\<^sub>1 id (Some b) [] =\n    ipurge_tr_rev I\\<^sub>1 id (Some b) [Some a]\n 3. next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n    next_dom_events (P\\<^sub>1 ; Q) id (Some b) [Some a]", "have \"[Some a] @ [Some b] \\<in> traces (P\\<^sub>1 ; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Some a] @ [Some b] \\<in> traces (P\\<^sub>1 ; Q)", "by (simp add: not_secure_comp_1_aux_2)"], ["proof (state)\nthis:\n  [Some a] @ [Some b] \\<in> traces (P\\<^sub>1 ; Q)\n\ngoal (3 subgoals):\n 1. [Some a] \\<in> traces (P\\<^sub>1 ; Q)\n 2. ipurge_tr_rev I\\<^sub>1 id (Some b) [] =\n    ipurge_tr_rev I\\<^sub>1 id (Some b) [Some a]\n 3. next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n    next_dom_events (P\\<^sub>1 ; Q) id (Some b) [Some a]", "thus \"[Some a] \\<in> traces (P\\<^sub>1 ; Q)\""], ["proof (prove)\nusing this:\n  [Some a] @ [Some b] \\<in> traces (P\\<^sub>1 ; Q)\n\ngoal (1 subgoal):\n 1. [Some a] \\<in> traces (P\\<^sub>1 ; Q)", "by (rule process_rule_2_traces)"], ["proof (state)\nthis:\n  [Some a] \\<in> traces (P\\<^sub>1 ; Q)\n\ngoal (2 subgoals):\n 1. ipurge_tr_rev I\\<^sub>1 id (Some b) [] =\n    ipurge_tr_rev I\\<^sub>1 id (Some b) [Some a]\n 2. next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n    next_dom_events (P\\<^sub>1 ; Q) id (Some b) [Some a]", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ipurge_tr_rev I\\<^sub>1 id (Some b) [] =\n    ipurge_tr_rev I\\<^sub>1 id (Some b) [Some a]\n 2. next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n    next_dom_events (P\\<^sub>1 ; Q) id (Some b) [Some a]", "show \"ipurge_tr_rev I\\<^sub>1 id (Some b) [] = ipurge_tr_rev I\\<^sub>1 id (Some b) [Some a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I\\<^sub>1 id (Some b) [] =\n    ipurge_tr_rev I\\<^sub>1 id (Some b) [Some a]", "by (simp add: I\\<^sub>1_def)"], ["proof (state)\nthis:\n  ipurge_tr_rev I\\<^sub>1 id (Some b) [] =\n  ipurge_tr_rev I\\<^sub>1 id (Some b) [Some a]\n\ngoal (1 subgoal):\n 1. next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n    next_dom_events (P\\<^sub>1 ; Q) id (Some b) [Some a]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n    next_dom_events (P\\<^sub>1 ; Q) id (Some b) [Some a]", "show\n     \"next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n      next_dom_events (P\\<^sub>1 ; Q) id (Some b) [Some a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n    next_dom_events (P\\<^sub>1 ; Q) id (Some b) [Some a]", "proof (simp add: next_dom_events_def next_events_def set_eq_iff,\n     rule exI [where x = \"Some b\"], simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. ([Some b] \\<in> traces (P\\<^sub>1 ; Q)) =\n    ([Some a, Some b] \\<notin> traces (P\\<^sub>1 ; Q))", "qed (simp add: not_secure_comp_1_aux_1 not_secure_comp_1_aux_2)"], ["proof (state)\nthis:\n  next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n  next_dom_events (P\\<^sub>1 ; Q) id (Some b) [Some a]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ys.\n     ys \\<in> traces (P\\<^sub>1 ; Q) \\<and>\n     ipurge_tr_rev I\\<^sub>1 id (Some b) [] =\n     ipurge_tr_rev I\\<^sub>1 id (Some b) ys \\<and>\n     (next_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n      next_dom_events (P\\<^sub>1 ; Q) id (Some b) ys \\<or>\n      ref_dom_events (P\\<^sub>1 ; Q) id (Some b) [] \\<noteq>\n      ref_dom_events (P\\<^sub>1 ; Q) id (Some b) ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nHere below, the previous results are used to show that constants @{term I\\<^sub>1}, @{term P\\<^sub>1}, @{term Q},\nand @{term id} indeed constitute a counterexample to the statement obtained by removing termination\nsecurity from the assumptions of the security conservation theorem.\n\n\\null\n\\<close>"], ["", "lemma counterexample_1:\n \"\\<not> (ref_union_closed P\\<^sub>1 \\<and>\n     sequential P\\<^sub>1 \\<and>\n     secure P\\<^sub>1 I\\<^sub>1 id \\<and>\n     secure Q I\\<^sub>1 id \\<longrightarrow>\n   secure (P\\<^sub>1 ; Q) I\\<^sub>1 id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (ref_union_closed P\\<^sub>1 \\<and>\n            sequential P\\<^sub>1 \\<and>\n            secure P\\<^sub>1 I\\<^sub>1 id \\<and>\n            secure Q I\\<^sub>1 id \\<longrightarrow>\n            secure (P\\<^sub>1 ; Q) I\\<^sub>1 id)", "proof (simp, simp only: conj_assoc [symmetric], (rule conjI)+)"], ["proof (state)\ngoal (5 subgoals):\n 1. ref_union_closed P\\<^sub>1\n 2. sequential P\\<^sub>1\n 3. secure P\\<^sub>1 I\\<^sub>1 id\n 4. secure Q I\\<^sub>1 id\n 5. \\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id", "show \"ref_union_closed P\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref_union_closed P\\<^sub>1", "by (rule ref_union_closed_fst_1)"], ["proof (state)\nthis:\n  ref_union_closed P\\<^sub>1\n\ngoal (4 subgoals):\n 1. sequential P\\<^sub>1\n 2. secure P\\<^sub>1 I\\<^sub>1 id\n 3. secure Q I\\<^sub>1 id\n 4. \\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. sequential P\\<^sub>1\n 2. secure P\\<^sub>1 I\\<^sub>1 id\n 3. secure Q I\\<^sub>1 id\n 4. \\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id", "show \"sequential P\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sequential P\\<^sub>1", "by (rule sequential_fst_1)"], ["proof (state)\nthis:\n  sequential P\\<^sub>1\n\ngoal (3 subgoals):\n 1. secure P\\<^sub>1 I\\<^sub>1 id\n 2. secure Q I\\<^sub>1 id\n 3. \\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. secure P\\<^sub>1 I\\<^sub>1 id\n 2. secure Q I\\<^sub>1 id\n 3. \\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id", "show \"secure P\\<^sub>1 I\\<^sub>1 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure P\\<^sub>1 I\\<^sub>1 id", "by (rule secure_fst_1)"], ["proof (state)\nthis:\n  secure P\\<^sub>1 I\\<^sub>1 id\n\ngoal (2 subgoals):\n 1. secure Q I\\<^sub>1 id\n 2. \\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. secure Q I\\<^sub>1 id\n 2. \\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id", "show \"secure Q I\\<^sub>1 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure Q I\\<^sub>1 id", "by (rule secure_snd_1)"], ["proof (state)\nthis:\n  secure Q I\\<^sub>1 id\n\ngoal (1 subgoal):\n 1. \\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id", "show \"\\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id", "by (rule not_secure_comp_1)"], ["proof (state)\nthis:\n  \\<not> secure (P\\<^sub>1 ; Q) I\\<^sub>1 id\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Necessity of process sequentiality\""], ["", "text \\<open>\nThe reason why the conservation of noninterference security under sequential composition requires\nthe first input process to satisfy predicate @{term sequential}, instead of the more permissive\npredicate @{term weakly_sequential}, is that the possibility for the first process to engage in\nevents alternative to successful termination entails the possibility for the resulting process to\nengage in events alternative to the initial ones of the second process. Namely, the resulting\nprocess would admit some state in which events of the first process can occur in alternative to\nevents of the second process. But neither process, though being secure on its own, will in general\nbe prepared to handle securely the alternative events added by the other process. Therefore, the\nfirst process must not admit alternatives to successful termination, which is exactly what predicate\n@{term sequential} states in addition to @{term weakly_sequential}.\n\nA counterexample showing the necessity of this assumption can then be constructed by defining a\nreflexive policy @{term I\\<^sub>2} that does not allow event @{term \"Some b\"} to affect @{term \"Some a\"},\nand a deterministic process @{term P\\<^sub>2} that can engage in @{term \"Some a\"} in alternative to\n@{term None}. The resulting process @{term \"P\\<^sub>2 ; Q\"} will number both @{term \"[Some b]\"} and\n@{term \"[Some a]\"}, but not @{term \"[Some b, Some a]\"}, among its traces, so that event\n@{term \"Some b\"} affects the occurrence of event @{term \"Some a\"} in contrast with policy\n@{term I\\<^sub>2}, viz. @{term \"P\\<^sub>2 ; Q\"} is not secure with respect to @{term I\\<^sub>2}.\n\nHere below are the definitions of constants @{term I\\<^sub>2} and @{term P\\<^sub>2}, followed by few useful lemmas\non process @{term P\\<^sub>2}.\n\n\\null\n\\<close>"], ["", "definition I\\<^sub>2 :: \"(event option \\<times> event option) set\" where\n\"I\\<^sub>2 \\<equiv> {(None, Some a)}\\<^sup>=\""], ["", "definition P\\<^sub>2 :: \"event option process\" where\n\"P\\<^sub>2 \\<equiv> ts_process {[], [None], [Some a], [Some a, None]}\""], ["", "lemma trace_set_fst_2:\n \"trace_set {[], [None], [Some a], [Some a, None]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_set {[], [None], [Some a], [Some a, None]}", "by (simp add: trace_set_def)"], ["", "lemmas failures_fst_2 = ts_process_failures [OF trace_set_fst_2]"], ["", "lemmas traces_fst_2 = ts_process_traces [OF trace_set_fst_2]"], ["", "lemmas next_events_fst_2 = ts_process_next_events [OF trace_set_fst_2]"], ["", "lemmas unwinding_fst_2 = ts_ipurge_unwinding [OF trace_set_fst_2]"], ["", "text \\<open>\n\\null\n\nHere below is the proof that process @{term P\\<^sub>2} does not satisfy predicate @{term sequential}, but\nrather predicate @{term weakly_sequential} only, whereas the remaining assumptions of the security\nconservation theorem keep being satisfied. For the sake of simplicity, the identity function is used\nas event-domain map.\n\n\\null\n\\<close>"], ["", "lemma secure_termination_2:\n \"secure_termination I\\<^sub>2 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure_termination I\\<^sub>2 id", "by (simp add: secure_termination_def I\\<^sub>2_def)"], ["", "lemma ref_union_closed_fst_2:\n \"ref_union_closed P\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref_union_closed P\\<^sub>2", "by (rule d_implies_ruc, subst P\\<^sub>2_def, rule ts_process_d, rule trace_set_fst_2)"], ["", "lemma weakly_sequential_fst_2:\n \"weakly_sequential P\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weakly_sequential P\\<^sub>2", "by (simp add: weakly_sequential_def P\\<^sub>2_def traces_fst_2)"], ["", "lemma not_sequential_fst_2:\n \"\\<not> sequential P\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sequential P\\<^sub>2", "proof (simp add: sequential_def, rule disjI2, rule bexI [where x = \"[]\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. next_events P\\<^sub>2 [] \\<noteq> {None}\n 2. [] \\<in> sentences P\\<^sub>2", "show \"next_events P\\<^sub>2 [] \\<noteq> {None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next_events P\\<^sub>2 [] \\<noteq> {None}", "proof (rule notI, drule eqset_imp_iff [where x = \"Some a\"], simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. Some a \\<notin> next_events P\\<^sub>2 [] \\<Longrightarrow> False", "qed (simp add: P\\<^sub>2_def next_events_fst_2)"], ["proof (state)\nthis:\n  next_events P\\<^sub>2 [] \\<noteq> {None}\n\ngoal (1 subgoal):\n 1. [] \\<in> sentences P\\<^sub>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<in> sentences P\\<^sub>2", "show \"[] \\<in> sentences P\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> sentences P\\<^sub>2", "by (simp add: sentences_def P\\<^sub>2_def traces_fst_2)"], ["proof (state)\nthis:\n  [] \\<in> sentences P\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma secure_fst_2:\n \"secure P\\<^sub>2 I\\<^sub>2 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure P\\<^sub>2 I\\<^sub>2 id", "proof (simp add: P\\<^sub>2_def unwinding_fst_2 dfc_equals_dwfc_rel_ipurge [symmetric]\n d_future_consistent_def rel_ipurge_def traces_fst_2, (rule allI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       (xs = [] \\<or>\n        xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or>\n        ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       next_dom_events (ts_process {[], [None], [Some a], [Some a, None]})\n        id u xs =\n       next_dom_events (ts_process {[], [None], [Some a], [Some a, None]})\n        id u ys", "fix u xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       (xs = [] \\<or>\n        xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or>\n        ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       next_dom_events (ts_process {[], [None], [Some a], [Some a, None]})\n        id u xs =\n       next_dom_events (ts_process {[], [None], [Some a], [Some a, None]})\n        id u ys", "show\n   \"(xs = [] \\<or> xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n    (ys = [] \\<or> ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n    ipurge_tr_rev I\\<^sub>2 id u xs = ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n      next_dom_events (ts_process {[], [None], [Some a], [Some a, None]}) id u xs =\n      next_dom_events (ts_process {[], [None], [Some a], [Some a, None]}) id u ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = [] \\<or>\n     xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n    (ys = [] \\<or>\n     ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n    ipurge_tr_rev I\\<^sub>2 id u xs =\n    ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n    next_dom_events (ts_process {[], [None], [Some a], [Some a, None]}) id u\n     xs =\n    next_dom_events (ts_process {[], [None], [Some a], [Some a, None]}) id u\n     ys", "proof (simp add: next_dom_events_def next_events_fst_2, cases u)"], ["proof (state)\ngoal (2 subgoals):\n 1. u = None \\<Longrightarrow>\n    (xs = [] \\<or>\n     xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n    (ys = [] \\<or>\n     ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n    ipurge_tr_rev I\\<^sub>2 id u xs =\n    ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n    {x. u = x \\<and>\n        (xs = [] \\<and> x = None \\<or>\n         xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n    {x. u = x \\<and>\n        (ys = [] \\<and> x = None \\<or>\n         ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}\n 2. \\<And>aa.\n       u = Some aa \\<Longrightarrow>\n       (xs = [] \\<or>\n        xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or>\n        ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       {x. u = x \\<and>\n           (xs = [] \\<and> x = None \\<or>\n            xs = [] \\<and> x = Some a \\<or>\n            xs = [Some a] \\<and> x = None)} =\n       {x. u = x \\<and>\n           (ys = [] \\<and> x = None \\<or>\n            ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "case None"], ["proof (state)\nthis:\n  u = None\n\ngoal (2 subgoals):\n 1. u = None \\<Longrightarrow>\n    (xs = [] \\<or>\n     xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n    (ys = [] \\<or>\n     ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n    ipurge_tr_rev I\\<^sub>2 id u xs =\n    ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n    {x. u = x \\<and>\n        (xs = [] \\<and> x = None \\<or>\n         xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n    {x. u = x \\<and>\n        (ys = [] \\<and> x = None \\<or>\n         ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}\n 2. \\<And>aa.\n       u = Some aa \\<Longrightarrow>\n       (xs = [] \\<or>\n        xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or>\n        ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       {x. u = x \\<and>\n           (xs = [] \\<and> x = None \\<or>\n            xs = [] \\<and> x = Some a \\<or>\n            xs = [Some a] \\<and> x = None)} =\n       {x. u = x \\<and>\n           (ys = [] \\<and> x = None \\<or>\n            ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "show\n     \"(xs = [] \\<or> xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n      (ys = [] \\<or> ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n      ipurge_tr_rev I\\<^sub>2 id u xs = ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n        {x. u = x \\<and> (xs = [] \\<and> x = None \\<or> xs = [] \\<and> x = Some a \\<or>\n          xs = [Some a] \\<and> x = None)} =\n        {x. u = x \\<and> (ys = [] \\<and> x = None \\<or> ys = [] \\<and> x = Some a \\<or>\n          ys = [Some a] \\<and> x = None)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = [] \\<or>\n     xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n    (ys = [] \\<or>\n     ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n    ipurge_tr_rev I\\<^sub>2 id u xs =\n    ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n    {x. u = x \\<and>\n        (xs = [] \\<and> x = None \\<or>\n         xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n    {x. u = x \\<and>\n        (ys = [] \\<and> x = None \\<or>\n         ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "by (simp add: I\\<^sub>2_def None, rule impI, (erule conjE)+,\n      (((erule disjE)+)?, simp, blast?)+)"], ["proof (state)\nthis:\n  (xs = [] \\<or>\n   xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n  (ys = [] \\<or>\n   ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n  ipurge_tr_rev I\\<^sub>2 id u xs =\n  ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n  {x. u = x \\<and>\n      (xs = [] \\<and> x = None \\<or>\n       xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n  {x. u = x \\<and>\n      (ys = [] \\<and> x = None \\<or>\n       ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       u = Some aa \\<Longrightarrow>\n       (xs = [] \\<or>\n        xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or>\n        ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       {x. u = x \\<and>\n           (xs = [] \\<and> x = None \\<or>\n            xs = [] \\<and> x = Some a \\<or>\n            xs = [Some a] \\<and> x = None)} =\n       {x. u = x \\<and>\n           (ys = [] \\<and> x = None \\<or>\n            ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       u = Some aa \\<Longrightarrow>\n       (xs = [] \\<or>\n        xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or>\n        ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       {x. u = x \\<and>\n           (xs = [] \\<and> x = None \\<or>\n            xs = [] \\<and> x = Some a \\<or>\n            xs = [Some a] \\<and> x = None)} =\n       {x. u = x \\<and>\n           (ys = [] \\<and> x = None \\<or>\n            ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "case (Some v)"], ["proof (state)\nthis:\n  u = Some v\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       u = Some aa \\<Longrightarrow>\n       (xs = [] \\<or>\n        xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n       (ys = [] \\<or>\n        ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       {x. u = x \\<and>\n           (xs = [] \\<and> x = None \\<or>\n            xs = [] \\<and> x = Some a \\<or>\n            xs = [Some a] \\<and> x = None)} =\n       {x. u = x \\<and>\n           (ys = [] \\<and> x = None \\<or>\n            ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "show\n     \"(xs = [] \\<or> xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n      (ys = [] \\<or> ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n      ipurge_tr_rev I\\<^sub>2 id u xs = ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n        {x. u = x \\<and> (xs = [] \\<and> x = None \\<or> xs = [] \\<and> x = Some a \\<or>\n          xs = [Some a] \\<and> x = None)} =\n        {x. u = x \\<and> (ys = [] \\<and> x = None \\<or> ys = [] \\<and> x = Some a \\<or>\n          ys = [Some a] \\<and> x = None)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = [] \\<or>\n     xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n    (ys = [] \\<or>\n     ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n    ipurge_tr_rev I\\<^sub>2 id u xs =\n    ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n    {x. u = x \\<and>\n        (xs = [] \\<and> x = None \\<or>\n         xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n    {x. u = x \\<and>\n        (ys = [] \\<and> x = None \\<or>\n         ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}", "by (simp add: I\\<^sub>2_def Some, rule impI, (erule conjE)+, cases v,\n      (((erule disjE)+)?, simp, blast?)+)"], ["proof (state)\nthis:\n  (xs = [] \\<or>\n   xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n  (ys = [] \\<or>\n   ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n  ipurge_tr_rev I\\<^sub>2 id u xs =\n  ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n  {x. u = x \\<and>\n      (xs = [] \\<and> x = None \\<or>\n       xs = [] \\<and> x = Some a \\<or> xs = [Some a] \\<and> x = None)} =\n  {x. u = x \\<and>\n      (ys = [] \\<and> x = None \\<or>\n       ys = [] \\<and> x = Some a \\<or> ys = [Some a] \\<and> x = None)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs = [] \\<or>\n   xs = [None] \\<or> xs = [Some a] \\<or> xs = [Some a, None]) \\<and>\n  (ys = [] \\<or>\n   ys = [None] \\<or> ys = [Some a] \\<or> ys = [Some a, None]) \\<and>\n  ipurge_tr_rev I\\<^sub>2 id u xs =\n  ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n  next_dom_events (ts_process {[], [None], [Some a], [Some a, None]}) id u\n   xs =\n  next_dom_events (ts_process {[], [None], [Some a], [Some a, None]}) id u\n   ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma secure_snd_2:\n \"secure Q I\\<^sub>2 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure Q I\\<^sub>2 id", "proof (simp add: Q_def unwinding_snd dfc_equals_dwfc_rel_ipurge [symmetric]\n d_future_consistent_def rel_ipurge_def traces_snd, (rule allI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       next_dom_events (ts_process {[], [Some b]}) id u xs =\n       next_dom_events (ts_process {[], [Some b]}) id u ys", "fix u xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       next_dom_events (ts_process {[], [Some b]}) id u xs =\n       next_dom_events (ts_process {[], [Some b]}) id u ys", "show\n   \"(xs = [] \\<or> xs = [Some b]) \\<and>\n    (ys = [] \\<or> ys = [Some b]) \\<and>\n    ipurge_tr_rev I\\<^sub>2 id u xs = ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n      next_dom_events (ts_process {[], [Some b]}) id u xs =\n      next_dom_events (ts_process {[], [Some b]}) id u ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = [] \\<or> xs = [Some b]) \\<and>\n    (ys = [] \\<or> ys = [Some b]) \\<and>\n    ipurge_tr_rev I\\<^sub>2 id u xs =\n    ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n    next_dom_events (ts_process {[], [Some b]}) id u xs =\n    next_dom_events (ts_process {[], [Some b]}) id u ys", "proof (simp add: next_dom_events_def next_events_snd, cases u)"], ["proof (state)\ngoal (2 subgoals):\n 1. u = None \\<Longrightarrow>\n    (xs = [] \\<or> xs = [Some b]) \\<and>\n    (ys = [] \\<or> ys = [Some b]) \\<and>\n    ipurge_tr_rev I\\<^sub>2 id u xs =\n    ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n    {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n    {x. u = x \\<and> ys = [] \\<and> x = Some b}\n 2. \\<And>a.\n       u = Some a \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n       {x. u = x \\<and> ys = [] \\<and> x = Some b}", "case None"], ["proof (state)\nthis:\n  u = None\n\ngoal (2 subgoals):\n 1. u = None \\<Longrightarrow>\n    (xs = [] \\<or> xs = [Some b]) \\<and>\n    (ys = [] \\<or> ys = [Some b]) \\<and>\n    ipurge_tr_rev I\\<^sub>2 id u xs =\n    ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n    {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n    {x. u = x \\<and> ys = [] \\<and> x = Some b}\n 2. \\<And>a.\n       u = Some a \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n       {x. u = x \\<and> ys = [] \\<and> x = Some b}", "show\n     \"(xs = [] \\<or> xs = [Some b]) \\<and>\n      (ys = [] \\<or> ys = [Some b]) \\<and>\n      ipurge_tr_rev I\\<^sub>2 id u xs = ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n        {x. u = x \\<and> xs = [] \\<and> x = Some b} = {x. u = x \\<and> ys = [] \\<and> x = Some b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = [] \\<or> xs = [Some b]) \\<and>\n    (ys = [] \\<or> ys = [Some b]) \\<and>\n    ipurge_tr_rev I\\<^sub>2 id u xs =\n    ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n    {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n    {x. u = x \\<and> ys = [] \\<and> x = Some b}", "by (simp add: None, rule impI, (erule conjE)+,\n      (((erule disjE)+)?, simp)+)"], ["proof (state)\nthis:\n  (xs = [] \\<or> xs = [Some b]) \\<and>\n  (ys = [] \\<or> ys = [Some b]) \\<and>\n  ipurge_tr_rev I\\<^sub>2 id u xs =\n  ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n  {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n  {x. u = x \\<and> ys = [] \\<and> x = Some b}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       u = Some a \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n       {x. u = x \\<and> ys = [] \\<and> x = Some b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       u = Some a \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n       {x. u = x \\<and> ys = [] \\<and> x = Some b}", "case (Some v)"], ["proof (state)\nthis:\n  u = Some v\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       u = Some a \\<Longrightarrow>\n       (xs = [] \\<or> xs = [Some b]) \\<and>\n       (ys = [] \\<or> ys = [Some b]) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id u xs =\n       ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n       {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n       {x. u = x \\<and> ys = [] \\<and> x = Some b}", "show\n     \"(xs = [] \\<or> xs = [Some b]) \\<and>\n      (ys = [] \\<or> ys = [Some b]) \\<and>\n      ipurge_tr_rev I\\<^sub>2 id u xs = ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n        {x. u = x \\<and> xs = [] \\<and> x = Some b} = {x. u = x \\<and> ys = [] \\<and> x = Some b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = [] \\<or> xs = [Some b]) \\<and>\n    (ys = [] \\<or> ys = [Some b]) \\<and>\n    ipurge_tr_rev I\\<^sub>2 id u xs =\n    ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n    {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n    {x. u = x \\<and> ys = [] \\<and> x = Some b}", "by (simp add: I\\<^sub>2_def Some, rule impI, (erule conjE)+, cases v,\n      (((erule disjE)+)?, simp)+)"], ["proof (state)\nthis:\n  (xs = [] \\<or> xs = [Some b]) \\<and>\n  (ys = [] \\<or> ys = [Some b]) \\<and>\n  ipurge_tr_rev I\\<^sub>2 id u xs =\n  ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n  {x. u = x \\<and> xs = [] \\<and> x = Some b} =\n  {x. u = x \\<and> ys = [] \\<and> x = Some b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs = [] \\<or> xs = [Some b]) \\<and>\n  (ys = [] \\<or> ys = [Some b]) \\<and>\n  ipurge_tr_rev I\\<^sub>2 id u xs =\n  ipurge_tr_rev I\\<^sub>2 id u ys \\<longrightarrow>\n  next_dom_events (ts_process {[], [Some b]}) id u xs =\n  next_dom_events (ts_process {[], [Some b]}) id u ys\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nIn what follows, the insecurity of process @{term \"P\\<^sub>2 ; Q\"} is demonstrated by proving that event\nlists @{term \"[Some b]\"} and @{term \"[Some a]\"} are traces of the process, whereas\n@{term \"[Some b, Some a]\"} is not.\n\n\\null\n\\<close>"], ["", "lemma traces_comp_2:\n \"traces (P\\<^sub>2 ; Q) = Domain (seq_comp_failures P\\<^sub>2 Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traces (P\\<^sub>2 ; Q) = Domain (seq_comp_failures P\\<^sub>2 Q)", "by (subst seq_comp_traces, rule weakly_sequential_fst_2, simp)"], ["", "lemma ref_union_closed_comp_2:\n \"ref_union_closed (P\\<^sub>2 ; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref_union_closed (P\\<^sub>2 ; Q)", "proof (rule seq_comp_ref_union_closed, rule weakly_sequential_fst_2,\n rule ref_union_closed_fst_2)"], ["proof (state)\ngoal (1 subgoal):\n 1. ref_union_closed Q", "qed (rule d_implies_ruc, subst Q_def, rule ts_process_d, rule trace_set_snd)"], ["", "lemma not_secure_comp_2_aux_aux_1:\n \"(xs, X) \\<in> seq_comp_failures P\\<^sub>2 Q \\<Longrightarrow> xs \\<noteq> [Some b, Some a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, X) \\<in> seq_comp_failures P\\<^sub>2 Q \\<Longrightarrow>\n    xs \\<noteq> [Some b, Some a]", "proof (rule notI, erule rev_mp, erule seq_comp_failures.induct, (rule_tac [!] impI)+,\n simp_all add: P\\<^sub>2_def Q_def sentences_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs X.\n       \\<lbrakk>[Some b, Some a, None]\n                \\<notin> traces\n                          (ts_process\n                            {[], [None], [Some a], [Some a, None]});\n        ([Some b, Some a], X)\n        \\<in> failures (ts_process {[], [None], [Some a], [Some a, None]});\n        xs = [Some b, Some a]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xs X Y.\n       \\<lbrakk>[Some b, Some a, None]\n                \\<in> traces\n                       (ts_process {[], [None], [Some a], [Some a, None]});\n        ([Some b, Some a], X)\n        \\<in> failures (ts_process {[], [None], [Some a], [Some a, None]});\n        ([], Y) \\<in> failures (ts_process {[], [Some b]});\n        xs = [Some b, Some a]\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>xs ys Y.\n       \\<lbrakk>xs @ [None]\n                \\<in> traces\n                       (ts_process {[], [None], [Some a], [Some a, None]});\n        (ys, Y) \\<in> failures (ts_process {[], [Some b]}); ys \\<noteq> [];\n        xs @ ys = [Some b, Some a]\\<rbrakk>\n       \\<Longrightarrow> False", "qed (simp_all add: failures_fst_2 traces_fst_2 failures_snd)"], ["", "lemma not_secure_comp_2_aux_1:\n \"[Some b, Some a] \\<notin> traces (P\\<^sub>2 ; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Some b, Some a] \\<notin> traces (P\\<^sub>2 ; Q)", "proof (simp add: traces_comp_2 Domain_iff, rule allI, rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ([Some b, Some a], y)\n       \\<in> seq_comp_failures P\\<^sub>2 Q \\<Longrightarrow>\n       False", "qed (drule not_secure_comp_2_aux_aux_1, simp)"], ["", "lemma not_secure_comp_2_aux_2:\n \"[Some a] \\<in> traces (P\\<^sub>2 ; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Some a] \\<in> traces (P\\<^sub>2 ; Q)", "proof (simp add: traces_comp_2 Domain_iff, rule exI [where x = \"{}\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. ([Some a], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "have \"[Some a] \\<in> sentences P\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Some a] \\<in> sentences P\\<^sub>2", "by (simp add: P\\<^sub>2_def sentences_def traces_fst_2)"], ["proof (state)\nthis:\n  [Some a] \\<in> sentences P\\<^sub>2\n\ngoal (1 subgoal):\n 1. ([Some a], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "moreover"], ["proof (state)\nthis:\n  [Some a] \\<in> sentences P\\<^sub>2\n\ngoal (1 subgoal):\n 1. ([Some a], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "have \"([Some a], {}) \\<in> failures P\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([Some a], {}) \\<in> failures P\\<^sub>2", "by (simp add: P\\<^sub>2_def failures_fst_2)"], ["proof (state)\nthis:\n  ([Some a], {}) \\<in> failures P\\<^sub>2\n\ngoal (1 subgoal):\n 1. ([Some a], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "moreover"], ["proof (state)\nthis:\n  ([Some a], {}) \\<in> failures P\\<^sub>2\n\ngoal (1 subgoal):\n 1. ([Some a], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "have \"([], {}) \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> failures Q", "by (simp add: Q_def failures_snd)"], ["proof (state)\nthis:\n  ([], {}) \\<in> failures Q\n\ngoal (1 subgoal):\n 1. ([Some a], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "ultimately"], ["proof (chain)\npicking this:\n  [Some a] \\<in> sentences P\\<^sub>2\n  ([Some a], {}) \\<in> failures P\\<^sub>2\n  ([], {}) \\<in> failures Q", "have \"([Some a], insert None {} \\<inter> {}) \\<in> seq_comp_failures P\\<^sub>2 Q\""], ["proof (prove)\nusing this:\n  [Some a] \\<in> sentences P\\<^sub>2\n  ([Some a], {}) \\<in> failures P\\<^sub>2\n  ([], {}) \\<in> failures Q\n\ngoal (1 subgoal):\n 1. ([Some a], {None} \\<inter> {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "by (rule SCF_R2)"], ["proof (state)\nthis:\n  ([Some a], {None} \\<inter> {}) \\<in> seq_comp_failures P\\<^sub>2 Q\n\ngoal (1 subgoal):\n 1. ([Some a], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "thus \"([Some a], {}) \\<in> seq_comp_failures P\\<^sub>2 Q\""], ["proof (prove)\nusing this:\n  ([Some a], {None} \\<inter> {}) \\<in> seq_comp_failures P\\<^sub>2 Q\n\ngoal (1 subgoal):\n 1. ([Some a], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "by simp"], ["proof (state)\nthis:\n  ([Some a], {}) \\<in> seq_comp_failures P\\<^sub>2 Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_secure_comp_2_aux_3:\n \"[Some b] \\<in> traces (P\\<^sub>2 ; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Some b] \\<in> traces (P\\<^sub>2 ; Q)", "proof (simp add: traces_comp_2 Domain_iff, rule exI [where x = \"{}\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. ([Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "have \"[] \\<in> sentences P\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> sentences P\\<^sub>2", "by (simp add: P\\<^sub>2_def sentences_def traces_fst_2)"], ["proof (state)\nthis:\n  [] \\<in> sentences P\\<^sub>2\n\ngoal (1 subgoal):\n 1. ([Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "moreover"], ["proof (state)\nthis:\n  [] \\<in> sentences P\\<^sub>2\n\ngoal (1 subgoal):\n 1. ([Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "have \"([Some b], {}) \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([Some b], {}) \\<in> failures Q", "by (simp add: Q_def failures_snd)"], ["proof (state)\nthis:\n  ([Some b], {}) \\<in> failures Q\n\ngoal (1 subgoal):\n 1. ([Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "moreover"], ["proof (state)\nthis:\n  ([Some b], {}) \\<in> failures Q\n\ngoal (1 subgoal):\n 1. ([Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "have \"[Some b] \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Some b] \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  [Some b] \\<noteq> []\n\ngoal (1 subgoal):\n 1. ([Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "ultimately"], ["proof (chain)\npicking this:\n  [] \\<in> sentences P\\<^sub>2\n  ([Some b], {}) \\<in> failures Q\n  [Some b] \\<noteq> []", "have \"([] @ [Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q\""], ["proof (prove)\nusing this:\n  [] \\<in> sentences P\\<^sub>2\n  ([Some b], {}) \\<in> failures Q\n  [Some b] \\<noteq> []\n\ngoal (1 subgoal):\n 1. ([] @ [Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "by (rule SCF_R3)"], ["proof (state)\nthis:\n  ([] @ [Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q\n\ngoal (1 subgoal):\n 1. ([Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "thus \"([Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q\""], ["proof (prove)\nusing this:\n  ([] @ [Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q\n\ngoal (1 subgoal):\n 1. ([Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q", "by simp"], ["proof (state)\nthis:\n  ([Some b], {}) \\<in> seq_comp_failures P\\<^sub>2 Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_secure_comp_2:\n \"\\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id", "proof (subst ipurge_unwinding, rule ref_union_closed_comp_2, simp\n add: fc_equals_wfc_rel_ipurge [symmetric] future_consistent_def rel_ipurge_def\n del: disj_not1, rule exI [where x = \"Some a\"], rule exI [where x = \"[]\"], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> traces (P\\<^sub>2 ; Q)\n 2. \\<exists>ys.\n       ys \\<in> traces (P\\<^sub>2 ; Q) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id (Some a) [] =\n       ipurge_tr_rev I\\<^sub>2 id (Some a) ys \\<and>\n       (next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n        next_dom_events (P\\<^sub>2 ; Q) id (Some a) ys \\<or>\n        ref_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n        ref_dom_events (P\\<^sub>2 ; Q) id (Some a) ys)", "show \"[] \\<in> traces (P\\<^sub>2 ; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> traces (P\\<^sub>2 ; Q)", "by (rule failures_traces [where X = \"{}\"], rule process_rule_1)"], ["proof (state)\nthis:\n  [] \\<in> traces (P\\<^sub>2 ; Q)\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       ys \\<in> traces (P\\<^sub>2 ; Q) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id (Some a) [] =\n       ipurge_tr_rev I\\<^sub>2 id (Some a) ys \\<and>\n       (next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n        next_dom_events (P\\<^sub>2 ; Q) id (Some a) ys \\<or>\n        ref_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n        ref_dom_events (P\\<^sub>2 ; Q) id (Some a) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       ys \\<in> traces (P\\<^sub>2 ; Q) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id (Some a) [] =\n       ipurge_tr_rev I\\<^sub>2 id (Some a) ys \\<and>\n       (next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n        next_dom_events (P\\<^sub>2 ; Q) id (Some a) ys \\<or>\n        ref_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n        ref_dom_events (P\\<^sub>2 ; Q) id (Some a) ys)", "show \"\\<exists>ys. ys \\<in> traces (P\\<^sub>2 ; Q) \\<and>\n    ipurge_tr_rev I\\<^sub>2 id (Some a) [] = ipurge_tr_rev I\\<^sub>2 id (Some a) ys \\<and>\n    (next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n       next_dom_events (P\\<^sub>2 ; Q) id (Some a) ys \\<or>\n     ref_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n       ref_dom_events (P\\<^sub>2 ; Q) id (Some a) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       ys \\<in> traces (P\\<^sub>2 ; Q) \\<and>\n       ipurge_tr_rev I\\<^sub>2 id (Some a) [] =\n       ipurge_tr_rev I\\<^sub>2 id (Some a) ys \\<and>\n       (next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n        next_dom_events (P\\<^sub>2 ; Q) id (Some a) ys \\<or>\n        ref_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n        ref_dom_events (P\\<^sub>2 ; Q) id (Some a) ys)", "proof (rule exI [where x = \"[Some b]\"], rule conjI, rule_tac [2] conjI,\n   rule_tac [3] disjI1)"], ["proof (state)\ngoal (3 subgoals):\n 1. [Some b] \\<in> traces (P\\<^sub>2 ; Q)\n 2. ipurge_tr_rev I\\<^sub>2 id (Some a) [] =\n    ipurge_tr_rev I\\<^sub>2 id (Some a) [Some b]\n 3. next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n    next_dom_events (P\\<^sub>2 ; Q) id (Some a) [Some b]", "show \"[Some b] \\<in> traces (P\\<^sub>2 ; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Some b] \\<in> traces (P\\<^sub>2 ; Q)", "by (rule not_secure_comp_2_aux_3)"], ["proof (state)\nthis:\n  [Some b] \\<in> traces (P\\<^sub>2 ; Q)\n\ngoal (2 subgoals):\n 1. ipurge_tr_rev I\\<^sub>2 id (Some a) [] =\n    ipurge_tr_rev I\\<^sub>2 id (Some a) [Some b]\n 2. next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n    next_dom_events (P\\<^sub>2 ; Q) id (Some a) [Some b]", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ipurge_tr_rev I\\<^sub>2 id (Some a) [] =\n    ipurge_tr_rev I\\<^sub>2 id (Some a) [Some b]\n 2. next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n    next_dom_events (P\\<^sub>2 ; Q) id (Some a) [Some b]", "show \"ipurge_tr_rev I\\<^sub>2 id (Some a) [] = ipurge_tr_rev I\\<^sub>2 id (Some a) [Some b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I\\<^sub>2 id (Some a) [] =\n    ipurge_tr_rev I\\<^sub>2 id (Some a) [Some b]", "by (simp add: I\\<^sub>2_def)"], ["proof (state)\nthis:\n  ipurge_tr_rev I\\<^sub>2 id (Some a) [] =\n  ipurge_tr_rev I\\<^sub>2 id (Some a) [Some b]\n\ngoal (1 subgoal):\n 1. next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n    next_dom_events (P\\<^sub>2 ; Q) id (Some a) [Some b]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n    next_dom_events (P\\<^sub>2 ; Q) id (Some a) [Some b]", "show\n     \"next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n      next_dom_events (P\\<^sub>2 ; Q) id (Some a) [Some b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n    next_dom_events (P\\<^sub>2 ; Q) id (Some a) [Some b]", "proof (simp add: next_dom_events_def next_events_def set_eq_iff,\n     rule exI [where x = \"Some a\"], simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. ([Some a] \\<in> traces (P\\<^sub>2 ; Q)) =\n    ([Some b, Some a] \\<notin> traces (P\\<^sub>2 ; Q))", "qed (simp add: not_secure_comp_2_aux_1 not_secure_comp_2_aux_2)"], ["proof (state)\nthis:\n  next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n  next_dom_events (P\\<^sub>2 ; Q) id (Some a) [Some b]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ys.\n     ys \\<in> traces (P\\<^sub>2 ; Q) \\<and>\n     ipurge_tr_rev I\\<^sub>2 id (Some a) [] =\n     ipurge_tr_rev I\\<^sub>2 id (Some a) ys \\<and>\n     (next_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n      next_dom_events (P\\<^sub>2 ; Q) id (Some a) ys \\<or>\n      ref_dom_events (P\\<^sub>2 ; Q) id (Some a) [] \\<noteq>\n      ref_dom_events (P\\<^sub>2 ; Q) id (Some a) ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nHere below, the previous results are used to show that constants @{term I\\<^sub>2}, @{term P\\<^sub>2}, @{term Q},\nand @{term id} indeed constitute a counterexample to the statement obtained by replacing process\nsequentiality with weak sequentiality in the assumptions of the security conservation theorem.\n\n\\null\n\\<close>"], ["", "lemma counterexample_2:\n \"\\<not> (secure_termination I\\<^sub>2 id \\<and>\n     ref_union_closed P\\<^sub>2 \\<and>\n     weakly_sequential P\\<^sub>2 \\<and>\n     secure P\\<^sub>2 I\\<^sub>2 id \\<and>\n     secure Q I\\<^sub>2 id \\<longrightarrow>\n   secure (P\\<^sub>2 ; Q) I\\<^sub>2 id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (secure_termination I\\<^sub>2 id \\<and>\n            ref_union_closed P\\<^sub>2 \\<and>\n            weakly_sequential P\\<^sub>2 \\<and>\n            secure P\\<^sub>2 I\\<^sub>2 id \\<and>\n            secure Q I\\<^sub>2 id \\<longrightarrow>\n            secure (P\\<^sub>2 ; Q) I\\<^sub>2 id)", "proof (simp, simp only: conj_assoc [symmetric], (rule conjI)+)"], ["proof (state)\ngoal (6 subgoals):\n 1. secure_termination I\\<^sub>2 id\n 2. ref_union_closed P\\<^sub>2\n 3. weakly_sequential P\\<^sub>2\n 4. secure P\\<^sub>2 I\\<^sub>2 id\n 5. secure Q I\\<^sub>2 id\n 6. \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id", "show \"secure_termination I\\<^sub>2 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure_termination I\\<^sub>2 id", "by (rule secure_termination_2)"], ["proof (state)\nthis:\n  secure_termination I\\<^sub>2 id\n\ngoal (5 subgoals):\n 1. ref_union_closed P\\<^sub>2\n 2. weakly_sequential P\\<^sub>2\n 3. secure P\\<^sub>2 I\\<^sub>2 id\n 4. secure Q I\\<^sub>2 id\n 5. \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. ref_union_closed P\\<^sub>2\n 2. weakly_sequential P\\<^sub>2\n 3. secure P\\<^sub>2 I\\<^sub>2 id\n 4. secure Q I\\<^sub>2 id\n 5. \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id", "show \"ref_union_closed P\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref_union_closed P\\<^sub>2", "by (rule ref_union_closed_fst_2)"], ["proof (state)\nthis:\n  ref_union_closed P\\<^sub>2\n\ngoal (4 subgoals):\n 1. weakly_sequential P\\<^sub>2\n 2. secure P\\<^sub>2 I\\<^sub>2 id\n 3. secure Q I\\<^sub>2 id\n 4. \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. weakly_sequential P\\<^sub>2\n 2. secure P\\<^sub>2 I\\<^sub>2 id\n 3. secure Q I\\<^sub>2 id\n 4. \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id", "show \"weakly_sequential P\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weakly_sequential P\\<^sub>2", "by (rule weakly_sequential_fst_2)"], ["proof (state)\nthis:\n  weakly_sequential P\\<^sub>2\n\ngoal (3 subgoals):\n 1. secure P\\<^sub>2 I\\<^sub>2 id\n 2. secure Q I\\<^sub>2 id\n 3. \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. secure P\\<^sub>2 I\\<^sub>2 id\n 2. secure Q I\\<^sub>2 id\n 3. \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id", "show \"secure P\\<^sub>2 I\\<^sub>2 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure P\\<^sub>2 I\\<^sub>2 id", "by (rule secure_fst_2)"], ["proof (state)\nthis:\n  secure P\\<^sub>2 I\\<^sub>2 id\n\ngoal (2 subgoals):\n 1. secure Q I\\<^sub>2 id\n 2. \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. secure Q I\\<^sub>2 id\n 2. \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id", "show \"secure Q I\\<^sub>2 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure Q I\\<^sub>2 id", "by (rule secure_snd_2)"], ["proof (state)\nthis:\n  secure Q I\\<^sub>2 id\n\ngoal (1 subgoal):\n 1. \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id", "show \"\\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id", "by (rule not_secure_comp_2)"], ["proof (state)\nthis:\n  \\<not> secure (P\\<^sub>2 ; Q) I\\<^sub>2 id\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}