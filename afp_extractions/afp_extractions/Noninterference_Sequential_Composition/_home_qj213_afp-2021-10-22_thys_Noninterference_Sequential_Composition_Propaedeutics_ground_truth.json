{"file_name": "/home/qj213/afp-2021-10-22/thys/Noninterference_Sequential_Composition/Propaedeutics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Noninterference_Sequential_Composition", "problem_names": ["lemma ipurge_tr_length:\n \"length (ipurge_tr I D u xs) \\<le> length xs\"", "lemma ipurge_ref_swap:\n \"ipurge_ref I D u xs {x \\<in> X. P x} =\n  {x \\<in> ipurge_ref I D u xs X. P x}\"", "lemma ipurge_ref_last:\n \"ipurge_ref I D u (xs @ [x]) X =\n   (if (u, D x) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u xs. (v, D x) \\<in> I)\n    then ipurge_ref I D u xs {x' \\<in> X. (D x, D x') \\<notin> I}\n    else ipurge_ref I D u xs X)\"", "lemma sinks_aux_append:\n \"sinks_aux I D U (xs @ ys) = sinks_aux I D (sinks_aux I D U xs) ys\"", "lemma sinks_aux_union:\n \"sinks_aux I D (U \\<union> V) xs =\n  sinks_aux I D U xs \\<union> sinks_aux I D V (ipurge_tr_aux I D U xs)\"", "lemma sinks_aux_subset_dom:\n  assumes A: \"U \\<subseteq> V\"\n  shows \"sinks_aux I D U xs \\<subseteq> sinks_aux I D V xs\"", "lemma sinks_aux_subset_ipurge_tr_aux:\n \"sinks_aux I D U (ipurge_tr_aux I' D' U' xs) \\<subseteq> sinks_aux I D U xs\"", "lemma sinks_aux_subset_ipurge_tr:\n \"sinks_aux I D U (ipurge_tr I' D' u' xs) \\<subseteq> sinks_aux I D U xs\"", "lemma sinks_aux_member_ipurge_tr_aux [rule_format]:\n \"u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n    (u, w) \\<in> I \\<longrightarrow>\n    \\<not> (\\<exists>v \\<in> sinks_aux I D V xs. (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\"", "lemma sinks_aux_member_ipurge_tr:\n  assumes\n    A: \"u \\<in> sinks_aux I D (insert v U) xs\" and\n    B: \"(u, w) \\<in> I\" and\n    C: \"\\<not> ((v, w) \\<in> I \\<or> (\\<exists>v' \\<in> sinks I D v xs. (v', w) \\<in> I))\"\n  shows \"u \\<in> sinks_aux I D U (ipurge_tr I D v xs)\"", "lemma ipurge_tr_aux_append:\n \"ipurge_tr_aux I D U (xs @ ys) =\n  ipurge_tr_aux I D U xs @ ipurge_tr_aux I D (sinks_aux I D U xs) ys\"", "lemma ipurge_tr_aux_single_event:\n \"ipurge_tr_aux I D U [x] = (if \\<exists>v \\<in> U. (v, D x) \\<in> I\n    then []\n    else [x])\"", "lemma ipurge_tr_aux_cons:\n \"ipurge_tr_aux I D U (x # xs) = (if \\<exists>u \\<in> U. (u, D x) \\<in> I\n    then ipurge_tr_aux I D (insert (D x) U) xs\n    else x # ipurge_tr_aux I D U xs)\"", "lemma ipurge_tr_aux_union:\n \"ipurge_tr_aux I D (U \\<union> V) xs =\n  ipurge_tr_aux I D V (ipurge_tr_aux I D U xs)\"", "lemma ipurge_tr_aux_insert:\n \"ipurge_tr_aux I D (insert v U) xs =\n  ipurge_tr_aux I D U (ipurge_tr I D v xs)\"", "lemma ipurge_ref_aux_subset:\n \"ipurge_ref_aux I D U xs X \\<subseteq> X\"", "lemma sinks_aux_sinks_aux_less:\n \"sinks_aux I D U xs = U \\<union> sinks_aux_less I D U xs\"", "lemma sinks_aux_less_single_dom:\n \"sinks_aux_less I D {u} xs = sinks I D u xs\"", "lemma sinks_aux_less_single_event:\n \"sinks_aux_less I D U [x] = (if \\<exists>u \\<in> U. (u, D x) \\<in> I then {D x} else {})\"", "lemma sinks_aux_less_append:\n \"sinks_aux_less I D U (xs @ ys) =\n  sinks_aux_less I D U xs \\<union> sinks_aux_less I D (U \\<union> sinks_aux_less I D U xs) ys\"", "lemma sinks_aux_less_cons:\n \"sinks_aux_less I D U (x # xs) = (if \\<exists>u \\<in> U. (u, D x) \\<in> I\n   then insert (D x) (sinks_aux_less I D (insert (D x) U) xs)\n   else sinks_aux_less I D U xs)\"", "lemma ipurge_ref_aux_less_last:\n \"ipurge_ref_aux_less I D U (xs @ [x]) X =\n   (if \\<exists>v \\<in> U \\<union> sinks_aux_less I D U xs. (v, D x) \\<in> I\n    then ipurge_ref_aux_less I D U xs {x' \\<in> X. (D x, D x') \\<notin> I}\n    else ipurge_ref_aux_less I D U xs X)\"", "lemma ipurge_ref_aux_less_nil:\n \"ipurge_ref_aux_less I D U xs (ipurge_ref_aux I D U [] X) =\n  ipurge_ref_aux I D U xs X\"", "lemma ipurge_ref_aux_less_cons_1:\n  assumes A: \"\\<exists>u \\<in> U. (u, D x) \\<in> I\"\n  shows \"ipurge_ref_aux_less I D U (x # xs) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs) (ipurge_ref I D (D x) xs X)\"", "lemma ipurge_ref_aux_less_cons_2:\n \"\\<not> (\\<exists>u \\<in> U. (u, D x) \\<in> I) \\<Longrightarrow>\n  ipurge_ref_aux_less I D U (x # xs) X =\n    ipurge_ref_aux_less I D U xs X\"", "lemma ipurge_fail_aux_t_subset:\n  assumes A: \"Z \\<in> ipurge_fail_aux_t_set Y\"\n  shows \"ipurge_fail_aux_t_set Z \\<subseteq> ipurge_fail_aux_t_set Y\"", "lemma ipurge_fail_aux_t_aux_set:\n \"ipurge_fail_aux_t_aux Y \\<in> ipurge_fail_aux_t_set Y\"", "lemma ipurge_fail_aux_t_input_1:\n \"ipurge_fail_aux_t_inv_1 I D U xs\n    \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None, Set = X\\<rparr>\"", "lemma ipurge_fail_aux_t_input_2:\n \"ipurge_fail_aux_t_inv_2 I D U xs X\n    \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None, Set = X\\<rparr>\"", "lemma ipurge_fail_aux_t_input_3:\n \"ipurge_fail_aux_t_inv_3 P I D xs X\n    \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None, Set = X\\<rparr>\"", "lemma ipurge_fail_aux_t_intro_1:\n \"\\<lbrakk>ipurge_fail_aux_t_inv_1 I D U xs Y; ipurge_fail_aux_t_form Y\\<rbrakk> \\<Longrightarrow>\n    fst (ipurge_fail_aux_t_out Y) = ipurge_tr_aux I D U xs\"", "lemma ipurge_fail_aux_t_intro_2:\n \"\\<lbrakk>ipurge_fail_aux_t_inv_2 I D U xs X Y; ipurge_fail_aux_t_form Y\\<rbrakk> \\<Longrightarrow>\n    snd (ipurge_fail_aux_t_out Y) = ipurge_ref_aux I D U xs X\"", "lemma ipurge_fail_aux_t_intro_3:\n \"\\<lbrakk>ipurge_fail_aux_t_inv_3 P I D xs X Y; ipurge_fail_aux_t_form Y\\<rbrakk> \\<Longrightarrow>\n    secure P I D \\<longrightarrow> (xs, X) \\<in> failures P \\<longrightarrow>\n      ipurge_fail_aux_t_out Y \\<in> failures P\"", "lemma ipurge_fail_aux_t_form_aux:\n \"ipurge_fail_aux_t_form (ipurge_fail_aux_t_aux Y)\"", "lemma ipurge_fail_aux_t_invariance_aux:\n \"Z \\<in> ipurge_fail_aux_t_set Y \\<Longrightarrow>\n  Pol Z = Pol Y \\<and> Map Z = Map Y \\<and> Doms Z = Doms Y\"", "lemma ipurge_fail_aux_t_invariance_1:\n \"\\<lbrakk>Z \\<in> ipurge_fail_aux_t_set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>);\n    ipurge_fail_aux_t_inv_1 I D U xs (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\\<rbrakk> \\<Longrightarrow>\n  ipurge_fail_aux_t_inv_1 I D U xs Z\"", "lemma ipurge_fail_aux_t_invariance_2:\n \"\\<lbrakk>Z \\<in> ipurge_fail_aux_t_set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>);\n    ipurge_fail_aux_t_inv_2 I D U xs X (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\\<rbrakk> \\<Longrightarrow>\n  ipurge_fail_aux_t_inv_2 I D U xs X Z\"", "lemma ipurge_fail_aux_t_invariance_3:\n \"\\<lbrakk>Z \\<in> ipurge_fail_aux_t_set (Y\\<lparr>Pol := I, Map := D\\<rparr>);\n    ipurge_fail_aux_t_inv_3 P I D xs X (Y\\<lparr>Pol := I, Map := D\\<rparr>)\\<rbrakk> \\<Longrightarrow>\n  ipurge_fail_aux_t_inv_3 P I D xs X Z\"", "lemma ipurge_fail_aux_t_eq_tr:\n \"fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs\"", "lemma ipurge_fail_aux_t_eq_ref:\n \"snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X\"", "lemma ipurge_fail_aux_t_failures [rule_format]:\n \"secure P I D \\<longrightarrow> (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P\"", "lemma ipurge_tr_ref_aux_failures:\n \"\\<lbrakk>secure P I D; (xs, X) \\<in> failures P\\<rbrakk> \\<Longrightarrow>\n    (ipurge_tr_aux I D U xs, ipurge_ref_aux I D U xs X) \\<in> failures P\"", "lemma ipurge_tr_aux_idem:\n \"ipurge_tr_aux I D U (ipurge_tr_aux I D U xs) = ipurge_tr_aux I D U xs\"", "lemma ipurge_tr_aux_set:\n \"set (ipurge_tr_aux I D U xs) \\<subseteq> set xs\"", "lemma ipurge_tr_aux_nil [rule_format]:\n  assumes A: \"u \\<in> U\"\n  shows \"(\\<forall>x \\<in> set xs. (u, D x) \\<in> I) \\<longrightarrow> ipurge_tr_aux I D U xs = []\"", "lemma ipurge_tr_aux_del_failures [rule_format]:\n  assumes S: \"secure P I D\"\n  shows \"(\\<forall>u \\<in> sinks_aux_less I D U ys. \\<forall>z \\<in> Z \\<union> set zs. (u, D z) \\<notin> I) \\<longrightarrow>\n    (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P \\<longrightarrow>\n    xs @ ys \\<in> traces P \\<longrightarrow>\n    (xs @ ys @ zs, Z) \\<in> failures P\"", "lemma ipurge_ref_aux_append:\n \"ipurge_ref_aux I D U (xs @ ys) X = ipurge_ref_aux I D (sinks_aux I D U xs) ys X\"", "lemma ipurge_ref_aux_empty [rule_format]:\n  assumes\n    A: \"u \\<in> sinks_aux I D U xs\" and\n    B: \"\\<forall>x \\<in> X. (u, D x) \\<in> I\"\n  shows \"ipurge_ref_aux I D U xs X = {}\"", "lemma sinks_idem:\n \"sinks I D u (ipurge_tr I D u xs) = {}\"", "lemma sinks_elem [rule_format]:\n \"v \\<in> sinks I D u xs \\<longrightarrow> (\\<exists>x \\<in> set xs. v = D x)\"", "lemma ipurge_tr_append:\n \"ipurge_tr I D u (xs @ ys) =\n  ipurge_tr I D u xs @ ipurge_tr_aux I D (insert u (sinks I D u xs)) ys\"", "lemma ipurge_tr_idem:\n \"ipurge_tr I D u (ipurge_tr I D u xs) = ipurge_tr I D u xs\"", "lemma ipurge_tr_set:\n \"set (ipurge_tr I D u xs) \\<subseteq> set xs\"", "lemma ipurge_tr_del_failures [rule_format]:\n  assumes\n    S: \"secure P I D\" and\n    A: \"\\<forall>v \\<in> sinks I D u ys. \\<forall>z \\<in> Z \\<union> set zs. (v, D z) \\<notin> I\" and\n    B: \"(xs @ ipurge_tr I D u ys @ zs, Z) \\<in> failures P\" and\n    C: \"xs @ ys \\<in> traces P\"\n  shows \"(xs @ ys @ zs, Z) \\<in> failures P\"", "lemma ipurge_tr_del_traces [rule_format]:\n  assumes\n    S: \"secure P I D\" and\n    A: \"\\<forall>v \\<in> sinks I D u ys. \\<forall>z \\<in> set zs. (v, D z) \\<notin> I\" and\n    B: \"xs @ ipurge_tr I D u ys @ zs \\<in> traces P\" and\n    C: \"xs @ ys \\<in> traces P\"\n  shows \"xs @ ys @ zs \\<in> traces P\"", "lemma ipurge_ref_append:\n \"ipurge_ref I D u (xs @ ys) X =\n  ipurge_ref_aux I D (insert u (sinks I D u xs)) ys X\"", "lemma ipurge_ref_distrib_inter:\n \"ipurge_ref I D u xs (X \\<inter> Y) = ipurge_ref I D u xs X \\<inter> ipurge_ref I D u xs Y\"", "lemma ipurge_ref_distrib_union:\n \"ipurge_ref I D u xs (X \\<union> Y) = ipurge_ref I D u xs X \\<union> ipurge_ref I D u xs Y\"", "lemma ipurge_ref_subset:\n \"ipurge_ref I D u xs X \\<subseteq> X\"", "lemma ipurge_ref_subset_union:\n \"ipurge_ref I D u xs (X \\<union> Y) \\<subseteq> X \\<union> ipurge_ref I D u xs Y\"", "lemma ipurge_ref_subset_insert:\n \"ipurge_ref I D u xs (insert x X) \\<subseteq> insert x (ipurge_ref I D u xs X)\"", "lemma ipurge_ref_empty [rule_format]:\n  assumes\n    A: \"v = u \\<or> v \\<in> sinks I D u xs\" and\n    B: \"\\<forall>x \\<in> X. (v, D x) \\<in> I\"\n  shows \"ipurge_ref I D u xs X = {}\"", "lemma process_rule_1:\n \"([], {}) \\<in> failures P\"", "lemma process_rule_5 [rule_format]:\n \"xs \\<in> divergences P \\<longrightarrow> xs @ [x] \\<in> divergences P\"", "lemma process_rule_6 [rule_format]:\n \"xs \\<in> divergences P \\<longrightarrow> (xs, X) \\<in> failures P\""], "translations": [["", "lemma ipurge_tr_length:\n \"length (ipurge_tr I D u xs) \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ipurge_tr I D u xs) \\<le> length xs", "by (induction xs rule: rev_induct, simp_all)"], ["", "lemma ipurge_ref_swap:\n \"ipurge_ref I D u xs {x \\<in> X. P x} =\n  {x \\<in> ipurge_ref I D u xs X. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D u xs {x \\<in> X. P x} =\n    {x \\<in> ipurge_ref I D u xs X. P x}", "proof (simp add: ipurge_ref_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. {x \\<in> X.\n     P x \\<and>\n     (u, D x) \\<notin> I \\<and>\n     (\\<forall>v\\<in>sinks I D u xs. (v, D x) \\<notin> I)} =\n    {x \\<in> X.\n     (u, D x) \\<notin> I \\<and>\n     (\\<forall>v\\<in>sinks I D u xs. (v, D x) \\<notin> I) \\<and> P x}", "qed blast"], ["", "lemma ipurge_ref_last:\n \"ipurge_ref I D u (xs @ [x]) X =\n   (if (u, D x) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u xs. (v, D x) \\<in> I)\n    then ipurge_ref I D u xs {x' \\<in> X. (D x, D x') \\<notin> I}\n    else ipurge_ref I D u xs X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D u (xs @ [x]) X =\n    (if (u, D x) \\<in> I \\<or>\n        (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n     then ipurge_ref I D u xs {x' \\<in> X. (D x, D x') \\<notin> I}\n     else ipurge_ref I D u xs X)", "proof (cases \"(u, D x) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u xs. (v, D x) \\<in> I)\",\n simp_all add: ipurge_ref_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I) \\<Longrightarrow>\n    {xa \\<in> X.\n     (u, D xa) \\<notin> I \\<and>\n     (D x, D xa) \\<notin> I \\<and>\n     (\\<forall>v\\<in>sinks I D u xs. (v, D xa) \\<notin> I)} =\n    {xa \\<in> X.\n     (D x, D xa) \\<notin> I \\<and>\n     (u, D xa) \\<notin> I \\<and>\n     (\\<forall>v\\<in>sinks I D u xs. (v, D xa) \\<notin> I)}", "qed blast"], ["", "text \\<open>\n\\null\n\nHere below is the proof of some properties of function @{term sinks_aux}.\n\n\\null\n\\<close>"], ["", "lemma sinks_aux_append:\n \"sinks_aux I D U (xs @ ys) = sinks_aux I D (sinks_aux I D U xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U (xs @ ys) = sinks_aux I D (sinks_aux I D U xs) ys", "proof (induction ys rule: rev_induct, simp, subst append_assoc [symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       sinks_aux I D U (xs @ xsa) =\n       sinks_aux I D (sinks_aux I D U xs) xsa \\<Longrightarrow>\n       sinks_aux I D U ((xs @ xsa) @ [x]) =\n       sinks_aux I D (sinks_aux I D U xs) (xsa @ [x])", "qed (simp del: append_assoc)"], ["", "lemma sinks_aux_union:\n \"sinks_aux I D (U \\<union> V) xs =\n  sinks_aux I D U xs \\<union> sinks_aux I D V (ipurge_tr_aux I D U xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D (U \\<union> V) xs =\n    sinks_aux I D U xs \\<union> sinks_aux I D V (ipurge_tr_aux I D U xs)", "proof (induction xs rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks_aux I D (U \\<union> V) xs =\n       sinks_aux I D U xs \\<union>\n       sinks_aux I D V (ipurge_tr_aux I D U xs) \\<Longrightarrow>\n       sinks_aux I D (U \\<union> V) (xs @ [x]) =\n       sinks_aux I D U (xs @ [x]) \\<union>\n       sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks_aux I D (U \\<union> V) xs =\n       sinks_aux I D U xs \\<union>\n       sinks_aux I D V (ipurge_tr_aux I D U xs) \\<Longrightarrow>\n       sinks_aux I D (U \\<union> V) (xs @ [x]) =\n       sinks_aux I D U (xs @ [x]) \\<union>\n       sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "assume A: \"sinks_aux I D (U \\<union> V) xs =\n    sinks_aux I D U xs \\<union> sinks_aux I D V (ipurge_tr_aux I D U xs)\""], ["proof (state)\nthis:\n  sinks_aux I D (U \\<union> V) xs =\n  sinks_aux I D U xs \\<union> sinks_aux I D V (ipurge_tr_aux I D U xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks_aux I D (U \\<union> V) xs =\n       sinks_aux I D U xs \\<union>\n       sinks_aux I D V (ipurge_tr_aux I D U xs) \\<Longrightarrow>\n       sinks_aux I D (U \\<union> V) (xs @ [x]) =\n       sinks_aux I D U (xs @ [x]) \\<union>\n       sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "show \"sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union> sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "proof (cases \"\\<exists>w \\<in> sinks_aux I D (U \\<union> V) xs. (w, D x) \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs.\n       (w, D x) \\<in> I \\<Longrightarrow>\n    sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n 2. \\<not> (\\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs.\n               (w, D x) \\<in> I) \\<Longrightarrow>\n    sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "case True"], ["proof (state)\nthis:\n  \\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs. (w, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs.\n       (w, D x) \\<in> I \\<Longrightarrow>\n    sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n 2. \\<not> (\\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs.\n               (w, D x) \\<in> I) \\<Longrightarrow>\n    sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "hence \"\\<exists>w \\<in> sinks_aux I D U xs \\<union> sinks_aux I D V (ipurge_tr_aux I D U xs).\n      (w, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs. (w, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                   sinks_aux I D V (ipurge_tr_aux I D U xs).\n       (w, D x) \\<in> I", "using A"], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs. (w, D x) \\<in> I\n  sinks_aux I D (U \\<union> V) xs =\n  sinks_aux I D U xs \\<union> sinks_aux I D V (ipurge_tr_aux I D U xs)\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                   sinks_aux I D V (ipurge_tr_aux I D U xs).\n       (w, D x) \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                 sinks_aux I D V (ipurge_tr_aux I D U xs).\n     (w, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs.\n       (w, D x) \\<in> I \\<Longrightarrow>\n    sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n 2. \\<not> (\\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs.\n               (w, D x) \\<in> I) \\<Longrightarrow>\n    sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "hence \"(\\<exists>w \\<in> sinks_aux I D U xs. (w, D x) \\<in> I) \\<or>\n      (\\<exists>w \\<in> sinks_aux I D V (ipurge_tr_aux I D U xs). (w, D x) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                 sinks_aux I D V (ipurge_tr_aux I D U xs).\n     (w, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<or>\n    (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n        (w, D x) \\<in> I)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<or>\n  (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n      (w, D x) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs.\n       (w, D x) \\<in> I \\<Longrightarrow>\n    sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n 2. \\<not> (\\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs.\n               (w, D x) \\<in> I) \\<Longrightarrow>\n    sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<or>\n  (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n      (w, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "using A and True"], ["proof (prove)\nusing this:\n  (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<or>\n  (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n      (w, D x) \\<in> I)\n  sinks_aux I D (U \\<union> V) xs =\n  sinks_aux I D U xs \\<union> sinks_aux I D V (ipurge_tr_aux I D U xs)\n  \\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs. (w, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "by (cases \"\\<exists>w \\<in> sinks_aux I D U xs. (w, D x) \\<in> I\", simp_all)"], ["proof (state)\nthis:\n  sinks_aux I D (U \\<union> V) (xs @ [x]) =\n  sinks_aux I D U (xs @ [x]) \\<union>\n  sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs.\n               (w, D x) \\<in> I) \\<Longrightarrow>\n    sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs.\n               (w, D x) \\<in> I) \\<Longrightarrow>\n    sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs. (w, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs.\n               (w, D x) \\<in> I) \\<Longrightarrow>\n    sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "hence \"\\<not> (\\<exists>w \\<in> sinks_aux I D U xs \\<union>\n      sinks_aux I D V (ipurge_tr_aux I D U xs). (w, D x) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs. (w, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                           sinks_aux I D V (ipurge_tr_aux I D U xs).\n               (w, D x) \\<in> I)", "using A"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs. (w, D x) \\<in> I)\n  sinks_aux I D (U \\<union> V) xs =\n  sinks_aux I D U xs \\<union> sinks_aux I D V (ipurge_tr_aux I D U xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                           sinks_aux I D V (ipurge_tr_aux I D U xs).\n               (w, D x) \\<in> I)", "by simp"], ["proof (state)\nthis:\n  \\<not> (\\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                         sinks_aux I D V (ipurge_tr_aux I D U xs).\n             (w, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs.\n               (w, D x) \\<in> I) \\<Longrightarrow>\n    sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "hence \"\\<not> (\\<exists>w \\<in> sinks_aux I D U xs. (w, D x) \\<in> I) \\<and>\n      \\<not> (\\<exists>w \\<in> sinks_aux I D V (ipurge_tr_aux I D U xs). (w, D x) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                         sinks_aux I D V (ipurge_tr_aux I D U xs).\n             (w, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<and>\n    \\<not> (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n               (w, D x) \\<in> I)", "by blast"], ["proof (state)\nthis:\n  \\<not> (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<and>\n  \\<not> (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n             (w, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs.\n               (w, D x) \\<in> I) \\<Longrightarrow>\n    sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<and>\n  \\<not> (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n             (w, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "using A and False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<and>\n  \\<not> (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n             (w, D x) \\<in> I)\n  sinks_aux I D (U \\<union> V) xs =\n  sinks_aux I D U xs \\<union> sinks_aux I D V (ipurge_tr_aux I D U xs)\n  \\<not> (\\<exists>w\\<in>sinks_aux I D (U \\<union> V) xs. (w, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. sinks_aux I D (U \\<union> V) (xs @ [x]) =\n    sinks_aux I D U (xs @ [x]) \\<union>\n    sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D (U \\<union> V) (xs @ [x]) =\n  sinks_aux I D U (xs @ [x]) \\<union>\n  sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sinks_aux I D (U \\<union> V) (xs @ [x]) =\n  sinks_aux I D U (xs @ [x]) \\<union>\n  sinks_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sinks_aux_subset_dom:\n  assumes A: \"U \\<subseteq> V\"\n  shows \"sinks_aux I D U xs \\<subseteq> sinks_aux I D V xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U xs \\<subseteq> sinks_aux I D V xs", "proof (induction xs rule: rev_induct, simp add: A, rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>sinks_aux I D U xs \\<subseteq> sinks_aux I D V xs;\n        xa \\<in> sinks_aux I D U (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> sinks_aux I D V (xs @ [x])", "fix x xs w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>sinks_aux I D U xs \\<subseteq> sinks_aux I D V xs;\n        xa \\<in> sinks_aux I D U (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> sinks_aux I D V (xs @ [x])", "assume\n    B: \"sinks_aux I D U xs \\<subseteq> sinks_aux I D V xs\" and\n    C: \"w \\<in> sinks_aux I D U (xs @ [x])\""], ["proof (state)\nthis:\n  sinks_aux I D U xs \\<subseteq> sinks_aux I D V xs\n  w \\<in> sinks_aux I D U (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>sinks_aux I D U xs \\<subseteq> sinks_aux I D V xs;\n        xa \\<in> sinks_aux I D U (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> sinks_aux I D V (xs @ [x])", "show \"w \\<in> sinks_aux I D V (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D V (xs @ [x])", "proof (cases \"\\<exists>u \\<in> sinks_aux I D U xs. (u, D x) \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "case True"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "hence \"w = D x \\<or> w \\<in> sinks_aux I D U xs\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. w = D x \\<or> w \\<in> sinks_aux I D U xs", "using C"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n  w \\<in> sinks_aux I D U (xs @ [x])\n\ngoal (1 subgoal):\n 1. w = D x \\<or> w \\<in> sinks_aux I D U xs", "by simp"], ["proof (state)\nthis:\n  w = D x \\<or> w \\<in> sinks_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  w = D x \\<or> w \\<in> sinks_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "{"], ["proof (state)\nthis:\n  w = D x \\<or> w \\<in> sinks_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "assume D: \"w = D x\""], ["proof (state)\nthis:\n  w = D x\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "obtain u where E: \"u \\<in> sinks_aux I D U xs\" and F: \"(u, D x) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux I D U xs; (u, D x) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using True"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux I D U xs; (u, D x) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U xs\n  (u, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "have \"u \\<in> sinks_aux I D V xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D V xs", "using B and E"], ["proof (prove)\nusing this:\n  sinks_aux I D U xs \\<subseteq> sinks_aux I D V xs\n  u \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D V xs", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D V xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "with F"], ["proof (chain)\npicking this:\n  (u, D x) \\<in> I\n  u \\<in> sinks_aux I D V xs", "have \"\\<exists>u \\<in> sinks_aux I D V xs. (u, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I\n  u \\<in> sinks_aux I D V xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D V xs. (u, D x) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D V xs. (u, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "hence ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D V xs. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D V (xs @ [x])", "using D"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D V xs. (u, D x) \\<in> I\n  w = D x\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D V (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D V (xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "}"], ["proof (state)\nthis:\n  w = D x \\<Longrightarrow> w \\<in> sinks_aux I D V (xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  w = D x \\<Longrightarrow> w \\<in> sinks_aux I D V (xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "{"], ["proof (state)\nthis:\n  w = D x \\<Longrightarrow> w \\<in> sinks_aux I D V (xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "assume \"w \\<in> sinks_aux I D U xs\""], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "with B"], ["proof (chain)\npicking this:\n  sinks_aux I D U xs \\<subseteq> sinks_aux I D V xs\n  w \\<in> sinks_aux I D U xs", "have \"w \\<in> sinks_aux I D V xs\""], ["proof (prove)\nusing this:\n  sinks_aux I D U xs \\<subseteq> sinks_aux I D V xs\n  w \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D V xs", ".."], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D V xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "hence ?thesis"], ["proof (prove)\nusing this:\n  w \\<in> sinks_aux I D V xs\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D V (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D V (xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "}"], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D U xs \\<Longrightarrow>\n  w \\<in> sinks_aux I D V (xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  w = D x \\<or> w \\<in> sinks_aux I D U xs\n  w = D x \\<Longrightarrow> w \\<in> sinks_aux I D V (xs @ [x])\n  w \\<in> sinks_aux I D U xs \\<Longrightarrow>\n  w \\<in> sinks_aux I D V (xs @ [x])", "show ?thesis"], ["proof (prove)\nusing this:\n  w = D x \\<or> w \\<in> sinks_aux I D U xs\n  w = D x \\<Longrightarrow> w \\<in> sinks_aux I D V (xs @ [x])\n  w \\<in> sinks_aux I D U xs \\<Longrightarrow>\n  w \\<in> sinks_aux I D V (xs @ [x])\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D V (xs @ [x])", ".."], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D V (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "hence \"w \\<in> sinks_aux I D U xs\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D U xs", "using C"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I)\n  w \\<in> sinks_aux I D U (xs @ [x])\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D U xs", "by simp"], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "with B"], ["proof (chain)\npicking this:\n  sinks_aux I D U xs \\<subseteq> sinks_aux I D V xs\n  w \\<in> sinks_aux I D U xs", "have \"w \\<in> sinks_aux I D V xs\""], ["proof (prove)\nusing this:\n  sinks_aux I D U xs \\<subseteq> sinks_aux I D V xs\n  w \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D V xs", ".."], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D V xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D V (xs @ [x])", "thus ?thesis"], ["proof (prove)\nusing this:\n  w \\<in> sinks_aux I D V xs\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D V (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D V (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D V (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sinks_aux_subset_ipurge_tr_aux:\n \"sinks_aux I D U (ipurge_tr_aux I' D' U' xs) \\<subseteq> sinks_aux I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n    \\<subseteq> sinks_aux I D U xs", "proof (induction xs rule: rev_induct, simp, rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n                \\<subseteq> sinks_aux I D U xs;\n        xa \\<in> sinks_aux I D U\n                  (ipurge_tr_aux I' D' U' (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> sinks_aux I D U (xs @ [x])", "fix x xs w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n                \\<subseteq> sinks_aux I D U xs;\n        xa \\<in> sinks_aux I D U\n                  (ipurge_tr_aux I' D' U' (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> sinks_aux I D U (xs @ [x])", "assume\n    A: \"sinks_aux I D U (ipurge_tr_aux I' D' U' xs) \\<subseteq> sinks_aux I D U xs\" and\n    B: \"w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' (xs @ [x]))\""], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr_aux I' D' U' xs) \\<subseteq> sinks_aux I D U xs\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n                \\<subseteq> sinks_aux I D U xs;\n        xa \\<in> sinks_aux I D U\n                  (ipurge_tr_aux I' D' U' (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> sinks_aux I D U (xs @ [x])", "show \"w \\<in> sinks_aux I D U (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D U (xs @ [x])", "proof (cases \"\\<exists>u \\<in> sinks_aux I D U xs. (u, D x) \\<in> I\", simp_all (no_asm_simp))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w = D x \\<or> w \\<in> sinks_aux I D U xs\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "from B"], ["proof (chain)\npicking this:\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' (xs @ [x]))", "have \"w = D x \\<or> w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\""], ["proof (prove)\nusing this:\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' (xs @ [x]))\n\ngoal (1 subgoal):\n 1. w = D x \\<or> w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "proof (cases \"\\<exists>u' \\<in> sinks_aux I' D' U' xs. (u', D' x) \\<in> I'\", simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> (if \\<exists>v\\<in>sinks_aux I D U\n   (ipurge_tr_aux I' D' U' xs).\n                            (v, D x) \\<in> I\n                      then insert (D x)\n                            (sinks_aux I D U (ipurge_tr_aux I' D' U' xs))\n                      else sinks_aux I D U (ipurge_tr_aux I' D' U' xs));\n     \\<forall>u'\\<in>sinks_aux I' D' U' xs. (u', D' x) \\<notin> I'\\<rbrakk>\n    \\<Longrightarrow> w = D x \\<or>\n                      w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "qed (cases \"\\<exists>u \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs). (u, D x) \\<in> I\",\n     simp_all)"], ["proof (state)\nthis:\n  w = D x \\<or> w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w = D x \\<or> w \\<in> sinks_aux I D U xs\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "moreover"], ["proof (state)\nthis:\n  w = D x \\<or> w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w = D x \\<or> w \\<in> sinks_aux I D U xs\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "{"], ["proof (state)\nthis:\n  w = D x \\<or> w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w = D x \\<or> w \\<in> sinks_aux I D U xs\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "assume \"w = D x\""], ["proof (state)\nthis:\n  w = D x\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w = D x \\<or> w \\<in> sinks_aux I D U xs\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "hence \"w = D x \\<or> w \\<in> sinks_aux I D U xs\""], ["proof (prove)\nusing this:\n  w = D x\n\ngoal (1 subgoal):\n 1. w = D x \\<or> w \\<in> sinks_aux I D U xs", ".."], ["proof (state)\nthis:\n  w = D x \\<or> w \\<in> sinks_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w = D x \\<or> w \\<in> sinks_aux I D U xs\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "}"], ["proof (state)\nthis:\n  w = D x \\<Longrightarrow> w = D x \\<or> w \\<in> sinks_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w = D x \\<or> w \\<in> sinks_aux I D U xs\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "moreover"], ["proof (state)\nthis:\n  w = D x \\<Longrightarrow> w = D x \\<or> w \\<in> sinks_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w = D x \\<or> w \\<in> sinks_aux I D U xs\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "{"], ["proof (state)\nthis:\n  w = D x \\<Longrightarrow> w = D x \\<or> w \\<in> sinks_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w = D x \\<or> w \\<in> sinks_aux I D U xs\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "assume \"w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\""], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w = D x \\<or> w \\<in> sinks_aux I D U xs\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "with A"], ["proof (chain)\npicking this:\n  sinks_aux I D U (ipurge_tr_aux I' D' U' xs) \\<subseteq> sinks_aux I D U xs\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "have \"w \\<in> sinks_aux I D U xs\""], ["proof (prove)\nusing this:\n  sinks_aux I D U (ipurge_tr_aux I' D' U' xs) \\<subseteq> sinks_aux I D U xs\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D U xs", ".."], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w = D x \\<or> w \\<in> sinks_aux I D U xs\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "hence \"w = D x \\<or> w \\<in> sinks_aux I D U xs\""], ["proof (prove)\nusing this:\n  w \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. w = D x \\<or> w \\<in> sinks_aux I D U xs", ".."], ["proof (state)\nthis:\n  w = D x \\<or> w \\<in> sinks_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w = D x \\<or> w \\<in> sinks_aux I D U xs\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "}"], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs) \\<Longrightarrow>\n  w = D x \\<or> w \\<in> sinks_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    w = D x \\<or> w \\<in> sinks_aux I D U xs\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "ultimately"], ["proof (chain)\npicking this:\n  w = D x \\<or> w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n  w = D x \\<Longrightarrow> w = D x \\<or> w \\<in> sinks_aux I D U xs\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs) \\<Longrightarrow>\n  w = D x \\<or> w \\<in> sinks_aux I D U xs", "show \"w = D x \\<or> w \\<in> sinks_aux I D U xs\""], ["proof (prove)\nusing this:\n  w = D x \\<or> w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n  w = D x \\<Longrightarrow> w = D x \\<or> w \\<in> sinks_aux I D U xs\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs) \\<Longrightarrow>\n  w = D x \\<or> w \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. w = D x \\<or> w \\<in> sinks_aux I D U xs", ".."], ["proof (state)\nthis:\n  w = D x \\<or> w \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "assume C: \"\\<not> (\\<exists>u \\<in> sinks_aux I D U xs. (u, D x) \\<in> I)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "have \"w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "proof (cases \"\\<exists>u' \\<in> sinks_aux I' D' U' xs. (u', D' x) \\<in> I'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I' D' U' xs.\n       (u', D' x) \\<in> I' \\<Longrightarrow>\n    w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I' D' U' xs.\n               (u', D' x) \\<in> I') \\<Longrightarrow>\n    w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "case True"], ["proof (state)\nthis:\n  \\<exists>u'\\<in>sinks_aux I' D' U' xs. (u', D' x) \\<in> I'\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I' D' U' xs.\n       (u', D' x) \\<in> I' \\<Longrightarrow>\n    w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I' D' U' xs.\n               (u', D' x) \\<in> I') \\<Longrightarrow>\n    w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "thus \"w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\""], ["proof (prove)\nusing this:\n  \\<exists>u'\\<in>sinks_aux I' D' U' xs. (u', D' x) \\<in> I'\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "using B"], ["proof (prove)\nusing this:\n  \\<exists>u'\\<in>sinks_aux I' D' U' xs. (u', D' x) \\<in> I'\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' (xs @ [x]))\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "by simp"], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I' D' U' xs.\n               (u', D' x) \\<in> I') \\<Longrightarrow>\n    w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I' D' U' xs.\n               (u', D' x) \\<in> I') \\<Longrightarrow>\n    w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u'\\<in>sinks_aux I' D' U' xs. (u', D' x) \\<in> I')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I' D' U' xs.\n               (u', D' x) \\<in> I') \\<Longrightarrow>\n    w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "hence \"w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs @ [x])\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u'\\<in>sinks_aux I' D' U' xs. (u', D' x) \\<in> I')\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs @ [x])", "using B"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u'\\<in>sinks_aux I' D' U' xs. (u', D' x) \\<in> I')\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' (xs @ [x]))\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs @ [x])", "by simp"], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I' D' U' xs.\n               (u', D' x) \\<in> I') \\<Longrightarrow>\n    w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "moreover"], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I' D' U' xs.\n               (u', D' x) \\<in> I') \\<Longrightarrow>\n    w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "have\n       \"\\<not> (\\<exists>u \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs). (u, D x) \\<in> I)\"\n       (is \"\\<not> ?P\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U (ipurge_tr_aux I' D' U' xs).\n               (u, D x) \\<in> I)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U (ipurge_tr_aux I' D' U' xs).\n       (u, D x) \\<in> I \\<Longrightarrow>\n    False", "assume ?P"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U (ipurge_tr_aux I' D' U' xs).\n     (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U (ipurge_tr_aux I' D' U' xs).\n       (u, D x) \\<in> I \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>sinks_aux I D U (ipurge_tr_aux I' D' U' xs).\n     (u, D x) \\<in> I", "obtain u where\n          D: \"u \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\" and\n          E: \"(u, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U (ipurge_tr_aux I' D' U' xs).\n     (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs);\n         (u, D x) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n  (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U (ipurge_tr_aux I' D' U' xs).\n       (u, D x) \\<in> I \\<Longrightarrow>\n    False", "have \"u \\<in> sinks_aux I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U xs", "using A and D"], ["proof (prove)\nusing this:\n  sinks_aux I D U (ipurge_tr_aux I' D' U' xs) \\<subseteq> sinks_aux I D U xs\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U xs", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U (ipurge_tr_aux I' D' U' xs).\n       (u, D x) \\<in> I \\<Longrightarrow>\n    False", "with E"], ["proof (chain)\npicking this:\n  (u, D x) \\<in> I\n  u \\<in> sinks_aux I D U xs", "have \"\\<exists>u \\<in> sinks_aux I D U xs. (u, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I\n  u \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U (ipurge_tr_aux I' D' U' xs).\n       (u, D x) \\<in> I \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U (ipurge_tr_aux I' D' U' xs).\n             (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I' D' U' xs.\n               (u', D' x) \\<in> I') \\<Longrightarrow>\n    w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "ultimately"], ["proof (chain)\npicking this:\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs @ [x])\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U (ipurge_tr_aux I' D' U' xs).\n             (u, D x) \\<in> I)", "show \"w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\""], ["proof (prove)\nusing this:\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs @ [x])\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U (ipurge_tr_aux I' D' U' xs).\n             (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "by simp"], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    w \\<in> sinks_aux I D U xs", "with A"], ["proof (chain)\npicking this:\n  sinks_aux I D U (ipurge_tr_aux I' D' U' xs) \\<subseteq> sinks_aux I D U xs\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)", "show \"w \\<in> sinks_aux I D U xs\""], ["proof (prove)\nusing this:\n  sinks_aux I D U (ipurge_tr_aux I' D' U' xs) \\<subseteq> sinks_aux I D U xs\n  w \\<in> sinks_aux I D U (ipurge_tr_aux I' D' U' xs)\n\ngoal (1 subgoal):\n 1. w \\<in> sinks_aux I D U xs", ".."], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D U xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w \\<in> sinks_aux I D U (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sinks_aux_subset_ipurge_tr:\n \"sinks_aux I D U (ipurge_tr I' D' u' xs) \\<subseteq> sinks_aux I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U (ipurge_tr I' D' u' xs) \\<subseteq> sinks_aux I D U xs", "by (simp add: ipurge_tr_aux_single_dom [symmetric] sinks_aux_subset_ipurge_tr_aux)"], ["", "lemma sinks_aux_member_ipurge_tr_aux [rule_format]:\n \"u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n    (u, w) \\<in> I \\<longrightarrow>\n    \\<not> (\\<exists>v \\<in> sinks_aux I D V xs. (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n    (u, w) \\<in> I \\<longrightarrow>\n    \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n               (v, w) \\<in> I) \\<longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "proof (induction xs arbitrary: u w rule: rev_induct, (rule_tac [!] impI)+, simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "fix u w"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "assume\n    A: \"(u, w) \\<in> I\" and\n    B: \"\\<forall>v \\<in> V. (v, w) \\<notin> I\""], ["proof (state)\nthis:\n  (u, w) \\<in> I\n  \\<forall>v\\<in>V. (v, w) \\<notin> I\n\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "assume \"u \\<in> U \\<or> u \\<in> V\""], ["proof (state)\nthis:\n  u \\<in> U \\<or> u \\<in> V\n\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  u \\<in> U \\<or> u \\<in> V\n\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "{"], ["proof (state)\nthis:\n  u \\<in> U \\<or> u \\<in> V\n\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "assume \"u \\<in> U\""], ["proof (state)\nthis:\n  u \\<in> U\n\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "}"], ["proof (state)\nthis:\n  u \\<in> U \\<Longrightarrow> u \\<in> U\n\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  u \\<in> U \\<Longrightarrow> u \\<in> U\n\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "{"], ["proof (state)\nthis:\n  u \\<in> U \\<Longrightarrow> u \\<in> U\n\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "assume \"u \\<in> V\""], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "with B"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>V. (v, w) \\<notin> I\n  u \\<in> V", "have \"(u, w) \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V. (v, w) \\<notin> I\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. (u, w) \\<notin> I", ".."], ["proof (state)\nthis:\n  (u, w) \\<notin> I\n\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "hence \"u \\<in> U\""], ["proof (prove)\nusing this:\n  (u, w) \\<notin> I\n\ngoal (1 subgoal):\n 1. u \\<in> U", "using A"], ["proof (prove)\nusing this:\n  (u, w) \\<notin> I\n  (u, w) \\<in> I\n\ngoal (1 subgoal):\n 1. u \\<in> U", "by contradiction"], ["proof (state)\nthis:\n  u \\<in> U\n\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "}"], ["proof (state)\nthis:\n  u \\<in> V \\<Longrightarrow> u \\<in> U\n\ngoal (2 subgoals):\n 1. \\<And>u w.\n       \\<lbrakk>u \\<in> U \\<or> u \\<in> V; (u, w) \\<in> I;\n        \\<forall>v\\<in>V. (v, w) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> u \\<in> U\n 2. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> U \\<or> u \\<in> V\n  u \\<in> U \\<Longrightarrow> u \\<in> U\n  u \\<in> V \\<Longrightarrow> u \\<in> U", "show \"u \\<in> U\""], ["proof (prove)\nusing this:\n  u \\<in> U \\<or> u \\<in> V\n  u \\<in> U \\<Longrightarrow> u \\<in> U\n  u \\<in> V \\<Longrightarrow> u \\<in> U\n\ngoal (1 subgoal):\n 1. u \\<in> U", ".."], ["proof (state)\nthis:\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "fix x xs u w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "assume\n    A: \"\\<And>u w. u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n      (u, w) \\<in> I \\<longrightarrow>\n      \\<not> (\\<exists>v \\<in> sinks_aux I D V xs. (v, w) \\<in> I) \\<longrightarrow>\n      u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\" and\n    B: \"u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x])\" and\n    C: \"(u, w) \\<in> I\" and\n    D: \"\\<not> (\\<exists>v \\<in> sinks_aux I D V (xs @ [x]). (v, w) \\<in> I)\""], ["proof (state)\nthis:\n  ?u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (?u, ?w) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, ?w) \\<in> I) \\<longrightarrow>\n  ?u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n  u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x])\n  (u, w) \\<in> I\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>x xs u w.\n       \\<lbrakk>\\<And>u w.\n                   u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n                   (u, w) \\<in> I \\<longrightarrow>\n                   \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n                              (v, w) \\<in> I) \\<longrightarrow>\n                   u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs);\n        u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x]); (u, w) \\<in> I;\n        \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]).\n                   (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> u \\<in> sinks_aux I D U\n                                  (ipurge_tr_aux I D V (xs @ [x]))", "show \"u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "proof (cases \"\\<exists>u' \\<in> sinks_aux I D (U \\<union> V) xs. (u', D x) \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "case True"], ["proof (state)\nthis:\n  \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs. (u', D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "hence \"u = D x \\<or> u \\<in> sinks_aux I D (U \\<union> V) xs\""], ["proof (prove)\nusing this:\n  \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs. (u', D x) \\<in> I\n\ngoal (1 subgoal):\n 1. u = D x \\<or> u \\<in> sinks_aux I D (U \\<union> V) xs", "using B"], ["proof (prove)\nusing this:\n  \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs. (u', D x) \\<in> I\n  u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x])\n\ngoal (1 subgoal):\n 1. u = D x \\<or> u \\<in> sinks_aux I D (U \\<union> V) xs", "by simp"], ["proof (state)\nthis:\n  u = D x \\<or> u \\<in> sinks_aux I D (U \\<union> V) xs\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  u = D x \\<or> u \\<in> sinks_aux I D (U \\<union> V) xs\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "{"], ["proof (state)\nthis:\n  u = D x \\<or> u \\<in> sinks_aux I D (U \\<union> V) xs\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "assume E: \"u = D x\""], ["proof (state)\nthis:\n  u = D x\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "obtain u' where \"u' \\<in> sinks_aux I D (U \\<union> V) xs\" and F: \"(u', D x) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>u' \\<in> sinks_aux I D (U \\<union> V) xs;\n         (u', D x) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using True"], ["proof (prove)\nusing this:\n  \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs. (u', D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>u' \\<in> sinks_aux I D (U \\<union> V) xs;\n         (u', D x) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u' \\<in> sinks_aux I D (U \\<union> V) xs\n  (u', D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  u' \\<in> sinks_aux I D (U \\<union> V) xs\n  (u', D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "have \"u' \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n        (u', D x) \\<in> I \\<longrightarrow>\n        \\<not> (\\<exists>v \\<in> sinks_aux I D V xs. (v, D x) \\<in> I) \\<longrightarrow>\n        u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\"\n       (is \"_ \\<longrightarrow> _ \\<longrightarrow> \\<not> ?P \\<longrightarrow> ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. u' \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n    (u', D x) \\<in> I \\<longrightarrow>\n    \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n               (v, D x) \\<in> I) \\<longrightarrow>\n    u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "using A"], ["proof (prove)\nusing this:\n  ?u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (?u, ?w) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, ?w) \\<in> I) \\<longrightarrow>\n  ?u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (1 subgoal):\n 1. u' \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n    (u', D x) \\<in> I \\<longrightarrow>\n    \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n               (v, D x) \\<in> I) \\<longrightarrow>\n    u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "."], ["proof (state)\nthis:\n  u' \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (u', D x) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, D x) \\<in> I) \\<longrightarrow>\n  u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  u' \\<in> sinks_aux I D (U \\<union> V) xs\n  (u', D x) \\<in> I\n  u' \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (u', D x) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, D x) \\<in> I) \\<longrightarrow>\n  u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "have \"\\<not> ?P \\<longrightarrow> ?Q\""], ["proof (prove)\nusing this:\n  u' \\<in> sinks_aux I D (U \\<union> V) xs\n  (u', D x) \\<in> I\n  u' \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (u', D x) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, D x) \\<in> I) \\<longrightarrow>\n  u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n               (v, D x) \\<in> I) \\<longrightarrow>\n    u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "by simp"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, D x) \\<in> I) \\<longrightarrow>\n  u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, D x) \\<in> I) \\<longrightarrow>\n  u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "have \"\\<not> ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I \\<Longrightarrow>\n    False", "have \"(D x, w) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D x, w) \\<in> I", "using C and E"], ["proof (prove)\nusing this:\n  (u, w) \\<in> I\n  u = D x\n\ngoal (1 subgoal):\n 1. (D x, w) \\<in> I", "by simp"], ["proof (state)\nthis:\n  (D x, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (D x, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I \\<Longrightarrow>\n    False", "assume ?P"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I \\<Longrightarrow>\n    False", "hence \"D x \\<in> sinks_aux I D V (xs @ [x])\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. D x \\<in> sinks_aux I D V (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  D x \\<in> sinks_aux I D V (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  (D x, w) \\<in> I\n  D x \\<in> sinks_aux I D V (xs @ [x])", "have \"\\<exists>v \\<in> sinks_aux I D V (xs @ [x]). (v, w) \\<in> I\""], ["proof (prove)\nusing this:\n  (D x, w) \\<in> I\n  D x \\<in> sinks_aux I D V (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I \\<Longrightarrow>\n    False", "have \"\\<not> (\\<exists>v \\<in> sinks_aux I D V (xs @ [x]). (v, w) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I)", "using D"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I)", "by simp"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I)", "show False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, D x) \\<in> I) \\<longrightarrow>\n  u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I)", "have ?Q"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, D x) \\<in> I) \\<longrightarrow>\n  u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", ".."], ["proof (state)\nthis:\n  u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "with F"], ["proof (chain)\npicking this:\n  (u', D x) \\<in> I\n  u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "have \"\\<exists>u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs).\n        (u', D x) \\<in> I\""], ["proof (prove)\nusing this:\n  (u', D x) \\<in> I\n  u' \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (1 subgoal):\n 1. \\<exists>u'\\<in>sinks_aux I D U (ipurge_tr_aux I D V xs).\n       (u', D x) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u'\\<in>sinks_aux I D U (ipurge_tr_aux I D V xs).\n     (u', D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "hence \"D x \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs @ [x])\""], ["proof (prove)\nusing this:\n  \\<exists>u'\\<in>sinks_aux I D U (ipurge_tr_aux I D V xs).\n     (u', D x) \\<in> I\n\ngoal (1 subgoal):\n 1. D x \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs @ [x])", "by simp"], ["proof (state)\nthis:\n  D x \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  D x \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "have \"ipurge_tr_aux I D V xs @ [x] =\n        ipurge_tr_aux I D V (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D V xs @ [x] = ipurge_tr_aux I D V (xs @ [x])", "using \\<open>\\<not> ?P\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs. (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D V xs @ [x] = ipurge_tr_aux I D V (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D V xs @ [x] = ipurge_tr_aux I D V (xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  D x \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs @ [x])\n  ipurge_tr_aux I D V xs @ [x] = ipurge_tr_aux I D V (xs @ [x])", "have ?thesis"], ["proof (prove)\nusing this:\n  D x \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs @ [x])\n  ipurge_tr_aux I D V xs @ [x] = ipurge_tr_aux I D V (xs @ [x])\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "using E"], ["proof (prove)\nusing this:\n  D x \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs @ [x])\n  ipurge_tr_aux I D V xs @ [x] = ipurge_tr_aux I D V (xs @ [x])\n  u = D x\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "}"], ["proof (state)\nthis:\n  u = D x \\<Longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  u = D x \\<Longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "{"], ["proof (state)\nthis:\n  u = D x \\<Longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "assume \"u \\<in> sinks_aux I D (U \\<union> V) xs\""], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D (U \\<union> V) xs\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D (U \\<union> V) xs\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "have \"u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n        (u, w) \\<in> I \\<longrightarrow>\n        \\<not> (\\<exists>v \\<in> sinks_aux I D V xs. (v, w) \\<in> I) \\<longrightarrow>\n        u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\"\n       (is \"_ \\<longrightarrow> _ \\<longrightarrow> \\<not> ?P \\<longrightarrow> ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n    (u, w) \\<in> I \\<longrightarrow>\n    \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n               (v, w) \\<in> I) \\<longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "using A"], ["proof (prove)\nusing this:\n  ?u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (?u, ?w) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, ?w) \\<in> I) \\<longrightarrow>\n  ?u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n    (u, w) \\<in> I \\<longrightarrow>\n    \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n               (v, w) \\<in> I) \\<longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (u, w) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> sinks_aux I D (U \\<union> V) xs\n  u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (u, w) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "have \"\\<not> ?P \\<longrightarrow> ?Q\""], ["proof (prove)\nusing this:\n  u \\<in> sinks_aux I D (U \\<union> V) xs\n  u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (u, w) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n               (v, w) \\<in> I) \\<longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "using C"], ["proof (prove)\nusing this:\n  u \\<in> sinks_aux I D (U \\<union> V) xs\n  u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (u, w) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n  (u, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n               (v, w) \\<in> I) \\<longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "by simp"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "have \"\\<not> ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I \\<Longrightarrow>\n    False", "assume ?P"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I \\<Longrightarrow>\n    False", "hence \"\\<exists>v \\<in> sinks_aux I D V (xs @ [x]). (v, w) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using D"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I)", "have \"u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "hence ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "}"], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D (U \\<union> V) xs \\<Longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n\ngoal (2 subgoals):\n 1. \\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n       (u', D x) \\<in> I \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n 2. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  u = D x \\<or> u \\<in> sinks_aux I D (U \\<union> V) xs\n  u = D x \\<Longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n  u \\<in> sinks_aux I D (U \\<union> V) xs \\<Longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  u = D x \\<or> u \\<in> sinks_aux I D (U \\<union> V) xs\n  u = D x \\<Longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n  u \\<in> sinks_aux I D (U \\<union> V) xs \\<Longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n             (u', D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "hence \"u \\<in> sinks_aux I D (U \\<union> V) xs\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n             (u', D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D (U \\<union> V) xs", "using B"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n             (u', D x) \\<in> I)\n  u \\<in> sinks_aux I D (U \\<union> V) (xs @ [x])\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D (U \\<union> V) xs", "by simp"], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D (U \\<union> V) xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D (U \\<union> V) xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "have \"u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n      (u, w) \\<in> I \\<longrightarrow>\n      \\<not> (\\<exists>v \\<in> sinks_aux I D V xs. (v, w) \\<in> I) \\<longrightarrow>\n      u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\"\n     (is \"_ \\<longrightarrow> _ \\<longrightarrow> \\<not> ?P \\<longrightarrow> ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n    (u, w) \\<in> I \\<longrightarrow>\n    \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n               (v, w) \\<in> I) \\<longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "using A"], ["proof (prove)\nusing this:\n  ?u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (?u, ?w) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, ?w) \\<in> I) \\<longrightarrow>\n  ?u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n    (u, w) \\<in> I \\<longrightarrow>\n    \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n               (v, w) \\<in> I) \\<longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (u, w) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> sinks_aux I D (U \\<union> V) xs\n  u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (u, w) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "have \"\\<not> ?P \\<longrightarrow> ?Q\""], ["proof (prove)\nusing this:\n  u \\<in> sinks_aux I D (U \\<union> V) xs\n  u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (u, w) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n               (v, w) \\<in> I) \\<longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "using C"], ["proof (prove)\nusing this:\n  u \\<in> sinks_aux I D (U \\<union> V) xs\n  u \\<in> sinks_aux I D (U \\<union> V) xs \\<longrightarrow>\n  (u, w) \\<in> I \\<longrightarrow>\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n  (u, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n               (v, w) \\<in> I) \\<longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", "by simp"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "have \"\\<not> ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I \\<Longrightarrow>\n    False", "assume ?P"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I \\<Longrightarrow>\n    False", "hence \"\\<exists>v \\<in> sinks_aux I D V (xs @ [x]). (v, w) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using D"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V (xs @ [x]). (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I)", "have \"u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs.\n             (v, w) \\<in> I) \\<longrightarrow>\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n  \\<not> (\\<exists>v\\<in>sinks_aux I D V xs. (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u'\\<in>sinks_aux I D (U \\<union> V) xs.\n               (u', D x) \\<in> I) \\<Longrightarrow>\n    u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V xs)\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U (ipurge_tr_aux I D V (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sinks_aux_member_ipurge_tr:\n  assumes\n    A: \"u \\<in> sinks_aux I D (insert v U) xs\" and\n    B: \"(u, w) \\<in> I\" and\n    C: \"\\<not> ((v, w) \\<in> I \\<or> (\\<exists>v' \\<in> sinks I D v xs. (v', w) \\<in> I))\"\n  shows \"u \\<in> sinks_aux I D U (ipurge_tr I D v xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U (ipurge_tr I D v xs)", "proof (subst ipurge_tr_aux_single_dom [symmetric],\n rule_tac w = w in sinks_aux_member_ipurge_tr_aux)"], ["proof (state)\ngoal (3 subgoals):\n 1. u \\<in> sinks_aux I D (U \\<union> {v}) xs\n 2. (u, w) \\<in> I\n 3. \\<not> (\\<exists>v\\<in>sinks_aux I D {v} xs. (v, w) \\<in> I)", "show \"u \\<in> sinks_aux I D (U \\<union> {v}) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D (U \\<union> {v}) xs", "using A"], ["proof (prove)\nusing this:\n  u \\<in> sinks_aux I D (insert v U) xs\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D (U \\<union> {v}) xs", "by simp"], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D (U \\<union> {v}) xs\n\ngoal (2 subgoals):\n 1. (u, w) \\<in> I\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D {v} xs. (v, w) \\<in> I)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (u, w) \\<in> I\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D {v} xs. (v, w) \\<in> I)", "show \"(u, w) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, w) \\<in> I", "using B"], ["proof (prove)\nusing this:\n  (u, w) \\<in> I\n\ngoal (1 subgoal):\n 1. (u, w) \\<in> I", "."], ["proof (state)\nthis:\n  (u, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D {v} xs. (v, w) \\<in> I)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D {v} xs. (v, w) \\<in> I)", "show \"\\<not> (\\<exists>v' \\<in> sinks_aux I D {v} xs. (v', w) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v'\\<in>sinks_aux I D {v} xs. (v', w) \\<in> I)", "using C"], ["proof (prove)\nusing this:\n  \\<not> ((v, w) \\<in> I \\<or>\n          (\\<exists>v'\\<in>sinks I D v xs. (v', w) \\<in> I))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v'\\<in>sinks_aux I D {v} xs. (v', w) \\<in> I)", "by (simp add: sinks_aux_single_dom)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v'\\<in>sinks_aux I D {v} xs. (v', w) \\<in> I)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nHere below is the proof of some properties of functions @{term ipurge_tr_aux} and\n@{term ipurge_ref_aux}.\n\n\\null\n\\<close>"], ["", "lemma ipurge_tr_aux_append:\n \"ipurge_tr_aux I D U (xs @ ys) =\n  ipurge_tr_aux I D U xs @ ipurge_tr_aux I D (sinks_aux I D U xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (xs @ ys) =\n    ipurge_tr_aux I D U xs @ ipurge_tr_aux I D (sinks_aux I D U xs) ys", "proof (induction ys rule: rev_induct, simp, subst append_assoc [symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       ipurge_tr_aux I D U (xs @ xsa) =\n       ipurge_tr_aux I D U xs @\n       ipurge_tr_aux I D (sinks_aux I D U xs) xsa \\<Longrightarrow>\n       ipurge_tr_aux I D U ((xs @ xsa) @ [x]) =\n       ipurge_tr_aux I D U xs @\n       ipurge_tr_aux I D (sinks_aux I D U xs) (xsa @ [x])", "qed (simp add: sinks_aux_append del: append_assoc)"], ["", "lemma ipurge_tr_aux_single_event:\n \"ipurge_tr_aux I D U [x] = (if \\<exists>v \\<in> U. (v, D x) \\<in> I\n    then []\n    else [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U [x] =\n    (if \\<exists>v\\<in>U. (v, D x) \\<in> I then [] else [x])", "by (subst (2) append_Nil [symmetric], simp del: append_Nil)"], ["", "lemma ipurge_tr_aux_cons:\n \"ipurge_tr_aux I D U (x # xs) = (if \\<exists>u \\<in> U. (u, D x) \\<in> I\n    then ipurge_tr_aux I D (insert (D x) U) xs\n    else x # ipurge_tr_aux I D U xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (x # xs) =\n    (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n     then ipurge_tr_aux I D (insert (D x) U) xs\n     else x # ipurge_tr_aux I D U xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (x # xs) =\n    (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n     then ipurge_tr_aux I D (insert (D x) U) xs\n     else x # ipurge_tr_aux I D U xs)", "have \"ipurge_tr_aux I D U (x # xs) = ipurge_tr_aux I D U ([x] @ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (x # xs) = ipurge_tr_aux I D U ([x] @ xs)", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D U (x # xs) = ipurge_tr_aux I D U ([x] @ xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (x # xs) =\n    (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n     then ipurge_tr_aux I D (insert (D x) U) xs\n     else x # ipurge_tr_aux I D U xs)", "also"], ["proof (state)\nthis:\n  ipurge_tr_aux I D U (x # xs) = ipurge_tr_aux I D U ([x] @ xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (x # xs) =\n    (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n     then ipurge_tr_aux I D (insert (D x) U) xs\n     else x # ipurge_tr_aux I D U xs)", "have \"\\<dots> =\n    ipurge_tr_aux I D U [x] @ ipurge_tr_aux I D (sinks_aux I D U [x]) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U ([x] @ xs) =\n    ipurge_tr_aux I D U [x] @ ipurge_tr_aux I D (sinks_aux I D U [x]) xs", "by (simp only: ipurge_tr_aux_append)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D U ([x] @ xs) =\n  ipurge_tr_aux I D U [x] @ ipurge_tr_aux I D (sinks_aux I D U [x]) xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (x # xs) =\n    (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n     then ipurge_tr_aux I D (insert (D x) U) xs\n     else x # ipurge_tr_aux I D U xs)", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr_aux I D U (x # xs) =\n  ipurge_tr_aux I D U [x] @ ipurge_tr_aux I D (sinks_aux I D U [x]) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D U (x # xs) =\n  ipurge_tr_aux I D U [x] @ ipurge_tr_aux I D (sinks_aux I D U [x]) xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (x # xs) =\n    (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n     then ipurge_tr_aux I D (insert (D x) U) xs\n     else x # ipurge_tr_aux I D U xs)", "by (simp add: sinks_aux_single_event ipurge_tr_aux_single_event)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D U (x # xs) =\n  (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n   then ipurge_tr_aux I D (insert (D x) U) xs\n   else x # ipurge_tr_aux I D U xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_aux_union:\n \"ipurge_tr_aux I D (U \\<union> V) xs =\n  ipurge_tr_aux I D V (ipurge_tr_aux I D U xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (U \\<union> V) xs =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U xs)", "proof (induction xs rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr_aux I D (U \\<union> V) xs =\n       ipurge_tr_aux I D V (ipurge_tr_aux I D U xs) \\<Longrightarrow>\n       ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n       ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr_aux I D (U \\<union> V) xs =\n       ipurge_tr_aux I D V (ipurge_tr_aux I D U xs) \\<Longrightarrow>\n       ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n       ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "assume A: \"ipurge_tr_aux I D (U \\<union> V) xs =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U xs)\""], ["proof (state)\nthis:\n  ipurge_tr_aux I D (U \\<union> V) xs =\n  ipurge_tr_aux I D V (ipurge_tr_aux I D U xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr_aux I D (U \\<union> V) xs =\n       ipurge_tr_aux I D V (ipurge_tr_aux I D U xs) \\<Longrightarrow>\n       ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n       ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "show \"ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "proof (cases \"\\<exists>v \\<in> sinks_aux I D (U \\<union> V) xs. (v, D x) \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs.\n       (v, D x) \\<in> I \\<Longrightarrow>\n    ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs. (v, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs.\n       (v, D x) \\<in> I \\<Longrightarrow>\n    ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "hence \"\\<exists>w \\<in> sinks_aux I D U xs \\<union> sinks_aux I D V (ipurge_tr_aux I D U xs).\n      (w, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs. (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                   sinks_aux I D V (ipurge_tr_aux I D U xs).\n       (w, D x) \\<in> I", "by (simp add: sinks_aux_union)"], ["proof (state)\nthis:\n  \\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                 sinks_aux I D V (ipurge_tr_aux I D U xs).\n     (w, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs.\n       (v, D x) \\<in> I \\<Longrightarrow>\n    ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "hence \"(\\<exists>w \\<in> sinks_aux I D U xs. (w, D x) \\<in> I) \\<or>\n      (\\<exists>w \\<in> sinks_aux I D V (ipurge_tr_aux I D U xs). (w, D x) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                 sinks_aux I D V (ipurge_tr_aux I D U xs).\n     (w, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<or>\n    (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n        (w, D x) \\<in> I)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<or>\n  (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n      (w, D x) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs.\n       (v, D x) \\<in> I \\<Longrightarrow>\n    ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<or>\n  (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n      (w, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "using A and True"], ["proof (prove)\nusing this:\n  (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<or>\n  (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n      (w, D x) \\<in> I)\n  ipurge_tr_aux I D (U \\<union> V) xs =\n  ipurge_tr_aux I D V (ipurge_tr_aux I D U xs)\n  \\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs. (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "by (cases \"\\<exists>w \\<in> sinks_aux I D U xs. (w, D x) \\<in> I\", simp_all)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n  ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs. (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "hence \"\\<not> (\\<exists>w \\<in> sinks_aux I D U xs \\<union>\n      sinks_aux I D V (ipurge_tr_aux I D U xs). (w, D x) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs. (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                           sinks_aux I D V (ipurge_tr_aux I D U xs).\n               (w, D x) \\<in> I)", "by (simp add: sinks_aux_union)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                         sinks_aux I D V (ipurge_tr_aux I D U xs).\n             (w, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "hence \"\\<not> (\\<exists>w \\<in> sinks_aux I D U xs. (w, D x) \\<in> I) \\<and>\n      \\<not> (\\<exists>w \\<in> sinks_aux I D V (ipurge_tr_aux I D U xs). (w, D x) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>w\\<in>sinks_aux I D U xs \\<union>\n                         sinks_aux I D V (ipurge_tr_aux I D U xs).\n             (w, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<and>\n    \\<not> (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n               (w, D x) \\<in> I)", "by blast"], ["proof (state)\nthis:\n  \\<not> (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<and>\n  \\<not> (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n             (w, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<and>\n  \\<not> (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n             (w, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "using A and False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>w\\<in>sinks_aux I D U xs. (w, D x) \\<in> I) \\<and>\n  \\<not> (\\<exists>w\\<in>sinks_aux I D V (ipurge_tr_aux I D U xs).\n             (w, D x) \\<in> I)\n  ipurge_tr_aux I D (U \\<union> V) xs =\n  ipurge_tr_aux I D V (ipurge_tr_aux I D U xs)\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (U \\<union> V) xs. (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n    ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n  ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (U \\<union> V) (xs @ [x]) =\n  ipurge_tr_aux I D V (ipurge_tr_aux I D U (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_aux_insert:\n \"ipurge_tr_aux I D (insert v U) xs =\n  ipurge_tr_aux I D U (ipurge_tr I D v xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (insert v U) xs =\n    ipurge_tr_aux I D U (ipurge_tr I D v xs)", "by (subst insert_is_Un, simp only: ipurge_tr_aux_union ipurge_tr_aux_single_dom)"], ["", "lemma ipurge_ref_aux_subset:\n \"ipurge_ref_aux I D U xs X \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U xs X \\<subseteq> X", "by (subst ipurge_ref_aux_def, rule subsetI, simp)"], ["", "subsection \"Intransitive purge of event sets with trivial base case\""], ["", "text \\<open>\nHere below are the definitions of variants of functions @{term sinks_aux} and\n@{term ipurge_ref_aux}, respectively named \\<open>sinks_aux_less\\<close> and \\<open>ipurge_ref_aux_less\\<close>,\nsuch that their base cases in correspondence with an empty input list are trivial, viz. such that\n@{term \"sinks_aux_less I D U [] = {}\"} and @{term \"ipurge_ref_aux_less I D U [] X = X\"}. These\nfunctions will prove to be useful in what follows.\n\n\\null\n\\<close>"], ["", "function sinks_aux_less ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'd set\" where\n\"sinks_aux_less _ _ _ [] = {}\" |\n\"sinks_aux_less I D U (xs @ [x]) =\n (if \\<exists>v \\<in> U \\<union> sinks_aux_less I D U xs. (v, D x) \\<in> I\n  then insert (D x) (sinks_aux_less I D U xs)\n  else sinks_aux_less I D U xs)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>uu_ uv_ uw_.\n                   x = (uu_, uv_, uw_, []) \\<Longrightarrow> P;\n        \\<And>I D U xs xa.\n           x = (I, D, U, xs @ [xa]) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>uu_ uv_ uw_ uua_ uva_ uwa_.\n       (uu_, uv_, uw_, []) = (uua_, uva_, uwa_, []) \\<Longrightarrow>\n       {} = {}\n 3. \\<And>uu_ uv_ uw_ I D U xs x.\n       (uu_, uv_, uw_, []) = (I, D, U, xs @ [x]) \\<Longrightarrow>\n       {} =\n       (if \\<exists>v\\<in>U \\<union> sinks_aux_less_sumC (I, D, U, xs).\n              (v, D x) \\<in> I\n        then insert (D x) (sinks_aux_less_sumC (I, D, U, xs))\n        else sinks_aux_less_sumC (I, D, U, xs))\n 4. \\<And>I D U xs x Ia Da Ua xsa xa.\n       (I, D, U, xs @ [x]) = (Ia, Da, Ua, xsa @ [xa]) \\<Longrightarrow>\n       (if \\<exists>v\\<in>U \\<union> sinks_aux_less_sumC (I, D, U, xs).\n              (v, D x) \\<in> I\n        then insert (D x) (sinks_aux_less_sumC (I, D, U, xs))\n        else sinks_aux_less_sumC (I, D, U, xs)) =\n       (if \\<exists>v\\<in>Ua \\<union> sinks_aux_less_sumC (Ia, Da, Ua, xsa).\n              (v, Da xa) \\<in> Ia\n        then insert (Da xa) (sinks_aux_less_sumC (Ia, Da, Ua, xsa))\n        else sinks_aux_less_sumC (Ia, Da, Ua, xsa))", "proof (atomize_elim, simp_all add: split_paired_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b. b = [] \\<or> (\\<exists>xs x. b = xs @ [x])", "qed (rule rev_cases, rule disjI1, assumption, simp)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All sinks_aux_less_dom", "by lexicographic_order"], ["", "definition ipurge_ref_aux_less ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'a set \\<Rightarrow> 'a set\" where\n\"ipurge_ref_aux_less I D U xs X \\<equiv>\n  {x \\<in> X. \\<forall>v \\<in> sinks_aux_less I D U xs. (v, D x) \\<notin> I}\""], ["", "text \\<open>\n\\null\n\nHere below is the proof of some properties of function @{term sinks_aux_less} used in what follows.\n\n\\null\n\\<close>"], ["", "lemma sinks_aux_sinks_aux_less:\n \"sinks_aux I D U xs = U \\<union> sinks_aux_less I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U xs = U \\<union> sinks_aux_less I D U xs", "by (induction xs rule: rev_induct, simp_all)"], ["", "lemma sinks_aux_less_single_dom:\n \"sinks_aux_less I D {u} xs = sinks I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux_less I D {u} xs = sinks I D u xs", "by (induction xs rule: rev_induct, simp_all)"], ["", "lemma sinks_aux_less_single_event:\n \"sinks_aux_less I D U [x] = (if \\<exists>u \\<in> U. (u, D x) \\<in> I then {D x} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux_less I D U [x] =\n    (if \\<exists>u\\<in>U. (u, D x) \\<in> I then {D x} else {})", "by (subst append_Nil [symmetric], simp del: append_Nil)"], ["", "lemma sinks_aux_less_append:\n \"sinks_aux_less I D U (xs @ ys) =\n  sinks_aux_less I D U xs \\<union> sinks_aux_less I D (U \\<union> sinks_aux_less I D U xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux_less I D U (xs @ ys) =\n    sinks_aux_less I D U xs \\<union>\n    sinks_aux_less I D (U \\<union> sinks_aux_less I D U xs) ys", "proof (induction ys rule: rev_induct, simp, subst append_assoc [symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       sinks_aux_less I D U (xs @ xsa) =\n       sinks_aux_less I D U xs \\<union>\n       sinks_aux_less I D (U \\<union> sinks_aux_less I D U xs)\n        xsa \\<Longrightarrow>\n       sinks_aux_less I D U ((xs @ xsa) @ [x]) =\n       sinks_aux_less I D U xs \\<union>\n       sinks_aux_less I D (U \\<union> sinks_aux_less I D U xs) (xsa @ [x])", "qed (simp del: append_assoc)"], ["", "lemma sinks_aux_less_cons:\n \"sinks_aux_less I D U (x # xs) = (if \\<exists>u \\<in> U. (u, D x) \\<in> I\n   then insert (D x) (sinks_aux_less I D (insert (D x) U) xs)\n   else sinks_aux_less I D U xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux_less I D U (x # xs) =\n    (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n     then insert (D x) (sinks_aux_less I D (insert (D x) U) xs)\n     else sinks_aux_less I D U xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sinks_aux_less I D U (x # xs) =\n    (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n     then insert (D x) (sinks_aux_less I D (insert (D x) U) xs)\n     else sinks_aux_less I D U xs)", "have \"sinks_aux_less I D U (x # xs) = sinks_aux_less I D U ([x] @ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux_less I D U (x # xs) = sinks_aux_less I D U ([x] @ xs)", "by simp"], ["proof (state)\nthis:\n  sinks_aux_less I D U (x # xs) = sinks_aux_less I D U ([x] @ xs)\n\ngoal (1 subgoal):\n 1. sinks_aux_less I D U (x # xs) =\n    (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n     then insert (D x) (sinks_aux_less I D (insert (D x) U) xs)\n     else sinks_aux_less I D U xs)", "also"], ["proof (state)\nthis:\n  sinks_aux_less I D U (x # xs) = sinks_aux_less I D U ([x] @ xs)\n\ngoal (1 subgoal):\n 1. sinks_aux_less I D U (x # xs) =\n    (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n     then insert (D x) (sinks_aux_less I D (insert (D x) U) xs)\n     else sinks_aux_less I D U xs)", "have \"\\<dots> =\n    sinks_aux_less I D U [x] \\<union> sinks_aux_less I D (U \\<union> sinks_aux_less I D U [x]) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux_less I D U ([x] @ xs) =\n    sinks_aux_less I D U [x] \\<union>\n    sinks_aux_less I D (U \\<union> sinks_aux_less I D U [x]) xs", "by (simp only: sinks_aux_less_append)"], ["proof (state)\nthis:\n  sinks_aux_less I D U ([x] @ xs) =\n  sinks_aux_less I D U [x] \\<union>\n  sinks_aux_less I D (U \\<union> sinks_aux_less I D U [x]) xs\n\ngoal (1 subgoal):\n 1. sinks_aux_less I D U (x # xs) =\n    (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n     then insert (D x) (sinks_aux_less I D (insert (D x) U) xs)\n     else sinks_aux_less I D U xs)", "finally"], ["proof (chain)\npicking this:\n  sinks_aux_less I D U (x # xs) =\n  sinks_aux_less I D U [x] \\<union>\n  sinks_aux_less I D (U \\<union> sinks_aux_less I D U [x]) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  sinks_aux_less I D U (x # xs) =\n  sinks_aux_less I D U [x] \\<union>\n  sinks_aux_less I D (U \\<union> sinks_aux_less I D U [x]) xs\n\ngoal (1 subgoal):\n 1. sinks_aux_less I D U (x # xs) =\n    (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n     then insert (D x) (sinks_aux_less I D (insert (D x) U) xs)\n     else sinks_aux_less I D U xs)", "by (cases \"\\<exists>u \\<in> U. (u, D x) \\<in> I\", simp_all add: sinks_aux_less_single_event)"], ["proof (state)\nthis:\n  sinks_aux_less I D U (x # xs) =\n  (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n   then insert (D x) (sinks_aux_less I D (insert (D x) U) xs)\n   else sinks_aux_less I D U xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nHere below is the proof of some properties of function @{term ipurge_ref_aux_less} used in what\nfollows.\n\n\\null\n\\<close>"], ["", "lemma ipurge_ref_aux_less_last:\n \"ipurge_ref_aux_less I D U (xs @ [x]) X =\n   (if \\<exists>v \\<in> U \\<union> sinks_aux_less I D U xs. (v, D x) \\<in> I\n    then ipurge_ref_aux_less I D U xs {x' \\<in> X. (D x, D x') \\<notin> I}\n    else ipurge_ref_aux_less I D U xs X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (xs @ [x]) X =\n    (if \\<exists>v\\<in>U \\<union> sinks_aux_less I D U xs. (v, D x) \\<in> I\n     then ipurge_ref_aux_less I D U xs {x' \\<in> X. (D x, D x') \\<notin> I}\n     else ipurge_ref_aux_less I D U xs X)", "by (cases \"\\<exists>v \\<in> U \\<union> sinks_aux_less I D U xs. (v, D x) \\<in> I\",\n simp_all add: ipurge_ref_aux_less_def)"], ["", "lemma ipurge_ref_aux_less_nil:\n \"ipurge_ref_aux_less I D U xs (ipurge_ref_aux I D U [] X) =\n  ipurge_ref_aux I D U xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U xs (ipurge_ref_aux I D U [] X) =\n    ipurge_ref_aux I D U xs X", "proof (simp add: ipurge_ref_aux_def ipurge_ref_aux_less_def sinks_aux_sinks_aux_less)"], ["proof (state)\ngoal (1 subgoal):\n 1. {x \\<in> X.\n     (\\<forall>v\\<in>U. (v, D x) \\<notin> I) \\<and>\n     (\\<forall>v\\<in>sinks_aux_less I D U xs. (v, D x) \\<notin> I)} =\n    {x \\<in> X.\n     \\<forall>v\\<in>U \\<union> sinks_aux_less I D U xs. (v, D x) \\<notin> I}", "qed blast"], ["", "lemma ipurge_ref_aux_less_cons_1:\n  assumes A: \"\\<exists>u \\<in> U. (u, D x) \\<in> I\"\n  shows \"ipurge_ref_aux_less I D U (x # xs) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs) (ipurge_ref I D (D x) xs X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     (ipurge_ref I D (D x) xs X)", "proof (induction xs arbitrary: X rule: rev_induct,\n simp add: ipurge_ref_def ipurge_ref_aux_less_def sinks_aux_less_single_event A)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs X.\n       (\\<And>X.\n           ipurge_ref_aux_less I D U (x # xs) X =\n           ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n            (ipurge_ref I D (D x) xs X)) \\<Longrightarrow>\n       ipurge_ref_aux_less I D U (x # xs @ [xa]) X =\n       ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [xa]))\n        (ipurge_ref I D (D x) (xs @ [xa]) X)", "fix x' xs X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs X.\n       (\\<And>X.\n           ipurge_ref_aux_less I D U (x # xs) X =\n           ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n            (ipurge_ref I D (D x) xs X)) \\<Longrightarrow>\n       ipurge_ref_aux_less I D U (x # xs @ [xa]) X =\n       ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [xa]))\n        (ipurge_ref I D (D x) (xs @ [xa]) X)", "assume B: \"\\<And>X.\n    ipurge_ref_aux_less I D U (x # xs) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n      (ipurge_ref I D (D x) xs X)\""], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs) ?X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs ?X)\n\ngoal (1 subgoal):\n 1. \\<And>xa xs X.\n       (\\<And>X.\n           ipurge_ref_aux_less I D U (x # xs) X =\n           ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n            (ipurge_ref I D (D x) xs X)) \\<Longrightarrow>\n       ipurge_ref_aux_less I D U (x # xs @ [xa]) X =\n       ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [xa]))\n        (ipurge_ref I D (D x) (xs @ [xa]) X)", "show\n   \"ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n      (ipurge_ref I D (D x) (xs @ [x']) X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "proof (cases \"\\<exists>v \\<in> U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)\n 2. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "assume C: \"\\<exists>v \\<in> U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)\n 2. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "hence \"ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n      ipurge_ref_aux_less I D U (x # xs) {y \\<in> X. (D x', D y) \\<notin> I}\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (x # xs) {y \\<in> X. (D x', D y) \\<notin> I}", "by (subst append_Cons [symmetric],\n      simp add: ipurge_ref_aux_less_last del: append_Cons)"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (x # xs) {y \\<in> X. (D x', D y) \\<notin> I}\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)\n 2. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "also"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (x # xs) {y \\<in> X. (D x', D y) \\<notin> I}\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)\n 2. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "have \"\\<dots> =\n      ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n        (ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs) {y \\<in> X. (D x', D y) \\<notin> I} =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     (ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I})", "using B"], ["proof (prove)\nusing this:\n  ipurge_ref_aux_less I D U (x # xs) ?X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs ?X)\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs) {y \\<in> X. (D x', D y) \\<notin> I} =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     (ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I})", "."], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs) {y \\<in> X. (D x', D y) \\<notin> I} =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I})\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)\n 2. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "finally"], ["proof (chain)\npicking this:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I})", "have D: \"ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n      ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n        (ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I})\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I})\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     (ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I})", "."], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I})\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)\n 2. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "proof (cases \"(D x, D x') \\<in> I \\<or> (\\<exists>v \\<in> sinks I D (D x) xs. (v, D x') \\<in> I)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)\n 2. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "case True"], ["proof (state)\nthis:\n  (D x, D x') \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I)\n\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)\n 2. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "hence \"ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n        ipurge_ref I D (D x) (xs @ [x']) X\""], ["proof (prove)\nusing this:\n  (D x, D x') \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n    ipurge_ref I D (D x) (xs @ [x']) X", "by (simp add: ipurge_ref_last)"], ["proof (state)\nthis:\n  ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n  ipurge_ref I D (D x) (xs @ [x']) X\n\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)\n 2. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "moreover"], ["proof (state)\nthis:\n  ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n  ipurge_ref I D (D x) (xs @ [x']) X\n\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)\n 2. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "have \"D x' \\<in> sinks I D (D x) (xs @ [x'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x' \\<in> sinks I D (D x) (xs @ [x'])", "using True"], ["proof (prove)\nusing this:\n  (D x, D x') \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. D x' \\<in> sinks I D (D x) (xs @ [x'])", "by (simp only: sinks_interference_eq)"], ["proof (state)\nthis:\n  D x' \\<in> sinks I D (D x) (xs @ [x'])\n\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)\n 2. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "hence \"ipurge_tr I D (D x) xs = ipurge_tr I D (D x) (xs @ [x'])\""], ["proof (prove)\nusing this:\n  D x' \\<in> sinks I D (D x) (xs @ [x'])\n\ngoal (1 subgoal):\n 1. ipurge_tr I D (D x) xs = ipurge_tr I D (D x) (xs @ [x'])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I D (D x) xs = ipurge_tr I D (D x) (xs @ [x'])\n\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)\n 2. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n  ipurge_ref I D (D x) (xs @ [x']) X\n  ipurge_tr I D (D x) xs = ipurge_tr I D (D x) (xs @ [x'])", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n  ipurge_ref I D (D x) (xs @ [x']) X\n  ipurge_tr I D (D x) xs = ipurge_tr I D (D x) (xs @ [x'])\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "using D"], ["proof (prove)\nusing this:\n  ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n  ipurge_ref I D (D x) (xs @ [x']) X\n  ipurge_tr I D (D x) xs = ipurge_tr I D (D x) (xs @ [x'])\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I})\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "by simp"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "case False"], ["proof (state)\nthis:\n  \\<not> ((D x, D x') \\<in> I \\<or>\n          (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I))\n\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "hence \"ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n        ipurge_ref I D (D x) (xs @ [x']) {y \\<in> X. (D x', D y) \\<notin> I}\""], ["proof (prove)\nusing this:\n  \\<not> ((D x, D x') \\<in> I \\<or>\n          (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I))\n\ngoal (1 subgoal):\n 1. ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n    ipurge_ref I D (D x) (xs @ [x']) {y \\<in> X. (D x', D y) \\<notin> I}", "by (simp add: ipurge_ref_last)"], ["proof (state)\nthis:\n  ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n  ipurge_ref I D (D x) (xs @ [x']) {y \\<in> X. (D x', D y) \\<notin> I}\n\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "also"], ["proof (state)\nthis:\n  ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n  ipurge_ref I D (D x) (xs @ [x']) {y \\<in> X. (D x', D y) \\<notin> I}\n\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "have \"\\<dots> = {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D (D x) (xs @ [x']) {y \\<in> X. (D x', D y) \\<notin> I} =\n    {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I}", "by (simp add: ipurge_ref_swap)"], ["proof (state)\nthis:\n  ipurge_ref I D (D x) (xs @ [x']) {y \\<in> X. (D x', D y) \\<notin> I} =\n  {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I}\n\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "finally"], ["proof (chain)\npicking this:\n  ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n  {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I}", "have \"ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n        ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n          {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I}\""], ["proof (prove)\nusing this:\n  ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n  {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I}\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I}", "using D"], ["proof (prove)\nusing this:\n  ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I} =\n  {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I}\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs {y \\<in> X. (D x', D y) \\<notin> I})\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I}", "by simp"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I}\n\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "also"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I}\n\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "have \"\\<dots> = ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n        (ipurge_ref I D (D x) (xs @ [x']) X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I} =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I} =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "have \"\\<exists>v \\<in> U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n          (v, D x') \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I", "obtain v where\n            E: \"v \\<in> U \\<union> sinks_aux_less I D U (x # xs)\" and\n            F: \"(v, D x') \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> U \\<union> sinks_aux_less I D U (x # xs);\n         (v, D x') \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using C"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> U \\<union> sinks_aux_less I D U (x # xs);\n         (v, D x') \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> U \\<union> sinks_aux_less I D U (x # xs)\n  (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I", "have \"v \\<in> sinks_aux I D U (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D U (x # xs)", "using E"], ["proof (prove)\nusing this:\n  v \\<in> U \\<union> sinks_aux_less I D U (x # xs)\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D U (x # xs)", "by (simp add: sinks_aux_sinks_aux_less)"], ["proof (state)\nthis:\n  v \\<in> sinks_aux I D U (x # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I", "hence \"v \\<in> sinks_aux I D (insert (D x) U) xs\""], ["proof (prove)\nusing this:\n  v \\<in> sinks_aux I D U (x # xs)\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D (insert (D x) U) xs", "using A"], ["proof (prove)\nusing this:\n  v \\<in> sinks_aux I D U (x # xs)\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D (insert (D x) U) xs", "by (simp add: sinks_aux_cons)"], ["proof (state)\nthis:\n  v \\<in> sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I", "hence \"v \\<in> sinks_aux I D U (ipurge_tr I D (D x) xs)\""], ["proof (prove)\nusing this:\n  v \\<in> sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D U (ipurge_tr I D (D x) xs)", "using F and False"], ["proof (prove)\nusing this:\n  v \\<in> sinks_aux I D (insert (D x) U) xs\n  (v, D x') \\<in> I\n  \\<not> ((D x, D x') \\<in> I \\<or>\n          (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I))\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D U (ipurge_tr I D (D x) xs)", "by (rule sinks_aux_member_ipurge_tr)"], ["proof (state)\nthis:\n  v \\<in> sinks_aux I D U (ipurge_tr I D (D x) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I", "hence \"v \\<in> U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs)\""], ["proof (prove)\nusing this:\n  v \\<in> sinks_aux I D U (ipurge_tr I D (D x) xs)\n\ngoal (1 subgoal):\n 1. v \\<in> U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs)", "by (simp add: sinks_aux_sinks_aux_less)"], ["proof (state)\nthis:\n  v \\<in> U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I", "with F"], ["proof (chain)\npicking this:\n  (v, D x') \\<in> I\n  v \\<in> U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, D x') \\<in> I\n  v \\<in> U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n     (v, D x') \\<in> I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n     (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I} =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n     (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I} =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "by (simp add: ipurge_ref_aux_less_last)"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I} =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   {y \\<in> ipurge_ref I D (D x) (xs @ [x']) X. (D x', D y) \\<notin> I} =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "finally"], ["proof (chain)\npicking this:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n   (ipurge_ref I D (D x) (xs @ [x']) X)", "have \"ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n        ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n          (ipurge_ref I D (D x) (xs @ [x']) X)\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "."], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "moreover"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "have \"D x' \\<notin> sinks I D (D x) (xs @ [x'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x' \\<notin> sinks I D (D x) (xs @ [x'])", "using False"], ["proof (prove)\nusing this:\n  \\<not> ((D x, D x') \\<in> I \\<or>\n          (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I))\n\ngoal (1 subgoal):\n 1. D x' \\<notin> sinks I D (D x) (xs @ [x'])", "by (simp only: sinks_interference_eq, simp)"], ["proof (state)\nthis:\n  D x' \\<notin> sinks I D (D x) (xs @ [x'])\n\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "hence \"ipurge_tr I D (D x) xs @ [x'] = ipurge_tr I D (D x) (xs @ [x'])\""], ["proof (prove)\nusing this:\n  D x' \\<notin> sinks I D (D x) (xs @ [x'])\n\ngoal (1 subgoal):\n 1. ipurge_tr I D (D x) xs @ [x'] = ipurge_tr I D (D x) (xs @ [x'])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I D (D x) xs @ [x'] = ipurge_tr I D (D x) (xs @ [x'])\n\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n  ipurge_tr I D (D x) xs @ [x'] = ipurge_tr I D (D x) (xs @ [x'])", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n  ipurge_tr I D (D x) xs @ [x'] = ipurge_tr I D (D x) (xs @ [x'])\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "by simp"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "assume C: \"\\<not> (\\<exists>v \\<in> U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n             (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "hence \"ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n      ipurge_ref_aux_less I D U (x # xs) X\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n             (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (x # xs) X", "by (subst append_Cons [symmetric],\n      simp add: ipurge_ref_aux_less_last del: append_Cons)"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (x # xs) X\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "also"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (x # xs) X\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "have \"\\<dots> =\n      ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n        (ipurge_ref I D (D x) xs X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     (ipurge_ref I D (D x) xs X)", "using B"], ["proof (prove)\nusing this:\n  ipurge_ref_aux_less I D U (x # xs) ?X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs ?X)\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     (ipurge_ref I D (D x) xs X)", "."], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs X)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "also"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs X)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "have \"\\<dots> =\n      ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n        (ipurge_ref I D (D x) xs X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     (ipurge_ref I D (D x) xs X) =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) xs X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     (ipurge_ref I D (D x) xs X) =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) xs X)", "have \"\\<not> (\\<exists>v \\<in> U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n        (v, D x') \\<in> I)\" (is \"\\<not> ?P\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U \\<union>\n                           sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n               (v, D x') \\<in> I)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "assume ?P"], ["proof (state)\nthis:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n     (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n     (v, D x') \\<in> I", "obtain v where\n          D: \"v \\<in> U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs)\" and\n          E: \"(v, D x') \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n     (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> U \\<union>\n                         sinks_aux_less I D U (ipurge_tr I D (D x) xs);\n         (v, D x') \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs)\n  (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "have \"sinks_aux I D U (ipurge_tr I D (D x) xs) \\<subseteq> sinks_aux I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U (ipurge_tr I D (D x) xs) \\<subseteq> sinks_aux I D U xs", "by (rule sinks_aux_subset_ipurge_tr)"], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr I D (D x) xs) \\<subseteq> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr I D (D x) xs) \\<subseteq> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "have \"v \\<in> sinks_aux I D U (ipurge_tr I D (D x) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D U (ipurge_tr I D (D x) xs)", "using D"], ["proof (prove)\nusing this:\n  v \\<in> U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs)\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D U (ipurge_tr I D (D x) xs)", "by (simp add: sinks_aux_sinks_aux_less)"], ["proof (state)\nthis:\n  v \\<in> sinks_aux I D U (ipurge_tr I D (D x) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D U (ipurge_tr I D (D x) xs) \\<subseteq> sinks_aux I D U xs\n  v \\<in> sinks_aux I D U (ipurge_tr I D (D x) xs)", "have \"v \\<in> sinks_aux I D U xs\""], ["proof (prove)\nusing this:\n  sinks_aux I D U (ipurge_tr I D (D x) xs) \\<subseteq> sinks_aux I D U xs\n  v \\<in> sinks_aux I D U (ipurge_tr I D (D x) xs)\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D U xs", ".."], ["proof (state)\nthis:\n  v \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  v \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "have \"U \\<subseteq> insert (D x) U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> insert (D x) U", "by (rule subset_insertI)"], ["proof (state)\nthis:\n  U \\<subseteq> insert (D x) U\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "hence \"sinks_aux I D U xs \\<subseteq> sinks_aux I D (insert (D x) U) xs\""], ["proof (prove)\nusing this:\n  U \\<subseteq> insert (D x) U\n\ngoal (1 subgoal):\n 1. sinks_aux I D U xs \\<subseteq> sinks_aux I D (insert (D x) U) xs", "by (rule sinks_aux_subset_dom)"], ["proof (state)\nthis:\n  sinks_aux I D U xs \\<subseteq> sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> sinks_aux I D U xs\n  sinks_aux I D U xs \\<subseteq> sinks_aux I D (insert (D x) U) xs", "have \"v \\<in> sinks_aux I D (insert (D x) U) xs\""], ["proof (prove)\nusing this:\n  v \\<in> sinks_aux I D U xs\n  sinks_aux I D U xs \\<subseteq> sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D (insert (D x) U) xs", ".."], ["proof (state)\nthis:\n  v \\<in> sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "hence \"v \\<in> sinks_aux I D U (x # xs)\""], ["proof (prove)\nusing this:\n  v \\<in> sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D U (x # xs)", "using A"], ["proof (prove)\nusing this:\n  v \\<in> sinks_aux I D (insert (D x) U) xs\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D U (x # xs)", "by (simp add: sinks_aux_cons)"], ["proof (state)\nthis:\n  v \\<in> sinks_aux I D U (x # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "hence \"v \\<in> U \\<union> sinks_aux_less I D U (x # xs)\""], ["proof (prove)\nusing this:\n  v \\<in> sinks_aux I D U (x # xs)\n\ngoal (1 subgoal):\n 1. v \\<in> U \\<union> sinks_aux_less I D U (x # xs)", "by (simp add: sinks_aux_sinks_aux_less)"], ["proof (state)\nthis:\n  v \\<in> U \\<union> sinks_aux_less I D U (x # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "with E"], ["proof (chain)\npicking this:\n  (v, D x') \\<in> I\n  v \\<in> U \\<union> sinks_aux_less I D U (x # xs)", "have \"\\<exists>v \\<in> U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\""], ["proof (prove)\nusing this:\n  (v, D x') \\<in> I\n  v \\<in> U \\<union> sinks_aux_less I D U (x # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n       (v, D x') \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\n  \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n             (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>U \\<union>\n                         sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n             (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     (ipurge_ref I D (D x) xs X) =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) xs X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>U \\<union>\n                         sinks_aux_less I D U (ipurge_tr I D (D x) xs).\n             (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n     (ipurge_ref I D (D x) xs X) =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) xs X)", "by (simp add: ipurge_ref_aux_less_last)"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs X) =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n   (ipurge_ref I D (D x) xs X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs X) =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n   (ipurge_ref I D (D x) xs X)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "also"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs)\n   (ipurge_ref I D (D x) xs X) =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n   (ipurge_ref I D (D x) xs X)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "have \"\\<dots> =\n      ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n        (ipurge_ref I D (D x) (xs @ [x']) X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) xs X) =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) xs X) =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "have \"\\<not> ((D x, D x') \\<in> I \\<or> (\\<exists>v \\<in> sinks I D (D x) xs. (v, D x') \\<in> I))\"\n       (is \"\\<not> ?P\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ((D x, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I))", "proof (rule notI, erule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "assume D: \"(D x, D x') \\<in> I\""], ["proof (state)\nthis:\n  (D x, D x') \\<in> I\n\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "have \"insert (D x) U \\<subseteq> sinks_aux I D (insert (D x) U) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (D x) U \\<subseteq> sinks_aux I D (insert (D x) U) xs", "by (rule sinks_aux_subset)"], ["proof (state)\nthis:\n  insert (D x) U \\<subseteq> sinks_aux I D (insert (D x) U) xs\n\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  insert (D x) U \\<subseteq> sinks_aux I D (insert (D x) U) xs\n\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "have \"D x \\<in> insert (D x) U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x \\<in> insert (D x) U", "by simp"], ["proof (state)\nthis:\n  D x \\<in> insert (D x) U\n\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  insert (D x) U \\<subseteq> sinks_aux I D (insert (D x) U) xs\n  D x \\<in> insert (D x) U", "have \"D x \\<in> sinks_aux I D (insert (D x) U) xs\""], ["proof (prove)\nusing this:\n  insert (D x) U \\<subseteq> sinks_aux I D (insert (D x) U) xs\n  D x \\<in> insert (D x) U\n\ngoal (1 subgoal):\n 1. D x \\<in> sinks_aux I D (insert (D x) U) xs", ".."], ["proof (state)\nthis:\n  D x \\<in> sinks_aux I D (insert (D x) U) xs\n\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "hence \"D x \\<in> sinks_aux I D U (x # xs)\""], ["proof (prove)\nusing this:\n  D x \\<in> sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. D x \\<in> sinks_aux I D U (x # xs)", "using A"], ["proof (prove)\nusing this:\n  D x \\<in> sinks_aux I D (insert (D x) U) xs\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. D x \\<in> sinks_aux I D U (x # xs)", "by (simp add: sinks_aux_cons)"], ["proof (state)\nthis:\n  D x \\<in> sinks_aux I D U (x # xs)\n\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "hence \"D x \\<in> U \\<union> sinks_aux_less I D U (x # xs)\""], ["proof (prove)\nusing this:\n  D x \\<in> sinks_aux I D U (x # xs)\n\ngoal (1 subgoal):\n 1. D x \\<in> U \\<union> sinks_aux_less I D U (x # xs)", "by (simp add: sinks_aux_sinks_aux_less)"], ["proof (state)\nthis:\n  D x \\<in> U \\<union> sinks_aux_less I D U (x # xs)\n\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "with D"], ["proof (chain)\npicking this:\n  (D x, D x') \\<in> I\n  D x \\<in> U \\<union> sinks_aux_less I D U (x # xs)", "have \"\\<exists>v \\<in> U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\""], ["proof (prove)\nusing this:\n  (D x, D x') \\<in> I\n  D x \\<in> U \\<union> sinks_aux_less I D U (x # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n       (v, D x') \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\n\ngoal (2 subgoals):\n 1. (D x, D x') \\<in> I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\n  \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n             (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "assume \"\\<exists>v \\<in> sinks I D (D x) xs. (v, D x') \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I", "obtain v where\n          D: \"v \\<in> sinks I D (D x) xs\" and\n          E: \"(v, D x') \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> sinks I D (D x) xs; (v, D x') \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> sinks I D (D x) xs\n  (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "have \"{D x} \\<subseteq> insert (D x) U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {D x} \\<subseteq> insert (D x) U", "by simp"], ["proof (state)\nthis:\n  {D x} \\<subseteq> insert (D x) U\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "hence \"sinks_aux I D {D x} xs \\<subseteq> sinks_aux I D (insert (D x) U) xs\""], ["proof (prove)\nusing this:\n  {D x} \\<subseteq> insert (D x) U\n\ngoal (1 subgoal):\n 1. sinks_aux I D {D x} xs \\<subseteq> sinks_aux I D (insert (D x) U) xs", "by (rule sinks_aux_subset_dom)"], ["proof (state)\nthis:\n  sinks_aux I D {D x} xs \\<subseteq> sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D {D x} xs \\<subseteq> sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "have \"v \\<in> sinks_aux I D {D x} xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D {D x} xs", "using D"], ["proof (prove)\nusing this:\n  v \\<in> sinks I D (D x) xs\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D {D x} xs", "by (simp add: sinks_aux_single_dom)"], ["proof (state)\nthis:\n  v \\<in> sinks_aux I D {D x} xs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D {D x} xs \\<subseteq> sinks_aux I D (insert (D x) U) xs\n  v \\<in> sinks_aux I D {D x} xs", "have \"v \\<in> sinks_aux I D (insert (D x) U) xs\""], ["proof (prove)\nusing this:\n  sinks_aux I D {D x} xs \\<subseteq> sinks_aux I D (insert (D x) U) xs\n  v \\<in> sinks_aux I D {D x} xs\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D (insert (D x) U) xs", ".."], ["proof (state)\nthis:\n  v \\<in> sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "hence \"v \\<in> sinks_aux I D U (x # xs)\""], ["proof (prove)\nusing this:\n  v \\<in> sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D U (x # xs)", "using A"], ["proof (prove)\nusing this:\n  v \\<in> sinks_aux I D (insert (D x) U) xs\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D U (x # xs)", "by (simp add: sinks_aux_cons)"], ["proof (state)\nthis:\n  v \\<in> sinks_aux I D U (x # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "hence \"v \\<in> U \\<union> sinks_aux_less I D U (x # xs)\""], ["proof (prove)\nusing this:\n  v \\<in> sinks_aux I D U (x # xs)\n\ngoal (1 subgoal):\n 1. v \\<in> U \\<union> sinks_aux_less I D U (x # xs)", "by (simp add: sinks_aux_sinks_aux_less)"], ["proof (state)\nthis:\n  v \\<in> U \\<union> sinks_aux_less I D U (x # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "with E"], ["proof (chain)\npicking this:\n  (v, D x') \\<in> I\n  v \\<in> U \\<union> sinks_aux_less I D U (x # xs)", "have \"\\<exists>v \\<in> U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\""], ["proof (prove)\nusing this:\n  (v, D x') \\<in> I\n  v \\<in> U \\<union> sinks_aux_less I D U (x # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n       (v, D x') \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs). (v, D x') \\<in> I\n  \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n             (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> ((D x, D x') \\<in> I \\<or>\n          (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I))\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) xs X) =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "hence \"ipurge_tr I D (D x) xs @ [x'] = ipurge_tr I D (D x) (xs @ [x'])\""], ["proof (prove)\nusing this:\n  \\<not> ((D x, D x') \\<in> I \\<or>\n          (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I))\n\ngoal (1 subgoal):\n 1. ipurge_tr I D (D x) xs @ [x'] = ipurge_tr I D (D x) (xs @ [x'])", "by (simp only: sinks_interference_eq, simp)"], ["proof (state)\nthis:\n  ipurge_tr I D (D x) xs @ [x'] = ipurge_tr I D (D x) (xs @ [x'])\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) xs X) =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "moreover"], ["proof (state)\nthis:\n  ipurge_tr I D (D x) xs @ [x'] = ipurge_tr I D (D x) (xs @ [x'])\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) xs X) =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "have \"ipurge_ref I D (D x) xs X =\n        ipurge_ref I D (D x) (xs @ [x']) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D (D x) xs X = ipurge_ref I D (D x) (xs @ [x']) X", "using \\<open>\\<not> ?P\\<close>"], ["proof (prove)\nusing this:\n  \\<not> ((D x, D x') \\<in> I \\<or>\n          (\\<exists>v\\<in>sinks I D (D x) xs. (v, D x') \\<in> I))\n\ngoal (1 subgoal):\n 1. ipurge_ref I D (D x) xs X = ipurge_ref I D (D x) (xs @ [x']) X", "by (simp add: ipurge_ref_last)"], ["proof (state)\nthis:\n  ipurge_ref I D (D x) xs X = ipurge_ref I D (D x) (xs @ [x']) X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) xs X) =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr I D (D x) xs @ [x'] = ipurge_tr I D (D x) (xs @ [x'])\n  ipurge_ref I D (D x) xs X = ipurge_ref I D (D x) (xs @ [x']) X", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr I D (D x) xs @ [x'] = ipurge_tr I D (D x) (xs @ [x'])\n  ipurge_ref I D (D x) xs X = ipurge_ref I D (D x) (xs @ [x']) X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n     (ipurge_ref I D (D x) xs X) =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "by simp"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n   (ipurge_ref I D (D x) xs X) =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs @ [x'])\n   (ipurge_ref I D (D x) xs X) =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U \\<union> sinks_aux_less I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "finally"], ["proof (chain)\npicking this:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n   (ipurge_ref I D (D x) (xs @ [x']) X)", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n     (ipurge_ref I D (D x) (xs @ [x']) X)", "."], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs @ [x']) X =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) (xs @ [x']))\n   (ipurge_ref I D (D x) (xs @ [x']) X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_ref_aux_less_cons_2:\n \"\\<not> (\\<exists>u \\<in> U. (u, D x) \\<in> I) \\<Longrightarrow>\n  ipurge_ref_aux_less I D U (x # xs) X =\n    ipurge_ref_aux_less I D U xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_ref_aux_less I D U (x # xs) X = ipurge_ref_aux_less I D U xs X", "by (simp add: ipurge_ref_aux_less_def sinks_aux_less_cons)"], ["", "subsection \"Closure of the failures of a secure process under intransitive purge\""], ["", "text \\<open>\nThe intransitive purge of an event list @{term xs} with regard to a policy @{term I}, an\nevent-domain map @{term D}, and a set of domains @{term U} can equivalently be computed as follows:\nfor each item @{term x} of @{term xs}, if @{term x} may be affected by some domain in @{term U},\ndiscard @{term x} and go on recursively using @{term \"ipurge_tr I D (D x) xs'\"} as input, where\n@{term xs'} is the sublist of @{term xs} following @{term x}; otherwise, retain @{term x} and go on\nrecursively using @{term xs'} as input.\n\nIn fact, in each recursive step, any item allowed to be indirectly affected by @{term U} through the\neffect of some item preceding @{term x} within @{term xs} has already been removed from the list.\nHence, it is sufficient to check whether @{term x} may be directly affected by @{term U}, and remove\n@{term x}, as well as any residual item allowed to be affected by @{term x}, if this is the case.\n\nSimilarly, the intransitive purge of an event set @{term X} with regard to a policy @{term I}, an\nevent-domain map @{term D}, a set of domains @{term U}, and an event list @{term xs} can be computed\nas follows. First of all, compute @{term \"ipurge_ref_aux I D U [] X\"} and use this set, along with\n@{term xs}, as the input for the subsequent step. Then, for each item @{term x} of @{term xs}, if\n@{term x} may be affected by some domain in @{term U}, go on recursively using\n@{term \"ipurge_tr I D (D x) xs'\"} and @{term \"ipurge_ref I D (D x) xs' X'\"} as input, where\n@{term X'} is the set input to the current recursive step; otherwise, go on recursively using\n@{term xs'} and @{term X'} as input.\n\nIn fact, in each recursive step, any item allowed to be affected by @{term U} either directly, or\nthrough the effect of some item preceding @{term x} within @{term xs}, has already been removed from\nthe set (in the initial step and in subsequent steps, respectively). Thus, it is sufficient to check\nwhether @{term x} may be directly affected by @{term U}, and remove any residual item allowed to be\naffected by @{term x} if this is the case.\n\nAssume that the two computations be performed simultaneously by a single function, which will then\ntake as input an event list-event set pair and return as output another such pair. Then, if the\ninput pair is a failure of a secure process, the output pair is still a failure. In fact, for each\nitem @{term x} of @{term xs} allowed to be affected by @{term U}, if @{term ys} is the partial\noutput list for the sublist of @{term xs} preceding @{term x}, then\n@{term \"(ys @ ipurge_tr I D (D x) xs', ipurge_ref I D (D x) xs' X')\"} is a failure provided that\nsuch is @{term \"(ys @ x # xs', X')\"}, by virtue of the definition of CSP noninterference security\n\\cite{R2}. Hence, the property of being a failure is conserved upon each recursive call by the event\nlist-event set pair such that the list matches the concatenation of the partial output list with the\nresidual input list, and the set matches the residual input set. This holds until the residual input\nlist is nil, which is the base case determining the end of the computation.\n\nAs shown by this argument, a proof by induction that the output event list-event set pair, under the\naforesaid assumptions, is still a failure, requires that the partial output list be passed to the\nfunction as a further argument, in addition to the residual input list, in the recursive calls\ncontained within the definition of the function. Therefore, the output list has to be accumulated\ninto a parameter of the function, viz. the function needs to be tail-recursive. This suggests to\nprove the properties of interest of the function by applying the ten-step proof method for theorems\non tail-recursive functions described in \\cite{R1}.\n\nThe starting point is to formulate a naive definition of the function, which will then be refined as\nspecified by the proof method. A slight complication is due to the preliminary replacement of the\ninput event set @{term X} with @{term \"ipurge_ref_aux I D U [] X\"}, to be performed before the items\nof the input event list start to be consumed recursively. A simple solution to this problem is to\nnest the accumulator of the output list within data type \\<open>option\\<close>. In this way, the initial\nstate can be distinguished from the subsequent one, in which the input event list starts to be\nconsumed, by assigning the distinct values @{term None} and @{term \"Some []\"}, respectively, to the\naccumulator.\n\nEverything is now ready for giving a naive definition of the function under consideration:\n\n\\null\n\\<close>"], ["", "function (sequential) ipurge_fail_aux_t_naive ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'a list option \\<Rightarrow> 'a set \\<Rightarrow>\n    'a failure\"\nwhere\n\"ipurge_fail_aux_t_naive I D U xs None X =\n  ipurge_fail_aux_t_naive I D U xs (Some []) (ipurge_ref_aux I D U [] X)\" |\n\"ipurge_fail_aux_t_naive I D U (x # xs) (Some ys) X =\n (if \\<exists>u \\<in> U. (u, D x) \\<in> I\n  then ipurge_fail_aux_t_naive I D U\n    (ipurge_tr I D (D x) xs) (Some ys) (ipurge_ref I D (D x) xs X)\n  else ipurge_fail_aux_t_naive I D U\n    xs (Some (ys @ [x])) X)\" |\n\"ipurge_fail_aux_t_naive _ _ _ _ (Some ys) X = (ys, X)\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>I D U xs X.\n                   x = (I, D, U, xs, None, X) \\<Longrightarrow> P;\n        \\<And>I D U xa xs ys X.\n           x = (I, D, U, xa # xs, Some ys, X) \\<Longrightarrow> P;\n        \\<And>uu_ uv_ uw_ ys X.\n           x = (uu_, uv_, uw_, [], Some ys, X) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>I D U xs X Ia Da Ua xsa Xa.\n       (I, D, U, xs, None, X) =\n       (Ia, Da, Ua, xsa, None, Xa) \\<Longrightarrow>\n       ipurge_fail_aux_t_naive_sumC\n        (I, D, U, xs, Some [], ipurge_ref_aux I D U [] X) =\n       ipurge_fail_aux_t_naive_sumC\n        (Ia, Da, Ua, xsa, Some [], ipurge_ref_aux Ia Da Ua [] Xa)\n 3. \\<And>I D U xs X Ia Da Ua x xsa ys Xa.\n       (I, D, U, xs, None, X) =\n       (Ia, Da, Ua, x # xsa, Some ys, Xa) \\<Longrightarrow>\n       ipurge_fail_aux_t_naive_sumC\n        (I, D, U, xs, Some [], ipurge_ref_aux I D U [] X) =\n       (if \\<exists>u\\<in>Ua. (u, Da x) \\<in> Ia\n        then ipurge_fail_aux_t_naive_sumC\n              (Ia, Da, Ua, ipurge_tr Ia Da (Da x) xsa, Some ys,\n               ipurge_ref Ia Da (Da x) xsa Xa)\n        else ipurge_fail_aux_t_naive_sumC\n              (Ia, Da, Ua, xsa, Some (ys @ [x]), Xa))\n 4. \\<And>I D U xs X uu_ uv_ uw_ ys Xa.\n       (I, D, U, xs, None, X) =\n       (uu_, uv_, uw_, [], Some ys, Xa) \\<Longrightarrow>\n       ipurge_fail_aux_t_naive_sumC\n        (I, D, U, xs, Some [], ipurge_ref_aux I D U [] X) =\n       (ys, Xa)\n 5. \\<And>I D U x xs ys X Ia Da Ua xa xsa ysa Xa.\n       (I, D, U, x # xs, Some ys, X) =\n       (Ia, Da, Ua, xa # xsa, Some ysa, Xa) \\<Longrightarrow>\n       (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n        then ipurge_fail_aux_t_naive_sumC\n              (I, D, U, ipurge_tr I D (D x) xs, Some ys,\n               ipurge_ref I D (D x) xs X)\n        else ipurge_fail_aux_t_naive_sumC\n              (I, D, U, xs, Some (ys @ [x]), X)) =\n       (if \\<exists>u\\<in>Ua. (u, Da xa) \\<in> Ia\n        then ipurge_fail_aux_t_naive_sumC\n              (Ia, Da, Ua, ipurge_tr Ia Da (Da xa) xsa, Some ysa,\n               ipurge_ref Ia Da (Da xa) xsa Xa)\n        else ipurge_fail_aux_t_naive_sumC\n              (Ia, Da, Ua, xsa, Some (ysa @ [xa]), Xa))\n 6. \\<And>I D U x xs ys X uu_ uv_ uw_ ysa Xa.\n       (I, D, U, x # xs, Some ys, X) =\n       (uu_, uv_, uw_, [], Some ysa, Xa) \\<Longrightarrow>\n       (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n        then ipurge_fail_aux_t_naive_sumC\n              (I, D, U, ipurge_tr I D (D x) xs, Some ys,\n               ipurge_ref I D (D x) xs X)\n        else ipurge_fail_aux_t_naive_sumC\n              (I, D, U, xs, Some (ys @ [x]), X)) =\n       (ysa, Xa)\n 7. \\<And>uu_ uv_ uw_ ys X uua_ uva_ uwa_ ysa Xa.\n       (uu_, uv_, uw_, [], Some ys, X) =\n       (uua_, uva_, uwa_, [], Some ysa, Xa) \\<Longrightarrow>\n       (ys, X) = (ysa, Xa)", "oops"], ["", "text \\<open>\n\\null\n\nThe parameter into which the output list is accumulated is the last but one.\n\nAs shown by the above informal argument, function \\<open>ipurge_fail_aux_t_naive\\<close> enjoys the\nfollowing properties:\n\n\\null\n\n@{term \"fst (ipurge_fail_aux_t_naive I D U xs None X) = ipurge_tr_aux I D U xs\"}\n\n\\null\n\n@{term \"snd (ipurge_fail_aux_t_naive I D U xs None X) = ipurge_ref_aux I D U xs X\"}\n\n\\null\n\n@{term \"\\<lbrakk>secure P I D; (xs, X) \\<in> failures P\\<rbrakk> \\<Longrightarrow>\n  ipurge_fail_aux_t_naive I D U xs None X \\<in> failures P\"}\n\n\\null\n\nwhich altogether imply the target lemma, viz. the closure of the failures of a secure process under\nintransitive purge.\n\nIn what follows, the steps provided for by the aforesaid proof method will be dealt with one after\nthe other, with the purpose of proving the target closure lemma in the final step. For more\ninformation on this proof method, cf. \\cite{R1}.\n\\<close>"], ["", "subsubsection \"Step 1\""], ["", "text \\<open>\nIn the definition of the auxiliary tail-recursive function \\<open>ipurge_fail_aux_t_aux\\<close>, the\nCartesian product of the input parameter types of function \\<open>ipurge_fail_aux_t_naive\\<close> will be\nimplemented as the following record type:\n\n\\null\n\\<close>"], ["", "record ('a, 'd) ipurge_rec =\n  Pol :: \"('d \\<times> 'd) set\"\n  Map :: \"'a \\<Rightarrow> 'd\"\n  Doms :: \"'d set\"\n  List :: \"'a list\"\n  ListOp :: \"'a list option\"\n  Set :: \"'a set\""], ["", "text \\<open>\n\\null\n\nHere below is the resulting definition of function \\<open>ipurge_fail_aux_t_aux\\<close>:\n\n\\null\n\\<close>"], ["", "function ipurge_fail_aux_t_aux :: \"('a, 'd) ipurge_rec \\<Rightarrow> ('a, 'd) ipurge_rec\"\nwhere\n\n\"ipurge_fail_aux_t_aux \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n  ListOp = None, Set = X\\<rparr> =\n ipurge_fail_aux_t_aux \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n  ListOp = Some [], Set = ipurge_ref_aux I D U [] X\\<rparr>\" |\n\n\"ipurge_fail_aux_t_aux \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n  ListOp = Some ys, Set = X\\<rparr> =\n (if \\<exists>u \\<in> U. (u, D x) \\<in> I\n  then ipurge_fail_aux_t_aux \\<lparr>Pol = I, Map = D, Doms = U,\n   List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n    Set = ipurge_ref I D (D x) xs X\\<rparr>\n  else ipurge_fail_aux_t_aux \\<lparr>Pol = I, Map = D, Doms = U,\n   List = xs, ListOp = Some (ys @ [x]), Set = X\\<rparr>)\" |\n\n\"ipurge_fail_aux_t_aux\n  \\<lparr>Pol = I, Map = D, Doms = U, List = [], ListOp = Some ys, Set = X\\<rparr> =\n \\<lparr>Pol = I, Map = D, Doms = U, List = [], ListOp = Some ys, Set = X\\<rparr>\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>I D U xs X.\n                   x =\n                   \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                      ListOp = None, Set = X\\<rparr> \\<Longrightarrow>\n                   P;\n        \\<And>I D U xa xs ys X.\n           x =\n           \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n              ListOp = Some ys, Set = X\\<rparr> \\<Longrightarrow>\n           P;\n        \\<And>I D U ys X.\n           x =\n           \\<lparr>Pol = I, Map = D, Doms = U, List = [], ListOp = Some ys,\n              Set = X\\<rparr> \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>I D U xs X Ia Da Ua xsa Xa.\n       \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n          Set = X\\<rparr> =\n       \\<lparr>Pol = Ia, Map = Da, Doms = Ua, List = xsa, ListOp = None,\n          Set = Xa\\<rparr> \\<Longrightarrow>\n       ipurge_fail_aux_t_aux_sumC\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr> =\n       ipurge_fail_aux_t_aux_sumC\n        \\<lparr>Pol = Ia, Map = Da, Doms = Ua, List = xsa, ListOp = Some [],\n           Set = ipurge_ref_aux Ia Da Ua [] Xa\\<rparr>\n 3. \\<And>I D U xs X Ia Da Ua x xsa ys Xa.\n       \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n          Set = X\\<rparr> =\n       \\<lparr>Pol = Ia, Map = Da, Doms = Ua, List = x # xsa,\n          ListOp = Some ys, Set = Xa\\<rparr> \\<Longrightarrow>\n       ipurge_fail_aux_t_aux_sumC\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr> =\n       (if \\<exists>u\\<in>Ua. (u, Da x) \\<in> Ia\n        then ipurge_fail_aux_t_aux_sumC\n              \\<lparr>Pol = Ia, Map = Da, Doms = Ua,\n                 List = ipurge_tr Ia Da (Da x) xsa, ListOp = Some ys,\n                 Set = ipurge_ref Ia Da (Da x) xsa Xa\\<rparr>\n        else ipurge_fail_aux_t_aux_sumC\n              \\<lparr>Pol = Ia, Map = Da, Doms = Ua, List = xsa,\n                 ListOp = Some (ys @ [x]), Set = Xa\\<rparr>)\n 4. \\<And>I D U xs X Ia Da Ua ys Xa.\n       \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n          Set = X\\<rparr> =\n       \\<lparr>Pol = Ia, Map = Da, Doms = Ua, List = [], ListOp = Some ys,\n          Set = Xa\\<rparr> \\<Longrightarrow>\n       ipurge_fail_aux_t_aux_sumC\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr> =\n       \\<lparr>Pol = Ia, Map = Da, Doms = Ua, List = [], ListOp = Some ys,\n          Set = Xa\\<rparr>\n 5. \\<And>I D U x xs ys X Ia Da Ua xa xsa ysa Xa.\n       \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n          Set = X\\<rparr> =\n       \\<lparr>Pol = Ia, Map = Da, Doms = Ua, List = xa # xsa,\n          ListOp = Some ysa, Set = Xa\\<rparr> \\<Longrightarrow>\n       (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n        then ipurge_fail_aux_t_aux_sumC\n              \\<lparr>Pol = I, Map = D, Doms = U,\n                 List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                 Set = ipurge_ref I D (D x) xs X\\<rparr>\n        else ipurge_fail_aux_t_aux_sumC\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                 ListOp = Some (ys @ [x]), Set = X\\<rparr>) =\n       (if \\<exists>u\\<in>Ua. (u, Da xa) \\<in> Ia\n        then ipurge_fail_aux_t_aux_sumC\n              \\<lparr>Pol = Ia, Map = Da, Doms = Ua,\n                 List = ipurge_tr Ia Da (Da xa) xsa, ListOp = Some ysa,\n                 Set = ipurge_ref Ia Da (Da xa) xsa Xa\\<rparr>\n        else ipurge_fail_aux_t_aux_sumC\n              \\<lparr>Pol = Ia, Map = Da, Doms = Ua, List = xsa,\n                 ListOp = Some (ysa @ [xa]), Set = Xa\\<rparr>)\n 6. \\<And>I D U x xs ys X Ia Da Ua ysa Xa.\n       \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n          Set = X\\<rparr> =\n       \\<lparr>Pol = Ia, Map = Da, Doms = Ua, List = [], ListOp = Some ysa,\n          Set = Xa\\<rparr> \\<Longrightarrow>\n       (if \\<exists>u\\<in>U. (u, D x) \\<in> I\n        then ipurge_fail_aux_t_aux_sumC\n              \\<lparr>Pol = I, Map = D, Doms = U,\n                 List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                 Set = ipurge_ref I D (D x) xs X\\<rparr>\n        else ipurge_fail_aux_t_aux_sumC\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                 ListOp = Some (ys @ [x]), Set = X\\<rparr>) =\n       \\<lparr>Pol = Ia, Map = Da, Doms = Ua, List = [], ListOp = Some ysa,\n          Set = Xa\\<rparr>\n 7. \\<And>I D U ys X Ia Da Ua ysa Xa.\n       \\<lparr>Pol = I, Map = D, Doms = U, List = [], ListOp = Some ys,\n          Set = X\\<rparr> =\n       \\<lparr>Pol = Ia, Map = Da, Doms = Ua, List = [], ListOp = Some ysa,\n          Set = Xa\\<rparr> \\<Longrightarrow>\n       \\<lparr>Pol = I, Map = D, Doms = U, List = [], ListOp = Some ys,\n          Set = X\\<rparr> =\n       \\<lparr>Pol = Ia, Map = Da, Doms = Ua, List = [], ListOp = Some ysa,\n          Set = Xa\\<rparr>", "proof (simp_all, atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>I D U xs X.\n           x =\n           \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n              Set = X\\<rparr>) \\<or>\n       (\\<exists>I D U xa xs ys X.\n           x =\n           \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n              ListOp = Some ys, Set = X\\<rparr>) \\<or>\n       (\\<exists>I D U ys X.\n           x =\n           \\<lparr>Pol = I, Map = D, Doms = U, List = [], ListOp = Some ys,\n              Set = X\\<rparr>)", "fix Y :: \"('a, 'd) ipurge_rec\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>I D U xs X.\n           x =\n           \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n              Set = X\\<rparr>) \\<or>\n       (\\<exists>I D U xa xs ys X.\n           x =\n           \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n              ListOp = Some ys, Set = X\\<rparr>) \\<or>\n       (\\<exists>I D U ys X.\n           x =\n           \\<lparr>Pol = I, Map = D, Doms = U, List = [], ListOp = Some ys,\n              Set = X\\<rparr>)", "show\n   \"(\\<exists>I D U xs X. Y = \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n      ListOp = None, Set = X\\<rparr>) \\<or>\n    (\\<exists>I D U x xs ys X. Y = \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n      ListOp = Some ys, Set = X\\<rparr>) \\<or>\n    (\\<exists>I D U ys X. Y = \\<lparr>Pol = I, Map = D, Doms = U, List = [],\n      ListOp = Some ys, Set = X\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>I D U xs X.\n        Y =\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n           Set = X\\<rparr>) \\<or>\n    (\\<exists>I D U x xs ys X.\n        Y =\n        \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n           Set = X\\<rparr>) \\<or>\n    (\\<exists>I D U ys X.\n        Y =\n        \\<lparr>Pol = I, Map = D, Doms = U, List = [], ListOp = Some ys,\n           Set = X\\<rparr>)", "proof (cases Y, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pol Map Doms List ListOp Set.\n       Y =\n       \\<lparr>Pol = Pol, Map = Map, Doms = Doms, List = List,\n          ListOp = ListOp, Set = Set\\<rparr> \\<Longrightarrow>\n       ListOp = None \\<or>\n       (\\<exists>x xs. List = x # xs) \\<and>\n       (\\<exists>ys. ListOp = Some ys) \\<or>\n       List = [] \\<and> (\\<exists>ys. ListOp = Some ys)", "fix xs :: \"'a list\" and yso :: \"'a list option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pol Map Doms List ListOp Set.\n       Y =\n       \\<lparr>Pol = Pol, Map = Map, Doms = Doms, List = List,\n          ListOp = ListOp, Set = Set\\<rparr> \\<Longrightarrow>\n       ListOp = None \\<or>\n       (\\<exists>x xs. List = x # xs) \\<and>\n       (\\<exists>ys. ListOp = Some ys) \\<or>\n       List = [] \\<and> (\\<exists>ys. ListOp = Some ys)", "show\n     \"yso = None \\<or>\n      (\\<exists>x' xs'. xs = x' # xs') \\<and> (\\<exists>ys. yso = Some ys) \\<or>\n      xs = [] \\<and> (\\<exists>ys. yso = Some ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yso = None \\<or>\n    (\\<exists>x' xs'. xs = x' # xs') \\<and>\n    (\\<exists>ys. yso = Some ys) \\<or>\n    xs = [] \\<and> (\\<exists>ys. yso = Some ys)", "proof (cases yso, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       yso = Some a \\<Longrightarrow>\n       (\\<exists>x' xs'. xs = x' # xs') \\<or> xs = []", "qed (subst disj_commute, rule spec [OF list.nchotomy])"], ["proof (state)\nthis:\n  yso = None \\<or>\n  (\\<exists>x' xs'. xs = x' # xs') \\<and> (\\<exists>ys. yso = Some ys) \\<or>\n  xs = [] \\<and> (\\<exists>ys. yso = Some ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>I D U xs X.\n      Y =\n      \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n         Set = X\\<rparr>) \\<or>\n  (\\<exists>I D U x xs ys X.\n      Y =\n      \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n         Set = X\\<rparr>) \\<or>\n  (\\<exists>I D U ys X.\n      Y =\n      \\<lparr>Pol = I, Map = D, Doms = U, List = [], ListOp = Some ys,\n         Set = X\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nThe length of the input event list of function @{term ipurge_fail_aux_t_aux} decreases in every\nrecursive call except for the first one, where the input list is left unchanged while the nested\noutput list passes from @{term None} to @{term \"Some []\"}. A measure function decreasing in the\nfirst recursive call as well can then be obtained by increasing the length of the input list by one\nin case the nested output list matches @{term None}. Using such a measure function, the termination\nof function @{term ipurge_fail_aux_t_aux} is guaranteed by the fact that the event lists output by\nfunction @{term ipurge_tr} are not longer than the corresponding input ones.\n\n\\null\n\\<close>"], ["", "termination ipurge_fail_aux_t_aux"], ["proof (prove)\ngoal (1 subgoal):\n 1. All ipurge_fail_aux_t_aux_dom", "proof (relation \"measure (\\<lambda>Y. (if ListOp Y = None then Suc else id)\n (length (List Y)))\", simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I D U x xs.\n       \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n       length (ipurge_tr I D (D x) xs) < Suc (length xs)", "fix D :: \"'a \\<Rightarrow> 'd\" and I x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I D U x xs.\n       \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n       length (ipurge_tr I D (D x) xs) < Suc (length xs)", "have \"length (ipurge_tr I D (D x) xs) \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ipurge_tr I D (D x) xs) \\<le> length xs", "by (rule ipurge_tr_length)"], ["proof (state)\nthis:\n  length (ipurge_tr I D (D x) xs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<And>I D U x xs.\n       \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n       length (ipurge_tr I D (D x) xs) < Suc (length xs)", "thus \"length (ipurge_tr I D (D x) xs) < Suc (length xs)\""], ["proof (prove)\nusing this:\n  length (ipurge_tr I D (D x) xs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. length (ipurge_tr I D (D x) xs) < Suc (length xs)", "by simp"], ["proof (state)\nthis:\n  length (ipurge_tr I D (D x) xs) < Suc (length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Step 2\""], ["", "definition ipurge_fail_aux_t_in ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'a set \\<Rightarrow> ('a, 'd) ipurge_rec\"\nwhere\n\"ipurge_fail_aux_t_in I D U xs X \\<equiv>\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None, Set = X\\<rparr>\""], ["", "definition ipurge_fail_aux_t_out :: \"('a, 'd) ipurge_rec \\<Rightarrow> 'a failure\" where\n\"ipurge_fail_aux_t_out Y \\<equiv> (case ListOp Y of Some ys \\<Rightarrow> ys, Set Y)\""], ["", "definition ipurge_fail_aux_t ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'a set \\<Rightarrow> 'a failure\"\nwhere\n\"ipurge_fail_aux_t I D U xs X \\<equiv>\n  ipurge_fail_aux_t_out (ipurge_fail_aux_t_aux (ipurge_fail_aux_t_in I D U xs X))\""], ["", "text \\<open>\n\\null\n\nSince the significant inputs of function \\<open>ipurge_fail_aux_t_naive\\<close> match pattern\n\\<open>_, _, _, _, None, _\\<close>, those of function @{term ipurge_fail_aux_t_aux}, as returned by\nfunction @{term ipurge_fail_aux_t_in}, match pattern\n\\<open>\\<lparr>Pol = _, Map = _, Doms = _, List = _, ListOp = None, Set = _\\<rparr>\\<close>.\n\nLikewise, since the nested output lists returned by function @{term ipurge_fail_aux_t_aux} match\npattern \\<open>Some _\\<close>, function @{term ipurge_fail_aux_t_out} does not need to worry about\ndealing with nested output lists equal to @{term None}.\n\nIn terms of function @{term ipurge_fail_aux_t}, the statements to be proven in order to demonstrate\nthe target closure lemma, previously expressed using function \\<open>ipurge_fail_aux_t_naive\\<close> and\nhenceforth respectively named \\<open>ipurge_fail_aux_t_eq_tr\\<close>, \\<open>ipurge_fail_aux_t_eq_ref\\<close>, and\n\\<open>ipurge_fail_aux_t_failures\\<close>, take the following form:\n\n\\null\n\n@{term \"fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs\"}\n\n\\null\n\n@{term \"snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X\"}\n\n\\null\n\n@{term \"\\<lbrakk>secure P I D; (xs, X) \\<in> failures P\\<rbrakk> \\<Longrightarrow>\n  ipurge_fail_aux_t I D U xs X \\<in> failures P\"}\n\\<close>"], ["", "subsubsection \"Step 3\""], ["", "inductive_set ipurge_fail_aux_t_set ::\n \"('a, 'd) ipurge_rec \\<Rightarrow> ('a, 'd) ipurge_rec set\"\nfor Y :: \"('a, 'd) ipurge_rec\" where\n\nR0: \"Y \\<in> ipurge_fail_aux_t_set Y\" |\n\nR1: \"\\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n  ListOp = None, Set = X\\<rparr> \\<in> ipurge_fail_aux_t_set Y \\<Longrightarrow>\n \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n  ListOp = Some [], Set = ipurge_ref_aux I D U [] X\\<rparr> \\<in> ipurge_fail_aux_t_set Y\" |\n\nR2: \"\\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n  ListOp = Some ys, Set = X\\<rparr> \\<in> ipurge_fail_aux_t_set Y;\n \\<exists>u \\<in> U. (u, D x) \\<in> I\\<rbrakk> \\<Longrightarrow>\n \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n  ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr> \\<in> ipurge_fail_aux_t_set Y\" |\n\nR3: \"\\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n  ListOp = Some ys, Set = X\\<rparr> \\<in> ipurge_fail_aux_t_set Y;\n \\<not> (\\<exists>u \\<in> U. (u, D x) \\<in> I)\\<rbrakk> \\<Longrightarrow>\n \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n  ListOp = Some (ys @ [x]), Set = X\\<rparr> \\<in> ipurge_fail_aux_t_set Y\""], ["", "subsubsection \"Step 4\""], ["", "lemma ipurge_fail_aux_t_subset:\n  assumes A: \"Z \\<in> ipurge_fail_aux_t_set Y\"\n  shows \"ipurge_fail_aux_t_set Z \\<subseteq> ipurge_fail_aux_t_set Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_set Z \\<subseteq> ipurge_fail_aux_t_set Y", "proof (rule subsetI, erule ipurge_fail_aux_t_set.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. Z \\<in> ipurge_fail_aux_t_set Y\n 2. \\<And>x I D U xs X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                   ListOp = None, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n           Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some [],\n                            Set = ipurge_ref_aux I D U [] X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 3. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<exists>u\\<in>U. (u, D xa) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                            List = ipurge_tr I D (D xa) xs,\n                            ListOp = Some ys,\n                            Set = ipurge_ref I D (D xa) xs X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 4. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<not> (\\<exists>u\\<in>U. (u, D xa) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some (ys @ [xa]), Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y", "show \"Z \\<in> ipurge_fail_aux_t_set Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<in> ipurge_fail_aux_t_set Y", "using A"], ["proof (prove)\nusing this:\n  Z \\<in> ipurge_fail_aux_t_set Y\n\ngoal (1 subgoal):\n 1. Z \\<in> ipurge_fail_aux_t_set Y", "."], ["proof (state)\nthis:\n  Z \\<in> ipurge_fail_aux_t_set Y\n\ngoal (3 subgoals):\n 1. \\<And>x I D U xs X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                   ListOp = None, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n           Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some [],\n                            Set = ipurge_ref_aux I D U [] X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 2. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<exists>u\\<in>U. (u, D xa) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                            List = ipurge_tr I D (D xa) xs,\n                            ListOp = Some ys,\n                            Set = ipurge_ref I D (D xa) xs X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 3. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<not> (\\<exists>u\\<in>U. (u, D xa) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some (ys @ [xa]), Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x I D U xs X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                   ListOp = None, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n           Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some [],\n                            Set = ipurge_ref_aux I D U [] X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 2. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<exists>u\\<in>U. (u, D xa) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                            List = ipurge_tr I D (D xa) xs,\n                            ListOp = Some ys,\n                            Set = ipurge_ref I D (D xa) xs X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 3. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<not> (\\<exists>u\\<in>U. (u, D xa) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some (ys @ [xa]), Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y", "fix I D U xs X"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x I D U xs X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                   ListOp = None, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n           Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some [],\n                            Set = ipurge_ref_aux I D U [] X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 2. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<exists>u\\<in>U. (u, D xa) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                            List = ipurge_tr I D (D xa) xs,\n                            ListOp = Some ys,\n                            Set = ipurge_ref I D (D xa) xs X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 3. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<not> (\\<exists>u\\<in>U. (u, D xa) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some (ys @ [xa]), Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y", "assume \"\\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n    ListOp = None, Set = X\\<rparr> \\<in> ipurge_fail_aux_t_set Y\""], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set Y\n\ngoal (3 subgoals):\n 1. \\<And>x I D U xs X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                   ListOp = None, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n           Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some [],\n                            Set = ipurge_ref_aux I D U [] X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 2. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<exists>u\\<in>U. (u, D xa) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                            List = ipurge_tr I D (D xa) xs,\n                            ListOp = Some ys,\n                            Set = ipurge_ref I D (D xa) xs X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 3. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<not> (\\<exists>u\\<in>U. (u, D xa) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some (ys @ [xa]), Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y", "thus \"\\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n    ListOp = Some [], Set = ipurge_ref_aux I D U [] X\\<rparr> \\<in> ipurge_fail_aux_t_set Y\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set Y\n\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n       Set = ipurge_ref_aux I D U [] X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set Y", "by (rule R1)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n     Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set Y\n\ngoal (2 subgoals):\n 1. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<exists>u\\<in>U. (u, D xa) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                            List = ipurge_tr I D (D xa) xs,\n                            ListOp = Some ys,\n                            Set = ipurge_ref I D (D xa) xs X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 2. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<not> (\\<exists>u\\<in>U. (u, D xa) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some (ys @ [xa]), Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<exists>u\\<in>U. (u, D xa) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                            List = ipurge_tr I D (D xa) xs,\n                            ListOp = Some ys,\n                            Set = ipurge_ref I D (D xa) xs X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 2. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<not> (\\<exists>u\\<in>U. (u, D xa) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some (ys @ [xa]), Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y", "fix I D U x xs ys X"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<exists>u\\<in>U. (u, D xa) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                            List = ipurge_tr I D (D xa) xs,\n                            ListOp = Some ys,\n                            Set = ipurge_ref I D (D xa) xs X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 2. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<not> (\\<exists>u\\<in>U. (u, D xa) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some (ys @ [xa]), Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y", "assume\n   \"\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n      ListOp = Some ys, Set = X\\<rparr> \\<in> ipurge_fail_aux_t_set Y\" and\n   \"\\<exists>u \\<in> U. (u, D x) \\<in> I\""], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set Y\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<exists>u\\<in>U. (u, D xa) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                            List = ipurge_tr I D (D xa) xs,\n                            ListOp = Some ys,\n                            Set = ipurge_ref I D (D xa) xs X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y\n 2. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<not> (\\<exists>u\\<in>U. (u, D xa) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some (ys @ [xa]), Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y", "thus \"\\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n    ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr> \\<in> ipurge_fail_aux_t_set Y\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set Y\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n       ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set Y", "by (rule R2)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n     ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set Y\n\ngoal (1 subgoal):\n 1. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<not> (\\<exists>u\\<in>U. (u, D xa) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some (ys @ [xa]), Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<not> (\\<exists>u\\<in>U. (u, D xa) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some (ys @ [xa]), Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y", "fix I D U x xs ys X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<not> (\\<exists>u\\<in>U. (u, D xa) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some (ys @ [xa]), Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y", "assume\n   \"\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n      ListOp = Some ys, Set = X\\<rparr> \\<in> ipurge_fail_aux_t_set Y\" and\n   \"\\<not> (\\<exists>u \\<in> U. (u, D x) \\<in> I)\""], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set Y\n  \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>x I D U xa xs ys X.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n                   ListOp = Some ys, Set = X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set Z;\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xa # xs,\n           ListOp = Some ys, Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set Y;\n        \\<not> (\\<exists>u\\<in>U. (u, D xa) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                            ListOp = Some (ys @ [xa]), Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set Y", "thus \"\\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n    ListOp = Some (ys @ [x]), Set = X\\<rparr> \\<in> ipurge_fail_aux_t_set Y\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set Y\n  \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n       Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set Y", "by (rule R3)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_fail_aux_t_aux_set:\n \"ipurge_fail_aux_t_aux Y \\<in> ipurge_fail_aux_t_set Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_aux Y \\<in> ipurge_fail_aux_t_set Y", "proof (induction rule: ipurge_fail_aux_t_aux.induct,\n simp_all add: R0 del: ipurge_fail_aux_t_aux.simps(2))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I D U xs X.\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                 ListOp = Some [],\n                 Set = ipurge_ref_aux I D U [] X\\<rparr> \\<Longrightarrow>\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                 Set = X\\<rparr>\n 2. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "fix I U xs X and D :: \"'a \\<Rightarrow> 'd\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I D U xs X.\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                 ListOp = Some [],\n                 Set = ipurge_ref_aux I D U [] X\\<rparr> \\<Longrightarrow>\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                 Set = X\\<rparr>\n 2. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "let\n    ?Y = \"\\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n      ListOp = None, Set = X\\<rparr>\" and\n    ?Y' = \"\\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n      ListOp = Some [], Set = ipurge_ref_aux I D U [] X\\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I D U xs X.\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                 ListOp = Some [],\n                 Set = ipurge_ref_aux I D U [] X\\<rparr> \\<Longrightarrow>\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                 Set = X\\<rparr>\n 2. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "have \"?Y \\<in> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n              Set = X\\<rparr>", "by (rule R0)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n            Set = X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>I D U xs X.\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                 ListOp = Some [],\n                 Set = ipurge_ref_aux I D U [] X\\<rparr> \\<Longrightarrow>\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                 Set = X\\<rparr>\n 2. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "moreover"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n            Set = X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>I D U xs X.\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                 ListOp = Some [],\n                 Set = ipurge_ref_aux I D U [] X\\<rparr> \\<Longrightarrow>\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                 Set = X\\<rparr>\n 2. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "have \"?Y \\<in> ipurge_fail_aux_t_set ?Y \\<Longrightarrow>\n    ?Y' \\<in> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n              Set = X\\<rparr> \\<Longrightarrow>\n    \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n       Set = ipurge_ref_aux I D U [] X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n              Set = X\\<rparr>", "by (rule R1)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n            Set = X\\<rparr> \\<Longrightarrow>\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n     Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n            Set = X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>I D U xs X.\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                 ListOp = Some [],\n                 Set = ipurge_ref_aux I D U [] X\\<rparr> \\<Longrightarrow>\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                 Set = X\\<rparr>\n 2. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n            Set = X\\<rparr>\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n            Set = X\\<rparr> \\<Longrightarrow>\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n     Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n            Set = X\\<rparr>", "have \"?Y' \\<in> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n            Set = X\\<rparr>\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n            Set = X\\<rparr> \\<Longrightarrow>\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n     Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n            Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n       Set = ipurge_ref_aux I D U [] X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n              Set = X\\<rparr>", "by simp"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n     Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n            Set = X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>I D U xs X.\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                 ListOp = Some [],\n                 Set = ipurge_ref_aux I D U [] X\\<rparr> \\<Longrightarrow>\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                 Set = X\\<rparr>\n 2. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "hence \"ipurge_fail_aux_t_set ?Y' \\<subseteq> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n     Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n            Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_set\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n        Set = ipurge_ref_aux I D U [] X\\<rparr>\n    \\<subseteq> ipurge_fail_aux_t_set\n                 \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                    ListOp = None, Set = X\\<rparr>", "by (rule ipurge_fail_aux_t_subset)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_set\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n      Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<subseteq> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                  Set = X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>I D U xs X.\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                 ListOp = Some [],\n                 Set = ipurge_ref_aux I D U [] X\\<rparr> \\<Longrightarrow>\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                 Set = X\\<rparr>\n 2. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "moreover"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_set\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n      Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<subseteq> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                  Set = X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>I D U xs X.\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                 ListOp = Some [],\n                 Set = ipurge_ref_aux I D U [] X\\<rparr> \\<Longrightarrow>\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                 Set = X\\<rparr>\n 2. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "assume \"ipurge_fail_aux_t_aux ?Y' \\<in> ipurge_fail_aux_t_set ?Y'\""], ["proof (state)\nthis:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n      Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n            Set = ipurge_ref_aux I D U [] X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>I D U xs X.\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                 ListOp = Some [],\n                 Set = ipurge_ref_aux I D U [] X\\<rparr> \\<Longrightarrow>\n       ipurge_fail_aux_t_aux\n        \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n           Set = ipurge_ref_aux I D U [] X\\<rparr>\n       \\<in> ipurge_fail_aux_t_set\n              \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                 Set = X\\<rparr>\n 2. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_fail_aux_t_set\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n      Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<subseteq> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                  Set = X\\<rparr>\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n      Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n            Set = ipurge_ref_aux I D U [] X\\<rparr>", "show \"ipurge_fail_aux_t_aux ?Y' \\<in> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\nusing this:\n  ipurge_fail_aux_t_set\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n      Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<subseteq> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n                  Set = X\\<rparr>\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n      Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n            Set = ipurge_ref_aux I D U [] X\\<rparr>\n\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n        Set = ipurge_ref_aux I D U [] X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n              Set = X\\<rparr>", ".."], ["proof (state)\nthis:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some [],\n      Set = ipurge_ref_aux I D U [] X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n            Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "fix I U x xs ys X and D :: \"'a \\<Rightarrow> 'd\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "let\n    ?Y = \"\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n      ListOp = Some ys, Set = X\\<rparr>\" and\n    ?Y' = \"\\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n      ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\" and\n    ?Y'' = \"\\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n      ListOp = Some (ys @ [x]), Set = X\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "assume\n    A: \"\\<exists>u \\<in> U. (u, D x) \\<in> I \\<Longrightarrow>\n      ipurge_fail_aux_t_aux ?Y' \\<in> ipurge_fail_aux_t_set ?Y'\" and\n    B: \"\\<forall>u \\<in> U. (u, D x) \\<notin> I \\<Longrightarrow>\n      ipurge_fail_aux_t_aux ?Y'' \\<in> ipurge_fail_aux_t_set ?Y''\""], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n      ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n            ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>I D U x xs ys X.\n       \\<lbrakk>\\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n                ipurge_fail_aux_t_aux\n                 \\<lparr>Pol = I, Map = D, Doms = U,\n                    List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                    Set = ipurge_ref I D (D x) xs X\\<rparr>\n                \\<in> ipurge_fail_aux_t_set\n                       \\<lparr>Pol = I, Map = D, Doms = U,\n                          List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                          Set = ipurge_ref I D (D x) xs X\\<rparr>;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n        ipurge_fail_aux_t_aux\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n        \\<in> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                  ListOp = Some (ys @ [x]), Set = X\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_fail_aux_t_aux\n                          \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                             ListOp = Some ys, Set = X\\<rparr>\n                         \\<in> ipurge_fail_aux_t_set\n                                \\<lparr>Pol = I, Map = D, Doms = U,\n                                   List = x # xs, ListOp = Some ys,\n                                   Set = X\\<rparr>", "show \"ipurge_fail_aux_t_aux ?Y \\<in> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n        Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "proof (cases \"\\<exists>u \\<in> U. (u, D x) \\<in> I\", simp_all (no_asm_simp))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n        ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n 2. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "case True"], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n        ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n 2. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "have \"?Y \\<in> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n       Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "by (rule R0)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n        ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n 2. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "moreover"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n        ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n 2. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "have \"?Y \\<in> ipurge_fail_aux_t_set ?Y \\<Longrightarrow> \\<exists>u \\<in> U. (u, D x) \\<in> I \\<Longrightarrow>\n      ?Y' \\<in> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                ListOp = Some ys, Set = X\\<rparr>\n             \\<in> ipurge_fail_aux_t_set\n                    \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                       ListOp = Some ys, Set = X\\<rparr>;\n     \\<exists>u\\<in>U. (u, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                         List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                         Set = ipurge_ref I D (D x) xs X\\<rparr>\n                      \\<in> ipurge_fail_aux_t_set\n                             \\<lparr>Pol = I, Map = D, Doms = U,\n                                List = x # xs, ListOp = Some ys,\n                                Set = X\\<rparr>", "by (rule R2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n           \\<in> ipurge_fail_aux_t_set\n                  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                     ListOp = Some ys, Set = X\\<rparr>;\n   \\<exists>u\\<in>U. (u, D x) \\<in> I\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                       List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                       Set = ipurge_ref I D (D x) xs X\\<rparr>\n                    \\<in> ipurge_fail_aux_t_set\n                           \\<lparr>Pol = I, Map = D, Doms = U,\n                              List = x # xs, ListOp = Some ys,\n                              Set = X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n        ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n 2. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n  \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n           \\<in> ipurge_fail_aux_t_set\n                  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                     ListOp = Some ys, Set = X\\<rparr>;\n   \\<exists>u\\<in>U. (u, D x) \\<in> I\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                       List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                       Set = ipurge_ref I D (D x) xs X\\<rparr>\n                    \\<in> ipurge_fail_aux_t_set\n                           \\<lparr>Pol = I, Map = D, Doms = U,\n                              List = x # xs, ListOp = Some ys,\n                              Set = X\\<rparr>", "have \"?Y' \\<in> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n  \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n           \\<in> ipurge_fail_aux_t_set\n                  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                     ListOp = Some ys, Set = X\\<rparr>;\n   \\<exists>u\\<in>U. (u, D x) \\<in> I\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                       List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                       Set = ipurge_ref I D (D x) xs X\\<rparr>\n                    \\<in> ipurge_fail_aux_t_set\n                           \\<lparr>Pol = I, Map = D, Doms = U,\n                              List = x # xs, ListOp = Some ys,\n                              Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n       ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "using True"], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n  \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n           \\<in> ipurge_fail_aux_t_set\n                  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                     ListOp = Some ys, Set = X\\<rparr>;\n   \\<exists>u\\<in>U. (u, D x) \\<in> I\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U,\n                       List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n                       Set = ipurge_ref I D (D x) xs X\\<rparr>\n                    \\<in> ipurge_fail_aux_t_set\n                           \\<lparr>Pol = I, Map = D, Doms = U,\n                              List = x # xs, ListOp = Some ys,\n                              Set = X\\<rparr>\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n       ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "by simp"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n     ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n        ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n 2. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "hence \"ipurge_fail_aux_t_set ?Y' \\<subseteq> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n     ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_set\n     \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n        ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<subseteq> ipurge_fail_aux_t_set\n                 \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                    ListOp = Some ys, Set = X\\<rparr>", "by (rule ipurge_fail_aux_t_subset)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_set\n   \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n      ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<subseteq> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                  ListOp = Some ys, Set = X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n        ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n 2. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "moreover"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_set\n   \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n      ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<subseteq> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                  ListOp = Some ys, Set = X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n        ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n 2. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "have \"ipurge_fail_aux_t_aux ?Y' \\<in> ipurge_fail_aux_t_set ?Y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n        ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U,\n              List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n              Set = ipurge_ref I D (D x) xs X\\<rparr>", "using A and True"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n      ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n            ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n        ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U,\n              List = ipurge_tr I D (D x) xs, ListOp = Some ys,\n              Set = ipurge_ref I D (D x) xs X\\<rparr>", "by simp"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n      ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n            ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n        ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n 2. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_fail_aux_t_set\n   \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n      ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<subseteq> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                  ListOp = Some ys, Set = X\\<rparr>\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n      ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n            ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>", "show \"ipurge_fail_aux_t_aux ?Y' \\<in> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\nusing this:\n  ipurge_fail_aux_t_set\n   \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n      ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<subseteq> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                  ListOp = Some ys, Set = X\\<rparr>\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n      ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n            ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n        ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", ".."], ["proof (state)\nthis:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = ipurge_tr I D (D x) xs,\n      ListOp = Some ys, Set = ipurge_ref I D (D x) xs X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "have \"?Y \\<in> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n       Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "by (rule R0)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "moreover"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "have \"?Y \\<in> ipurge_fail_aux_t_set ?Y \\<Longrightarrow>\n      \\<not> (\\<exists>u \\<in> U. (u, D x) \\<in> I) \\<Longrightarrow> ?Y'' \\<in> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                ListOp = Some ys, Set = X\\<rparr>\n             \\<in> ipurge_fail_aux_t_set\n                    \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                       ListOp = Some ys, Set = X\\<rparr>;\n     \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                         ListOp = Some (ys @ [x]), Set = X\\<rparr>\n                      \\<in> ipurge_fail_aux_t_set\n                             \\<lparr>Pol = I, Map = D, Doms = U,\n                                List = x # xs, ListOp = Some ys,\n                                Set = X\\<rparr>", "by (rule R3)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n           \\<in> ipurge_fail_aux_t_set\n                  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                     ListOp = Some ys, Set = X\\<rparr>;\n   \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                       ListOp = Some (ys @ [x]), Set = X\\<rparr>\n                    \\<in> ipurge_fail_aux_t_set\n                           \\<lparr>Pol = I, Map = D, Doms = U,\n                              List = x # xs, ListOp = Some ys,\n                              Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n  \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n           \\<in> ipurge_fail_aux_t_set\n                  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                     ListOp = Some ys, Set = X\\<rparr>;\n   \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                       ListOp = Some (ys @ [x]), Set = X\\<rparr>\n                    \\<in> ipurge_fail_aux_t_set\n                           \\<lparr>Pol = I, Map = D, Doms = U,\n                              List = x # xs, ListOp = Some ys,\n                              Set = X\\<rparr>", "have \"?Y'' \\<in> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n  \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n           \\<in> ipurge_fail_aux_t_set\n                  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                     ListOp = Some ys, Set = X\\<rparr>;\n   \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                       ListOp = Some (ys @ [x]), Set = X\\<rparr>\n                    \\<in> ipurge_fail_aux_t_set\n                           \\<lparr>Pol = I, Map = D, Doms = U,\n                              List = x # xs, ListOp = Some ys,\n                              Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n       Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "using False"], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n  \\<lbrakk>\\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>\n           \\<in> ipurge_fail_aux_t_set\n                  \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                     ListOp = Some ys, Set = X\\<rparr>;\n   \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n                       ListOp = Some (ys @ [x]), Set = X\\<rparr>\n                    \\<in> ipurge_fail_aux_t_set\n                           \\<lparr>Pol = I, Map = D, Doms = U,\n                              List = x # xs, ListOp = Some ys,\n                              Set = X\\<rparr>\n  \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n       Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "by simp"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "hence \"ipurge_fail_aux_t_set ?Y'' \\<subseteq> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n     Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_set\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<subseteq> ipurge_fail_aux_t_set\n                 \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                    ListOp = Some ys, Set = X\\<rparr>", "by (rule ipurge_fail_aux_t_subset)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_set\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n      Set = X\\<rparr>\n  \\<subseteq> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                  ListOp = Some ys, Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "moreover"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_set\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n      Set = X\\<rparr>\n  \\<subseteq> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                  ListOp = Some ys, Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "have \"ipurge_fail_aux_t_aux ?Y'' \\<in> ipurge_fail_aux_t_set ?Y''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n              ListOp = Some (ys @ [x]), Set = X\\<rparr>", "using B and False"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n  \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n              ListOp = Some (ys @ [x]), Set = X\\<rparr>", "by simp"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_fail_aux_t_set\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n      Set = X\\<rparr>\n  \\<subseteq> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                  ListOp = Some ys, Set = X\\<rparr>\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>", "show \"ipurge_fail_aux_t_aux ?Y'' \\<in> ipurge_fail_aux_t_set ?Y\""], ["proof (prove)\nusing this:\n  ipurge_fail_aux_t_set\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n      Set = X\\<rparr>\n  \\<subseteq> ipurge_fail_aux_t_set\n               \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n                  ListOp = Some ys, Set = X\\<rparr>\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n            ListOp = Some (ys @ [x]), Set = X\\<rparr>\n\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs,\n        ListOp = Some (ys @ [x]), Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n              ListOp = Some ys, Set = X\\<rparr>", ".."], ["proof (state)\nthis:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = Some (ys @ [x]),\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs, ListOp = Some ys,\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         \\<lparr>Pol = I, Map = D, Doms = U, List = x # xs,\n            ListOp = Some ys, Set = X\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Step 5\""], ["", "definition ipurge_fail_aux_t_inv_1 ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'd) ipurge_rec \\<Rightarrow> bool\"\nwhere\n\"ipurge_fail_aux_t_inv_1 I D U xs Y \\<equiv>\n  (case ListOp Y of None \\<Rightarrow> [] | Some ys \\<Rightarrow> ys) @ ipurge_tr_aux I D U (List Y) =\n  ipurge_tr_aux I D U xs\""], ["", "definition ipurge_fail_aux_t_inv_2 ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'a set \\<Rightarrow>\n    ('a, 'd) ipurge_rec \\<Rightarrow> bool\"\nwhere\n\"ipurge_fail_aux_t_inv_2 I D U xs X Y \\<equiv>\n  if ListOp Y = None\n  then List Y = xs \\<and> Set Y = X\n  else ipurge_ref_aux_less I D U (List Y) (Set Y) = ipurge_ref_aux I D U xs X\""], ["", "definition ipurge_fail_aux_t_inv_3 ::\n \"'a process \\<Rightarrow> ('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'a list \\<Rightarrow> 'a set \\<Rightarrow>\n    ('a, 'd) ipurge_rec \\<Rightarrow> bool\"\nwhere\n\"ipurge_fail_aux_t_inv_3 P I D xs X Y \\<equiv>\n  secure P I D \\<longrightarrow> (xs, X) \\<in> failures P \\<longrightarrow>\n  ((case ListOp Y of None \\<Rightarrow> [] | Some ys \\<Rightarrow> ys) @ List Y, Set Y) \\<in> failures P\""], ["", "text \\<open>\n\\null\n\nThree invariants have been defined, one for each of lemmas \\<open>ipurge_fail_aux_t_eq_tr\\<close>,\n\\<open>ipurge_fail_aux_t_eq_ref\\<close>, and \\<open>ipurge_fail_aux_t_failures\\<close>. More precisely, the\ninvariants are @{term \"ipurge_fail_aux_t_inv_1 I D U xs\"},\n@{term \"ipurge_fail_aux_t_inv_2 I D U xs X\"}, and @{term \"ipurge_fail_aux_t_inv_3 P I D xs X\"},\nwhere the free variables are intended to match those appearing in the aforesaid lemmas.\n\nParticularly:\n\n\\begin{itemize}\n\n\\item\nThe first invariant expresses the fact that in each recursive step, any item of the residual input\nlist @{term \"List Y\"} indirectly affected by @{term U} through the effect of previous, already\nconsumed items has already been removed from the list, so that applying function\n@{term \"ipurge_tr_aux I D U\"} to the list is sufficient to obtain the intransitive purge of the\nwhole original list.\n\n\\item\nThe second invariant expresses the fact that in each recursive step, any item of the residual input\nset @{term \"Set Y\"} affected by @{term U} either directly, or through the effect of previous,\nalready consumed items, has already been removed from the set, so that applying function\n@{term \"ipurge_ref_aux_less I D U (List Y)\"} to the set is sufficient to obtain the intransitive\npurge of the whole original set.\n\\\\The use of function @{term ipurge_ref_aux_less} ensures that the invariant implies the equality\n@{term \"Set Y = ipurge_ref_aux I D U xs X\"} for @{term \"List Y = []\"}, viz. for the output values of\nfunction @{term ipurge_fail_aux_t_aux}, which is the reason requiring the introduction of function\n@{term ipurge_ref_aux_less}.\n\n\\item\nThe third invariant expresses the fact that in each recursive step, the event list-event set pair\nsuch that the list matches the concatenation of the partial output list with @{term \"List Y\"}, and\nthe set matches @{term \"Set Y\"}, is a failure provided that the original input pair is such as well.\n\n\\end{itemize}\n\\<close>"], ["", "subsubsection \"Step 6\""], ["", "lemma ipurge_fail_aux_t_input_1:\n \"ipurge_fail_aux_t_inv_1 I D U xs\n    \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None, Set = X\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_inv_1 I D U xs\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>", "by (simp add: ipurge_fail_aux_t_inv_1_def)"], ["", "lemma ipurge_fail_aux_t_input_2:\n \"ipurge_fail_aux_t_inv_2 I D U xs X\n    \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None, Set = X\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_inv_2 I D U xs X\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>", "by (simp add: ipurge_fail_aux_t_inv_2_def)"], ["", "lemma ipurge_fail_aux_t_input_3:\n \"ipurge_fail_aux_t_inv_3 P I D xs X\n    \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None, Set = X\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_inv_3 P I D xs X\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>", "by (simp add: ipurge_fail_aux_t_inv_3_def)"], ["", "subsubsection \"Step 7\""], ["", "definition ipurge_fail_aux_t_form :: \"('a, 'd) ipurge_rec \\<Rightarrow> bool\" where\n\"ipurge_fail_aux_t_form Y \\<equiv>\n  case ListOp Y of None \\<Rightarrow> False | Some ys \\<Rightarrow> List Y = []\""], ["", "lemma ipurge_fail_aux_t_intro_1:\n \"\\<lbrakk>ipurge_fail_aux_t_inv_1 I D U xs Y; ipurge_fail_aux_t_form Y\\<rbrakk> \\<Longrightarrow>\n    fst (ipurge_fail_aux_t_out Y) = ipurge_tr_aux I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipurge_fail_aux_t_inv_1 I D U xs Y;\n     ipurge_fail_aux_t_form Y\\<rbrakk>\n    \\<Longrightarrow> fst (ipurge_fail_aux_t_out Y) = ipurge_tr_aux I D U xs", "proof (simp add: ipurge_fail_aux_t_inv_1_def ipurge_fail_aux_t_form_def\n ipurge_fail_aux_t_out_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n              | Some ys \\<Rightarrow> ys) @\n             ipurge_tr_aux I D U (List Y) =\n             ipurge_tr_aux I D U xs;\n     case ListOp Y of None \\<Rightarrow> False\n     | Some ys \\<Rightarrow> List Y = []\\<rbrakk>\n    \\<Longrightarrow> (case ListOp Y of Some ys \\<Rightarrow> ys) =\n                      ipurge_tr_aux I D U xs", "qed (simp split: option.split_asm)"], ["", "lemma ipurge_fail_aux_t_intro_2:\n \"\\<lbrakk>ipurge_fail_aux_t_inv_2 I D U xs X Y; ipurge_fail_aux_t_form Y\\<rbrakk> \\<Longrightarrow>\n    snd (ipurge_fail_aux_t_out Y) = ipurge_ref_aux I D U xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipurge_fail_aux_t_inv_2 I D U xs X Y;\n     ipurge_fail_aux_t_form Y\\<rbrakk>\n    \\<Longrightarrow> snd (ipurge_fail_aux_t_out Y) =\n                      ipurge_ref_aux I D U xs X", "proof (simp add: ipurge_fail_aux_t_inv_2_def ipurge_fail_aux_t_form_def\n ipurge_fail_aux_t_out_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>if ListOp Y = None then List Y = xs \\<and> Set Y = X\n             else ipurge_ref_aux_less I D U (List Y) (Set Y) =\n                  ipurge_ref_aux I D U xs X;\n     case ListOp Y of None \\<Rightarrow> False\n     | Some ys \\<Rightarrow> List Y = []\\<rbrakk>\n    \\<Longrightarrow> Set Y = ipurge_ref_aux I D U xs X", "qed (simp add: ipurge_ref_aux_less_def split: option.split_asm)"], ["", "lemma ipurge_fail_aux_t_intro_3:\n \"\\<lbrakk>ipurge_fail_aux_t_inv_3 P I D xs X Y; ipurge_fail_aux_t_form Y\\<rbrakk> \\<Longrightarrow>\n    secure P I D \\<longrightarrow> (xs, X) \\<in> failures P \\<longrightarrow>\n      ipurge_fail_aux_t_out Y \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipurge_fail_aux_t_inv_3 P I D xs X Y;\n     ipurge_fail_aux_t_form Y\\<rbrakk>\n    \\<Longrightarrow> secure P I D \\<longrightarrow>\n                      (xs, X) \\<in> failures P \\<longrightarrow>\n                      ipurge_fail_aux_t_out Y \\<in> failures P", "proof (simp add: ipurge_fail_aux_t_inv_3_def ipurge_fail_aux_t_form_def\n ipurge_fail_aux_t_out_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure P I D \\<longrightarrow>\n             (xs, X) \\<in> failures P \\<longrightarrow>\n             ((case ListOp Y of None \\<Rightarrow> []\n               | Some ys \\<Rightarrow> ys) @\n              List Y,\n              Set Y)\n             \\<in> failures P;\n     case ListOp Y of None \\<Rightarrow> False\n     | Some ys \\<Rightarrow> List Y = []\\<rbrakk>\n    \\<Longrightarrow> secure P I D \\<longrightarrow>\n                      (xs, X) \\<in> failures P \\<longrightarrow>\n                      (case ListOp Y of Some ys \\<Rightarrow> ys, Set Y)\n                      \\<in> failures P", "qed (simp split: option.split_asm)"], ["", "subsubsection \"Step 8\""], ["", "lemma ipurge_fail_aux_t_form_aux:\n \"ipurge_fail_aux_t_form (ipurge_fail_aux_t_aux Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_form (ipurge_fail_aux_t_aux Y)", "by (induction Y rule: ipurge_fail_aux_t_aux.induct,\n simp_all add: ipurge_fail_aux_t_form_def)"], ["", "subsubsection \"Step 9\""], ["", "lemma ipurge_fail_aux_t_invariance_aux:\n \"Z \\<in> ipurge_fail_aux_t_set Y \\<Longrightarrow>\n  Pol Z = Pol Y \\<and> Map Z = Map Y \\<and> Doms Z = Doms Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<in> ipurge_fail_aux_t_set Y \\<Longrightarrow>\n    Pol Z = Pol Y \\<and> Map Z = Map Y \\<and> Doms Z = Doms Y", "by (erule ipurge_fail_aux_t_set.induct, simp_all)"], ["", "text \\<open>\n\\null\n\nThe lemma just proven, stating the invariance of the first three record fields over inductive set\n@{term \"ipurge_fail_aux_t_set Y\"}, is used in the following proofs of the invariance of predicates\n@{term \"ipurge_fail_aux_t_inv_1 I D U xs\"}, @{term \"ipurge_fail_aux_t_inv_2 I D U xs X\"}, and\n@{term \"ipurge_fail_aux_t_inv_3 P I D xs X\"}.\n\nThe equality between the free variables appearing in the predicates and the corresponding fields of\nthe record generating the set, which is required for such invariance properties to hold, is asserted\nin the enunciation of the properties by means of record updates. In the subsequent proofs of lemmas\n\\<open>ipurge_fail_aux_t_eq_tr\\<close>, \\<open>ipurge_fail_aux_t_eq_ref\\<close>, and\n\\<open>ipurge_fail_aux_t_failures\\<close>, the enforcement of this equality will be ensured by the\nidentification of both predicate variables and record fields with the related free variables\nappearing in the lemmas.\n\n\\null\n\\<close>"], ["", "lemma ipurge_fail_aux_t_invariance_1:\n \"\\<lbrakk>Z \\<in> ipurge_fail_aux_t_set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>);\n    ipurge_fail_aux_t_inv_1 I D U xs (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\\<rbrakk> \\<Longrightarrow>\n  ipurge_fail_aux_t_inv_1 I D U xs Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Z \\<in> ipurge_fail_aux_t_set\n                      (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>);\n     ipurge_fail_aux_t_inv_1 I D U xs\n      (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> ipurge_fail_aux_t_inv_1 I D U xs Z", "proof (erule ipurge_fail_aux_t_set.induct, assumption,\n drule_tac [!] ipurge_fail_aux_t_invariance_aux,\n simp_all add: ipurge_fail_aux_t_inv_1_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @\n                         ipurge_tr_aux I D U (ipurge_tr I D (D x) xsa) =\n                         ipurge_tr_aux I D U xs\n 2. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "fix x xs' ys"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @\n                         ipurge_tr_aux I D U (ipurge_tr I D (D x) xsa) =\n                         ipurge_tr_aux I D U xs\n 2. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "assume \"ys @ ipurge_tr_aux I D U (x # xs') = ipurge_tr_aux I D U xs\"\n   (is \"?A = ?C\")"], ["proof (state)\nthis:\n  ys @ ipurge_tr_aux I D U (x # xs') = ipurge_tr_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @\n                         ipurge_tr_aux I D U (ipurge_tr I D (D x) xsa) =\n                         ipurge_tr_aux I D U xs\n 2. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "moreover"], ["proof (state)\nthis:\n  ys @ ipurge_tr_aux I D U (x # xs') = ipurge_tr_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @\n                         ipurge_tr_aux I D U (ipurge_tr I D (D x) xsa) =\n                         ipurge_tr_aux I D U xs\n 2. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "assume \"\\<exists>u \\<in> U. (u, D x) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @\n                         ipurge_tr_aux I D U (ipurge_tr I D (D x) xsa) =\n                         ipurge_tr_aux I D U xs\n 2. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "hence \"?A = ys @ ipurge_tr_aux I D (insert (D x) U) xs'\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. ys @ ipurge_tr_aux I D U (x # xs') =\n    ys @ ipurge_tr_aux I D (insert (D x) U) xs'", "by (simp add: ipurge_tr_aux_cons)"], ["proof (state)\nthis:\n  ys @ ipurge_tr_aux I D U (x # xs') =\n  ys @ ipurge_tr_aux I D (insert (D x) U) xs'\n\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @\n                         ipurge_tr_aux I D U (ipurge_tr I D (D x) xsa) =\n                         ipurge_tr_aux I D U xs\n 2. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "hence \"?A = ys @ ipurge_tr_aux I D U (ipurge_tr I D (D x) xs')\"\n   (is \"_ = ?B\")"], ["proof (prove)\nusing this:\n  ys @ ipurge_tr_aux I D U (x # xs') =\n  ys @ ipurge_tr_aux I D (insert (D x) U) xs'\n\ngoal (1 subgoal):\n 1. ys @ ipurge_tr_aux I D U (x # xs') =\n    ys @ ipurge_tr_aux I D U (ipurge_tr I D (D x) xs')", "by (simp add: ipurge_tr_aux_insert)"], ["proof (state)\nthis:\n  ys @ ipurge_tr_aux I D U (x # xs') =\n  ys @ ipurge_tr_aux I D U (ipurge_tr I D (D x) xs')\n\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @\n                         ipurge_tr_aux I D U (ipurge_tr I D (D x) xsa) =\n                         ipurge_tr_aux I D U xs\n 2. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "ultimately"], ["proof (chain)\npicking this:\n  ys @ ipurge_tr_aux I D U (x # xs') = ipurge_tr_aux I D U xs\n  ys @ ipurge_tr_aux I D U (x # xs') =\n  ys @ ipurge_tr_aux I D U (ipurge_tr I D (D x) xs')", "show \"?B = ?C\""], ["proof (prove)\nusing this:\n  ys @ ipurge_tr_aux I D U (x # xs') = ipurge_tr_aux I D U xs\n  ys @ ipurge_tr_aux I D U (x # xs') =\n  ys @ ipurge_tr_aux I D U (ipurge_tr I D (D x) xs')\n\ngoal (1 subgoal):\n 1. ys @ ipurge_tr_aux I D U (ipurge_tr I D (D x) xs') =\n    ipurge_tr_aux I D U xs", "by simp"], ["proof (state)\nthis:\n  ys @ ipurge_tr_aux I D U (ipurge_tr I D (D x) xs') =\n  ipurge_tr_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "fix x xs' ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "assume \"ys @ ipurge_tr_aux I D U (x # xs') = ipurge_tr_aux I D U xs\"\n   (is \"?A = ?C\")"], ["proof (state)\nthis:\n  ys @ ipurge_tr_aux I D U (x # xs') = ipurge_tr_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "moreover"], ["proof (state)\nthis:\n  ys @ ipurge_tr_aux I D U (x # xs') = ipurge_tr_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "assume \"\\<forall>u \\<in> U. (u, D x) \\<notin> I\""], ["proof (state)\nthis:\n  \\<forall>u\\<in>U. (u, D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "hence \"?A = ys @ x # ipurge_tr_aux I D U xs'\"\n   (is \"_ = ?B\")"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>U. (u, D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. ys @ ipurge_tr_aux I D U (x # xs') = ys @ x # ipurge_tr_aux I D U xs'", "by (simp add: ipurge_tr_aux_cons)"], ["proof (state)\nthis:\n  ys @ ipurge_tr_aux I D U (x # xs') = ys @ x # ipurge_tr_aux I D U xs'\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys.\n       \\<lbrakk>(case ListOp Y of None \\<Rightarrow> []\n                 | Some ys \\<Rightarrow> ys) @\n                ipurge_tr_aux I D U (List Y) =\n                ipurge_tr_aux I D U xs;\n        ys @ ipurge_tr_aux I D U (x # xsa) = ipurge_tr_aux I D U xs;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ x # ipurge_tr_aux I D U xsa =\n                         ipurge_tr_aux I D U xs", "ultimately"], ["proof (chain)\npicking this:\n  ys @ ipurge_tr_aux I D U (x # xs') = ipurge_tr_aux I D U xs\n  ys @ ipurge_tr_aux I D U (x # xs') = ys @ x # ipurge_tr_aux I D U xs'", "show \"?B = ?C\""], ["proof (prove)\nusing this:\n  ys @ ipurge_tr_aux I D U (x # xs') = ipurge_tr_aux I D U xs\n  ys @ ipurge_tr_aux I D U (x # xs') = ys @ x # ipurge_tr_aux I D U xs'\n\ngoal (1 subgoal):\n 1. ys @ x # ipurge_tr_aux I D U xs' = ipurge_tr_aux I D U xs", "by simp"], ["proof (state)\nthis:\n  ys @ x # ipurge_tr_aux I D U xs' = ipurge_tr_aux I D U xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_fail_aux_t_invariance_2:\n \"\\<lbrakk>Z \\<in> ipurge_fail_aux_t_set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>);\n    ipurge_fail_aux_t_inv_2 I D U xs X (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\\<rbrakk> \\<Longrightarrow>\n  ipurge_fail_aux_t_inv_2 I D U xs X Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Z \\<in> ipurge_fail_aux_t_set\n                      (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>);\n     ipurge_fail_aux_t_inv_2 I D U xs X\n      (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> ipurge_fail_aux_t_inv_2 I D U xs X Z", "proof (erule ipurge_fail_aux_t_set.induct, assumption,\n drule_tac [!] ipurge_fail_aux_t_invariance_aux,\n simp_all add: ipurge_fail_aux_t_inv_2_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>Ia xsa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        xsa = xs; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xs\n                          (ipurge_ref_aux I D U [] X) =\n                         ipurge_ref_aux I D U xs X\n 2. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xsa)\n                          (ipurge_ref I D (D x) xsa Xa) =\n                         ipurge_ref_aux I D U xs X\n 3. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "show \"ipurge_ref_aux_less I D U xs (ipurge_ref_aux I D U [] X) =\n    ipurge_ref_aux I D U xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U xs (ipurge_ref_aux I D U [] X) =\n    ipurge_ref_aux I D U xs X", "by (rule ipurge_ref_aux_less_nil)"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U xs (ipurge_ref_aux I D U [] X) =\n  ipurge_ref_aux I D U xs X\n\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xsa)\n                          (ipurge_ref I D (D x) xsa Xa) =\n                         ipurge_ref_aux I D U xs X\n 2. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xsa)\n                          (ipurge_ref I D (D x) xsa Xa) =\n                         ipurge_ref_aux I D U xs X\n 2. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "fix x xs' X'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xsa)\n                          (ipurge_ref I D (D x) xsa Xa) =\n                         ipurge_ref_aux I D U xs X\n 2. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "assume \"ipurge_ref_aux_less I D U (x # xs') X' = ipurge_ref_aux I D U xs X\"\n   (is \"?A = ?C\")"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs') X' = ipurge_ref_aux I D U xs X\n\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xsa)\n                          (ipurge_ref I D (D x) xsa Xa) =\n                         ipurge_ref_aux I D U xs X\n 2. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "moreover"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs') X' = ipurge_ref_aux I D U xs X\n\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xsa)\n                          (ipurge_ref I D (D x) xsa Xa) =\n                         ipurge_ref_aux I D U xs X\n 2. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "assume \"\\<exists>u \\<in> U. (u, D x) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xsa)\n                          (ipurge_ref I D (D x) xsa Xa) =\n                         ipurge_ref_aux I D U xs X\n 2. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "hence \"?A = ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs')\n    (ipurge_ref I D (D x) xs' X')\"\n   (is \"_ = ?B\")"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs') X' =\n    ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs')\n     (ipurge_ref I D (D x) xs' X')", "by (rule ipurge_ref_aux_less_cons_1)"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs') X' =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs')\n   (ipurge_ref I D (D x) xs' X')\n\ngoal (2 subgoals):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<exists>u\\<in>U. (u, D x) \\<in> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xsa)\n                          (ipurge_ref I D (D x) xsa Xa) =\n                         ipurge_ref_aux I D U xs X\n 2. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_ref_aux_less I D U (x # xs') X' = ipurge_ref_aux I D U xs X\n  ipurge_ref_aux_less I D U (x # xs') X' =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs')\n   (ipurge_ref I D (D x) xs' X')", "show \"?B = ?C\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux_less I D U (x # xs') X' = ipurge_ref_aux I D U xs X\n  ipurge_ref_aux_less I D U (x # xs') X' =\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs')\n   (ipurge_ref I D (D x) xs' X')\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs')\n     (ipurge_ref I D (D x) xs' X') =\n    ipurge_ref_aux I D U xs X", "by simp"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (ipurge_tr I D (D x) xs')\n   (ipurge_ref I D (D x) xs' X') =\n  ipurge_ref_aux I D U xs X\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "fix x xs' X'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "assume \"ipurge_ref_aux_less I D U (x # xs') X' = ipurge_ref_aux I D U xs X\"\n   (is \"?A = ?C\")"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs') X' = ipurge_ref_aux I D U xs X\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "moreover"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs') X' = ipurge_ref_aux I D U xs X\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "assume \"\\<forall>u \\<in> U. (u, D x) \\<notin> I\""], ["proof (state)\nthis:\n  \\<forall>u\\<in>U. (u, D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "hence \"\\<not> (\\<exists>u \\<in> U. (u, D x) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>U. (u, D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)", "by simp"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "hence \"?A = ipurge_ref_aux_less I D U xs' X'\"\n   (is \"_ = ?B\")"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U (x # xs') X' =\n    ipurge_ref_aux_less I D U xs' X'", "by (rule ipurge_ref_aux_less_cons_2)"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U (x # xs') X' = ipurge_ref_aux_less I D U xs' X'\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa Xa.\n       \\<lbrakk>if ListOp Y = None\n                then List (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     xs \\<and>\n                     Set (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>) =\n                     X\n                else ipurge_ref_aux_less I D U\n                      (List\n                        (Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>))\n                      (Set (Y\\<lparr>Pol := I, Map := D,\n                                Doms := U\\<rparr>)) =\n                     ipurge_ref_aux I D U xs X;\n        ipurge_ref_aux_less I D U (x # xsa) Xa = ipurge_ref_aux I D U xs X;\n        \\<forall>u\\<in>U. (u, D x) \\<notin> I; Ia = I\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux_less I D U xsa Xa =\n                         ipurge_ref_aux I D U xs X", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_ref_aux_less I D U (x # xs') X' = ipurge_ref_aux I D U xs X\n  ipurge_ref_aux_less I D U (x # xs') X' = ipurge_ref_aux_less I D U xs' X'", "show \"?B = ?C\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux_less I D U (x # xs') X' = ipurge_ref_aux I D U xs X\n  ipurge_ref_aux_less I D U (x # xs') X' = ipurge_ref_aux_less I D U xs' X'\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux_less I D U xs' X' = ipurge_ref_aux I D U xs X", "by simp"], ["proof (state)\nthis:\n  ipurge_ref_aux_less I D U xs' X' = ipurge_ref_aux I D U xs X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_fail_aux_t_invariance_3:\n \"\\<lbrakk>Z \\<in> ipurge_fail_aux_t_set (Y\\<lparr>Pol := I, Map := D\\<rparr>);\n    ipurge_fail_aux_t_inv_3 P I D xs X (Y\\<lparr>Pol := I, Map := D\\<rparr>)\\<rbrakk> \\<Longrightarrow>\n  ipurge_fail_aux_t_inv_3 P I D xs X Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Z \\<in> ipurge_fail_aux_t_set\n                      (Y\\<lparr>Pol := I, Map := D\\<rparr>);\n     ipurge_fail_aux_t_inv_3 P I D xs X\n      (Y\\<lparr>Pol := I, Map := D\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> ipurge_fail_aux_t_inv_3 P I D xs X Z", "proof (erule ipurge_fail_aux_t_set.induct, assumption,\n drule_tac [!] ipurge_fail_aux_t_invariance_aux,\n simp_all add: ipurge_fail_aux_t_inv_3_def, (rule_tac [!] impI)+)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ia xsa Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (xsa, Xa) \\<in> failures P;\n        Ia = I; secure P I D; (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xsa, ipurge_ref_aux I D (Doms Y) [] Xa)\n                         \\<in> failures P\n 2. \\<And>Ia x xsa ys Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (ys @ x # xsa, Xa) \\<in> failures P;\n        \\<exists>u\\<in>Doms Y. (u, D x) \\<in> I; Ia = I; secure P I D;\n        (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (ys @ ipurge_tr I D (D x) xsa,\n                          ipurge_ref I D (D x) xsa Xa)\n                         \\<in> failures P", "fix xs' X'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ia xsa Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (xsa, Xa) \\<in> failures P;\n        Ia = I; secure P I D; (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xsa, ipurge_ref_aux I D (Doms Y) [] Xa)\n                         \\<in> failures P\n 2. \\<And>Ia x xsa ys Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (ys @ x # xsa, Xa) \\<in> failures P;\n        \\<exists>u\\<in>Doms Y. (u, D x) \\<in> I; Ia = I; secure P I D;\n        (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (ys @ ipurge_tr I D (D x) xsa,\n                          ipurge_ref I D (D x) xsa Xa)\n                         \\<in> failures P", "assume\n   \"secure P I D\" and\n   \"(xs, X) \\<in> failures P\" and\n   \"secure P I D \\<longrightarrow> (xs, X) \\<in> failures P \\<longrightarrow> (xs', X') \\<in> failures P\""], ["proof (state)\nthis:\n  secure P I D\n  (xs, X) \\<in> failures P\n  secure P I D \\<longrightarrow>\n  (xs, X) \\<in> failures P \\<longrightarrow> (xs', X') \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<And>Ia xsa Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (xsa, Xa) \\<in> failures P;\n        Ia = I; secure P I D; (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xsa, ipurge_ref_aux I D (Doms Y) [] Xa)\n                         \\<in> failures P\n 2. \\<And>Ia x xsa ys Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (ys @ x # xsa, Xa) \\<in> failures P;\n        \\<exists>u\\<in>Doms Y. (u, D x) \\<in> I; Ia = I; secure P I D;\n        (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (ys @ ipurge_tr I D (D x) xsa,\n                          ipurge_ref I D (D x) xsa Xa)\n                         \\<in> failures P", "hence \"(xs', X') \\<in> failures P\""], ["proof (prove)\nusing this:\n  secure P I D\n  (xs, X) \\<in> failures P\n  secure P I D \\<longrightarrow>\n  (xs, X) \\<in> failures P \\<longrightarrow> (xs', X') \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs', X') \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (xs', X') \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<And>Ia xsa Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (xsa, Xa) \\<in> failures P;\n        Ia = I; secure P I D; (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xsa, ipurge_ref_aux I D (Doms Y) [] Xa)\n                         \\<in> failures P\n 2. \\<And>Ia x xsa ys Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (ys @ x # xsa, Xa) \\<in> failures P;\n        \\<exists>u\\<in>Doms Y. (u, D x) \\<in> I; Ia = I; secure P I D;\n        (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (ys @ ipurge_tr I D (D x) xsa,\n                          ipurge_ref I D (D x) xsa Xa)\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (xs', X') \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<And>Ia xsa Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (xsa, Xa) \\<in> failures P;\n        Ia = I; secure P I D; (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xsa, ipurge_ref_aux I D (Doms Y) [] Xa)\n                         \\<in> failures P\n 2. \\<And>Ia x xsa ys Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (ys @ x # xsa, Xa) \\<in> failures P;\n        \\<exists>u\\<in>Doms Y. (u, D x) \\<in> I; Ia = I; secure P I D;\n        (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (ys @ ipurge_tr I D (D x) xsa,\n                          ipurge_ref I D (D x) xsa Xa)\n                         \\<in> failures P", "have \"ipurge_ref_aux I D (Doms Y) [] X' \\<subseteq> X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (Doms Y) [] X' \\<subseteq> X'", "by (rule ipurge_ref_aux_subset)"], ["proof (state)\nthis:\n  ipurge_ref_aux I D (Doms Y) [] X' \\<subseteq> X'\n\ngoal (2 subgoals):\n 1. \\<And>Ia xsa Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (xsa, Xa) \\<in> failures P;\n        Ia = I; secure P I D; (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xsa, ipurge_ref_aux I D (Doms Y) [] Xa)\n                         \\<in> failures P\n 2. \\<And>Ia x xsa ys Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (ys @ x # xsa, Xa) \\<in> failures P;\n        \\<exists>u\\<in>Doms Y. (u, D x) \\<in> I; Ia = I; secure P I D;\n        (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (ys @ ipurge_tr I D (D x) xsa,\n                          ipurge_ref I D (D x) xsa Xa)\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (xs', X') \\<in> failures P\n  ipurge_ref_aux I D (Doms Y) [] X' \\<subseteq> X'", "show \"(xs', ipurge_ref_aux I D (Doms Y) [] X') \\<in> failures P\""], ["proof (prove)\nusing this:\n  (xs', X') \\<in> failures P\n  ipurge_ref_aux I D (Doms Y) [] X' \\<subseteq> X'\n\ngoal (1 subgoal):\n 1. (xs', ipurge_ref_aux I D (Doms Y) [] X') \\<in> failures P", "by (rule process_rule_3)"], ["proof (state)\nthis:\n  (xs', ipurge_ref_aux I D (Doms Y) [] X') \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (ys @ x # xsa, Xa) \\<in> failures P;\n        \\<exists>u\\<in>Doms Y. (u, D x) \\<in> I; Ia = I; secure P I D;\n        (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (ys @ ipurge_tr I D (D x) xsa,\n                          ipurge_ref I D (D x) xsa Xa)\n                         \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (ys @ x # xsa, Xa) \\<in> failures P;\n        \\<exists>u\\<in>Doms Y. (u, D x) \\<in> I; Ia = I; secure P I D;\n        (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (ys @ ipurge_tr I D (D x) xsa,\n                          ipurge_ref I D (D x) xsa Xa)\n                         \\<in> failures P", "fix x xs' ys X'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (ys @ x # xsa, Xa) \\<in> failures P;\n        \\<exists>u\\<in>Doms Y. (u, D x) \\<in> I; Ia = I; secure P I D;\n        (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (ys @ ipurge_tr I D (D x) xsa,\n                          ipurge_ref I D (D x) xsa Xa)\n                         \\<in> failures P", "assume S: \"secure P I D\" and\n   \"(xs, X) \\<in> failures P\" and\n   \"secure P I D \\<longrightarrow> (xs, X) \\<in> failures P \\<longrightarrow> (ys @ x # xs', X') \\<in> failures P\""], ["proof (state)\nthis:\n  secure P I D\n  (xs, X) \\<in> failures P\n  secure P I D \\<longrightarrow>\n  (xs, X) \\<in> failures P \\<longrightarrow>\n  (ys @ x # xs', X') \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (ys @ x # xsa, Xa) \\<in> failures P;\n        \\<exists>u\\<in>Doms Y. (u, D x) \\<in> I; Ia = I; secure P I D;\n        (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (ys @ ipurge_tr I D (D x) xsa,\n                          ipurge_ref I D (D x) xsa Xa)\n                         \\<in> failures P", "hence \"(ys @ x # xs', X') \\<in> failures P\""], ["proof (prove)\nusing this:\n  secure P I D\n  (xs, X) \\<in> failures P\n  secure P I D \\<longrightarrow>\n  (xs, X) \\<in> failures P \\<longrightarrow>\n  (ys @ x # xs', X') \\<in> failures P\n\ngoal (1 subgoal):\n 1. (ys @ x # xs', X') \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (ys @ x # xs', X') \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (ys @ x # xsa, Xa) \\<in> failures P;\n        \\<exists>u\\<in>Doms Y. (u, D x) \\<in> I; Ia = I; secure P I D;\n        (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (ys @ ipurge_tr I D (D x) xsa,\n                          ipurge_ref I D (D x) xsa Xa)\n                         \\<in> failures P", "hence \"(x # xs', X') \\<in> futures P ys\""], ["proof (prove)\nusing this:\n  (ys @ x # xs', X') \\<in> failures P\n\ngoal (1 subgoal):\n 1. (x # xs', X') \\<in> futures P ys", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (x # xs', X') \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (ys @ x # xsa, Xa) \\<in> failures P;\n        \\<exists>u\\<in>Doms Y. (u, D x) \\<in> I; Ia = I; secure P I D;\n        (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (ys @ ipurge_tr I D (D x) xsa,\n                          ipurge_ref I D (D x) xsa Xa)\n                         \\<in> failures P", "hence \"(ipurge_tr I D (D x) xs', ipurge_ref I D (D x) xs' X') \\<in> futures P ys\""], ["proof (prove)\nusing this:\n  (x # xs', X') \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. (ipurge_tr I D (D x) xs', ipurge_ref I D (D x) xs' X')\n    \\<in> futures P ys", "using S"], ["proof (prove)\nusing this:\n  (x # xs', X') \\<in> futures P ys\n  secure P I D\n\ngoal (1 subgoal):\n 1. (ipurge_tr I D (D x) xs', ipurge_ref I D (D x) xs' X')\n    \\<in> futures P ys", "by (simp add: secure_def)"], ["proof (state)\nthis:\n  (ipurge_tr I D (D x) xs', ipurge_ref I D (D x) xs' X') \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xsa ys Xa.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                (xs, X) \\<in> failures P \\<longrightarrow>\n                ((case ListOp Y of None \\<Rightarrow> []\n                  | Some ys \\<Rightarrow> ys) @\n                 List Y,\n                 Set Y)\n                \\<in> failures P;\n        secure P I D \\<longrightarrow>\n        (xs, X) \\<in> failures P \\<longrightarrow>\n        (ys @ x # xsa, Xa) \\<in> failures P;\n        \\<exists>u\\<in>Doms Y. (u, D x) \\<in> I; Ia = I; secure P I D;\n        (xs, X) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (ys @ ipurge_tr I D (D x) xsa,\n                          ipurge_ref I D (D x) xsa Xa)\n                         \\<in> failures P", "thus \"(ys @ ipurge_tr I D (D x) xs', ipurge_ref I D (D x) xs' X') \\<in> failures P\""], ["proof (prove)\nusing this:\n  (ipurge_tr I D (D x) xs', ipurge_ref I D (D x) xs' X') \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. (ys @ ipurge_tr I D (D x) xs', ipurge_ref I D (D x) xs' X')\n    \\<in> failures P", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (ys @ ipurge_tr I D (D x) xs', ipurge_ref I D (D x) xs' X')\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Step 10\""], ["", "text \\<open>\nHere below are the proofs of lemmas \\<open>ipurge_fail_aux_t_eq_tr\\<close>,\n\\<open>ipurge_fail_aux_t_eq_ref\\<close>, and \\<open>ipurge_fail_aux_t_failures\\<close>, which are then applied to\ndemonstrate the target closure lemma.\n\n\\null\n\\<close>"], ["", "lemma ipurge_fail_aux_t_eq_tr:\n \"fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs", "let ?Y = \"\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n    Set = X\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs", "have \"ipurge_fail_aux_t_aux ?Y\n    \\<in> ipurge_fail_aux_t_set (?Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n               Set = X\\<rparr>\n            \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)", "by (simp add: ipurge_fail_aux_t_aux_set del: ipurge_fail_aux_t_aux.simps)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>\n          \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\n\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs", "moreover"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>\n          \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\n\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs", "have\n   \"ipurge_fail_aux_t_inv_1 I D U xs (?Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_inv_1 I D U xs\n     (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n         Set = X\\<rparr>\n      \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)", "by (simp add: ipurge_fail_aux_t_input_1)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_inv_1 I D U xs\n   (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr>\n    \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\n\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>\n          \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\n  ipurge_fail_aux_t_inv_1 I D U xs\n   (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr>\n    \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)", "have \"ipurge_fail_aux_t_inv_1 I D U xs (ipurge_fail_aux_t_aux ?Y)\""], ["proof (prove)\nusing this:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>\n          \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\n  ipurge_fail_aux_t_inv_1 I D U xs\n   (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr>\n    \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\n\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_inv_1 I D U xs\n     (ipurge_fail_aux_t_aux\n       \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n          Set = X\\<rparr>)", "by (rule ipurge_fail_aux_t_invariance_1)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_inv_1 I D U xs\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs", "moreover"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_inv_1 I D U xs\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs", "have \"ipurge_fail_aux_t_form (ipurge_fail_aux_t_aux ?Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_form\n     (ipurge_fail_aux_t_aux\n       \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n          Set = X\\<rparr>)", "by (rule ipurge_fail_aux_t_form_aux)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_form\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_fail_aux_t_inv_1 I D U xs\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n  ipurge_fail_aux_t_form\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)", "have \"fst (ipurge_fail_aux_t_out (ipurge_fail_aux_t_aux ?Y)) =\n    ipurge_tr_aux I D U xs\""], ["proof (prove)\nusing this:\n  ipurge_fail_aux_t_inv_1 I D U xs\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n  ipurge_fail_aux_t_form\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t_out\n          (ipurge_fail_aux_t_aux\n            \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n               Set = X\\<rparr>)) =\n    ipurge_tr_aux I D U xs", "by (rule ipurge_fail_aux_t_intro_1)"], ["proof (state)\nthis:\n  fst (ipurge_fail_aux_t_out\n        (ipurge_fail_aux_t_aux\n          \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>)) =\n  ipurge_tr_aux I D U xs\n\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs", "moreover"], ["proof (state)\nthis:\n  fst (ipurge_fail_aux_t_out\n        (ipurge_fail_aux_t_aux\n          \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>)) =\n  ipurge_tr_aux I D U xs\n\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs", "have \"?Y = ipurge_fail_aux_t_in I D U xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr> =\n    ipurge_fail_aux_t_in I D U xs X", "by (simp add: ipurge_fail_aux_t_in_def)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr> =\n  ipurge_fail_aux_t_in I D U xs X\n\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs", "ultimately"], ["proof (chain)\npicking this:\n  fst (ipurge_fail_aux_t_out\n        (ipurge_fail_aux_t_aux\n          \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>)) =\n  ipurge_tr_aux I D U xs\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr> =\n  ipurge_fail_aux_t_in I D U xs X", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (ipurge_fail_aux_t_out\n        (ipurge_fail_aux_t_aux\n          \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>)) =\n  ipurge_tr_aux I D U xs\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr> =\n  ipurge_fail_aux_t_in I D U xs X\n\ngoal (1 subgoal):\n 1. fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs", "by (simp add: ipurge_fail_aux_t_def)"], ["proof (state)\nthis:\n  fst (ipurge_fail_aux_t I D U xs X) = ipurge_tr_aux I D U xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_fail_aux_t_eq_ref:\n \"snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X", "let ?Y = \"\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n    Set = X\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X", "have \"ipurge_fail_aux_t_aux ?Y\n    \\<in> ipurge_fail_aux_t_set (?Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n               Set = X\\<rparr>\n            \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)", "by (simp add: ipurge_fail_aux_t_aux_set del: ipurge_fail_aux_t_aux.simps)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>\n          \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\n\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X", "moreover"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>\n          \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\n\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X", "have\n   \"ipurge_fail_aux_t_inv_2 I D U xs X (?Y\\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_inv_2 I D U xs X\n     (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n         Set = X\\<rparr>\n      \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)", "by (simp add: ipurge_fail_aux_t_input_2)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_inv_2 I D U xs X\n   (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr>\n    \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\n\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>\n          \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\n  ipurge_fail_aux_t_inv_2 I D U xs X\n   (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr>\n    \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)", "have \"ipurge_fail_aux_t_inv_2 I D U xs X (ipurge_fail_aux_t_aux ?Y)\""], ["proof (prove)\nusing this:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>\n          \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\n  ipurge_fail_aux_t_inv_2 I D U xs X\n   (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr>\n    \\<lparr>Pol := I, Map := D, Doms := U\\<rparr>)\n\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_inv_2 I D U xs X\n     (ipurge_fail_aux_t_aux\n       \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n          Set = X\\<rparr>)", "by (rule ipurge_fail_aux_t_invariance_2)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_inv_2 I D U xs X\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X", "moreover"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_inv_2 I D U xs X\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X", "have \"ipurge_fail_aux_t_form (ipurge_fail_aux_t_aux ?Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_form\n     (ipurge_fail_aux_t_aux\n       \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n          Set = X\\<rparr>)", "by (rule ipurge_fail_aux_t_form_aux)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_form\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_fail_aux_t_inv_2 I D U xs X\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n  ipurge_fail_aux_t_form\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)", "have \"snd (ipurge_fail_aux_t_out (ipurge_fail_aux_t_aux ?Y)) =\n    ipurge_ref_aux I D U xs X\""], ["proof (prove)\nusing this:\n  ipurge_fail_aux_t_inv_2 I D U xs X\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n  ipurge_fail_aux_t_form\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t_out\n          (ipurge_fail_aux_t_aux\n            \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n               Set = X\\<rparr>)) =\n    ipurge_ref_aux I D U xs X", "by (rule ipurge_fail_aux_t_intro_2)"], ["proof (state)\nthis:\n  snd (ipurge_fail_aux_t_out\n        (ipurge_fail_aux_t_aux\n          \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>)) =\n  ipurge_ref_aux I D U xs X\n\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X", "moreover"], ["proof (state)\nthis:\n  snd (ipurge_fail_aux_t_out\n        (ipurge_fail_aux_t_aux\n          \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>)) =\n  ipurge_ref_aux I D U xs X\n\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X", "have \"?Y = ipurge_fail_aux_t_in I D U xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr> =\n    ipurge_fail_aux_t_in I D U xs X", "by (simp add: ipurge_fail_aux_t_in_def)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr> =\n  ipurge_fail_aux_t_in I D U xs X\n\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X", "ultimately"], ["proof (chain)\npicking this:\n  snd (ipurge_fail_aux_t_out\n        (ipurge_fail_aux_t_aux\n          \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>)) =\n  ipurge_ref_aux I D U xs X\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr> =\n  ipurge_fail_aux_t_in I D U xs X", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (ipurge_fail_aux_t_out\n        (ipurge_fail_aux_t_aux\n          \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>)) =\n  ipurge_ref_aux I D U xs X\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr> =\n  ipurge_fail_aux_t_in I D U xs X\n\ngoal (1 subgoal):\n 1. snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X", "by (simp add: ipurge_fail_aux_t_def)"], ["proof (state)\nthis:\n  snd (ipurge_fail_aux_t I D U xs X) = ipurge_ref_aux I D U xs X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_fail_aux_t_failures [rule_format]:\n \"secure P I D \\<longrightarrow> (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P", "let ?Y = \"\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n    Set = X\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P", "have \"ipurge_fail_aux_t_aux ?Y\n    \\<in> ipurge_fail_aux_t_set (?Y\\<lparr>Pol := I, Map := D\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>\n    \\<in> ipurge_fail_aux_t_set\n           (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n               Set = X\\<rparr>\n            \\<lparr>Pol := I, Map := D\\<rparr>)", "by (simp add: ipurge_fail_aux_t_aux_set del: ipurge_fail_aux_t_aux.simps)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>\n          \\<lparr>Pol := I, Map := D\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>\n          \\<lparr>Pol := I, Map := D\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P", "have\n   \"ipurge_fail_aux_t_inv_3 P I D xs X (?Y\\<lparr>Pol := I, Map := D\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_inv_3 P I D xs X\n     (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n         Set = X\\<rparr>\n      \\<lparr>Pol := I, Map := D\\<rparr>)", "by (simp add: ipurge_fail_aux_t_input_3)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_inv_3 P I D xs X\n   (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr>\n    \\<lparr>Pol := I, Map := D\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>\n          \\<lparr>Pol := I, Map := D\\<rparr>)\n  ipurge_fail_aux_t_inv_3 P I D xs X\n   (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr>\n    \\<lparr>Pol := I, Map := D\\<rparr>)", "have \"ipurge_fail_aux_t_inv_3 P I D xs X (ipurge_fail_aux_t_aux ?Y)\""], ["proof (prove)\nusing this:\n  ipurge_fail_aux_t_aux\n   \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n      Set = X\\<rparr>\n  \\<in> ipurge_fail_aux_t_set\n         (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n             Set = X\\<rparr>\n          \\<lparr>Pol := I, Map := D\\<rparr>)\n  ipurge_fail_aux_t_inv_3 P I D xs X\n   (\\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr>\n    \\<lparr>Pol := I, Map := D\\<rparr>)\n\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_inv_3 P I D xs X\n     (ipurge_fail_aux_t_aux\n       \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n          Set = X\\<rparr>)", "by (rule ipurge_fail_aux_t_invariance_3)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_inv_3 P I D xs X\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_inv_3 P I D xs X\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P", "have \"ipurge_fail_aux_t_form (ipurge_fail_aux_t_aux ?Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_fail_aux_t_form\n     (ipurge_fail_aux_t_aux\n       \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n          Set = X\\<rparr>)", "by (rule ipurge_fail_aux_t_form_aux)"], ["proof (state)\nthis:\n  ipurge_fail_aux_t_form\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_fail_aux_t_inv_3 P I D xs X\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n  ipurge_fail_aux_t_form\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)", "have \"secure P I D \\<longrightarrow> (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t_out (ipurge_fail_aux_t_aux ?Y) \\<in> failures P\""], ["proof (prove)\nusing this:\n  ipurge_fail_aux_t_inv_3 P I D xs X\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n  ipurge_fail_aux_t_form\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t_out\n     (ipurge_fail_aux_t_aux\n       \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n          Set = X\\<rparr>)\n    \\<in> failures P", "by (rule ipurge_fail_aux_t_intro_3)"], ["proof (state)\nthis:\n  secure P I D \\<longrightarrow>\n  (xs, X) \\<in> failures P \\<longrightarrow>\n  ipurge_fail_aux_t_out\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  secure P I D \\<longrightarrow>\n  (xs, X) \\<in> failures P \\<longrightarrow>\n  ipurge_fail_aux_t_out\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P", "have \"?Y = ipurge_fail_aux_t_in I D U xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n       Set = X\\<rparr> =\n    ipurge_fail_aux_t_in I D U xs X", "by (simp add: ipurge_fail_aux_t_in_def)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr> =\n  ipurge_fail_aux_t_in I D U xs X\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  secure P I D \\<longrightarrow>\n  (xs, X) \\<in> failures P \\<longrightarrow>\n  ipurge_fail_aux_t_out\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n  \\<in> failures P\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr> =\n  ipurge_fail_aux_t_in I D U xs X", "show ?thesis"], ["proof (prove)\nusing this:\n  secure P I D \\<longrightarrow>\n  (xs, X) \\<in> failures P \\<longrightarrow>\n  ipurge_fail_aux_t_out\n   (ipurge_fail_aux_t_aux\n     \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n        Set = X\\<rparr>)\n  \\<in> failures P\n  \\<lparr>Pol = I, Map = D, Doms = U, List = xs, ListOp = None,\n     Set = X\\<rparr> =\n  ipurge_fail_aux_t_in I D U xs X\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    (xs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_fail_aux_t I D U xs X \\<in> failures P", "by (simp add: ipurge_fail_aux_t_def)"], ["proof (state)\nthis:\n  secure P I D \\<longrightarrow>\n  (xs, X) \\<in> failures P \\<longrightarrow>\n  ipurge_fail_aux_t I D U xs X \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_ref_aux_failures:\n \"\\<lbrakk>secure P I D; (xs, X) \\<in> failures P\\<rbrakk> \\<Longrightarrow>\n    (ipurge_tr_aux I D U xs, ipurge_ref_aux I D U xs X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure P I D; (xs, X) \\<in> failures P\\<rbrakk>\n    \\<Longrightarrow> (ipurge_tr_aux I D U xs, ipurge_ref_aux I D U xs X)\n                      \\<in> failures P", "proof (drule ipurge_fail_aux_t_failures [where U = U], assumption,\n cases \"ipurge_fail_aux_t I D U xs X\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(xs, X) \\<in> failures P;\n        ipurge_fail_aux_t I D U xs X \\<in> failures P;\n        ipurge_fail_aux_t I D U xs X = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_aux I D U xs, ipurge_ref_aux I D U xs X)\n                         \\<in> failures P", "qed (simp add: ipurge_fail_aux_t_eq_tr [where X = X, symmetric]\n ipurge_fail_aux_t_eq_ref [symmetric])"], ["", "subsection \"Additional propaedeutic lemmas\""], ["", "text \\<open>\nIn what follows, additional lemmas required for the demonstration of the target security\nconservation theorem are proven.\n\nHere below is the proof of some properties of functions @{term ipurge_tr_aux} and\n@{term ipurge_ref_aux}. Particularly, it is shown that in case an event list and its intransitive\npurge for some set of domains are both traces of a secure process, and the purged list has a future\nnot affected by any purged event, then that future is also a future for the full event list.\n\n\\null\n\\<close>"], ["", "lemma ipurge_tr_aux_idem:\n \"ipurge_tr_aux I D U (ipurge_tr_aux I D U xs) = ipurge_tr_aux I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (ipurge_tr_aux I D U xs) = ipurge_tr_aux I D U xs", "by (simp add: ipurge_tr_aux_union [symmetric])"], ["", "lemma ipurge_tr_aux_set:\n \"set (ipurge_tr_aux I D U xs) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ipurge_tr_aux I D U xs) \\<subseteq> set xs", "proof (induction xs rule: rev_induct, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set (ipurge_tr_aux I D U xs) \\<subseteq> set xs \\<Longrightarrow>\n       ((\\<exists>v\\<in>sinks_aux I D U xs.\n            (v, D x) \\<in> I) \\<longrightarrow>\n        set (ipurge_tr_aux I D U xs) \\<subseteq> insert x (set xs)) \\<and>\n       ((\\<forall>v\\<in>sinks_aux I D U xs.\n            (v, D x) \\<notin> I) \\<longrightarrow>\n        set (ipurge_tr_aux I D U xs) \\<subseteq> insert x (set xs))", "qed blast"], ["", "lemma ipurge_tr_aux_nil [rule_format]:\n  assumes A: \"u \\<in> U\"\n  shows \"(\\<forall>x \\<in> set xs. (u, D x) \\<in> I) \\<longrightarrow> ipurge_tr_aux I D U xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set xs. (u, D x) \\<in> I) \\<longrightarrow>\n    ipurge_tr_aux I D U xs = []", "proof (induction xs rule: rev_induct, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>x\\<in>set xs. (u, D x) \\<in> I) \\<longrightarrow>\n                ipurge_tr_aux I D U xs = [];\n        \\<forall>x\\<in>set (xs @ [x]). (u, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D U (xs @ [x]) = []", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>x\\<in>set xs. (u, D x) \\<in> I) \\<longrightarrow>\n                ipurge_tr_aux I D U xs = [];\n        \\<forall>x\\<in>set (xs @ [x]). (u, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D U (xs @ [x]) = []", "assume \"(\\<forall>x' \\<in> set xs. (u, D x') \\<in> I) \\<longrightarrow> ipurge_tr_aux I D U xs = []\""], ["proof (state)\nthis:\n  (\\<forall>x'\\<in>set xs. (u, D x') \\<in> I) \\<longrightarrow>\n  ipurge_tr_aux I D U xs = []\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>x\\<in>set xs. (u, D x) \\<in> I) \\<longrightarrow>\n                ipurge_tr_aux I D U xs = [];\n        \\<forall>x\\<in>set (xs @ [x]). (u, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D U (xs @ [x]) = []", "moreover"], ["proof (state)\nthis:\n  (\\<forall>x'\\<in>set xs. (u, D x') \\<in> I) \\<longrightarrow>\n  ipurge_tr_aux I D U xs = []\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>x\\<in>set xs. (u, D x) \\<in> I) \\<longrightarrow>\n                ipurge_tr_aux I D U xs = [];\n        \\<forall>x\\<in>set (xs @ [x]). (u, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D U (xs @ [x]) = []", "assume B: \"\\<forall>x' \\<in> set (xs @ [x]). (u, D x') \\<in> I\""], ["proof (state)\nthis:\n  \\<forall>x'\\<in>set (xs @ [x]). (u, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>x\\<in>set xs. (u, D x) \\<in> I) \\<longrightarrow>\n                ipurge_tr_aux I D U xs = [];\n        \\<forall>x\\<in>set (xs @ [x]). (u, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D U (xs @ [x]) = []", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>x'\\<in>set xs. (u, D x') \\<in> I) \\<longrightarrow>\n  ipurge_tr_aux I D U xs = []\n  \\<forall>x'\\<in>set (xs @ [x]). (u, D x') \\<in> I", "have C: \"ipurge_tr_aux I D U xs = []\""], ["proof (prove)\nusing this:\n  (\\<forall>x'\\<in>set xs. (u, D x') \\<in> I) \\<longrightarrow>\n  ipurge_tr_aux I D U xs = []\n  \\<forall>x'\\<in>set (xs @ [x]). (u, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U xs = []", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D U xs = []\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>x\\<in>set xs. (u, D x) \\<in> I) \\<longrightarrow>\n                ipurge_tr_aux I D U xs = [];\n        \\<forall>x\\<in>set (xs @ [x]). (u, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D U (xs @ [x]) = []", "have \"(u, D x) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I", "using B"], ["proof (prove)\nusing this:\n  \\<forall>x'\\<in>set (xs @ [x]). (u, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I", "by simp"], ["proof (state)\nthis:\n  (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>x\\<in>set xs. (u, D x) \\<in> I) \\<longrightarrow>\n                ipurge_tr_aux I D U xs = [];\n        \\<forall>x\\<in>set (xs @ [x]). (u, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D U (xs @ [x]) = []", "moreover"], ["proof (state)\nthis:\n  (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>x\\<in>set xs. (u, D x) \\<in> I) \\<longrightarrow>\n                ipurge_tr_aux I D U xs = [];\n        \\<forall>x\\<in>set (xs @ [x]). (u, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D U (xs @ [x]) = []", "have \"U \\<subseteq> sinks_aux I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> sinks_aux I D U xs", "by (rule sinks_aux_subset)"], ["proof (state)\nthis:\n  U \\<subseteq> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>x\\<in>set xs. (u, D x) \\<in> I) \\<longrightarrow>\n                ipurge_tr_aux I D U xs = [];\n        \\<forall>x\\<in>set (xs @ [x]). (u, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D U (xs @ [x]) = []", "hence \"u \\<in> sinks_aux I D U xs\""], ["proof (prove)\nusing this:\n  U \\<subseteq> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U xs", "using A"], ["proof (prove)\nusing this:\n  U \\<subseteq> sinks_aux I D U xs\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U xs", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>x\\<in>set xs. (u, D x) \\<in> I) \\<longrightarrow>\n                ipurge_tr_aux I D U xs = [];\n        \\<forall>x\\<in>set (xs @ [x]). (u, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D U (xs @ [x]) = []", "ultimately"], ["proof (chain)\npicking this:\n  (u, D x) \\<in> I\n  u \\<in> sinks_aux I D U xs", "have \"\\<exists>u \\<in> sinks_aux I D U xs. (u, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I\n  u \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>x\\<in>set xs. (u, D x) \\<in> I) \\<longrightarrow>\n                ipurge_tr_aux I D U xs = [];\n        \\<forall>x\\<in>set (xs @ [x]). (u, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D U (xs @ [x]) = []", "hence \"ipurge_tr_aux I D U (xs @ [x]) = ipurge_tr_aux I D U xs\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (xs @ [x]) = ipurge_tr_aux I D U xs", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D U (xs @ [x]) = ipurge_tr_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>x\\<in>set xs. (u, D x) \\<in> I) \\<longrightarrow>\n                ipurge_tr_aux I D U xs = [];\n        \\<forall>x\\<in>set (xs @ [x]). (u, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D U (xs @ [x]) = []", "thus \"ipurge_tr_aux I D U (xs @ [x]) = []\""], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D U (xs @ [x]) = ipurge_tr_aux I D U xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (xs @ [x]) = []", "using C"], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D U (xs @ [x]) = ipurge_tr_aux I D U xs\n  ipurge_tr_aux I D U xs = []\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (xs @ [x]) = []", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D U (xs @ [x]) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_aux_del_failures [rule_format]:\n  assumes S: \"secure P I D\"\n  shows \"(\\<forall>u \\<in> sinks_aux_less I D U ys. \\<forall>z \\<in> Z \\<union> set zs. (u, D z) \\<notin> I) \\<longrightarrow>\n    (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P \\<longrightarrow>\n    xs @ ys \\<in> traces P \\<longrightarrow>\n    (xs @ ys @ zs, Z) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>sinks_aux_less I D U ys.\n        \\<forall>z\\<in>Z \\<union> set zs.\n           (u, D z) \\<notin> I) \\<longrightarrow>\n    (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P \\<longrightarrow>\n    xs @ ys \\<in> traces P \\<longrightarrow>\n    (xs @ ys @ zs, Z) \\<in> failures P", "proof (induction ys arbitrary: zs rule: rev_induct, simp, (rule impI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa zs.\n       \\<lbrakk>\\<And>zs.\n                   (\\<forall>u\\<in>sinks_aux_less I D U xsa.\n                       \\<forall>z\\<in>Z \\<union> set zs.\n                          (u, D z) \\<notin> I) \\<longrightarrow>\n                   (xs @ ipurge_tr_aux I D U xsa @ zs, Z)\n                   \\<in> failures P \\<longrightarrow>\n                   xs @ xsa \\<in> traces P \\<longrightarrow>\n                   (xs @ xsa @ zs, Z) \\<in> failures P;\n        \\<forall>u\\<in>sinks_aux_less I D U (xsa @ [x]).\n           \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I;\n        (xs @ ipurge_tr_aux I D U (xsa @ [x]) @ zs, Z) \\<in> failures P;\n        xs @ xsa @ [x] \\<in> traces P\\<rbrakk>\n       \\<Longrightarrow> (xs @ (xsa @ [x]) @ zs, Z) \\<in> failures P", "fix y ys zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa zs.\n       \\<lbrakk>\\<And>zs.\n                   (\\<forall>u\\<in>sinks_aux_less I D U xsa.\n                       \\<forall>z\\<in>Z \\<union> set zs.\n                          (u, D z) \\<notin> I) \\<longrightarrow>\n                   (xs @ ipurge_tr_aux I D U xsa @ zs, Z)\n                   \\<in> failures P \\<longrightarrow>\n                   xs @ xsa \\<in> traces P \\<longrightarrow>\n                   (xs @ xsa @ zs, Z) \\<in> failures P;\n        \\<forall>u\\<in>sinks_aux_less I D U (xsa @ [x]).\n           \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I;\n        (xs @ ipurge_tr_aux I D U (xsa @ [x]) @ zs, Z) \\<in> failures P;\n        xs @ xsa @ [x] \\<in> traces P\\<rbrakk>\n       \\<Longrightarrow> (xs @ (xsa @ [x]) @ zs, Z) \\<in> failures P", "assume\n    A: \"\\<And>zs. (\\<forall>u \\<in> sinks_aux_less I D U ys. \\<forall>z \\<in> Z \\<union> set zs. (u, D z) \\<notin> I) \\<longrightarrow>\n      (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P \\<longrightarrow>\n      xs @ ys \\<in> traces P \\<longrightarrow>\n        (xs @ ys @ zs, Z) \\<in> failures P\" and\n    B: \"\\<forall>u \\<in> sinks_aux_less I D U (ys @ [y]). \\<forall>z \\<in> Z \\<union> set zs. (u, D z) \\<notin> I\" and\n    C: \"(xs @ ipurge_tr_aux I D U (ys @ [y]) @ zs, Z) \\<in> failures P\" and\n    D: \"xs @ (ys @ [y]) \\<in> traces P\""], ["proof (state)\nthis:\n  (\\<forall>u\\<in>sinks_aux_less I D U ys.\n      \\<forall>z\\<in>Z \\<union> set ?zs.\n         (u, D z) \\<notin> I) \\<longrightarrow>\n  (xs @ ipurge_tr_aux I D U ys @ ?zs, Z) \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ ?zs, Z) \\<in> failures P\n  \\<forall>u\\<in>sinks_aux_less I D U (ys @ [y]).\n     \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I\n  (xs @ ipurge_tr_aux I D U (ys @ [y]) @ zs, Z) \\<in> failures P\n  xs @ ys @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa zs.\n       \\<lbrakk>\\<And>zs.\n                   (\\<forall>u\\<in>sinks_aux_less I D U xsa.\n                       \\<forall>z\\<in>Z \\<union> set zs.\n                          (u, D z) \\<notin> I) \\<longrightarrow>\n                   (xs @ ipurge_tr_aux I D U xsa @ zs, Z)\n                   \\<in> failures P \\<longrightarrow>\n                   xs @ xsa \\<in> traces P \\<longrightarrow>\n                   (xs @ xsa @ zs, Z) \\<in> failures P;\n        \\<forall>u\\<in>sinks_aux_less I D U (xsa @ [x]).\n           \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I;\n        (xs @ ipurge_tr_aux I D U (xsa @ [x]) @ zs, Z) \\<in> failures P;\n        xs @ xsa @ [x] \\<in> traces P\\<rbrakk>\n       \\<Longrightarrow> (xs @ (xsa @ [x]) @ zs, Z) \\<in> failures P", "show \"(xs @ (ys @ [y]) @ zs, Z) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ (ys @ [y]) @ zs, Z) \\<in> failures P", "proof (cases \"\\<exists>u \\<in> sinks_aux I D U ys. (u, D y) \\<in> I\", simp_all (no_asm))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "case True"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "have\n     \"(\\<forall>u \\<in> sinks_aux_less I D U ys. \\<forall>z \\<in> Z \\<union> set zs. (u, D z) \\<notin> I) \\<longrightarrow>\n      (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P \\<longrightarrow>\n      xs @ ys \\<in> traces P \\<longrightarrow>\n        (xs @ ys @ zs, Z) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>sinks_aux_less I D U ys.\n        \\<forall>z\\<in>Z \\<union> set zs.\n           (u, D z) \\<notin> I) \\<longrightarrow>\n    (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P \\<longrightarrow>\n    xs @ ys \\<in> traces P \\<longrightarrow>\n    (xs @ ys @ zs, Z) \\<in> failures P", "using A"], ["proof (prove)\nusing this:\n  (\\<forall>u\\<in>sinks_aux_less I D U ys.\n      \\<forall>z\\<in>Z \\<union> set ?zs.\n         (u, D z) \\<notin> I) \\<longrightarrow>\n  (xs @ ipurge_tr_aux I D U ys @ ?zs, Z) \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ ?zs, Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>sinks_aux_less I D U ys.\n        \\<forall>z\\<in>Z \\<union> set zs.\n           (u, D z) \\<notin> I) \\<longrightarrow>\n    (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P \\<longrightarrow>\n    xs @ ys \\<in> traces P \\<longrightarrow>\n    (xs @ ys @ zs, Z) \\<in> failures P", "."], ["proof (state)\nthis:\n  (\\<forall>u\\<in>sinks_aux_less I D U ys.\n      \\<forall>z\\<in>Z \\<union> set zs.\n         (u, D z) \\<notin> I) \\<longrightarrow>\n  (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ zs, Z) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (\\<forall>u\\<in>sinks_aux_less I D U ys.\n      \\<forall>z\\<in>Z \\<union> set zs.\n         (u, D z) \\<notin> I) \\<longrightarrow>\n  (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ zs, Z) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "have \"\\<exists>u \\<in> U \\<union> sinks_aux_less I D U ys. (u, D y) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U \\<union> sinks_aux_less I D U ys. (u, D y) \\<in> I", "using True"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U \\<union> sinks_aux_less I D U ys. (u, D y) \\<in> I", "by (simp add: sinks_aux_sinks_aux_less)"], ["proof (state)\nthis:\n  \\<exists>u\\<in>U \\<union> sinks_aux_less I D U ys. (u, D y) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "hence E: \"\\<forall>u \\<in> insert (D y) (sinks_aux_less I D U ys). \\<forall>z \\<in> Z \\<union> set zs.\n      (u, D z) \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U \\<union> sinks_aux_less I D U ys. (u, D y) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>insert (D y) (sinks_aux_less I D U ys).\n       \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I", "using B"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U \\<union> sinks_aux_less I D U ys. (u, D y) \\<in> I\n  \\<forall>u\\<in>sinks_aux_less I D U (ys @ [y]).\n     \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>insert (D y) (sinks_aux_less I D U ys).\n       \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I", "by (simp only: sinks_aux_less.simps if_True)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>insert (D y) (sinks_aux_less I D U ys).\n     \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "hence \"\\<forall>u \\<in> sinks_aux_less I D U ys. \\<forall>z \\<in> Z \\<union> set zs. (u, D z) \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>insert (D y) (sinks_aux_less I D U ys).\n     \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>sinks_aux_less I D U ys.\n       \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I", "by simp"], ["proof (state)\nthis:\n  \\<forall>u\\<in>sinks_aux_less I D U ys.\n     \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  \\<forall>u\\<in>sinks_aux_less I D U ys.\n     \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "have \"(xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P", "using C and True"], ["proof (prove)\nusing this:\n  (xs @ ipurge_tr_aux I D U (ys @ [y]) @ zs, Z) \\<in> failures P\n  \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "have \"(xs @ ys) @ [y] \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ys) @ [y] \\<in> traces P", "using D"], ["proof (prove)\nusing this:\n  xs @ ys @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ ys) @ [y] \\<in> traces P", "by simp"], ["proof (state)\nthis:\n  (xs @ ys) @ [y] \\<in> traces P\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "hence \"xs @ ys \\<in> traces P\""], ["proof (prove)\nusing this:\n  (xs @ ys) @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. xs @ ys \\<in> traces P", "by (rule process_rule_2_traces)"], ["proof (state)\nthis:\n  xs @ ys \\<in> traces P\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>u\\<in>sinks_aux_less I D U ys.\n      \\<forall>z\\<in>Z \\<union> set zs.\n         (u, D z) \\<notin> I) \\<longrightarrow>\n  (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ zs, Z) \\<in> failures P\n  \\<forall>u\\<in>sinks_aux_less I D U ys.\n     \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I\n  (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P\n  xs @ ys \\<in> traces P", "have \"(xs @ ys @ zs, Z) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (\\<forall>u\\<in>sinks_aux_less I D U ys.\n      \\<forall>z\\<in>Z \\<union> set zs.\n         (u, D z) \\<notin> I) \\<longrightarrow>\n  (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ zs, Z) \\<in> failures P\n  \\<forall>u\\<in>sinks_aux_less I D U ys.\n     \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I\n  (xs @ ipurge_tr_aux I D U ys @ zs, Z) \\<in> failures P\n  xs @ ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ ys @ zs, Z) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (xs @ ys @ zs, Z) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "hence \"(zs, Z) \\<in> futures P (xs @ ys)\""], ["proof (prove)\nusing this:\n  (xs @ ys @ zs, Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (zs, Z) \\<in> futures P (xs @ ys)", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (zs, Z) \\<in> futures P (xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (zs, Z) \\<in> futures P (xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "have \"(xs @ ys @ [y], {}) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ys @ [y], {}) \\<in> failures P", "using D"], ["proof (prove)\nusing this:\n  xs @ ys @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ ys @ [y], {}) \\<in> failures P", "by (rule traces_failures)"], ["proof (state)\nthis:\n  (xs @ ys @ [y], {}) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "hence \"([y], {}) \\<in> futures P (xs @ ys)\""], ["proof (prove)\nusing this:\n  (xs @ ys @ [y], {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. ([y], {}) \\<in> futures P (xs @ ys)", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  ([y], {}) \\<in> futures P (xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (zs, Z) \\<in> futures P (xs @ ys)\n  ([y], {}) \\<in> futures P (xs @ ys)", "have \"(y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n      \\<in> futures P (xs @ ys)\""], ["proof (prove)\nusing this:\n  (zs, Z) \\<in> futures P (xs @ ys)\n  ([y], {}) \\<in> futures P (xs @ ys)\n\ngoal (1 subgoal):\n 1. (y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> futures P (xs @ ys)", "using S"], ["proof (prove)\nusing this:\n  (zs, Z) \\<in> futures P (xs @ ys)\n  ([y], {}) \\<in> futures P (xs @ ys)\n  secure P I D\n\ngoal (1 subgoal):\n 1. (y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> futures P (xs @ ys)", "by (simp add: secure_def)"], ["proof (state)\nthis:\n  (y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n  \\<in> futures P (xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n  \\<in> futures P (xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "have \"ipurge_tr I D (D y) zs = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I D (D y) zs = zs", "by (subst ipurge_tr_all, simp add: E)"], ["proof (state)\nthis:\n  ipurge_tr I D (D y) zs = zs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr I D (D y) zs = zs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "have \"ipurge_ref I D (D y) zs Z = Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D (D y) zs Z = Z", "by (rule ipurge_ref_all, simp add: E)"], ["proof (state)\nthis:\n  ipurge_ref I D (D y) zs Z = Z\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n  \\<in> futures P (xs @ ys)\n  ipurge_tr I D (D y) zs = zs\n  ipurge_ref I D (D y) zs Z = Z", "have \"(y # zs, Z) \\<in> futures P (xs @ ys)\""], ["proof (prove)\nusing this:\n  (y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n  \\<in> futures P (xs @ ys)\n  ipurge_tr I D (D y) zs = zs\n  ipurge_ref I D (D y) zs Z = Z\n\ngoal (1 subgoal):\n 1. (y # zs, Z) \\<in> futures P (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  (y # zs, Z) \\<in> futures P (xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "thus \"(xs @ ys @ y # zs, Z) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (y # zs, Z) \\<in> futures P (xs @ ys)\n\ngoal (1 subgoal):\n 1. (xs @ ys @ y # zs, Z) \\<in> failures P", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (xs @ ys @ y # zs, Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "have E:\n     \"(\\<forall>u \\<in> sinks_aux_less I D U ys. \\<forall>z \\<in> Z \\<union> set (y # zs). (u, D z) \\<notin> I) \\<longrightarrow>\n      (xs @ ipurge_tr_aux I D U ys @ (y # zs), Z) \\<in> failures P \\<longrightarrow>\n      xs @ ys \\<in> traces P \\<longrightarrow>\n        (xs @ ys @ (y # zs), Z) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>sinks_aux_less I D U ys.\n        \\<forall>z\\<in>Z \\<union> set (y # zs).\n           (u, D z) \\<notin> I) \\<longrightarrow>\n    (xs @ ipurge_tr_aux I D U ys @ y # zs, Z)\n    \\<in> failures P \\<longrightarrow>\n    xs @ ys \\<in> traces P \\<longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "using A"], ["proof (prove)\nusing this:\n  (\\<forall>u\\<in>sinks_aux_less I D U ys.\n      \\<forall>z\\<in>Z \\<union> set ?zs.\n         (u, D z) \\<notin> I) \\<longrightarrow>\n  (xs @ ipurge_tr_aux I D U ys @ ?zs, Z) \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ ?zs, Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>sinks_aux_less I D U ys.\n        \\<forall>z\\<in>Z \\<union> set (y # zs).\n           (u, D z) \\<notin> I) \\<longrightarrow>\n    (xs @ ipurge_tr_aux I D U ys @ y # zs, Z)\n    \\<in> failures P \\<longrightarrow>\n    xs @ ys \\<in> traces P \\<longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "."], ["proof (state)\nthis:\n  (\\<forall>u\\<in>sinks_aux_less I D U ys.\n      \\<forall>z\\<in>Z \\<union> set (y # zs).\n         (u, D z) \\<notin> I) \\<longrightarrow>\n  (xs @ ipurge_tr_aux I D U ys @ y # zs, Z)\n  \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ y # zs, Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "have F: \"\\<not> (\\<exists>u \\<in> U \\<union> sinks_aux_less I D U ys. (u, D y) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U \\<union> sinks_aux_less I D U ys.\n               (u, D y) \\<in> I)", "using False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U \\<union> sinks_aux_less I D U ys.\n               (u, D y) \\<in> I)", "by (simp add: sinks_aux_sinks_aux_less)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>U \\<union> sinks_aux_less I D U ys.\n             (u, D y) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "hence \"\\<forall>u \\<in> sinks_aux_less I D U ys. \\<forall>z \\<in> Z \\<union> set zs. (u, D z) \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>U \\<union> sinks_aux_less I D U ys.\n             (u, D y) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>sinks_aux_less I D U ys.\n       \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I", "using B"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>U \\<union> sinks_aux_less I D U ys.\n             (u, D y) \\<in> I)\n  \\<forall>u\\<in>sinks_aux_less I D U (ys @ [y]).\n     \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>sinks_aux_less I D U ys.\n       \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I", "by (simp only: sinks_aux_less.simps if_False)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>sinks_aux_less I D U ys.\n     \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  \\<forall>u\\<in>sinks_aux_less I D U ys.\n     \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "have \"\\<forall>u \\<in> sinks_aux_less I D U ys. (u, D y) \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>sinks_aux_less I D U ys. (u, D y) \\<notin> I", "using F"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>U \\<union> sinks_aux_less I D U ys.\n             (u, D y) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>sinks_aux_less I D U ys. (u, D y) \\<notin> I", "by simp"], ["proof (state)\nthis:\n  \\<forall>u\\<in>sinks_aux_less I D U ys. (u, D y) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>sinks_aux_less I D U ys.\n     \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I\n  \\<forall>u\\<in>sinks_aux_less I D U ys. (u, D y) \\<notin> I", "have\n     \"\\<forall>u \\<in> sinks_aux_less I D U ys. \\<forall>z \\<in> Z \\<union> set (y # zs). (u, D z) \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>sinks_aux_less I D U ys.\n     \\<forall>z\\<in>Z \\<union> set zs. (u, D z) \\<notin> I\n  \\<forall>u\\<in>sinks_aux_less I D U ys. (u, D y) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>sinks_aux_less I D U ys.\n       \\<forall>z\\<in>Z \\<union> set (y # zs). (u, D z) \\<notin> I", "by simp"], ["proof (state)\nthis:\n  \\<forall>u\\<in>sinks_aux_less I D U ys.\n     \\<forall>z\\<in>Z \\<union> set (y # zs). (u, D z) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "with E"], ["proof (chain)\npicking this:\n  (\\<forall>u\\<in>sinks_aux_less I D U ys.\n      \\<forall>z\\<in>Z \\<union> set (y # zs).\n         (u, D z) \\<notin> I) \\<longrightarrow>\n  (xs @ ipurge_tr_aux I D U ys @ y # zs, Z)\n  \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ y # zs, Z) \\<in> failures P\n  \\<forall>u\\<in>sinks_aux_less I D U ys.\n     \\<forall>z\\<in>Z \\<union> set (y # zs). (u, D z) \\<notin> I", "have\n     \"(xs @ ipurge_tr_aux I D U ys @ (y # zs), Z) \\<in> failures P \\<longrightarrow>\n      xs @ ys \\<in> traces P \\<longrightarrow>\n        (xs @ ys @ (y # zs), Z) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (\\<forall>u\\<in>sinks_aux_less I D U ys.\n      \\<forall>z\\<in>Z \\<union> set (y # zs).\n         (u, D z) \\<notin> I) \\<longrightarrow>\n  (xs @ ipurge_tr_aux I D U ys @ y # zs, Z)\n  \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ y # zs, Z) \\<in> failures P\n  \\<forall>u\\<in>sinks_aux_less I D U ys.\n     \\<forall>z\\<in>Z \\<union> set (y # zs). (u, D z) \\<notin> I\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr_aux I D U ys @ y # zs, Z)\n    \\<in> failures P \\<longrightarrow>\n    xs @ ys \\<in> traces P \\<longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", ".."], ["proof (state)\nthis:\n  (xs @ ipurge_tr_aux I D U ys @ y # zs, Z)\n  \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ y # zs, Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (xs @ ipurge_tr_aux I D U ys @ y # zs, Z)\n  \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ y # zs, Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "have \"(xs @ ipurge_tr_aux I D U ys @ (y # zs), Z) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr_aux I D U ys @ y # zs, Z) \\<in> failures P", "using C and False"], ["proof (prove)\nusing this:\n  (xs @ ipurge_tr_aux I D U (ys @ [y]) @ zs, Z) \\<in> failures P\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U ys. (u, D y) \\<in> I)\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr_aux I D U ys @ y # zs, Z) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (xs @ ipurge_tr_aux I D U ys @ y # zs, Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (xs @ ipurge_tr_aux I D U ys @ y # zs, Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "have \"(xs @ ys) @ [y] \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ys) @ [y] \\<in> traces P", "using D"], ["proof (prove)\nusing this:\n  xs @ ys @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ ys) @ [y] \\<in> traces P", "by simp"], ["proof (state)\nthis:\n  (xs @ ys) @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "hence \"xs @ ys \\<in> traces P\""], ["proof (prove)\nusing this:\n  (xs @ ys) @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. xs @ ys \\<in> traces P", "by (rule process_rule_2_traces)"], ["proof (state)\nthis:\n  xs @ ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U ys.\n               (u, D y) \\<in> I) \\<Longrightarrow>\n    (xs @ ys @ y # zs, Z) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (xs @ ipurge_tr_aux I D U ys @ y # zs, Z)\n  \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ y # zs, Z) \\<in> failures P\n  (xs @ ipurge_tr_aux I D U ys @ y # zs, Z) \\<in> failures P\n  xs @ ys \\<in> traces P", "show \"(xs @ ys @ (y # zs), Z) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (xs @ ipurge_tr_aux I D U ys @ y # zs, Z)\n  \\<in> failures P \\<longrightarrow>\n  xs @ ys \\<in> traces P \\<longrightarrow>\n  (xs @ ys @ y # zs, Z) \\<in> failures P\n  (xs @ ipurge_tr_aux I D U ys @ y # zs, Z) \\<in> failures P\n  xs @ ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ ys @ y # zs, Z) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (xs @ ys @ y # zs, Z) \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs @ (ys @ [y]) @ zs, Z) \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_ref_aux_append:\n \"ipurge_ref_aux I D U (xs @ ys) X = ipurge_ref_aux I D (sinks_aux I D U xs) ys X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U (xs @ ys) X =\n    ipurge_ref_aux I D (sinks_aux I D U xs) ys X", "by (simp add: ipurge_ref_aux_def sinks_aux_append)"], ["", "lemma ipurge_ref_aux_empty [rule_format]:\n  assumes\n    A: \"u \\<in> sinks_aux I D U xs\" and\n    B: \"\\<forall>x \\<in> X. (u, D x) \\<in> I\"\n  shows \"ipurge_ref_aux I D U xs X = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U xs X = {}", "proof (rule equals0I, simp add: ipurge_ref_aux_def, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> X;\n        \\<forall>v\\<in>sinks_aux I D U xs. (v, D y) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> X;\n        \\<forall>v\\<in>sinks_aux I D U xs. (v, D y) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> X;\n        \\<forall>v\\<in>sinks_aux I D U xs. (v, D y) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "with B"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X. (u, D x) \\<in> I\n  x \\<in> X", "have \"(u, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X. (u, D x) \\<in> I\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I", ".."], ["proof (state)\nthis:\n  (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> X;\n        \\<forall>v\\<in>sinks_aux I D U xs. (v, D y) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> X;\n        \\<forall>v\\<in>sinks_aux I D U xs. (v, D y) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"\\<forall>u \\<in> sinks_aux I D U xs. (u, D x) \\<notin> I\""], ["proof (state)\nthis:\n  \\<forall>u\\<in>sinks_aux I D U xs. (u, D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> X;\n        \\<forall>v\\<in>sinks_aux I D U xs. (v, D y) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(u, D x) \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>sinks_aux I D U xs. (u, D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. (u, D x) \\<notin> I", "using A"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>sinks_aux I D U xs. (u, D x) \\<notin> I\n  u \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. (u, D x) \\<notin> I", ".."], ["proof (state)\nthis:\n  (u, D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> X;\n        \\<forall>v\\<in>sinks_aux I D U xs. (v, D y) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (u, D x) \\<in> I\n  (u, D x) \\<notin> I", "show False"], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I\n  (u, D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nHere below is the proof of some properties of functions @{term sinks}, @{term ipurge_tr}, and\n@{term ipurge_ref}. Particularly, using the previous analogous result on function\n@{term ipurge_tr_aux}, it is shown that in case an event list and its intransitive purge for some\ndomain are both traces of a secure process, and the purged list has a future not affected by any\npurged event, then that future is also a future for the full event list.\n\n\\null\n\\<close>"], ["", "lemma sinks_idem:\n \"sinks I D u (ipurge_tr I D u xs) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks I D u (ipurge_tr I D u xs) = {}", "by (induction xs rule: rev_induct, simp_all)"], ["", "lemma sinks_elem [rule_format]:\n \"v \\<in> sinks I D u xs \\<longrightarrow> (\\<exists>x \\<in> set xs. v = D x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> sinks I D u xs \\<longrightarrow>\n    (\\<exists>x\\<in>set xs. v = D x)", "by (induction xs rule: rev_induct, simp_all)"], ["", "lemma ipurge_tr_append:\n \"ipurge_tr I D u (xs @ ys) =\n  ipurge_tr I D u xs @ ipurge_tr_aux I D (insert u (sinks I D u xs)) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I D u (xs @ ys) =\n    ipurge_tr I D u xs @ ipurge_tr_aux I D (insert u (sinks I D u xs)) ys", "proof (simp add: sinks_aux_single_dom [symmetric]\n ipurge_tr_aux_single_dom [symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D {u} (xs @ ys) =\n    ipurge_tr_aux I D {u} xs @ ipurge_tr_aux I D (sinks_aux I D {u} xs) ys", "qed (simp add: ipurge_tr_aux_append)"], ["", "lemma ipurge_tr_idem:\n \"ipurge_tr I D u (ipurge_tr I D u xs) = ipurge_tr I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I D u (ipurge_tr I D u xs) = ipurge_tr I D u xs", "by (simp add: ipurge_tr_aux_single_dom [symmetric] ipurge_tr_aux_idem)"], ["", "lemma ipurge_tr_set:\n \"set (ipurge_tr I D u xs) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ipurge_tr I D u xs) \\<subseteq> set xs", "by (simp add: ipurge_tr_aux_single_dom [symmetric] ipurge_tr_aux_set)"], ["", "lemma ipurge_tr_del_failures [rule_format]:\n  assumes\n    S: \"secure P I D\" and\n    A: \"\\<forall>v \\<in> sinks I D u ys. \\<forall>z \\<in> Z \\<union> set zs. (v, D z) \\<notin> I\" and\n    B: \"(xs @ ipurge_tr I D u ys @ zs, Z) \\<in> failures P\" and\n    C: \"xs @ ys \\<in> traces P\"\n  shows \"(xs @ ys @ zs, Z) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ys @ zs, Z) \\<in> failures P", "proof (rule ipurge_tr_aux_del_failures [OF S _ _ C, where U = \"{u}\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ua z.\n       \\<lbrakk>ua \\<in> sinks_aux_less I D {u} ys;\n        z \\<in> Z \\<union> set zs\\<rbrakk>\n       \\<Longrightarrow> (ua, D z) \\<notin> I\n 2. (xs @ ipurge_tr_aux I D {u} ys @ zs, Z) \\<in> failures P", "qed (simp add: A sinks_aux_less_single_dom, simp add: B ipurge_tr_aux_single_dom)"], ["", "lemma ipurge_tr_del_traces [rule_format]:\n  assumes\n    S: \"secure P I D\" and\n    A: \"\\<forall>v \\<in> sinks I D u ys. \\<forall>z \\<in> set zs. (v, D z) \\<notin> I\" and\n    B: \"xs @ ipurge_tr I D u ys @ zs \\<in> traces P\" and\n    C: \"xs @ ys \\<in> traces P\"\n  shows \"xs @ ys @ zs \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ ys @ zs \\<in> traces P", "proof (rule failures_traces [where X = \"{}\"],\n rule ipurge_tr_del_failures [OF S _ _ C, where u = u])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v z.\n       \\<lbrakk>v \\<in> sinks I D u ys; z \\<in> {} \\<union> set zs\\<rbrakk>\n       \\<Longrightarrow> (v, D z) \\<notin> I\n 2. (xs @ ipurge_tr I D u ys @ zs, {}) \\<in> failures P", "qed (simp add: A, rule traces_failures [OF B])"], ["", "lemma ipurge_ref_append:\n \"ipurge_ref I D u (xs @ ys) X =\n  ipurge_ref_aux I D (insert u (sinks I D u xs)) ys X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D u (xs @ ys) X =\n    ipurge_ref_aux I D (insert u (sinks I D u xs)) ys X", "proof (simp add: sinks_aux_single_dom [symmetric]\n ipurge_ref_aux_single_dom [symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D {u} (xs @ ys) X =\n    ipurge_ref_aux I D (sinks_aux I D {u} xs) ys X", "qed (simp add: ipurge_ref_aux_append)"], ["", "lemma ipurge_ref_distrib_inter:\n \"ipurge_ref I D u xs (X \\<inter> Y) = ipurge_ref I D u xs X \\<inter> ipurge_ref I D u xs Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D u xs (X \\<inter> Y) =\n    ipurge_ref I D u xs X \\<inter> ipurge_ref I D u xs Y", "proof (simp add: ipurge_ref_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. {x \\<in> X.\n     x \\<in> Y \\<and>\n     (u, D x) \\<notin> I \\<and>\n     (\\<forall>v\\<in>sinks I D u xs. (v, D x) \\<notin> I)} =\n    {x \\<in> X.\n     (u, D x) \\<notin> I \\<and>\n     (\\<forall>v\\<in>sinks I D u xs. (v, D x) \\<notin> I)} \\<inter>\n    {x \\<in> Y.\n     (u, D x) \\<notin> I \\<and>\n     (\\<forall>v\\<in>sinks I D u xs. (v, D x) \\<notin> I)}", "qed blast"], ["", "lemma ipurge_ref_distrib_union:\n \"ipurge_ref I D u xs (X \\<union> Y) = ipurge_ref I D u xs X \\<union> ipurge_ref I D u xs Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D u xs (X \\<union> Y) =\n    ipurge_ref I D u xs X \\<union> ipurge_ref I D u xs Y", "proof (simp add: ipurge_ref_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. (x \\<in> X \\<or> x \\<in> Y) \\<and>\n        (u, D x) \\<notin> I \\<and>\n        (\\<forall>v\\<in>sinks I D u xs. (v, D x) \\<notin> I)} =\n    {x \\<in> X.\n     (u, D x) \\<notin> I \\<and>\n     (\\<forall>v\\<in>sinks I D u xs. (v, D x) \\<notin> I)} \\<union>\n    {x \\<in> Y.\n     (u, D x) \\<notin> I \\<and>\n     (\\<forall>v\\<in>sinks I D u xs. (v, D x) \\<notin> I)}", "qed blast"], ["", "lemma ipurge_ref_subset:\n \"ipurge_ref I D u xs X \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D u xs X \\<subseteq> X", "by (subst ipurge_ref_def, rule subsetI, simp)"], ["", "lemma ipurge_ref_subset_union:\n \"ipurge_ref I D u xs (X \\<union> Y) \\<subseteq> X \\<union> ipurge_ref I D u xs Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D u xs (X \\<union> Y)\n    \\<subseteq> X \\<union> ipurge_ref I D u xs Y", "proof (simp add: ipurge_ref_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. (x \\<in> X \\<or> x \\<in> Y) \\<and>\n        (u, D x) \\<notin> I \\<and>\n        (\\<forall>v\\<in>sinks I D u xs. (v, D x) \\<notin> I)}\n    \\<subseteq> X \\<union>\n                {x \\<in> Y.\n                 (u, D x) \\<notin> I \\<and>\n                 (\\<forall>v\\<in>sinks I D u xs. (v, D x) \\<notin> I)}", "qed blast"], ["", "lemma ipurge_ref_subset_insert:\n \"ipurge_ref I D u xs (insert x X) \\<subseteq> insert x (ipurge_ref I D u xs X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D u xs (insert x X)\n    \\<subseteq> insert x (ipurge_ref I D u xs X)", "by (simp only: insert_def ipurge_ref_subset_union)"], ["", "lemma ipurge_ref_empty [rule_format]:\n  assumes\n    A: \"v = u \\<or> v \\<in> sinks I D u xs\" and\n    B: \"\\<forall>x \\<in> X. (v, D x) \\<in> I\"\n  shows \"ipurge_ref I D u xs X = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D u xs X = {}", "proof (subst ipurge_ref_aux_single_dom [symmetric],\n rule ipurge_ref_aux_empty [of v])"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> sinks_aux I D {u} xs\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> (v, D x) \\<in> I", "show \"v \\<in> sinks_aux I D {u} xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D {u} xs", "using A"], ["proof (prove)\nusing this:\n  v = u \\<or> v \\<in> sinks I D u xs\n\ngoal (1 subgoal):\n 1. v \\<in> sinks_aux I D {u} xs", "by (simp add: sinks_aux_single_dom)"], ["proof (state)\nthis:\n  v \\<in> sinks_aux I D {u} xs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> (v, D x) \\<in> I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> (v, D x) \\<in> I", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> (v, D x) \\<in> I", "assume \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> (v, D x) \\<in> I", "with B"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X. (v, D x) \\<in> I\n  x \\<in> X", "show \"(v, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X. (v, D x) \\<in> I\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. (v, D x) \\<in> I", ".."], ["proof (state)\nthis:\n  (v, D x) \\<in> I\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nFinally, in what follows, properties @{term process_prop_1}, @{term process_prop_5}, and\n@{term process_prop_6} of processes (cf. \\cite{R2}) are put into the form of introduction rules.\n\n\\null\n\\<close>"], ["", "lemma process_rule_1:\n \"([], {}) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> failures P", "proof (simp add: failures_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> fst (Rep_process P)", "have \"Rep_process P \\<in> process_set\" (is \"?P' \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_process P \\<in> process_set", "by (rule Rep_process)"], ["proof (state)\nthis:\n  Rep_process P \\<in> process_set\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> fst (Rep_process P)", "thus \"([], {}) \\<in> fst ?P'\""], ["proof (prove)\nusing this:\n  Rep_process P \\<in> process_set\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> fst (Rep_process P)", "by (simp add: process_set_def process_prop_1_def)"], ["proof (state)\nthis:\n  ([], {}) \\<in> fst (Rep_process P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma process_rule_5 [rule_format]:\n \"xs \\<in> divergences P \\<longrightarrow> xs @ [x] \\<in> divergences P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> divergences P \\<longrightarrow> xs @ [x] \\<in> divergences P", "proof (simp add: divergences_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<in> snd (Rep_process P) \\<longrightarrow>\n    xs @ [x] \\<in> snd (Rep_process P)", "have \"Rep_process P \\<in> process_set\" (is \"?P' \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_process P \\<in> process_set", "by (rule Rep_process)"], ["proof (state)\nthis:\n  Rep_process P \\<in> process_set\n\ngoal (1 subgoal):\n 1. xs \\<in> snd (Rep_process P) \\<longrightarrow>\n    xs @ [x] \\<in> snd (Rep_process P)", "hence \"\\<forall>xs x. xs \\<in> snd ?P' \\<longrightarrow> xs @ [x] \\<in> snd ?P'\""], ["proof (prove)\nusing this:\n  Rep_process P \\<in> process_set\n\ngoal (1 subgoal):\n 1. \\<forall>xs x.\n       xs \\<in> snd (Rep_process P) \\<longrightarrow>\n       xs @ [x] \\<in> snd (Rep_process P)", "by (simp add: process_set_def process_prop_5_def)"], ["proof (state)\nthis:\n  \\<forall>xs x.\n     xs \\<in> snd (Rep_process P) \\<longrightarrow>\n     xs @ [x] \\<in> snd (Rep_process P)\n\ngoal (1 subgoal):\n 1. xs \\<in> snd (Rep_process P) \\<longrightarrow>\n    xs @ [x] \\<in> snd (Rep_process P)", "thus \"xs \\<in> snd ?P' \\<longrightarrow> xs @ [x] \\<in> snd ?P'\""], ["proof (prove)\nusing this:\n  \\<forall>xs x.\n     xs \\<in> snd (Rep_process P) \\<longrightarrow>\n     xs @ [x] \\<in> snd (Rep_process P)\n\ngoal (1 subgoal):\n 1. xs \\<in> snd (Rep_process P) \\<longrightarrow>\n    xs @ [x] \\<in> snd (Rep_process P)", "by blast"], ["proof (state)\nthis:\n  xs \\<in> snd (Rep_process P) \\<longrightarrow>\n  xs @ [x] \\<in> snd (Rep_process P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma process_rule_6 [rule_format]:\n \"xs \\<in> divergences P \\<longrightarrow> (xs, X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> divergences P \\<longrightarrow> (xs, X) \\<in> failures P", "proof (simp add: failures_def divergences_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<in> snd (Rep_process P) \\<longrightarrow>\n    (xs, X) \\<in> fst (Rep_process P)", "have \"Rep_process P \\<in> process_set\" (is \"?P' \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_process P \\<in> process_set", "by (rule Rep_process)"], ["proof (state)\nthis:\n  Rep_process P \\<in> process_set\n\ngoal (1 subgoal):\n 1. xs \\<in> snd (Rep_process P) \\<longrightarrow>\n    (xs, X) \\<in> fst (Rep_process P)", "hence \"\\<forall>xs X. xs \\<in> snd ?P' \\<longrightarrow> (xs, X) \\<in> fst ?P'\""], ["proof (prove)\nusing this:\n  Rep_process P \\<in> process_set\n\ngoal (1 subgoal):\n 1. \\<forall>xs X.\n       xs \\<in> snd (Rep_process P) \\<longrightarrow>\n       (xs, X) \\<in> fst (Rep_process P)", "by (simp add: process_set_def process_prop_6_def)"], ["proof (state)\nthis:\n  \\<forall>xs X.\n     xs \\<in> snd (Rep_process P) \\<longrightarrow>\n     (xs, X) \\<in> fst (Rep_process P)\n\ngoal (1 subgoal):\n 1. xs \\<in> snd (Rep_process P) \\<longrightarrow>\n    (xs, X) \\<in> fst (Rep_process P)", "thus \"xs \\<in> snd ?P' \\<longrightarrow> (xs, X) \\<in> fst ?P'\""], ["proof (prove)\nusing this:\n  \\<forall>xs X.\n     xs \\<in> snd (Rep_process P) \\<longrightarrow>\n     (xs, X) \\<in> fst (Rep_process P)\n\ngoal (1 subgoal):\n 1. xs \\<in> snd (Rep_process P) \\<longrightarrow>\n    (xs, X) \\<in> fst (Rep_process P)", "by blast"], ["proof (state)\nthis:\n  xs \\<in> snd (Rep_process P) \\<longrightarrow>\n  (xs, X) \\<in> fst (Rep_process P)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}