{"file_name": "/home/qj213/afp-2021-10-22/thys/BytecodeLogicJmlTypes/Reachability.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BytecodeLogicJmlTypes", "problem_names": ["lemma ZeroHeightReachableElimAux[rule_format]:\n  \"(M, l, s, k, r) \\<in> Reachable \\<Longrightarrow> 0=k \\<longrightarrow> r=s\"", "lemma ZeroHeightReachableElim: \"(M,l,s,0,r) \\<in> Reachable \\<Longrightarrow> r=s\"", "lemma ReachableSplit[rule_format]:\n  \"(M, l,s, k, t) \\<in> Reachable \\<Longrightarrow> \n    1 \\<le> k \\<longrightarrow> \n   ((\\<exists> n m r ll. (M,l,s,n,ll,r):Step \\<and> \n                 (M,ll,r,m,t):Reachable \\<and> Suc m +n =k) \\<or>\n    (\\<exists> n ops S h c m par R ops1 code l0. \n          s=(ops,S,h) \\<and> get_ins M l = Some (invokeS c m) \\<and> \n          mbody_is c m (par,code,l0) \\<and> (ops,par,R,ops1):Frame \\<and> \n          ((par,code,l0), l0, ([],R,h), n, t):Reachable \\<and> Suc n = k))\"", "lemma Reachable_returnElim[rule_format]:\n\"(M,l,s,k,t) \\<in> Reachable \\<Longrightarrow> get_ins M l = Some vreturn \\<longrightarrow> t=s\""], "translations": [["", "lemma ZeroHeightReachableElimAux[rule_format]:\n  \"(M, l, s, k, r) \\<in> Reachable \\<Longrightarrow> 0=k \\<longrightarrow> r=s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, l, s, k, r) \\<in> Reachable \\<Longrightarrow>\n    0 = k \\<longrightarrow> r = s", "by (erule Reachable.induct, simp_all)"], ["", "(*>*)"], ["", "lemma ZeroHeightReachableElim: \"(M,l,s,0,r) \\<in> Reachable \\<Longrightarrow> r=s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, l, s, 0, r) \\<in> Reachable \\<Longrightarrow> r = s", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, l, s, 0, r) \\<in> Reachable \\<Longrightarrow> r = s", "by (erule ZeroHeightReachableElimAux, simp)"], ["", "(*>*)"], ["", "lemma ReachableSplit[rule_format]:\n  \"(M, l,s, k, t) \\<in> Reachable \\<Longrightarrow> \n    1 \\<le> k \\<longrightarrow> \n   ((\\<exists> n m r ll. (M,l,s,n,ll,r):Step \\<and> \n                 (M,ll,r,m,t):Reachable \\<and> Suc m +n =k) \\<or>\n    (\\<exists> n ops S h c m par R ops1 code l0. \n          s=(ops,S,h) \\<and> get_ins M l = Some (invokeS c m) \\<and> \n          mbody_is c m (par,code,l0) \\<and> (ops,par,R,ops1):Frame \\<and> \n          ((par,code,l0), l0, ([],R,h), n, t):Reachable \\<and> Suc n = k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, l, s, k, t) \\<in> Reachable \\<Longrightarrow>\n    1 \\<le> k \\<longrightarrow>\n    (\\<exists>n m r ll.\n        (M, l, s, n, ll, r) \\<in> Step \\<and>\n        (M, ll, r, m, t) \\<in> Reachable \\<and> Suc m + n = k) \\<or>\n    (\\<exists>n ops S h c m par R ops1 code l0.\n        s = (ops, S, h) \\<and>\n        get_ins M l = Some (invokeS c m) \\<and>\n        mbody_is c m (par, code, l0) \\<and>\n        (ops, par, R, ops1) \\<in> Frame \\<and>\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable \\<and>\n        Suc n = k)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, l, s, k, t) \\<in> Reachable \\<Longrightarrow>\n    1 \\<le> k \\<longrightarrow>\n    (\\<exists>n m r ll.\n        (M, l, s, n, ll, r) \\<in> Step \\<and>\n        (M, ll, r, m, t) \\<in> Reachable \\<and> Suc m + n = k) \\<or>\n    (\\<exists>n ops S h c m par R ops1 code l0.\n        s = (ops, S, h) \\<and>\n        get_ins M l = Some (invokeS c m) \\<and>\n        mbody_is c m (par, code, l0) \\<and>\n        (ops, par, R, ops1) \\<in> Frame \\<and>\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable \\<and>\n        Suc n = k)", "apply (erule Reachable.induct, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M l s n ll r m t k.\n       \\<lbrakk>(M, l, s, n, ll, r) \\<in> Step;\n        (M, ll, r, m, t) \\<in> Reachable;\n        Suc 0 \\<le> m \\<longrightarrow>\n        (\\<exists>n ma a aa b lla.\n            (M, ll, r, n, lla, a, aa, b) \\<in> Step \\<and>\n            (M, lla, (a, aa, b), ma, t) \\<in> Reachable \\<and>\n            Suc (ma + n) = m) \\<or>\n        (\\<exists>n ops S h.\n            r = (ops, S, h) \\<and>\n            (\\<exists>c ma.\n                get_ins M ll = Some (invokeS c ma) \\<and>\n                (\\<exists>par R ops1 code l0.\n                    mbody_is c ma (par, code, l0) \\<and>\n                    (ops, par, R, ops1) \\<in> Frame \\<and>\n                    ((par, code, l0), l0, ([], R, h), n, t)\n                    \\<in> Reachable \\<and>\n                    Suc n = m)));\n        k = Suc (m + n)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na ma a aa b ll.\n                             (M, l, s, na, ll, a, aa, b) \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), ma, t)\n                             \\<in> Reachable \\<and>\n                             ma + na = m + n) \\<or>\n                         (\\<exists>na ops S h.\n                             s = (ops, S, h) \\<and>\n                             (\\<exists>c ma.\n                                 get_ins M l = Some (invokeS c ma) \\<and>\n                                 (\\<exists>par R ops1 code l0.\n                                     mbody_is c ma (par, code, l0) \\<and>\n                                     (ops, par, R, ops1) \\<in> Frame \\<and>\n                                     ((par, code, l0), l0, ([], R, h), na,\nt)\n                                     \\<in> Reachable \\<and>\n                                     na = m + n)))\n 2. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na m a aa b ll.\n                             (M, l, (ops, S, h), na, ll, a, aa, b)\n                             \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), m, t)\n                             \\<in> Reachable \\<and>\n                             m + na = n) \\<or>\n                         (\\<exists>par R ops1 code l0.\n                             mbody_is C m (par, code, l0) \\<and>\n                             (ops, par, R, ops1) \\<in> Frame \\<and>\n                             ((par, code, l0), l0, ([], R, h), n, t)\n                             \\<in> Reachable)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb m af ag bc.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        ((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc) \\<in> Reachable;\n        Suc 0 \\<le> m \\<longrightarrow>\n        (\\<exists>n ma ab ac ba lla.\n            ((a, aa, b), ll, (ad, ae, bb), n, lla, ab, ac, ba)\n            \\<in> Step \\<and>\n            ((a, aa, b), lla, (ab, ac, ba), ma, af, ag, bc)\n            \\<in> Reachable \\<and>\n            Suc (ma + n) = m) \\<or>\n        (\\<exists>n c ma.\n            get_ins (a, aa, b) ll = Some (invokeS c ma) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c ma (par, code, l0) \\<and>\n                (ad, par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, bb), n, af, ag, bc)\n                \\<in> Reachable \\<and>\n                Suc n = m));\n        \\<forall>na c ma.\n           get_ins (a, aa, b) l = Some (invokeS c ma) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, af, ag, bc)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c ma (par, code, l0) \\<longrightarrow>\n               na \\<noteq> m + n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na ma ad ae bb ll.\n                            ((a, aa, b), l, (ab, ac, ba), na, ll, ad, ae,\n                             bb)\n                            \\<in> Step \\<and>\n                            ((a, aa, b), ll, (ad, ae, bb), ma, af, ag, bc)\n                            \\<in> Reachable \\<and>\n                            ma + na = m + n\n 2. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na m a aa b ll.\n                             (M, l, (ops, S, h), na, ll, a, aa, b)\n                             \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), m, t)\n                             \\<in> Reachable \\<and>\n                             m + na = n) \\<or>\n                         (\\<exists>par R ops1 code l0.\n                             mbody_is C m (par, code, l0) \\<and>\n                             (ops, par, R, ops1) \\<in> Frame \\<and>\n                             ((par, code, l0), l0, ([], R, h), n, t)\n                             \\<in> Reachable)", "apply (case_tac m, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb af ag bc.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        ((a, aa, b), ll, (ad, ae, bb), 0, af, ag, bc) \\<in> Reachable;\n        \\<forall>na c m.\n           get_ins (a, aa, b) l = Some (invokeS c m) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, af, ag, bc)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c m (par, code, l0) \\<longrightarrow>\n               na \\<noteq> n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na m ad ae bb ll.\n                            ((a, aa, b), l, (ab, ac, ba), na, ll, ad, ae,\n                             bb)\n                            \\<in> Step \\<and>\n                            ((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc)\n                            \\<in> Reachable \\<and>\n                            m + na = n\n 2. \\<And>a aa b l ab ac ba n ll ad ae bb m af ag bc nat.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        ((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc) \\<in> Reachable;\n        Suc 0 \\<le> m \\<longrightarrow>\n        (\\<exists>n ma ab ac ba lla.\n            ((a, aa, b), ll, (ad, ae, bb), n, lla, ab, ac, ba)\n            \\<in> Step \\<and>\n            ((a, aa, b), lla, (ab, ac, ba), ma, af, ag, bc)\n            \\<in> Reachable \\<and>\n            Suc (ma + n) = m) \\<or>\n        (\\<exists>n c ma.\n            get_ins (a, aa, b) ll = Some (invokeS c ma) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c ma (par, code, l0) \\<and>\n                (ad, par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, bb), n, af, ag, bc)\n                \\<in> Reachable \\<and>\n                Suc n = m));\n        \\<forall>na c ma.\n           get_ins (a, aa, b) l = Some (invokeS c ma) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, af, ag, bc)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c ma (par, code, l0) \\<longrightarrow>\n               na \\<noteq> m + n);\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na ma ad ae bb ll.\n                            ((a, aa, b), l, (ab, ac, ba), na, ll, ad, ae,\n                             bb)\n                            \\<in> Step \\<and>\n                            ((a, aa, b), ll, (ad, ae, bb), ma, af, ag, bc)\n                            \\<in> Reachable \\<and>\n                            ma + na = m + n\n 3. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na m a aa b ll.\n                             (M, l, (ops, S, h), na, ll, a, aa, b)\n                             \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), m, t)\n                             \\<in> Reachable \\<and>\n                             m + na = n) \\<or>\n                         (\\<exists>par R ops1 code l0.\n                             mbody_is C m (par, code, l0) \\<and>\n                             (ops, par, R, ops1) \\<in> Frame \\<and>\n                             ((par, code, l0), l0, ([], R, h), n, t)\n                             \\<in> Reachable)", "apply (drule ZeroHeightReachableElim[simplified], clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        \\<forall>na c m.\n           get_ins (a, aa, b) l = Some (invokeS c m) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, ad, ae, bb)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c m (par, code, l0) \\<longrightarrow>\n               na \\<noteq> n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na m af ag bc ll.\n                            ((a, aa, b), l, (ab, ac, ba), na, ll, af, ag,\n                             bc)\n                            \\<in> Step \\<and>\n                            ((a, aa, b), ll, (af, ag, bc), m, ad, ae, bb)\n                            \\<in> Reachable \\<and>\n                            m + na = n\n 2. \\<And>a aa b l ab ac ba n ll ad ae bb m af ag bc nat.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        ((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc) \\<in> Reachable;\n        Suc 0 \\<le> m \\<longrightarrow>\n        (\\<exists>n ma ab ac ba lla.\n            ((a, aa, b), ll, (ad, ae, bb), n, lla, ab, ac, ba)\n            \\<in> Step \\<and>\n            ((a, aa, b), lla, (ab, ac, ba), ma, af, ag, bc)\n            \\<in> Reachable \\<and>\n            Suc (ma + n) = m) \\<or>\n        (\\<exists>n c ma.\n            get_ins (a, aa, b) ll = Some (invokeS c ma) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c ma (par, code, l0) \\<and>\n                (ad, par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, bb), n, af, ag, bc)\n                \\<in> Reachable \\<and>\n                Suc n = m));\n        \\<forall>na c ma.\n           get_ins (a, aa, b) l = Some (invokeS c ma) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, af, ag, bc)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c ma (par, code, l0) \\<longrightarrow>\n               na \\<noteq> m + n);\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na ma ad ae bb ll.\n                            ((a, aa, b), l, (ab, ac, ba), na, ll, ad, ae,\n                             bb)\n                            \\<in> Step \\<and>\n                            ((a, aa, b), ll, (ad, ae, bb), ma, af, ag, bc)\n                            \\<in> Reachable \\<and>\n                            ma + na = m + n\n 3. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na m a aa b ll.\n                             (M, l, (ops, S, h), na, ll, a, aa, b)\n                             \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), m, t)\n                             \\<in> Reachable \\<and>\n                             m + na = n) \\<or>\n                         (\\<exists>par R ops1 code l0.\n                             mbody_is C m (par, code, l0) \\<and>\n                             (ops, par, R, ops1) \\<in> Frame \\<and>\n                             ((par, code, l0), l0, ([], R, h), n, t)\n                             \\<in> Reachable)", "apply (rule, rule,rule, rule,rule, rule, rule, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        \\<forall>na c m.\n           get_ins (a, aa, b) l = Some (invokeS c m) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, ad, ae, bb)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c m (par, code, l0) \\<longrightarrow>\n               na \\<noteq> n)\\<rbrakk>\n       \\<Longrightarrow> ((a, aa, b), ll, (ad, ae, bb),\n                          ?m19 a aa b l ab ac ba n ll ad ae bb, ad, ae, bb)\n                         \\<in> Reachable \\<and>\n                         ?m19 a aa b l ab ac ba n ll ad ae bb + n = n\n 2. \\<And>a aa b l ab ac ba n ll ad ae bb m af ag bc nat.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        ((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc) \\<in> Reachable;\n        Suc 0 \\<le> m \\<longrightarrow>\n        (\\<exists>n ma ab ac ba lla.\n            ((a, aa, b), ll, (ad, ae, bb), n, lla, ab, ac, ba)\n            \\<in> Step \\<and>\n            ((a, aa, b), lla, (ab, ac, ba), ma, af, ag, bc)\n            \\<in> Reachable \\<and>\n            Suc (ma + n) = m) \\<or>\n        (\\<exists>n c ma.\n            get_ins (a, aa, b) ll = Some (invokeS c ma) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c ma (par, code, l0) \\<and>\n                (ad, par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, bb), n, af, ag, bc)\n                \\<in> Reachable \\<and>\n                Suc n = m));\n        \\<forall>na c ma.\n           get_ins (a, aa, b) l = Some (invokeS c ma) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, af, ag, bc)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c ma (par, code, l0) \\<longrightarrow>\n               na \\<noteq> m + n);\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na ma ad ae bb ll.\n                            ((a, aa, b), l, (ab, ac, ba), na, ll, ad, ae,\n                             bb)\n                            \\<in> Step \\<and>\n                            ((a, aa, b), ll, (ad, ae, bb), ma, af, ag, bc)\n                            \\<in> Reachable \\<and>\n                            ma + na = m + n\n 3. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na m a aa b ll.\n                             (M, l, (ops, S, h), na, ll, a, aa, b)\n                             \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), m, t)\n                             \\<in> Reachable \\<and>\n                             m + na = n) \\<or>\n                         (\\<exists>par R ops1 code l0.\n                             mbody_is C m (par, code, l0) \\<and>\n                             (ops, par, R, ops1) \\<in> Frame \\<and>\n                             ((par, code, l0), l0, ([], R, h), n, t)\n                             \\<in> Reachable)", "apply (rule,rule Reachable_zero)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        \\<forall>na c m.\n           get_ins (a, aa, b) l = Some (invokeS c m) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, ad, ae, bb)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c m (par, code, l0) \\<longrightarrow>\n               na \\<noteq> n)\\<rbrakk>\n       \\<Longrightarrow> ?m19 a aa b l ab ac ba n ll ad ae bb = 0\n 2. \\<And>a aa b l ab ac ba n ll ad ae bb.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        \\<forall>na c m.\n           get_ins (a, aa, b) l = Some (invokeS c m) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, ad, ae, bb)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c m (par, code, l0) \\<longrightarrow>\n               na \\<noteq> n)\\<rbrakk>\n       \\<Longrightarrow> (ad, ae, bb) = (ad, ae, bb)\n 3. \\<And>a aa b l ab ac ba n ll ad ae bb.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        \\<forall>na c m.\n           get_ins (a, aa, b) l = Some (invokeS c m) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, ad, ae, bb)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c m (par, code, l0) \\<longrightarrow>\n               na \\<noteq> n)\\<rbrakk>\n       \\<Longrightarrow> ?m19 a aa b l ab ac ba n ll ad ae bb + n = n\n 4. \\<And>a aa b l ab ac ba n ll ad ae bb m af ag bc nat.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        ((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc) \\<in> Reachable;\n        Suc 0 \\<le> m \\<longrightarrow>\n        (\\<exists>n ma ab ac ba lla.\n            ((a, aa, b), ll, (ad, ae, bb), n, lla, ab, ac, ba)\n            \\<in> Step \\<and>\n            ((a, aa, b), lla, (ab, ac, ba), ma, af, ag, bc)\n            \\<in> Reachable \\<and>\n            Suc (ma + n) = m) \\<or>\n        (\\<exists>n c ma.\n            get_ins (a, aa, b) ll = Some (invokeS c ma) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c ma (par, code, l0) \\<and>\n                (ad, par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, bb), n, af, ag, bc)\n                \\<in> Reachable \\<and>\n                Suc n = m));\n        \\<forall>na c ma.\n           get_ins (a, aa, b) l = Some (invokeS c ma) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, af, ag, bc)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c ma (par, code, l0) \\<longrightarrow>\n               na \\<noteq> m + n);\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na ma ad ae bb ll.\n                            ((a, aa, b), l, (ab, ac, ba), na, ll, ad, ae,\n                             bb)\n                            \\<in> Step \\<and>\n                            ((a, aa, b), ll, (ad, ae, bb), ma, af, ag, bc)\n                            \\<in> Reachable \\<and>\n                            ma + na = m + n\n 5. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na m a aa b ll.\n                             (M, l, (ops, S, h), na, ll, a, aa, b)\n                             \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), m, t)\n                             \\<in> Reachable \\<and>\n                             m + na = n) \\<or>\n                         (\\<exists>par R ops1 code l0.\n                             mbody_is C m (par, code, l0) \\<and>\n                             (ops, par, R, ops1) \\<in> Frame \\<and>\n                             ((par, code, l0), l0, ([], R, h), n, t)\n                             \\<in> Reachable)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        \\<forall>na c m.\n           get_ins (a, aa, b) l = Some (invokeS c m) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, ad, ae, bb)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c m (par, code, l0) \\<longrightarrow>\n               na \\<noteq> n)\\<rbrakk>\n       \\<Longrightarrow> (ad, ae, bb) = (ad, ae, bb)\n 2. \\<And>a aa b l ab ac ba n ll ad ae bb.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        \\<forall>na c m.\n           get_ins (a, aa, b) l = Some (invokeS c m) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, ad, ae, bb)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c m (par, code, l0) \\<longrightarrow>\n               na \\<noteq> n)\\<rbrakk>\n       \\<Longrightarrow> 0 + n = n\n 3. \\<And>a aa b l ab ac ba n ll ad ae bb m af ag bc nat.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        ((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc) \\<in> Reachable;\n        Suc 0 \\<le> m \\<longrightarrow>\n        (\\<exists>n ma ab ac ba lla.\n            ((a, aa, b), ll, (ad, ae, bb), n, lla, ab, ac, ba)\n            \\<in> Step \\<and>\n            ((a, aa, b), lla, (ab, ac, ba), ma, af, ag, bc)\n            \\<in> Reachable \\<and>\n            Suc (ma + n) = m) \\<or>\n        (\\<exists>n c ma.\n            get_ins (a, aa, b) ll = Some (invokeS c ma) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c ma (par, code, l0) \\<and>\n                (ad, par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, bb), n, af, ag, bc)\n                \\<in> Reachable \\<and>\n                Suc n = m));\n        \\<forall>na c ma.\n           get_ins (a, aa, b) l = Some (invokeS c ma) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, af, ag, bc)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c ma (par, code, l0) \\<longrightarrow>\n               na \\<noteq> m + n);\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na ma ad ae bb ll.\n                            ((a, aa, b), l, (ab, ac, ba), na, ll, ad, ae,\n                             bb)\n                            \\<in> Step \\<and>\n                            ((a, aa, b), ll, (ad, ae, bb), ma, af, ag, bc)\n                            \\<in> Reachable \\<and>\n                            ma + na = m + n\n 4. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na m a aa b ll.\n                             (M, l, (ops, S, h), na, ll, a, aa, b)\n                             \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), m, t)\n                             \\<in> Reachable \\<and>\n                             m + na = n) \\<or>\n                         (\\<exists>par R ops1 code l0.\n                             mbody_is C m (par, code, l0) \\<and>\n                             (ops, par, R, ops1) \\<in> Frame \\<and>\n                             ((par, code, l0), l0, ([], R, h), n, t)\n                             \\<in> Reachable)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        \\<forall>na c m.\n           get_ins (a, aa, b) l = Some (invokeS c m) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, ad, ae, bb)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c m (par, code, l0) \\<longrightarrow>\n               na \\<noteq> n)\\<rbrakk>\n       \\<Longrightarrow> 0 + n = n\n 2. \\<And>a aa b l ab ac ba n ll ad ae bb m af ag bc nat.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        ((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc) \\<in> Reachable;\n        Suc 0 \\<le> m \\<longrightarrow>\n        (\\<exists>n ma ab ac ba lla.\n            ((a, aa, b), ll, (ad, ae, bb), n, lla, ab, ac, ba)\n            \\<in> Step \\<and>\n            ((a, aa, b), lla, (ab, ac, ba), ma, af, ag, bc)\n            \\<in> Reachable \\<and>\n            Suc (ma + n) = m) \\<or>\n        (\\<exists>n c ma.\n            get_ins (a, aa, b) ll = Some (invokeS c ma) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c ma (par, code, l0) \\<and>\n                (ad, par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, bb), n, af, ag, bc)\n                \\<in> Reachable \\<and>\n                Suc n = m));\n        \\<forall>na c ma.\n           get_ins (a, aa, b) l = Some (invokeS c ma) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, af, ag, bc)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c ma (par, code, l0) \\<longrightarrow>\n               na \\<noteq> m + n);\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na ma ad ae bb ll.\n                            ((a, aa, b), l, (ab, ac, ba), na, ll, ad, ae,\n                             bb)\n                            \\<in> Step \\<and>\n                            ((a, aa, b), ll, (ad, ae, bb), ma, af, ag, bc)\n                            \\<in> Reachable \\<and>\n                            ma + na = m + n\n 3. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na m a aa b ll.\n                             (M, l, (ops, S, h), na, ll, a, aa, b)\n                             \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), m, t)\n                             \\<in> Reachable \\<and>\n                             m + na = n) \\<or>\n                         (\\<exists>par R ops1 code l0.\n                             mbody_is C m (par, code, l0) \\<and>\n                             (ops, par, R, ops1) \\<in> Frame \\<and>\n                             ((par, code, l0), l0, ([], R, h), n, t)\n                             \\<in> Reachable)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb m af ag bc nat.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        ((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc) \\<in> Reachable;\n        Suc 0 \\<le> m \\<longrightarrow>\n        (\\<exists>n ma ab ac ba lla.\n            ((a, aa, b), ll, (ad, ae, bb), n, lla, ab, ac, ba)\n            \\<in> Step \\<and>\n            ((a, aa, b), lla, (ab, ac, ba), ma, af, ag, bc)\n            \\<in> Reachable \\<and>\n            Suc (ma + n) = m) \\<or>\n        (\\<exists>n c ma.\n            get_ins (a, aa, b) ll = Some (invokeS c ma) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c ma (par, code, l0) \\<and>\n                (ad, par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, bb), n, af, ag, bc)\n                \\<in> Reachable \\<and>\n                Suc n = m));\n        \\<forall>na c ma.\n           get_ins (a, aa, b) l = Some (invokeS c ma) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, af, ag, bc)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c ma (par, code, l0) \\<longrightarrow>\n               na \\<noteq> m + n);\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na ma ad ae bb ll.\n                            ((a, aa, b), l, (ab, ac, ba), na, ll, ad, ae,\n                             bb)\n                            \\<in> Step \\<and>\n                            ((a, aa, b), ll, (ad, ae, bb), ma, af, ag, bc)\n                            \\<in> Reachable \\<and>\n                            ma + na = m + n\n 2. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na m a aa b ll.\n                             (M, l, (ops, S, h), na, ll, a, aa, b)\n                             \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), m, t)\n                             \\<in> Reachable \\<and>\n                             m + na = n) \\<or>\n                         (\\<exists>par R ops1 code l0.\n                             mbody_is C m (par, code, l0) \\<and>\n                             (ops, par, R, ops1) \\<in> Frame \\<and>\n                             ((par, code, l0), l0, ([], R, h), n, t)\n                             \\<in> Reachable)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb af ag bc nat.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        ((a, aa, b), ll, (ad, ae, bb), Suc nat, af, ag, bc) \\<in> Reachable;\n        (\\<exists>n m ab ac ba lla.\n            ((a, aa, b), ll, (ad, ae, bb), n, lla, ab, ac, ba)\n            \\<in> Step \\<and>\n            ((a, aa, b), lla, (ab, ac, ba), m, af, ag, bc)\n            \\<in> Reachable \\<and>\n            m + n = nat) \\<or>\n        (\\<exists>n c m.\n            get_ins (a, aa, b) ll = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                (ad, par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, bb), n, af, ag, bc)\n                \\<in> Reachable \\<and>\n                n = nat));\n        \\<forall>na c m.\n           get_ins (a, aa, b) l = Some (invokeS c m) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, af, ag, bc)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c m (par, code, l0) \\<longrightarrow>\n               na \\<noteq> Suc (nat + n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na m ad ae bb ll.\n                            ((a, aa, b), l, (ab, ac, ba), na, ll, ad, ae,\n                             bb)\n                            \\<in> Step \\<and>\n                            ((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc)\n                            \\<in> Reachable \\<and>\n                            m + na = Suc (nat + n)\n 2. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na m a aa b ll.\n                             (M, l, (ops, S, h), na, ll, a, aa, b)\n                             \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), m, t)\n                             \\<in> Reachable \\<and>\n                             m + na = n) \\<or>\n                         (\\<exists>par R ops1 code l0.\n                             mbody_is C m (par, code, l0) \\<and>\n                             (ops, par, R, ops1) \\<in> Frame \\<and>\n                             ((par, code, l0), l0, ([], R, h), n, t)\n                             \\<in> Reachable)", "apply (rule, rule,rule, rule,rule, rule,rule,assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb af ag bc nat.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        ((a, aa, b), ll, (ad, ae, bb), Suc nat, af, ag, bc) \\<in> Reachable;\n        (\\<exists>n m ab ac ba lla.\n            ((a, aa, b), ll, (ad, ae, bb), n, lla, ab, ac, ba)\n            \\<in> Step \\<and>\n            ((a, aa, b), lla, (ab, ac, ba), m, af, ag, bc)\n            \\<in> Reachable \\<and>\n            m + n = nat) \\<or>\n        (\\<exists>n c m.\n            get_ins (a, aa, b) ll = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                (ad, par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, bb), n, af, ag, bc)\n                \\<in> Reachable \\<and>\n                n = nat));\n        \\<forall>na c m.\n           get_ins (a, aa, b) l = Some (invokeS c m) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, af, ag, bc)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c m (par, code, l0) \\<longrightarrow>\n               na \\<noteq> Suc (nat + n))\\<rbrakk>\n       \\<Longrightarrow> ((a, aa, b), ll, (ad, ae, bb),\n                          ?m44 a aa b l ab ac ba n ll ad ae bb af ag bc nat,\n                          af, ag, bc)\n                         \\<in> Reachable \\<and>\n                         ?m44 a aa b l ab ac ba n ll ad ae bb af ag bc nat +\n                         n =\n                         Suc (nat + n)\n 2. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na m a aa b ll.\n                             (M, l, (ops, S, h), na, ll, a, aa, b)\n                             \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), m, t)\n                             \\<in> Reachable \\<and>\n                             m + na = n) \\<or>\n                         (\\<exists>par R ops1 code l0.\n                             mbody_is C m (par, code, l0) \\<and>\n                             (ops, par, R, ops1) \\<in> Frame \\<and>\n                             ((par, code, l0), l0, ([], R, h), n, t)\n                             \\<in> Reachable)", "apply (rule,assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb af ag bc nat.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        ((a, aa, b), ll, (ad, ae, bb), Suc nat, af, ag, bc) \\<in> Reachable;\n        (\\<exists>n m ab ac ba lla.\n            ((a, aa, b), ll, (ad, ae, bb), n, lla, ab, ac, ba)\n            \\<in> Step \\<and>\n            ((a, aa, b), lla, (ab, ac, ba), m, af, ag, bc)\n            \\<in> Reachable \\<and>\n            m + n = nat) \\<or>\n        (\\<exists>n c m.\n            get_ins (a, aa, b) ll = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                (ad, par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, bb), n, af, ag, bc)\n                \\<in> Reachable \\<and>\n                n = nat));\n        \\<forall>na c m.\n           get_ins (a, aa, b) l = Some (invokeS c m) \\<longrightarrow>\n           (\\<forall>par R ops1 code l0.\n               ((par, code, l0), l0, ([], R, ba), na, af, ag, bc)\n               \\<in> Reachable \\<longrightarrow>\n               (ab, par, R, ops1) \\<in> Frame \\<longrightarrow>\n               mbody_is c m (par, code, l0) \\<longrightarrow>\n               na \\<noteq> Suc (nat + n))\\<rbrakk>\n       \\<Longrightarrow> Suc nat + n = Suc (nat + n)\n 2. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na m a aa b ll.\n                             (M, l, (ops, S, h), na, ll, a, aa, b)\n                             \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), m, t)\n                             \\<in> Reachable \\<and>\n                             m + na = n) \\<or>\n                         (\\<exists>par R ops1 code l0.\n                             mbody_is C m (par, code, l0) \\<and>\n                             (ops, par, R, ops1) \\<in> Frame \\<and>\n                             ((par, code, l0), l0, ([], R, h), n, t)\n                             \\<in> Reachable)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na m a aa b ll.\n                             (M, l, (ops, S, h), na, ll, a, aa, b)\n                             \\<in> Step \\<and>\n                             (M, ll, (a, aa, b), m, t)\n                             \\<in> Reachable \\<and>\n                             m + na = n) \\<or>\n                         (\\<exists>par R ops1 code l0.\n                             mbody_is C m (par, code, l0) \\<and>\n                             (ops, par, R, ops1) \\<in> Frame \\<and>\n                             ((par, code, l0), l0, ([], R, h), n, t)\n                             \\<in> Reachable)", "apply (rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        Suc 0 \\<le> n \\<longrightarrow>\n        (\\<exists>na m a aa b ll.\n            ((par, code, l0), l0, ([], R, h), na, ll, a, aa, b)\n            \\<in> Step \\<and>\n            ((par, code, l0), ll, (a, aa, b), m, t) \\<in> Reachable \\<and>\n            Suc (m + na) = n) \\<or>\n        (\\<exists>na c m.\n            get_ins (par, code, l0) l0 = Some (invokeS c m) \\<and>\n            (\\<exists>par R ops1 code l0.\n                mbody_is c m (par, code, l0) \\<and>\n                ([], par, R, ops1) \\<in> Frame \\<and>\n                ((par, code, l0), l0, ([], R, h), na, t)\n                \\<in> Reachable \\<and>\n                Suc na = n));\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>par R ops1 code l0.\n                            mbody_is C m (par, code, l0) \\<and>\n                            (ops, par, R, ops1) \\<in> Frame \\<and>\n                            ((par, code, l0), l0, ([], R, h), n, t)\n                            \\<in> Reachable", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Reachable_returnElim[rule_format]:\n\"(M,l,s,k,t) \\<in> Reachable \\<Longrightarrow> get_ins M l = Some vreturn \\<longrightarrow> t=s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, l, s, k, t) \\<in> Reachable \\<Longrightarrow>\n    get_ins M l = Some vreturn \\<longrightarrow> t = s", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, l, s, k, t) \\<in> Reachable \\<Longrightarrow>\n    get_ins M l = Some vreturn \\<longrightarrow> t = s", "apply (erule Reachable.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k t s M l.\n       \\<lbrakk>k = 0; t = s\\<rbrakk>\n       \\<Longrightarrow> get_ins M l = Some vreturn \\<longrightarrow> t = s\n 2. \\<And>M l s n ll r m t k.\n       \\<lbrakk>(M, l, s, n, ll, r) \\<in> Step;\n        (M, ll, r, m, t) \\<in> Reachable;\n        get_ins M ll = Some vreturn \\<longrightarrow> t = r;\n        k = Suc m + n\\<rbrakk>\n       \\<Longrightarrow> get_ins M l = Some vreturn \\<longrightarrow> t = s\n 3. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        get_ins (par, code, l0) l0 = Some vreturn \\<longrightarrow>\n        t = ([], R, h);\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> get_ins M l = Some vreturn \\<longrightarrow> t = s", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M l s n ll r m t k.\n       \\<lbrakk>(M, l, s, n, ll, r) \\<in> Step;\n        (M, ll, r, m, t) \\<in> Reachable;\n        get_ins M ll = Some vreturn \\<longrightarrow> t = r;\n        k = Suc m + n\\<rbrakk>\n       \\<Longrightarrow> get_ins M l = Some vreturn \\<longrightarrow> t = s\n 2. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        get_ins (par, code, l0) l0 = Some vreturn \\<longrightarrow>\n        t = ([], R, h);\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> get_ins M l = Some vreturn \\<longrightarrow> t = s", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb m af ag bc.\n       \\<lbrakk>((a, aa, b), l, (ab, ac, ba), n, ll, ad, ae, bb) \\<in> Step;\n        ((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc) \\<in> Reachable;\n        get_ins (a, aa, b) ll = Some vreturn \\<longrightarrow>\n        af = ad \\<and> ag = ae \\<and> bc = bb;\n        get_ins (a, aa, b) l = Some vreturn\\<rbrakk>\n       \\<Longrightarrow> af = ab \\<and> ag = ac \\<and> bc = ba\n 2. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        get_ins (par, code, l0) l0 = Some vreturn \\<longrightarrow>\n        t = ([], R, h);\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> get_ins M l = Some vreturn \\<longrightarrow> t = s", "apply (drule RetElim1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb m af ag bc.\n       \\<lbrakk>((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc)\n                \\<in> Reachable;\n        get_ins (a, aa, b) ll = Some vreturn \\<longrightarrow>\n        af = ad \\<and> ag = ae \\<and> bc = bb;\n        get_ins (a, aa, b) l = Some vreturn\\<rbrakk>\n       \\<Longrightarrow> get_ins (a, aa, b) l = Some vreturn\n 2. \\<And>a aa b l ab ac ba n ll ad ae bb m af ag bc.\n       \\<lbrakk>((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc)\n                \\<in> Reachable;\n        get_ins (a, aa, b) ll = Some vreturn \\<longrightarrow>\n        af = ad \\<and> ag = ae \\<and> bc = bb;\n        get_ins (a, aa, b) l = Some vreturn; False\\<rbrakk>\n       \\<Longrightarrow> af = ab \\<and> ag = ac \\<and> bc = ba\n 3. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        get_ins (par, code, l0) l0 = Some vreturn \\<longrightarrow>\n        t = ([], R, h);\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> get_ins M l = Some vreturn \\<longrightarrow> t = s", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b l ab ac ba n ll ad ae bb m af ag bc.\n       \\<lbrakk>((a, aa, b), ll, (ad, ae, bb), m, af, ag, bc)\n                \\<in> Reachable;\n        get_ins (a, aa, b) ll = Some vreturn \\<longrightarrow>\n        af = ad \\<and> ag = ae \\<and> bc = bb;\n        get_ins (a, aa, b) l = Some vreturn; False\\<rbrakk>\n       \\<Longrightarrow> af = ab \\<and> ag = ac \\<and> bc = ba\n 2. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        get_ins (par, code, l0) l0 = Some vreturn \\<longrightarrow>\n        t = ([], R, h);\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> get_ins M l = Some vreturn \\<longrightarrow> t = s", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C m par code l0 M l s ops S h R ops1 n t k.\n       \\<lbrakk>mbody_is C m (par, code, l0);\n        get_ins M l = Some (invokeS C m); s = (ops, S, h);\n        (ops, par, R, ops1) \\<in> Frame;\n        ((par, code, l0), l0, ([], R, h), n, t) \\<in> Reachable;\n        get_ins (par, code, l0) l0 = Some vreturn \\<longrightarrow>\n        t = ([], R, h);\n        k = Suc n\\<rbrakk>\n       \\<Longrightarrow> get_ins M l = Some vreturn \\<longrightarrow> t = s", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>Similar to the operational semantics, we define a variation of\nthe reachability relation that hides the index.\\<close>"], ["", "definition Reach::\"Mbody \\<Rightarrow> Label \\<Rightarrow> State \\<Rightarrow> State \\<Rightarrow> bool\"\nwhere \"Reach M l s t = (\\<exists> k . (M,l,s,k,t):Reachable)\""], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}