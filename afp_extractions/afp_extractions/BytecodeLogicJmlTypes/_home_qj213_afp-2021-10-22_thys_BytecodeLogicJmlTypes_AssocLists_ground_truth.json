{"file_name": "/home/qj213/afp-2021-10-22/thys/BytecodeLogicJmlTypes/AssocLists.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BytecodeLogicJmlTypes", "problem_names": ["lemma AL_lookup1[rule_format]:\"\\<forall> a b . (L\\<down>a = Some b) \\<longrightarrow> ((a,b) \\<in> set L)\"", "lemma AL_Triv1:\"a=b \\<Longrightarrow> L\\<down>a = L\\<down>b\"", "lemma AL_Triv2: \"\\<lbrakk>L\\<down>a = X; L\\<down>a = Y\\<rbrakk> \\<Longrightarrow> X=Y\"", "lemma AL_Triv3:\"\\<lbrakk>L=M ; M\\<down>b = X\\<rbrakk> \\<Longrightarrow> L\\<down>b = X\"", "lemma AL_Triv4:\"\\<lbrakk>L=M ; L\\<down>b = X\\<rbrakk> \\<Longrightarrow> M\\<down>b = X\"", "lemma AL_delete1: \"(delete L a) \\<down> a = None\"", "lemma AL_delete2[rule_format]:\"b \\<noteq> a \\<longrightarrow> (delete l a)\\<down>b = l\\<down>b\"", "lemma AL_delete3: \"L\\<down>a = None \\<Longrightarrow> delete L a = L\"", "lemma AL_delete4[simp]: \"length(delete t a) < Suc(length t)\"", "lemma AL_delete5[rule_format]:\"[|b \\<noteq> a; l\\<down>b = x|] ==> (delete l a)\\<down>b = x\"", "lemma AL_delete_idempotent: \"delete M x = delete (delete M x) x\"", "lemma AL_delete_commutative: \"delete (delete M c) x = delete (delete M x) c\"", "lemma AL_update1: \"(L::('a, 'b) AssList)[a\\<mapsto>b]\\<down>a = Some b\"", "lemma AL_update1a: \"a=c \\<Longrightarrow> (L::('a, 'b) AssList)[a\\<mapsto>b]\\<down>c = Some b\"", "lemma AL_update2: \"a \\<noteq> b \\<Longrightarrow> (L::('a, 'b) AssList)[a\\<mapsto>v]\\<down>b = L\\<down>b\"", "lemma AL_update3: \"\\<lbrakk>(L::('a, 'b) AssList)[a\\<mapsto>v]\\<down>b = X; a \\<noteq> b\\<rbrakk> \\<Longrightarrow> L\\<down>b=X\"", "lemma AL_update4:\"\\<lbrakk> (L::('a, 'b) AssList)\\<down>b = Some X; a \\<noteq> b\\<rbrakk>\\<Longrightarrow> L[a\\<mapsto>v]\\<down>b = Some X\"", "lemma AL_update5: \"\\<lbrakk>(L::('a, 'b) AssList)\\<down>b = M; a \\<noteq> b\\<rbrakk> \\<Longrightarrow> L[a\\<mapsto>X]\\<down>b = M\"", "lemma AL_emp1: \"emp\\<down>a = None\"", "lemma AL_Size_Zero: \"|L| = 0 \\<Longrightarrow> None = L\\<down>a\"", "lemma AL_Size_Suc: \"\\<forall> n . |L| = Suc n \\<longrightarrow> (\\<exists> a b . L\\<down>a = Some b)\"", "lemma AL_Size_UpdateSuc:\"L\\<down>a = None \\<Longrightarrow> |L[a\\<mapsto>b]| = Suc |L|\"", "lemma AL_Size_SucSplit[rule_format]:\n\"\\<forall> n . |L| = Suc n \\<longrightarrow> \n  (\\<exists> a b M . |M| = n \\<and> M\\<down>a = None \\<and> L\\<down>a = Some b \\<and> (\\<forall> c . c\\<noteq> a \\<longrightarrow> M\\<down>c = L\\<down>c))\"", "lemma updSizeAux[rule_format]: \n\"\\<forall> h a obj obj1 . |h[a\\<mapsto>obj1]| = n \\<longrightarrow> h\\<down>a = Some obj \\<longrightarrow> |h| = n\"", "lemma updSize: \"h\\<down>a = Some obj \\<Longrightarrow> |h[a\\<mapsto>obj1]| = |h|\""], "translations": [["", "lemma AL_lookup1[rule_format]:\"\\<forall> a b . (L\\<down>a = Some b) \\<longrightarrow> ((a,b) \\<in> set L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. L\\<down>a = Some b \\<longrightarrow> (a, b) \\<in> set L", "by (induct L, simp_all)"], ["", "(* add: set_mem_eq)*)"], ["", "lemma AL_Triv1:\"a=b \\<Longrightarrow> L\\<down>a = L\\<down>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> L\\<down>a = L\\<down>b", "by simp"], ["", "lemma AL_Triv2: \"\\<lbrakk>L\\<down>a = X; L\\<down>a = Y\\<rbrakk> \\<Longrightarrow> X=Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<down>a = X; L\\<down>a = Y\\<rbrakk> \\<Longrightarrow> X = Y", "by simp"], ["", "lemma AL_Triv3:\"\\<lbrakk>L=M ; M\\<down>b = X\\<rbrakk> \\<Longrightarrow> L\\<down>b = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L = M; M\\<down>b = X\\<rbrakk> \\<Longrightarrow> L\\<down>b = X", "by clarsimp"], ["", "lemma AL_Triv4:\"\\<lbrakk>L=M ; L\\<down>b = X\\<rbrakk> \\<Longrightarrow> M\\<down>b = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L = M; L\\<down>b = X\\<rbrakk> \\<Longrightarrow> M\\<down>b = X", "by clarsimp"], ["", "(*>*)"], ["", "text\\<open>The statement following the type declaration of \\<open>lookup\\<close>\nindicates that we may use the infix notation \\<open>L\\<down>a\\<close> for the\nlookup operation, and asserts some precedence for bracketing. In a\nsimilar way, shorthands are introduced for various operations\nthroughout this document.\\<close>"], ["", "primrec delete::\"('a, 'b) AssList \\<Rightarrow> 'a \\<Rightarrow> ('a, 'b) AssList\"\nwhere\n\"delete [] a = []\" |\n\"delete (h # t) a = (if (fst h) = a then delete t a else (h # (delete t a)))\""], ["", "(*<*)"], ["", "lemma AL_delete1: \"(delete L a) \\<down> a = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete L a\\<down>a = None", "by (induct L, auto)"], ["", "lemma AL_delete2[rule_format]:\"b \\<noteq> a \\<longrightarrow> (delete l a)\\<down>b = l\\<down>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> a \\<longrightarrow> delete l a\\<down>b = l\\<down>b", "by (induct l, simp, simp)"], ["", "lemma AL_delete3: \"L\\<down>a = None \\<Longrightarrow> delete L a = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L\\<down>a = None \\<Longrightarrow> delete L a = L", "apply (induct L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. []\\<down>a = None \\<Longrightarrow> delete [] a = []\n 2. \\<And>aa L.\n       \\<lbrakk>L\\<down>a = None \\<Longrightarrow> delete L a = L;\n        (aa # L)\\<down>a = None\\<rbrakk>\n       \\<Longrightarrow> delete (aa # L) a = aa # L", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa L.\n       \\<lbrakk>L\\<down>a = None \\<Longrightarrow> delete L a = L;\n        (aa # L)\\<down>a = None\\<rbrakk>\n       \\<Longrightarrow> delete (aa # L) a = aa # L", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b L.\n       \\<lbrakk>L\\<down>a = None \\<Longrightarrow> delete L a = L;\n        (if aa = a then Some (snd (aa, b)) else L\\<down>a) = None\\<rbrakk>\n       \\<Longrightarrow> (aa = a \\<longrightarrow>\n                          delete L a = (a, b) # L) \\<and>\n                         (aa \\<noteq> a \\<longrightarrow> delete L a = L)", "apply (subgoal_tac \"L\\<down>a = None\", clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b L.\n       \\<lbrakk>L\\<down>a = None \\<Longrightarrow> delete L a = L;\n        (if aa = a then Some (snd (aa, b)) else L\\<down>a) = None\\<rbrakk>\n       \\<Longrightarrow> L\\<down>a = None", "apply (case_tac \"aa=a\", clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b L.\n       \\<lbrakk>L\\<down>a = None \\<Longrightarrow> delete L a = L;\n        (if aa = a then Some (snd (aa, b)) else L\\<down>a) = None;\n        aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> L\\<down>a = None", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma AL_delete4[simp]: \"length(delete t a) < Suc(length t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (delete t a) < Suc (length t)", "by (induct t, simp+)"], ["", "lemma AL_delete5[rule_format]:\"[|b \\<noteq> a; l\\<down>b = x|] ==> (delete l a)\\<down>b = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<noteq> a; l\\<down>b = x\\<rbrakk>\n    \\<Longrightarrow> delete l a\\<down>b = x", "by (drule_tac l=l in AL_delete2, simp)"], ["", "lemma AL_delete_idempotent: \"delete M x = delete (delete M x) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete M x = delete (delete M x) x", "by (induct M, auto)"], ["", "lemma AL_delete_commutative: \"delete (delete M c) x = delete (delete M x) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete (delete M c) x = delete (delete M x) c", "apply (induct M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. delete (delete [] c) x = delete (delete [] x) c\n 2. \\<And>a M.\n       delete (delete M c) x = delete (delete M x) c \\<Longrightarrow>\n       delete (delete (a # M) c) x = delete (delete (a # M) x) c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       delete (delete M c) x = delete (delete M x) c \\<Longrightarrow>\n       delete (delete (a # M) c) x = delete (delete (a # M) x) c", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "definition upd::\"('a, 'b) AssList \\<Rightarrow> 'a \\<Rightarrow> 'b \\<Rightarrow> ('a, 'b) AssList\"\n         (\"_[_\\<mapsto>_]\" [1000,0,0] 1000)\nwhere \"upd L a b = (a,b) # (delete L a)\""], ["", "(*<*)"], ["", "lemma AL_update1: \"(L::('a, 'b) AssList)[a\\<mapsto>b]\\<down>a = Some b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L[a\\<mapsto>b]\\<down>a = Some b", "by (simp add: upd_def)"], ["", "lemma AL_update1a: \"a=c \\<Longrightarrow> (L::('a, 'b) AssList)[a\\<mapsto>b]\\<down>c = Some b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = c \\<Longrightarrow> L[a\\<mapsto>b]\\<down>c = Some b", "by (simp add: AL_update1)"], ["", "lemma AL_update2: \"a \\<noteq> b \\<Longrightarrow> (L::('a, 'b) AssList)[a\\<mapsto>v]\\<down>b = L\\<down>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> L[a\\<mapsto>v]\\<down>b = L\\<down>b", "by (induct L, simp_all add: upd_def)"], ["", "lemma AL_update3: \"\\<lbrakk>(L::('a, 'b) AssList)[a\\<mapsto>v]\\<down>b = X; a \\<noteq> b\\<rbrakk> \\<Longrightarrow> L\\<down>b=X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L[a\\<mapsto>v]\\<down>b = X; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> L\\<down>b = X", "by (subgoal_tac \"(L::('a, 'b) AssList)[a\\<mapsto>v]\\<down>b = L\\<down>b\", clarsimp,erule AL_update2)"], ["", "lemma AL_update4:\"\\<lbrakk> (L::('a, 'b) AssList)\\<down>b = Some X; a \\<noteq> b\\<rbrakk>\\<Longrightarrow> L[a\\<mapsto>v]\\<down>b = Some X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<down>b = Some X; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> L[a\\<mapsto>v]\\<down>b = Some X", "by (subgoal_tac \"(L::('a, 'b) AssList)[a\\<mapsto>v]\\<down>b = L\\<down>b\", clarsimp, erule AL_update2)"], ["", "lemma AL_update5: \"\\<lbrakk>(L::('a, 'b) AssList)\\<down>b = M; a \\<noteq> b\\<rbrakk> \\<Longrightarrow> L[a\\<mapsto>X]\\<down>b = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<down>b = M; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> L[a\\<mapsto>X]\\<down>b = M", "apply (subgoal_tac \"(L::('a, 'b) AssList)[a\\<mapsto>X]\\<down>b = L\\<down>b\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<down>b = M; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> L[a\\<mapsto>X]\\<down>b = L\\<down>b", "apply (erule AL_update2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>The empty map is represented by the empty list.\\<close>"], ["", "definition emp::\"('a, 'b)AssList\"\nwhere \"emp = []\""], ["", "(*<*)"], ["", "lemma AL_emp1: \"emp\\<down>a = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emp\\<down>a = None", "by (simp add: emp_def)"], ["", "definition AL_isEmp::\"('a,'b) AssList \\<Rightarrow> bool\"\nwhere \"AL_isEmp l = (\\<forall> a . l\\<down>a = None)\""], ["", "(*>*)"], ["", "definition contained::\"('a,'b) AssList \\<Rightarrow> ('a,'b) AssList \\<Rightarrow> bool\"\nwhere \"contained L M = (\\<forall> a b . L\\<down>a = Some b \\<longrightarrow> M\\<down>a = Some b)\""], ["", "text\\<open>The following operation defined the cardinality of a map.\\<close>"], ["", "fun AL_Size :: \"('a, 'b) AssList \\<Rightarrow> nat\"  (\"|_|\" [1000] 1000) where\n  \"AL_Size [] = 0\"\n| \"AL_Size (h # t) = Suc (AL_Size (delete t (fst h)))\""], ["", "(*<*)"], ["", "lemma AL_Size_Zero: \"|L| = 0 \\<Longrightarrow> None = L\\<down>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |L| = 0 \\<Longrightarrow> None = L\\<down>a", "by (induct L, simp, simp)"], ["", "lemma AL_Size_Suc: \"\\<forall> n . |L| = Suc n \\<longrightarrow> (\\<exists> a b . L\\<down>a = Some b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       |L| = Suc n \\<longrightarrow> (\\<exists>a b. L\\<down>a = Some b)", "apply (induct L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>n.\n       |[]| = Suc n \\<longrightarrow> (\\<exists>a b. []\\<down>a = Some b)\n 2. \\<And>a L.\n       \\<forall>n.\n          |L| = Suc n \\<longrightarrow>\n          (\\<exists>a b. L\\<down>a = Some b) \\<Longrightarrow>\n       \\<forall>n.\n          |(a # L)| = Suc n \\<longrightarrow>\n          (\\<exists>aa b. (a # L)\\<down>aa = Some b)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<forall>n.\n          |L| = Suc n \\<longrightarrow>\n          (\\<exists>a b. L\\<down>a = Some b) \\<Longrightarrow>\n       \\<forall>n.\n          |(a # L)| = Suc n \\<longrightarrow>\n          (\\<exists>aa b. (a # L)\\<down>aa = Some b)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       (\\<exists>n. |L| = Suc n) \\<longrightarrow>\n       (\\<exists>a b. L\\<down>a = Some b) \\<Longrightarrow>\n       \\<exists>aa.\n          a \\<noteq> aa \\<longrightarrow> (\\<exists>b. L\\<down>aa = Some b)", "apply (rule_tac x=a in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma AL_Size_UpdateSuc:\"L\\<down>a = None \\<Longrightarrow> |L[a\\<mapsto>b]| = Suc |L|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L\\<down>a = None \\<Longrightarrow> |L[a\\<mapsto>b]| = Suc |L|", "apply (induct L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. []\\<down>a = None \\<Longrightarrow> |[][a\\<mapsto>b]| = Suc |[]|\n 2. \\<And>aa L.\n       \\<lbrakk>L\\<down>a = None \\<Longrightarrow>\n                |L[a\\<mapsto>b]| = Suc |L|;\n        (aa # L)\\<down>a = None\\<rbrakk>\n       \\<Longrightarrow> |(aa # L)[a\\<mapsto>b]| = Suc |(aa # L)|", "apply (simp add: upd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa L.\n       \\<lbrakk>L\\<down>a = None \\<Longrightarrow>\n                |L[a\\<mapsto>b]| = Suc |L|;\n        (aa # L)\\<down>a = None\\<rbrakk>\n       \\<Longrightarrow> |(aa # L)[a\\<mapsto>b]| = Suc |(aa # L)|", "apply (simp add: upd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa L.\n       \\<lbrakk>L\\<down>a = None \\<Longrightarrow>\n                |(delete (delete L a) a)| = |L|;\n        (if fst aa = a then Some (snd aa) else L\\<down>a) = None\\<rbrakk>\n       \\<Longrightarrow> (fst aa = a \\<longrightarrow>\n                          |(delete (delete L a) a)| =\n                          Suc |(delete L a)|) \\<and>\n                         (fst aa \\<noteq> a \\<longrightarrow>\n                          |(delete (delete (delete L a) a) (fst aa))| =\n                          |(delete L (fst aa))|)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b L.\n       \\<lbrakk>L\\<down>a = None \\<Longrightarrow>\n                |(delete (delete L a) a)| = |L|;\n        (if aa = a then Some (snd (aa, b)) else L\\<down>a) = None\\<rbrakk>\n       \\<Longrightarrow> (aa = a \\<longrightarrow>\n                          |(delete (delete L a) a)| =\n                          Suc |(delete L a)|) \\<and>\n                         (aa \\<noteq> a \\<longrightarrow>\n                          |(delete (delete (delete L a) a) aa)| =\n                          |(delete L aa)|)", "apply (case_tac \"aa=a\", clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b L.\n       \\<lbrakk>L\\<down>a = None \\<Longrightarrow>\n                |(delete (delete L a) a)| = |L|;\n        (if aa = a then Some (snd (aa, b)) else L\\<down>a) = None;\n        aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> (aa = a \\<longrightarrow>\n                          |(delete (delete L a) a)| =\n                          Suc |(delete L a)|) \\<and>\n                         (aa \\<noteq> a \\<longrightarrow>\n                          |(delete (delete (delete L a) a) aa)| =\n                          |(delete L aa)|)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa L.\n       \\<lbrakk>|(delete (delete L a) a)| = |L|; L\\<down>a = None;\n        aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> |(delete (delete (delete L a) a) aa)| =\n                         |(delete L aa)|", "apply (drule AL_delete3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa L.\n       \\<lbrakk>|(delete (delete L a) a)| = |L|; aa \\<noteq> a;\n        delete L a = L\\<rbrakk>\n       \\<Longrightarrow> |(delete (delete (delete L a) a) aa)| =\n                         |(delete L aa)|", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma AL_Size_SucSplit[rule_format]:\n\"\\<forall> n . |L| = Suc n \\<longrightarrow> \n  (\\<exists> a b M . |M| = n \\<and> M\\<down>a = None \\<and> L\\<down>a = Some b \\<and> (\\<forall> c . c\\<noteq> a \\<longrightarrow> M\\<down>c = L\\<down>c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       |L| = Suc n \\<longrightarrow>\n       (\\<exists>a b M.\n           |M| = n \\<and>\n           M\\<down>a = None \\<and>\n           L\\<down>a = Some b \\<and>\n           (\\<forall>c.\n               c \\<noteq> a \\<longrightarrow> M\\<down>c = L\\<down>c))", "apply (induct L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>n.\n       |[]| = Suc n \\<longrightarrow>\n       (\\<exists>a b M.\n           |M| = n \\<and>\n           M\\<down>a = None \\<and>\n           []\\<down>a = Some b \\<and>\n           (\\<forall>c.\n               c \\<noteq> a \\<longrightarrow> M\\<down>c = []\\<down>c))\n 2. \\<And>a L.\n       \\<forall>n.\n          |L| = Suc n \\<longrightarrow>\n          (\\<exists>a b M.\n              |M| = n \\<and>\n              M\\<down>a = None \\<and>\n              L\\<down>a = Some b \\<and>\n              (\\<forall>c.\n                  c \\<noteq> a \\<longrightarrow>\n                  M\\<down>c = L\\<down>c)) \\<Longrightarrow>\n       \\<forall>n.\n          |(a # L)| = Suc n \\<longrightarrow>\n          (\\<exists>aa b M.\n              |M| = n \\<and>\n              M\\<down>aa = None \\<and>\n              (a # L)\\<down>aa = Some b \\<and>\n              (\\<forall>c.\n                  c \\<noteq> aa \\<longrightarrow>\n                  M\\<down>c = (a # L)\\<down>c))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<forall>n.\n          |L| = Suc n \\<longrightarrow>\n          (\\<exists>a b M.\n              |M| = n \\<and>\n              M\\<down>a = None \\<and>\n              L\\<down>a = Some b \\<and>\n              (\\<forall>c.\n                  c \\<noteq> a \\<longrightarrow>\n                  M\\<down>c = L\\<down>c)) \\<Longrightarrow>\n       \\<forall>n.\n          |(a # L)| = Suc n \\<longrightarrow>\n          (\\<exists>aa b M.\n              |M| = n \\<and>\n              M\\<down>aa = None \\<and>\n              (a # L)\\<down>aa = Some b \\<and>\n              (\\<forall>c.\n                  c \\<noteq> aa \\<longrightarrow>\n                  M\\<down>c = (a # L)\\<down>c))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b L.\n       \\<forall>n.\n          |L| = Suc n \\<longrightarrow>\n          (\\<exists>a b M.\n              |M| = n \\<and>\n              M\\<down>a = None \\<and>\n              L\\<down>a = Some b \\<and>\n              (\\<forall>c.\n                  c \\<noteq> a \\<longrightarrow>\n                  M\\<down>c = L\\<down>c)) \\<Longrightarrow>\n       \\<exists>aa.\n          (a = aa \\<longrightarrow>\n           (\\<exists>M.\n               |M| = |(delete L aa)| \\<and>\n               M\\<down>aa = None \\<and>\n               (\\<forall>c.\n                   c \\<noteq> aa \\<longrightarrow>\n                   M\\<down>c = L\\<down>c))) \\<and>\n          (a \\<noteq> aa \\<longrightarrow>\n           (\\<exists>ba M.\n               |M| = |(delete L a)| \\<and>\n               M\\<down>aa = None \\<and>\n               L\\<down>aa = Some ba \\<and>\n               (\\<forall>c.\n                   (a = c \\<longrightarrow>\n                    c \\<noteq> aa \\<longrightarrow>\n                    M\\<down>c = Some b) \\<and>\n                   (a \\<noteq> c \\<longrightarrow>\n                    c \\<noteq> aa \\<longrightarrow>\n                    M\\<down>c = L\\<down>c))))", "apply (rule_tac x=a in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b L.\n       \\<forall>n.\n          |L| = Suc n \\<longrightarrow>\n          (\\<exists>a b M.\n              |M| = n \\<and>\n              M\\<down>a = None \\<and>\n              L\\<down>a = Some b \\<and>\n              (\\<forall>c.\n                  c \\<noteq> a \\<longrightarrow>\n                  M\\<down>c = L\\<down>c)) \\<Longrightarrow>\n       (a = a \\<longrightarrow>\n        (\\<exists>M.\n            |M| = |(delete L a)| \\<and>\n            M\\<down>a = None \\<and>\n            (\\<forall>c.\n                c \\<noteq> a \\<longrightarrow>\n                M\\<down>c = L\\<down>c))) \\<and>\n       (a \\<noteq> a \\<longrightarrow>\n        (\\<exists>ba M.\n            |M| = |(delete L a)| \\<and>\n            M\\<down>a = None \\<and>\n            L\\<down>a = Some ba \\<and>\n            (\\<forall>c.\n                (a = c \\<longrightarrow>\n                 c \\<noteq> a \\<longrightarrow> M\\<down>c = Some b) \\<and>\n                (a \\<noteq> c \\<longrightarrow>\n                 c \\<noteq> a \\<longrightarrow> M\\<down>c = L\\<down>c))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<forall>n.\n          |L| = Suc n \\<longrightarrow>\n          (\\<exists>a b M.\n              |M| = n \\<and>\n              M\\<down>a = None \\<and>\n              L\\<down>a = Some b \\<and>\n              (\\<forall>c.\n                  c \\<noteq> a \\<longrightarrow>\n                  M\\<down>c = L\\<down>c)) \\<Longrightarrow>\n       \\<exists>M.\n          |M| = |(delete L a)| \\<and>\n          M\\<down>a = None \\<and>\n          (\\<forall>c. c \\<noteq> a \\<longrightarrow> M\\<down>c = L\\<down>c)", "apply (rule_tac x=\"delete L a\" in exI, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<forall>n.\n          |L| = Suc n \\<longrightarrow>\n          (\\<exists>a b M.\n              |M| = n \\<and>\n              M\\<down>a = None \\<and>\n              L\\<down>a = Some b \\<and>\n              (\\<forall>c.\n                  c \\<noteq> a \\<longrightarrow>\n                  M\\<down>c = L\\<down>c)) \\<Longrightarrow>\n       delete L a\\<down>a = None \\<and>\n       (\\<forall>c.\n           c \\<noteq> a \\<longrightarrow> delete L a\\<down>c = L\\<down>c)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a L.\n       \\<forall>n.\n          |L| = Suc n \\<longrightarrow>\n          (\\<exists>a b M.\n              |M| = n \\<and>\n              M\\<down>a = None \\<and>\n              L\\<down>a = Some b \\<and>\n              (\\<forall>c.\n                  c \\<noteq> a \\<longrightarrow>\n                  M\\<down>c = L\\<down>c)) \\<Longrightarrow>\n       delete L a\\<down>a = None\n 2. \\<And>a L.\n       \\<forall>n.\n          |L| = Suc n \\<longrightarrow>\n          (\\<exists>a b M.\n              |M| = n \\<and>\n              M\\<down>a = None \\<and>\n              L\\<down>a = Some b \\<and>\n              (\\<forall>c.\n                  c \\<noteq> a \\<longrightarrow>\n                  M\\<down>c = L\\<down>c)) \\<Longrightarrow>\n       \\<forall>c.\n          c \\<noteq> a \\<longrightarrow> delete L a\\<down>c = L\\<down>c", "apply (rule AL_delete1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<forall>n.\n          |L| = Suc n \\<longrightarrow>\n          (\\<exists>a b M.\n              |M| = n \\<and>\n              M\\<down>a = None \\<and>\n              L\\<down>a = Some b \\<and>\n              (\\<forall>c.\n                  c \\<noteq> a \\<longrightarrow>\n                  M\\<down>c = L\\<down>c)) \\<Longrightarrow>\n       \\<forall>c.\n          c \\<noteq> a \\<longrightarrow> delete L a\\<down>c = L\\<down>c", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L c.\n       \\<lbrakk>\\<forall>n.\n                   |L| = Suc n \\<longrightarrow>\n                   (\\<exists>a b M.\n                       |M| = n \\<and>\n                       M\\<down>a = None \\<and>\n                       L\\<down>a = Some b \\<and>\n                       (\\<forall>c.\n                           c \\<noteq> a \\<longrightarrow>\n                           M\\<down>c = L\\<down>c));\n        c \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> delete L a\\<down>c = L\\<down>c", "apply (erule AL_delete2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma updSizeAux[rule_format]: \n\"\\<forall> h a obj obj1 . |h[a\\<mapsto>obj1]| = n \\<longrightarrow> h\\<down>a = Some obj \\<longrightarrow> |h| = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h a obj obj1.\n       |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n       h\\<down>a = Some obj \\<longrightarrow> |h| = n", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>h a obj obj1.\n       |h[a\\<mapsto>obj1]| = 0 \\<longrightarrow>\n       h\\<down>a = Some obj \\<longrightarrow> |h| = 0\n 2. \\<And>n.\n       \\<forall>h a obj obj1.\n          |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n          h\\<down>a = Some obj \\<longrightarrow> |h| = n \\<Longrightarrow>\n       \\<forall>h a obj obj1.\n          |h[a\\<mapsto>obj1]| = Suc n \\<longrightarrow>\n          h\\<down>a = Some obj \\<longrightarrow> |h| = Suc n", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h a obj1 obj.\n       \\<lbrakk>|h[a\\<mapsto>obj1]| = 0; h\\<down>a = Some obj\\<rbrakk>\n       \\<Longrightarrow> |h| = 0\n 2. \\<And>n.\n       \\<forall>h a obj obj1.\n          |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n          h\\<down>a = Some obj \\<longrightarrow> |h| = n \\<Longrightarrow>\n       \\<forall>h a obj obj1.\n          |h[a\\<mapsto>obj1]| = Suc n \\<longrightarrow>\n          h\\<down>a = Some obj \\<longrightarrow> |h| = Suc n", "apply (drule_tac a=a in AL_Size_Zero)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h a obj1 obj.\n       \\<lbrakk>h\\<down>a = Some obj;\n        None = h[a\\<mapsto>obj1]\\<down>a\\<rbrakk>\n       \\<Longrightarrow> |h| = 0\n 2. \\<And>n.\n       \\<forall>h a obj obj1.\n          |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n          h\\<down>a = Some obj \\<longrightarrow> |h| = n \\<Longrightarrow>\n       \\<forall>h a obj obj1.\n          |h[a\\<mapsto>obj1]| = Suc n \\<longrightarrow>\n          h\\<down>a = Some obj \\<longrightarrow> |h| = Suc n", "apply (simp add: AL_update1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>h a obj obj1.\n          |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n          h\\<down>a = Some obj \\<longrightarrow> |h| = n \\<Longrightarrow>\n       \\<forall>h a obj obj1.\n          |h[a\\<mapsto>obj1]| = Suc n \\<longrightarrow>\n          h\\<down>a = Some obj \\<longrightarrow> |h| = Suc n", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n h a obj obj1.\n       \\<lbrakk>\\<forall>h a obj obj1.\n                   |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n                   h\\<down>a = Some obj \\<longrightarrow> |h| = n;\n        |h[a\\<mapsto>obj1]| = Suc n; h\\<down>a = Some obj\\<rbrakk>\n       \\<Longrightarrow> |h| = Suc n", "apply (case_tac h, clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n h a obj obj1.\n       \\<lbrakk>\\<forall>h a obj obj1.\n                   |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n                   h\\<down>a = Some obj \\<longrightarrow> |h| = n;\n        |[][a\\<mapsto>obj1]| = Suc n; []\\<down>a = Some obj\\<rbrakk>\n       \\<Longrightarrow> |[]| = Suc n\n 2. \\<And>n h a obj obj1 aa list.\n       \\<lbrakk>\\<forall>h a obj obj1.\n                   |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n                   h\\<down>a = Some obj \\<longrightarrow> |h| = n;\n        |h[a\\<mapsto>obj1]| = Suc n; h\\<down>a = Some obj;\n        h = aa # list\\<rbrakk>\n       \\<Longrightarrow> |h| = Suc n", "apply (erule thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n h a obj obj1.\n       \\<lbrakk>|[][a\\<mapsto>obj1]| = Suc n; []\\<down>a = Some obj\\<rbrakk>\n       \\<Longrightarrow> |[]| = Suc n\n 2. \\<And>n h a obj obj1 aa list.\n       \\<lbrakk>\\<forall>h a obj obj1.\n                   |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n                   h\\<down>a = Some obj \\<longrightarrow> |h| = n;\n        |h[a\\<mapsto>obj1]| = Suc n; h\\<down>a = Some obj;\n        h = aa # list\\<rbrakk>\n       \\<Longrightarrow> |h| = Suc n", "apply (simp add: AL_emp1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n h a obj obj1 aa list.\n       \\<lbrakk>\\<forall>h a obj obj1.\n                   |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n                   h\\<down>a = Some obj \\<longrightarrow> |h| = n;\n        |h[a\\<mapsto>obj1]| = Suc n; h\\<down>a = Some obj;\n        h = aa # list\\<rbrakk>\n       \\<Longrightarrow> |h| = Suc n", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>\\<forall>h a obj obj1.\n                   |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n                   h\\<down>a = Some obj \\<longrightarrow> |h| = n;\n        |((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (case_tac \"aa=a\", clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>\\<forall>h a obj obj1.\n                   |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n                   h\\<down>a = Some obj \\<longrightarrow> |h| = n;\n        |((a, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((a, b) # list)\\<down>a = Some obj\\<rbrakk>\n       \\<Longrightarrow> |((a, b) # list)| = Suc n\n 2. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>\\<forall>h a obj obj1.\n                   |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n                   h\\<down>a = Some obj \\<longrightarrow> |h| = n;\n        |((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (erule thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((a, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((a, b) # list)\\<down>a = Some obj\\<rbrakk>\n       \\<Longrightarrow> |((a, b) # list)| = Suc n\n 2. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>\\<forall>h a obj obj1.\n                   |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n                   h\\<down>a = Some obj \\<longrightarrow> |h| = n;\n        |((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (simp add: upd_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n a obj b list.\n       \\<lbrakk>|(delete (delete list a) a)| = n; b = obj\\<rbrakk>\n       \\<Longrightarrow> |(delete list a)| = n\n 2. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>\\<forall>h a obj obj1.\n                   |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n                   h\\<down>a = Some obj \\<longrightarrow> |h| = n;\n        |((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (subgoal_tac \"(delete list a) = (delete (delete list a) a)\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n a obj b list.\n       \\<lbrakk>|(delete (delete list a) a)| = n; b = obj\\<rbrakk>\n       \\<Longrightarrow> delete list a = delete (delete list a) a\n 2. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>\\<forall>h a obj obj1.\n                   |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n                   h\\<down>a = Some obj \\<longrightarrow> |h| = n;\n        |((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (rule AL_delete_idempotent)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>\\<forall>h a obj obj1.\n                   |h[a\\<mapsto>obj1]| = n \\<longrightarrow>\n                   h\\<down>a = Some obj \\<longrightarrow> |h| = n;\n        |((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (erule_tac x=\"delete list aa\" in allE, erule_tac x=a in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        \\<forall>obj obj1.\n           |(delete list aa)[a\\<mapsto>obj1]| = n \\<longrightarrow>\n           delete list aa\\<down>a = Some obj \\<longrightarrow>\n           |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (erule_tac x=obj in allE, erule_tac x=obj1 in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        |(delete list aa)[a\\<mapsto>obj1]| = n \\<longrightarrow>\n        delete list aa\\<down>a = Some obj \\<longrightarrow>\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> |(delete list aa)[a\\<mapsto>obj1]| = n\n 2. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        delete list aa\\<down>a = Some obj \\<longrightarrow>\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (simp add: upd_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete (delete list a) a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> Suc |(delete (delete (delete list aa) a) a)| = n\n 2. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        delete list aa\\<down>a = Some obj \\<longrightarrow>\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (subgoal_tac \"(delete (delete (delete list aa) a) a) = (delete (delete (delete list a) a) aa)\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete (delete list a) a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> delete (delete (delete list aa) a) a =\n                         delete (delete (delete list a) a) aa\n 2. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        delete list aa\\<down>a = Some obj \\<longrightarrow>\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (subgoal_tac \"(delete (delete list a) a) = (delete list a)\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete list a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a;\n        delete (delete list a) a = delete list a\\<rbrakk>\n       \\<Longrightarrow> delete (delete (delete list aa) a) a =\n                         delete (delete list a) aa\n 2. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete (delete list a) a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> delete (delete list a) a = delete list a\n 3. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        delete list aa\\<down>a = Some obj \\<longrightarrow>\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (subgoal_tac \"delete (delete (delete list aa) a) a = delete (delete list aa) a\", simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete list a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a;\n        delete (delete list a) a = delete list a;\n        delete (delete (delete list aa) a) a =\n        delete (delete list aa) a\\<rbrakk>\n       \\<Longrightarrow> delete (delete list aa) a =\n                         delete (delete list a) aa\n 2. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete list a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a;\n        delete (delete list a) a = delete list a\\<rbrakk>\n       \\<Longrightarrow> delete (delete (delete list aa) a) a =\n                         delete (delete list aa) a\n 3. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete (delete list a) a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> delete (delete list a) a = delete list a\n 4. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        delete list aa\\<down>a = Some obj \\<longrightarrow>\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (rule AL_delete_commutative)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete list a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a;\n        delete (delete list a) a = delete list a\\<rbrakk>\n       \\<Longrightarrow> delete (delete (delete list aa) a) a =\n                         delete (delete list aa) a\n 2. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete (delete list a) a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> delete (delete list a) a = delete list a\n 3. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        delete list aa\\<down>a = Some obj \\<longrightarrow>\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (subgoal_tac \"delete (delete list aa) a = delete (delete (delete list aa) a) a\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete list a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a;\n        delete (delete list a) a = delete list a\\<rbrakk>\n       \\<Longrightarrow> delete (delete list aa) a =\n                         delete (delete (delete list aa) a) a\n 2. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete (delete list a) a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> delete (delete list a) a = delete list a\n 3. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        delete list aa\\<down>a = Some obj \\<longrightarrow>\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (rule AL_delete_idempotent)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete (delete list a) a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> delete (delete list a) a = delete list a\n 2. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        delete list aa\\<down>a = Some obj \\<longrightarrow>\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (subgoal_tac \"delete list a = delete (delete list a) a\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete (delete list a) a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> delete list a = delete (delete list a) a\n 2. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        delete list aa\\<down>a = Some obj \\<longrightarrow>\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (rule AL_delete_idempotent)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        delete list aa\\<down>a = Some obj \\<longrightarrow>\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> delete list aa\\<down>a = Some obj\n 2. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (simp add: upd_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete (delete list a) a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> delete list aa\\<down>a = Some obj\n 2. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply (rule AL_delete5)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete (delete list a) a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> aa\n 2. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete (delete list a) a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> list\\<down>a = Some obj\n 3. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n a obj aa list.\n       \\<lbrakk>Suc |(delete (delete (delete list a) a) aa)| = n;\n        list\\<down>a = Some obj; aa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> list\\<down>a = Some obj\n 2. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n h a obj obj1 aa b list.\n       \\<lbrakk>|((aa, b) # list)[a\\<mapsto>obj1]| = Suc n;\n        ((aa, b) # list)\\<down>a = Some obj; aa \\<noteq> a;\n        |(delete list aa)| = n\\<rbrakk>\n       \\<Longrightarrow> |((aa, b) # list)| = Suc n", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma updSize: \"h\\<down>a = Some obj \\<Longrightarrow> |h[a\\<mapsto>obj1]| = |h|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<down>a = Some obj \\<Longrightarrow> |h[a\\<mapsto>obj1]| = |h|", "by (insert updSizeAux [of h a obj1 \"|h[a\\<mapsto>obj1]|\" obj], simp)"], ["", "(*>*)"], ["", "text\\<open>Some obvious basic properties of association lists and their\noperations are easily proven, but have been suppressed\nduring the document preparation.\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}