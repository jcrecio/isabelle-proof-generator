{"file_name": "/home/qj213/afp-2021-10-22/thys/Minimal_SSA/Irreducible.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Minimal_SSA", "problem_names": ["lemma condensation_finite: \"finite (condensation_edges g P)\"", "lemma condensation_nodes_edges: \"(condensation_edges g P) \\<subseteq> (condensation_nodes g P \\<times> condensation_nodes g P)\"", "lemma condensation_edge_impl_path:\nassumes \"(a, b) \\<in> (condensation_edges g P)\"\nassumes \"(\\<phi>\\<^sub>a \\<in> a)\"\nassumes \"(\\<phi>\\<^sub>b \\<in> b)\"\nshows \"(\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\"", "lemma path_in_condensation_impl_path:\nassumes \"(a, b) \\<in> (condensation_edges g P)\\<^sup>+\"\nassumes \"(\\<phi>\\<^sub>a \\<in> a)\"\nassumes \"(\\<phi>\\<^sub>b \\<in> b)\"\nshows \"(\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\"", "lemma condensation_acyclic: \"acyclic (condensation_edges g P)\"", "lemma Ex_condensation_leaf:\nassumes \"P \\<noteq> {}\"\nshows \"\\<exists>leaf. leaf \\<in> (condensation_nodes g P) \\<and> (\\<forall> scc.(leaf, scc) \\<notin> condensation_edges g P)\"", "lemma scc_in_P:\nassumes \"scc \\<in> condensation_nodes g P\"\nshows \"scc \\<subseteq> P\"", "lemma redundant_scc_phis:\nassumes \"redundant_set g P\" \"scc \\<in> condensation_nodes g P\" \"x \\<in> scc\"\nshows \"phi g x \\<noteq> None\"", "lemma 1:\nassumes \"redundant_set g P\"\nshows \"\\<exists>scc \\<subseteq> P. redundant_scc g P scc\"", "lemma reachable_props:\n  assumes \"\\<phi>' \\<in> reachable g \\<phi>\"\n  shows \"(phiArg g)\\<^sup>*\\<^sup>* \\<phi> \\<phi>'\" and \"unnecessaryPhi g \\<phi>'\"", "lemma preds_finite: \"finite (trueArgs g \\<phi>)\"", "lemma few_preds_redundant:\nassumes \"card (trueArgs g \\<phi>) < 2\" \"unnecessaryPhi g \\<phi>\"\nshows \"redundant_set g (reachable g \\<phi>)\"", "lemma phiArg_trancl_same_var:\nassumes \"(phiArg g)\\<^sup>+\\<^sup>+ \\<phi> n\"\nshows \"var g \\<phi> = var g n\"", "lemma phiArg_disjoint_paths_extend:\nassumes \"var g r = V\" and \"var g s = V\" and \"r \\<in> allVars g\" and \"s \\<in> allVars g\"\nand \"V \\<in> oldDefs g n\" and \"V \\<in> oldDefs g m\"\nand \"g \\<turnstile> n-ns\\<rightarrow>defNode g r\" and \"g \\<turnstile> m-ms\\<rightarrow>defNode g s\"\nand \"set ns \\<inter> set ms = {}\"\nand \"phiArg g \\<phi>\\<^sub>r r\"\nobtains ns'\nwhere \"g \\<turnstile> n-ns@ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r\"\nand \"set (butlast (ns@ns')) \\<inter> set ms = {}\"", "lemma reachable_same_var:\nassumes \"\\<phi>' \\<in> reachable g \\<phi>\"\nshows \"var g \\<phi> = var g \\<phi>'\"", "lemma \\<phi>_node_no_defs:\nassumes \"unnecessaryPhi g \\<phi>\" \"\\<phi> \\<in> allVars g\" \"var g \\<phi> \\<in> oldDefs g n\"\nshows \"defNode g \\<phi> \\<noteq> n\"", "lemma defNode_differ_aux:\nassumes \"\\<phi>\\<^sub>s \\<in> reachable g \\<phi>\" \"\\<phi> \\<in> allVars g\" \"s \\<in> allVars g\" \"\\<phi>\\<^sub>s \\<noteq> s\" \"var g \\<phi> = var g s\"\nshows \"defNode g \\<phi>\\<^sub>s \\<noteq> defNode g s\"", "theorem no_redundant_set_minimal:\nassumes no_redundant_set: \"\\<not>(\\<exists>P. redundant_set g P)\"\nshows \"cytronMinimal g\""], "translations": [["", "lemma condensation_finite: \"finite (condensation_edges g P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (condensation_edges g P)", "txt \\<open>The set of edges of the condensation graph, spanning at most all $\\phi$ nodes and their arguments (both of which are finite sets), is finite itself.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (condensation_edges g P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (condensation_edges g P)", "let ?phiEdges=\"{(a,b). phiArg g a b}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (condensation_edges g P)", "have \"finite ?phiEdges\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(a, b). phiArg g a b}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {(a, b). phiArg g a b}", "let ?phiDomRan=\"(dom (phi g) \\<times> \\<Union> (set ` (ran (phi g))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {(a, b). phiArg g a b}", "from phi_finite"], ["proof (chain)\npicking this:\n  finite (dom (phi ?g))", "have \"finite ?phiDomRan\""], ["proof (prove)\nusing this:\n  finite (dom (phi ?g))\n\ngoal (1 subgoal):\n 1. finite (dom (phi g) \\<times> \\<Union> (set ` ran (phi g)))", "by (simp add: imageE phi_finite map_dom_ran_finite)"], ["proof (state)\nthis:\n  finite (dom (phi g) \\<times> \\<Union> (set ` ran (phi g)))\n\ngoal (1 subgoal):\n 1. finite {(a, b). phiArg g a b}", "have \"?phiEdges \\<subseteq> ?phiDomRan\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). phiArg g a b}\n    \\<subseteq> dom (phi g) \\<times> \\<Union> (set ` ran (phi g))", "apply (rule subst[of \"\\<forall>a \\<in> ?phiEdges. a \\<in> ?phiDomRan\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<forall>a\\<in>{(a, b). phiArg g a b}.\n        a \\<in> dom (phi g) \\<times> \\<Union> (set ` ran (phi g))) =\n    ({(a, b). phiArg g a b}\n     \\<subseteq> dom (phi g) \\<times> \\<Union> (set ` ran (phi g)))\n 2. \\<forall>a\\<in>{(a, b). phiArg g a b}.\n       a \\<in> dom (phi g) \\<times> \\<Union> (set ` ran (phi g))", "apply (simp_all add: subset_eq[symmetric] phiArg_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). \\<exists>vs. phi g a = Some vs \\<and> b \\<in> set vs}\n    \\<subseteq> dom (phi g) \\<times> \\<Union> (set ` ran (phi g))", "by (auto simp: ran_def)"], ["proof (state)\nthis:\n  {(a, b). phiArg g a b}\n  \\<subseteq> dom (phi g) \\<times> \\<Union> (set ` ran (phi g))\n\ngoal (1 subgoal):\n 1. finite {(a, b). phiArg g a b}", "with \\<open>finite ?phiDomRan\\<close>"], ["proof (chain)\npicking this:\n  finite (dom (phi g) \\<times> \\<Union> (set ` ran (phi g)))\n  {(a, b). phiArg g a b}\n  \\<subseteq> dom (phi g) \\<times> \\<Union> (set ` ran (phi g))", "show \"finite ?phiEdges\""], ["proof (prove)\nusing this:\n  finite (dom (phi g) \\<times> \\<Union> (set ` ran (phi g)))\n  {(a, b). phiArg g a b}\n  \\<subseteq> dom (phi g) \\<times> \\<Union> (set ` ran (phi g))\n\ngoal (1 subgoal):\n 1. finite {(a, b). phiArg g a b}", "by (rule Finite_Set.rev_finite_subset)"], ["proof (state)\nthis:\n  finite {(a, b). phiArg g a b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {(a, b). phiArg g a b}\n\ngoal (1 subgoal):\n 1. finite (condensation_edges g P)", "hence \"\\<And>f. finite (f ` (?phiEdges \\<inter> (P \\<times> P)))\""], ["proof (prove)\nusing this:\n  finite {(a, b). phiArg g a b}\n\ngoal (1 subgoal):\n 1. \\<And>f. finite (f ` Restr {(a, b). phiArg g a b} P)", "by auto"], ["proof (state)\nthis:\n  finite (?f1 ` Restr {(a, b). phiArg g a b} P)\n\ngoal (1 subgoal):\n 1. finite (condensation_edges g P)", "thus \"finite (condensation_edges g P)\""], ["proof (prove)\nusing this:\n  finite (?f1 ` Restr {(a, b). phiArg g a b} P)\n\ngoal (1 subgoal):\n 1. finite (condensation_edges g P)", "unfolding condensation_edges_def induced_phi_graph_def"], ["proof (prove)\nusing this:\n  finite (?f1 ` Restr {(a, b). phiArg g a b} P)\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(x, y).\n          (scc_of (Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P) x,\n           scc_of (Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P)\n            y)) `\n      Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P -\n      Id)", "by auto"], ["proof (state)\nthis:\n  finite (condensation_edges g P)\n\ngoal:\nNo subgoals!", "qed"], ["", "txt \\<open>auxiliary lemmas for acyclicity\\<close>"], ["", "lemma condensation_nodes_edges: \"(condensation_edges g P) \\<subseteq> (condensation_nodes g P \\<times> condensation_nodes g P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. condensation_edges g P\n    \\<subseteq> condensation_nodes g P \\<times> condensation_nodes g P", "unfolding condensation_edges_def condensation_nodes_def induced_phi_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y).\n        (scc_of (Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P) x,\n         scc_of (Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P) y)) `\n    Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P -\n    Id\n    \\<subseteq> scc_of\n                 (Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P) `\n                P \\<times>\n                scc_of\n                 (Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P) `\n                P", "by auto"], ["", "lemma condensation_edge_impl_path:\nassumes \"(a, b) \\<in> (condensation_edges g P)\"\nassumes \"(\\<phi>\\<^sub>a \\<in> a)\"\nassumes \"(\\<phi>\\<^sub>b \\<in> b)\"\nshows \"(\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "unfolding condensation_edges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "from assms(1)"], ["proof (chain)\npicking this:\n  (a, b) \\<in> condensation_edges g P", "obtain x y where x_y_props:\n    \"(x, y) \\<in> (induced_phi_graph g P)\"\n    \"a = scc_of (induced_phi_graph g P) x\"\n    \"b = scc_of (induced_phi_graph g P) y\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> condensation_edges g P\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>(x, y) \\<in> induced_phi_graph g P;\n         a = scc_of (induced_phi_graph g P) x;\n         b = scc_of (induced_phi_graph g P) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding condensation_edges_def"], ["proof (prove)\nusing this:\n  (a, b)\n  \\<in> (\\<lambda>(x, y).\n            (scc_of (induced_phi_graph g P) x,\n             scc_of (induced_phi_graph g P) y)) `\n        induced_phi_graph g P -\n        Id\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>(x, y) \\<in> induced_phi_graph g P;\n         a = scc_of (induced_phi_graph g P) x;\n         b = scc_of (induced_phi_graph g P) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x, y) \\<in> induced_phi_graph g P\n  a = scc_of (induced_phi_graph g P) x\n  b = scc_of (induced_phi_graph g P) y\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "hence \"x \\<in> a\" \"y \\<in> b\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> induced_phi_graph g P\n  a = scc_of (induced_phi_graph g P) x\n  b = scc_of (induced_phi_graph g P) y\n\ngoal (1 subgoal):\n 1. x \\<in> a &&& y \\<in> b", "by auto"], ["proof (state)\nthis:\n  x \\<in> a\n  y \\<in> b\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "txt \\<open>All that's left is to combine these paths.\\<close>"], ["proof (state)\nthis:\n  x \\<in> a\n  y \\<in> b\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "with assms(2) x_y_props(2)"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>a \\<in> a\n  a = scc_of (induced_phi_graph g P) x\n  x \\<in> a\n  y \\<in> b", "have \"(\\<phi>\\<^sub>a, x) \\<in> (induced_phi_graph g P)\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>a \\<in> a\n  a = scc_of (induced_phi_graph g P) x\n  x \\<in> a\n  y \\<in> b\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, x) \\<in> (induced_phi_graph g P)\\<^sup>*", "by (meson is_scc_connected scc_of_is_scc)"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>a, x) \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>a, x) \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "with assms(3) x_y_props(3) \\<open>y \\<in> b\\<close>"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>b \\<in> b\n  b = scc_of (induced_phi_graph g P) y\n  y \\<in> b\n  (\\<phi>\\<^sub>a, x) \\<in> (induced_phi_graph g P)\\<^sup>*", "have \"(y, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>b \\<in> b\n  b = scc_of (induced_phi_graph g P) y\n  y \\<in> b\n  (\\<phi>\\<^sub>a, x) \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (y, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "by (meson is_scc_connected scc_of_is_scc)"], ["proof (state)\nthis:\n  (y, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  (\\<phi>\\<^sub>a, x) \\<in> (induced_phi_graph g P)\\<^sup>*\n  (y, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "show \"(\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\""], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>a, x) \\<in> (induced_phi_graph g P)\\<^sup>*\n  (y, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "using x_y_props(1)"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>a, x) \\<in> (induced_phi_graph g P)\\<^sup>*\n  (y, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\n  (x, y) \\<in> induced_phi_graph g P\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_in_condensation_impl_path:\nassumes \"(a, b) \\<in> (condensation_edges g P)\\<^sup>+\"\nassumes \"(\\<phi>\\<^sub>a \\<in> a)\"\nassumes \"(\\<phi>\\<^sub>b \\<in> b)\"\nshows \"(\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  (a, b) \\<in> (condensation_edges g P)\\<^sup>+\n  \\<phi>\\<^sub>a \\<in> a\n  \\<phi>\\<^sub>b \\<in> b\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "proof (induction arbitrary: \\<phi>\\<^sub>b rule:trancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> condensation_edges g P; \\<phi>\\<^sub>a \\<in> a;\n        \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*\n 2. \\<And>y z \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> (condensation_edges g P)\\<^sup>+;\n        (y, z) \\<in> condensation_edges g P;\n        \\<And>\\<phi>\\<^sub>b.\n           \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n           \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                             \\<in> (induced_phi_graph g P)\\<^sup>*;\n        \\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> z\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*", "fix y z \\<phi>\\<^sub>b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> condensation_edges g P; \\<phi>\\<^sub>a \\<in> a;\n        \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*\n 2. \\<And>y z \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> (condensation_edges g P)\\<^sup>+;\n        (y, z) \\<in> condensation_edges g P;\n        \\<And>\\<phi>\\<^sub>b.\n           \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n           \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                             \\<in> (induced_phi_graph g P)\\<^sup>*;\n        \\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> z\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*", "assume \"(y, z) \\<in> condensation_edges g P\""], ["proof (state)\nthis:\n  (y, z) \\<in> condensation_edges g P\n\ngoal (2 subgoals):\n 1. \\<And>y \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> condensation_edges g P; \\<phi>\\<^sub>a \\<in> a;\n        \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*\n 2. \\<And>y z \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> (condensation_edges g P)\\<^sup>+;\n        (y, z) \\<in> condensation_edges g P;\n        \\<And>\\<phi>\\<^sub>b.\n           \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n           \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                             \\<in> (induced_phi_graph g P)\\<^sup>*;\n        \\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> z\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*", "hence \"is_scc (induced_phi_graph g P) y\""], ["proof (prove)\nusing this:\n  (y, z) \\<in> condensation_edges g P\n\ngoal (1 subgoal):\n 1. is_scc (induced_phi_graph g P) y", "unfolding condensation_edges_def"], ["proof (prove)\nusing this:\n  (y, z)\n  \\<in> (\\<lambda>(x, y).\n            (scc_of (induced_phi_graph g P) x,\n             scc_of (induced_phi_graph g P) y)) `\n        induced_phi_graph g P -\n        Id\n\ngoal (1 subgoal):\n 1. is_scc (induced_phi_graph g P) y", "by auto"], ["proof (state)\nthis:\n  is_scc (induced_phi_graph g P) y\n\ngoal (2 subgoals):\n 1. \\<And>y \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> condensation_edges g P; \\<phi>\\<^sub>a \\<in> a;\n        \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*\n 2. \\<And>y z \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> (condensation_edges g P)\\<^sup>+;\n        (y, z) \\<in> condensation_edges g P;\n        \\<And>\\<phi>\\<^sub>b.\n           \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n           \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                             \\<in> (induced_phi_graph g P)\\<^sup>*;\n        \\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> z\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*", "hence \"\\<exists>\\<phi>\\<^sub>y. \\<phi>\\<^sub>y \\<in> y\""], ["proof (prove)\nusing this:\n  is_scc (induced_phi_graph g P) y\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>y. \\<phi>\\<^sub>y \\<in> y", "using scc_non_empty'"], ["proof (prove)\nusing this:\n  is_scc (induced_phi_graph g P) y\n  is_scc ?E ?U \\<Longrightarrow> ?U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>y. \\<phi>\\<^sub>y \\<in> y", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>y. \\<phi>\\<^sub>y \\<in> y\n\ngoal (2 subgoals):\n 1. \\<And>y \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> condensation_edges g P; \\<phi>\\<^sub>a \\<in> a;\n        \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*\n 2. \\<And>y z \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> (condensation_edges g P)\\<^sup>+;\n        (y, z) \\<in> condensation_edges g P;\n        \\<And>\\<phi>\\<^sub>b.\n           \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n           \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                             \\<in> (induced_phi_graph g P)\\<^sup>*;\n        \\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> z\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<phi>\\<^sub>y. \\<phi>\\<^sub>y \\<in> y", "obtain \\<phi>\\<^sub>y where \\<phi>\\<^sub>y_in_y: \"\\<phi>\\<^sub>y \\<in> y\""], ["proof (prove)\nusing this:\n  \\<exists>\\<phi>\\<^sub>y. \\<phi>\\<^sub>y \\<in> y\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>\\<^sub>y.\n        \\<phi>\\<^sub>y \\<in> y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>y \\<in> y\n\ngoal (2 subgoals):\n 1. \\<And>y \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> condensation_edges g P; \\<phi>\\<^sub>a \\<in> a;\n        \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*\n 2. \\<And>y z \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> (condensation_edges g P)\\<^sup>+;\n        (y, z) \\<in> condensation_edges g P;\n        \\<And>\\<phi>\\<^sub>b.\n           \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n           \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                             \\<in> (induced_phi_graph g P)\\<^sup>*;\n        \\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> z\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*", "assume \\<phi>\\<^sub>b_elem: \"\\<phi>\\<^sub>b \\<in> z\""], ["proof (state)\nthis:\n  \\<phi>\\<^sub>b \\<in> z\n\ngoal (2 subgoals):\n 1. \\<And>y \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> condensation_edges g P; \\<phi>\\<^sub>a \\<in> a;\n        \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*\n 2. \\<And>y z \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> (condensation_edges g P)\\<^sup>+;\n        (y, z) \\<in> condensation_edges g P;\n        \\<And>\\<phi>\\<^sub>b.\n           \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n           \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                             \\<in> (induced_phi_graph g P)\\<^sup>*;\n        \\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> z\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*", "assume \"\\<And>\\<phi>\\<^sub>b. \\<phi>\\<^sub>a \\<in> a \\<Longrightarrow> \\<phi>\\<^sub>b \\<in> y \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\""], ["proof (state)\nthis:\n  \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; ?\\<phi>\\<^sub>b1 \\<in> y\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>a, ?\\<phi>\\<^sub>b1)\n                    \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>y \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> condensation_edges g P; \\<phi>\\<^sub>a \\<in> a;\n        \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*\n 2. \\<And>y z \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> (condensation_edges g P)\\<^sup>+;\n        (y, z) \\<in> condensation_edges g P;\n        \\<And>\\<phi>\\<^sub>b.\n           \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n           \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                             \\<in> (induced_phi_graph g P)\\<^sup>*;\n        \\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> z\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*", "with assms(2) \\<phi>\\<^sub>y_in_y"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>a \\<in> a\n  \\<phi>\\<^sub>y \\<in> y\n  \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; ?\\<phi>\\<^sub>b1 \\<in> y\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>a, ?\\<phi>\\<^sub>b1)\n                    \\<in> (induced_phi_graph g P)\\<^sup>*", "have \\<phi>\\<^sub>a_to_\\<phi>\\<^sub>y: \"(\\<phi>\\<^sub>a, \\<phi>\\<^sub>y) \\<in> (induced_phi_graph g P)\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>a \\<in> a\n  \\<phi>\\<^sub>y \\<in> y\n  \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; ?\\<phi>\\<^sub>b1 \\<in> y\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>a, ?\\<phi>\\<^sub>b1)\n                    \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>y) \\<in> (induced_phi_graph g P)\\<^sup>*", "using condensation_edge_impl_path"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>a \\<in> a\n  \\<phi>\\<^sub>y \\<in> y\n  \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; ?\\<phi>\\<^sub>b1 \\<in> y\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>a, ?\\<phi>\\<^sub>b1)\n                    \\<in> (induced_phi_graph g P)\\<^sup>*\n  \\<lbrakk>(?a, ?b) \\<in> condensation_edges ?g ?P;\n   ?\\<phi>\\<^sub>a \\<in> ?a; ?\\<phi>\\<^sub>b \\<in> ?b\\<rbrakk>\n  \\<Longrightarrow> (?\\<phi>\\<^sub>a, ?\\<phi>\\<^sub>b)\n                    \\<in> (induced_phi_graph ?g ?P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>y) \\<in> (induced_phi_graph g P)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>a, \\<phi>\\<^sub>y) \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>y \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> condensation_edges g P; \\<phi>\\<^sub>a \\<in> a;\n        \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*\n 2. \\<And>y z \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> (condensation_edges g P)\\<^sup>+;\n        (y, z) \\<in> condensation_edges g P;\n        \\<And>\\<phi>\\<^sub>b.\n           \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n           \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                             \\<in> (induced_phi_graph g P)\\<^sup>*;\n        \\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> z\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*", "from \\<phi>\\<^sub>b_elem \\<phi>\\<^sub>y_in_y \\<open>(y, z) \\<in> condensation_edges g P\\<close>"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>b \\<in> z\n  \\<phi>\\<^sub>y \\<in> y\n  (y, z) \\<in> condensation_edges g P", "have \"(\\<phi>\\<^sub>y, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>b \\<in> z\n  \\<phi>\\<^sub>y \\<in> y\n  (y, z) \\<in> condensation_edges g P\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>y, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "using condensation_edge_impl_path"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>b \\<in> z\n  \\<phi>\\<^sub>y \\<in> y\n  (y, z) \\<in> condensation_edges g P\n  \\<lbrakk>(?a, ?b) \\<in> condensation_edges ?g ?P;\n   ?\\<phi>\\<^sub>a \\<in> ?a; ?\\<phi>\\<^sub>b \\<in> ?b\\<rbrakk>\n  \\<Longrightarrow> (?\\<phi>\\<^sub>a, ?\\<phi>\\<^sub>b)\n                    \\<in> (induced_phi_graph ?g ?P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>y, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>y, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>y \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> condensation_edges g P; \\<phi>\\<^sub>a \\<in> a;\n        \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*\n 2. \\<And>y z \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> (condensation_edges g P)\\<^sup>+;\n        (y, z) \\<in> condensation_edges g P;\n        \\<And>\\<phi>\\<^sub>b.\n           \\<lbrakk>\\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n           \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                             \\<in> (induced_phi_graph g P)\\<^sup>*;\n        \\<phi>\\<^sub>a \\<in> a; \\<phi>\\<^sub>b \\<in> z\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*", "with \\<phi>\\<^sub>a_to_\\<phi>\\<^sub>y"], ["proof (chain)\npicking this:\n  (\\<phi>\\<^sub>a, \\<phi>\\<^sub>y) \\<in> (induced_phi_graph g P)\\<^sup>*\n  (\\<phi>\\<^sub>y, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "show \"(\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\""], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>a, \\<phi>\\<^sub>y) \\<in> (induced_phi_graph g P)\\<^sup>*\n  (\\<phi>\\<^sub>y, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b) \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y \\<phi>\\<^sub>b.\n       \\<lbrakk>(a, y) \\<in> condensation_edges g P; \\<phi>\\<^sub>a \\<in> a;\n        \\<phi>\\<^sub>b \\<in> y\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>\\<^sub>a, \\<phi>\\<^sub>b)\n                         \\<in> (induced_phi_graph g P)\\<^sup>*", "qed (auto intro:condensation_edge_impl_path)"], ["", "lemma condensation_acyclic: \"acyclic (condensation_edges g P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic (condensation_edges g P)", "proof (rule acyclicI, rule allI, rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "txt \\<open>Assume there is a cycle in the condensation graph.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "assume cyclic: \"(x, x) \\<in> (condensation_edges g P)\\<^sup>+\""], ["proof (state)\nthis:\n  (x, x) \\<in> (condensation_edges g P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "have nonrefl: \"(x, x) \\<notin> (condensation_edges g P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, x) \\<notin> condensation_edges g P", "unfolding condensation_edges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, x)\n    \\<notin> (\\<lambda>(x, y).\n                 (scc_of (induced_phi_graph g P) x,\n                  scc_of (induced_phi_graph g P) y)) `\n             induced_phi_graph g P -\n             Id", "by auto"], ["proof (state)\nthis:\n  (x, x) \\<notin> condensation_edges g P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "txt \\<open>Then there must be a second SCC \\<open>b\\<close> on this path.\\<close>"], ["proof (state)\nthis:\n  (x, x) \\<notin> condensation_edges g P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "from this cyclic"], ["proof (chain)\npicking this:\n  (x, x) \\<notin> condensation_edges g P\n  (x, x) \\<in> (condensation_edges g P)\\<^sup>+", "obtain b where b_on_path: \"(x, b) \\<in> (condensation_edges g P)\" \"(b, x) \\<in> (condensation_edges g P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (x, x) \\<notin> condensation_edges g P\n  (x, x) \\<in> (condensation_edges g P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>(x, b) \\<in> condensation_edges g P;\n         (b, x) \\<in> (condensation_edges g P)\\<^sup>+\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson converse_tranclE)"], ["proof (state)\nthis:\n  (x, b) \\<in> condensation_edges g P\n  (b, x) \\<in> (condensation_edges g P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "hence \"x \\<in> (condensation_nodes g P)\" \"b \\<in> (condensation_nodes g P)\""], ["proof (prove)\nusing this:\n  (x, b) \\<in> condensation_edges g P\n  (b, x) \\<in> (condensation_edges g P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. x \\<in> condensation_nodes g P &&& b \\<in> condensation_nodes g P", "using condensation_nodes_edges"], ["proof (prove)\nusing this:\n  (x, b) \\<in> condensation_edges g P\n  (b, x) \\<in> (condensation_edges g P)\\<^sup>+\n  condensation_edges ?g ?P\n  \\<subseteq> condensation_nodes ?g ?P \\<times> condensation_nodes ?g ?P\n\ngoal (1 subgoal):\n 1. x \\<in> condensation_nodes g P &&& b \\<in> condensation_nodes g P", "by auto"], ["proof (state)\nthis:\n  x \\<in> condensation_nodes g P\n  b \\<in> condensation_nodes g P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "hence nodes_are_scc: \"is_scc (induced_phi_graph g P) x\" \"is_scc (induced_phi_graph g P) b\""], ["proof (prove)\nusing this:\n  x \\<in> condensation_nodes g P\n  b \\<in> condensation_nodes g P\n\ngoal (1 subgoal):\n 1. is_scc (induced_phi_graph g P) x &&& is_scc (induced_phi_graph g P) b", "using scc_of_is_scc"], ["proof (prove)\nusing this:\n  x \\<in> condensation_nodes g P\n  b \\<in> condensation_nodes g P\n  is_scc ?E (scc_of ?E ?v)\n\ngoal (1 subgoal):\n 1. is_scc (induced_phi_graph g P) x &&& is_scc (induced_phi_graph g P) b", "unfolding induced_phi_graph_def condensation_nodes_def"], ["proof (prove)\nusing this:\n  x \\<in> scc_of (Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P) ` P\n  b \\<in> scc_of (Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P) ` P\n  is_scc ?E (scc_of ?E ?v)\n\ngoal (1 subgoal):\n 1. is_scc (Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P) x &&&\n    is_scc (Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P) b", "by auto"], ["proof (state)\nthis:\n  is_scc (induced_phi_graph g P) x\n  is_scc (induced_phi_graph g P) b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "txt \\<open>However, the existence of this path means all nodes in @{term b} and @{term x} are mutually reachable.\\<close>"], ["proof (state)\nthis:\n  is_scc (induced_phi_graph g P) x\n  is_scc (induced_phi_graph g P) b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "have \"\\<exists>\\<phi>\\<^sub>x. \\<phi>\\<^sub>x \\<in> x\" \"\\<exists>\\<phi>\\<^sub>b. \\<phi>\\<^sub>b \\<in> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>x. \\<phi>\\<^sub>x \\<in> x &&&\n    \\<exists>\\<phi>\\<^sub>b. \\<phi>\\<^sub>b \\<in> b", "using nodes_are_scc scc_non_empty' ex_in_conv"], ["proof (prove)\nusing this:\n  is_scc (induced_phi_graph g P) x\n  is_scc (induced_phi_graph g P) b\n  is_scc ?E ?U \\<Longrightarrow> ?U \\<noteq> {}\n  (\\<exists>x. x \\<in> ?A) = (?A \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>x. \\<phi>\\<^sub>x \\<in> x &&&\n    \\<exists>\\<phi>\\<^sub>b. \\<phi>\\<^sub>b \\<in> b", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>x. \\<phi>\\<^sub>x \\<in> x\n  \\<exists>\\<phi>\\<^sub>b. \\<phi>\\<^sub>b \\<in> b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<phi>\\<^sub>x. \\<phi>\\<^sub>x \\<in> x\n  \\<exists>\\<phi>\\<^sub>b. \\<phi>\\<^sub>b \\<in> b", "obtain \\<phi>\\<^sub>x \\<phi>\\<^sub>b where \\<phi>xb_elem: \"\\<phi>\\<^sub>x \\<in> x\" \"\\<phi>\\<^sub>b \\<in> b\""], ["proof (prove)\nusing this:\n  \\<exists>\\<phi>\\<^sub>x. \\<phi>\\<^sub>x \\<in> x\n  \\<exists>\\<phi>\\<^sub>b. \\<phi>\\<^sub>b \\<in> b\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>\\<^sub>x \\<phi>\\<^sub>b.\n        \\<lbrakk>\\<phi>\\<^sub>x \\<in> x; \\<phi>\\<^sub>b \\<in> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>x \\<in> x\n  \\<phi>\\<^sub>b \\<in> b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "with nodes_are_scc(1) b_on_path path_in_condensation_impl_path condensation_edge_impl_path \\<phi>xb_elem(2)"], ["proof (chain)\npicking this:\n  is_scc (induced_phi_graph g P) x\n  (x, b) \\<in> condensation_edges g P\n  (b, x) \\<in> (condensation_edges g P)\\<^sup>+\n  \\<lbrakk>(?a, ?b) \\<in> (condensation_edges ?g ?P)\\<^sup>+;\n   ?\\<phi>\\<^sub>a \\<in> ?a; ?\\<phi>\\<^sub>b \\<in> ?b\\<rbrakk>\n  \\<Longrightarrow> (?\\<phi>\\<^sub>a, ?\\<phi>\\<^sub>b)\n                    \\<in> (induced_phi_graph ?g ?P)\\<^sup>*\n  \\<lbrakk>(?a, ?b) \\<in> condensation_edges ?g ?P;\n   ?\\<phi>\\<^sub>a \\<in> ?a; ?\\<phi>\\<^sub>b \\<in> ?b\\<rbrakk>\n  \\<Longrightarrow> (?\\<phi>\\<^sub>a, ?\\<phi>\\<^sub>b)\n                    \\<in> (induced_phi_graph ?g ?P)\\<^sup>*\n  \\<phi>\\<^sub>b \\<in> b\n  \\<phi>\\<^sub>x \\<in> x\n  \\<phi>\\<^sub>b \\<in> b", "have \"\\<phi>\\<^sub>b \\<in> x\""], ["proof (prove)\nusing this:\n  is_scc (induced_phi_graph g P) x\n  (x, b) \\<in> condensation_edges g P\n  (b, x) \\<in> (condensation_edges g P)\\<^sup>+\n  \\<lbrakk>(?a, ?b) \\<in> (condensation_edges ?g ?P)\\<^sup>+;\n   ?\\<phi>\\<^sub>a \\<in> ?a; ?\\<phi>\\<^sub>b \\<in> ?b\\<rbrakk>\n  \\<Longrightarrow> (?\\<phi>\\<^sub>a, ?\\<phi>\\<^sub>b)\n                    \\<in> (induced_phi_graph ?g ?P)\\<^sup>*\n  \\<lbrakk>(?a, ?b) \\<in> condensation_edges ?g ?P;\n   ?\\<phi>\\<^sub>a \\<in> ?a; ?\\<phi>\\<^sub>b \\<in> ?b\\<rbrakk>\n  \\<Longrightarrow> (?\\<phi>\\<^sub>a, ?\\<phi>\\<^sub>b)\n                    \\<in> (induced_phi_graph ?g ?P)\\<^sup>*\n  \\<phi>\\<^sub>b \\<in> b\n  \\<phi>\\<^sub>x \\<in> x\n  \\<phi>\\<^sub>b \\<in> b\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>b \\<in> x", "by - (rule is_scc_closed)"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>b \\<in> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "txt \\<open>This however means @{term x} and @{term b} must be the same SCC, which is a contradiction to the nonreflexivity of @{theory_text condensation_edges}.\\<close>"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>b \\<in> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "with nodes_are_scc \\<phi>xb_elem"], ["proof (chain)\npicking this:\n  is_scc (induced_phi_graph g P) x\n  is_scc (induced_phi_graph g P) b\n  \\<phi>\\<^sub>x \\<in> x\n  \\<phi>\\<^sub>b \\<in> b\n  \\<phi>\\<^sub>b \\<in> x", "have \"x = b\""], ["proof (prove)\nusing this:\n  is_scc (induced_phi_graph g P) x\n  is_scc (induced_phi_graph g P) b\n  \\<phi>\\<^sub>x \\<in> x\n  \\<phi>\\<^sub>b \\<in> b\n  \\<phi>\\<^sub>b \\<in> x\n\ngoal (1 subgoal):\n 1. x = b", "using is_scc_unique[of \"induced_phi_graph g P\"]"], ["proof (prove)\nusing this:\n  is_scc (induced_phi_graph g P) x\n  is_scc (induced_phi_graph g P) b\n  \\<phi>\\<^sub>x \\<in> x\n  \\<phi>\\<^sub>b \\<in> b\n  \\<phi>\\<^sub>b \\<in> x\n  \\<lbrakk>is_scc (induced_phi_graph g P) ?scc;\n   is_scc (induced_phi_graph g P) ?scc'; ?v \\<in> ?scc;\n   ?v \\<in> ?scc'\\<rbrakk>\n  \\<Longrightarrow> ?scc = ?scc'\n\ngoal (1 subgoal):\n 1. x = b", "by simp"], ["proof (state)\nthis:\n  x = b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "hence \"(x, x) \\<in> (condensation_edges g P)\""], ["proof (prove)\nusing this:\n  x = b\n\ngoal (1 subgoal):\n 1. (x, x) \\<in> condensation_edges g P", "using b_on_path"], ["proof (prove)\nusing this:\n  x = b\n  (x, b) \\<in> condensation_edges g P\n  (b, x) \\<in> (condensation_edges g P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, x) \\<in> condensation_edges g P", "by simp"], ["proof (state)\nthis:\n  (x, x) \\<in> condensation_edges g P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, x) \\<in> (condensation_edges g P)\\<^sup>+ \\<Longrightarrow> False", "with nonrefl"], ["proof (chain)\npicking this:\n  (x, x) \\<notin> condensation_edges g P\n  (x, x) \\<in> condensation_edges g P", "show \"False\""], ["proof (prove)\nusing this:\n  (x, x) \\<notin> condensation_edges g P\n  (x, x) \\<in> condensation_edges g P\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "txt \\<open>Since the condensation graph of a set is acyclic and finite, it must have a leaf.\\<close>"], ["", "lemma Ex_condensation_leaf:\nassumes \"P \\<noteq> {}\"\nshows \"\\<exists>leaf. leaf \\<in> (condensation_nodes g P) \\<and> (\\<forall> scc.(leaf, scc) \\<notin> condensation_edges g P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>leaf.\n       leaf \\<in> condensation_nodes g P \\<and>\n       (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>leaf.\n       leaf \\<in> condensation_nodes g P \\<and>\n       (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)", "from assms"], ["proof (chain)\npicking this:\n  P \\<noteq> {}", "obtain x where \"x \\<in> condensation_nodes g P\""], ["proof (prove)\nusing this:\n  P \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> condensation_nodes g P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding condensation_nodes_def"], ["proof (prove)\nusing this:\n  P \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> scc_of (induced_phi_graph g P) ` P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> condensation_nodes g P\n\ngoal (1 subgoal):\n 1. \\<exists>leaf.\n       leaf \\<in> condensation_nodes g P \\<and>\n       (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>leaf.\n       leaf \\<in> condensation_nodes g P \\<and>\n       (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)", "proof (rule wfE_min)"], ["proof (state)\ngoal (3 subgoals):\n 1. wf ?R\n 2. ?x \\<in> ?Q\n 3. \\<And>z.\n       \\<lbrakk>z \\<in> ?Q;\n        \\<And>y. (y, z) \\<in> ?R \\<Longrightarrow> y \\<notin> ?Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>leaf.\n                            leaf \\<in> condensation_nodes g P \\<and>\n                            (\\<forall>scc.\n                                (leaf, scc) \\<notin> condensation_edges g P)", "from condensation_finite condensation_acyclic"], ["proof (chain)\npicking this:\n  finite (condensation_edges ?g ?P)\n  acyclic (condensation_edges ?g ?P)", "show \"wf ((condensation_edges g P)\\<inverse>)\""], ["proof (prove)\nusing this:\n  finite (condensation_edges ?g ?P)\n  acyclic (condensation_edges ?g ?P)\n\ngoal (1 subgoal):\n 1. wf ((condensation_edges g P)\\<inverse>)", "by (rule finite_acyclic_wf_converse)"], ["proof (state)\nthis:\n  wf ((condensation_edges g P)\\<inverse>)\n\ngoal (2 subgoals):\n 1. ?x \\<in> ?Q\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> ?Q;\n        \\<And>y.\n           (y, z) \\<in> (condensation_edges g P)\\<inverse> \\<Longrightarrow>\n           y \\<notin> ?Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>leaf.\n                            leaf \\<in> condensation_nodes g P \\<and>\n                            (\\<forall>scc.\n                                (leaf, scc) \\<notin> condensation_edges g P)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ?x \\<in> ?Q\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> ?Q;\n        \\<And>y.\n           (y, z) \\<in> (condensation_edges g P)\\<inverse> \\<Longrightarrow>\n           y \\<notin> ?Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>leaf.\n                            leaf \\<in> condensation_nodes g P \\<and>\n                            (\\<forall>scc.\n                                (leaf, scc) \\<notin> condensation_edges g P)", "fix leaf"], ["proof (state)\ngoal (2 subgoals):\n 1. ?x \\<in> ?Q\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> ?Q;\n        \\<And>y.\n           (y, z) \\<in> (condensation_edges g P)\\<inverse> \\<Longrightarrow>\n           y \\<notin> ?Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>leaf.\n                            leaf \\<in> condensation_nodes g P \\<and>\n                            (\\<forall>scc.\n                                (leaf, scc) \\<notin> condensation_edges g P)", "assume leaf_node: \"leaf \\<in> condensation_nodes g P\""], ["proof (state)\nthis:\n  leaf \\<in> condensation_nodes g P\n\ngoal (2 subgoals):\n 1. ?x \\<in> ?Q\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> ?Q;\n        \\<And>y.\n           (y, z) \\<in> (condensation_edges g P)\\<inverse> \\<Longrightarrow>\n           y \\<notin> ?Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>leaf.\n                            leaf \\<in> condensation_nodes g P \\<and>\n                            (\\<forall>scc.\n                                (leaf, scc) \\<notin> condensation_edges g P)", "moreover"], ["proof (state)\nthis:\n  leaf \\<in> condensation_nodes g P\n\ngoal (2 subgoals):\n 1. ?x \\<in> ?Q\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> ?Q;\n        \\<And>y.\n           (y, z) \\<in> (condensation_edges g P)\\<inverse> \\<Longrightarrow>\n           y \\<notin> ?Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>leaf.\n                            leaf \\<in> condensation_nodes g P \\<and>\n                            (\\<forall>scc.\n                                (leaf, scc) \\<notin> condensation_edges g P)", "assume leaf_is_leaf: \"scc \\<notin> condensation_nodes g P\" if \"(scc, leaf) \\<in> (condensation_edges g P)\\<inverse>\" for scc"], ["proof (state)\nthis:\n  (?scc1, leaf) \\<in> (condensation_edges g P)\\<inverse> \\<Longrightarrow>\n  ?scc1 \\<notin> condensation_nodes g P\n\ngoal (2 subgoals):\n 1. ?x \\<in> ?Q\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> ?Q;\n        \\<And>y.\n           (y, z) \\<in> (condensation_edges g P)\\<inverse> \\<Longrightarrow>\n           y \\<notin> ?Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>leaf.\n                            leaf \\<in> condensation_nodes g P \\<and>\n                            (\\<forall>scc.\n                                (leaf, scc) \\<notin> condensation_edges g P)", "ultimately"], ["proof (chain)\npicking this:\n  leaf \\<in> condensation_nodes g P\n  (?scc1, leaf) \\<in> (condensation_edges g P)\\<inverse> \\<Longrightarrow>\n  ?scc1 \\<notin> condensation_nodes g P", "have \"leaf \\<in> condensation_nodes g P \\<and> (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)\""], ["proof (prove)\nusing this:\n  leaf \\<in> condensation_nodes g P\n  (?scc1, leaf) \\<in> (condensation_edges g P)\\<inverse> \\<Longrightarrow>\n  ?scc1 \\<notin> condensation_nodes g P\n\ngoal (1 subgoal):\n 1. leaf \\<in> condensation_nodes g P \\<and>\n    (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)", "using condensation_nodes_edges"], ["proof (prove)\nusing this:\n  leaf \\<in> condensation_nodes g P\n  (?scc1, leaf) \\<in> (condensation_edges g P)\\<inverse> \\<Longrightarrow>\n  ?scc1 \\<notin> condensation_nodes g P\n  condensation_edges ?g ?P\n  \\<subseteq> condensation_nodes ?g ?P \\<times> condensation_nodes ?g ?P\n\ngoal (1 subgoal):\n 1. leaf \\<in> condensation_nodes g P \\<and>\n    (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)", "by blast"], ["proof (state)\nthis:\n  leaf \\<in> condensation_nodes g P \\<and>\n  (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)\n\ngoal (2 subgoals):\n 1. ?x \\<in> ?Q\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> ?Q;\n        \\<And>y.\n           (y, z) \\<in> (condensation_edges g P)\\<inverse> \\<Longrightarrow>\n           y \\<notin> ?Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>leaf.\n                            leaf \\<in> condensation_nodes g P \\<and>\n                            (\\<forall>scc.\n                                (leaf, scc) \\<notin> condensation_edges g P)", "thus \"\\<exists>leaf. leaf \\<in> condensation_nodes g P \\<and> (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)\""], ["proof (prove)\nusing this:\n  leaf \\<in> condensation_nodes g P \\<and>\n  (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)\n\ngoal (1 subgoal):\n 1. \\<exists>leaf.\n       leaf \\<in> condensation_nodes g P \\<and>\n       (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)", "by blast"], ["proof (state)\nthis:\n  \\<exists>leaf.\n     leaf \\<in> condensation_nodes g P \\<and>\n     (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)\n\ngoal (1 subgoal):\n 1. ?x \\<in> condensation_nodes g P", "qed fact"], ["proof (state)\nthis:\n  \\<exists>leaf.\n     leaf \\<in> condensation_nodes g P \\<and>\n     (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scc_in_P:\nassumes \"scc \\<in> condensation_nodes g P\"\nshows \"scc \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scc \\<subseteq> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. scc \\<subseteq> P", "have \"scc \\<subseteq> P\" if y_props: \"scc = scc_of (induced_phi_graph g P) n\" \"n \\<in> P\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. scc \\<subseteq> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. scc \\<subseteq> P", "from y_props"], ["proof (chain)\npicking this:\n  scc = scc_of (induced_phi_graph g P) n\n  n \\<in> P", "show \"scc \\<subseteq> P\""], ["proof (prove)\nusing this:\n  scc = scc_of (induced_phi_graph g P) n\n  n \\<in> P\n\ngoal (1 subgoal):\n 1. scc \\<subseteq> P", "proof (clarsimp simp:y_props(1); case_tac \"n = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P; n = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P\n 2. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P;\n        n \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P; n = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P\n 2. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P;\n        n \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P", "assume different: \"n \\<noteq> x\""], ["proof (state)\nthis:\n  n \\<noteq> x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P; n = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P\n 2. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P;\n        n \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P", "assume \"x \\<in> scc_of (induced_phi_graph g P) n\""], ["proof (state)\nthis:\n  x \\<in> scc_of (induced_phi_graph g P) n\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P; n = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P\n 2. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P;\n        n \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P", "hence \"(n, x) \\<in> (induced_phi_graph g P)\\<^sup>*\""], ["proof (prove)\nusing this:\n  x \\<in> scc_of (induced_phi_graph g P) n\n\ngoal (1 subgoal):\n 1. (n, x) \\<in> (induced_phi_graph g P)\\<^sup>*", "by (metis is_scc_connected scc_of_is_scc node_in_scc_of_node)"], ["proof (state)\nthis:\n  (n, x) \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P; n = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P\n 2. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P;\n        n \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P", "with different"], ["proof (chain)\npicking this:\n  n \\<noteq> x\n  (n, x) \\<in> (induced_phi_graph g P)\\<^sup>*", "have \"(n, x) \\<in> (induced_phi_graph g P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  n \\<noteq> x\n  (n, x) \\<in> (induced_phi_graph g P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (n, x) \\<in> (induced_phi_graph g P)\\<^sup>+", "by (metis rtranclD)"], ["proof (state)\nthis:\n  (n, x) \\<in> (induced_phi_graph g P)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P; n = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P\n 2. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P;\n        n \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P", "then"], ["proof (chain)\npicking this:\n  (n, x) \\<in> (induced_phi_graph g P)\\<^sup>+", "obtain z where step: \"(z, x) \\<in> (induced_phi_graph g P)\""], ["proof (prove)\nusing this:\n  (n, x) \\<in> (induced_phi_graph g P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        (z, x) \\<in> induced_phi_graph g P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson tranclE)"], ["proof (state)\nthis:\n  (z, x) \\<in> induced_phi_graph g P\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P; n = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P\n 2. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P;\n        n \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P", "from step"], ["proof (chain)\npicking this:\n  (z, x) \\<in> induced_phi_graph g P", "show \"x \\<in> P\""], ["proof (prove)\nusing this:\n  (z, x) \\<in> induced_phi_graph g P\n\ngoal (1 subgoal):\n 1. x \\<in> P", "unfolding induced_phi_graph_def"], ["proof (prove)\nusing this:\n  (z, x) \\<in> Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P\n\ngoal (1 subgoal):\n 1. x \\<in> P", "by auto"], ["proof (state)\nthis:\n  x \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>n \\<in> P; x \\<in> scc_of (induced_phi_graph g P) n;\n        scc = scc_of (induced_phi_graph g P) n; n \\<in> P; n = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P", "qed simp"], ["proof (state)\nthis:\n  scc \\<subseteq> P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>scc = scc_of (induced_phi_graph g P) ?n1; ?n1 \\<in> P\\<rbrakk>\n  \\<Longrightarrow> scc \\<subseteq> P\n\ngoal (1 subgoal):\n 1. scc \\<subseteq> P", "from this assms(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>scc = scc_of (induced_phi_graph g P) ?n1; ?n1 \\<in> P\\<rbrakk>\n  \\<Longrightarrow> scc \\<subseteq> P\n  scc \\<in> condensation_nodes g P", "have \"x \\<in> P\" if x_node: \"x \\<in> scc\" for x"], ["proof (prove)\nusing this:\n  \\<lbrakk>scc = scc_of (induced_phi_graph g P) ?n1; ?n1 \\<in> P\\<rbrakk>\n  \\<Longrightarrow> scc \\<subseteq> P\n  scc \\<in> condensation_nodes g P\n\ngoal (1 subgoal):\n 1. x \\<in> P", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>scc = scc_of (induced_phi_graph g P) n;\n                 n \\<in> P\\<rbrakk>\n                \\<Longrightarrow> scc \\<subseteq> P;\n     scc \\<in> condensation_nodes g P\\<rbrakk>\n    \\<Longrightarrow> x \\<in> P", "apply (rule imageE[of scc \"scc_of (induced_phi_graph g P)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>scc = scc_of (induced_phi_graph g P) n;\n                 n \\<in> P\\<rbrakk>\n                \\<Longrightarrow> scc \\<subseteq> P;\n     scc \\<in> condensation_nodes g P\\<rbrakk>\n    \\<Longrightarrow> scc \\<in> scc_of (induced_phi_graph g P) ` ?A4\n 2. \\<And>xa.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>scc = scc_of (induced_phi_graph g P) n;\n                    n \\<in> P\\<rbrakk>\n                   \\<Longrightarrow> scc \\<subseteq> P;\n        scc \\<in> condensation_nodes g P;\n        scc = scc_of (induced_phi_graph g P) xa; xa \\<in> ?A4\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P", "using condensation_nodes_def x_node"], ["proof (prove)\nusing this:\n  condensation_nodes ?g ?P \\<equiv> scc_of (induced_phi_graph ?g ?P) ` ?P\n  x \\<in> scc\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>scc = scc_of (induced_phi_graph g P) n;\n                 n \\<in> P\\<rbrakk>\n                \\<Longrightarrow> scc \\<subseteq> P;\n     scc \\<in> condensation_nodes g P\\<rbrakk>\n    \\<Longrightarrow> scc \\<in> scc_of (induced_phi_graph g P) ` ?A4\n 2. \\<And>xa.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>scc = scc_of (induced_phi_graph g P) n;\n                    n \\<in> P\\<rbrakk>\n                   \\<Longrightarrow> scc \\<subseteq> P;\n        scc \\<in> condensation_nodes g P;\n        scc = scc_of (induced_phi_graph g P) xa; xa \\<in> ?A4\\<rbrakk>\n       \\<Longrightarrow> x \\<in> P", "by blast+"], ["proof (state)\nthis:\n  ?x1 \\<in> scc \\<Longrightarrow> ?x1 \\<in> P\n\ngoal (1 subgoal):\n 1. scc \\<subseteq> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x1 \\<in> scc \\<Longrightarrow> ?x1 \\<in> P\n\ngoal (1 subgoal):\n 1. scc \\<subseteq> P", "by clarify"], ["proof (state)\nthis:\n  scc \\<subseteq> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma redundant_scc_phis:\nassumes \"redundant_set g P\" \"scc \\<in> condensation_nodes g P\" \"x \\<in> scc\"\nshows \"phi g x \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phi g x \\<noteq> None", "using assms"], ["proof (prove)\nusing this:\n  redundant_set g P\n  scc \\<in> condensation_nodes g P\n  x \\<in> scc\n\ngoal (1 subgoal):\n 1. phi g x \\<noteq> None", "by (meson domIff redundant_set_def scc_in_P subsetCE)"], ["", "txt \\<open>The following lemma will be important for the main proof of this section.\nIf @{term P} is redundant, a leaf in the condensation graph induced by P corresponds to a strongly connected set\nwith at most one argument, thus a redundant strongly connected set exists.\\<close>"], ["", "txt \\<open>Lemma 1. Every redundant set contains a redundant SCC.\\<close>"], ["", "lemma 1:\nassumes \"redundant_set g P\"\nshows \"\\<exists>scc \\<subseteq> P. redundant_scc g P scc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "from assms Ex_condensation_leaf[of P g]"], ["proof (chain)\npicking this:\n  redundant_set g P\n  P \\<noteq> {} \\<Longrightarrow>\n  \\<exists>leaf.\n     leaf \\<in> condensation_nodes g P \\<and>\n     (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)", "obtain leaf where leaf_props: \"leaf \\<in> (condensation_nodes g P)\" \"\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P\""], ["proof (prove)\nusing this:\n  redundant_set g P\n  P \\<noteq> {} \\<Longrightarrow>\n  \\<exists>leaf.\n     leaf \\<in> condensation_nodes g P \\<and>\n     (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)\n\ngoal (1 subgoal):\n 1. (\\<And>leaf.\n        \\<lbrakk>leaf \\<in> condensation_nodes g P;\n         \\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_set_def"], ["proof (prove)\nusing this:\n  P \\<noteq> {} \\<and>\n  P \\<subseteq> dom (phi g) \\<and>\n  (\\<exists>v'\\<in>allVars g.\n      \\<forall>\\<phi>\\<in>P.\n         \\<forall>\\<phi>'.\n            phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n            \\<phi>' \\<in> P \\<union> {v'})\n  P \\<noteq> {} \\<Longrightarrow>\n  \\<exists>leaf.\n     leaf \\<in> condensation_nodes g P \\<and>\n     (\\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P)\n\ngoal (1 subgoal):\n 1. (\\<And>leaf.\n        \\<lbrakk>leaf \\<in> condensation_nodes g P;\n         \\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  leaf \\<in> condensation_nodes g P\n  \\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "hence \"is_scc (induced_phi_graph g P) leaf\""], ["proof (prove)\nusing this:\n  leaf \\<in> condensation_nodes g P\n  \\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P\n\ngoal (1 subgoal):\n 1. is_scc (induced_phi_graph g P) leaf", "unfolding condensation_nodes_def"], ["proof (prove)\nusing this:\n  leaf \\<in> scc_of (induced_phi_graph g P) ` P\n  \\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P\n\ngoal (1 subgoal):\n 1. is_scc (induced_phi_graph g P) leaf", "by auto"], ["proof (state)\nthis:\n  is_scc (induced_phi_graph g P) leaf\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "moreover"], ["proof (state)\nthis:\n  is_scc (induced_phi_graph g P) leaf\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "hence \"leaf \\<noteq> {}\""], ["proof (prove)\nusing this:\n  is_scc (induced_phi_graph g P) leaf\n\ngoal (1 subgoal):\n 1. leaf \\<noteq> {}", "by (rule scc_non_empty')"], ["proof (state)\nthis:\n  leaf \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "moreover"], ["proof (state)\nthis:\n  leaf \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "have \"leaf \\<subseteq> dom (phi g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. leaf \\<subseteq> dom (phi g)", "apply (subst subset_eq, rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> leaf \\<Longrightarrow> x \\<in> dom (phi g)", "using redundant_scc_phis leaf_props(1) assms(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>redundant_set ?g ?P; ?scc \\<in> condensation_nodes ?g ?P;\n   ?x \\<in> ?scc\\<rbrakk>\n  \\<Longrightarrow> phi ?g ?x \\<noteq> None\n  leaf \\<in> condensation_nodes g P\n  redundant_set g P\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> leaf \\<Longrightarrow> x \\<in> dom (phi g)", "by auto"], ["proof (state)\nthis:\n  leaf \\<subseteq> dom (phi g)\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "moreover"], ["proof (state)\nthis:\n  leaf \\<subseteq> dom (phi g)\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "from assms"], ["proof (chain)\npicking this:\n  redundant_set g P", "obtain pred where pred_props: \"pred \\<in> allVars g\" \"\\<forall>\\<phi>\\<in>P. \\<forall>\\<phi>'. phiArg g \\<phi> \\<phi>' \\<longrightarrow> \\<phi>' \\<in> P \\<union> {pred}\""], ["proof (prove)\nusing this:\n  redundant_set g P\n\ngoal (1 subgoal):\n 1. (\\<And>pred.\n        \\<lbrakk>pred \\<in> allVars g;\n         \\<forall>\\<phi>\\<in>P.\n            \\<forall>\\<phi>'.\n               phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n               \\<phi>' \\<in> P \\<union> {pred}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_set_def"], ["proof (prove)\nusing this:\n  P \\<noteq> {} \\<and>\n  P \\<subseteq> dom (phi g) \\<and>\n  (\\<exists>v'\\<in>allVars g.\n      \\<forall>\\<phi>\\<in>P.\n         \\<forall>\\<phi>'.\n            phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n            \\<phi>' \\<in> P \\<union> {v'})\n\ngoal (1 subgoal):\n 1. (\\<And>pred.\n        \\<lbrakk>pred \\<in> allVars g;\n         \\<forall>\\<phi>\\<in>P.\n            \\<forall>\\<phi>'.\n               phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n               \\<phi>' \\<in> P \\<union> {pred}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pred \\<in> allVars g\n  \\<forall>\\<phi>\\<in>P.\n     \\<forall>\\<phi>'.\n        phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n        \\<phi>' \\<in> P \\<union> {pred}\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "{"], ["proof (state)\nthis:\n  pred \\<in> allVars g\n  \\<forall>\\<phi>\\<in>P.\n     \\<forall>\\<phi>'.\n        phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n        \\<phi>' \\<in> P \\<union> {pred}\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "txt \\<open>Any argument of a \\pf\\ in the leaf SCC which is \\emph{not} in the leaf SCC itself must be the unique argument of P\\<close>"], ["proof (state)\nthis:\n  pred \\<in> allVars g\n  \\<forall>\\<phi>\\<in>P.\n     \\<forall>\\<phi>'.\n        phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n        \\<phi>' \\<in> P \\<union> {pred}\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "fix \\<phi> \\<phi>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "consider (in_P) \"\\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P\" | (neither) \"\\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<notin> P \\<union> {pred}\" | \"\\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred}\" | \"\\<phi>' \\<in> leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P \\<Longrightarrow>\n             thesis;\n     \\<phi>' \\<notin> leaf \\<and>\n     \\<phi>' \\<notin> P \\<union> {pred} \\<Longrightarrow>\n     thesis;\n     \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred} \\<Longrightarrow>\n     thesis;\n     \\<phi>' \\<in> leaf \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P \\<Longrightarrow>\n           ?thesis1;\n   \\<phi>' \\<notin> leaf \\<and>\n   \\<phi>' \\<notin> P \\<union> {pred} \\<Longrightarrow>\n   ?thesis1;\n   \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred} \\<Longrightarrow>\n   ?thesis1;\n   \\<phi>' \\<in> leaf \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "hence \"\\<phi>' \\<in> leaf \\<union> {pred}\" if \"\\<phi> \\<in> leaf\" and \"phiArg g \\<phi> \\<phi>'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P \\<Longrightarrow>\n           ?thesis1;\n   \\<phi>' \\<notin> leaf \\<and>\n   \\<phi>' \\<notin> P \\<union> {pred} \\<Longrightarrow>\n   ?thesis1;\n   \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred} \\<Longrightarrow>\n   ?thesis1;\n   \\<phi>' \\<in> leaf \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<phi>' \\<in> leaf \\<union> {pred}", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 2. \\<phi>' \\<notin> leaf \\<and>\n    \\<phi>' \\<notin> P \\<union> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 3. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 4. \\<phi>' \\<in> leaf \\<Longrightarrow> \\<phi>' \\<in> leaf \\<union> {pred}", "case in_P \\<comment> \\<open>In this case @{term leaf} wasn't really a leaf, a contradiction\\<close>"], ["proof (state)\nthis:\n  \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P\n\ngoal (4 subgoals):\n 1. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 2. \\<phi>' \\<notin> leaf \\<and>\n    \\<phi>' \\<notin> P \\<union> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 3. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 4. \\<phi>' \\<in> leaf \\<Longrightarrow> \\<phi>' \\<in> leaf \\<union> {pred}", "moreover"], ["proof (state)\nthis:\n  \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P\n\ngoal (4 subgoals):\n 1. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 2. \\<phi>' \\<notin> leaf \\<and>\n    \\<phi>' \\<notin> P \\<union> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 3. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 4. \\<phi>' \\<in> leaf \\<Longrightarrow> \\<phi>' \\<in> leaf \\<union> {pred}", "from in_P that leaf_props(1) scc_in_P[of leaf g P]"], ["proof (chain)\npicking this:\n  \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P\n  \\<phi> \\<in> leaf\n  phiArg g \\<phi> \\<phi>'\n  leaf \\<in> condensation_nodes g P\n  leaf \\<in> condensation_nodes g P \\<Longrightarrow> leaf \\<subseteq> P", "have \"(\\<phi>, \\<phi>') \\<in> induced_phi_graph g P\""], ["proof (prove)\nusing this:\n  \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P\n  \\<phi> \\<in> leaf\n  phiArg g \\<phi> \\<phi>'\n  leaf \\<in> condensation_nodes g P\n  leaf \\<in> condensation_nodes g P \\<Longrightarrow> leaf \\<subseteq> P\n\ngoal (1 subgoal):\n 1. (\\<phi>, \\<phi>') \\<in> induced_phi_graph g P", "unfolding induced_phi_graph_def"], ["proof (prove)\nusing this:\n  \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P\n  \\<phi> \\<in> leaf\n  phiArg g \\<phi> \\<phi>'\n  leaf \\<in> condensation_nodes g P\n  leaf \\<in> condensation_nodes g P \\<Longrightarrow> leaf \\<subseteq> P\n\ngoal (1 subgoal):\n 1. (\\<phi>, \\<phi>')\n    \\<in> Restr {(\\<phi>, \\<phi>'). phiArg g \\<phi> \\<phi>'} P", "by auto"], ["proof (state)\nthis:\n  (\\<phi>, \\<phi>') \\<in> induced_phi_graph g P\n\ngoal (4 subgoals):\n 1. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 2. \\<phi>' \\<notin> leaf \\<and>\n    \\<phi>' \\<notin> P \\<union> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 3. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 4. \\<phi>' \\<in> leaf \\<Longrightarrow> \\<phi>' \\<in> leaf \\<union> {pred}", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P\n  (\\<phi>, \\<phi>') \\<in> induced_phi_graph g P", "have \"(leaf, scc_of (induced_phi_graph g P) \\<phi>') \\<in> condensation_edges g P\""], ["proof (prove)\nusing this:\n  \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P\n  (\\<phi>, \\<phi>') \\<in> induced_phi_graph g P\n\ngoal (1 subgoal):\n 1. (leaf, scc_of (induced_phi_graph g P) \\<phi>')\n    \\<in> condensation_edges g P", "unfolding condensation_edges_def"], ["proof (prove)\nusing this:\n  \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P\n  (\\<phi>, \\<phi>') \\<in> induced_phi_graph g P\n\ngoal (1 subgoal):\n 1. (leaf, scc_of (induced_phi_graph g P) \\<phi>')\n    \\<in> (\\<lambda>(x, y).\n              (scc_of (induced_phi_graph g P) x,\n               scc_of (induced_phi_graph g P) y)) `\n          induced_phi_graph g P -\n          Id", "using leaf_props(1) that \\<open>is_scc (induced_phi_graph g P) leaf\\<close>"], ["proof (prove)\nusing this:\n  \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P\n  (\\<phi>, \\<phi>') \\<in> induced_phi_graph g P\n  leaf \\<in> condensation_nodes g P\n  \\<phi> \\<in> leaf\n  phiArg g \\<phi> \\<phi>'\n  is_scc (induced_phi_graph g P) leaf\n\ngoal (1 subgoal):\n 1. (leaf, scc_of (induced_phi_graph g P) \\<phi>')\n    \\<in> (\\<lambda>(x, y).\n              (scc_of (induced_phi_graph g P) x,\n               scc_of (induced_phi_graph g P) y)) `\n          induced_phi_graph g P -\n          Id", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P;\n     (\\<phi>, \\<phi>') \\<in> induced_phi_graph g P;\n     leaf \\<in> condensation_nodes g P; \\<phi> \\<in> leaf;\n     phiArg g \\<phi> \\<phi>'; is_scc (induced_phi_graph g P) leaf\\<rbrakk>\n    \\<Longrightarrow> (leaf, scc_of (induced_phi_graph g P) \\<phi>')\n                      \\<in> (\\<lambda>(x, y).\n                                (scc_of (induced_phi_graph g P) x,\n                                 scc_of (induced_phi_graph g P) y)) `\n                            induced_phi_graph g P -\n                            Id", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<phi>, \\<phi>') \\<in> induced_phi_graph g P;\n     leaf \\<in> condensation_nodes g P; \\<phi> \\<in> leaf;\n     phiArg g \\<phi> \\<phi>'; is_scc (induced_phi_graph g P) leaf;\n     \\<phi>' \\<notin> leaf; \\<phi>' \\<in> P\\<rbrakk>\n    \\<Longrightarrow> (leaf, scc_of (induced_phi_graph g P) \\<phi>')\n                      \\<in> (\\<lambda>x.\n                                case x of\n                                (x, y) \\<Rightarrow>\n                                  (scc_of (induced_phi_graph g P) x,\n                                   scc_of (induced_phi_graph g P) y)) `\n                            induced_phi_graph g P \\<and>\n                      leaf \\<noteq> scc_of (induced_phi_graph g P) \\<phi>'", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<phi>, \\<phi>') \\<in> induced_phi_graph g P;\n     leaf \\<in> condensation_nodes g P; \\<phi> \\<in> leaf;\n     phiArg g \\<phi> \\<phi>'; is_scc (induced_phi_graph g P) leaf;\n     \\<phi>' \\<notin> leaf; \\<phi>' \\<in> P\\<rbrakk>\n    \\<Longrightarrow> (leaf, scc_of (induced_phi_graph g P) \\<phi>')\n                      \\<in> (\\<lambda>x.\n                                case x of\n                                (x, y) \\<Rightarrow>\n                                  (scc_of (induced_phi_graph g P) x,\n                                   scc_of (induced_phi_graph g P) y)) `\n                            induced_phi_graph g P\n 2. \\<lbrakk>(\\<phi>, \\<phi>') \\<in> induced_phi_graph g P;\n     leaf \\<in> condensation_nodes g P; \\<phi> \\<in> leaf;\n     phiArg g \\<phi> \\<phi>'; is_scc (induced_phi_graph g P) leaf;\n     \\<phi>' \\<notin> leaf; \\<phi>' \\<in> P\\<rbrakk>\n    \\<Longrightarrow> leaf \\<noteq> scc_of (induced_phi_graph g P) \\<phi>'", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<phi>, \\<phi>') \\<in> induced_phi_graph g P;\n     leaf \\<in> condensation_nodes g P; \\<phi> \\<in> leaf;\n     phiArg g \\<phi> \\<phi>'; is_scc (induced_phi_graph g P) leaf;\n     \\<phi>' \\<notin> leaf; \\<phi>' \\<in> P\\<rbrakk>\n    \\<Longrightarrow> leaf \\<noteq> scc_of (induced_phi_graph g P) \\<phi>'\n 2. \\<lbrakk>(\\<phi>, \\<phi>') \\<in> induced_phi_graph g P;\n     leaf \\<in> condensation_nodes g P; \\<phi> \\<in> leaf;\n     phiArg g \\<phi> \\<phi>'; is_scc (induced_phi_graph g P) leaf;\n     \\<phi>' \\<notin> leaf; \\<phi>' \\<in> P\\<rbrakk>\n    \\<Longrightarrow> (leaf, scc_of (induced_phi_graph g P) \\<phi>')\n                      \\<in> (\\<lambda>x.\n                                case x of\n                                (x, y) \\<Rightarrow>\n                                  (scc_of (induced_phi_graph g P) x,\n                                   scc_of (induced_phi_graph g P) y)) `\n                            induced_phi_graph g P", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<phi>, \\<phi>') \\<in> induced_phi_graph g P;\n     leaf \\<in> condensation_nodes g P; \\<phi> \\<in> leaf;\n     phiArg g \\<phi> \\<phi>'; is_scc (induced_phi_graph g P) leaf;\n     \\<phi>' \\<notin> leaf; \\<phi>' \\<in> P\\<rbrakk>\n    \\<Longrightarrow> (leaf, scc_of (induced_phi_graph g P) \\<phi>')\n                      \\<in> (\\<lambda>x.\n                                case x of\n                                (x, y) \\<Rightarrow>\n                                  (scc_of (induced_phi_graph g P) x,\n                                   scc_of (induced_phi_graph g P) y)) `\n                            induced_phi_graph g P", "unfolding condensation_nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<phi>, \\<phi>') \\<in> induced_phi_graph g P;\n     leaf \\<in> scc_of (induced_phi_graph g P) ` P; \\<phi> \\<in> leaf;\n     phiArg g \\<phi> \\<phi>'; is_scc (induced_phi_graph g P) leaf;\n     \\<phi>' \\<notin> leaf; \\<phi>' \\<in> P\\<rbrakk>\n    \\<Longrightarrow> (leaf, scc_of (induced_phi_graph g P) \\<phi>')\n                      \\<in> (\\<lambda>x.\n                                case x of\n                                (x, y) \\<Rightarrow>\n                                  (scc_of (induced_phi_graph g P) x,\n                                   scc_of (induced_phi_graph g P) y)) `\n                            induced_phi_graph g P", "by (metis (no_types, lifting) is_scc_unique node_in_scc_of_node pair_imageI scc_of_is_scc)"], ["proof (state)\nthis:\n  (leaf, scc_of (induced_phi_graph g P) \\<phi>')\n  \\<in> condensation_edges g P\n\ngoal (4 subgoals):\n 1. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> P \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 2. \\<phi>' \\<notin> leaf \\<and>\n    \\<phi>' \\<notin> P \\<union> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 3. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 4. \\<phi>' \\<in> leaf \\<Longrightarrow> \\<phi>' \\<in> leaf \\<union> {pred}", "with leaf_props(2)"], ["proof (chain)\npicking this:\n  \\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P\n  (leaf, scc_of (induced_phi_graph g P) \\<phi>')\n  \\<in> condensation_edges g P", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P\n  (leaf, scc_of (induced_phi_graph g P) \\<phi>')\n  \\<in> condensation_edges g P\n\ngoal (1 subgoal):\n 1. \\<phi>' \\<in> leaf \\<union> {pred}", "by auto"], ["proof (state)\nthis:\n  \\<phi>' \\<in> leaf \\<union> {pred}\n\ngoal (3 subgoals):\n 1. \\<phi>' \\<notin> leaf \\<and>\n    \\<phi>' \\<notin> P \\<union> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 2. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 3. \\<phi>' \\<in> leaf \\<Longrightarrow> \\<phi>' \\<in> leaf \\<union> {pred}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<phi>' \\<notin> leaf \\<and>\n    \\<phi>' \\<notin> P \\<union> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 2. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 3. \\<phi>' \\<in> leaf \\<Longrightarrow> \\<phi>' \\<in> leaf \\<union> {pred}", "case neither \\<comment> \\<open>In which case @{term P} itself wasn't redundant, a contradiction\\<close>"], ["proof (state)\nthis:\n  \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<notin> P \\<union> {pred}\n\ngoal (3 subgoals):\n 1. \\<phi>' \\<notin> leaf \\<and>\n    \\<phi>' \\<notin> P \\<union> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 2. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 3. \\<phi>' \\<in> leaf \\<Longrightarrow> \\<phi>' \\<in> leaf \\<union> {pred}", "with that leaf_props pred_props"], ["proof (chain)\npicking this:\n  \\<phi> \\<in> leaf\n  phiArg g \\<phi> \\<phi>'\n  leaf \\<in> condensation_nodes g P\n  \\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P\n  pred \\<in> allVars g\n  \\<forall>\\<phi>\\<in>P.\n     \\<forall>\\<phi>'.\n        phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n        \\<phi>' \\<in> P \\<union> {pred}\n  \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<notin> P \\<union> {pred}", "have \"\\<not>redundant_set g P\""], ["proof (prove)\nusing this:\n  \\<phi> \\<in> leaf\n  phiArg g \\<phi> \\<phi>'\n  leaf \\<in> condensation_nodes g P\n  \\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P\n  pred \\<in> allVars g\n  \\<forall>\\<phi>\\<in>P.\n     \\<forall>\\<phi>'.\n        phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n        \\<phi>' \\<in> P \\<union> {pred}\n  \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<notin> P \\<union> {pred}\n\ngoal (1 subgoal):\n 1. \\<not> redundant_set g P", "unfolding redundant_set_def"], ["proof (prove)\nusing this:\n  \\<phi> \\<in> leaf\n  phiArg g \\<phi> \\<phi>'\n  leaf \\<in> condensation_nodes g P\n  \\<forall>scc. (leaf, scc) \\<notin> condensation_edges g P\n  pred \\<in> allVars g\n  \\<forall>\\<phi>\\<in>P.\n     \\<forall>\\<phi>'.\n        phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n        \\<phi>' \\<in> P \\<union> {pred}\n  \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<notin> P \\<union> {pred}\n\ngoal (1 subgoal):\n 1. \\<not> (P \\<noteq> {} \\<and>\n            P \\<subseteq> dom (phi g) \\<and>\n            (\\<exists>v'\\<in>allVars g.\n                \\<forall>\\<phi>\\<in>P.\n                   \\<forall>\\<phi>'.\n                      phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n                      \\<phi>' \\<in> P \\<union> {v'}))", "by (meson rev_subsetD scc_in_P)"], ["proof (state)\nthis:\n  \\<not> redundant_set g P\n\ngoal (3 subgoals):\n 1. \\<phi>' \\<notin> leaf \\<and>\n    \\<phi>' \\<notin> P \\<union> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 2. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 3. \\<phi>' \\<in> leaf \\<Longrightarrow> \\<phi>' \\<in> leaf \\<union> {pred}", "with assms"], ["proof (chain)\npicking this:\n  redundant_set g P\n  \\<not> redundant_set g P", "show ?thesis"], ["proof (prove)\nusing this:\n  redundant_set g P\n  \\<not> redundant_set g P\n\ngoal (1 subgoal):\n 1. \\<phi>' \\<in> leaf \\<union> {pred}", "by auto"], ["proof (state)\nthis:\n  \\<phi>' \\<in> leaf \\<union> {pred}\n\ngoal (2 subgoals):\n 1. \\<phi>' \\<notin> leaf \\<and> \\<phi>' \\<in> {pred} \\<Longrightarrow>\n    \\<phi>' \\<in> leaf \\<union> {pred}\n 2. \\<phi>' \\<in> leaf \\<Longrightarrow> \\<phi>' \\<in> leaf \\<union> {pred}", "qed auto \\<comment> \\<open>the other cases are trivial\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>\\<phi> \\<in> leaf; phiArg g \\<phi> \\<phi>'\\<rbrakk>\n  \\<Longrightarrow> \\<phi>' \\<in> leaf \\<union> {pred}\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<phi>3 \\<in> leaf; phiArg g ?\\<phi>3 ?\\<phi>'3\\<rbrakk>\n  \\<Longrightarrow> ?\\<phi>'3 \\<in> leaf \\<union> {pred}\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "with pred_props(1)"], ["proof (chain)\npicking this:\n  pred \\<in> allVars g\n  \\<lbrakk>?\\<phi>3 \\<in> leaf; phiArg g ?\\<phi>3 ?\\<phi>'3\\<rbrakk>\n  \\<Longrightarrow> ?\\<phi>'3 \\<in> leaf \\<union> {pred}", "have \"\\<exists>v'\\<in>allVars g. \\<forall>\\<phi>\\<in>leaf. \\<forall>\\<phi>'. phiArg g \\<phi> \\<phi>' \\<longrightarrow> \\<phi>' \\<in> leaf \\<union> {v'}\""], ["proof (prove)\nusing this:\n  pred \\<in> allVars g\n  \\<lbrakk>?\\<phi>3 \\<in> leaf; phiArg g ?\\<phi>3 ?\\<phi>'3\\<rbrakk>\n  \\<Longrightarrow> ?\\<phi>'3 \\<in> leaf \\<union> {pred}\n\ngoal (1 subgoal):\n 1. \\<exists>v'\\<in>allVars g.\n       \\<forall>\\<phi>\\<in>leaf.\n          \\<forall>\\<phi>'.\n             phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n             \\<phi>' \\<in> leaf \\<union> {v'}", "by auto"], ["proof (state)\nthis:\n  \\<exists>v'\\<in>allVars g.\n     \\<forall>\\<phi>\\<in>leaf.\n        \\<forall>\\<phi>'.\n           phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n           \\<phi>' \\<in> leaf \\<union> {v'}\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "ultimately"], ["proof (chain)\npicking this:\n  is_scc (induced_phi_graph g P) leaf\n  leaf \\<noteq> {}\n  leaf \\<subseteq> dom (phi g)\n  \\<exists>v'\\<in>allVars g.\n     \\<forall>\\<phi>\\<in>leaf.\n        \\<forall>\\<phi>'.\n           phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n           \\<phi>' \\<in> leaf \\<union> {v'}", "have \"redundant_scc g P leaf\""], ["proof (prove)\nusing this:\n  is_scc (induced_phi_graph g P) leaf\n  leaf \\<noteq> {}\n  leaf \\<subseteq> dom (phi g)\n  \\<exists>v'\\<in>allVars g.\n     \\<forall>\\<phi>\\<in>leaf.\n        \\<forall>\\<phi>'.\n           phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n           \\<phi>' \\<in> leaf \\<union> {v'}\n\ngoal (1 subgoal):\n 1. redundant_scc g P leaf", "unfolding redundant_scc_def redundant_set_def"], ["proof (prove)\nusing this:\n  is_scc (induced_phi_graph g P) leaf\n  leaf \\<noteq> {}\n  leaf \\<subseteq> dom (phi g)\n  \\<exists>v'\\<in>allVars g.\n     \\<forall>\\<phi>\\<in>leaf.\n        \\<forall>\\<phi>'.\n           phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n           \\<phi>' \\<in> leaf \\<union> {v'}\n\ngoal (1 subgoal):\n 1. (leaf \\<noteq> {} \\<and>\n     leaf \\<subseteq> dom (phi g) \\<and>\n     (\\<exists>v'\\<in>allVars g.\n         \\<forall>\\<phi>\\<in>leaf.\n            \\<forall>\\<phi>'.\n               phiArg g \\<phi> \\<phi>' \\<longrightarrow>\n               \\<phi>' \\<in> leaf \\<union> {v'})) \\<and>\n    is_scc (induced_phi_graph g P) leaf", "by auto"], ["proof (state)\nthis:\n  redundant_scc g P leaf\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "thus ?thesis"], ["proof (prove)\nusing this:\n  redundant_scc g P leaf\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "using leaf_props(1) scc_in_P"], ["proof (prove)\nusing this:\n  redundant_scc g P leaf\n  leaf \\<in> condensation_nodes g P\n  ?scc \\<in> condensation_nodes ?g ?P \\<Longrightarrow> ?scc \\<subseteq> ?P\n\ngoal (1 subgoal):\n 1. \\<exists>scc\\<subseteq>P. redundant_scc g P scc", "by meson"], ["proof (state)\nthis:\n  \\<exists>scc\\<subseteq>P. redundant_scc g P scc\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proof of Minimality\\<close>"], ["", "txt \\<open>We inductively define the reachable-set of a \\pf\\ as all \\pf s reachable from a given node via an\nunbroken chain of $\\phi$ argument edges to unnecessary \\pf s.\\<close>"], ["", "inductive_set reachable :: \"'g \\<Rightarrow> 'val \\<Rightarrow> 'val set\"\n  for g :: \"'g\" and \\<phi> :: \"'val\"\n  where refl: \"unnecessaryPhi g \\<phi> \\<Longrightarrow> \\<phi> \\<in> reachable g \\<phi>\"\n  | step: \"\\<phi>' \\<in> reachable g \\<phi> \\<Longrightarrow> phiArg g \\<phi>' \\<phi>'' \\<Longrightarrow> unnecessaryPhi g \\<phi>'' \\<Longrightarrow> \\<phi>'' \\<in> reachable g \\<phi>\""], ["", "lemma reachable_props:\n  assumes \"\\<phi>' \\<in> reachable g \\<phi>\"\n  shows \"(phiArg g)\\<^sup>*\\<^sup>* \\<phi> \\<phi>'\" and \"unnecessaryPhi g \\<phi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> \\<phi>' &&& unnecessaryPhi g \\<phi>'", "using assms"], ["proof (prove)\nusing this:\n  \\<phi>' \\<in> reachable g \\<phi>\n\ngoal (1 subgoal):\n 1. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> \\<phi>' &&& unnecessaryPhi g \\<phi>'", "by (induction \\<phi>' rule: reachable.induct) auto"], ["", "txt \\<open>We call the transitive arguments of a \\pf\\ not in its reachable-set the \"true arguments\" of this \\pf.\\<close>"], ["", "definition [simp]: \"trueArgs g \\<phi> \\<equiv> {\\<phi>'. \\<phi>' \\<notin> reachable g \\<phi>} \\<inter> {\\<phi>'. \\<exists>\\<phi>'' \\<in> reachable g \\<phi>. phiArg g \\<phi>'' \\<phi>'}\""], ["", "lemma preds_finite: \"finite (trueArgs g \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (trueArgs g \\<phi>)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (trueArgs g \\<phi>) \\<Longrightarrow> False", "assume \"infinite (trueArgs g \\<phi>)\""], ["proof (state)\nthis:\n  infinite (trueArgs g \\<phi>)\n\ngoal (1 subgoal):\n 1. infinite (trueArgs g \\<phi>) \\<Longrightarrow> False", "hence a: \"infinite {\\<phi>'. \\<exists>\\<phi>'' \\<in> reachable g \\<phi>. phiArg g \\<phi>'' \\<phi>'}\""], ["proof (prove)\nusing this:\n  infinite (trueArgs g \\<phi>)\n\ngoal (1 subgoal):\n 1. infinite\n     {\\<phi>'.\n      \\<exists>\\<phi>''\\<in>reachable g \\<phi>. phiArg g \\<phi>'' \\<phi>'}", "by auto"], ["proof (state)\nthis:\n  infinite\n   {\\<phi>'.\n    \\<exists>\\<phi>''\\<in>reachable g \\<phi>. phiArg g \\<phi>'' \\<phi>'}\n\ngoal (1 subgoal):\n 1. infinite (trueArgs g \\<phi>) \\<Longrightarrow> False", "have phiarg_set: \"{\\<phi>'. \\<exists>\\<phi>. phiArg g \\<phi> \\<phi>'} = \\<Union> (set `{b. \\<exists>a. phi g a = Some b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<phi>'. \\<exists>\\<phi>. phiArg g \\<phi> \\<phi>'} =\n    \\<Union> (set ` {b. \\<exists>a. phi g a = Some b})", "unfolding phiArg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<phi>'.\n     \\<exists>\\<phi> vs.\n        phi g \\<phi> = Some vs \\<and> \\<phi>' \\<in> set vs} =\n    \\<Union> (set ` {b. \\<exists>a. phi g a = Some b})", "by auto"], ["proof (state)\nthis:\n  {\\<phi>'. \\<exists>\\<phi>. phiArg g \\<phi> \\<phi>'} =\n  \\<Union> (set ` {b. \\<exists>a. phi g a = Some b})\n\ngoal (1 subgoal):\n 1. infinite (trueArgs g \\<phi>) \\<Longrightarrow> False", "txt \\<open>If the true arguments of a \\pf\\ are infinite in number, there must be an infinite number of \\pf s\\ldots\\<close>"], ["proof (state)\nthis:\n  {\\<phi>'. \\<exists>\\<phi>. phiArg g \\<phi> \\<phi>'} =\n  \\<Union> (set ` {b. \\<exists>a. phi g a = Some b})\n\ngoal (1 subgoal):\n 1. infinite (trueArgs g \\<phi>) \\<Longrightarrow> False", "have \"infinite {\\<phi>'. \\<exists>\\<phi>. phiArg g \\<phi> \\<phi>'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {\\<phi>'. \\<exists>\\<phi>. phiArg g \\<phi> \\<phi>'}", "by (rule infinite_super[of \"{\\<phi>'. \\<exists>\\<phi>'' \\<in> reachable g \\<phi>. phiArg g \\<phi>'' \\<phi>'}\"])  (auto simp: a)"], ["proof (state)\nthis:\n  infinite {\\<phi>'. \\<exists>\\<phi>. phiArg g \\<phi> \\<phi>'}\n\ngoal (1 subgoal):\n 1. infinite (trueArgs g \\<phi>) \\<Longrightarrow> False", "with phiarg_set"], ["proof (chain)\npicking this:\n  {\\<phi>'. \\<exists>\\<phi>. phiArg g \\<phi> \\<phi>'} =\n  \\<Union> (set ` {b. \\<exists>a. phi g a = Some b})\n  infinite {\\<phi>'. \\<exists>\\<phi>. phiArg g \\<phi> \\<phi>'}", "have \"infinite (ran (phi g))\""], ["proof (prove)\nusing this:\n  {\\<phi>'. \\<exists>\\<phi>. phiArg g \\<phi> \\<phi>'} =\n  \\<Union> (set ` {b. \\<exists>a. phi g a = Some b})\n  infinite {\\<phi>'. \\<exists>\\<phi>. phiArg g \\<phi> \\<phi>'}\n\ngoal (1 subgoal):\n 1. infinite (ran (phi g))", "unfolding ran_def phiArg_def"], ["proof (prove)\nusing this:\n  {\\<phi>'.\n   \\<exists>\\<phi> vs. phi g \\<phi> = Some vs \\<and> \\<phi>' \\<in> set vs} =\n  \\<Union> (set ` {b. \\<exists>a. phi g a = Some b})\n  infinite\n   {\\<phi>'.\n    \\<exists>\\<phi> vs. phi g \\<phi> = Some vs \\<and> \\<phi>' \\<in> set vs}\n\ngoal (1 subgoal):\n 1. infinite {b. \\<exists>a. phi g a = Some b}", "by clarsimp"], ["proof (state)\nthis:\n  infinite (ran (phi g))\n\ngoal (1 subgoal):\n 1. infinite (trueArgs g \\<phi>) \\<Longrightarrow> False", "txt \\<open>Which cannot be.\\<close>"], ["proof (state)\nthis:\n  infinite (ran (phi g))\n\ngoal (1 subgoal):\n 1. infinite (trueArgs g \\<phi>) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  infinite (ran (phi g))\n\ngoal (1 subgoal):\n 1. False", "by (simp add:phi_finite map_dom_ran_finite)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "txt \\<open>Any unnecessary $\\phi$ with less than 2 true arguments induces with @{term \"reachable g \\<phi>\"} a redundant set itself.\\<close>"], ["", "lemma few_preds_redundant:\nassumes \"card (trueArgs g \\<phi>) < 2\" \"unnecessaryPhi g \\<phi>\"\nshows \"redundant_set g (reachable g \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant_set g (reachable g \\<phi>)", "unfolding redundant_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable g \\<phi> \\<noteq> {} \\<and>\n    reachable g \\<phi> \\<subseteq> dom (phi g) \\<and>\n    (\\<exists>v'\\<in>allVars g.\n        \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n           \\<forall>\\<phi>''.\n              phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n              \\<phi>'' \\<in> reachable g \\<phi> \\<union> {v'})", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. reachable g \\<phi> \\<noteq> {}\n 2. reachable g \\<phi> \\<subseteq> dom (phi g)\n 3. \\<exists>v'\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {v'}", "from assms"], ["proof (chain)\npicking this:\n  card (trueArgs g \\<phi>) < 2\n  unnecessaryPhi g \\<phi>", "show \"reachable g \\<phi> \\<noteq> {}\""], ["proof (prove)\nusing this:\n  card (trueArgs g \\<phi>) < 2\n  unnecessaryPhi g \\<phi>\n\ngoal (1 subgoal):\n 1. reachable g \\<phi> \\<noteq> {}", "using empty_iff reachable.intros(1)"], ["proof (prove)\nusing this:\n  card (trueArgs g \\<phi>) < 2\n  unnecessaryPhi g \\<phi>\n  (?c \\<in> {}) = False\n  unnecessaryPhi ?g ?\\<phi> \\<Longrightarrow>\n  ?\\<phi> \\<in> reachable ?g ?\\<phi>\n\ngoal (1 subgoal):\n 1. reachable g \\<phi> \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  reachable g \\<phi> \\<noteq> {}\n\ngoal (2 subgoals):\n 1. reachable g \\<phi> \\<subseteq> dom (phi g)\n 2. \\<exists>v'\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {v'}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. reachable g \\<phi> \\<subseteq> dom (phi g)\n 2. \\<exists>v'\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {v'}", "from assms(2)"], ["proof (chain)\npicking this:\n  unnecessaryPhi g \\<phi>", "show \"reachable g \\<phi> \\<subseteq> dom (phi g)\""], ["proof (prove)\nusing this:\n  unnecessaryPhi g \\<phi>\n\ngoal (1 subgoal):\n 1. reachable g \\<phi> \\<subseteq> dom (phi g)", "by (metis domIff reachable.cases subsetI unnecessaryPhi_def)"], ["proof (state)\nthis:\n  reachable g \\<phi> \\<subseteq> dom (phi g)\n\ngoal (1 subgoal):\n 1. \\<exists>v'\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {v'}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v'\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {v'}", "from assms(1)"], ["proof (chain)\npicking this:\n  card (trueArgs g \\<phi>) < 2", "consider (single) \"card (trueArgs g \\<phi>) = 1\" | (empty) \"card (trueArgs g \\<phi>) = 0\""], ["proof (prove)\nusing this:\n  card (trueArgs g \\<phi>) < 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>card (trueArgs g \\<phi>) = 1 \\<Longrightarrow> thesis;\n     card (trueArgs g \\<phi>) = 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>card (trueArgs g \\<phi>) = 1 \\<Longrightarrow> ?thesis1;\n   card (trueArgs g \\<phi>) = 0 \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<exists>v'\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {v'}", "thus \"\\<exists>pred\\<in>allVars g. \\<forall>\\<phi>'\\<in>reachable g \\<phi>. \\<forall>\\<phi>''. phiArg g \\<phi>' \\<phi>'' \\<longrightarrow> \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>card (trueArgs g \\<phi>) = 1 \\<Longrightarrow> ?thesis1;\n   card (trueArgs g \\<phi>) = 0 \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. card (trueArgs g \\<phi>) = 1 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}\n 2. card (trueArgs g \\<phi>) = 0 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "case single"], ["proof (state)\nthis:\n  card (trueArgs g \\<phi>) = 1\n\ngoal (2 subgoals):\n 1. card (trueArgs g \\<phi>) = 1 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}\n 2. card (trueArgs g \\<phi>) = 0 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "then"], ["proof (chain)\npicking this:\n  card (trueArgs g \\<phi>) = 1", "obtain pred where pred_prop: \"trueArgs g \\<phi> = {pred}\""], ["proof (prove)\nusing this:\n  card (trueArgs g \\<phi>) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>pred.\n        trueArgs g \\<phi> = {pred} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using card_eq_1_singleton"], ["proof (prove)\nusing this:\n  card (trueArgs g \\<phi>) = 1\n  \\<lbrakk>card ?A = 1; \\<And>x. ?A = {x} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>pred.\n        trueArgs g \\<phi> = {pred} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trueArgs g \\<phi> = {pred}\n\ngoal (2 subgoals):\n 1. card (trueArgs g \\<phi>) = 1 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}\n 2. card (trueArgs g \\<phi>) = 0 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "hence \"pred \\<in> allVars g\""], ["proof (prove)\nusing this:\n  trueArgs g \\<phi> = {pred}\n\ngoal (1 subgoal):\n 1. pred \\<in> allVars g", "by (auto intro: Int_Collect phiArg_in_allVars)"], ["proof (state)\nthis:\n  pred \\<in> allVars g\n\ngoal (2 subgoals):\n 1. card (trueArgs g \\<phi>) = 1 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}\n 2. card (trueArgs g \\<phi>) = 0 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "moreover"], ["proof (state)\nthis:\n  pred \\<in> allVars g\n\ngoal (2 subgoals):\n 1. card (trueArgs g \\<phi>) = 1 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}\n 2. card (trueArgs g \\<phi>) = 0 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "from pred_prop"], ["proof (chain)\npicking this:\n  trueArgs g \\<phi> = {pred}", "have \"\\<forall>\\<phi>'\\<in>reachable g \\<phi>. \\<forall>\\<phi>''. phiArg g \\<phi>' \\<phi>'' \\<longrightarrow> \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}\""], ["proof (prove)\nusing this:\n  trueArgs g \\<phi> = {pred}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n       \\<forall>\\<phi>''.\n          phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n          \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n     \\<forall>\\<phi>''.\n        phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n        \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}\n\ngoal (2 subgoals):\n 1. card (trueArgs g \\<phi>) = 1 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}\n 2. card (trueArgs g \\<phi>) = 0 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "ultimately"], ["proof (chain)\npicking this:\n  pred \\<in> allVars g\n  \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n     \\<forall>\\<phi>''.\n        phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n        \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "show ?thesis"], ["proof (prove)\nusing this:\n  pred \\<in> allVars g\n  \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n     \\<forall>\\<phi>''.\n        phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n        \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}\n\ngoal (1 subgoal):\n 1. \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "by auto"], ["proof (state)\nthis:\n  \\<exists>pred\\<in>allVars g.\n     \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n        \\<forall>\\<phi>''.\n           phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n           \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}\n\ngoal (1 subgoal):\n 1. card (trueArgs g \\<phi>) = 0 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card (trueArgs g \\<phi>) = 0 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "case empty"], ["proof (state)\nthis:\n  card (trueArgs g \\<phi>) = 0\n\ngoal (1 subgoal):\n 1. card (trueArgs g \\<phi>) = 0 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "from allDefs_in_allVars[of _ g \"defNode g \\<phi>\"] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?v \\<in> allDefs g (defNode g \\<phi>);\n   defNode g \\<phi> \\<in> set (\\<alpha>n g)\\<rbrakk>\n  \\<Longrightarrow> ?v \\<in> allVars g\n  card (trueArgs g \\<phi>) < 2\n  unnecessaryPhi g \\<phi>", "have phi_var: \"\\<phi> \\<in> allVars g\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> allDefs g (defNode g \\<phi>);\n   defNode g \\<phi> \\<in> set (\\<alpha>n g)\\<rbrakk>\n  \\<Longrightarrow> ?v \\<in> allVars g\n  card (trueArgs g \\<phi>) < 2\n  unnecessaryPhi g \\<phi>\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> allVars g", "unfolding unnecessaryPhi_def phiDefs_def allDefs_def defNode_def phi_def trueArgs_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> defs g (defNode g \\<phi>) \\<union>\n                    {v. (defNode g \\<phi>, v) \\<in> dom (phis g)};\n   defNode g \\<phi> \\<in> set (\\<alpha>n g)\\<rbrakk>\n  \\<Longrightarrow> ?v \\<in> allVars g\n  card\n   ({\\<phi>'. \\<phi>' \\<notin> reachable g \\<phi>} \\<inter>\n    {\\<phi>'.\n     \\<exists>\\<phi>''\\<in>reachable g \\<phi>. phiArg g \\<phi>'' \\<phi>'})\n  < 2\n  phis g (defNode g \\<phi>, \\<phi>) \\<noteq> None \\<and>\n  \\<not> necessaryPhi' g \\<phi>\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> allVars g", "by (clarsimp simp: domIff phis_in_\\<alpha>n)"], ["proof (state)\nthis:\n  \\<phi> \\<in> allVars g\n\ngoal (1 subgoal):\n 1. card (trueArgs g \\<phi>) = 0 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "from empty assms(1)"], ["proof (chain)\npicking this:\n  card (trueArgs g \\<phi>) = 0\n  card (trueArgs g \\<phi>) < 2", "have no_preds: \"trueArgs g \\<phi> = {}\""], ["proof (prove)\nusing this:\n  card (trueArgs g \\<phi>) = 0\n  card (trueArgs g \\<phi>) < 2\n\ngoal (1 subgoal):\n 1. trueArgs g \\<phi> = {}", "by (subst card_0_eq[OF preds_finite, symmetric]) auto"], ["proof (state)\nthis:\n  trueArgs g \\<phi> = {}\n\ngoal (1 subgoal):\n 1. card (trueArgs g \\<phi>) = 0 \\<Longrightarrow>\n    \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pred\\<in>allVars g.\n       \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n          \\<forall>\\<phi>''.\n             phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n             \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}", "proof (rule bexI, rule ballI, rule allI, rule impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi>' \\<phi>''.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        phiArg g \\<phi>' \\<phi>''\\<rbrakk>\n       \\<Longrightarrow> \\<phi>'' \\<in> reachable g \\<phi> \\<union> {?pred}\n 2. ?pred \\<in> allVars g", "fix \\<phi>' \\<phi>''"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi>' \\<phi>''.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        phiArg g \\<phi>' \\<phi>''\\<rbrakk>\n       \\<Longrightarrow> \\<phi>'' \\<in> reachable g \\<phi> \\<union> {?pred}\n 2. ?pred \\<in> allVars g", "assume phis_props: \"\\<phi>' \\<in> reachable g \\<phi>\" \"phiArg g \\<phi>' \\<phi>''\""], ["proof (state)\nthis:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>''\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>' \\<phi>''.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        phiArg g \\<phi>' \\<phi>''\\<rbrakk>\n       \\<Longrightarrow> \\<phi>'' \\<in> reachable g \\<phi> \\<union> {?pred}\n 2. ?pred \\<in> allVars g", "with no_preds"], ["proof (chain)\npicking this:\n  trueArgs g \\<phi> = {}\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>''", "have \"\\<phi>'' \\<in> reachable g \\<phi>\""], ["proof (prove)\nusing this:\n  trueArgs g \\<phi> = {}\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>''\n\ngoal (1 subgoal):\n 1. \\<phi>'' \\<in> reachable g \\<phi>", "unfolding trueArgs_def"], ["proof (prove)\nusing this:\n  {\\<phi>'. \\<phi>' \\<notin> reachable g \\<phi>} \\<inter>\n  {\\<phi>'.\n   \\<exists>\\<phi>''\\<in>reachable g \\<phi>. phiArg g \\<phi>'' \\<phi>'} =\n  {}\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>''\n\ngoal (1 subgoal):\n 1. \\<phi>'' \\<in> reachable g \\<phi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>{\\<phi>'. \\<phi>' \\<notin> reachable g \\<phi>} \\<inter>\n             {\\<phi>'.\n              \\<exists>\\<phi>''\\<in>reachable g \\<phi>.\n                 phiArg g \\<phi>'' \\<phi>'} =\n             {};\n     \\<phi>' \\<in> reachable g \\<phi>; phiArg g \\<phi>' \\<phi>''\\<rbrakk>\n    \\<Longrightarrow> \\<phi>'' \\<in> reachable g \\<phi>", "from phis_props"], ["proof (chain)\npicking this:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>''", "have \"\\<phi>'' \\<in> {\\<phi>'. \\<exists>\\<phi>''\\<in>reachable g \\<phi>. phiArg g \\<phi>'' \\<phi>'}\""], ["proof (prove)\nusing this:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>''\n\ngoal (1 subgoal):\n 1. \\<phi>''\n    \\<in> {\\<phi>'.\n           \\<exists>\\<phi>''\\<in>reachable g \\<phi>.\n              phiArg g \\<phi>'' \\<phi>'}", "by auto"], ["proof (state)\nthis:\n  \\<phi>''\n  \\<in> {\\<phi>'.\n         \\<exists>\\<phi>''\\<in>reachable g \\<phi>.\n            phiArg g \\<phi>'' \\<phi>'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{\\<phi>'. \\<phi>' \\<notin> reachable g \\<phi>} \\<inter>\n             {\\<phi>'.\n              \\<exists>\\<phi>''\\<in>reachable g \\<phi>.\n                 phiArg g \\<phi>'' \\<phi>'} =\n             {};\n     \\<phi>' \\<in> reachable g \\<phi>; phiArg g \\<phi>' \\<phi>''\\<rbrakk>\n    \\<Longrightarrow> \\<phi>'' \\<in> reachable g \\<phi>", "with phis_props no_preds"], ["proof (chain)\npicking this:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>''\n  trueArgs g \\<phi> = {}\n  \\<phi>''\n  \\<in> {\\<phi>'.\n         \\<exists>\\<phi>''\\<in>reachable g \\<phi>.\n            phiArg g \\<phi>'' \\<phi>'}", "show \"\\<phi>'' \\<in> reachable g \\<phi>\""], ["proof (prove)\nusing this:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>''\n  trueArgs g \\<phi> = {}\n  \\<phi>''\n  \\<in> {\\<phi>'.\n         \\<exists>\\<phi>''\\<in>reachable g \\<phi>.\n            phiArg g \\<phi>'' \\<phi>'}\n\ngoal (1 subgoal):\n 1. \\<phi>'' \\<in> reachable g \\<phi>", "unfolding trueArgs_def"], ["proof (prove)\nusing this:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>''\n  {\\<phi>'. \\<phi>' \\<notin> reachable g \\<phi>} \\<inter>\n  {\\<phi>'.\n   \\<exists>\\<phi>''\\<in>reachable g \\<phi>. phiArg g \\<phi>'' \\<phi>'} =\n  {}\n  \\<phi>''\n  \\<in> {\\<phi>'.\n         \\<exists>\\<phi>''\\<in>reachable g \\<phi>.\n            phiArg g \\<phi>'' \\<phi>'}\n\ngoal (1 subgoal):\n 1. \\<phi>'' \\<in> reachable g \\<phi>", "by auto"], ["proof (state)\nthis:\n  \\<phi>'' \\<in> reachable g \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi>'' \\<in> reachable g \\<phi>\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>' \\<phi>''.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        phiArg g \\<phi>' \\<phi>''\\<rbrakk>\n       \\<Longrightarrow> \\<phi>'' \\<in> reachable g \\<phi> \\<union> {?pred}\n 2. ?pred \\<in> allVars g", "thus \"\\<phi>'' \\<in> reachable g \\<phi> \\<union> {\\<phi>}\""], ["proof (prove)\nusing this:\n  \\<phi>'' \\<in> reachable g \\<phi>\n\ngoal (1 subgoal):\n 1. \\<phi>'' \\<in> reachable g \\<phi> \\<union> {\\<phi>}", "by simp"], ["proof (state)\nthis:\n  \\<phi>'' \\<in> reachable g \\<phi> \\<union> {\\<phi>}\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> allVars g", "qed (auto simp: phi_var)"], ["proof (state)\nthis:\n  \\<exists>pred\\<in>allVars g.\n     \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n        \\<forall>\\<phi>''.\n           phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n           \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>pred\\<in>allVars g.\n     \\<forall>\\<phi>'\\<in>reachable g \\<phi>.\n        \\<forall>\\<phi>''.\n           phiArg g \\<phi>' \\<phi>'' \\<longrightarrow>\n           \\<phi>'' \\<in> reachable g \\<phi> \\<union> {pred}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phiArg_trancl_same_var:\nassumes \"(phiArg g)\\<^sup>+\\<^sup>+ \\<phi> n\"\nshows \"var g \\<phi> = var g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var g \\<phi> = var g n", "using assms"], ["proof (prove)\nusing this:\n  (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> n\n\ngoal (1 subgoal):\n 1. var g \\<phi> = var g n", "apply (induction rule: tranclp_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y. phiArg g \\<phi> y \\<Longrightarrow> var g \\<phi> = var g y\n 2. \\<And>y z.\n       \\<lbrakk>(phiArg g)\\<^sup>+\\<^sup>+ \\<phi> y; phiArg g y z;\n        var g \\<phi> = var g y\\<rbrakk>\n       \\<Longrightarrow> var g \\<phi> = var g z", "apply (rule phiArg_same_var[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y. phiArg g \\<phi> y \\<Longrightarrow> phiArg g \\<phi> y\n 2. \\<And>y z.\n       \\<lbrakk>(phiArg g)\\<^sup>+\\<^sup>+ \\<phi> y; phiArg g y z;\n        var g \\<phi> = var g y\\<rbrakk>\n       \\<Longrightarrow> var g \\<phi> = var g z", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(phiArg g)\\<^sup>+\\<^sup>+ \\<phi> y; phiArg g y z;\n        var g \\<phi> = var g y\\<rbrakk>\n       \\<Longrightarrow> var g \\<phi> = var g z", "using phiArg_same_var"], ["proof (prove)\nusing this:\n  phiArg ?g ?p ?q \\<Longrightarrow> var ?g ?q = var ?g ?p\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(phiArg g)\\<^sup>+\\<^sup>+ \\<phi> y; phiArg g y z;\n        var g \\<phi> = var g y\\<rbrakk>\n       \\<Longrightarrow> var g \\<phi> = var g z", "by auto"], ["", "txt \\<open>The following path extension lemma will be used a number of times in the inner induction of the\nmain proof. Basically, the idea is to extend a path ending in a $\\phi$ argument to the corresponding \\pf\\ \nwhile preserving disjointness to a second path.\\<close>"], ["", "lemma phiArg_disjoint_paths_extend:\nassumes \"var g r = V\" and \"var g s = V\" and \"r \\<in> allVars g\" and \"s \\<in> allVars g\"\nand \"V \\<in> oldDefs g n\" and \"V \\<in> oldDefs g m\"\nand \"g \\<turnstile> n-ns\\<rightarrow>defNode g r\" and \"g \\<turnstile> m-ms\\<rightarrow>defNode g s\"\nand \"set ns \\<inter> set ms = {}\"\nand \"phiArg g \\<phi>\\<^sub>r r\"\nobtains ns'\nwhere \"g \\<turnstile> n-ns@ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r\"\nand \"set (butlast (ns@ns')) \\<inter> set ms = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>g \\<turnstile> n-ns @\n                                  ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n         set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"r = \\<phi>\\<^sub>r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r = \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "case (True)"], ["proof (state)\nthis:\n  r = \\<phi>\\<^sub>r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r = \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "txt \\<open>If the node to extend the path to is already the endpoint, the lemma is trivial.\\<close>"], ["proof (state)\nthis:\n  r = \\<phi>\\<^sub>r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r = \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms(7,8,9) in_set_butlastD"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  set ns \\<inter> set ms = {}\n  ?x \\<in> set (butlast ?xs) \\<Longrightarrow> ?x \\<in> set ?xs\n  r = \\<phi>\\<^sub>r", "have \"g \\<turnstile> n-ns@[]\\<rightarrow>defNode g \\<phi>\\<^sub>r\" \"set (butlast (ns@[])) \\<inter> set ms = {}\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  set ns \\<inter> set ms = {}\n  ?x \\<in> set (butlast ?xs) \\<Longrightarrow> ?x \\<in> set ?xs\n  r = \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. g \\<turnstile> n-ns @ []\\<rightarrow>defNode g \\<phi>\\<^sub>r &&&\n    set (butlast (ns @ [])) \\<inter> set ms = {}", "by simp_all fastforce"], ["proof (state)\nthis:\n  g \\<turnstile> n-ns @ []\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast (ns @ [])) \\<inter> set ms = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r = \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "with that"], ["proof (chain)\npicking this:\n  \\<lbrakk>g \\<turnstile> n-ns @ ?ns'1\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n   set (butlast (ns @ ?ns'1)) \\<inter> set ms = {}\\<rbrakk>\n  \\<Longrightarrow> thesis\n  g \\<turnstile> n-ns @ []\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast (ns @ [])) \\<inter> set ms = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>g \\<turnstile> n-ns @ ?ns'1\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n   set (butlast (ns @ ?ns'1)) \\<inter> set ms = {}\\<rbrakk>\n  \\<Longrightarrow> thesis\n  g \\<turnstile> n-ns @ []\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast (ns @ [])) \\<inter> set ms = {}\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  r \\<noteq> \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "txt \\<open>It suffices to obtain any path from r to @{term \\<phi>\\<^sub>r}.\n     However, since we'll need the corresponding predecessor of @{term \\<phi>\\<^sub>r} later, we must do this as follows:\\<close>"], ["proof (state)\nthis:\n  r \\<noteq> \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "from assms(10)"], ["proof (chain)\npicking this:\n  phiArg g \\<phi>\\<^sub>r r", "have \"\\<phi>\\<^sub>r \\<in> allVars g\""], ["proof (prove)\nusing this:\n  phiArg g \\<phi>\\<^sub>r r\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>r \\<in> allVars g", "unfolding phiArg_def"], ["proof (prove)\nusing this:\n  \\<exists>vs. phi g \\<phi>\\<^sub>r = Some vs \\<and> r \\<in> set vs\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>r \\<in> allVars g", "by (metis allDefs_in_allVars phiDefs_in_allDefs phi_def phi_phiDefs phis_in_\\<alpha>n)"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>r \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms(10)"], ["proof (chain)\npicking this:\n  phiArg g \\<phi>\\<^sub>r r\n  \\<phi>\\<^sub>r \\<in> allVars g", "obtain rs' pred\\<^sub>\\<phi>\\<^sub>r where rs'_props: \"g \\<turnstile> defNode g r-rs'\\<rightarrow> pred\\<^sub>\\<phi>\\<^sub>r\" \"old.EntryPath g rs'\" \"r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r\" \"pred\\<^sub>\\<phi>\\<^sub>r \\<in> set (old.predecessors g (defNode g \\<phi>\\<^sub>r))\""], ["proof (prove)\nusing this:\n  phiArg g \\<phi>\\<^sub>r r\n  \\<phi>\\<^sub>r \\<in> allVars g\n\ngoal (1 subgoal):\n 1. (\\<And>rs' pred\\<^sub>\\<phi>\\<^sub>r.\n        \\<lbrakk>g \\<turnstile> defNode g\n                                 r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r;\n         old.EntryPath g rs'; r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r;\n         pred\\<^sub>\\<phi>\\<^sub>r\n         \\<in> set (old.predecessors g (defNode g \\<phi>\\<^sub>r))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule phiArg_path_ex')"], ["proof (state)\nthis:\n  g \\<turnstile> defNode g r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  old.EntryPath g rs'\n  r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r\n  pred\\<^sub>\\<phi>\\<^sub>r\n  \\<in> set (old.predecessors g (defNode g \\<phi>\\<^sub>r))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "define rs where \"rs = rs'@[defNode g \\<phi>\\<^sub>r]\""], ["proof (state)\nthis:\n  rs = rs' @ [defNode g \\<phi>\\<^sub>r]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "from rs'_props(2,1) old.EntryPath_distinct old.path2_hd"], ["proof (chain)\npicking this:\n  old.EntryPath g rs'\n  g \\<turnstile> defNode g r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  old.EntryPath ?g ?ns \\<Longrightarrow> distinct ?ns\n  ?g \\<turnstile> ?n-?ns\\<rightarrow>?m \\<Longrightarrow> ?n = hd ?ns", "have rs'_loopfree: \"defNode g r \\<notin> set (tl rs')\""], ["proof (prove)\nusing this:\n  old.EntryPath g rs'\n  g \\<turnstile> defNode g r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  old.EntryPath ?g ?ns \\<Longrightarrow> distinct ?ns\n  ?g \\<turnstile> ?n-?ns\\<rightarrow>?m \\<Longrightarrow> ?n = hd ?ns\n\ngoal (1 subgoal):\n 1. defNode g r \\<notin> set (tl rs')", "by (simp add: Misc.distinct_hd_tl)"], ["proof (state)\nthis:\n  defNode g r \\<notin> set (tl rs')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "from False assms"], ["proof (chain)\npicking this:\n  r \\<noteq> \\<phi>\\<^sub>r\n  var g r = V\n  var g s = V\n  r \\<in> allVars g\n  s \\<in> allVars g\n  V \\<in> oldDefs g n\n  V \\<in> oldDefs g m\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  set ns \\<inter> set ms = {}\n  phiArg g \\<phi>\\<^sub>r r", "have \"defNode g \\<phi>\\<^sub>r \\<noteq> defNode g r\""], ["proof (prove)\nusing this:\n  r \\<noteq> \\<phi>\\<^sub>r\n  var g r = V\n  var g s = V\n  r \\<in> allVars g\n  s \\<in> allVars g\n  V \\<in> oldDefs g n\n  V \\<in> oldDefs g m\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  set ns \\<inter> set ms = {}\n  phiArg g \\<phi>\\<^sub>r r\n\ngoal (1 subgoal):\n 1. defNode g \\<phi>\\<^sub>r \\<noteq> defNode g r", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<noteq> \\<phi>\\<^sub>r; var g r = V; var g s = V;\n     r \\<in> allVars g; s \\<in> allVars g; V \\<in> oldDefs g n;\n     V \\<in> oldDefs g m; g \\<turnstile> n-ns\\<rightarrow>defNode g r;\n     g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n     set ns \\<inter> set ms = {}; phiArg g \\<phi>\\<^sub>r r\\<rbrakk>\n    \\<Longrightarrow> defNode g \\<phi>\\<^sub>r \\<noteq> defNode g r", "apply (rule phiArg_distinct_nodes)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>r \\<noteq> \\<phi>\\<^sub>r; var g r = V; var g s = V;\n     r \\<in> allVars g; s \\<in> allVars g; V \\<in> oldDefs g n;\n     V \\<in> oldDefs g m; g \\<turnstile> n-ns\\<rightarrow>defNode g r;\n     g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n     set ns \\<inter> set ms = {}; phiArg g \\<phi>\\<^sub>r r\\<rbrakk>\n    \\<Longrightarrow> phiArg g \\<phi>\\<^sub>r r\n 2. \\<lbrakk>r \\<noteq> \\<phi>\\<^sub>r; var g r = V; var g s = V;\n     r \\<in> allVars g; s \\<in> allVars g; V \\<in> oldDefs g n;\n     V \\<in> oldDefs g m; g \\<turnstile> n-ns\\<rightarrow>defNode g r;\n     g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n     set ns \\<inter> set ms = {}; phiArg g \\<phi>\\<^sub>r r\\<rbrakk>\n    \\<Longrightarrow> \\<phi>\\<^sub>r \\<noteq> r\n 3. \\<lbrakk>r \\<noteq> \\<phi>\\<^sub>r; var g r = V; var g s = V;\n     r \\<in> allVars g; s \\<in> allVars g; V \\<in> oldDefs g n;\n     V \\<in> oldDefs g m; g \\<turnstile> n-ns\\<rightarrow>defNode g r;\n     g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n     set ns \\<inter> set ms = {}; phiArg g \\<phi>\\<^sub>r r\\<rbrakk>\n    \\<Longrightarrow> \\<phi>\\<^sub>r \\<in> allVars g", "apply (auto intro:phiArg_in_allVars)[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<noteq> \\<phi>\\<^sub>r; var g r = V; var g s = V;\n     r \\<in> allVars g; s \\<in> allVars g; V \\<in> oldDefs g n;\n     V \\<in> oldDefs g m; g \\<turnstile> n-ns\\<rightarrow>defNode g r;\n     g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n     set ns \\<inter> set ms = {}; phiArg g \\<phi>\\<^sub>r r\\<rbrakk>\n    \\<Longrightarrow> \\<phi>\\<^sub>r \\<in> allVars g", "unfolding phiArg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<noteq> \\<phi>\\<^sub>r; var g r = V; var g s = V;\n     r \\<in> allVars g; s \\<in> allVars g; V \\<in> oldDefs g n;\n     V \\<in> oldDefs g m; g \\<turnstile> n-ns\\<rightarrow>defNode g r;\n     g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n     set ns \\<inter> set ms = {};\n     \\<exists>vs.\n        phi g \\<phi>\\<^sub>r = Some vs \\<and> r \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> \\<phi>\\<^sub>r \\<in> allVars g", "by (metis allDefs_in_allVars phiDefs_in_allDefs phi_def phi_phiDefs phis_in_\\<alpha>n)"], ["proof (state)\nthis:\n  defNode g \\<phi>\\<^sub>r \\<noteq> defNode g r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "from rs'_props"], ["proof (chain)\npicking this:\n  g \\<turnstile> defNode g r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  old.EntryPath g rs'\n  r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r\n  pred\\<^sub>\\<phi>\\<^sub>r\n  \\<in> set (old.predecessors g (defNode g \\<phi>\\<^sub>r))", "have rs_props: \"g \\<turnstile> defNode g r-rs\\<rightarrow> defNode g \\<phi>\\<^sub>r\" \"length rs > 1\" \"defNode g r \\<notin> set (tl rs)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> defNode g r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  old.EntryPath g rs'\n  r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r\n  pred\\<^sub>\\<phi>\\<^sub>r\n  \\<in> set (old.predecessors g (defNode g \\<phi>\\<^sub>r))\n\ngoal (1 subgoal):\n 1. g \\<turnstile> defNode g r-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r &&&\n    1 < length rs &&& defNode g r \\<notin> set (tl rs)", "apply (subgoal_tac \"defNode g r = hd rs'\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>g \\<turnstile> defNode g\n                             r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r;\n     old.EntryPath g rs'; r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r;\n     pred\\<^sub>\\<phi>\\<^sub>r\n     \\<in> set (old.predecessors g (defNode g \\<phi>\\<^sub>r));\n     defNode g r = hd rs'\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> defNode g\nr-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 2. \\<lbrakk>g \\<turnstile> defNode g\n                             r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r;\n     old.EntryPath g rs'; r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r;\n     pred\\<^sub>\\<phi>\\<^sub>r\n     \\<in> set (old.predecessors g (defNode g \\<phi>\\<^sub>r))\\<rbrakk>\n    \\<Longrightarrow> defNode g r = hd rs'\n 3. 1 < length rs\n 4. defNode g r \\<notin> set (tl rs)", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>g \\<turnstile> defNode g\n                             r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r;\n     old.EntryPath g rs'; r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r;\n     pred\\<^sub>\\<phi>\\<^sub>r\n     \\<in> set (old.predecessors g (defNode g \\<phi>\\<^sub>r))\\<rbrakk>\n    \\<Longrightarrow> defNode g r = hd rs'\n 2. \\<lbrakk>g \\<turnstile> defNode g\n                             r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r;\n     old.EntryPath g rs'; r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r;\n     pred\\<^sub>\\<phi>\\<^sub>r\n     \\<in> set (old.predecessors g (defNode g \\<phi>\\<^sub>r));\n     defNode g r = hd rs'\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> defNode g\nr-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 3. 1 < length rs\n 4. defNode g r \\<notin> set (tl rs)", "using rs'_props(1)"], ["proof (prove)\nusing this:\n  g \\<turnstile> defNode g r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n\ngoal (4 subgoals):\n 1. \\<lbrakk>g \\<turnstile> defNode g\n                             r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r;\n     old.EntryPath g rs'; r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r;\n     pred\\<^sub>\\<phi>\\<^sub>r\n     \\<in> set (old.predecessors g (defNode g \\<phi>\\<^sub>r))\\<rbrakk>\n    \\<Longrightarrow> defNode g r = hd rs'\n 2. \\<lbrakk>g \\<turnstile> defNode g\n                             r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r;\n     old.EntryPath g rs'; r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r;\n     pred\\<^sub>\\<phi>\\<^sub>r\n     \\<in> set (old.predecessors g (defNode g \\<phi>\\<^sub>r));\n     defNode g r = hd rs'\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> defNode g\nr-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 3. 1 < length rs\n 4. defNode g r \\<notin> set (tl rs)", "apply (rule old.path2_hd)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>g \\<turnstile> defNode g\n                             r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r;\n     old.EntryPath g rs'; r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r;\n     pred\\<^sub>\\<phi>\\<^sub>r\n     \\<in> set (old.predecessors g (defNode g \\<phi>\\<^sub>r));\n     defNode g r = hd rs'\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> defNode g\nr-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 2. 1 < length rs\n 3. defNode g r \\<notin> set (tl rs)", "using old.path2_snoc old.path2_def rs'_props(1) rs_def rs'_loopfree \\<open>defNode g \\<phi>\\<^sub>r \\<noteq> defNode g r\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<turnstile> ?n-?ns\\<rightarrow>?m;\n   ?m \\<in> set (old.predecessors ?g ?m')\\<rbrakk>\n  \\<Longrightarrow> ?g \\<turnstile> ?n-?ns @ [?m']\\<rightarrow>?m'\n  ?g \\<turnstile> ?n-?ns\\<rightarrow>?m \\<equiv>\n  old.path ?g ?ns \\<and> ?n = hd ?ns \\<and> ?m = last ?ns\n  g \\<turnstile> defNode g r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  rs = rs' @ [defNode g \\<phi>\\<^sub>r]\n  defNode g r \\<notin> set (tl rs')\n  defNode g \\<phi>\\<^sub>r \\<noteq> defNode g r\n\ngoal (3 subgoals):\n 1. \\<lbrakk>g \\<turnstile> defNode g\n                             r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r;\n     old.EntryPath g rs'; r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r;\n     pred\\<^sub>\\<phi>\\<^sub>r\n     \\<in> set (old.predecessors g (defNode g \\<phi>\\<^sub>r));\n     defNode g r = hd rs'\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> defNode g\nr-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 2. 1 < length rs\n 3. defNode g r \\<notin> set (tl rs)", "by auto"], ["proof (state)\nthis:\n  g \\<turnstile> defNode g r-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  1 < length rs\n  defNode g r \\<notin> set (tl rs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns'.\n                \\<lbrakk>g \\<turnstile> n-ns @\n    ns'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n                 set (butlast (ns @ ns')) \\<inter> set ms = {}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     r \\<noteq> \\<phi>\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"set (butlast rs) \\<inter> set ms = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. set (butlast rs) \\<inter> set ms = {} \\<Longrightarrow> thesis\n 2. set (butlast rs) \\<inter> set ms \\<noteq> {} \\<Longrightarrow> thesis", "case inter_empty: True"], ["proof (state)\nthis:\n  set (butlast rs) \\<inter> set ms = {}\n\ngoal (2 subgoals):\n 1. set (butlast rs) \\<inter> set ms = {} \\<Longrightarrow> thesis\n 2. set (butlast rs) \\<inter> set ms \\<noteq> {} \\<Longrightarrow> thesis", "txt \\<open>If the intersection of these is empty, @{term \"tl rs\"} is already the extension we're looking for\\<close>"], ["proof (state)\nthis:\n  set (butlast rs) \\<inter> set ms = {}\n\ngoal (2 subgoals):\n 1. set (butlast rs) \\<inter> set ms = {} \\<Longrightarrow> thesis\n 2. set (butlast rs) \\<inter> set ms \\<noteq> {} \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule that)"], ["proof (state)\ngoal (2 subgoals):\n 1. g \\<turnstile> n-ns @ ?ns'1\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 2. set (butlast (ns @ ?ns'1)) \\<inter> set ms = {}", "show \"set (butlast (ns @ tl rs)) \\<inter> set ms = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (butlast (ns @ tl rs)) \\<inter> set ms = {}", "proof (rule ccontr, simp only: ex_in_conv[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> set (butlast (ns @ tl rs)) \\<inter> set ms \\<Longrightarrow>\n    False", "assume \"\\<exists>x. x \\<in> set (butlast (ns @ tl rs)) \\<inter> set ms\""], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> set (butlast (ns @ tl rs)) \\<inter> set ms\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> set (butlast (ns @ tl rs)) \\<inter> set ms \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. x \\<in> set (butlast (ns @ tl rs)) \\<inter> set ms", "obtain x where x_props: \"x \\<in> set (butlast (ns @ tl rs))\" \"x \\<in> set ms\""], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> set (butlast (ns @ tl rs)) \\<inter> set ms\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set (butlast (ns @ tl rs)); x \\<in> set ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (butlast (ns @ tl rs))\n  x \\<in> set ms\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> set (butlast (ns @ tl rs)) \\<inter> set ms \\<Longrightarrow>\n    False", "with rs_props(2)"], ["proof (chain)\npicking this:\n  1 < length rs\n  x \\<in> set (butlast (ns @ tl rs))\n  x \\<in> set ms", "consider (in_ns) \"x \\<in> set ns\" | (in_rs) \"x \\<in> set (butlast (tl rs))\""], ["proof (prove)\nusing this:\n  1 < length rs\n  x \\<in> set (butlast (ns @ tl rs))\n  x \\<in> set ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ns \\<Longrightarrow> thesis;\n     x \\<in> set (butlast (tl rs)) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis Un_iff butlast_append in_set_butlastD set_append)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> set ns \\<Longrightarrow> ?thesis1;\n   x \\<in> set (butlast (tl rs)) \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> set (butlast (ns @ tl rs)) \\<inter> set ms \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> set ns \\<Longrightarrow> ?thesis1;\n   x \\<in> set (butlast (tl rs)) \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. False", "apply (cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> set ns \\<Longrightarrow> False\n 2. x \\<in> set (butlast (tl rs)) \\<Longrightarrow> False", "using x_props(2) assms(9)"], ["proof (prove)\nusing this:\n  x \\<in> set ms\n  set ns \\<inter> set ms = {}\n\ngoal (2 subgoals):\n 1. x \\<in> set ns \\<Longrightarrow> False\n 2. x \\<in> set (butlast (tl rs)) \\<Longrightarrow> False", "apply (simp add: disjoint_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (butlast (tl rs)) \\<Longrightarrow> False", "by (metis x_props(2) inter_empty in_set_tlD List.butlast_tl disjoint_iff_not_equal)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (butlast (ns @ tl rs)) \\<inter> set ms = {}\n\ngoal (1 subgoal):\n 1. g \\<turnstile> n-ns @ tl rs\\<rightarrow>defNode g \\<phi>\\<^sub>r", "qed (auto intro:assms(7) rs_props(1) old.path2_app)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. set (butlast rs) \\<inter> set ms \\<noteq> {} \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set (butlast rs) \\<inter> set ms \\<noteq> {} \\<Longrightarrow> thesis", "case inter_ex: False"], ["proof (state)\nthis:\n  set (butlast rs) \\<inter> set ms \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set (butlast rs) \\<inter> set ms \\<noteq> {} \\<Longrightarrow> thesis", "txt \\<open>If the intersection is nonempty, there must be a first point of intersection @{term i}.\\<close>"], ["proof (state)\nthis:\n  set (butlast rs) \\<inter> set ms \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set (butlast rs) \\<inter> set ms \\<noteq> {} \\<Longrightarrow> thesis", "from inter_ex assms(7,8) rs_props"], ["proof (chain)\npicking this:\n  set (butlast rs) \\<inter> set ms \\<noteq> {}\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  g \\<turnstile> defNode g r-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  1 < length rs\n  defNode g r \\<notin> set (tl rs)", "obtain i ri where ri_props: \"g \\<turnstile> defNode g r-ri\\<rightarrow>i\" \"i \\<in> set ms\" \"\\<forall>n \\<in> set (butlast ri). n \\<notin> set ms\" \"prefix ri rs\""], ["proof (prove)\nusing this:\n  set (butlast rs) \\<inter> set ms \\<noteq> {}\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  g \\<turnstile> defNode g r-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  1 < length rs\n  defNode g r \\<notin> set (tl rs)\n\ngoal (1 subgoal):\n 1. (\\<And>ri i.\n        \\<lbrakk>g \\<turnstile> defNode g r-ri\\<rightarrow>i;\n         i \\<in> set ms; \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms;\n         prefix ri rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ri i.\n                \\<lbrakk>g \\<turnstile> defNode g r-ri\\<rightarrow>i;\n                 i \\<in> set ms;\n                 \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms;\n                 prefix ri rs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     set (butlast rs) \\<inter> set ms \\<noteq> {};\n     g \\<turnstile> n-ns\\<rightarrow>defNode g r;\n     g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n     g \\<turnstile> defNode g r-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     1 < length rs; defNode g r \\<notin> set (tl rs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (rule old.path2_split_first_prop[of g \"defNode g r\" rs \"defNode g \\<phi>\\<^sub>r\", where P=\"\\<lambda>m. m \\<in> set ms\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>ri i.\n                \\<lbrakk>g \\<turnstile> defNode g r-ri\\<rightarrow>i;\n                 i \\<in> set ms;\n                 \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms;\n                 prefix ri rs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     set (butlast rs) \\<inter> set ms \\<noteq> {};\n     g \\<turnstile> n-ns\\<rightarrow>defNode g r;\n     g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n     g \\<turnstile> defNode g r-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     1 < length rs; defNode g r \\<notin> set (tl rs)\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> defNode g\nr-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 2. \\<lbrakk>\\<And>ri i.\n                \\<lbrakk>g \\<turnstile> defNode g r-ri\\<rightarrow>i;\n                 i \\<in> set ms;\n                 \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms;\n                 prefix ri rs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     set (butlast rs) \\<inter> set ms \\<noteq> {};\n     g \\<turnstile> n-ns\\<rightarrow>defNode g r;\n     g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n     g \\<turnstile> defNode g r-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     1 < length rs; defNode g r \\<notin> set (tl rs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>set rs. x \\<in> set ms\n 3. \\<And>m' ns'.\n       \\<lbrakk>\\<And>ri i.\n                   \\<lbrakk>g \\<turnstile> defNode g r-ri\\<rightarrow>i;\n                    i \\<in> set ms;\n                    \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms;\n                    prefix ri rs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        set (butlast rs) \\<inter> set ms \\<noteq> {};\n        g \\<turnstile> n-ns\\<rightarrow>defNode g r;\n        g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n        g \\<turnstile> defNode g r-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n        1 < length rs; defNode g r \\<notin> set (tl rs);\n        g \\<turnstile> defNode g r-ns'\\<rightarrow>m'; m' \\<in> set ms;\n        \\<forall>x\\<in>set (butlast ns'). x \\<notin> set ms;\n        prefix ns' rs\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ri i.\n                \\<lbrakk>g \\<turnstile> defNode g r-ri\\<rightarrow>i;\n                 i \\<in> set ms;\n                 \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms;\n                 prefix ri rs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     set (butlast rs) \\<inter> set ms \\<noteq> {};\n     g \\<turnstile> n-ns\\<rightarrow>defNode g r;\n     g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n     g \\<turnstile> defNode g r-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     1 < length rs; defNode g r \\<notin> set (tl rs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>set rs. x \\<in> set ms\n 2. \\<And>m' ns'.\n       \\<lbrakk>\\<And>ri i.\n                   \\<lbrakk>g \\<turnstile> defNode g r-ri\\<rightarrow>i;\n                    i \\<in> set ms;\n                    \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms;\n                    prefix ri rs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        set (butlast rs) \\<inter> set ms \\<noteq> {};\n        g \\<turnstile> n-ns\\<rightarrow>defNode g r;\n        g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n        g \\<turnstile> defNode g r-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n        1 < length rs; defNode g r \\<notin> set (tl rs);\n        g \\<turnstile> defNode g r-ns'\\<rightarrow>m'; m' \\<in> set ms;\n        \\<forall>x\\<in>set (butlast ns'). x \\<notin> set ms;\n        prefix ns' rs\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (metis disjoint_iff_not_equal in_set_butlastD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' ns'.\n       \\<lbrakk>\\<And>ri i.\n                   \\<lbrakk>g \\<turnstile> defNode g r-ri\\<rightarrow>i;\n                    i \\<in> set ms;\n                    \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms;\n                    prefix ri rs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        set (butlast rs) \\<inter> set ms \\<noteq> {};\n        g \\<turnstile> n-ns\\<rightarrow>defNode g r;\n        g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n        g \\<turnstile> defNode g r-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n        1 < length rs; defNode g r \\<notin> set (tl rs);\n        g \\<turnstile> defNode g r-ns'\\<rightarrow>m'; m' \\<in> set ms;\n        \\<forall>x\\<in>set (butlast ns'). x \\<notin> set ms;\n        prefix ns' rs\\<rbrakk>\n       \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  g \\<turnstile> defNode g r-ri\\<rightarrow>i\n  i \\<in> set ms\n  \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms\n  prefix ri rs\n\ngoal (1 subgoal):\n 1. set (butlast rs) \\<inter> set ms \\<noteq> {} \\<Longrightarrow> thesis", "with assms(8) old.path2_prefix_ex"], ["proof (chain)\npicking this:\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  \\<lbrakk>?g \\<turnstile> ?n-?ns\\<rightarrow>?m; ?m' \\<in> set ?ns;\n   \\<And>ns'.\n      \\<lbrakk>?g \\<turnstile> ?n-ns'\\<rightarrow>?m'; prefix ns' ?ns;\n       ?m' \\<notin> set (butlast ns')\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  g \\<turnstile> defNode g r-ri\\<rightarrow>i\n  i \\<in> set ms\n  \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms\n  prefix ri rs", "obtain ms' where ms'_props: \"g \\<turnstile> m -ms'\\<rightarrow> i\" \"prefix ms' ms\" \"i \\<notin> set (butlast ms')\""], ["proof (prove)\nusing this:\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  \\<lbrakk>?g \\<turnstile> ?n-?ns\\<rightarrow>?m; ?m' \\<in> set ?ns;\n   \\<And>ns'.\n      \\<lbrakk>?g \\<turnstile> ?n-ns'\\<rightarrow>?m'; prefix ns' ?ns;\n       ?m' \\<notin> set (butlast ns')\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  g \\<turnstile> defNode g r-ri\\<rightarrow>i\n  i \\<in> set ms\n  \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms\n  prefix ri rs\n\ngoal (1 subgoal):\n 1. (\\<And>ms'.\n        \\<lbrakk>g \\<turnstile> m-ms'\\<rightarrow>i; prefix ms' ms;\n         i \\<notin> set (butlast ms')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  g \\<turnstile> m-ms'\\<rightarrow>i\n  prefix ms' ms\n  i \\<notin> set (butlast ms')\n\ngoal (1 subgoal):\n 1. set (butlast rs) \\<inter> set ms \\<noteq> {} \\<Longrightarrow> thesis", "txt \\<open>We proceed by case distinction:\n      \\<^item> if @{prop \"i = defNode g \\<phi>\\<^sub>r\"}, the path @{term ri} is already the path extension we're looking for\n      \\<^item> Otherwise, the fact that @{term i} is on the path from $\\phi$ argument to the $\\phi$ itself leads to a contradiction.\n        However, we still need to distinguish the cases of whether @{prop \"m = i\"}\\<close>"], ["proof (state)\nthis:\n  g \\<turnstile> m-ms'\\<rightarrow>i\n  prefix ms' ms\n  i \\<notin> set (butlast ms')\n\ngoal (1 subgoal):\n 1. set (butlast rs) \\<inter> set ms \\<noteq> {} \\<Longrightarrow> thesis", "consider (ri_is_valid) \"i = defNode g \\<phi>\\<^sub>r\" | (m_i_same) \"i \\<noteq> defNode g \\<phi>\\<^sub>r\" \"m = i\" | (m_i_differ) \"i \\<noteq> defNode g \\<phi>\\<^sub>r\" \"m \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis;\n     \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>i = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n   \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n   \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. set (butlast rs) \\<inter> set ms \\<noteq> {} \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>i = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n   \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n   \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. thesis", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. i = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "case ri_is_valid"], ["proof (state)\nthis:\n  i = defNode g \\<phi>\\<^sub>r\n\ngoal (3 subgoals):\n 1. i = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "txt \\<open>@{term ri} is a valid path extension.\\<close>"], ["proof (state)\nthis:\n  i = defNode g \\<phi>\\<^sub>r\n\ngoal (3 subgoals):\n 1. i = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms(7) ri_props(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  g \\<turnstile> defNode g r-ri\\<rightarrow>i\n  i = defNode g \\<phi>\\<^sub>r", "have \"g \\<turnstile> n -ns@(tl ri)\\<rightarrow> defNode g \\<phi>\\<^sub>r\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  g \\<turnstile> defNode g r-ri\\<rightarrow>i\n  i = defNode g \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. g \\<turnstile> n-ns @ tl ri\\<rightarrow>defNode g \\<phi>\\<^sub>r", "by auto"], ["proof (state)\nthis:\n  g \\<turnstile> n-ns @ tl ri\\<rightarrow>defNode g \\<phi>\\<^sub>r\n\ngoal (3 subgoals):\n 1. i = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  g \\<turnstile> n-ns @ tl ri\\<rightarrow>defNode g \\<phi>\\<^sub>r\n\ngoal (3 subgoals):\n 1. i = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"set (butlast (ns@(tl ri))) \\<inter> set ms = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (butlast (ns @ tl ri)) \\<inter> set ms = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. set (butlast (ns @ tl ri)) \\<inter> set ms \\<noteq> {} \\<Longrightarrow>\n    False", "assume contr: \"set (butlast (ns @ tl ri)) \\<inter> set ms \\<noteq> {}\""], ["proof (state)\nthis:\n  set (butlast (ns @ tl ri)) \\<inter> set ms \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set (butlast (ns @ tl ri)) \\<inter> set ms \\<noteq> {} \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  set (butlast (ns @ tl ri)) \\<inter> set ms \\<noteq> {}", "obtain x where x_props: \"x \\<in> set (butlast (ns @ tl ri))\" \"x \\<in> set ms\""], ["proof (prove)\nusing this:\n  set (butlast (ns @ tl ri)) \\<inter> set ms \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set (butlast (ns @ tl ri)); x \\<in> set ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (butlast (ns @ tl ri))\n  x \\<in> set ms\n\ngoal (1 subgoal):\n 1. set (butlast (ns @ tl ri)) \\<inter> set ms \\<noteq> {} \\<Longrightarrow>\n    False", "with assms(9)"], ["proof (chain)\npicking this:\n  set ns \\<inter> set ms = {}\n  x \\<in> set (butlast (ns @ tl ri))\n  x \\<in> set ms", "have \"x \\<notin> set ns\""], ["proof (prove)\nusing this:\n  set ns \\<inter> set ms = {}\n  x \\<in> set (butlast (ns @ tl ri))\n  x \\<in> set ms\n\ngoal (1 subgoal):\n 1. x \\<notin> set ns", "by auto"], ["proof (state)\nthis:\n  x \\<notin> set ns\n\ngoal (1 subgoal):\n 1. set (butlast (ns @ tl ri)) \\<inter> set ms \\<noteq> {} \\<Longrightarrow>\n    False", "with x_props \\<open>g \\<turnstile> n-ns @ tl ri\\<rightarrow>defNode g \\<phi>\\<^sub>r\\<close> \\<open>defNode g \\<phi>\\<^sub>r \\<noteq> defNode g r\\<close> assms(7)"], ["proof (chain)\npicking this:\n  x \\<in> set (butlast (ns @ tl ri))\n  x \\<in> set ms\n  g \\<turnstile> n-ns @ tl ri\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  defNode g \\<phi>\\<^sub>r \\<noteq> defNode g r\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  x \\<notin> set ns", "have \"x \\<in> set (butlast (tl ri))\""], ["proof (prove)\nusing this:\n  x \\<in> set (butlast (ns @ tl ri))\n  x \\<in> set ms\n  g \\<turnstile> n-ns @ tl ri\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  defNode g \\<phi>\\<^sub>r \\<noteq> defNode g r\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  x \\<notin> set ns\n\ngoal (1 subgoal):\n 1. x \\<in> set (butlast (tl ri))", "by (metis Un_iff append_Nil2 butlast_append old.path2_last set_append)"], ["proof (state)\nthis:\n  x \\<in> set (butlast (tl ri))\n\ngoal (1 subgoal):\n 1. set (butlast (ns @ tl ri)) \\<inter> set ms \\<noteq> {} \\<Longrightarrow>\n    False", "with x_props(2) ri_props(3)"], ["proof (chain)\npicking this:\n  x \\<in> set ms\n  \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms\n  x \\<in> set (butlast (tl ri))", "show \"False\""], ["proof (prove)\nusing this:\n  x \\<in> set ms\n  \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms\n  x \\<in> set (butlast (tl ri))\n\ngoal (1 subgoal):\n 1. False", "by (metis FormalSSA_Misc.in_set_tlD List.butlast_tl)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (butlast (ns @ tl ri)) \\<inter> set ms = {}\n\ngoal (3 subgoals):\n 1. i = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns @ tl ri\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast (ns @ tl ri)) \\<inter> set ms = {}", "show thesis"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns @ tl ri\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast (ns @ tl ri)) \\<inter> set ms = {}\n\ngoal (1 subgoal):\n 1. thesis", "by (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "case m_i_same"], ["proof (state)\nthis:\n  i \\<noteq> defNode g \\<phi>\\<^sub>r\n  m = i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "txt \\<open>If @{prop \"m = i\"}, we have, with @{term m}, a variable definition on the path from a \\pf\\ to its argument.\n          This constitutes a contradiction to the conventional property.\\<close>"], ["proof (state)\nthis:\n  i \\<noteq> defNode g \\<phi>\\<^sub>r\n  m = i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "note rs'_props(1) rs'_loopfree"], ["proof (state)\nthis:\n  g \\<turnstile> defNode g r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  defNode g r \\<notin> set (tl rs')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  g \\<turnstile> defNode g r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  defNode g r \\<notin> set (tl rs')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"r \\<in> allDefs g (defNode g r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> allDefs g (defNode g r)", "by (simp add: assms(3))"], ["proof (state)\nthis:\n  r \\<in> allDefs g (defNode g r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  r \\<in> allDefs g (defNode g r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "from rs'_props(3)"], ["proof (chain)\npicking this:\n  r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r", "have \"r \\<in> allUses g pred\\<^sub>\\<phi>\\<^sub>r\""], ["proof (prove)\nusing this:\n  r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. r \\<in> allUses g pred\\<^sub>\\<phi>\\<^sub>r", "unfolding allUses_def"], ["proof (prove)\nusing this:\n  r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. r \\<in> uses g pred\\<^sub>\\<phi>\\<^sub>r \\<union>\n            phiUses g pred\\<^sub>\\<phi>\\<^sub>r", "by simp"], ["proof (state)\nthis:\n  r \\<in> allUses g pred\\<^sub>\\<phi>\\<^sub>r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  r \\<in> allUses g pred\\<^sub>\\<phi>\\<^sub>r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "from rs_props(1) m_i_same rs_def ri_props(1,2,4) \\<open>defNode g \\<phi>\\<^sub>r \\<noteq> defNode g r\\<close> assms(7,9)"], ["proof (chain)\npicking this:\n  g \\<turnstile> defNode g r-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  i \\<noteq> defNode g \\<phi>\\<^sub>r\n  m = i\n  rs = rs' @ [defNode g \\<phi>\\<^sub>r]\n  g \\<turnstile> defNode g r-ri\\<rightarrow>i\n  i \\<in> set ms\n  prefix ri rs\n  defNode g \\<phi>\\<^sub>r \\<noteq> defNode g r\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  set ns \\<inter> set ms = {}", "have \"m \\<in> set (tl rs')\""], ["proof (prove)\nusing this:\n  g \\<turnstile> defNode g r-rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  i \\<noteq> defNode g \\<phi>\\<^sub>r\n  m = i\n  rs = rs' @ [defNode g \\<phi>\\<^sub>r]\n  g \\<turnstile> defNode g r-ri\\<rightarrow>i\n  i \\<in> set ms\n  prefix ri rs\n  defNode g \\<phi>\\<^sub>r \\<noteq> defNode g r\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  set ns \\<inter> set ms = {}\n\ngoal (1 subgoal):\n 1. m \\<in> set (tl rs')", "by (metis disjoint_elem hd_append in_hd_or_tl_conv in_prefix list.sel(1) old.path2_hd old.path2_last old.path2_last_in_ns prefix_snoc)"], ["proof (state)\nthis:\n  m \\<in> set (tl rs')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  m \\<in> set (tl rs')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "from assms(6)"], ["proof (chain)\npicking this:\n  V \\<in> oldDefs g m", "obtain def\\<^sub>m where \"def\\<^sub>m \\<in> allDefs g m\" \"var g def\\<^sub>m = V\""], ["proof (prove)\nusing this:\n  V \\<in> oldDefs g m\n\ngoal (1 subgoal):\n 1. (\\<And>def\\<^sub>m.\n        \\<lbrakk>def\\<^sub>m \\<in> allDefs g m;\n         var g def\\<^sub>m = V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding oldDefs_def"], ["proof (prove)\nusing this:\n  V \\<in> var g ` defs g m\n\ngoal (1 subgoal):\n 1. (\\<And>def\\<^sub>m.\n        \\<lbrakk>def\\<^sub>m \\<in> allDefs g m;\n         var g def\\<^sub>m = V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using defs_in_allDefs"], ["proof (prove)\nusing this:\n  V \\<in> var g ` defs g m\n  ?v \\<in> defs ?g ?n \\<Longrightarrow> ?v \\<in> allDefs ?g ?n\n\ngoal (1 subgoal):\n 1. (\\<And>def\\<^sub>m.\n        \\<lbrakk>def\\<^sub>m \\<in> allDefs g m;\n         var g def\\<^sub>m = V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  def\\<^sub>m \\<in> allDefs g m\n  var g def\\<^sub>m = V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  g \\<turnstile> defNode g r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  defNode g r \\<notin> set (tl rs')\n  r \\<in> allDefs g (defNode g r)\n  r \\<in> allUses g pred\\<^sub>\\<phi>\\<^sub>r\n  m \\<in> set (tl rs')\n  def\\<^sub>m \\<in> allDefs g m\n  var g def\\<^sub>m = V", "have \"var g def\\<^sub>m \\<noteq> var g r\""], ["proof (prove)\nusing this:\n  g \\<turnstile> defNode g r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  defNode g r \\<notin> set (tl rs')\n  r \\<in> allDefs g (defNode g r)\n  r \\<in> allUses g pred\\<^sub>\\<phi>\\<^sub>r\n  m \\<in> set (tl rs')\n  def\\<^sub>m \\<in> allDefs g m\n  var g def\\<^sub>m = V\n\ngoal (1 subgoal):\n 1. var g def\\<^sub>m \\<noteq> var g r", "by - (rule conventional, simp_all)"], ["proof (state)\nthis:\n  var g def\\<^sub>m \\<noteq> var g r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<open>var g def\\<^sub>m = V\\<close> assms(1)"], ["proof (chain)\npicking this:\n  var g def\\<^sub>m = V\n  var g r = V\n  var g def\\<^sub>m \\<noteq> var g r", "have \"False\""], ["proof (prove)\nusing this:\n  var g def\\<^sub>m = V\n  var g r = V\n  var g def\\<^sub>m \\<noteq> var g r\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m = i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "case m_i_differ"], ["proof (state)\nthis:\n  i \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "txt \\<open>If @{prop \"m \\<noteq> i\"}, @{term i} constitutes a proper path convergence point.\\<close>"], ["proof (state)\nthis:\n  i \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"old.pathsConverge g m ms' n (ns @ tl ri) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. old.pathsConverge g m ms' n (ns @ tl ri) i", "proof (rule old.pathsConvergeI)"], ["proof (state)\ngoal (5 subgoals):\n 1. g \\<turnstile> m-ms'\\<rightarrow>i\n 2. g \\<turnstile> n-ns @ tl ri\\<rightarrow>i\n 3. 1 < length ms'\n 4. 1 < length (ns @ tl ri)\n 5. set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) = {}", "show \"1 < length ms'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length ms'", "using m_i_differ ms'_props old.path2_nontriv"], ["proof (prove)\nusing this:\n  i \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> i\n  g \\<turnstile> m-ms'\\<rightarrow>i\n  prefix ms' ms\n  i \\<notin> set (butlast ms')\n  \\<lbrakk>?g \\<turnstile> ?n-?ns\\<rightarrow>?m; ?n \\<noteq> ?m\\<rbrakk>\n  \\<Longrightarrow> 1 < length ?ns\n\ngoal (1 subgoal):\n 1. 1 < length ms'", "by blast"], ["proof (state)\nthis:\n  1 < length ms'\n\ngoal (4 subgoals):\n 1. g \\<turnstile> m-ms'\\<rightarrow>i\n 2. g \\<turnstile> n-ns @ tl ri\\<rightarrow>i\n 3. 1 < length (ns @ tl ri)\n 4. set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) = {}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. g \\<turnstile> m-ms'\\<rightarrow>i\n 2. g \\<turnstile> n-ns @ tl ri\\<rightarrow>i\n 3. 1 < length (ns @ tl ri)\n 4. set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) = {}", "show \"1 < length (ns @ tl ri)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length (ns @ tl ri)", "using ri_props old.path2_nontriv assms(9)"], ["proof (prove)\nusing this:\n  g \\<turnstile> defNode g r-ri\\<rightarrow>i\n  i \\<in> set ms\n  \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms\n  prefix ri rs\n  \\<lbrakk>?g \\<turnstile> ?n-?ns\\<rightarrow>?m; ?n \\<noteq> ?m\\<rbrakk>\n  \\<Longrightarrow> 1 < length ?ns\n  set ns \\<inter> set ms = {}\n\ngoal (1 subgoal):\n 1. 1 < length (ns @ tl ri)", "by (metis assms(7) disjoint_elem old.path2_app old.path2_hd_in_ns)"], ["proof (state)\nthis:\n  1 < length (ns @ tl ri)\n\ngoal (3 subgoals):\n 1. g \\<turnstile> m-ms'\\<rightarrow>i\n 2. g \\<turnstile> n-ns @ tl ri\\<rightarrow>i\n 3. set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) = {}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. g \\<turnstile> m-ms'\\<rightarrow>i\n 2. g \\<turnstile> n-ns @ tl ri\\<rightarrow>i\n 3. set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) = {}", "show \"set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) \\<noteq> {}\""], ["proof (state)\nthis:\n  set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) \\<noteq> {}", "obtain i' where i'_props: \"i' \\<in> set (butlast ms')\" \"i' \\<in> set (butlast (ns @ tl ri))\""], ["proof (prove)\nusing this:\n  set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i' \\<in> set (butlast ms');\n         i' \\<in> set (butlast (ns @ tl ri))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i' \\<in> set (butlast ms')\n  i' \\<in> set (butlast (ns @ tl ri))\n\ngoal (1 subgoal):\n 1. set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "with ms'_props(2)"], ["proof (chain)\npicking this:\n  prefix ms' ms\n  i' \\<in> set (butlast ms')\n  i' \\<in> set (butlast (ns @ tl ri))", "have i'_not_in_ms: \"i' \\<in> set (butlast ms)\""], ["proof (prove)\nusing this:\n  prefix ms' ms\n  i' \\<in> set (butlast ms')\n  i' \\<in> set (butlast (ns @ tl ri))\n\ngoal (1 subgoal):\n 1. i' \\<in> set (butlast ms)", "by (metis in_set_butlast_appendI prefixE)"], ["proof (state)\nthis:\n  i' \\<in> set (butlast ms)\n\ngoal (1 subgoal):\n 1. set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "with assms(9)"], ["proof (chain)\npicking this:\n  set ns \\<inter> set ms = {}\n  i' \\<in> set (butlast ms)", "show False"], ["proof (prove)\nusing this:\n  set ns \\<inter> set ms = {}\n  i' \\<in> set (butlast ms)\n\ngoal (1 subgoal):\n 1. False", "proof (cases \"i' \\<notin> set ns\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>set ns \\<inter> set ms = {}; i' \\<in> set (butlast ms);\n     i' \\<notin> set ns\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>set ns \\<inter> set ms = {}; i' \\<in> set (butlast ms);\n     \\<not> i' \\<notin> set ns\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  i' \\<notin> set ns\n\ngoal (2 subgoals):\n 1. \\<lbrakk>set ns \\<inter> set ms = {}; i' \\<in> set (butlast ms);\n     i' \\<notin> set ns\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>set ns \\<inter> set ms = {}; i' \\<in> set (butlast ms);\n     \\<not> i' \\<notin> set ns\\<rbrakk>\n    \\<Longrightarrow> False", "with i'_props(2)"], ["proof (chain)\npicking this:\n  i' \\<in> set (butlast (ns @ tl ri))\n  i' \\<notin> set ns", "have \"i' \\<in> set (butlast (tl ri))\""], ["proof (prove)\nusing this:\n  i' \\<in> set (butlast (ns @ tl ri))\n  i' \\<notin> set ns\n\ngoal (1 subgoal):\n 1. i' \\<in> set (butlast (tl ri))", "by (metis Un_iff butlast_append in_set_butlastD set_append)"], ["proof (state)\nthis:\n  i' \\<in> set (butlast (tl ri))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>set ns \\<inter> set ms = {}; i' \\<in> set (butlast ms);\n     i' \\<notin> set ns\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>set ns \\<inter> set ms = {}; i' \\<in> set (butlast ms);\n     \\<not> i' \\<notin> set ns\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"i' \\<in> set (butlast ri)\""], ["proof (prove)\nusing this:\n  i' \\<in> set (butlast (tl ri))\n\ngoal (1 subgoal):\n 1. i' \\<in> set (butlast ri)", "by (simp add:in_set_tlD List.butlast_tl)"], ["proof (state)\nthis:\n  i' \\<in> set (butlast ri)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>set ns \\<inter> set ms = {}; i' \\<in> set (butlast ms);\n     i' \\<notin> set ns\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>set ns \\<inter> set ms = {}; i' \\<in> set (butlast ms);\n     \\<not> i' \\<notin> set ns\\<rbrakk>\n    \\<Longrightarrow> False", "with i'_not_in_ms ri_props(3)"], ["proof (chain)\npicking this:\n  i' \\<in> set (butlast ms)\n  \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms\n  i' \\<in> set (butlast ri)", "show False"], ["proof (prove)\nusing this:\n  i' \\<in> set (butlast ms)\n  \\<forall>n\\<in>set (butlast ri). n \\<notin> set ms\n  i' \\<in> set (butlast ri)\n\ngoal (1 subgoal):\n 1. False", "by (auto dest:in_set_butlastD)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set ns \\<inter> set ms = {}; i' \\<in> set (butlast ms);\n     \\<not> i' \\<notin> set ns\\<rbrakk>\n    \\<Longrightarrow> False", "qed (meson disjoint_elem in_set_butlastD)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (butlast ms') \\<inter> set (butlast (ns @ tl ri)) = {}\n\ngoal (2 subgoals):\n 1. g \\<turnstile> m-ms'\\<rightarrow>i\n 2. g \\<turnstile> n-ns @ tl ri\\<rightarrow>i", "qed (auto intro: assms(7) ri_props(1) old.path2_app ms'_props(1))"], ["proof (state)\nthis:\n  old.pathsConverge g m ms' n (ns @ tl ri) i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "txt \\<open>At this intersection of paths we can find a \\pf.\\<close>"], ["proof (state)\nthis:\n  old.pathsConverge g m ms' n (ns @ tl ri) i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "from this assms(6,5)"], ["proof (chain)\npicking this:\n  old.pathsConverge g m ms' n (ns @ tl ri) i\n  V \\<in> oldDefs g m\n  V \\<in> oldDefs g n", "have \"necessaryPhi g V i\""], ["proof (prove)\nusing this:\n  old.pathsConverge g m ms' n (ns @ tl ri) i\n  V \\<in> oldDefs g m\n  V \\<in> oldDefs g n\n\ngoal (1 subgoal):\n 1. necessaryPhi g V i", "by (rule necessaryPhiI)"], ["proof (state)\nthis:\n  necessaryPhi g V i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "txt \\<open>Before we can conclude that there is indeed a $\\phi$ at @{term i}, we have to prove a couple of technicalities\\ldots\\<close>"], ["proof (state)\nthis:\n  necessaryPhi g V i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  necessaryPhi g V i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "from m_i_differ ri_props(1,4) rs_def old.path2_last prefix_snoc"], ["proof (chain)\npicking this:\n  i \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> i\n  g \\<turnstile> defNode g r-ri\\<rightarrow>i\n  prefix ri rs\n  rs = rs' @ [defNode g \\<phi>\\<^sub>r]\n  ?g \\<turnstile> ?n-?ns\\<rightarrow>?m \\<Longrightarrow> ?m = last ?ns\n  prefix ?xs (?ys @ [?y]) = (?xs = ?ys @ [?y] \\<or> prefix ?xs ?ys)", "have ri_rs'_prefix: \"prefix ri rs'\""], ["proof (prove)\nusing this:\n  i \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> i\n  g \\<turnstile> defNode g r-ri\\<rightarrow>i\n  prefix ri rs\n  rs = rs' @ [defNode g \\<phi>\\<^sub>r]\n  ?g \\<turnstile> ?n-?ns\\<rightarrow>?m \\<Longrightarrow> ?m = last ?ns\n  prefix ?xs (?ys @ [?y]) = (?xs = ?ys @ [?y] \\<or> prefix ?xs ?ys)\n\ngoal (1 subgoal):\n 1. prefix ri rs'", "by fastforce"], ["proof (state)\nthis:\n  prefix ri rs'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  prefix ri rs'", "obtain rs'_rest where rs'_rest_prop: \"rs' = ri@rs'_rest\""], ["proof (prove)\nusing this:\n  prefix ri rs'\n\ngoal (1 subgoal):\n 1. (\\<And>rs'_rest.\n        rs' = ri @ rs'_rest \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prefixE"], ["proof (prove)\nusing this:\n  prefix ri rs'\n  \\<lbrakk>prefix ?xs ?ys;\n   \\<And>zs. ?ys = ?xs @ zs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>rs'_rest.\n        rs' = ri @ rs'_rest \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rs' = ri @ rs'_rest\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "from old.path2_last[OF ri_props(1)] last_snoc[of _ i]"], ["proof (chain)\npicking this:\n  i = last ri\n  last (?xs @ [i]) = i", "obtain tmp where \"ri = tmp@[i]\""], ["proof (prove)\nusing this:\n  i = last ri\n  last (?xs @ [i]) = i\n\ngoal (1 subgoal):\n 1. (\\<And>tmp. ri = tmp @ [i] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (subgoal_tac \"ri \\<noteq> []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>tmp. ri = tmp @ [i] \\<Longrightarrow> thesis;\n     i = last ri; \\<And>xs. last (xs @ [i]) = i; ri \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>tmp. ri = tmp @ [i] \\<Longrightarrow> thesis;\n     i = last ri; \\<And>xs. last (xs @ [i]) = i\\<rbrakk>\n    \\<Longrightarrow> ri \\<noteq> []", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>tmp. ri = tmp @ [i] \\<Longrightarrow> thesis;\n     i = last ri; \\<And>xs. last (xs @ [i]) = i\\<rbrakk>\n    \\<Longrightarrow> ri \\<noteq> []\n 2. \\<lbrakk>\\<And>tmp. ri = tmp @ [i] \\<Longrightarrow> thesis;\n     i = last ri; \\<And>xs. last (xs @ [i]) = i; ri \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "using ri_props(1)"], ["proof (prove)\nusing this:\n  g \\<turnstile> defNode g r-ri\\<rightarrow>i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>tmp. ri = tmp @ [i] \\<Longrightarrow> thesis;\n     i = last ri; \\<And>xs. last (xs @ [i]) = i\\<rbrakk>\n    \\<Longrightarrow> ri \\<noteq> []\n 2. \\<lbrakk>\\<And>tmp. ri = tmp @ [i] \\<Longrightarrow> thesis;\n     i = last ri; \\<And>xs. last (xs @ [i]) = i; ri \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (simp add: old.path2_not_Nil)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tmp. ri = tmp @ [i] \\<Longrightarrow> thesis;\n     i = last ri; \\<And>xs. last (xs @ [i]) = i; ri \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (rule_tac that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tmp. ri = tmp @ [i] \\<Longrightarrow> thesis;\n     i = last ri; \\<And>xs. last (xs @ [i]) = i; ri \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ri = ?tmp10 @ [i]", "using append_butlast_last_id[symmetric]"], ["proof (prove)\nusing this:\n  ?t \\<noteq> [] \\<Longrightarrow> ?t = butlast ?t @ [last ?t]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tmp. ri = tmp @ [i] \\<Longrightarrow> thesis;\n     i = last ri; \\<And>xs. last (xs @ [i]) = i; ri \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ri = ?tmp10 @ [i]", "by auto"], ["proof (state)\nthis:\n  ri = tmp @ [i]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "with rs'_rest_prop"], ["proof (chain)\npicking this:\n  rs' = ri @ rs'_rest\n  ri = tmp @ [i]", "have rs'_rest_def: \"rs' = tmp@i#rs'_rest\""], ["proof (prove)\nusing this:\n  rs' = ri @ rs'_rest\n  ri = tmp @ [i]\n\ngoal (1 subgoal):\n 1. rs' = tmp @ i # rs'_rest", "by auto"], ["proof (state)\nthis:\n  rs' = tmp @ i # rs'_rest\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "with rs'_props(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> defNode g r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  rs' = tmp @ i # rs'_rest", "have \"g \\<turnstile> i -i#rs'_rest\\<rightarrow> pred\\<^sub>\\<phi>\\<^sub>r\""], ["proof (prove)\nusing this:\n  g \\<turnstile> defNode g r-rs'\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  rs' = tmp @ i # rs'_rest\n\ngoal (1 subgoal):\n 1. g \\<turnstile> i-i # rs'_rest\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r", "by (simp add:old.path2_split)"], ["proof (state)\nthis:\n  g \\<turnstile> i-i # rs'_rest\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  g \\<turnstile> i-i # rs'_rest\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "note \\<open>var g r = V\\<close> [simp]"], ["proof (state)\nthis:\n  var g r = V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "from rs'_props(3)"], ["proof (chain)\npicking this:\n  r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r", "have \"r \\<in> allUses g pred\\<^sub>\\<phi>\\<^sub>r\""], ["proof (prove)\nusing this:\n  r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. r \\<in> allUses g pred\\<^sub>\\<phi>\\<^sub>r", "unfolding allUses_def"], ["proof (prove)\nusing this:\n  r \\<in> phiUses g pred\\<^sub>\\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. r \\<in> uses g pred\\<^sub>\\<phi>\\<^sub>r \\<union>\n            phiUses g pred\\<^sub>\\<phi>\\<^sub>r", "by simp"], ["proof (state)\nthis:\n  r \\<in> allUses g pred\\<^sub>\\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  r \\<in> allUses g pred\\<^sub>\\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "from \\<open>defNode g r \\<notin> set (tl rs')\\<close> rs'_rest_def"], ["proof (chain)\npicking this:\n  defNode g r \\<notin> set (tl rs')\n  rs' = tmp @ i # rs'_rest", "have \"defNode g r \\<notin> set rs'_rest\""], ["proof (prove)\nusing this:\n  defNode g r \\<notin> set (tl rs')\n  rs' = tmp @ i # rs'_rest\n\ngoal (1 subgoal):\n 1. defNode g r \\<notin> set rs'_rest", "by auto"], ["proof (state)\nthis:\n  defNode g r \\<notin> set rs'_rest\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<open>g \\<turnstile> i -i#rs'_rest\\<rightarrow> pred\\<^sub>\\<phi>\\<^sub>r\\<close>"], ["proof (chain)\npicking this:\n  g \\<turnstile> i-i # rs'_rest\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  defNode g r \\<notin> set rs'_rest", "have \"\\<And>x. x \\<in> set rs'_rest \\<Longrightarrow> r \\<notin> allDefs g x\""], ["proof (prove)\nusing this:\n  g \\<turnstile> i-i # rs'_rest\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  defNode g r \\<notin> set rs'_rest\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set rs'_rest \\<Longrightarrow> r \\<notin> allDefs g x", "by (metis defNode_eq list.distinct(1) list.sel(3) list.set_cases old.path2_cases old.path2_in_\\<alpha>n)"], ["proof (state)\nthis:\n  ?x1 \\<in> set rs'_rest \\<Longrightarrow> r \\<notin> allDefs g ?x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  ?x1 \\<in> set rs'_rest \\<Longrightarrow> r \\<notin> allDefs g ?x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "from assms(7,9) \\<open>g \\<turnstile> i -i#rs'_rest\\<rightarrow> pred\\<^sub>\\<phi>\\<^sub>r\\<close> ri_props(2)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  set ns \\<inter> set ms = {}\n  g \\<turnstile> i-i # rs'_rest\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  i \\<in> set ms", "have \"r \\<notin> defs g i\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  set ns \\<inter> set ms = {}\n  g \\<turnstile> i-i # rs'_rest\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  i \\<in> set ms\n\ngoal (1 subgoal):\n 1. r \\<notin> defs g i", "by (metis defNode_eq defs_in_allDefs disjoint_elem old.path2_hd_in_\\<alpha>n old.path2_last_in_ns)"], ["proof (state)\nthis:\n  r \\<notin> defs g i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  necessaryPhi g V i\n  g \\<turnstile> i-i # rs'_rest\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  r \\<in> allUses g pred\\<^sub>\\<phi>\\<^sub>r\n  ?x1 \\<in> set rs'_rest \\<Longrightarrow> r \\<notin> allDefs g ?x1\n  r \\<notin> defs g i", "txt \\<open>The convergence property gives us that there is a $\\phi$ in the last node fulfilling @{theory_text necessaryPhi}\n          on a path to a use of @{term r} without a definition of @{term r}.\n          Thus @{term i} bears a \\pf\\ for the value of @{term r}.\\<close>"], ["proof (chain)\npicking this:\n  necessaryPhi g V i\n  g \\<turnstile> i-i # rs'_rest\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  r \\<in> allUses g pred\\<^sub>\\<phi>\\<^sub>r\n  ?x1 \\<in> set rs'_rest \\<Longrightarrow> r \\<notin> allDefs g ?x1\n  r \\<notin> defs g i", "have \"\\<exists>y. phis g (i, r) = Some y\""], ["proof (prove)\nusing this:\n  necessaryPhi g V i\n  g \\<turnstile> i-i # rs'_rest\\<rightarrow>pred\\<^sub>\\<phi>\\<^sub>r\n  r \\<in> allUses g pred\\<^sub>\\<phi>\\<^sub>r\n  ?x1 \\<in> set rs'_rest \\<Longrightarrow> r \\<notin> allDefs g ?x1\n  r \\<notin> defs g i\n\ngoal (1 subgoal):\n 1. \\<exists>y. phis g (i, r) = Some y", "by (rule convergence_prop [where g=g and n=i and v=r and ns=\"i#rs'_rest\", simplified])"], ["proof (state)\nthis:\n  \\<exists>y. phis g (i, r) = Some y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<exists>y. phis g (i, r) = Some y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "from \\<open>g \\<turnstile> n-ns\\<rightarrow>defNode g r\\<close>"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r", "have \"defNode g r \\<in> set ns\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n\ngoal (1 subgoal):\n 1. defNode g r \\<in> set ns", "by auto"], ["proof (state)\nthis:\n  defNode g r \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<open>set ns \\<inter> set ms = {}\\<close> \\<open>i \\<in> set ms\\<close>"], ["proof (chain)\npicking this:\n  set ns \\<inter> set ms = {}\n  i \\<in> set ms\n  defNode g r \\<in> set ns", "have \"i \\<noteq> defNode g r\""], ["proof (prove)\nusing this:\n  set ns \\<inter> set ms = {}\n  i \\<in> set ms\n  defNode g r \\<in> set ns\n\ngoal (1 subgoal):\n 1. i \\<noteq> defNode g r", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> defNode g r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  i \\<noteq> defNode g r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "from ms'_props(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> m-ms'\\<rightarrow>i", "have \"i \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> m-ms'\\<rightarrow>i\n\ngoal (1 subgoal):\n 1. i \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  i \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  i \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"defNode g r \\<in> set (\\<alpha>n g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defNode g r \\<in> set (\\<alpha>n g)", "by (simp add: assms(3))"], ["proof (state)\nthis:\n  defNode g r \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "txt \\<open>However, we now have two definitions of @{term r}: one in @{term i}, and one in @{term \"defNode g r\"}, which we know to be distinct.\n          This is a contradiction to the @{theory_text allDefs_disjoint}-property.\\<close>"], ["proof (state)\nthis:\n  defNode g r \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>y. phis g (i, r) = Some y\n  i \\<noteq> defNode g r\n  i \\<in> set (\\<alpha>n g)\n  defNode g r \\<in> set (\\<alpha>n g)", "have False"], ["proof (prove)\nusing this:\n  \\<exists>y. phis g (i, r) = Some y\n  i \\<noteq> defNode g r\n  i \\<in> set (\\<alpha>n g)\n  defNode g r \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. False", "using allDefs_disjoint [where g=g and n=i and m=\"defNode g r\"]"], ["proof (prove)\nusing this:\n  \\<exists>y. phis g (i, r) = Some y\n  i \\<noteq> defNode g r\n  i \\<in> set (\\<alpha>n g)\n  defNode g r \\<in> set (\\<alpha>n g)\n  \\<lbrakk>i \\<in> set (\\<alpha>n g); defNode g r \\<in> set (\\<alpha>n g);\n   i \\<noteq> defNode g r\\<rbrakk>\n  \\<Longrightarrow> allDefs g i \\<inter> allDefs g (defNode g r) = {}\n\ngoal (1 subgoal):\n 1. False", "unfolding allDefs_def phiDefs_def"], ["proof (prove)\nusing this:\n  \\<exists>y. phis g (i, r) = Some y\n  i \\<noteq> defNode g r\n  i \\<in> set (\\<alpha>n g)\n  defNode g r \\<in> set (\\<alpha>n g)\n  \\<lbrakk>i \\<in> set (\\<alpha>n g); defNode g r \\<in> set (\\<alpha>n g);\n   i \\<noteq> defNode g r\\<rbrakk>\n  \\<Longrightarrow> (defs g i \\<union>\n                     {v. (i, v) \\<in> dom (phis g)}) \\<inter>\n                    (defs g (defNode g r) \\<union>\n                     {v. (defNode g r, v) \\<in> dom (phis g)}) =\n                    {}\n\ngoal (1 subgoal):\n 1. False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>i \\<noteq> defNode g r; i \\<in> set (\\<alpha>n g);\n        defNode g r \\<in> set (\\<alpha>n g);\n        (defs g i \\<union> {v. (i, v) \\<in> dom (phis g)}) \\<inter>\n        (defs g (defNode g r) \\<union>\n         {v. (defNode g r, v) \\<in> dom (phis g)}) =\n        {};\n        phis g (i, r) = Some y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule_tac c=r in equalityCE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>i \\<noteq> defNode g r; i \\<in> set (\\<alpha>n g);\n        defNode g r \\<in> set (\\<alpha>n g); phis g (i, r) = Some y;\n        r \\<in> (defs g i \\<union> {v. (i, v) \\<in> dom (phis g)}) \\<inter>\n                (defs g (defNode g r) \\<union>\n                 {v. (defNode g r, v) \\<in> dom (phis g)});\n        r \\<in> {}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>y.\n       \\<lbrakk>i \\<noteq> defNode g r; i \\<in> set (\\<alpha>n g);\n        defNode g r \\<in> set (\\<alpha>n g); phis g (i, r) = Some y;\n        r \\<notin> (defs g i \\<union>\n                    {v. (i, v) \\<in> dom (phis g)}) \\<inter>\n                   (defs g (defNode g r) \\<union>\n                    {v. (defNode g r, v) \\<in> dom (phis g)});\n        r \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> False", "using phi_def phis_phi"], ["proof (prove)\nusing this:\n  phi ?g ?v = phis ?g (defNode ?g ?v, ?v)\n  phis ?g (?n, ?v) = Some ?vs \\<Longrightarrow> phi ?g ?v = Some ?vs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>i \\<noteq> defNode g r; i \\<in> set (\\<alpha>n g);\n        defNode g r \\<in> set (\\<alpha>n g); phis g (i, r) = Some y;\n        r \\<in> (defs g i \\<union> {v. (i, v) \\<in> dom (phis g)}) \\<inter>\n                (defs g (defNode g r) \\<union>\n                 {v. (defNode g r, v) \\<in> dom (phis g)});\n        r \\<in> {}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>y.\n       \\<lbrakk>i \\<noteq> defNode g r; i \\<in> set (\\<alpha>n g);\n        defNode g r \\<in> set (\\<alpha>n g); phis g (i, r) = Some y;\n        r \\<notin> (defs g i \\<union>\n                    {v. (i, v) \\<in> dom (phis g)}) \\<inter>\n                   (defs g (defNode g r) \\<union>\n                    {v. (defNode g r, v) \\<in> dom (phis g)});\n        r \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> defNode g \\<phi>\\<^sub>r; m \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_same_var:\nassumes \"\\<phi>' \\<in> reachable g \\<phi>\"\nshows \"var g \\<phi> = var g \\<phi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var g \\<phi> = var g \\<phi>'", "using assms"], ["proof (prove)\nusing this:\n  \\<phi>' \\<in> reachable g \\<phi>\n\ngoal (1 subgoal):\n 1. var g \\<phi> = var g \\<phi>'", "by (metis Nitpick.rtranclp_unfold phiArg_trancl_same_var reachable_props(1))"], ["", "lemma \\<phi>_node_no_defs:\nassumes \"unnecessaryPhi g \\<phi>\" \"\\<phi> \\<in> allVars g\" \"var g \\<phi> \\<in> oldDefs g n\"\nshows \"defNode g \\<phi> \\<noteq> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defNode g \\<phi> \\<noteq> n", "using assms simpleDefs_phiDefs_var_disjoint defNode(1) not_None_eq phi_phiDefs"], ["proof (prove)\nusing this:\n  unnecessaryPhi g \\<phi>\n  \\<phi> \\<in> allVars g\n  var g \\<phi> \\<in> oldDefs g n\n  \\<lbrakk>?v \\<in> phiDefs ?g ?n; ?n \\<in> set (\\<alpha>n ?g)\\<rbrakk>\n  \\<Longrightarrow> var ?g ?v \\<notin> oldDefs ?g ?n\n  ?v \\<in> allVars ?g \\<Longrightarrow>\n  defNode ?g ?v \\<in> set (\\<alpha>n ?g)\n  (?x \\<noteq> None) = (\\<exists>y. ?x = Some y)\n  phi ?g ?v = Some ?vs \\<Longrightarrow> ?v \\<in> phiDefs ?g (defNode ?g ?v)\n\ngoal (1 subgoal):\n 1. defNode g \\<phi> \\<noteq> n", "unfolding unnecessaryPhi_def"], ["proof (prove)\nusing this:\n  phi g \\<phi> \\<noteq> None \\<and> \\<not> necessaryPhi' g \\<phi>\n  \\<phi> \\<in> allVars g\n  var g \\<phi> \\<in> oldDefs g n\n  \\<lbrakk>?v \\<in> phiDefs ?g ?n; ?n \\<in> set (\\<alpha>n ?g)\\<rbrakk>\n  \\<Longrightarrow> var ?g ?v \\<notin> oldDefs ?g ?n\n  ?v \\<in> allVars ?g \\<Longrightarrow>\n  defNode ?g ?v \\<in> set (\\<alpha>n ?g)\n  (?x \\<noteq> None) = (\\<exists>y. ?x = Some y)\n  phi ?g ?v = Some ?vs \\<Longrightarrow> ?v \\<in> phiDefs ?g (defNode ?g ?v)\n\ngoal (1 subgoal):\n 1. defNode g \\<phi> \\<noteq> n", "by auto"], ["", "lemma defNode_differ_aux:\nassumes \"\\<phi>\\<^sub>s \\<in> reachable g \\<phi>\" \"\\<phi> \\<in> allVars g\" \"s \\<in> allVars g\" \"\\<phi>\\<^sub>s \\<noteq> s\" \"var g \\<phi> = var g s\"\nshows \"defNode g \\<phi>\\<^sub>s \\<noteq> defNode g s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defNode g \\<phi>\\<^sub>s \\<noteq> defNode g s", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. defNode g \\<phi>\\<^sub>s \\<noteq> defNode g s", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> defNode g \\<phi>\\<^sub>s \\<noteq> defNode g s \\<Longrightarrow>\n    False", "assume \"\\<not> defNode g \\<phi>\\<^sub>s \\<noteq> defNode g s\""], ["proof (state)\nthis:\n  \\<not> defNode g \\<phi>\\<^sub>s \\<noteq> defNode g s\n\ngoal (1 subgoal):\n 1. \\<not> defNode g \\<phi>\\<^sub>s \\<noteq> defNode g s \\<Longrightarrow>\n    False", "hence eq: \"defNode g \\<phi>\\<^sub>s = defNode g s\""], ["proof (prove)\nusing this:\n  \\<not> defNode g \\<phi>\\<^sub>s \\<noteq> defNode g s\n\ngoal (1 subgoal):\n 1. defNode g \\<phi>\\<^sub>s = defNode g s", "by simp"], ["proof (state)\nthis:\n  defNode g \\<phi>\\<^sub>s = defNode g s\n\ngoal (1 subgoal):\n 1. \\<not> defNode g \\<phi>\\<^sub>s \\<noteq> defNode g s \\<Longrightarrow>\n    False", "from assms(1)"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>", "have vars_eq: \"var g \\<phi> = var g \\<phi>\\<^sub>s\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n\ngoal (1 subgoal):\n 1. var g \\<phi> = var g \\<phi>\\<^sub>s", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>s \\<in> reachable g \\<phi> \\<Longrightarrow>\n    var g \\<phi> = var g \\<phi>\\<^sub>s", "apply (cases \"\\<phi> = \\<phi>\\<^sub>s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<phi>\\<^sub>s \\<in> reachable g \\<phi>;\n     \\<phi> = \\<phi>\\<^sub>s\\<rbrakk>\n    \\<Longrightarrow> var g \\<phi> = var g \\<phi>\\<^sub>s\n 2. \\<lbrakk>\\<phi>\\<^sub>s \\<in> reachable g \\<phi>;\n     \\<phi> \\<noteq> \\<phi>\\<^sub>s\\<rbrakk>\n    \\<Longrightarrow> var g \\<phi> = var g \\<phi>\\<^sub>s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>\\<^sub>s \\<in> reachable g \\<phi>;\n     \\<phi> \\<noteq> \\<phi>\\<^sub>s\\<rbrakk>\n    \\<Longrightarrow> var g \\<phi> = var g \\<phi>\\<^sub>s", "apply (rule phiArg_trancl_same_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>\\<^sub>s \\<in> reachable g \\<phi>;\n     \\<phi> \\<noteq> \\<phi>\\<^sub>s\\<rbrakk>\n    \\<Longrightarrow> (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> \\<phi>\\<^sub>s", "apply (drule reachable_props)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi> \\<noteq> \\<phi>\\<^sub>s;\n     (phiArg g)\\<^sup>*\\<^sup>* \\<phi> \\<phi>\\<^sub>s\\<rbrakk>\n    \\<Longrightarrow> (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> \\<phi>\\<^sub>s", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi> \\<noteq> \\<phi>\\<^sub>s;\n     (phiArg g)\\<^sup>*\\<^sup>* \\<phi> \\<phi>\\<^sub>s\\<rbrakk>\n    \\<Longrightarrow> (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> \\<phi>\\<^sub>s", "by (meson IntD1 mem_Collect_eq rtranclpD)"], ["proof (state)\nthis:\n  var g \\<phi> = var g \\<phi>\\<^sub>s\n\ngoal (1 subgoal):\n 1. \\<not> defNode g \\<phi>\\<^sub>s \\<noteq> defNode g s \\<Longrightarrow>\n    False", "have \\<phi>\\<^sub>s_in_allVars: \"\\<phi>\\<^sub>s \\<in> allVars g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>s \\<in> allVars g", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>s \\<in> allVars g", "proof (cases \"\\<phi> = \\<phi>\\<^sub>s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<phi> = \\<phi>\\<^sub>s \\<Longrightarrow> \\<phi>\\<^sub>s \\<in> allVars g\n 2. \\<phi> \\<noteq> \\<phi>\\<^sub>s \\<Longrightarrow>\n    \\<phi>\\<^sub>s \\<in> allVars g", "case False"], ["proof (state)\nthis:\n  \\<phi> \\<noteq> \\<phi>\\<^sub>s\n\ngoal (2 subgoals):\n 1. \\<phi> = \\<phi>\\<^sub>s \\<Longrightarrow> \\<phi>\\<^sub>s \\<in> allVars g\n 2. \\<phi> \\<noteq> \\<phi>\\<^sub>s \\<Longrightarrow>\n    \\<phi>\\<^sub>s \\<in> allVars g", "with assms(1)"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<phi> \\<noteq> \\<phi>\\<^sub>s", "obtain \\<phi>' where \"phiArg g \\<phi>' \\<phi>\\<^sub>s\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<phi> \\<noteq> \\<phi>\\<^sub>s\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>'.\n        phiArg g \\<phi>' \\<phi>\\<^sub>s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis rtranclp.cases reachable_props(1))"], ["proof (state)\nthis:\n  phiArg g \\<phi>' \\<phi>\\<^sub>s\n\ngoal (2 subgoals):\n 1. \\<phi> = \\<phi>\\<^sub>s \\<Longrightarrow> \\<phi>\\<^sub>s \\<in> allVars g\n 2. \\<phi> \\<noteq> \\<phi>\\<^sub>s \\<Longrightarrow>\n    \\<phi>\\<^sub>s \\<in> allVars g", "thus \"\\<phi>\\<^sub>s \\<in> allVars g\""], ["proof (prove)\nusing this:\n  phiArg g \\<phi>' \\<phi>\\<^sub>s\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>s \\<in> allVars g", "by (rule phiArg_in_allVars)"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>s \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<phi> = \\<phi>\\<^sub>s \\<Longrightarrow> \\<phi>\\<^sub>s \\<in> allVars g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> = \\<phi>\\<^sub>s \\<Longrightarrow> \\<phi>\\<^sub>s \\<in> allVars g", "case eq: True"], ["proof (state)\nthis:\n  \\<phi> = \\<phi>\\<^sub>s\n\ngoal (1 subgoal):\n 1. \\<phi> = \\<phi>\\<^sub>s \\<Longrightarrow> \\<phi>\\<^sub>s \\<in> allVars g", "with assms(2)"], ["proof (chain)\npicking this:\n  \\<phi> \\<in> allVars g\n  \\<phi> = \\<phi>\\<^sub>s", "show \"\\<phi>\\<^sub>s \\<in> allVars g\""], ["proof (prove)\nusing this:\n  \\<phi> \\<in> allVars g\n  \\<phi> = \\<phi>\\<^sub>s\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>s \\<in> allVars g", "by (subst eq[symmetric])"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>s \\<in> allVars g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>s \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<not> defNode g \\<phi>\\<^sub>s \\<noteq> defNode g s \\<Longrightarrow>\n    False", "from eq \\<phi>\\<^sub>s_in_allVars assms(3,4)"], ["proof (chain)\npicking this:\n  defNode g \\<phi>\\<^sub>s = defNode g s\n  \\<phi>\\<^sub>s \\<in> allVars g\n  s \\<in> allVars g\n  \\<phi>\\<^sub>s \\<noteq> s", "have \"var g \\<phi>\\<^sub>s \\<noteq> var g s\""], ["proof (prove)\nusing this:\n  defNode g \\<phi>\\<^sub>s = defNode g s\n  \\<phi>\\<^sub>s \\<in> allVars g\n  s \\<in> allVars g\n  \\<phi>\\<^sub>s \\<noteq> s\n\ngoal (1 subgoal):\n 1. var g \\<phi>\\<^sub>s \\<noteq> var g s", "by - (rule defNode_var_disjoint)"], ["proof (state)\nthis:\n  var g \\<phi>\\<^sub>s \\<noteq> var g s\n\ngoal (1 subgoal):\n 1. \\<not> defNode g \\<phi>\\<^sub>s \\<noteq> defNode g s \\<Longrightarrow>\n    False", "with vars_eq assms(5)"], ["proof (chain)\npicking this:\n  var g \\<phi> = var g \\<phi>\\<^sub>s\n  var g \\<phi> = var g s\n  var g \\<phi>\\<^sub>s \\<noteq> var g s", "show False"], ["proof (prove)\nusing this:\n  var g \\<phi> = var g \\<phi>\\<^sub>s\n  var g \\<phi> = var g s\n  var g \\<phi>\\<^sub>s \\<noteq> var g s\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "txt \\<open>Theorem 1. A graph which does not contain any redundant set is minimal according to Cytron et al.'s definition of minimality.\\<close>"], ["", "theorem no_redundant_set_minimal:\nassumes no_redundant_set: \"\\<not>(\\<exists>P. redundant_set g P)\"\nshows \"cytronMinimal g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cytronMinimal g", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> cytronMinimal g \\<Longrightarrow> False", "assume \"\\<not>cytronMinimal g\""], ["proof (state)\nthis:\n  \\<not> cytronMinimal g\n\ngoal (1 subgoal):\n 1. \\<not> cytronMinimal g \\<Longrightarrow> False", "txt \\<open>Assume the graph is not Cytron-minimal. Thus there is a \\pf\\ which does not sit at the\n      convergence point of multiple liveness intervals.\\<close>"], ["proof (state)\nthis:\n  \\<not> cytronMinimal g\n\ngoal (1 subgoal):\n 1. \\<not> cytronMinimal g \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> cytronMinimal g", "obtain \\<phi> where \\<phi>_props: \"unnecessaryPhi g \\<phi>\" \"\\<phi> \\<in> allVars g\" \"\\<phi> \\<in> reachable g \\<phi>\""], ["proof (prove)\nusing this:\n  \\<not> cytronMinimal g\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>unnecessaryPhi g \\<phi>; \\<phi> \\<in> allVars g;\n         \\<phi> \\<in> reachable g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cytronMinimal_def unnecessaryPhi_def reachable_def unnecessaryPhi_def reachable.intros"], ["proof (prove)\nusing this:\n  \\<not> cytronMinimal g\n  cytronMinimal ?g \\<equiv>\n  \\<forall>v\\<in>allVars ?g.\n     phi ?g v \\<noteq> None \\<longrightarrow> necessaryPhi' ?g v\n  unnecessaryPhi ?g ?val \\<equiv>\n  phi ?g ?val \\<noteq> None \\<and> \\<not> necessaryPhi' ?g ?val\n  reachable \\<equiv> \\<lambda>g \\<phi>. {x. reachablep g \\<phi> x}\n  unnecessaryPhi ?g ?val \\<equiv>\n  phi ?g ?val \\<noteq> None \\<and> \\<not> necessaryPhi' ?g ?val\n  unnecessaryPhi ?g ?\\<phi> \\<Longrightarrow>\n  ?\\<phi> \\<in> reachable ?g ?\\<phi>\n  \\<lbrakk>?\\<phi>' \\<in> reachable ?g ?\\<phi>;\n   phiArg ?g ?\\<phi>' ?\\<phi>''; unnecessaryPhi ?g ?\\<phi>''\\<rbrakk>\n  \\<Longrightarrow> ?\\<phi>'' \\<in> reachable ?g ?\\<phi>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>unnecessaryPhi g \\<phi>; \\<phi> \\<in> allVars g;\n         \\<phi> \\<in> reachable g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  unnecessaryPhi g \\<phi>\n  \\<phi> \\<in> allVars g\n  \\<phi> \\<in> reachable g \\<phi>\n\ngoal (1 subgoal):\n 1. \\<not> cytronMinimal g \\<Longrightarrow> False", "txt \\<open>We consider the reachable-set of @{term \\<phi>}. If @{term \\<phi>} has less than two true arguments, we\n     know it to be a redundant set, a contradiction. Otherwise, we know there to be at least two\n     paths from different definitions leading into the reachable-set of @{term \\<phi>}.\\<close>"], ["proof (state)\nthis:\n  unnecessaryPhi g \\<phi>\n  \\<phi> \\<in> allVars g\n  \\<phi> \\<in> reachable g \\<phi>\n\ngoal (1 subgoal):\n 1. \\<not> cytronMinimal g \\<Longrightarrow> False", "consider (nontrivial) \"card (trueArgs g \\<phi>) \\<ge> 2\" | (trivial) \"card (trueArgs g \\<phi>) < 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> thesis;\n     card (trueArgs g \\<phi>) < 2 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using linorder_not_le"], ["proof (prove)\nusing this:\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> thesis;\n     card (trueArgs g \\<phi>) < 2 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> ?thesis1;\n   card (trueArgs g \\<phi>) < 2 \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<not> cytronMinimal g \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<lbrakk>2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> ?thesis1;\n   card (trueArgs g \\<phi>) < 2 \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False\n 2. card (trueArgs g \\<phi>) < 2 \\<Longrightarrow> False", "case trivial"], ["proof (state)\nthis:\n  card (trueArgs g \\<phi>) < 2\n\ngoal (2 subgoals):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False\n 2. card (trueArgs g \\<phi>) < 2 \\<Longrightarrow> False", "txt \\<open>If there are less than 2 true arguments of this set, the set is trivially redundant (see @{theory_text few_preds_redundant}).\\<close>"], ["proof (state)\nthis:\n  card (trueArgs g \\<phi>) < 2\n\ngoal (2 subgoals):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False\n 2. card (trueArgs g \\<phi>) < 2 \\<Longrightarrow> False", "from this \\<phi>_props(1)"], ["proof (chain)\npicking this:\n  card (trueArgs g \\<phi>) < 2\n  unnecessaryPhi g \\<phi>", "have \"redundant_set g (reachable g \\<phi>)\""], ["proof (prove)\nusing this:\n  card (trueArgs g \\<phi>) < 2\n  unnecessaryPhi g \\<phi>\n\ngoal (1 subgoal):\n 1. redundant_set g (reachable g \\<phi>)", "by (rule few_preds_redundant)"], ["proof (state)\nthis:\n  redundant_set g (reachable g \\<phi>)\n\ngoal (2 subgoals):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False\n 2. card (trueArgs g \\<phi>) < 2 \\<Longrightarrow> False", "with no_redundant_set"], ["proof (chain)\npicking this:\n  \\<nexists>P. redundant_set g P\n  redundant_set g (reachable g \\<phi>)", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>P. redundant_set g P\n  redundant_set g (reachable g \\<phi>)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "case nontrivial"], ["proof (state)\nthis:\n  2 \\<le> card (trueArgs g \\<phi>)\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "txt \\<open>If there are two or more necessary arguments, there must be disjoint paths from Defs to two of these \\pf s.\\<close>"], ["proof (state)\nthis:\n  2 \\<le> card (trueArgs g \\<phi>)\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  2 \\<le> card (trueArgs g \\<phi>)", "obtain r s \\<phi>\\<^sub>r \\<phi>\\<^sub>s where assign_nodes_props:\n      \"r \\<noteq> s\" \"\\<phi>\\<^sub>r \\<in> reachable g \\<phi>\" \"\\<phi>\\<^sub>s \\<in> reachable g \\<phi>\"\n      \"\\<not> unnecessaryPhi g r\" \"\\<not> unnecessaryPhi g s\"\n      \"r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\" \"s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\"\n      \"phiArg g \\<phi>\\<^sub>r r\" \"phiArg g \\<phi>\\<^sub>s s\""], ["proof (prove)\nusing this:\n  2 \\<le> card (trueArgs g \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<And>r s \\<phi>\\<^sub>r \\<phi>\\<^sub>s.\n        \\<lbrakk>r \\<noteq> s; \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n         \\<phi>\\<^sub>s \\<in> reachable g \\<phi>; \\<not> unnecessaryPhi g r;\n         \\<not> unnecessaryPhi g s;\n         r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n};\n         s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n};\n         phiArg g \\<phi>\\<^sub>r r; phiArg g \\<phi>\\<^sub>s s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r s \\<phi>\\<^sub>r \\<phi>\\<^sub>s.\n                \\<lbrakk>r \\<noteq> s;\n                 \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n                 \\<phi>\\<^sub>s \\<in> reachable g \\<phi>;\n                 \\<not> unnecessaryPhi g r; \\<not> unnecessaryPhi g s;\n                 (phiArg g)\\<^sup>*\\<^sup>* \\<phi> r;\n                 (phiArg g)\\<^sup>*\\<^sup>* \\<phi> s;\n                 phiArg g \\<phi>\\<^sub>r r;\n                 phiArg g \\<phi>\\<^sub>s s\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     2 \\<le> card\n              ({\\<phi>'. \\<phi>' \\<notin> reachable g \\<phi>} \\<inter>\n               {\\<phi>'.\n                \\<exists>\\<phi>''\\<in>reachable g \\<phi>.\n                   phiArg g \\<phi>'' \\<phi>'})\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (rule set_take_two[OF nontrivial])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>r s \\<phi>\\<^sub>r \\<phi>\\<^sub>s.\n                   \\<lbrakk>r \\<noteq> s;\n                    \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n                    \\<phi>\\<^sub>s \\<in> reachable g \\<phi>;\n                    \\<not> unnecessaryPhi g r; \\<not> unnecessaryPhi g s;\n                    (phiArg g)\\<^sup>*\\<^sup>* \\<phi> r;\n                    (phiArg g)\\<^sup>*\\<^sup>* \\<phi> s;\n                    phiArg g \\<phi>\\<^sub>r r;\n                    phiArg g \\<phi>\\<^sub>s s\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        2 \\<le> card\n                 ({\\<phi>'. \\<phi>' \\<notin> reachable g \\<phi>} \\<inter>\n                  {\\<phi>'.\n                   \\<exists>\\<phi>''\\<in>reachable g \\<phi>.\n                      phiArg g \\<phi>'' \\<phi>'});\n        x \\<in> trueArgs g \\<phi>; y \\<in> trueArgs g \\<phi>;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>r s \\<phi>\\<^sub>r \\<phi>\\<^sub>s.\n                   \\<lbrakk>r \\<noteq> s;\n                    \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n                    \\<phi>\\<^sub>s \\<in> reachable g \\<phi>;\n                    \\<not> unnecessaryPhi g r; \\<not> unnecessaryPhi g s;\n                    (phiArg g)\\<^sup>*\\<^sup>* \\<phi> r;\n                    (phiArg g)\\<^sup>*\\<^sup>* \\<phi> s;\n                    phiArg g \\<phi>\\<^sub>r r;\n                    phiArg g \\<phi>\\<^sub>s s\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        2 \\<le> card\n                 ({\\<phi>'. \\<phi>' \\<notin> reachable g \\<phi>} \\<inter>\n                  {\\<phi>'.\n                   \\<exists>\\<phi>''\\<in>reachable g \\<phi>.\n                      phiArg g \\<phi>'' \\<phi>'});\n        x \\<notin> reachable g \\<phi> \\<and>\n        (\\<exists>\\<phi>''\\<in>reachable g \\<phi>. phiArg g \\<phi>'' x);\n        y \\<notin> reachable g \\<phi> \\<and>\n        (\\<exists>\\<phi>''\\<in>reachable g \\<phi>. phiArg g \\<phi>'' y);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (meson reachable.intros(2) reachable_props(1) rtranclp_tranclp_tranclp tranclp.r_into_trancl tranclp_into_rtranclp)"], ["proof (state)\nthis:\n  r \\<noteq> s\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<not> unnecessaryPhi g r\n  \\<not> unnecessaryPhi g s\n  r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg g \\<phi>\\<^sub>s s\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  r \\<noteq> s\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<not> unnecessaryPhi g r\n  \\<not> unnecessaryPhi g s\n  r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg g \\<phi>\\<^sub>s s\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "from assign_nodes_props"], ["proof (chain)\npicking this:\n  r \\<noteq> s\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<not> unnecessaryPhi g r\n  \\<not> unnecessaryPhi g s\n  r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg g \\<phi>\\<^sub>s s", "have \\<phi>_r_s_uneq: \"\\<phi> \\<noteq> r\" \"\\<phi> \\<noteq> s\""], ["proof (prove)\nusing this:\n  r \\<noteq> s\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<not> unnecessaryPhi g r\n  \\<not> unnecessaryPhi g s\n  r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg g \\<phi>\\<^sub>s s\n\ngoal (1 subgoal):\n 1. \\<phi> \\<noteq> r &&& \\<phi> \\<noteq> s", "using \\<phi>_props"], ["proof (prove)\nusing this:\n  r \\<noteq> s\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<not> unnecessaryPhi g r\n  \\<not> unnecessaryPhi g s\n  r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg g \\<phi>\\<^sub>s s\n  unnecessaryPhi g \\<phi>\n  \\<phi> \\<in> allVars g\n  \\<phi> \\<in> reachable g \\<phi>\n\ngoal (1 subgoal):\n 1. \\<phi> \\<noteq> r &&& \\<phi> \\<noteq> s", "by auto"], ["proof (state)\nthis:\n  \\<phi> \\<noteq> r\n  \\<phi> \\<noteq> s\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<phi> \\<noteq> r\n  \\<phi> \\<noteq> s\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "from assign_nodes_props this"], ["proof (chain)\npicking this:\n  r \\<noteq> s\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<not> unnecessaryPhi g r\n  \\<not> unnecessaryPhi g s\n  r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg g \\<phi>\\<^sub>s s\n  \\<phi> \\<noteq> r\n  \\<phi> \\<noteq> s", "have r_s_in_tranclp: \"(phiArg g)\\<^sup>+\\<^sup>+ \\<phi> r\" \"(phiArg g)\\<^sup>+\\<^sup>+ \\<phi> s\""], ["proof (prove)\nusing this:\n  r \\<noteq> s\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<not> unnecessaryPhi g r\n  \\<not> unnecessaryPhi g s\n  r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg g \\<phi>\\<^sub>s s\n  \\<phi> \\<noteq> r\n  \\<phi> \\<noteq> s\n\ngoal (1 subgoal):\n 1. (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> r &&&\n    (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> s", "by (meson mem_Collect_eq rtranclpD) (meson assign_nodes_props(7) \\<phi>_r_s_uneq(2) mem_Collect_eq rtranclpD)"], ["proof (state)\nthis:\n  (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> r\n  (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> s\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> r\n  (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> s", "obtain V where V_props: \"var g r = V\" \"var g s = V\" \"var g \\<phi> = V\""], ["proof (prove)\nusing this:\n  (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> r\n  (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> s\n\ngoal (1 subgoal):\n 1. (\\<And>V.\n        \\<lbrakk>var g r = V; var g s = V; var g \\<phi> = V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis phiArg_trancl_same_var)"], ["proof (state)\nthis:\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "from r_s_in_tranclp"], ["proof (chain)\npicking this:\n  (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> r\n  (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> s", "have r_s_allVars: \"r \\<in> allVars g\" \"s \\<in> allVars g\""], ["proof (prove)\nusing this:\n  (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> r\n  (phiArg g)\\<^sup>+\\<^sup>+ \\<phi> s\n\ngoal (1 subgoal):\n 1. r \\<in> allVars g &&& s \\<in> allVars g", "by (metis phiArg_in_allVars tranclp.cases)+"], ["proof (state)\nthis:\n  r \\<in> allVars g\n  s \\<in> allVars g\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  r \\<in> allVars g\n  s \\<in> allVars g\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "from V_props defNode_var_disjoint r_s_allVars assign_nodes_props(1)"], ["proof (chain)\npicking this:\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  \\<lbrakk>?p \\<in> allVars ?g; ?q \\<in> allVars ?g; ?p \\<noteq> ?q;\n   defNode ?g ?p = defNode ?g ?q\\<rbrakk>\n  \\<Longrightarrow> var ?g ?p \\<noteq> var ?g ?q\n  r \\<in> allVars g\n  s \\<in> allVars g\n  r \\<noteq> s", "have r_s_defNode_distinct: \"defNode g r \\<noteq> defNode g s\""], ["proof (prove)\nusing this:\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  \\<lbrakk>?p \\<in> allVars ?g; ?q \\<in> allVars ?g; ?p \\<noteq> ?q;\n   defNode ?g ?p = defNode ?g ?q\\<rbrakk>\n  \\<Longrightarrow> var ?g ?p \\<noteq> var ?g ?q\n  r \\<in> allVars g\n  s \\<in> allVars g\n  r \\<noteq> s\n\ngoal (1 subgoal):\n 1. defNode g r \\<noteq> defNode g s", "by auto"], ["proof (state)\nthis:\n  defNode g r \\<noteq> defNode g s\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  r \\<noteq> s\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<not> unnecessaryPhi g r\n  \\<not> unnecessaryPhi g s\n  r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg g \\<phi>\\<^sub>s s\n  \\<phi> \\<noteq> r\n  \\<phi> \\<noteq> s\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  r \\<in> allVars g\n  s \\<in> allVars g\n  defNode g r \\<noteq> defNode g s", "obtain n ns m ms where r_s_path_props: \"V \\<in> oldDefs g n\" \"g \\<turnstile> n-ns\\<rightarrow>defNode g r\" \"V \\<in> oldDefs g m\" \"g \\<turnstile> m-ms\\<rightarrow>defNode g s\"\n      \"set ns \\<inter> set ms = {}\""], ["proof (prove)\nusing this:\n  r \\<noteq> s\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<not> unnecessaryPhi g r\n  \\<not> unnecessaryPhi g s\n  r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg g \\<phi>\\<^sub>s s\n  \\<phi> \\<noteq> r\n  \\<phi> \\<noteq> s\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  r \\<in> allVars g\n  s \\<in> allVars g\n  defNode g r \\<noteq> defNode g s\n\ngoal (1 subgoal):\n 1. (\\<And>n ns m ms.\n        \\<lbrakk>V \\<in> oldDefs g n;\n         g \\<turnstile> n-ns\\<rightarrow>defNode g r; V \\<in> oldDefs g m;\n         g \\<turnstile> m-ms\\<rightarrow>defNode g s;\n         set ns \\<inter> set ms = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: ununnecessaryPhis_disjoint_paths[of g r s])"], ["proof (state)\nthis:\n  V \\<in> oldDefs g n\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  V \\<in> oldDefs g m\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  set ns \\<inter> set ms = {}\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "have n_m_distinct: \"n \\<noteq> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> m", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<noteq> m \\<Longrightarrow> False", "assume n_m: \"\\<not> n \\<noteq> m\""], ["proof (state)\nthis:\n  \\<not> n \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<not> n \\<noteq> m \\<Longrightarrow> False", "with r_s_path_props(2) old.path2_hd_in_ns"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  ?g \\<turnstile> ?n-?ns\\<rightarrow>?m \\<Longrightarrow> ?n \\<in> set ?ns\n  \\<not> n \\<noteq> m", "have \"n \\<in> set ns\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  ?g \\<turnstile> ?n-?ns\\<rightarrow>?m \\<Longrightarrow> ?n \\<in> set ?ns\n  \\<not> n \\<noteq> m\n\ngoal (1 subgoal):\n 1. n \\<in> set ns", "by blast"], ["proof (state)\nthis:\n  n \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<not> n \\<noteq> m \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<not> n \\<noteq> m \\<Longrightarrow> False", "from n_m r_s_path_props(4) old.path2_hd_in_ns"], ["proof (chain)\npicking this:\n  \\<not> n \\<noteq> m\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  ?g \\<turnstile> ?n-?ns\\<rightarrow>?m \\<Longrightarrow> ?n \\<in> set ?ns", "have \"n \\<in> set ms\""], ["proof (prove)\nusing this:\n  \\<not> n \\<noteq> m\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  ?g \\<turnstile> ?n-?ns\\<rightarrow>?m \\<Longrightarrow> ?n \\<in> set ?ns\n\ngoal (1 subgoal):\n 1. n \\<in> set ms", "by blast"], ["proof (state)\nthis:\n  n \\<in> set ms\n\ngoal (1 subgoal):\n 1. \\<not> n \\<noteq> m \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  n \\<in> set ns\n  n \\<in> set ms", "show False"], ["proof (prove)\nusing this:\n  n \\<in> set ns\n  n \\<in> set ms\n\ngoal (1 subgoal):\n 1. False", "using r_s_path_props(5)"], ["proof (prove)\nusing this:\n  n \\<in> set ns\n  n \\<in> set ms\n  set ns \\<inter> set ms = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<noteq> m\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "txt \\<open>These paths can be extended into paths reaching \\pf s in our set.\\<close>"], ["proof (state)\nthis:\n  n \\<noteq> m\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "from V_props r_s_allVars r_s_path_props assign_nodes_props"], ["proof (chain)\npicking this:\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  r \\<in> allVars g\n  s \\<in> allVars g\n  V \\<in> oldDefs g n\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  V \\<in> oldDefs g m\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  set ns \\<inter> set ms = {}\n  r \\<noteq> s\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<not> unnecessaryPhi g r\n  \\<not> unnecessaryPhi g s\n  r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg g \\<phi>\\<^sub>s s", "obtain rs where rs_props: \"g \\<turnstile> n -ns@rs\\<rightarrow> defNode g \\<phi>\\<^sub>r\" \"set (butlast (ns@rs)) \\<inter> set ms = {}\""], ["proof (prove)\nusing this:\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  r \\<in> allVars g\n  s \\<in> allVars g\n  V \\<in> oldDefs g n\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  V \\<in> oldDefs g m\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  set ns \\<inter> set ms = {}\n  r \\<noteq> s\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<not> unnecessaryPhi g r\n  \\<not> unnecessaryPhi g s\n  r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg g \\<phi>\\<^sub>s s\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>g \\<turnstile> n-ns @\n                                  rs\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n         set (butlast (ns @ rs)) \\<inter> set ms = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using phiArg_disjoint_paths_extend"], ["proof (prove)\nusing this:\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  r \\<in> allVars g\n  s \\<in> allVars g\n  V \\<in> oldDefs g n\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  V \\<in> oldDefs g m\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  set ns \\<inter> set ms = {}\n  r \\<noteq> s\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<not> unnecessaryPhi g r\n  \\<not> unnecessaryPhi g s\n  r \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  s \\<in> {n. (phiArg g)\\<^sup>*\\<^sup>* \\<phi> n}\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg g \\<phi>\\<^sub>s s\n  \\<lbrakk>var ?g ?r = ?V; var ?g ?s = ?V; ?r \\<in> allVars ?g;\n   ?s \\<in> allVars ?g; ?V \\<in> oldDefs ?g ?n; ?V \\<in> oldDefs ?g ?m;\n   ?g \\<turnstile> ?n-?ns\\<rightarrow>defNode ?g ?r;\n   ?g \\<turnstile> ?m-?ms\\<rightarrow>defNode ?g ?s;\n   set ?ns \\<inter> set ?ms = {}; phiArg ?g ?\\<phi>\\<^sub>r ?r;\n   \\<And>ns'.\n      \\<lbrakk>?g \\<turnstile> ?n-?ns @\n                                  ns'\\<rightarrow>defNode ?g\n             ?\\<phi>\\<^sub>r;\n       set (butlast (?ns @ ns')) \\<inter> set ?ms = {}\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>g \\<turnstile> n-ns @\n                                  rs\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n         set (butlast (ns @ rs)) \\<inter> set ms = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast (ns @ rs)) \\<inter> set ms = {}\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "txt \\<open>(In fact, we can prove that @{prop \"set (ns@rs) \\<inter> set ms = {}\"}, which we need for the next path extension.)\\<close>"], ["proof (state)\nthis:\n  g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast (ns @ rs)) \\<inter> set ms = {}\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "have \"defNode g \\<phi>\\<^sub>r \\<notin> set ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defNode g \\<phi>\\<^sub>r \\<notin> set ms", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> defNode g \\<phi>\\<^sub>r \\<notin> set ms \\<Longrightarrow> False", "assume \\<phi>\\<^sub>r_in_ms: \"\\<not> defNode g \\<phi>\\<^sub>r \\<notin> set ms\""], ["proof (state)\nthis:\n  \\<not> defNode g \\<phi>\\<^sub>r \\<notin> set ms\n\ngoal (1 subgoal):\n 1. \\<not> defNode g \\<phi>\\<^sub>r \\<notin> set ms \\<Longrightarrow> False", "from this r_s_path_props(4)"], ["proof (chain)\npicking this:\n  \\<not> defNode g \\<phi>\\<^sub>r \\<notin> set ms\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s", "obtain ms' where ms'_props: \"g \\<turnstile> m -ms'\\<rightarrow> defNode g \\<phi>\\<^sub>r\" \"prefix ms' ms\""], ["proof (prove)\nusing this:\n  \\<not> defNode g \\<phi>\\<^sub>r \\<notin> set ms\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n\ngoal (1 subgoal):\n 1. (\\<And>ms'.\n        \\<lbrakk>g \\<turnstile> m-ms'\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n         prefix ms' ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(rule old.path2_prefix_ex[of g m ms \"defNode g s\" \"defNode g \\<phi>\\<^sub>r\"], auto)"], ["proof (state)\nthis:\n  g \\<turnstile> m-ms'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  prefix ms' ms\n\ngoal (1 subgoal):\n 1. \\<not> defNode g \\<phi>\\<^sub>r \\<notin> set ms \\<Longrightarrow> False", "have \"old.pathsConverge g n (ns@rs) m ms' (defNode g \\<phi>\\<^sub>r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. old.pathsConverge g n (ns @ rs) m ms' (defNode g \\<phi>\\<^sub>r)", "proof (rule old.pathsConvergeI)"], ["proof (state)\ngoal (5 subgoals):\n 1. g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 2. g \\<turnstile> m-ms'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 3. 1 < length (ns @ rs)\n 4. 1 < length ms'\n 5. set (butlast (ns @ rs)) \\<inter> set (butlast ms') = {}", "show \"set (butlast (ns @ rs)) \\<inter> set (butlast ms') = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (butlast (ns @ rs)) \\<inter> set (butlast ms') = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. set (butlast (ns @ rs)) \\<inter> set (butlast ms') \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"set (butlast (ns @ rs)) \\<inter> set (butlast ms') \\<noteq> {}\""], ["proof (state)\nthis:\n  set (butlast (ns @ rs)) \\<inter> set (butlast ms') \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set (butlast (ns @ rs)) \\<inter> set (butlast ms') \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  set (butlast (ns @ rs)) \\<inter> set (butlast ms') \\<noteq> {}", "obtain c where c_props: \"c \\<in> set (butlast (ns@rs))\" \"c \\<in> set (butlast ms')\""], ["proof (prove)\nusing this:\n  set (butlast (ns @ rs)) \\<inter> set (butlast ms') \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> set (butlast (ns @ rs));\n         c \\<in> set (butlast ms')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<in> set (butlast (ns @ rs))\n  c \\<in> set (butlast ms')\n\ngoal (1 subgoal):\n 1. set (butlast (ns @ rs)) \\<inter> set (butlast ms') \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from this(2) ms'_props(2)"], ["proof (chain)\npicking this:\n  c \\<in> set (butlast ms')\n  prefix ms' ms", "have \"c \\<in> set ms\""], ["proof (prove)\nusing this:\n  c \\<in> set (butlast ms')\n  prefix ms' ms\n\ngoal (1 subgoal):\n 1. c \\<in> set ms", "by (simp add: in_prefix in_set_butlastD)"], ["proof (state)\nthis:\n  c \\<in> set ms\n\ngoal (1 subgoal):\n 1. set (butlast (ns @ rs)) \\<inter> set (butlast ms') \\<noteq>\n    {} \\<Longrightarrow>\n    False", "with c_props(1) rs_props(2)"], ["proof (chain)\npicking this:\n  c \\<in> set (butlast (ns @ rs))\n  set (butlast (ns @ rs)) \\<inter> set ms = {}\n  c \\<in> set ms", "show False"], ["proof (prove)\nusing this:\n  c \\<in> set (butlast (ns @ rs))\n  set (butlast (ns @ rs)) \\<inter> set ms = {}\n  c \\<in> set ms\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (butlast (ns @ rs)) \\<inter> set (butlast ms') = {}\n\ngoal (4 subgoals):\n 1. g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 2. g \\<turnstile> m-ms'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 3. 1 < length (ns @ rs)\n 4. 1 < length ms'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 2. g \\<turnstile> m-ms'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 3. 1 < length (ns @ rs)\n 4. 1 < length ms'", "have m_n_\\<phi>\\<^sub>r_differ: \"n \\<noteq> defNode g \\<phi>\\<^sub>r\" \"m \\<noteq> defNode g \\<phi>\\<^sub>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> defNode g \\<phi>\\<^sub>r &&&\n    m \\<noteq> defNode g \\<phi>\\<^sub>r", "using assign_nodes_props(2,3,4,5) V_props r_s_path_props \\<phi>\\<^sub>r_in_ms"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<not> unnecessaryPhi g r\n  \\<not> unnecessaryPhi g s\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  V \\<in> oldDefs g n\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  V \\<in> oldDefs g m\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  set ns \\<inter> set ms = {}\n  \\<not> defNode g \\<phi>\\<^sub>r \\<notin> set ms\n\ngoal (1 subgoal):\n 1. n \\<noteq> defNode g \\<phi>\\<^sub>r &&&\n    m \\<noteq> defNode g \\<phi>\\<^sub>r", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> defNode g \\<phi>\\<^sub>r", "using V_props(1) \\<phi>\\<^sub>r_in_ms assign_nodes_props(8) old.path2_in_\\<alpha>n phiArg_def phiArg_same_var r_s_path_props(3,4) simpleDefs_phiDefs_var_disjoint"], ["proof (prove)\nusing this:\n  var g r = V\n  \\<not> defNode g \\<phi>\\<^sub>r \\<notin> set ms\n  phiArg g \\<phi>\\<^sub>r r\n  \\<lbrakk>?g \\<turnstile> ?n-?ns\\<rightarrow>?m; ?l \\<in> set ?ns\\<rbrakk>\n  \\<Longrightarrow> ?l \\<in> set (\\<alpha>n ?g)\n  phiArg ?g ?v ?v' \\<equiv>\n  \\<exists>vs. phi ?g ?v = Some vs \\<and> ?v' \\<in> set vs\n  phiArg ?g ?p ?q \\<Longrightarrow> var ?g ?q = var ?g ?p\n  V \\<in> oldDefs g m\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  \\<lbrakk>?v \\<in> phiDefs ?g ?n; ?n \\<in> set (\\<alpha>n ?g)\\<rbrakk>\n  \\<Longrightarrow> var ?g ?v \\<notin> oldDefs ?g ?n\n\ngoal (1 subgoal):\n 1. m \\<noteq> defNode g \\<phi>\\<^sub>r", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> defNode g \\<phi>\\<^sub>r\n\ngoal (4 subgoals):\n 1. g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 2. g \\<turnstile> m-ms'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 3. 1 < length (ns @ rs)\n 4. 1 < length ms'", "with ms'_props(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> m-ms'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  n \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> defNode g \\<phi>\\<^sub>r", "show \"1 < length ms'\""], ["proof (prove)\nusing this:\n  g \\<turnstile> m-ms'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  n \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> defNode g \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. 1 < length ms'", "using old.path2_nontriv"], ["proof (prove)\nusing this:\n  g \\<turnstile> m-ms'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  n \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> defNode g \\<phi>\\<^sub>r\n  \\<lbrakk>?g \\<turnstile> ?n-?ns\\<rightarrow>?m; ?n \\<noteq> ?m\\<rbrakk>\n  \\<Longrightarrow> 1 < length ?ns\n\ngoal (1 subgoal):\n 1. 1 < length ms'", "by simp"], ["proof (state)\nthis:\n  1 < length ms'\n\ngoal (3 subgoals):\n 1. g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 2. g \\<turnstile> m-ms'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 3. 1 < length (ns @ rs)", "from m_n_\\<phi>\\<^sub>r_differ rs_props(1)"], ["proof (chain)\npicking this:\n  n \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r", "show \"1 < length (ns@rs)\""], ["proof (prove)\nusing this:\n  n \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. 1 < length (ns @ rs)", "using old.path2_nontriv"], ["proof (prove)\nusing this:\n  n \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  \\<lbrakk>?g \\<turnstile> ?n-?ns\\<rightarrow>?m; ?n \\<noteq> ?m\\<rbrakk>\n  \\<Longrightarrow> 1 < length ?ns\n\ngoal (1 subgoal):\n 1. 1 < length (ns @ rs)", "by blast"], ["proof (state)\nthis:\n  1 < length (ns @ rs)\n\ngoal (2 subgoals):\n 1. g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 2. g \\<turnstile> m-ms'\\<rightarrow>defNode g \\<phi>\\<^sub>r", "qed (auto intro: rs_props set_mono_prefix ms'_props)"], ["proof (state)\nthis:\n  old.pathsConverge g n (ns @ rs) m ms' (defNode g \\<phi>\\<^sub>r)\n\ngoal (1 subgoal):\n 1. \\<not> defNode g \\<phi>\\<^sub>r \\<notin> set ms \\<Longrightarrow> False", "with V_props r_s_path_props"], ["proof (chain)\npicking this:\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  V \\<in> oldDefs g n\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  V \\<in> oldDefs g m\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  set ns \\<inter> set ms = {}\n  old.pathsConverge g n (ns @ rs) m ms' (defNode g \\<phi>\\<^sub>r)", "have \"necessaryPhi' g \\<phi>\\<^sub>r\""], ["proof (prove)\nusing this:\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  V \\<in> oldDefs g n\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  V \\<in> oldDefs g m\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  set ns \\<inter> set ms = {}\n  old.pathsConverge g n (ns @ rs) m ms' (defNode g \\<phi>\\<^sub>r)\n\ngoal (1 subgoal):\n 1. necessaryPhi' g \\<phi>\\<^sub>r", "unfolding necessaryPhi_def"], ["proof (prove)\nusing this:\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  V \\<in> oldDefs g n\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  V \\<in> oldDefs g m\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  set ns \\<inter> set ms = {}\n  old.pathsConverge g n (ns @ rs) m ms' (defNode g \\<phi>\\<^sub>r)\n\ngoal (1 subgoal):\n 1. \\<exists>n ns m ms.\n       old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>r) \\<and>\n       var g \\<phi>\\<^sub>r \\<in> oldDefs g n \\<and>\n       var g \\<phi>\\<^sub>r \\<in> oldDefs g m", "using assign_nodes_props(8) phiArg_same_var"], ["proof (prove)\nusing this:\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  V \\<in> oldDefs g n\n  g \\<turnstile> n-ns\\<rightarrow>defNode g r\n  V \\<in> oldDefs g m\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  set ns \\<inter> set ms = {}\n  old.pathsConverge g n (ns @ rs) m ms' (defNode g \\<phi>\\<^sub>r)\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg ?g ?p ?q \\<Longrightarrow> var ?g ?q = var ?g ?p\n\ngoal (1 subgoal):\n 1. \\<exists>n ns m ms.\n       old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>r) \\<and>\n       var g \\<phi>\\<^sub>r \\<in> oldDefs g n \\<and>\n       var g \\<phi>\\<^sub>r \\<in> oldDefs g m", "by auto"], ["proof (state)\nthis:\n  necessaryPhi' g \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. \\<not> defNode g \\<phi>\\<^sub>r \\<notin> set ms \\<Longrightarrow> False", "with reachable_props(2)[OF assign_nodes_props(2)]"], ["proof (chain)\npicking this:\n  unnecessaryPhi g \\<phi>\\<^sub>r\n  necessaryPhi' g \\<phi>\\<^sub>r", "show False"], ["proof (prove)\nusing this:\n  unnecessaryPhi g \\<phi>\\<^sub>r\n  necessaryPhi' g \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. False", "unfolding unnecessaryPhi_def"], ["proof (prove)\nusing this:\n  phi g \\<phi>\\<^sub>r \\<noteq> None \\<and>\n  \\<not> necessaryPhi' g \\<phi>\\<^sub>r\n  necessaryPhi' g \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  defNode g \\<phi>\\<^sub>r \\<notin> set ms\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "with rs_props"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast (ns @ rs)) \\<inter> set ms = {}\n  defNode g \\<phi>\\<^sub>r \\<notin> set ms", "have aux: \"set ms \\<inter> set (ns @ rs) = {}\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast (ns @ rs)) \\<inter> set ms = {}\n  defNode g \\<phi>\\<^sub>r \\<notin> set ms\n\ngoal (1 subgoal):\n 1. set ms \\<inter> set (ns @ rs) = {}", "by (metis disjoint_iff_not_equal not_in_butlast old.path2_last)"], ["proof (state)\nthis:\n  set ms \\<inter> set (ns @ rs) = {}\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "have \\<phi>\\<^sub>r_V: \"var g \\<phi>\\<^sub>r = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var g \\<phi>\\<^sub>r = V", "using V_props(1) assign_nodes_props(8) phiArg_same_var"], ["proof (prove)\nusing this:\n  var g r = V\n  phiArg g \\<phi>\\<^sub>r r\n  phiArg ?g ?p ?q \\<Longrightarrow> var ?g ?q = var ?g ?p\n\ngoal (1 subgoal):\n 1. var g \\<phi>\\<^sub>r = V", "by auto"], ["proof (state)\nthis:\n  var g \\<phi>\\<^sub>r = V\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "have \\<phi>\\<^sub>r_allVars: \"\\<phi>\\<^sub>r \\<in> allVars g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>r \\<in> allVars g", "by (meson phiArg_def assign_nodes_props(8) allDefs_in_allVars old.path2_tl_in_\\<alpha>n phiDefs_in_allDefs phi_phiDefs rs_props)"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>r \\<in> allVars g\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "from V_props(2) \\<phi>\\<^sub>r_V r_s_allVars(2) \\<phi>\\<^sub>r_allVars r_s_path_props(3) r_s_path_props(1)\n             r_s_path_props(4) rs_props(1) aux assign_nodes_props(9)"], ["proof (chain)\npicking this:\n  var g s = V\n  var g \\<phi>\\<^sub>r = V\n  s \\<in> allVars g\n  \\<phi>\\<^sub>r \\<in> allVars g\n  V \\<in> oldDefs g m\n  V \\<in> oldDefs g n\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set ms \\<inter> set (ns @ rs) = {}\n  phiArg g \\<phi>\\<^sub>s s", "obtain ss where ss_props: \"g \\<turnstile> m -ms@ss\\<rightarrow> defNode g \\<phi>\\<^sub>s\" \"set (butlast (ms@ss)) \\<inter> set (butlast (ns@rs)) = {}\""], ["proof (prove)\nusing this:\n  var g s = V\n  var g \\<phi>\\<^sub>r = V\n  s \\<in> allVars g\n  \\<phi>\\<^sub>r \\<in> allVars g\n  V \\<in> oldDefs g m\n  V \\<in> oldDefs g n\n  g \\<turnstile> m-ms\\<rightarrow>defNode g s\n  g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set ms \\<inter> set (ns @ rs) = {}\n  phiArg g \\<phi>\\<^sub>s s\n\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>g \\<turnstile> m-ms @\n                                  ss\\<rightarrow>defNode g \\<phi>\\<^sub>s;\n         set (butlast (ms @ ss)) \\<inter> set (butlast (ns @ rs)) =\n         {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule phiArg_disjoint_paths_extend) (metis disjoint_iff_not_equal in_set_butlastD)"], ["proof (state)\nthis:\n  g \\<turnstile> m-ms @ ss\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  set (butlast (ms @ ss)) \\<inter> set (butlast (ns @ rs)) = {}\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "define p\\<^sub>m where \"p\\<^sub>m = ms@ss\""], ["proof (state)\nthis:\n  p\\<^sub>m = ms @ ss\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "define p\\<^sub>n where \"p\\<^sub>n = ns@rs\""], ["proof (state)\nthis:\n  p\\<^sub>n = ns @ rs\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "have ind_props: \"g \\<turnstile> m -p\\<^sub>m\\<rightarrow> defNode g \\<phi>\\<^sub>s\" \"g \\<turnstile> n -p\\<^sub>n\\<rightarrow> defNode g \\<phi>\\<^sub>r\" \"set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s &&&\n    g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r &&&\n    set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}", "using rs_props(1) ss_props p\\<^sub>m_def p\\<^sub>n_def"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns @ rs\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> m-ms @ ss\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  set (butlast (ms @ ss)) \\<inter> set (butlast (ns @ rs)) = {}\n  p\\<^sub>m = ms @ ss\n  p\\<^sub>n = ns @ rs\n\ngoal (1 subgoal):\n 1. g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s &&&\n    g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r &&&\n    set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}", "by auto"], ["proof (state)\nthis:\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "txt \\<open>The following case will occur twice in the induction, with swapped identifiers, so we're proving it outside.\n    Basically, if the paths @{term p\\<^sub>m} and @{term p\\<^sub>n} intersect, the first such intersection point must be a \\pf\\ in @{term \"reachable g \\<phi>\"},\n    yielding the path convergence we seek.\\<close>"], ["proof (state)\nthis:\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "have path_crossing_yields_convergence:\n      \"\\<exists>\\<phi>\\<^sub>z \\<in> reachable g \\<phi>. \\<exists>ns ms. old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\"\n      if \"\\<phi>\\<^sub>r \\<in> reachable g \\<phi>\" and \"\\<phi>\\<^sub>s \\<in> reachable g \\<phi>\" and \"g \\<turnstile> n -p\\<^sub>n\\<rightarrow> defNode g \\<phi>\\<^sub>r\"\n        and \"g \\<turnstile> m -p\\<^sub>m\\<rightarrow> defNode g \\<phi>\\<^sub>s\" and \"set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\"\n        and \"set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {}\"\n      for \\<phi>\\<^sub>r \\<phi>\\<^sub>s p\\<^sub>m p\\<^sub>n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "from that(6) split_list_first_propE"], ["proof (chain)\npicking this:\n  set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {}\n  \\<lbrakk>\\<exists>x\\<in>set ?xs. ?P x;\n   \\<And>ys x zs.\n      \\<lbrakk>?xs = ys @ x # zs; ?P x;\n       \\<forall>y\\<in>set ys. \\<not> ?P y\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "obtain p\\<^sub>m1 n\\<^sub>z p\\<^sub>m2 where n\\<^sub>z_props: \"n\\<^sub>z \\<in> set p\\<^sub>n\" \"p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2\" \"\\<forall>n \\<in> set p\\<^sub>m1. n \\<notin> set p\\<^sub>n\""], ["proof (prove)\nusing this:\n  set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {}\n  \\<lbrakk>\\<exists>x\\<in>set ?xs. ?P x;\n   \\<And>ys x zs.\n      \\<lbrakk>?xs = ys @ x # zs; ?P x;\n       \\<forall>y\\<in>set ys. \\<not> ?P y\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>n\\<^sub>z p\\<^sub>m1 p\\<^sub>m2.\n        \\<lbrakk>n\\<^sub>z \\<in> set p\\<^sub>n;\n         p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2;\n         \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: split_list_first_propE)"], ["proof (state)\nthis:\n  n\\<^sub>z \\<in> set p\\<^sub>n\n  p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2\n  \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "with that(3,4)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  n\\<^sub>z \\<in> set p\\<^sub>n\n  p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2\n  \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n", "obtain p\\<^sub>n' where p\\<^sub>n'_props: \"g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>n\\<^sub>z\" \"g \\<turnstile> m-p\\<^sub>m1@[n\\<^sub>z]\\<rightarrow>n\\<^sub>z\" \"prefix p\\<^sub>n' p\\<^sub>n\" \"n\\<^sub>z \\<notin> set (butlast p\\<^sub>n')\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  n\\<^sub>z \\<in> set p\\<^sub>n\n  p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2\n  \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n\n\ngoal (1 subgoal):\n 1. (\\<And>p\\<^sub>n''.\n        \\<lbrakk>g \\<turnstile> n-p\\<^sub>n''\\<rightarrow>n\\<^sub>z;\n         g \\<turnstile> m-p\\<^sub>m1 @ [n\\<^sub>z]\\<rightarrow>n\\<^sub>z;\n         prefix p\\<^sub>n'' p\\<^sub>n;\n         n\\<^sub>z \\<notin> set (butlast p\\<^sub>n'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson old.path2_prefix_ex old.path2_split(1))"], ["proof (state)\nthis:\n  g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>n\\<^sub>z\n  g \\<turnstile> m-p\\<^sub>m1 @ [n\\<^sub>z]\\<rightarrow>n\\<^sub>z\n  prefix p\\<^sub>n' p\\<^sub>n\n  n\\<^sub>z \\<notin> set (butlast p\\<^sub>n')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "from V_props(3) reachable_same_var[OF that(1)] reachable_same_var[OF that(2)]"], ["proof (chain)\npicking this:\n  var g \\<phi> = V\n  var g \\<phi> = var g \\<phi>\\<^sub>r\n  var g \\<phi> = var g \\<phi>\\<^sub>s", "have phis_V: \"var g \\<phi>\\<^sub>r = V\" \"var g \\<phi>\\<^sub>s = V\""], ["proof (prove)\nusing this:\n  var g \\<phi> = V\n  var g \\<phi> = var g \\<phi>\\<^sub>r\n  var g \\<phi> = var g \\<phi>\\<^sub>s\n\ngoal (1 subgoal):\n 1. var g \\<phi>\\<^sub>r = V &&& var g \\<phi>\\<^sub>s = V", "by simp_all"], ["proof (state)\nthis:\n  var g \\<phi>\\<^sub>r = V\n  var g \\<phi>\\<^sub>s = V\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "from reachable_props(1) that(1,2) \\<phi>_props(2) phiArg_in_allVars"], ["proof (chain)\npicking this:\n  ?\\<phi>' \\<in> reachable ?g ?\\<phi> \\<Longrightarrow>\n  (phiArg ?g)\\<^sup>*\\<^sup>* ?\\<phi> ?\\<phi>'\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<phi> \\<in> allVars g\n  phiArg ?g ?v ?v' \\<Longrightarrow> ?v' \\<in> allVars ?g", "have phis_allVars: \"\\<phi>\\<^sub>r \\<in> allVars g\" \"\\<phi>\\<^sub>s \\<in> allVars g\""], ["proof (prove)\nusing this:\n  ?\\<phi>' \\<in> reachable ?g ?\\<phi> \\<Longrightarrow>\n  (phiArg ?g)\\<^sup>*\\<^sup>* ?\\<phi> ?\\<phi>'\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<phi> \\<in> allVars g\n  phiArg ?g ?v ?v' \\<Longrightarrow> ?v' \\<in> allVars ?g\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>r \\<in> allVars g &&& \\<phi>\\<^sub>s \\<in> allVars g", "by (metis rtranclp.cases)+"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>r \\<in> allVars g\n  \\<phi>\\<^sub>s \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "txt \\<open>Various inequalities for proving paths aren't trivial.\\<close>"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>r \\<in> allVars g\n  \\<phi>\\<^sub>s \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "have \"n \\<noteq> defNode g \\<phi>\\<^sub>r\" \"m \\<noteq> defNode g \\<phi>\\<^sub>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> defNode g \\<phi>\\<^sub>r &&&\n    m \\<noteq> defNode g \\<phi>\\<^sub>r", "using \\<phi>_node_no_defs phis_V(1) phis_allVars(1) r_s_path_props(1,3) reachable_props(2) that(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>unnecessaryPhi ?g ?\\<phi>; ?\\<phi> \\<in> allVars ?g;\n   var ?g ?\\<phi> \\<in> oldDefs ?g ?n\\<rbrakk>\n  \\<Longrightarrow> defNode ?g ?\\<phi> \\<noteq> ?n\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  V \\<in> oldDefs g n\n  V \\<in> oldDefs g m\n  ?\\<phi>' \\<in> reachable ?g ?\\<phi> \\<Longrightarrow>\n  unnecessaryPhi ?g ?\\<phi>'\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n\ngoal (1 subgoal):\n 1. n \\<noteq> defNode g \\<phi>\\<^sub>r &&&\n    m \\<noteq> defNode g \\<phi>\\<^sub>r", "by blast+"], ["proof (state)\nthis:\n  n \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> defNode g \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "from \\<phi>_node_no_defs reachable_props(2) that(2) r_s_path_props(1,3) phis_V(2) that phis_allVars"], ["proof (chain)\npicking this:\n  \\<lbrakk>unnecessaryPhi ?g ?\\<phi>; ?\\<phi> \\<in> allVars ?g;\n   var ?g ?\\<phi> \\<in> oldDefs ?g ?n\\<rbrakk>\n  \\<Longrightarrow> defNode ?g ?\\<phi> \\<noteq> ?n\n  ?\\<phi>' \\<in> reachable ?g ?\\<phi> \\<Longrightarrow>\n  unnecessaryPhi ?g ?\\<phi>'\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  V \\<in> oldDefs g n\n  V \\<in> oldDefs g m\n  var g \\<phi>\\<^sub>s = V\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {}\n  \\<phi>\\<^sub>r \\<in> allVars g\n  \\<phi>\\<^sub>s \\<in> allVars g", "have \"m \\<noteq> defNode g \\<phi>\\<^sub>s\" \"n \\<noteq> defNode g \\<phi>\\<^sub>s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>unnecessaryPhi ?g ?\\<phi>; ?\\<phi> \\<in> allVars ?g;\n   var ?g ?\\<phi> \\<in> oldDefs ?g ?n\\<rbrakk>\n  \\<Longrightarrow> defNode ?g ?\\<phi> \\<noteq> ?n\n  ?\\<phi>' \\<in> reachable ?g ?\\<phi> \\<Longrightarrow>\n  unnecessaryPhi ?g ?\\<phi>'\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  V \\<in> oldDefs g n\n  V \\<in> oldDefs g m\n  var g \\<phi>\\<^sub>s = V\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {}\n  \\<phi>\\<^sub>r \\<in> allVars g\n  \\<phi>\\<^sub>s \\<in> allVars g\n\ngoal (1 subgoal):\n 1. m \\<noteq> defNode g \\<phi>\\<^sub>s &&&\n    n \\<noteq> defNode g \\<phi>\\<^sub>s", "by blast+"], ["proof (state)\nthis:\n  m \\<noteq> defNode g \\<phi>\\<^sub>s\n  n \\<noteq> defNode g \\<phi>\\<^sub>s\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "txt \\<open>With this scenario, since @{prop \"set (butlast p\\<^sub>n) \\<inter> set (butlast p\\<^sub>m) = {}\"}, one of the paths @{term p\\<^sub>n} and\n      @{term p\\<^sub>m} must end somewhere within the other, however this means the \\pf\\ in that node must either be @{term \\<phi>} or @{term \\<phi>\\<^sub>r}\\<close>"], ["proof (state)\nthis:\n  m \\<noteq> defNode g \\<phi>\\<^sub>s\n  n \\<noteq> defNode g \\<phi>\\<^sub>s\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "from assms n\\<^sub>z_props"], ["proof (chain)\npicking this:\n  \\<nexists>P. redundant_set g P\n  n\\<^sub>z \\<in> set p\\<^sub>n\n  p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2\n  \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n", "consider (p\\<^sub>n_ends_in_p\\<^sub>m) \"n\\<^sub>z = defNode g \\<phi>\\<^sub>s\" | (p\\<^sub>m_ends_in_p\\<^sub>n) \"n\\<^sub>z = defNode g \\<phi>\\<^sub>r\""], ["proof (prove)\nusing this:\n  \\<nexists>P. redundant_set g P\n  n\\<^sub>z \\<in> set p\\<^sub>n\n  p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2\n  \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis;\n     n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases \"n\\<^sub>z = last p\\<^sub>n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis;\n     n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis;\n     \\<nexists>P. redundant_set g P; n\\<^sub>z \\<in> set p\\<^sub>n;\n     p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2;\n     \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n;\n     n\\<^sub>z = last p\\<^sub>n\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis;\n     n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis;\n     \\<nexists>P. redundant_set g P; n\\<^sub>z \\<in> set p\\<^sub>n;\n     p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2;\n     \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n;\n     n\\<^sub>z \\<noteq> last p\\<^sub>n\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  n\\<^sub>z = last p\\<^sub>n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis;\n     n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis;\n     \\<nexists>P. redundant_set g P; n\\<^sub>z \\<in> set p\\<^sub>n;\n     p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2;\n     \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n;\n     n\\<^sub>z = last p\\<^sub>n\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis;\n     n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis;\n     \\<nexists>P. redundant_set g P; n\\<^sub>z \\<in> set p\\<^sub>n;\n     p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2;\n     \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n;\n     n\\<^sub>z \\<noteq> last p\\<^sub>n\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<open>g \\<turnstile> n -p\\<^sub>n\\<rightarrow> defNode g \\<phi>\\<^sub>r\\<close>"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  n\\<^sub>z = last p\\<^sub>n", "have \"n\\<^sub>z = defNode g \\<phi>\\<^sub>r\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  n\\<^sub>z = last p\\<^sub>n\n\ngoal (1 subgoal):\n 1. n\\<^sub>z = defNode g \\<phi>\\<^sub>r", "using old.path2_last"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  n\\<^sub>z = last p\\<^sub>n\n  ?g \\<turnstile> ?n-?ns\\<rightarrow>?m \\<Longrightarrow> ?m = last ?ns\n\ngoal (1 subgoal):\n 1. n\\<^sub>z = defNode g \\<phi>\\<^sub>r", "by auto"], ["proof (state)\nthis:\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis;\n     n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis;\n     \\<nexists>P. redundant_set g P; n\\<^sub>z \\<in> set p\\<^sub>n;\n     p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2;\n     \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n;\n     n\\<^sub>z = last p\\<^sub>n\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis;\n     n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis;\n     \\<nexists>P. redundant_set g P; n\\<^sub>z \\<in> set p\\<^sub>n;\n     p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2;\n     \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n;\n     n\\<^sub>z \\<noteq> last p\\<^sub>n\\<rbrakk>\n    \\<Longrightarrow> thesis", "with that(2)"], ["proof (chain)\npicking this:\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>r", "show ?thesis"], ["proof (prove)\nusing this:\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis;\n     n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis;\n     \\<nexists>P. redundant_set g P; n\\<^sub>z \\<in> set p\\<^sub>n;\n     p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2;\n     \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n;\n     n\\<^sub>z \\<noteq> last p\\<^sub>n\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis;\n     n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis;\n     \\<nexists>P. redundant_set g P; n\\<^sub>z \\<in> set p\\<^sub>n;\n     p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2;\n     \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n;\n     n\\<^sub>z \\<noteq> last p\\<^sub>n\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  n\\<^sub>z \\<noteq> last p\\<^sub>n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis;\n     n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis;\n     \\<nexists>P. redundant_set g P; n\\<^sub>z \\<in> set p\\<^sub>n;\n     p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2;\n     \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n;\n     n\\<^sub>z \\<noteq> last p\\<^sub>n\\<rbrakk>\n    \\<Longrightarrow> thesis", "from n\\<^sub>z_props(2)"], ["proof (chain)\npicking this:\n  p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2", "have \"n\\<^sub>z \\<in> set p\\<^sub>m\""], ["proof (prove)\nusing this:\n  p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2\n\ngoal (1 subgoal):\n 1. n\\<^sub>z \\<in> set p\\<^sub>m", "by simp"], ["proof (state)\nthis:\n  n\\<^sub>z \\<in> set p\\<^sub>m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis;\n     n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis;\n     \\<nexists>P. redundant_set g P; n\\<^sub>z \\<in> set p\\<^sub>n;\n     p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2;\n     \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n;\n     n\\<^sub>z \\<noteq> last p\\<^sub>n\\<rbrakk>\n    \\<Longrightarrow> thesis", "with False n\\<^sub>z_props(1) \\<open>set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\\<close> \\<open>g \\<turnstile> m -p\\<^sub>m\\<rightarrow> defNode g \\<phi>\\<^sub>s\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>z \\<noteq> last p\\<^sub>n\n  n\\<^sub>z \\<in> set p\\<^sub>n\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  n\\<^sub>z \\<in> set p\\<^sub>m", "have \"n\\<^sub>z = defNode g \\<phi>\\<^sub>s\""], ["proof (prove)\nusing this:\n  n\\<^sub>z \\<noteq> last p\\<^sub>n\n  n\\<^sub>z \\<in> set p\\<^sub>n\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  n\\<^sub>z \\<in> set p\\<^sub>m\n\ngoal (1 subgoal):\n 1. n\\<^sub>z = defNode g \\<phi>\\<^sub>s", "by (metis disjoint_elem not_in_butlast old.path2_last)"], ["proof (state)\nthis:\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis;\n     n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> thesis;\n     \\<nexists>P. redundant_set g P; n\\<^sub>z \\<in> set p\\<^sub>n;\n     p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2;\n     \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n;\n     n\\<^sub>z \\<noteq> last p\\<^sub>n\\<rbrakk>\n    \\<Longrightarrow> thesis", "with that(1)"], ["proof (chain)\npicking this:\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>s", "show ?thesis"], ["proof (prove)\nusing this:\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> thesis\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>s\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> ?thesis1;\n   n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "thus \"\\<exists>\\<phi>\\<^sub>z \\<in> reachable g \\<phi>. \\<exists>ns ms. old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow> ?thesis1;\n   n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n 2. n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "case p\\<^sub>n_ends_in_p\\<^sub>m"], ["proof (state)\nthis:\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>s\n\ngoal (2 subgoals):\n 1. n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n 2. n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "have \"old.pathsConverge g n p\\<^sub>n' m p\\<^sub>m (defNode g \\<phi>\\<^sub>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. old.pathsConverge g n p\\<^sub>n' m p\\<^sub>m (defNode g \\<phi>\\<^sub>s)", "proof (rule old.pathsConvergeI)"], ["proof (state)\ngoal (5 subgoals):\n 1. g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>defNode g \\<phi>\\<^sub>s\n 2. g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n 3. 1 < length p\\<^sub>n'\n 4. 1 < length p\\<^sub>m\n 5. set (butlast p\\<^sub>n') \\<inter> set (butlast p\\<^sub>m) = {}", "from p\\<^sub>n_ends_in_p\\<^sub>m p\\<^sub>n'_props(1)"], ["proof (chain)\npicking this:\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>s\n  g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>n\\<^sub>z", "show \"g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>defNode g \\<phi>\\<^sub>s\""], ["proof (prove)\nusing this:\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>s\n  g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>n\\<^sub>z\n\ngoal (1 subgoal):\n 1. g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>defNode g \\<phi>\\<^sub>s", "by simp"], ["proof (state)\nthis:\n  g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>defNode g \\<phi>\\<^sub>s\n\ngoal (4 subgoals):\n 1. g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n 2. 1 < length p\\<^sub>n'\n 3. 1 < length p\\<^sub>m\n 4. set (butlast p\\<^sub>n') \\<inter> set (butlast p\\<^sub>m) = {}", "from \\<open>n \\<noteq> defNode g \\<phi>\\<^sub>s\\<close> p\\<^sub>n_ends_in_p\\<^sub>m p\\<^sub>n'_props(1) old.path2_nontriv"], ["proof (chain)\npicking this:\n  n \\<noteq> defNode g \\<phi>\\<^sub>s\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>s\n  g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>n\\<^sub>z\n  \\<lbrakk>?g \\<turnstile> ?n-?ns\\<rightarrow>?m; ?n \\<noteq> ?m\\<rbrakk>\n  \\<Longrightarrow> 1 < length ?ns", "show \"1 < length p\\<^sub>n'\""], ["proof (prove)\nusing this:\n  n \\<noteq> defNode g \\<phi>\\<^sub>s\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>s\n  g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>n\\<^sub>z\n  \\<lbrakk>?g \\<turnstile> ?n-?ns\\<rightarrow>?m; ?n \\<noteq> ?m\\<rbrakk>\n  \\<Longrightarrow> 1 < length ?ns\n\ngoal (1 subgoal):\n 1. 1 < length p\\<^sub>n'", "by auto"], ["proof (state)\nthis:\n  1 < length p\\<^sub>n'\n\ngoal (3 subgoals):\n 1. g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n 2. 1 < length p\\<^sub>m\n 3. set (butlast p\\<^sub>n') \\<inter> set (butlast p\\<^sub>m) = {}", "from that(4)"], ["proof (chain)\npicking this:\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s", "show \"g \\<turnstile> m -p\\<^sub>m\\<rightarrow> defNode g \\<phi>\\<^sub>s\""], ["proof (prove)\nusing this:\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n\ngoal (1 subgoal):\n 1. g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s", "."], ["proof (state)\nthis:\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n\ngoal (2 subgoals):\n 1. 1 < length p\\<^sub>m\n 2. set (butlast p\\<^sub>n') \\<inter> set (butlast p\\<^sub>m) = {}", "with \\<open>m \\<noteq> defNode g \\<phi>\\<^sub>s\\<close> old.path2_nontriv"], ["proof (chain)\npicking this:\n  m \\<noteq> defNode g \\<phi>\\<^sub>s\n  \\<lbrakk>?g \\<turnstile> ?n-?ns\\<rightarrow>?m; ?n \\<noteq> ?m\\<rbrakk>\n  \\<Longrightarrow> 1 < length ?ns\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s", "show \"1 < length p\\<^sub>m\""], ["proof (prove)\nusing this:\n  m \\<noteq> defNode g \\<phi>\\<^sub>s\n  \\<lbrakk>?g \\<turnstile> ?n-?ns\\<rightarrow>?m; ?n \\<noteq> ?m\\<rbrakk>\n  \\<Longrightarrow> 1 < length ?ns\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n\ngoal (1 subgoal):\n 1. 1 < length p\\<^sub>m", "by simp"], ["proof (state)\nthis:\n  1 < length p\\<^sub>m\n\ngoal (1 subgoal):\n 1. set (butlast p\\<^sub>n') \\<inter> set (butlast p\\<^sub>m) = {}", "from that p\\<^sub>n'_props(3)"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {}\n  prefix p\\<^sub>n' p\\<^sub>n", "show \"set (butlast p\\<^sub>n') \\<inter> set (butlast p\\<^sub>m) = {}\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {}\n  prefix p\\<^sub>n' p\\<^sub>n\n\ngoal (1 subgoal):\n 1. set (butlast p\\<^sub>n') \\<inter> set (butlast p\\<^sub>m) = {}", "by (meson butlast_prefix disjointI disjoint_elem in_prefix)"], ["proof (state)\nthis:\n  set (butlast p\\<^sub>n') \\<inter> set (butlast p\\<^sub>m) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  old.pathsConverge g n p\\<^sub>n' m p\\<^sub>m (defNode g \\<phi>\\<^sub>s)\n\ngoal (2 subgoals):\n 1. n\\<^sub>z = defNode g \\<phi>\\<^sub>s \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n 2. n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "with that(1,2,3)"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  old.pathsConverge g n p\\<^sub>n' m p\\<^sub>m (defNode g \\<phi>\\<^sub>s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  old.pathsConverge g n p\\<^sub>n' m p\\<^sub>m (defNode g \\<phi>\\<^sub>s)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "by (auto intro:reachable.intros(2))"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "case p\\<^sub>m_ends_in_p\\<^sub>n"], ["proof (state)\nthis:\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "have \"old.pathsConverge g n p\\<^sub>n' m (p\\<^sub>m1@[n\\<^sub>z]) (defNode g \\<phi>\\<^sub>r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. old.pathsConverge g n p\\<^sub>n' m (p\\<^sub>m1 @ [n\\<^sub>z])\n     (defNode g \\<phi>\\<^sub>r)", "proof (rule old.pathsConvergeI)"], ["proof (state)\ngoal (5 subgoals):\n 1. g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 2. g \\<turnstile> m-p\\<^sub>m1 @\n                     [n\\<^sub>z]\\<rightarrow>defNode g \\<phi>\\<^sub>r\n 3. 1 < length p\\<^sub>n'\n 4. 1 < length (p\\<^sub>m1 @ [n\\<^sub>z])\n 5. set (butlast p\\<^sub>n') \\<inter>\n    set (butlast (p\\<^sub>m1 @ [n\\<^sub>z])) =\n    {}", "from p\\<^sub>m_ends_in_p\\<^sub>n  p\\<^sub>n'_props(1,2)"], ["proof (chain)\npicking this:\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>n\\<^sub>z\n  g \\<turnstile> m-p\\<^sub>m1 @ [n\\<^sub>z]\\<rightarrow>n\\<^sub>z", "show \"g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>defNode g \\<phi>\\<^sub>r\" \"g \\<turnstile> m-p\\<^sub>m1 @ [n\\<^sub>z]\\<rightarrow>defNode g \\<phi>\\<^sub>r\""], ["proof (prove)\nusing this:\n  n\\<^sub>z = defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>n\\<^sub>z\n  g \\<turnstile> m-p\\<^sub>m1 @ [n\\<^sub>z]\\<rightarrow>n\\<^sub>z\n\ngoal (1 subgoal):\n 1. g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>defNode g \\<phi>\\<^sub>r &&&\n    g \\<turnstile> m-p\\<^sub>m1 @\n                     [n\\<^sub>z]\\<rightarrow>defNode g \\<phi>\\<^sub>r", "by simp_all"], ["proof (state)\nthis:\n  g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> m-p\\<^sub>m1 @\n                   [n\\<^sub>z]\\<rightarrow>defNode g \\<phi>\\<^sub>r\n\ngoal (3 subgoals):\n 1. 1 < length p\\<^sub>n'\n 2. 1 < length (p\\<^sub>m1 @ [n\\<^sub>z])\n 3. set (butlast p\\<^sub>n') \\<inter>\n    set (butlast (p\\<^sub>m1 @ [n\\<^sub>z])) =\n    {}", "with \\<open>n \\<noteq> defNode g \\<phi>\\<^sub>r\\<close> \\<open>m \\<noteq> defNode g \\<phi>\\<^sub>r\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> m-p\\<^sub>m1 @\n                   [n\\<^sub>z]\\<rightarrow>defNode g \\<phi>\\<^sub>r", "show \"1 < length p\\<^sub>n'\" \"1 < length (p\\<^sub>m1 @ [n\\<^sub>z])\""], ["proof (prove)\nusing this:\n  n \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> m-p\\<^sub>m1 @\n                   [n\\<^sub>z]\\<rightarrow>defNode g \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. 1 < length p\\<^sub>n' &&& 1 < length (p\\<^sub>m1 @ [n\\<^sub>z])", "using old.path2_nontriv[of g m \"p\\<^sub>m1 @ [n\\<^sub>z]\"] old.path2_nontriv[of g n]"], ["proof (prove)\nusing this:\n  n \\<noteq> defNode g \\<phi>\\<^sub>r\n  m \\<noteq> defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> n-p\\<^sub>n'\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> m-p\\<^sub>m1 @\n                   [n\\<^sub>z]\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  \\<lbrakk>g \\<turnstile> m-p\\<^sub>m1 @ [n\\<^sub>z]\\<rightarrow>?m;\n   m \\<noteq> ?m\\<rbrakk>\n  \\<Longrightarrow> 1 < length (p\\<^sub>m1 @ [n\\<^sub>z])\n  \\<lbrakk>g \\<turnstile> n-?ns\\<rightarrow>?m; n \\<noteq> ?m\\<rbrakk>\n  \\<Longrightarrow> 1 < length ?ns\n\ngoal (1 subgoal):\n 1. 1 < length p\\<^sub>n' &&& 1 < length (p\\<^sub>m1 @ [n\\<^sub>z])", "by simp_all"], ["proof (state)\nthis:\n  1 < length p\\<^sub>n'\n  1 < length (p\\<^sub>m1 @ [n\\<^sub>z])\n\ngoal (1 subgoal):\n 1. set (butlast p\\<^sub>n') \\<inter>\n    set (butlast (p\\<^sub>m1 @ [n\\<^sub>z])) =\n    {}", "from n\\<^sub>z_props p\\<^sub>n'_props(3)"], ["proof (chain)\npicking this:\n  n\\<^sub>z \\<in> set p\\<^sub>n\n  p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2\n  \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n\n  prefix p\\<^sub>n' p\\<^sub>n", "show \"set (butlast p\\<^sub>n') \\<inter> set (butlast (p\\<^sub>m1 @ [n\\<^sub>z])) = {}\""], ["proof (prove)\nusing this:\n  n\\<^sub>z \\<in> set p\\<^sub>n\n  p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2\n  \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n\n  prefix p\\<^sub>n' p\\<^sub>n\n\ngoal (1 subgoal):\n 1. set (butlast p\\<^sub>n') \\<inter>\n    set (butlast (p\\<^sub>m1 @ [n\\<^sub>z])) =\n    {}", "using butlast_snoc disjointI in_prefix in_set_butlastD"], ["proof (prove)\nusing this:\n  n\\<^sub>z \\<in> set p\\<^sub>n\n  p\\<^sub>m = p\\<^sub>m1 @ n\\<^sub>z # p\\<^sub>m2\n  \\<forall>n\\<in>set p\\<^sub>m1. n \\<notin> set p\\<^sub>n\n  prefix p\\<^sub>n' p\\<^sub>n\n  butlast (?xs @ [?x]) = ?xs\n  (\\<And>x.\n      \\<lbrakk>x \\<in> ?a; x \\<in> ?b\\<rbrakk>\n      \\<Longrightarrow> False) \\<Longrightarrow>\n  ?a \\<inter> ?b = {}\n  \\<lbrakk>prefix ?xs ?ys; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> set ?ys\n  ?x \\<in> set (butlast ?xs) \\<Longrightarrow> ?x \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. set (butlast p\\<^sub>n') \\<inter>\n    set (butlast (p\\<^sub>m1 @ [n\\<^sub>z])) =\n    {}", "by fastforce"], ["proof (state)\nthis:\n  set (butlast p\\<^sub>n') \\<inter>\n  set (butlast (p\\<^sub>m1 @ [n\\<^sub>z])) =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  old.pathsConverge g n p\\<^sub>n' m (p\\<^sub>m1 @ [n\\<^sub>z])\n   (defNode g \\<phi>\\<^sub>r)\n\ngoal (1 subgoal):\n 1. n\\<^sub>z = defNode g \\<phi>\\<^sub>r \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "with that(1)"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  old.pathsConverge g n p\\<^sub>n' m (p\\<^sub>m1 @ [n\\<^sub>z])\n   (defNode g \\<phi>\\<^sub>r)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  old.pathsConverge g n p\\<^sub>n' m (p\\<^sub>m1 @ [n\\<^sub>z])\n   (defNode g \\<phi>\\<^sub>r)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "by (auto intro:reachable.intros)"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<phi>\\<^sub>r1 \\<in> reachable g \\<phi>;\n   ?\\<phi>\\<^sub>s1 \\<in> reachable g \\<phi>;\n   g \\<turnstile> n-?p\\<^sub>n1\\<rightarrow>defNode g ?\\<phi>\\<^sub>r1;\n   g \\<turnstile> m-?p\\<^sub>m1\\<rightarrow>defNode g ?\\<phi>\\<^sub>s1;\n   set (butlast ?p\\<^sub>m1) \\<inter> set (butlast ?p\\<^sub>n1) = {};\n   set ?p\\<^sub>m1 \\<inter> set ?p\\<^sub>n1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "txt \\<open>Since the reachable-set was built starting at a single $\\phi$, these paths must at some\n         point converge \\emph{within} @{term \"reachable g \\<phi>\"}.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<phi>\\<^sub>r1 \\<in> reachable g \\<phi>;\n   ?\\<phi>\\<^sub>s1 \\<in> reachable g \\<phi>;\n   g \\<turnstile> n-?p\\<^sub>n1\\<rightarrow>defNode g ?\\<phi>\\<^sub>r1;\n   g \\<turnstile> m-?p\\<^sub>m1\\<rightarrow>defNode g ?\\<phi>\\<^sub>s1;\n   set (butlast ?p\\<^sub>m1) \\<inter> set (butlast ?p\\<^sub>n1) = {};\n   set ?p\\<^sub>m1 \\<inter> set ?p\\<^sub>n1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "from assign_nodes_props(3,2) ind_props V_props(3) \\<phi>\\<^sub>r_V \\<phi>\\<^sub>r_allVars"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g", "have \"\\<exists>\\<phi>\\<^sub>z \\<in> reachable g \\<phi>. \\<exists>ns ms. old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>s \\<in> reachable g \\<phi>\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "proof (induction arbitrary: p\\<^sub>m p\\<^sub>n rule: reachable.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>unnecessaryPhi g \\<phi>;\n        \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n        \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)\n 2. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n            g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>';\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n            \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>'';\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n        \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "case refl"], ["proof (state)\nthis:\n  unnecessaryPhi g \\<phi>\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n\ngoal (2 subgoals):\n 1. \\<And>p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>unnecessaryPhi g \\<phi>;\n        \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n        \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)\n 2. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n            g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>';\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n            \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>'';\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n        \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "txt \\<open>In the induction basis, we know that @{prop \"\\<phi> = \\<phi>\\<^sub>s\"}, and a path to @{term \\<phi>\\<^sub>r} must be obtained\n          -- for this we need a second induction.\\<close>"], ["proof (state)\nthis:\n  unnecessaryPhi g \\<phi>\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n\ngoal (2 subgoals):\n 1. \\<And>p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>unnecessaryPhi g \\<phi>;\n        \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n        \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)\n 2. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n            g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>';\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n            \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>'';\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n        \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "from refl.prems refl.hyps"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  unnecessaryPhi g \\<phi>", "show ?case"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  unnecessaryPhi g \\<phi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "proof (induction arbitrary: p\\<^sub>m p\\<^sub>n rule: reachable.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>unnecessaryPhi g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi> = V; \\<phi> \\<in> allVars g;\n        unnecessaryPhi g \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)\n 2. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n            unnecessaryPhi g \\<phi>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>'';\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>'' = V; \\<phi>'' \\<in> allVars g;\n        unnecessaryPhi g \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "case refl"], ["proof (state)\nthis:\n  unnecessaryPhi g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi> = V\n  \\<phi> \\<in> allVars g\n  unnecessaryPhi g \\<phi>\n\ngoal (2 subgoals):\n 1. \\<And>p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>unnecessaryPhi g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi> = V; \\<phi> \\<in> allVars g;\n        unnecessaryPhi g \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)\n 2. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n            unnecessaryPhi g \\<phi>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>'';\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>'' = V; \\<phi>'' \\<in> allVars g;\n        unnecessaryPhi g \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "txt \\<open>The first case, in which \\<open>\\<phi>\\<^sub>r = \\<phi>\\<^sub>s = \\<phi>\\<close>, is trivial -- \\<open>\\<phi>\\<close> suffices.\\<close>"], ["proof (state)\nthis:\n  unnecessaryPhi g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi> = V\n  \\<phi> \\<in> allVars g\n  unnecessaryPhi g \\<phi>\n\ngoal (2 subgoals):\n 1. \\<And>p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>unnecessaryPhi g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi> = V; \\<phi> \\<in> allVars g;\n        unnecessaryPhi g \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)\n 2. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n            unnecessaryPhi g \\<phi>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>'';\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>'' = V; \\<phi>'' \\<in> allVars g;\n        unnecessaryPhi g \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "have \"old.pathsConverge g n p\\<^sub>n m p\\<^sub>m (defNode g \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. old.pathsConverge g n p\\<^sub>n m p\\<^sub>m (defNode g \\<phi>)", "proof (rule old.pathsConvergeI)"], ["proof (state)\ngoal (5 subgoals):\n 1. g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\n 2. g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n 3. 1 < length p\\<^sub>n\n 4. 1 < length p\\<^sub>m\n 5. set (butlast p\\<^sub>n) \\<inter> set (butlast p\\<^sub>m) = {}", "show \"1 < length p\\<^sub>n\" \"1 < length p\\<^sub>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length p\\<^sub>n &&& 1 < length p\\<^sub>m", "using refl V_props simpleDefs_phiDefs_var_disjoint"], ["proof (prove)\nusing this:\n  unnecessaryPhi g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi> = V\n  \\<phi> \\<in> allVars g\n  unnecessaryPhi g \\<phi>\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  \\<lbrakk>?v \\<in> phiDefs ?g ?n; ?n \\<in> set (\\<alpha>n ?g)\\<rbrakk>\n  \\<Longrightarrow> var ?g ?v \\<notin> oldDefs ?g ?n\n\ngoal (1 subgoal):\n 1. 1 < length p\\<^sub>n &&& 1 < length p\\<^sub>m", "unfolding unnecessaryPhi_def"], ["proof (prove)\nusing this:\n  phi g \\<phi> \\<noteq> None \\<and> \\<not> necessaryPhi' g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi> = V\n  \\<phi> \\<in> allVars g\n  phi g \\<phi> \\<noteq> None \\<and> \\<not> necessaryPhi' g \\<phi>\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  \\<lbrakk>?v \\<in> phiDefs ?g ?n; ?n \\<in> set (\\<alpha>n ?g)\\<rbrakk>\n  \\<Longrightarrow> var ?g ?v \\<notin> oldDefs ?g ?n\n\ngoal (1 subgoal):\n 1. 1 < length p\\<^sub>n &&& 1 < length p\\<^sub>m", "by (metis domD domIff old.path2_hd_in_\\<alpha>n old.path2_nontriv phi_phiDefs r_s_path_props(1) r_s_path_props(3))+"], ["proof (state)\nthis:\n  1 < length p\\<^sub>n\n  1 < length p\\<^sub>m\n\ngoal (3 subgoals):\n 1. g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\n 2. g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n 3. set (butlast p\\<^sub>n) \\<inter> set (butlast p\\<^sub>m) = {}", "show \"g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\" \"g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\" \"set (butlast p\\<^sub>n) \\<inter> set (butlast p\\<^sub>m) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi> &&&\n    g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi> &&&\n    set (butlast p\\<^sub>n) \\<inter> set (butlast p\\<^sub>m) = {}", "using refl"], ["proof (prove)\nusing this:\n  unnecessaryPhi g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi> = V\n  \\<phi> \\<in> allVars g\n  unnecessaryPhi g \\<phi>\n\ngoal (1 subgoal):\n 1. g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi> &&&\n    g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi> &&&\n    set (butlast p\\<^sub>n) \\<inter> set (butlast p\\<^sub>m) = {}", "by auto"], ["proof (state)\nthis:\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  set (butlast p\\<^sub>n) \\<inter> set (butlast p\\<^sub>m) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  old.pathsConverge g n p\\<^sub>n m p\\<^sub>m (defNode g \\<phi>)\n\ngoal (2 subgoals):\n 1. \\<And>p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>unnecessaryPhi g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi> = V; \\<phi> \\<in> allVars g;\n        unnecessaryPhi g \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)\n 2. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n            unnecessaryPhi g \\<phi>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>'';\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>'' = V; \\<phi>'' \\<in> allVars g;\n        unnecessaryPhi g \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "with \\<open>\\<phi> \\<in> reachable g \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  \\<phi> \\<in> reachable g \\<phi>\n  old.pathsConverge g n p\\<^sub>n m p\\<^sub>m (defNode g \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  \\<phi> \\<in> reachable g \\<phi>\n  old.pathsConverge g n p\\<^sub>n m p\\<^sub>m (defNode g \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n            unnecessaryPhi g \\<phi>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>'';\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>'' = V; \\<phi>'' \\<in> allVars g;\n        unnecessaryPhi g \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n            unnecessaryPhi g \\<phi>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>'';\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>'' = V; \\<phi>'' \\<in> allVars g;\n        unnecessaryPhi g \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "case (step \\<phi>' \\<phi>\\<^sub>r)"], ["proof (state)\nthis:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>\\<^sub>r\n  unnecessaryPhi g \\<phi>\\<^sub>r\n  \\<lbrakk>g \\<turnstile> m-?p\\<^sub>m1\\<rightarrow>defNode g \\<phi>;\n   g \\<turnstile> n-?p\\<^sub>n1\\<rightarrow>defNode g \\<phi>';\n   set (butlast ?p\\<^sub>m1) \\<inter> set (butlast ?p\\<^sub>n1) = {};\n   var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n   unnecessaryPhi g \\<phi>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  unnecessaryPhi g \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n            unnecessaryPhi g \\<phi>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>'';\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>'' = V; \\<phi>'' \\<in> allVars g;\n        unnecessaryPhi g \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "txt \\<open>In this case we have that @{prop \"\\<phi> = \\<phi>\\<^sub>s\"} and need to acquire a path going to @{term \\<phi>\\<^sub>r},\n            however with the aux.\\ lemma we have, we still need that @{term p\\<^sub>n} and @{term p\\<^sub>m} are disjoint.\\<close>"], ["proof (state)\nthis:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>\\<^sub>r\n  unnecessaryPhi g \\<phi>\\<^sub>r\n  \\<lbrakk>g \\<turnstile> m-?p\\<^sub>m1\\<rightarrow>defNode g \\<phi>;\n   g \\<turnstile> n-?p\\<^sub>n1\\<rightarrow>defNode g \\<phi>';\n   set (butlast ?p\\<^sub>m1) \\<inter> set (butlast ?p\\<^sub>n1) = {};\n   var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n   unnecessaryPhi g \\<phi>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  unnecessaryPhi g \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n            unnecessaryPhi g \\<phi>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>'';\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>'' = V; \\<phi>'' \\<in> allVars g;\n        unnecessaryPhi g \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>\\<^sub>r\n  unnecessaryPhi g \\<phi>\\<^sub>r\n  \\<lbrakk>g \\<turnstile> m-?p\\<^sub>m1\\<rightarrow>defNode g \\<phi>;\n   g \\<turnstile> n-?p\\<^sub>n1\\<rightarrow>defNode g \\<phi>';\n   set (butlast ?p\\<^sub>m1) \\<inter> set (butlast ?p\\<^sub>n1) = {};\n   var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n   unnecessaryPhi g \\<phi>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  unnecessaryPhi g \\<phi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "proof (cases \"set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)\n 2. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)", "case paths_cross: False"], ["proof (state)\nthis:\n  set p\\<^sub>n \\<inter> set p\\<^sub>m \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)\n 2. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)", "with step reachable.intros"], ["proof (chain)\npicking this:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>\\<^sub>r\n  unnecessaryPhi g \\<phi>\\<^sub>r\n  \\<lbrakk>g \\<turnstile> m-?p\\<^sub>m1\\<rightarrow>defNode g \\<phi>;\n   g \\<turnstile> n-?p\\<^sub>n1\\<rightarrow>defNode g \\<phi>';\n   set (butlast ?p\\<^sub>m1) \\<inter> set (butlast ?p\\<^sub>n1) = {};\n   var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n   unnecessaryPhi g \\<phi>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  unnecessaryPhi g \\<phi>\n  unnecessaryPhi ?g ?\\<phi> \\<Longrightarrow>\n  ?\\<phi> \\<in> reachable ?g ?\\<phi>\n  \\<lbrakk>?\\<phi>' \\<in> reachable ?g ?\\<phi>;\n   phiArg ?g ?\\<phi>' ?\\<phi>''; unnecessaryPhi ?g ?\\<phi>''\\<rbrakk>\n  \\<Longrightarrow> ?\\<phi>'' \\<in> reachable ?g ?\\<phi>\n  set p\\<^sub>n \\<inter> set p\\<^sub>m \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>\\<^sub>r\n  unnecessaryPhi g \\<phi>\\<^sub>r\n  \\<lbrakk>g \\<turnstile> m-?p\\<^sub>m1\\<rightarrow>defNode g \\<phi>;\n   g \\<turnstile> n-?p\\<^sub>n1\\<rightarrow>defNode g \\<phi>';\n   set (butlast ?p\\<^sub>m1) \\<inter> set (butlast ?p\\<^sub>n1) = {};\n   var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n   unnecessaryPhi g \\<phi>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  unnecessaryPhi g \\<phi>\n  unnecessaryPhi ?g ?\\<phi> \\<Longrightarrow>\n  ?\\<phi> \\<in> reachable ?g ?\\<phi>\n  \\<lbrakk>?\\<phi>' \\<in> reachable ?g ?\\<phi>;\n   phiArg ?g ?\\<phi>' ?\\<phi>''; unnecessaryPhi ?g ?\\<phi>''\\<rbrakk>\n  \\<Longrightarrow> ?\\<phi>'' \\<in> reachable ?g ?\\<phi>\n  set p\\<^sub>n \\<inter> set p\\<^sub>m \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "using path_crossing_yields_convergence[of \\<phi>\\<^sub>r \\<phi> p\\<^sub>n p\\<^sub>m]"], ["proof (prove)\nusing this:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>\\<^sub>r\n  unnecessaryPhi g \\<phi>\\<^sub>r\n  \\<lbrakk>g \\<turnstile> m-?p\\<^sub>m1\\<rightarrow>defNode g \\<phi>;\n   g \\<turnstile> n-?p\\<^sub>n1\\<rightarrow>defNode g \\<phi>';\n   set (butlast ?p\\<^sub>m1) \\<inter> set (butlast ?p\\<^sub>n1) = {};\n   var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n   unnecessaryPhi g \\<phi>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  unnecessaryPhi g \\<phi>\n  unnecessaryPhi ?g ?\\<phi> \\<Longrightarrow>\n  ?\\<phi> \\<in> reachable ?g ?\\<phi>\n  \\<lbrakk>?\\<phi>' \\<in> reachable ?g ?\\<phi>;\n   phiArg ?g ?\\<phi>' ?\\<phi>''; unnecessaryPhi ?g ?\\<phi>''\\<rbrakk>\n  \\<Longrightarrow> ?\\<phi>'' \\<in> reachable ?g ?\\<phi>\n  set p\\<^sub>n \\<inter> set p\\<^sub>m \\<noteq> {}\n  \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n   \\<phi> \\<in> reachable g \\<phi>;\n   g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n   g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n   set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n   set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "by (metis disjointI disjoint_elem)"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)", "case True"], ["proof (state)\nthis:\n  set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)", "txt \\<open>If the paths are intersection-free, we can apply our path extension lemma to obtain the path needed.\\<close>"], ["proof (state)\nthis:\n  set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)", "from step(9,8,10) \\<open>\\<phi> \\<in> allVars g\\<close> r_s_path_props(1,3) step(6,5) True step(2)"], ["proof (chain)\npicking this:\n  var g \\<phi>\\<^sub>r = V\n  var g \\<phi> = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  \\<phi> \\<in> allVars g\n  V \\<in> oldDefs g n\n  V \\<in> oldDefs g m\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\n  phiArg g \\<phi>' \\<phi>\\<^sub>r", "obtain ns where \"g \\<turnstile> n -p\\<^sub>n@ns\\<rightarrow> defNode g \\<phi>'\" \"set (butlast (p\\<^sub>n@ns)) \\<inter> set p\\<^sub>m = {}\""], ["proof (prove)\nusing this:\n  var g \\<phi>\\<^sub>r = V\n  var g \\<phi> = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  \\<phi> \\<in> allVars g\n  V \\<in> oldDefs g n\n  V \\<in> oldDefs g m\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\n  phiArg g \\<phi>' \\<phi>\\<^sub>r\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>g \\<turnstile> n-p\\<^sub>n @\n                                  ns\\<rightarrow>defNode g \\<phi>';\n         set (butlast (p\\<^sub>n @ ns)) \\<inter> set p\\<^sub>m = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule phiArg_disjoint_paths_extend)"], ["proof (state)\nthis:\n  g \\<turnstile> n-p\\<^sub>n @ ns\\<rightarrow>defNode g \\<phi>'\n  set (butlast (p\\<^sub>n @ ns)) \\<inter> set p\\<^sub>m = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)", "from this(2)"], ["proof (chain)\npicking this:\n  set (butlast (p\\<^sub>n @ ns)) \\<inter> set p\\<^sub>m = {}", "have \"set (butlast p\\<^sub>m) \\<inter> set (butlast (p\\<^sub>n @ ns)) = {}\""], ["proof (prove)\nusing this:\n  set (butlast (p\\<^sub>n @ ns)) \\<inter> set p\\<^sub>m = {}\n\ngoal (1 subgoal):\n 1. set (butlast p\\<^sub>m) \\<inter> set (butlast (p\\<^sub>n @ ns)) = {}", "using in_set_butlastD"], ["proof (prove)\nusing this:\n  set (butlast (p\\<^sub>n @ ns)) \\<inter> set p\\<^sub>m = {}\n  ?x \\<in> set (butlast ?xs) \\<Longrightarrow> ?x \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. set (butlast p\\<^sub>m) \\<inter> set (butlast (p\\<^sub>n @ ns)) = {}", "by fastforce"], ["proof (state)\nthis:\n  set (butlast p\\<^sub>m) \\<inter> set (butlast (p\\<^sub>n @ ns)) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)", "moreover"], ["proof (state)\nthis:\n  set (butlast p\\<^sub>m) \\<inter> set (butlast (p\\<^sub>n @ ns)) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)", "from phiArg_same_var step.hyps(2) step.prems(5)"], ["proof (chain)\npicking this:\n  phiArg ?g ?p ?q \\<Longrightarrow> var ?g ?q = var ?g ?p\n  phiArg g \\<phi>' \\<phi>\\<^sub>r\n  var g \\<phi>\\<^sub>r = V", "have \"var g \\<phi>' = V\""], ["proof (prove)\nusing this:\n  phiArg ?g ?p ?q \\<Longrightarrow> var ?g ?q = var ?g ?p\n  phiArg g \\<phi>' \\<phi>\\<^sub>r\n  var g \\<phi>\\<^sub>r = V\n\ngoal (1 subgoal):\n 1. var g \\<phi>' = V", "by auto"], ["proof (state)\nthis:\n  var g \\<phi>' = V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)", "moreover"], ["proof (state)\nthis:\n  var g \\<phi>' = V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)", "have \"\\<phi>' \\<in> allVars g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>' \\<in> allVars g", "by (metis \\<phi>_props(2) phiArg_in_allVars reachable.cases step.hyps(1))"], ["proof (state)\nthis:\n  \\<phi>' \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n     phiArg g \\<phi>' \\<phi>\\<^sub>r; unnecessaryPhi g \\<phi>\\<^sub>r;\n     \\<And>p\\<^sub>m p\\<^sub>n.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n         g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>';\n         set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n         var g \\<phi> = V; var g \\<phi>' = V; \\<phi>' \\<in> allVars g;\n         unnecessaryPhi g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                             \\<exists>ns ms.\n                                old.pathsConverge g n ns m ms\n                                 (defNode g \\<phi>\\<^sub>z);\n     g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>;\n     g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n     set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n     var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n     \\<phi>\\<^sub>r \\<in> allVars g; unnecessaryPhi g \\<phi>;\n     set p\\<^sub>n \\<inter> set p\\<^sub>m = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                         \\<exists>ns ms.\n                            old.pathsConverge g n ns m ms\n                             (defNode g \\<phi>\\<^sub>z)", "ultimately"], ["proof (chain)\npicking this:\n  set (butlast p\\<^sub>m) \\<inter> set (butlast (p\\<^sub>n @ ns)) = {}\n  var g \\<phi>' = V\n  \\<phi>' \\<in> allVars g", "show \"\\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>. \\<exists>ns ms. old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\""], ["proof (prove)\nusing this:\n  set (butlast p\\<^sub>m) \\<inter> set (butlast (p\\<^sub>n @ ns)) = {}\n  var g \\<phi>' = V\n  \\<phi>' \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "using step.prems(1) \\<phi>_props V_props \\<open>g \\<turnstile> n -p\\<^sub>n@ns\\<rightarrow> defNode g \\<phi>'\\<close>"], ["proof (prove)\nusing this:\n  set (butlast p\\<^sub>m) \\<inter> set (butlast (p\\<^sub>n @ ns)) = {}\n  var g \\<phi>' = V\n  \\<phi>' \\<in> allVars g\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\n  unnecessaryPhi g \\<phi>\n  \\<phi> \\<in> allVars g\n  \\<phi> \\<in> reachable g \\<phi>\n  var g r = V\n  var g s = V\n  var g \\<phi> = V\n  g \\<turnstile> n-p\\<^sub>n @ ns\\<rightarrow>defNode g \\<phi>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "by -(rule step.IH; blast)"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n            g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>';\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n            \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>'';\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n        \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n            g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>';\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n            \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>'';\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n        \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "case (step \\<phi>' \\<phi>\\<^sub>s)"], ["proof (state)\nthis:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>\\<^sub>s\n  unnecessaryPhi g \\<phi>\\<^sub>s\n  \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n   g \\<turnstile> m-?p\\<^sub>m1\\<rightarrow>defNode g \\<phi>';\n   g \\<turnstile> n-?p\\<^sub>n1\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n   set (butlast ?p\\<^sub>m1) \\<inter> set (butlast ?p\\<^sub>n1) = {};\n   var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n   \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n            g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>';\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n            \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>'';\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n        \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "txt \\<open>With the induction basis handled, we can finally move on to the induction proper.\\<close>"], ["proof (state)\nthis:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>\\<^sub>s\n  unnecessaryPhi g \\<phi>\\<^sub>s\n  \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n   g \\<turnstile> m-?p\\<^sub>m1\\<rightarrow>defNode g \\<phi>';\n   g \\<turnstile> n-?p\\<^sub>n1\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n   set (butlast ?p\\<^sub>m1) \\<inter> set (butlast ?p\\<^sub>n1) = {};\n   var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n   \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>' \\<phi>'' p\\<^sub>m p\\<^sub>n.\n       \\<lbrakk>\\<phi>' \\<in> reachable g \\<phi>;\n        \\<And>p\\<^sub>m p\\<^sub>n.\n           \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n            g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>';\n            g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n            set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n            var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n            \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n           \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                                \\<exists>ns ms.\n                                   old.pathsConverge g n ns m ms\n                                    (defNode g \\<phi>\\<^sub>z);\n        phiArg g \\<phi>' \\<phi>''; unnecessaryPhi g \\<phi>'';\n        \\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n        g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>'';\n        g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n        set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n        var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n        \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                            \\<exists>ns ms.\n                               old.pathsConverge g n ns m ms\n                                (defNode g \\<phi>\\<^sub>z)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "proof (cases \"set p\\<^sub>m \\<inter> set p\\<^sub>n = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. set p\\<^sub>m \\<inter> set p\\<^sub>n = {} \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n 2. set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {} \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "case True"], ["proof (state)\nthis:\n  set p\\<^sub>m \\<inter> set p\\<^sub>n = {}\n\ngoal (2 subgoals):\n 1. set p\\<^sub>m \\<inter> set p\\<^sub>n = {} \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n 2. set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {} \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "have \\<phi>\\<^sub>s_V: \"var g \\<phi>\\<^sub>s = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var g \\<phi>\\<^sub>s = V", "using step(1,2,3,9) reachable_same_var"], ["proof (prove)\nusing this:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>\\<^sub>s\n  unnecessaryPhi g \\<phi>\\<^sub>s\n  var g \\<phi> = V\n  ?\\<phi>' \\<in> reachable ?g ?\\<phi> \\<Longrightarrow>\n  var ?g ?\\<phi> = var ?g ?\\<phi>'\n\ngoal (1 subgoal):\n 1. var g \\<phi>\\<^sub>s = V", "by (simp add: phiArg_same_var)"], ["proof (state)\nthis:\n  var g \\<phi>\\<^sub>s = V\n\ngoal (2 subgoals):\n 1. set p\\<^sub>m \\<inter> set p\\<^sub>n = {} \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n 2. set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {} \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "from step(2)"], ["proof (chain)\npicking this:\n  phiArg g \\<phi>' \\<phi>\\<^sub>s", "have \\<phi>\\<^sub>s_allVars: \"\\<phi>\\<^sub>s \\<in> allVars g\""], ["proof (prove)\nusing this:\n  phiArg g \\<phi>' \\<phi>\\<^sub>s\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>s \\<in> allVars g", "by (rule phiArg_in_allVars)"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>s \\<in> allVars g\n\ngoal (2 subgoals):\n 1. set p\\<^sub>m \\<inter> set p\\<^sub>n = {} \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n 2. set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {} \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "obtain p\\<^sub>m' where tmp: \"g \\<turnstile> m -p\\<^sub>m@p\\<^sub>m'\\<rightarrow> defNode g \\<phi>'\" \"set (butlast (p\\<^sub>m@p\\<^sub>m')) \\<inter> set (butlast p\\<^sub>n) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p\\<^sub>m''.\n        \\<lbrakk>g \\<turnstile> m-p\\<^sub>m @\n                                  p\\<^sub>m''\\<rightarrow>defNode g \\<phi>';\n         set (butlast (p\\<^sub>m @ p\\<^sub>m'')) \\<inter>\n         set (butlast p\\<^sub>n) =\n         {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule phiArg_disjoint_paths_extend[of g \\<phi>\\<^sub>s V  \\<phi>\\<^sub>r m n p\\<^sub>m p\\<^sub>n \\<phi>'])\n            (metis \\<phi>\\<^sub>s_V \\<phi>\\<^sub>s_allVars step r_s_path_props(1,3) True disjoint_iff_not_equal in_set_butlastD)+"], ["proof (state)\nthis:\n  g \\<turnstile> m-p\\<^sub>m @ p\\<^sub>m'\\<rightarrow>defNode g \\<phi>'\n  set (butlast (p\\<^sub>m @ p\\<^sub>m')) \\<inter> set (butlast p\\<^sub>n) =\n  {}\n\ngoal (2 subgoals):\n 1. set p\\<^sub>m \\<inter> set p\\<^sub>n = {} \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n 2. set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {} \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "from step(5) this(1) step(7) this(2) step(9) step(10) step(11)"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m @ p\\<^sub>m'\\<rightarrow>defNode g \\<phi>'\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast (p\\<^sub>m @ p\\<^sub>m')) \\<inter> set (butlast p\\<^sub>n) =\n  {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m @ p\\<^sub>m'\\<rightarrow>defNode g \\<phi>'\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast (p\\<^sub>m @ p\\<^sub>m')) \\<inter> set (butlast p\\<^sub>n) =\n  {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "by (rule step.IH[of \"p\\<^sub>m@p\\<^sub>m'\" p\\<^sub>n])"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {} \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {} \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "case paths_cross: False"], ["proof (state)\nthis:\n  set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {} \\<Longrightarrow>\n    \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "with step reachable.intros"], ["proof (chain)\npicking this:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>\\<^sub>s\n  unnecessaryPhi g \\<phi>\\<^sub>s\n  \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n   g \\<turnstile> m-?p\\<^sub>m1\\<rightarrow>defNode g \\<phi>';\n   g \\<turnstile> n-?p\\<^sub>n1\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n   set (butlast ?p\\<^sub>m1) \\<inter> set (butlast ?p\\<^sub>n1) = {};\n   var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n   \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  unnecessaryPhi ?g ?\\<phi> \\<Longrightarrow>\n  ?\\<phi> \\<in> reachable ?g ?\\<phi>\n  \\<lbrakk>?\\<phi>' \\<in> reachable ?g ?\\<phi>;\n   phiArg ?g ?\\<phi>' ?\\<phi>''; unnecessaryPhi ?g ?\\<phi>''\\<rbrakk>\n  \\<Longrightarrow> ?\\<phi>'' \\<in> reachable ?g ?\\<phi>\n  set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>\\<^sub>s\n  unnecessaryPhi g \\<phi>\\<^sub>s\n  \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n   g \\<turnstile> m-?p\\<^sub>m1\\<rightarrow>defNode g \\<phi>';\n   g \\<turnstile> n-?p\\<^sub>n1\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n   set (butlast ?p\\<^sub>m1) \\<inter> set (butlast ?p\\<^sub>n1) = {};\n   var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n   \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  unnecessaryPhi ?g ?\\<phi> \\<Longrightarrow>\n  ?\\<phi> \\<in> reachable ?g ?\\<phi>\n  \\<lbrakk>?\\<phi>' \\<in> reachable ?g ?\\<phi>;\n   phiArg ?g ?\\<phi>' ?\\<phi>''; unnecessaryPhi ?g ?\\<phi>''\\<rbrakk>\n  \\<Longrightarrow> ?\\<phi>'' \\<in> reachable ?g ?\\<phi>\n  set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "using path_crossing_yields_convergence[of \\<phi>\\<^sub>r \\<phi>\\<^sub>s p\\<^sub>n p\\<^sub>m]"], ["proof (prove)\nusing this:\n  \\<phi>' \\<in> reachable g \\<phi>\n  phiArg g \\<phi>' \\<phi>\\<^sub>s\n  unnecessaryPhi g \\<phi>\\<^sub>s\n  \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n   g \\<turnstile> m-?p\\<^sub>m1\\<rightarrow>defNode g \\<phi>';\n   g \\<turnstile> n-?p\\<^sub>n1\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n   set (butlast ?p\\<^sub>m1) \\<inter> set (butlast ?p\\<^sub>n1) = {};\n   var g \\<phi> = V; var g \\<phi>\\<^sub>r = V;\n   \\<phi>\\<^sub>r \\<in> allVars g\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n  \\<phi>\\<^sub>r \\<in> reachable g \\<phi>\n  g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s\n  g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r\n  set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {}\n  var g \\<phi> = V\n  var g \\<phi>\\<^sub>r = V\n  \\<phi>\\<^sub>r \\<in> allVars g\n  unnecessaryPhi ?g ?\\<phi> \\<Longrightarrow>\n  ?\\<phi> \\<in> reachable ?g ?\\<phi>\n  \\<lbrakk>?\\<phi>' \\<in> reachable ?g ?\\<phi>;\n   phiArg ?g ?\\<phi>' ?\\<phi>''; unnecessaryPhi ?g ?\\<phi>''\\<rbrakk>\n  \\<Longrightarrow> ?\\<phi>'' \\<in> reachable ?g ?\\<phi>\n  set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {}\n  \\<lbrakk>\\<phi>\\<^sub>r \\<in> reachable g \\<phi>;\n   \\<phi>\\<^sub>s \\<in> reachable g \\<phi>;\n   g \\<turnstile> n-p\\<^sub>n\\<rightarrow>defNode g \\<phi>\\<^sub>r;\n   g \\<turnstile> m-p\\<^sub>m\\<rightarrow>defNode g \\<phi>\\<^sub>s;\n   set (butlast p\\<^sub>m) \\<inter> set (butlast p\\<^sub>n) = {};\n   set p\\<^sub>m \\<inter> set p\\<^sub>n \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n                       \\<exists>ns ms.\n                          old.pathsConverge g n ns m ms\n                           (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n       \\<exists>ns ms.\n          old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "obtain \\<phi>\\<^sub>z ns ms where \"\\<phi>\\<^sub>z \\<in> reachable g \\<phi>\" and \"old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<phi>\\<^sub>z\\<in>reachable g \\<phi>.\n     \\<exists>ns ms.\n        old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>\\<^sub>z ns ms.\n        \\<lbrakk>\\<phi>\\<^sub>z \\<in> reachable g \\<phi>;\n         old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>z \\<in> reachable g \\<phi>\n  old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>z \\<in> reachable g \\<phi>\n  old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "with reachable_props"], ["proof (chain)\npicking this:\n  ?\\<phi>' \\<in> reachable ?g ?\\<phi> \\<Longrightarrow>\n  (phiArg ?g)\\<^sup>*\\<^sup>* ?\\<phi> ?\\<phi>'\n  ?\\<phi>' \\<in> reachable ?g ?\\<phi> \\<Longrightarrow>\n  unnecessaryPhi ?g ?\\<phi>'\n  \\<phi>\\<^sub>z \\<in> reachable g \\<phi>\n  old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)", "have \"var g \\<phi>\\<^sub>z = V\""], ["proof (prove)\nusing this:\n  ?\\<phi>' \\<in> reachable ?g ?\\<phi> \\<Longrightarrow>\n  (phiArg ?g)\\<^sup>*\\<^sup>* ?\\<phi> ?\\<phi>'\n  ?\\<phi>' \\<in> reachable ?g ?\\<phi> \\<Longrightarrow>\n  unnecessaryPhi ?g ?\\<phi>'\n  \\<phi>\\<^sub>z \\<in> reachable g \\<phi>\n  old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n\ngoal (1 subgoal):\n 1. var g \\<phi>\\<^sub>z = V", "by (metis V_props(3) phiArg_trancl_same_var rtranclpD)"], ["proof (state)\nthis:\n  var g \\<phi>\\<^sub>z = V\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>z \\<in> reachable g \\<phi>\n  old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n  var g \\<phi>\\<^sub>z = V", "have \"necessaryPhi' g \\<phi>\\<^sub>z \""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>z \\<in> reachable g \\<phi>\n  old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n  var g \\<phi>\\<^sub>z = V\n\ngoal (1 subgoal):\n 1. necessaryPhi' g \\<phi>\\<^sub>z", "using r_s_path_props"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>z \\<in> reachable g \\<phi>\n  old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n  var g \\<phi>\\<^sub>z = V\n  V \\<in> oldDefs g n\n  g \\<turnstile> n-ns__\\<rightarrow>defNode g r\n  V \\<in> oldDefs g m\n  g \\<turnstile> m-ms__\\<rightarrow>defNode g s\n  set ns__ \\<inter> set ms__ = {}\n\ngoal (1 subgoal):\n 1. necessaryPhi' g \\<phi>\\<^sub>z", "unfolding necessaryPhi_def"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>z \\<in> reachable g \\<phi>\n  old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z)\n  var g \\<phi>\\<^sub>z = V\n  V \\<in> oldDefs g n\n  g \\<turnstile> n-ns__\\<rightarrow>defNode g r\n  V \\<in> oldDefs g m\n  g \\<turnstile> m-ms__\\<rightarrow>defNode g s\n  set ns__ \\<inter> set ms__ = {}\n\ngoal (1 subgoal):\n 1. \\<exists>n ns m ms.\n       old.pathsConverge g n ns m ms (defNode g \\<phi>\\<^sub>z) \\<and>\n       var g \\<phi>\\<^sub>z \\<in> oldDefs g n \\<and>\n       var g \\<phi>\\<^sub>z \\<in> oldDefs g m", "by blast"], ["proof (state)\nthis:\n  necessaryPhi' g \\<phi>\\<^sub>z\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  necessaryPhi' g \\<phi>\\<^sub>z\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "with \\<open>\\<phi>\\<^sub>z \\<in> reachable g \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>z \\<in> reachable g \\<phi>\n  necessaryPhi' g \\<phi>\\<^sub>z", "have \"unnecessaryPhi g \\<phi>\\<^sub>z\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>z \\<in> reachable g \\<phi>\n  necessaryPhi' g \\<phi>\\<^sub>z\n\ngoal (1 subgoal):\n 1. unnecessaryPhi g \\<phi>\\<^sub>z", "by -(rule reachable_props)"], ["proof (state)\nthis:\n  unnecessaryPhi g \\<phi>\\<^sub>z\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (trueArgs g \\<phi>) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  necessaryPhi' g \\<phi>\\<^sub>z\n  unnecessaryPhi g \\<phi>\\<^sub>z", "show False"], ["proof (prove)\nusing this:\n  necessaryPhi' g \\<phi>\\<^sub>z\n  unnecessaryPhi g \\<phi>\\<^sub>z\n\ngoal (1 subgoal):\n 1. False", "unfolding unnecessaryPhi_def"], ["proof (prove)\nusing this:\n  necessaryPhi' g \\<phi>\\<^sub>z\n  phi g \\<phi>\\<^sub>z \\<noteq> None \\<and>\n  \\<not> necessaryPhi' g \\<phi>\\<^sub>z\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "txt \\<open>Together with lemma 1, we thus have that a CFG without redundant SCCs is cytron-minimal, proving that the\n     property established by Braun et al.'s algorithm suffices.\\<close>"], ["", "corollary no_redundant_SCC_minimal:\nassumes \"\\<not>(\\<exists>P scc. redundant_scc g P scc)\"\nshows \"cytronMinimal g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cytronMinimal g", "using assms 1 no_redundant_set_minimal"], ["proof (prove)\nusing this:\n  \\<nexists>P scc. redundant_scc g P scc\n  redundant_set ?g ?P \\<Longrightarrow>\n  \\<exists>scc\\<subseteq>?P. redundant_scc ?g ?P scc\n  \\<nexists>P. redundant_set ?g P \\<Longrightarrow> cytronMinimal ?g\n\ngoal (1 subgoal):\n 1. cytronMinimal g", "by blast"], ["", "txt \\<open>Finally, to conclude, we'll show that the above theorem is indeed a stronger assertion about a graph\n     than the lack of trivial \\pf s. Intuitively, this is because a set containing only a\n     trivial \\pf\\ is a redundant set.\\<close>"], ["", "corollary\nassumes \"\\<not>(\\<exists>P. redundant_set g P)\"\nshows \"\\<not>redundant g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> redundant g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> redundant g", "have \"redundant g \\<Longrightarrow> \\<exists>P. redundant_set g P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant g \\<Longrightarrow> \\<exists>P. redundant_set g P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. redundant g \\<Longrightarrow> \\<exists>P. redundant_set g P", "assume \"redundant g\""], ["proof (state)\nthis:\n  redundant g\n\ngoal (1 subgoal):\n 1. redundant g \\<Longrightarrow> \\<exists>P. redundant_set g P", "then"], ["proof (chain)\npicking this:\n  redundant g", "obtain \\<phi> where \"phi g \\<phi> \\<noteq> None\" \"trivial g \\<phi>\""], ["proof (prove)\nusing this:\n  redundant g\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>phi g \\<phi> \\<noteq> None; trivial g \\<phi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_def redundant_set_def dom_def phiArg_def trivial_def isTrivialPhi_def"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>allVars g.\n     \\<exists>v'\\<in>allVars g.\n        v' \\<noteq> v \\<and>\n        (case phi g v of None \\<Rightarrow> False\n         | Some vs \\<Rightarrow> set vs = {v, v'} \\<or> set vs = {v'})\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>phi g \\<phi> \\<noteq> None;\n         \\<exists>v'\\<in>allVars g.\n            v' \\<noteq> \\<phi> \\<and>\n            (case phi g \\<phi> of None \\<Rightarrow> False\n             | Some vs \\<Rightarrow>\n                 set vs = {\\<phi>, v'} \\<or> set vs = {v'})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp split: option.splits) fastforce"], ["proof (state)\nthis:\n  phi g \\<phi> \\<noteq> None\n  trivial g \\<phi>\n\ngoal (1 subgoal):\n 1. redundant g \\<Longrightarrow> \\<exists>P. redundant_set g P", "hence \"redundant_set g {\\<phi>}\""], ["proof (prove)\nusing this:\n  phi g \\<phi> \\<noteq> None\n  trivial g \\<phi>\n\ngoal (1 subgoal):\n 1. redundant_set g {\\<phi>}", "unfolding redundant_set_def dom_def phiArg_def trivial_def isTrivialPhi_def"], ["proof (prove)\nusing this:\n  phi g \\<phi> \\<noteq> None\n  \\<exists>v'\\<in>allVars g.\n     v' \\<noteq> \\<phi> \\<and>\n     (case phi g \\<phi> of None \\<Rightarrow> False\n      | Some vs \\<Rightarrow> set vs = {\\<phi>, v'} \\<or> set vs = {v'})\n\ngoal (1 subgoal):\n 1. {\\<phi>} \\<noteq> {} \\<and>\n    {\\<phi>} \\<subseteq> {a. phi g a \\<noteq> None} \\<and>\n    (\\<exists>v'\\<in>allVars g.\n        \\<forall>\\<phi>'\\<in>{\\<phi>}.\n           \\<forall>\\<phi>''.\n              (\\<exists>vs.\n                  phi g \\<phi>' = Some vs \\<and>\n                  \\<phi>'' \\<in> set vs) \\<longrightarrow>\n              \\<phi>'' \\<in> {\\<phi>} \\<union> {v'})", "by auto"], ["proof (state)\nthis:\n  redundant_set g {\\<phi>}\n\ngoal (1 subgoal):\n 1. redundant g \\<Longrightarrow> \\<exists>P. redundant_set g P", "thus ?thesis"], ["proof (prove)\nusing this:\n  redundant_set g {\\<phi>}\n\ngoal (1 subgoal):\n 1. \\<exists>P. redundant_set g P", "by auto"], ["proof (state)\nthis:\n  \\<exists>P. redundant_set g P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  redundant g \\<Longrightarrow> \\<exists>P. redundant_set g P\n\ngoal (1 subgoal):\n 1. \\<not> redundant g", "with assms"], ["proof (chain)\npicking this:\n  \\<nexists>P. redundant_set g P\n  redundant g \\<Longrightarrow> \\<exists>P. redundant_set g P", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>P. redundant_set g P\n  redundant g \\<Longrightarrow> \\<exists>P. redundant_set g P\n\ngoal (1 subgoal):\n 1. \\<not> redundant g", "by auto"], ["proof (state)\nthis:\n  \\<not> redundant g\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}