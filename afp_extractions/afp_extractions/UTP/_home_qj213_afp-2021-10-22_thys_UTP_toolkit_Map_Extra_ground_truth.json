{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/toolkit/Map_Extra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["lemma functional_insert [simp]: \"functional (insert (x,y) g) \\<longleftrightarrow> (g``{x} \\<subseteq> {y} \\<and> functional g)\"", "lemma functional_list_nil[simp]: \"functional_list []\"", "lemma functional_list: \"functional_list xs \\<longleftrightarrow> functional (set xs)\"", "lemma map_graph_mem_equiv: \"(x, y) \\<in> map_graph f \\<longleftrightarrow> f(x) = Some y\"", "lemma map_graph_functional[simp]: \"functional (map_graph f)\"", "lemma map_graph_countable [simp]: \"countable (dom f) \\<Longrightarrow> countable (map_graph f)\"", "lemma map_graph_inv [simp]: \"graph_map (map_graph f) = f\"", "lemma graph_map_empty[simp]: \"graph_map {} = Map.empty\"", "lemma graph_map_insert [simp]: \"\\<lbrakk>functional g; g``{x} \\<subseteq> {y}\\<rbrakk> \\<Longrightarrow> graph_map (insert (x,y) g) = (graph_map g)(x \\<mapsto> y)\"", "lemma dom_map_graph: \"dom f = Domain(map_graph f)\"", "lemma ran_map_graph: \"ran f = Range(map_graph f)\"", "lemma ran_map_add_subset:\n  \"ran (x ++ y) \\<subseteq> (ran x) \\<union> (ran y)\"", "lemma finite_dom_graph: \"finite (dom f) \\<Longrightarrow> finite (map_graph f)\"", "lemma finite_dom_ran [simp]: \"finite (dom f) \\<Longrightarrow> finite (ran f)\"", "lemma graph_map_inv [simp]: \"functional g \\<Longrightarrow> map_graph (graph_map g) = g\"", "lemma graph_map_dom: \"dom (graph_map R) = fst ` R\"", "lemma graph_map_countable_dom: \"countable R \\<Longrightarrow> countable (dom (graph_map R))\"", "lemma countable_ran:\n  assumes \"countable (dom f)\"\n  shows \"countable (ran f)\"", "lemma map_graph_inv' [simp]:\n  \"graph_map' (map_graph f) = Some f\"", "lemma map_graph_inj:\n  \"inj map_graph\"", "lemma map_eq_graph: \"f = g \\<longleftrightarrow> map_graph f = map_graph g\"", "lemma map_le_graph: \"f \\<subseteq>\\<^sub>m g \\<longleftrightarrow> map_graph f \\<subseteq> map_graph g\"", "lemma map_graph_comp: \"map_graph (g \\<circ>\\<^sub>m f) = (map_graph f) O (map_graph g)\"", "lemma map_ext:\n  \"\\<lbrakk> \\<And> x y. (x, y) \\<in>\\<^sub>m A \\<longleftrightarrow> (x, y) \\<in>\\<^sub>m B \\<rbrakk> \\<Longrightarrow> A = B\"", "lemma map_member_alt_def:\n  \"(x, y) \\<in>\\<^sub>m A \\<longleftrightarrow> (x \\<in> dom A \\<and> A(x)\\<^sub>m = y)\"", "lemma map_le_member:\n  \"f \\<subseteq>\\<^sub>m g \\<longleftrightarrow> (\\<forall> x y. (x,y) \\<in>\\<^sub>m f \\<longrightarrow> (x,y) \\<in>\\<^sub>m g)\"", "lemma preimage_range: \"preimage f (ran f) = dom f\"", "lemma dom_preimage: \"dom (m \\<circ>\\<^sub>m f) = preimage f (dom m)\"", "lemma countable_preimage:\n  \"\\<lbrakk> countable A; inj_on f (preimage f A) \\<rbrakk> \\<Longrightarrow> countable (preimage f A)\"", "lemma map_minus_apply [simp]: \"y \\<in> dom(f -- g) \\<Longrightarrow> (f -- g)(y)\\<^sub>m = f(y)\\<^sub>m\"", "lemma map_member_plus:\n  \"(x, y) \\<in>\\<^sub>m f ++ g \\<longleftrightarrow> ((x \\<notin> dom(g) \\<and> (x, y) \\<in>\\<^sub>m f) \\<or> (x, y) \\<in>\\<^sub>m g)\"", "lemma map_member_minus:\n  \"(x, y) \\<in>\\<^sub>m f -- g \\<longleftrightarrow> (x, y) \\<in>\\<^sub>m f \\<and> (\\<not> (x, y) \\<in>\\<^sub>m g)\"", "lemma map_minus_plus_commute:\n  \"dom(g) \\<inter> dom(h) = {} \\<Longrightarrow> (f -- g) ++ h = (f ++ h) -- g\"", "lemma map_graph_minus: \"map_graph (f -- g) = map_graph f - map_graph g\"", "lemma map_minus_common_subset:\n  \"\\<lbrakk> h \\<subseteq>\\<^sub>m f; h \\<subseteq>\\<^sub>m g \\<rbrakk> \\<Longrightarrow> (f -- h = g -- h) = (f = g)\"", "lemma option_bindSomeE [elim!]:\n  \"\\<lbrakk> X >>= F = Some(v); \\<And> x. \\<lbrakk> X = Some(x); F(x) = Some(v) \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma option_bindSomeI [intro]:\n  \"\\<lbrakk> X = Some(x); F(x) = Some(y) \\<rbrakk> \\<Longrightarrow> X >>= F = Some(y)\"", "lemma ifSomeE [elim]: \"\\<lbrakk> (if c then Some(x) else None) = Some(y); \\<lbrakk> c; x = y \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma ran_restrict_empty [simp]: \"f\\<upharpoonleft>\\<^bsub>{}\\<^esub> = Map.empty\"", "lemma ran_restrict_ran [simp]: \"f\\<upharpoonleft>\\<^bsub>ran(f) \\<^esub> = f\"", "lemma ran_ran_restrict [simp]: \"ran(f\\<upharpoonleft>\\<^bsub>B\\<^esub>) = ran(f) \\<inter> B\"", "lemma dom_ran_restrict: \"dom(f\\<upharpoonleft>\\<^bsub>B\\<^esub>) \\<subseteq> dom(f)\"", "lemma ran_restrict_finite_dom [intro]:\n  \"finite(dom(f)) \\<Longrightarrow> finite(dom(f\\<upharpoonleft>\\<^bsub>B\\<^esub>))\"", "lemma dom_Some [simp]: \"dom (Some \\<circ> f) = UNIV\"", "lemma dom_left_map_add [simp]: \"x \\<in> dom g \\<Longrightarrow> (f ++ g) x = g x\"", "lemma dom_right_map_add [simp]: \"\\<lbrakk> x \\<notin> dom g; x \\<in> dom f \\<rbrakk> \\<Longrightarrow> (f ++ g) x = f x\"", "lemma map_add_restrict:\n  \"f ++ g = (f |` (- dom g)) ++ g\"", "lemma map_id_on_in [simp]:\n  \"x \\<in> xs \\<Longrightarrow> map_id_on xs x = Some x\"", "lemma map_id_on_out [simp]:\n  \"x \\<notin> xs \\<Longrightarrow> map_id_on xs x = None\"", "lemma map_id_dom [simp]: \"dom (map_id_on xs) = xs\"", "lemma map_id_ran [simp]: \"ran (map_id_on xs) = xs\"", "lemma map_id_on_UNIV[simp]: \"map_id_on UNIV = Some\"", "lemma map_id_on_inj [simp]:\n  \"inj_on (map_id_on xs) xs\"", "lemma map_inv_empty [simp]: \"map_inv Map.empty = Map.empty\"", "lemma map_inv_id [simp]:\n  \"map_inv (map_id_on xs) = map_id_on xs\"", "lemma map_inv_Some [simp]: \"map_inv Some = Some\"", "lemma map_inv_f_f [simp]:\n  \"\\<lbrakk> inj_on f (dom f); f x = Some y \\<rbrakk> \\<Longrightarrow> map_inv f y = Some x\"", "lemma dom_map_inv [simp]:\n  \"dom (map_inv f) = ran f\"", "lemma ran_map_inv [simp]:\n  \"inj_on f (dom f) \\<Longrightarrow> ran (map_inv f) = dom f\"", "lemma dom_image_ran: \"f ` dom f = Some ` ran f\"", "lemma inj_map_inv [intro]:\n  \"inj_on f (dom f) \\<Longrightarrow> inj_on (map_inv f) (ran f)\"", "lemma inj_map_bij: \"inj_on f (dom f) \\<Longrightarrow> bij_betw f (dom f) (Some ` ran f)\"", "lemma map_inv_map_inv [simp]:\n  assumes \"inj_on f (dom f)\"\n  shows \"map_inv (map_inv f) = f\"", "lemma map_self_adjoin_complete [intro]:\n  assumes \"dom f \\<inter> ran f = {}\" \"inj_on f (dom f)\"\n  shows \"inj_on (map_inv f ++ f) (dom f \\<union> ran f)\"", "lemma inj_completed_map [intro]:\n  \"\\<lbrakk> dom f = ran f; inj_on f (dom f) \\<rbrakk> \\<Longrightarrow> inj (Some ++ f)\"", "lemma bij_completed_map [intro]:\n  \"\\<lbrakk> dom f = ran f; inj_on f (dom f) \\<rbrakk> \\<Longrightarrow>\n   bij_betw (Some ++ f) UNIV (range Some)\"", "lemma bij_map_Some:\n  \"bij_betw f a (Some ` b) \\<Longrightarrow> bij_betw (the \\<circ> f) a b\"", "lemma ran_map_add [simp]:\n  \"m`(dom m \\<inter> dom n) = n`(dom m \\<inter> dom n) \\<Longrightarrow>\n   ran(m++n) = ran n \\<union> ran m\"", "lemma ran_maplets [simp]:\n  \"\\<lbrakk> length xs = length ys; distinct xs \\<rbrakk> \\<Longrightarrow> ran [xs [\\<mapsto>] ys] = set ys\"", "lemma inj_map_add:\n  \"\\<lbrakk> inj_on f (dom f); inj_on g (dom g); ran f \\<inter> ran g = {} \\<rbrakk> \\<Longrightarrow>\n   inj_on (f ++ g) (dom f \\<union> dom g)\"", "lemma map_inv_add [simp]:\n  assumes \"inj_on f (dom f)\" \"inj_on g (dom g)\"\n          \"dom f \\<inter> dom g = {}\" \"ran f \\<inter> ran g = {}\"\n  shows \"map_inv (f ++ g) = map_inv f ++ map_inv g\"", "lemma map_add_lookup [simp]:\n  \"x \\<notin> dom f \\<Longrightarrow> ([x \\<mapsto> y] ++ f) x = Some y\"", "lemma map_add_Some: \"Some ++ f = map_id_on (- dom f) ++ f\"", "lemma distinct_map_dom:\n  \"x \\<notin> set xs \\<Longrightarrow> x \\<notin> dom [xs [\\<mapsto>] ys]\"", "lemma distinct_map_ran:\n  \"\\<lbrakk> distinct xs; y \\<notin> set ys; length xs = length ys \\<rbrakk> \\<Longrightarrow>\n   y \\<notin> ran ([xs [\\<mapsto>] ys])\"", "lemma maplets_lookup[rule_format,dest]:\n  \"\\<lbrakk> length xs = length ys; distinct xs \\<rbrakk> \\<Longrightarrow>\n     \\<forall> y. [xs [\\<mapsto>] ys] x = Some y \\<longrightarrow> y \\<in> set ys\"", "lemma maplets_distinct_inj [intro]:\n  \"\\<lbrakk> length xs = length ys; distinct xs; distinct ys; set xs \\<inter> set ys = {} \\<rbrakk> \\<Longrightarrow>\n   inj_on [xs [\\<mapsto>] ys] (set xs)\"", "lemma map_inv_maplet[simp]: \"map_inv [x \\<mapsto> y] = [y \\<mapsto> x]\"", "lemma map_inv_maplets [simp]:\n  \"\\<lbrakk> length xs = length ys; distinct xs; distinct ys; set xs \\<inter> set ys = {} \\<rbrakk> \\<Longrightarrow>\n  map_inv [xs [\\<mapsto>] ys] = [ys [\\<mapsto>] xs]\"", "lemma maplets_lookup_nth [rule_format,simp]:\n  \"\\<lbrakk> length xs = length ys; distinct xs \\<rbrakk> \\<Longrightarrow>\n   \\<forall> i < length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i)\"", "theorem inv_map_inv:\n  \"\\<lbrakk> inj_on f (dom f); ran f = dom f \\<rbrakk>\n  \\<Longrightarrow> inv (the \\<circ> (Some ++ f)) = the \\<circ> map_inv (Some ++ f)\"", "lemma map_comp_dom: \"dom (g \\<circ>\\<^sub>m f) \\<subseteq> dom f\"", "lemma map_comp_assoc: \"f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h) = f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h\"", "lemma map_comp_runit [simp]: \"f \\<circ>\\<^sub>m Some = f\"", "lemma map_comp_lunit [simp]: \"Some \\<circ>\\<^sub>m f = f\"", "lemma map_comp_apply [simp]: \"(f \\<circ>\\<^sub>m g) x = g(x) >>= f\"", "lemma comp_map_unit: \"Map.empty \\<parallel>\\<^sub>m f\"", "lemma comp_map_refl: \"f \\<parallel>\\<^sub>m f\"", "lemma comp_map_sym: \"f \\<parallel>\\<^sub>m g \\<Longrightarrow> g \\<parallel>\\<^sub>m f\"", "lemma merge_empty: \"merge {} = Map.empty\"", "lemma merge_singleton: \"merge {f} = f\"", "lemma map_of_list_nil [simp]: \"map_of_list [] = Map.empty\"", "lemma dom_map_of_list [simp]: \"dom (map_of_list xs) = {0..<length xs}\"", "lemma ran_map_of_list [simp]: \"ran (map_of_list xs) = set xs\"", "lemma list_of_map_empty [simp]: \"list_of_map Map.empty = []\"", "lemma map_of_list_inv [simp]: \"list_of_map (map_of_list xs) = xs\"", "lemma map_compr_eta:\n  \"[x \\<mapsto> y | x y. (x, y) \\<in>\\<^sub>m f] = f\"", "lemma map_compr_simple:\n  \"[x \\<mapsto> F x y | x y. (x, y) \\<in>\\<^sub>m f] = (\\<lambda> x. do { y \\<leftarrow> f(x); Some(F x y) })\"", "lemma map_compr_dom_simple [simp]:\n  \"dom [x \\<mapsto> f x | x. P x] = {x. P x}\"", "lemma map_compr_ran_simple [simp]:\n  \"ran [x \\<mapsto> f x | x. P x] = {f x | x. P x}\"", "lemma map_compr_eval_simple [simp]:\n  \"[x \\<mapsto> f x | x. P x] x = (if (P x) then Some (f x) else None)\"", "lemma sorted_list_of_map_empty [simp]:\n  \"sorted_list_of_map Map.empty = []\"", "lemma sorted_list_of_map_inv:\n  assumes \"finite(dom(f))\"\n  shows \"map_of (sorted_list_of_map f) = f\"", "lemma map_eqI:\n  \"\\<lbrakk> dom f = dom g; \\<forall> x\\<in>dom(f). the(f x) = the(g x) \\<rbrakk> \\<Longrightarrow> f = g\"", "lemma map_restrict_dom [simp]: \"f |` dom f = f\"", "lemma map_restrict_dom_compl: \"f |` (- dom f) = Map.empty\"", "lemma restrict_map_neg_disj:\n  \"dom(f) \\<inter> A = {} \\<Longrightarrow> f |` (- A) = f\"", "lemma map_plus_restrict_dist: \"(f ++ g) |` A = (f |` A) ++ (g |` A)\"", "lemma map_plus_eq_left:\n  assumes \"f ++ h = g ++ h\"\n  shows \"(f |` (- dom h)) = (g |` (- dom h))\"", "lemma map_add_split:\n  \"dom(f) = A \\<union> B \\<Longrightarrow> (f |` A) ++ (f |` B) = f\"", "lemma map_le_via_restrict:\n  \"f \\<subseteq>\\<^sub>m g \\<longleftrightarrow> g |` dom(f) = f\"", "lemma map_add_cancel:\n  \"f \\<subseteq>\\<^sub>m g \\<Longrightarrow> f ++ (g -- f) = g\"", "lemma map_le_iff_add: \"f \\<subseteq>\\<^sub>m g \\<longleftrightarrow> (\\<exists> h. dom(f) \\<inter> dom(h) = {} \\<and> f ++ h = g)\"", "lemma map_add_comm_weak: \"(\\<forall> k \\<in> dom m1 \\<inter> dom m2. m1(k) = m2(k)) \\<Longrightarrow> m1 ++ m2 = m2 ++ m1\""], "translations": [["", "lemma functional_insert [simp]: \"functional (insert (x,y) g) \\<longleftrightarrow> (g``{x} \\<subseteq> {y} \\<and> functional g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functional (insert (x, y) g) =\n    (g `` {x} \\<subseteq> {y} \\<and> functional g)", "by (auto simp add:functional_def inj_on_def image_def)"], ["", "lemma functional_list_nil[simp]: \"functional_list []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functional_list []", "by (simp add:functional_list_def ListMem_iff)"], ["", "lemma functional_list: \"functional_list xs \\<longleftrightarrow> functional (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functional_list xs = functional (set xs)", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. functional_list [] = functional (set [])\n 2. \\<And>a xs.\n       functional_list xs = functional (set xs) \\<Longrightarrow>\n       functional_list (a # xs) = functional (set (a # xs))", "apply (simp add:functional_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       functional_list xs = functional (set xs) \\<Longrightarrow>\n       functional_list (a # xs) = functional (set (a # xs))", "apply (simp add:functional_def functional_list_def ListMem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       (\\<forall>x y z.\n           (x, y) \\<in> set xs \\<and> (x, z) \\<in> set xs \\<longrightarrow>\n           y = z) =\n       inj_on fst (set xs) \\<Longrightarrow>\n       (\\<forall>x y z.\n           ((x, y) = a \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = a \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z) =\n       (inj_on fst (set xs) \\<and> fst a \\<notin> fst ` (set xs - {a}))", "apply (safe)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a b xs aa ba.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs);\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> aa = a\n 2. \\<And>a b xs aa ba.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs);\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> ba = b\n 3. \\<And>a b xs x y z.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs); inj_on fst (set xs);\n        fst (a, b) \\<notin> fst ` (set xs - {(a, b)});\n        (a, z) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> b = z\n 4. \\<And>a b xs x y z.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs); inj_on fst (set xs);\n        fst (a, b) \\<notin> fst ` (set xs - {(a, b)});\n        (a, y) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> y = b\n 5. \\<And>a b xs x y z.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs); inj_on fst (set xs);\n        fst (a, b) \\<notin> fst ` (set xs - {(a, b)}); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> y = z\n 6. \\<And>a b xs x y z.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z\\<rbrakk>\n       \\<Longrightarrow> inj_on fst (set xs)\n 7. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> aa = a\n 8. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> ba = b", "apply (force)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b xs aa ba.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs);\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> ba = b\n 2. \\<And>a b xs x y z.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs); inj_on fst (set xs);\n        fst (a, b) \\<notin> fst ` (set xs - {(a, b)});\n        (a, z) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> b = z\n 3. \\<And>a b xs x y z.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs); inj_on fst (set xs);\n        fst (a, b) \\<notin> fst ` (set xs - {(a, b)});\n        (a, y) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> y = b\n 4. \\<And>a b xs x y z.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs); inj_on fst (set xs);\n        fst (a, b) \\<notin> fst ` (set xs - {(a, b)}); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> y = z\n 5. \\<And>a b xs x y z.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z\\<rbrakk>\n       \\<Longrightarrow> inj_on fst (set xs)\n 6. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> aa = a\n 7. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> ba = b", "apply (force)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b xs x y z.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs); inj_on fst (set xs);\n        fst (a, b) \\<notin> fst ` (set xs - {(a, b)});\n        (a, z) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> b = z\n 2. \\<And>a b xs x y z.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs); inj_on fst (set xs);\n        fst (a, b) \\<notin> fst ` (set xs - {(a, b)});\n        (a, y) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> y = b\n 3. \\<And>a b xs x y z.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs); inj_on fst (set xs);\n        fst (a, b) \\<notin> fst ` (set xs - {(a, b)}); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> y = z\n 4. \\<And>a b xs x y z.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z\\<rbrakk>\n       \\<Longrightarrow> inj_on fst (set xs)\n 5. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> aa = a\n 6. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> ba = b", "apply (force)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b xs x y z.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs); inj_on fst (set xs);\n        fst (a, b) \\<notin> fst ` (set xs - {(a, b)});\n        (a, y) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> y = b\n 2. \\<And>a b xs x y z.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs); inj_on fst (set xs);\n        fst (a, b) \\<notin> fst ` (set xs - {(a, b)}); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> y = z\n 3. \\<And>a b xs x y z.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z\\<rbrakk>\n       \\<Longrightarrow> inj_on fst (set xs)\n 4. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> aa = a\n 5. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> ba = b", "apply (force)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b xs x y z.\n       \\<lbrakk>\\<forall>x y z.\n                   (x, y) \\<in> set xs \\<and>\n                   (x, z) \\<in> set xs \\<longrightarrow>\n                   y = z;\n        inj_on fst (set xs); inj_on fst (set xs);\n        fst (a, b) \\<notin> fst ` (set xs - {(a, b)}); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>a b xs x y z.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z\\<rbrakk>\n       \\<Longrightarrow> inj_on fst (set xs)\n 3. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> aa = a\n 4. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> ba = b", "apply (force)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b xs x y z.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z\\<rbrakk>\n       \\<Longrightarrow> inj_on fst (set xs)\n 2. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> aa = a\n 3. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> ba = b", "apply (force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> aa = a\n 2. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> ba = b", "apply (force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b xs x y z aa ba.\n       \\<lbrakk>\\<not> inj_on fst (set xs); (x, y) \\<in> set xs;\n        (x, z) \\<in> set xs; y \\<noteq> z;\n        \\<forall>x y z.\n           ((x, y) = (a, b) \\<or> (x, y) \\<in> set xs) \\<and>\n           ((x, z) = (a, b) \\<or> (x, z) \\<in> set xs) \\<longrightarrow>\n           y = z;\n        fst (a, b) = fst (aa, ba); (aa, ba) \\<in> set xs; \\<not> False;\n        (aa, ba) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> ba = b", "apply (force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open> Graphing Maps \\<close>"], ["", "definition map_graph :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> ('a * 'b) set\" where\n\"map_graph f = {(x,y) | x y. f x = Some y}\""], ["", "definition graph_map :: \"('a * 'b) set \\<Rightarrow> ('a \\<rightharpoonup> 'b)\" where\n\"graph_map g = (\\<lambda> x. if (x \\<in> fst ` g) then Some (SOME y. (x,y) \\<in> g) else None)\""], ["", "definition graph_map' :: \"('a \\<times> 'b) set \\<rightharpoonup> ('a \\<rightharpoonup> 'b)\" where\n\"graph_map' R = (if (functional R) then Some (graph_map R) else None)\""], ["", "lemma map_graph_mem_equiv: \"(x, y) \\<in> map_graph f \\<longleftrightarrow> f(x) = Some y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> map_graph f) = (f x = Some y)", "by (simp add: map_graph_def)"], ["", "lemma map_graph_functional[simp]: \"functional (map_graph f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functional (map_graph f)", "by (simp add:functional_def map_graph_def inj_on_def)"], ["", "lemma map_graph_countable [simp]: \"countable (dom f) \\<Longrightarrow> countable (map_graph f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (dom f) \\<Longrightarrow> countable (map_graph f)", "apply (auto simp add:map_graph_def countable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       inj_on fa (dom f) \\<Longrightarrow>\n       \\<exists>fa. inj_on fa {(x, y). f x = Some y}", "apply (rename_tac f')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f'.\n       inj_on f' (dom f) \\<Longrightarrow>\n       \\<exists>fa. inj_on fa {(x, y). f x = Some y}", "apply (rule_tac x=\"f' \\<circ> fst\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f'.\n       inj_on f' (dom f) \\<Longrightarrow>\n       inj_on (f' \\<circ> fst) {(x, y). f x = Some y}", "apply (auto simp add:inj_on_def dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f' a b aa ba.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>y. f x = Some y) \\<longrightarrow>\n                   (\\<forall>y.\n                       (\\<exists>ya. f y = Some ya) \\<longrightarrow>\n                       f' x = f' y \\<longrightarrow> x = y);\n        f a = Some b; f aa = Some ba; f' a = f' aa\\<rbrakk>\n       \\<Longrightarrow> b = ba", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_graph_inv [simp]: \"graph_map (map_graph f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_map (map_graph f) = f", "by (auto intro!:ext simp add:map_graph_def graph_map_def image_def)"], ["", "lemma graph_map_empty[simp]: \"graph_map {} = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_map {} = Map.empty", "by (simp add:graph_map_def)"], ["", "lemma graph_map_insert [simp]: \"\\<lbrakk>functional g; g``{x} \\<subseteq> {y}\\<rbrakk> \\<Longrightarrow> graph_map (insert (x,y) g) = (graph_map g)(x \\<mapsto> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>functional g; g `` {x} \\<subseteq> {y}\\<rbrakk>\n    \\<Longrightarrow> graph_map (insert (x, y) g) = graph_map g(x \\<mapsto>\n                      y)", "by (rule ext, auto simp add:graph_map_def)"], ["", "lemma dom_map_graph: \"dom f = Domain(map_graph f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom f = Domain (map_graph f)", "by (simp add: map_graph_def dom_def image_def)"], ["", "lemma ran_map_graph: \"ran f = Range(map_graph f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran f = Range (map_graph f)", "by (simp add: map_graph_def ran_def image_def)"], ["", "lemma ran_map_add_subset:\n  \"ran (x ++ y) \\<subseteq> (ran x) \\<union> (ran y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (x ++ y) \\<subseteq> ran x \\<union> ran y", "by (auto simp add:ran_def)"], ["", "lemma finite_dom_graph: \"finite (dom f) \\<Longrightarrow> finite (map_graph f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom f) \\<Longrightarrow> finite (map_graph f)", "by (metis dom_map_graph finite_imageD fst_eq_Domain functional_def map_graph_functional)"], ["", "lemma finite_dom_ran [simp]: \"finite (dom f) \\<Longrightarrow> finite (ran f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom f) \\<Longrightarrow> finite (ran f)", "by (metis finite_Range finite_dom_graph ran_map_graph)"], ["", "lemma graph_map_inv [simp]: \"functional g \\<Longrightarrow> map_graph (graph_map g) = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functional g \\<Longrightarrow> map_graph (graph_map g) = g", "apply (auto simp add:map_graph_def graph_map_def functional_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>inj_on fst g;\n        (if a \\<in> fst ` g then Some (SOME y. (a, y) \\<in> g) else None) =\n        Some b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> g\n 2. \\<And>b aa ba.\n       \\<lbrakk>inj_on fst g; (aa, b) \\<in> g; (aa, ba) \\<in> g\\<rbrakk>\n       \\<Longrightarrow> (SOME y. (aa, y) \\<in> g) = b\n 3. \\<And>a b.\n       \\<lbrakk>inj_on fst g; (a, b) \\<in> g\\<rbrakk>\n       \\<Longrightarrow> a \\<in> fst ` g", "apply (metis (lifting, no_types) image_iff option.distinct(1) option.inject someI surjective_pairing)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b aa ba.\n       \\<lbrakk>inj_on fst g; (aa, b) \\<in> g; (aa, ba) \\<in> g\\<rbrakk>\n       \\<Longrightarrow> (SOME y. (aa, y) \\<in> g) = b\n 2. \\<And>a b.\n       \\<lbrakk>inj_on fst g; (a, b) \\<in> g\\<rbrakk>\n       \\<Longrightarrow> a \\<in> fst ` g", "apply (simp add:inj_on_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b aa ba.\n       \\<lbrakk>\\<forall>x\\<in>g.\n                   \\<forall>y\\<in>g. fst x = fst y \\<longrightarrow> x = y;\n        (aa, b) \\<in> g; (aa, ba) \\<in> g\\<rbrakk>\n       \\<Longrightarrow> (SOME y. (aa, y) \\<in> g) = b\n 2. \\<And>a b.\n       \\<lbrakk>inj_on fst g; (a, b) \\<in> g\\<rbrakk>\n       \\<Longrightarrow> a \\<in> fst ` g", "apply (metis fst_conv snd_conv some_equality)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>inj_on fst g; (a, b) \\<in> g\\<rbrakk>\n       \\<Longrightarrow> a \\<in> fst ` g", "apply (metis (lifting) fst_conv image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma graph_map_dom: \"dom (graph_map R) = fst ` R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (graph_map R) = fst ` R", "by (simp add: graph_map_def dom_def)"], ["", "lemma graph_map_countable_dom: \"countable R \\<Longrightarrow> countable (dom (graph_map R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable R \\<Longrightarrow> countable (dom (graph_map R))", "by (simp add: graph_map_dom)"], ["", "lemma countable_ran:\n  assumes \"countable (dom f)\"\n  shows \"countable (ran f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (ran f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (ran f)", "have \"countable (map_graph f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (map_graph f)", "by (simp add: assms)"], ["proof (state)\nthis:\n  countable (map_graph f)\n\ngoal (1 subgoal):\n 1. countable (ran f)", "then"], ["proof (chain)\npicking this:\n  countable (map_graph f)", "have \"countable (Range(map_graph f))\""], ["proof (prove)\nusing this:\n  countable (map_graph f)\n\ngoal (1 subgoal):\n 1. countable (Range (map_graph f))", "by (simp add: Range_snd)"], ["proof (state)\nthis:\n  countable (Range (map_graph f))\n\ngoal (1 subgoal):\n 1. countable (ran f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  countable (Range (map_graph f))\n\ngoal (1 subgoal):\n 1. countable (ran f)", "by (simp add: ran_map_graph)"], ["proof (state)\nthis:\n  countable (ran f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_graph_inv' [simp]:\n  \"graph_map' (map_graph f) = Some f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_map' (map_graph f) = Some f", "by (simp add: graph_map'_def)"], ["", "lemma map_graph_inj:\n  \"inj map_graph\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj map_graph", "by (metis injI map_graph_inv)"], ["", "lemma map_eq_graph: \"f = g \\<longleftrightarrow> map_graph f = map_graph g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = g) = (map_graph f = map_graph g)", "by (auto simp add: inj_eq map_graph_inj)"], ["", "lemma map_le_graph: \"f \\<subseteq>\\<^sub>m g \\<longleftrightarrow> map_graph f \\<subseteq> map_graph g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<subseteq>\\<^sub>m g) = (map_graph f \\<subseteq> map_graph g)", "by (force simp add: map_le_def map_graph_def)"], ["", "lemma map_graph_comp: \"map_graph (g \\<circ>\\<^sub>m f) = (map_graph f) O (map_graph g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_graph (g \\<circ>\\<^sub>m f) = map_graph f O map_graph g", "apply (auto simp add: map_comp_def map_graph_def relcomp_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (case f a of None \\<Rightarrow> None | Some x \\<Rightarrow> g x) =\n       Some b \\<Longrightarrow>\n       \\<exists>y. f a = Some y \\<and> g y = Some b", "apply (rename_tac a b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (case f a of None \\<Rightarrow> None | Some x \\<Rightarrow> g x) =\n       Some b \\<Longrightarrow>\n       \\<exists>y. f a = Some y \\<and> g y = Some b", "apply (case_tac \"f a\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open> Map Application \\<close>"], ["", "definition map_apply :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b\" (\"_'(_')\\<^sub>m\" [999,0] 999) where\n\"map_apply = (\\<lambda> f x. the (f x))\""], ["", "subsection \\<open> Map Membership \\<close>"], ["", "fun map_member :: \"'a \\<times> 'b \\<Rightarrow> ('a \\<rightharpoonup> 'b) \\<Rightarrow> bool\" (infix \"\\<in>\\<^sub>m\" 50) where\n\"(k, v) \\<in>\\<^sub>m m \\<longleftrightarrow> m(k) = Some(v)\""], ["", "lemma map_ext:\n  \"\\<lbrakk> \\<And> x y. (x, y) \\<in>\\<^sub>m A \\<longleftrightarrow> (x, y) \\<in>\\<^sub>m B \\<rbrakk> \\<Longrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        ((x, y) \\<in>\\<^sub>m A) =\n        ((x, y) \\<in>\\<^sub>m B)) \\<Longrightarrow>\n    A = B", "by (rule ext, auto, metis not_Some_eq)"], ["", "lemma map_member_alt_def:\n  \"(x, y) \\<in>\\<^sub>m A \\<longleftrightarrow> (x \\<in> dom A \\<and> A(x)\\<^sub>m = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in>\\<^sub>m A) = (x \\<in> dom A \\<and> A(x)\\<^sub>m = y)", "by (auto simp add: map_apply_def)"], ["", "lemma map_le_member:\n  \"f \\<subseteq>\\<^sub>m g \\<longleftrightarrow> (\\<forall> x y. (x,y) \\<in>\\<^sub>m f \\<longrightarrow> (x,y) \\<in>\\<^sub>m g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<subseteq>\\<^sub>m g) =\n    (\\<forall>x y.\n        (x, y) \\<in>\\<^sub>m f \\<longrightarrow> (x, y) \\<in>\\<^sub>m g)", "by (force simp add: map_le_def)"], ["", "subsection \\<open> Preimage \\<close>"], ["", "definition preimage :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> 'b set \\<Rightarrow> 'a set\" where\n\"preimage f B = {x \\<in> dom(f). the(f(x)) \\<in> B}\""], ["", "lemma preimage_range: \"preimage f (ran f) = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preimage f (ran f) = dom f", "by (auto simp add: preimage_def ran_def)"], ["", "lemma dom_preimage: \"dom (m \\<circ>\\<^sub>m f) = preimage f (dom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (m \\<circ>\\<^sub>m f) = preimage f (dom m)", "apply (auto simp add: dom_def preimage_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (m \\<circ>\\<^sub>m f) x = Some y \\<Longrightarrow>\n       \\<exists>y. f x = Some y\n 2. \\<And>x y.\n       (m \\<circ>\\<^sub>m f) x = Some y \\<Longrightarrow>\n       \\<exists>y. m (the (f x)) = Some y", "apply (meson map_comp_Some_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (m \\<circ>\\<^sub>m f) x = Some y \\<Longrightarrow>\n       \\<exists>y. m (the (f x)) = Some y", "apply (metis map_comp_def option.case_eq_if option.distinct(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma countable_preimage:\n  \"\\<lbrakk> countable A; inj_on f (preimage f A) \\<rbrakk> \\<Longrightarrow> countable (preimage f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>countable A; inj_on f (preimage f A)\\<rbrakk>\n    \\<Longrightarrow> countable (preimage f A)", "apply (auto simp add: countable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       \\<lbrakk>inj_on f (preimage f A); inj_on fa A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fa. inj_on fa (preimage f A)", "apply (rename_tac g)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>inj_on f (preimage f A); inj_on g A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fa. inj_on fa (preimage f A)", "apply (rule_tac x=\"g \\<circ> the \\<circ> f\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>inj_on f (preimage f A); inj_on g A\\<rbrakk>\n       \\<Longrightarrow> inj_on (g \\<circ> the \\<circ> f) (preimage f A)", "apply (rule inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g x y.\n       \\<lbrakk>inj_on f (preimage f A); inj_on g A; x \\<in> preimage f A;\n        y \\<in> preimage f A;\n        (g \\<circ> the \\<circ> f) x = (g \\<circ> the \\<circ> f) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (drule inj_onD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>g x y.\n       \\<lbrakk>inj_on g A; x \\<in> preimage f A; y \\<in> preimage f A;\n        (g \\<circ> the \\<circ> f) x = (g \\<circ> the \\<circ> f) y\\<rbrakk>\n       \\<Longrightarrow> f (?x4 g x y) = f (?y4 g x y)\n 2. \\<And>g x y.\n       \\<lbrakk>inj_on g A; x \\<in> preimage f A; y \\<in> preimage f A;\n        (g \\<circ> the \\<circ> f) x = (g \\<circ> the \\<circ> f) y\\<rbrakk>\n       \\<Longrightarrow> ?x4 g x y \\<in> preimage f A\n 3. \\<And>g x y.\n       \\<lbrakk>inj_on g A; x \\<in> preimage f A; y \\<in> preimage f A;\n        (g \\<circ> the \\<circ> f) x = (g \\<circ> the \\<circ> f) y\\<rbrakk>\n       \\<Longrightarrow> ?y4 g x y \\<in> preimage f A\n 4. \\<And>g x y.\n       \\<lbrakk>inj_on g A; x \\<in> preimage f A; y \\<in> preimage f A;\n        (g \\<circ> the \\<circ> f) x = (g \\<circ> the \\<circ> f) y;\n        ?x4 g x y = ?y4 g x y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (auto simp add: preimage_def inj_onD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open> Minus operation for maps \\<close>"], ["", "definition map_minus :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> ('a \\<rightharpoonup> 'b) \\<Rightarrow> ('a \\<rightharpoonup> 'b)\" (infixl \"--\" 100)\nwhere \"map_minus f g = (\\<lambda> x. if (f x = g x) then None else f x)\""], ["", "lemma map_minus_apply [simp]: \"y \\<in> dom(f -- g) \\<Longrightarrow> (f -- g)(y)\\<^sub>m = f(y)\\<^sub>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> dom (f -- g) \\<Longrightarrow>\n    (f -- g)(y)\\<^sub>m = f(y)\\<^sub>m", "by (auto simp add: map_minus_def dom_def map_apply_def)"], ["", "lemma map_member_plus:\n  \"(x, y) \\<in>\\<^sub>m f ++ g \\<longleftrightarrow> ((x \\<notin> dom(g) \\<and> (x, y) \\<in>\\<^sub>m f) \\<or> (x, y) \\<in>\\<^sub>m g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in>\\<^sub>m f ++ g) =\n    (x \\<notin> dom g \\<and> (x, y) \\<in>\\<^sub>m f \\<or>\n     (x, y) \\<in>\\<^sub>m g)", "by (auto simp add: map_add_Some_iff)"], ["", "lemma map_member_minus:\n  \"(x, y) \\<in>\\<^sub>m f -- g \\<longleftrightarrow> (x, y) \\<in>\\<^sub>m f \\<and> (\\<not> (x, y) \\<in>\\<^sub>m g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in>\\<^sub>m f -- g) =\n    ((x, y) \\<in>\\<^sub>m f \\<and> \\<not> (x, y) \\<in>\\<^sub>m g)", "by (auto simp add: map_minus_def)"], ["", "lemma map_minus_plus_commute:\n  \"dom(g) \\<inter> dom(h) = {} \\<Longrightarrow> (f -- g) ++ h = (f ++ h) -- g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom g \\<inter> dom h = {} \\<Longrightarrow> f -- g ++ h = f ++ h -- g", "apply (rule map_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       dom g \\<inter> dom h = {} \\<Longrightarrow>\n       ((x, y) \\<in>\\<^sub>m f -- g ++ h) =\n       ((x, y) \\<in>\\<^sub>m f ++ h -- g)", "apply (auto simp add: map_member_plus map_member_minus simp del: map_member.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>dom g \\<inter> dom h = {}; (x, y) \\<in>\\<^sub>m h;\n        (x, y) \\<in>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp add: map_member_alt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_graph_minus: \"map_graph (f -- g) = map_graph f - map_graph g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_graph (f -- g) = map_graph f - map_graph g", "by (auto simp add: map_minus_def map_graph_def, (meson option.distinct(1))+)"], ["", "lemma map_minus_common_subset:\n  \"\\<lbrakk> h \\<subseteq>\\<^sub>m f; h \\<subseteq>\\<^sub>m g \\<rbrakk> \\<Longrightarrow> (f -- h = g -- h) = (f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<subseteq>\\<^sub>m f; h \\<subseteq>\\<^sub>m g\\<rbrakk>\n    \\<Longrightarrow> (f -- h = g -- h) = (f = g)", "by (auto simp add: map_eq_graph map_graph_minus map_le_graph)"], ["", "subsection \\<open> Map Bind \\<close>"], ["", "text \\<open> Create some extra intro/elim rules to help dealing with proof about option bind. \\<close>"], ["", "lemma option_bindSomeE [elim!]:\n  \"\\<lbrakk> X >>= F = Some(v); \\<And> x. \\<lbrakk> X = Some(x); F(x) = Some(v) \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<bind> F = Some v;\n     \\<And>x.\n        \\<lbrakk>X = Some x; F x = Some v\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (case_tac X, auto)"], ["", "lemma option_bindSomeI [intro]:\n  \"\\<lbrakk> X = Some(x); F(x) = Some(y) \\<rbrakk> \\<Longrightarrow> X >>= F = Some(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X = Some x; F x = Some y\\<rbrakk>\n    \\<Longrightarrow> X \\<bind> F = Some y", "by (simp)"], ["", "lemma ifSomeE [elim]: \"\\<lbrakk> (if c then Some(x) else None) = Some(y); \\<lbrakk> c; x = y \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c then Some x else None) = Some y;\n     \\<lbrakk>c; x = y\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (case_tac c, auto)"], ["", "subsection \\<open> Range Restriction \\<close>"], ["", "text \\<open>A range restriction operator; only domain restriction is provided in HOL.\\<close>"], ["", "definition ran_restrict_map :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> 'b set \\<Rightarrow> 'a \\<rightharpoonup> 'b\" (\"_\\<upharpoonleft>\\<^bsub>_\\<^esub>\" [111,110] 110) where\n\"ran_restrict_map f B = (\\<lambda>x. do { v <- f(x); if (v \\<in> B) then Some(v) else None })\""], ["", "lemma ran_restrict_empty [simp]: \"f\\<upharpoonleft>\\<^bsub>{}\\<^esub> = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<upharpoonleft>\\<^bsub>{}\\<^esub> = Map.empty", "by (simp add:ran_restrict_map_def)"], ["", "lemma ran_restrict_ran [simp]: \"f\\<upharpoonleft>\\<^bsub>ran(f) \\<^esub> = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<upharpoonleft>\\<^bsub>ran f\\<^esub> = f", "apply (auto simp add:ran_restrict_map_def ran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        f x \\<bind>\n        (\\<lambda>v. if \\<exists>a. f a = Some v then Some v else None)) =\n    f", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       f x \\<bind>\n       (\\<lambda>v. if \\<exists>a. f a = Some v then Some v else None) =\n       f x", "apply (case_tac \"f(x)\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ran_ran_restrict [simp]: \"ran(f\\<upharpoonleft>\\<^bsub>B\\<^esub>) = ran(f) \\<inter> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (f\\<upharpoonleft>\\<^bsub>B\\<^esub>) = ran f \\<inter> B", "by (auto intro!:option_bindSomeI simp add:ran_restrict_map_def ran_def)"], ["", "lemma dom_ran_restrict: \"dom(f\\<upharpoonleft>\\<^bsub>B\\<^esub>) \\<subseteq> dom(f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (f\\<upharpoonleft>\\<^bsub>B\\<^esub>) \\<subseteq> dom f", "by (auto simp add:ran_restrict_map_def dom_def)"], ["", "lemma ran_restrict_finite_dom [intro]:\n  \"finite(dom(f)) \\<Longrightarrow> finite(dom(f\\<upharpoonleft>\\<^bsub>B\\<^esub>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom f) \\<Longrightarrow>\n    finite (dom (f\\<upharpoonleft>\\<^bsub>B\\<^esub>))", "by (metis finite_subset dom_ran_restrict)"], ["", "lemma dom_Some [simp]: \"dom (Some \\<circ> f) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Some \\<circ> f) = UNIV", "by (auto)"], ["", "lemma dom_left_map_add [simp]: \"x \\<in> dom g \\<Longrightarrow> (f ++ g) x = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom g \\<Longrightarrow> (f ++ g) x = g x", "by (auto simp add:map_add_def dom_def)"], ["", "lemma dom_right_map_add [simp]: \"\\<lbrakk> x \\<notin> dom g; x \\<in> dom f \\<rbrakk> \\<Longrightarrow> (f ++ g) x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom g; x \\<in> dom f\\<rbrakk>\n    \\<Longrightarrow> (f ++ g) x = f x", "by (auto simp add:map_add_def dom_def)"], ["", "lemma map_add_restrict:\n  \"f ++ g = (f |` (- dom g)) ++ g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ++ g = f |` (- dom g) ++ g", "by (rule ext, auto simp add: map_add_def restrict_map_def)"], ["", "subsection \\<open> Map Inverse and Identity \\<close>"], ["", "definition map_inv :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> ('b \\<rightharpoonup> 'a)\" where\n\"map_inv f \\<equiv> \\<lambda> y. if (y \\<in> ran f) then Some (SOME x. f x = Some y) else None\""], ["", "definition map_id_on :: \"'a set \\<Rightarrow> ('a \\<rightharpoonup> 'a)\" where\n\"map_id_on xs \\<equiv> \\<lambda> x. if (x \\<in> xs) then Some x else None\""], ["", "lemma map_id_on_in [simp]:\n  \"x \\<in> xs \\<Longrightarrow> map_id_on xs x = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> xs \\<Longrightarrow> map_id_on xs x = Some x", "by (simp add:map_id_on_def)"], ["", "lemma map_id_on_out [simp]:\n  \"x \\<notin> xs \\<Longrightarrow> map_id_on xs x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> xs \\<Longrightarrow> map_id_on xs x = None", "by (simp add:map_id_on_def)"], ["", "lemma map_id_dom [simp]: \"dom (map_id_on xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_id_on xs) = xs", "by (simp add:dom_def map_id_on_def)"], ["", "lemma map_id_ran [simp]: \"ran (map_id_on xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (map_id_on xs) = xs", "by (force simp add:ran_def map_id_on_def)"], ["", "lemma map_id_on_UNIV[simp]: \"map_id_on UNIV = Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_id_on UNIV = Some", "by (simp add:map_id_on_def)"], ["", "lemma map_id_on_inj [simp]:\n  \"inj_on (map_id_on xs) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (map_id_on xs) xs", "by (simp add:inj_on_def)"], ["", "lemma map_inv_empty [simp]: \"map_inv Map.empty = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_inv Map.empty = Map.empty", "by (simp add:map_inv_def)"], ["", "lemma map_inv_id [simp]:\n  \"map_inv (map_id_on xs) = map_id_on xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_inv (map_id_on xs) = map_id_on xs", "by (force simp add:map_inv_def map_id_on_def ran_def)"], ["", "lemma map_inv_Some [simp]: \"map_inv Some = Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_inv Some = Some", "by (simp add:map_inv_def ran_def)"], ["", "lemma map_inv_f_f [simp]:\n  \"\\<lbrakk> inj_on f (dom f); f x = Some y \\<rbrakk> \\<Longrightarrow> map_inv f y = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f (dom f); f x = Some y\\<rbrakk>\n    \\<Longrightarrow> map_inv f y = Some x", "apply (auto simp add: map_inv_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (dom f); f x = Some y; y \\<in> ran f\\<rbrakk>\n    \\<Longrightarrow> (SOME x. f x = Some y) = x\n 2. \\<lbrakk>inj_on f (dom f); f x = Some y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> ran f", "apply (rule some_equality)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>inj_on f (dom f); f x = Some y; y \\<in> ran f\\<rbrakk>\n    \\<Longrightarrow> f x = Some y\n 2. \\<And>xa.\n       \\<lbrakk>inj_on f (dom f); f x = Some y; y \\<in> ran f;\n        f xa = Some y\\<rbrakk>\n       \\<Longrightarrow> xa = x\n 3. \\<lbrakk>inj_on f (dom f); f x = Some y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> ran f", "apply (auto simp add:inj_on_def dom_def ran_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dom_map_inv [simp]:\n  \"dom (map_inv f) = ran f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_inv f) = ran f", "by (auto simp add:map_inv_def)"], ["", "lemma ran_map_inv [simp]:\n  \"inj_on f (dom f) \\<Longrightarrow> ran (map_inv f) = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (dom f) \\<Longrightarrow> ran (map_inv f) = dom f", "apply (auto simp add:map_inv_def ran_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>inj_on f (dom f); f aa = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. f (SOME x. f x = Some a) = Some y\n 2. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); f x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            ((\\<exists>aa. f aa = Some a) \\<longrightarrow>\n                             (SOME x. f x = Some a) = x) \\<and>\n                            (\\<exists>aa. f aa = Some a)", "apply (rename_tac a b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>inj_on f (dom f); f b = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. f (SOME x. f x = Some a) = Some y\n 2. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); f x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            ((\\<exists>aa. f aa = Some a) \\<longrightarrow>\n                             (SOME x. f x = Some a) = x) \\<and>\n                            (\\<exists>aa. f aa = Some a)", "apply (rule_tac x=\"a\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>inj_on f (dom f); f b = Some a\\<rbrakk>\n       \\<Longrightarrow> f (SOME x. f x = Some a) = Some a\n 2. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); f x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            ((\\<exists>aa. f aa = Some a) \\<longrightarrow>\n                             (SOME x. f x = Some a) = x) \\<and>\n                            (\\<exists>aa. f aa = Some a)", "apply (force intro:someI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); f x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            ((\\<exists>aa. f aa = Some a) \\<longrightarrow>\n                             (SOME x. f x = Some a) = x) \\<and>\n                            (\\<exists>aa. f aa = Some a)", "apply (rename_tac x y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); f x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            ((\\<exists>aa. f aa = Some a) \\<longrightarrow>\n                             (SOME x. f x = Some a) = x) \\<and>\n                            (\\<exists>aa. f aa = Some a)", "apply (rule_tac x=\"y\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); f x = Some y\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>a. f a = Some y) \\<longrightarrow>\n                          (SOME x. f x = Some y) = x) \\<and>\n                         (\\<exists>a. f a = Some y)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y a.\n       \\<lbrakk>inj_on f (dom f); f x = Some y; f a = Some y\\<rbrakk>\n       \\<Longrightarrow> (SOME x. f x = Some y) = x", "apply (rule some_equality, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y a xa.\n       \\<lbrakk>inj_on f (dom f); f x = Some y; f a = Some y;\n        f xa = Some y\\<rbrakk>\n       \\<Longrightarrow> xa = x", "apply (auto simp add:inj_on_def dom_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dom_image_ran: \"f ` dom f = Some ` ran f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` dom f = Some ` ran f", "by (auto simp add:dom_def ran_def image_def)"], ["", "lemma inj_map_inv [intro]:\n  \"inj_on f (dom f) \\<Longrightarrow> inj_on (map_inv f) (ran f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (dom f) \\<Longrightarrow> inj_on (map_inv f) (ran f)", "apply (auto simp add:map_inv_def inj_on_def dom_def ran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a y aa.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>y. f x = Some y) \\<longrightarrow>\n                   (\\<forall>y.\n                       (\\<exists>ya. f y = Some ya) \\<longrightarrow>\n                       f x = f y \\<longrightarrow> x = y);\n        f a = Some x; f aa = Some y;\n        (SOME xa. f xa = Some x) = (SOME x. f x = Some y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (rename_tac x y u v)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y u v.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>y. f x = Some y) \\<longrightarrow>\n                   (\\<forall>y.\n                       (\\<exists>ya. f y = Some ya) \\<longrightarrow>\n                       f x = f y \\<longrightarrow> x = y);\n        f y = Some x; f v = Some u;\n        (SOME xa. f xa = Some x) = (SOME x. f x = Some u)\\<rbrakk>\n       \\<Longrightarrow> x = u", "apply (frule_tac P=\"\\<lambda> xa. f xa = Some x\" in some_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y u v xa.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>y. f x = Some y) \\<longrightarrow>\n                   (\\<forall>y.\n                       (\\<exists>ya. f y = Some ya) \\<longrightarrow>\n                       f x = f y \\<longrightarrow> x = y);\n        f y = Some x; f v = Some u;\n        (SOME xa. f xa = Some x) = (SOME x. f x = Some u);\n        f xa = Some x\\<rbrakk>\n       \\<Longrightarrow> xa = y\n 2. \\<And>x y u v.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>y. f x = Some y) \\<longrightarrow>\n                   (\\<forall>y.\n                       (\\<exists>ya. f y = Some ya) \\<longrightarrow>\n                       f x = f y \\<longrightarrow> x = y);\n        f y = Some x; f v = Some u;\n        (SOME xa. f xa = Some x) = (SOME x. f x = Some u);\n        (SOME xa. f xa = Some x) = y\\<rbrakk>\n       \\<Longrightarrow> x = u", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x u v.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>y. f x = Some y) \\<longrightarrow>\n                   (\\<forall>y.\n                       (\\<exists>ya. f y = Some ya) \\<longrightarrow>\n                       f x = f y \\<longrightarrow> x = y);\n        f (SOME x. f x = Some u) = Some x; f v = Some u;\n        (SOME xa. f xa = Some x) = (SOME x. f x = Some u)\\<rbrakk>\n       \\<Longrightarrow> x = u", "apply (metis (mono_tags) option.sel someI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inj_map_bij: \"inj_on f (dom f) \\<Longrightarrow> bij_betw f (dom f) (Some ` ran f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (dom f) \\<Longrightarrow> bij_betw f (dom f) (Some ` ran f)", "by (auto simp add:inj_on_def dom_def ran_def image_def bij_betw_def)"], ["", "lemma map_inv_map_inv [simp]:\n  assumes \"inj_on f (dom f)\"\n  shows \"map_inv (map_inv f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_inv (map_inv f) = f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_inv (map_inv f) = f", "from assms"], ["proof (chain)\npicking this:\n  inj_on f (dom f)", "have \"inj_on (map_inv f) (ran f)\""], ["proof (prove)\nusing this:\n  inj_on f (dom f)\n\ngoal (1 subgoal):\n 1. inj_on (map_inv f) (ran f)", "by auto"], ["proof (state)\nthis:\n  inj_on (map_inv f) (ran f)\n\ngoal (1 subgoal):\n 1. map_inv (map_inv f) = f", "thus ?thesis"], ["proof (prove)\nusing this:\n  inj_on (map_inv f) (ran f)\n\ngoal (1 subgoal):\n 1. map_inv (map_inv f) = f", "apply (rule_tac ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       inj_on (map_inv f) (ran f) \\<Longrightarrow>\n       map_inv (map_inv f) x = f x", "apply (rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       inj_on (map_inv f) (ran f) \\<Longrightarrow>\n       map_inv (map_inv f) x = f x", "apply (case_tac \"\\<exists> y. map_inv f y = Some x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>inj_on (map_inv f) (ran f);\n        \\<exists>y. map_inv f y = Some x\\<rbrakk>\n       \\<Longrightarrow> map_inv (map_inv f) x = f x\n 2. \\<And>x.\n       \\<lbrakk>inj_on (map_inv f) (ran f);\n        \\<nexists>y. map_inv f y = Some x\\<rbrakk>\n       \\<Longrightarrow> map_inv (map_inv f) x = f x", "apply (auto)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on (map_inv f) (ran f); map_inv f y = Some x\\<rbrakk>\n       \\<Longrightarrow> Some y = f x\n 2. \\<And>x.\n       \\<lbrakk>inj_on (map_inv f) (ran f);\n        \\<nexists>y. map_inv f y = Some x\\<rbrakk>\n       \\<Longrightarrow> map_inv (map_inv f) x = f x", "apply (simp add:map_inv_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on\n                 (\\<lambda>y.\n                     if y \\<in> ran f then Some (SOME x. f x = Some y)\n                     else None)\n                 (ran f);\n        (if y \\<in> ran f then Some (SOME x. f x = Some y) else None) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> Some y = f x\n 2. \\<And>x.\n       \\<lbrakk>inj_on (map_inv f) (ran f);\n        \\<nexists>y. map_inv f y = Some x\\<rbrakk>\n       \\<Longrightarrow> map_inv (map_inv f) x = f x", "apply (rename_tac x y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on\n                 (\\<lambda>y.\n                     if y \\<in> ran f then Some (SOME x. f x = Some y)\n                     else None)\n                 (ran f);\n        (if y \\<in> ran f then Some (SOME x. f x = Some y) else None) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> Some y = f x\n 2. \\<And>x.\n       \\<lbrakk>inj_on (map_inv f) (ran f);\n        \\<nexists>y. map_inv f y = Some x\\<rbrakk>\n       \\<Longrightarrow> map_inv (map_inv f) x = f x", "apply (case_tac \"y \\<in> ran f\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on\n                 (\\<lambda>y.\n                     if y \\<in> ran f then Some (SOME x. f x = Some y)\n                     else None)\n                 (ran f);\n        (SOME x. f x = Some y) = x; y \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> Some y = f x\n 2. \\<And>x.\n       \\<lbrakk>inj_on (map_inv f) (ran f);\n        \\<forall>y. map_inv f y \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> map_inv (map_inv f) x = f x", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>inj_on\n                 (\\<lambda>y.\n                     if y \\<in> ran f then Some (SOME x. f x = Some y)\n                     else None)\n                 (ran f);\n        y \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> Some y = f (SOME x. f x = Some y)\n 2. \\<And>x.\n       \\<lbrakk>inj_on (map_inv f) (ran f);\n        \\<forall>y. map_inv f y \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> map_inv (map_inv f) x = f x", "apply (rule someI2_ex)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>inj_on\n                 (\\<lambda>y.\n                     if y \\<in> ran f then Some (SOME x. f x = Some y)\n                     else None)\n                 (ran f);\n        y \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. f a = Some y\n 2. \\<And>y x.\n       \\<lbrakk>inj_on\n                 (\\<lambda>y.\n                     if y \\<in> ran f then Some (SOME x. f x = Some y)\n                     else None)\n                 (ran f);\n        y \\<in> ran f; f x = Some y\\<rbrakk>\n       \\<Longrightarrow> Some y = f x\n 3. \\<And>x.\n       \\<lbrakk>inj_on (map_inv f) (ran f);\n        \\<forall>y. map_inv f y \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> map_inv (map_inv f) x = f x", "apply (simp add:ran_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y x.\n       \\<lbrakk>inj_on\n                 (\\<lambda>y.\n                     if y \\<in> ran f then Some (SOME x. f x = Some y)\n                     else None)\n                 (ran f);\n        y \\<in> ran f; f x = Some y\\<rbrakk>\n       \\<Longrightarrow> Some y = f x\n 2. \\<And>x.\n       \\<lbrakk>inj_on (map_inv f) (ran f);\n        \\<forall>y. map_inv f y \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> map_inv (map_inv f) x = f x", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>inj_on (map_inv f) (ran f);\n        \\<forall>y. map_inv f y \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> map_inv (map_inv f) x = f x", "apply (metis assms dom_image_ran dom_map_inv image_iff map_add_dom_app_simps(2) map_add_dom_app_simps(3) ran_map_inv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_inv (map_inv f) = f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_self_adjoin_complete [intro]:\n  assumes \"dom f \\<inter> ran f = {}\" \"inj_on f (dom f)\"\n  shows \"inj_on (map_inv f ++ f) (dom f \\<union> ran f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (map_inv f ++ f) (dom f \\<union> ran f)", "apply (rule inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (insert assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f)\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (rename_tac x y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f)\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (case_tac \"x \\<in> dom f\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<in> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (case_tac \"y \\<in> dom f\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f;\n        y \\<in> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f;\n        y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp add:inj_on_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f;\n        y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (case_tac \"y \\<in> ran f\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f;\n        y \\<notin> dom f; y \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f;\n        y \\<notin> dom f; y \\<notin> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (subgoal_tac \"y \\<in> dom (map_inv f)\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f;\n        y \\<notin> dom f; y \\<in> ran f; y \\<in> dom (map_inv f)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f;\n        y \\<notin> dom f; y \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> y \\<in> dom (map_inv f)\n 3. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f;\n        y \\<notin> dom f; y \\<notin> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>f x = map_inv f y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<in> dom f; y \\<notin> dom f;\n        y \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f;\n        y \\<notin> dom f; y \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> y \\<in> dom (map_inv f)\n 3. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f;\n        y \\<notin> dom f; y \\<notin> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (metis Int_iff domD empty_iff ranI ran_map_inv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f;\n        y \\<notin> dom f; y \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> y \\<in> dom (map_inv f)\n 2. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f;\n        y \\<notin> dom f; y \\<notin> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>y \\<in> dom f \\<or> y \\<in> ran f; f x = (map_inv f ++ f) y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<in> dom f;\n        y \\<notin> dom f; y \\<notin> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> dom f \\<union> ran f; y \\<in> dom f \\<union> ran f;\n        (map_inv f ++ f) x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; y \\<in> dom f \\<or> y \\<in> ran f;\n        map_inv f x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (case_tac \"y \\<in> dom f\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; y \\<in> dom f \\<or> y \\<in> ran f;\n        map_inv f x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<in> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; y \\<in> dom f \\<or> y \\<in> ran f;\n        map_inv f x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; map_inv f x = f y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<in> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; y \\<in> dom f \\<or> y \\<in> ran f;\n        map_inv f x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (case_tac \"y \\<in> ran f\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; map_inv f x = f y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<in> dom f;\n        y \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; map_inv f x = f y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<in> dom f;\n        y \\<notin> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; y \\<in> dom f \\<or> y \\<in> ran f;\n        map_inv f x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (subgoal_tac \"y \\<in> dom (map_inv f)\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; map_inv f x = f y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<in> dom f; y \\<in> ran f;\n        y \\<in> dom (map_inv f)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; map_inv f x = f y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<in> dom f;\n        y \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> y \\<in> dom (map_inv f)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; map_inv f x = f y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<in> dom f;\n        y \\<notin> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; y \\<in> dom f \\<or> y \\<in> ran f;\n        map_inv f x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; map_inv f x = f y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<in> dom f;\n        y \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; map_inv f x = f y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<in> dom f;\n        y \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> y \\<in> dom (map_inv f)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; map_inv f x = f y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<in> dom f;\n        y \\<notin> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; y \\<in> dom f \\<or> y \\<in> ran f;\n        map_inv f x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (metis Int_iff empty_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; map_inv f x = f y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<in> dom f;\n        y \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> y \\<in> dom (map_inv f)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; map_inv f x = f y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<in> dom f;\n        y \\<notin> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; y \\<in> dom f \\<or> y \\<in> ran f;\n        map_inv f x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; map_inv f x = f y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<in> dom f;\n        y \\<notin> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; y \\<in> dom f \\<or> y \\<in> ran f;\n        map_inv f x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (metis Int_iff domD empty_iff ranI ran_map_inv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; y \\<in> dom f \\<or> y \\<in> ran f;\n        map_inv f x = (map_inv f ++ f) y; dom f \\<inter> ran f = {};\n        inj_on f (dom f); x \\<notin> dom f; y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ran f; y \\<in> ran f; map_inv f x = map_inv f y;\n        dom f \\<inter> ran f = {}; inj_on f (dom f); x \\<notin> dom f;\n        y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (metis (lifting) inj_map_inv inj_on_contraD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inj_completed_map [intro]:\n  \"\\<lbrakk> dom f = ran f; inj_on f (dom f) \\<rbrakk> \\<Longrightarrow> inj (Some ++ f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom f = ran f; inj_on f (dom f)\\<rbrakk>\n    \\<Longrightarrow> inj (Some ++ f)", "apply (drule inj_map_bij)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom f = ran f; bij_betw f (dom f) (Some ` ran f)\\<rbrakk>\n    \\<Longrightarrow> inj (Some ++ f)", "apply (auto simp add:bij_betw_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom f = ran f; inj_on f (ran f);\n     f ` ran f = Some ` ran f\\<rbrakk>\n    \\<Longrightarrow> inj (Some ++ f)", "apply (auto simp add:inj_on_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; (Some ++ f) x = (Some ++ f) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (rename_tac x y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; (Some ++ f) x = (Some ++ f) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (case_tac \"x \\<in> dom f\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; (Some ++ f) x = (Some ++ f) y;\n        x \\<in> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; (Some ++ f) x = (Some ++ f) y;\n        x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; f x = (Some ++ f) y;\n        x \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; (Some ++ f) x = (Some ++ f) y;\n        x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (case_tac \"y \\<in> dom f\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; f x = (Some ++ f) y; x \\<in> ran f;\n        y \\<in> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; f x = (Some ++ f) y; x \\<in> ran f;\n        y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; (Some ++ f) x = (Some ++ f) y;\n        x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; f x = (Some ++ f) y; x \\<in> ran f;\n        y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; (Some ++ f) x = (Some ++ f) y;\n        x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp add:ran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; (Some ++ f) x = (Some ++ f) y;\n        x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (case_tac \"y \\<in> dom f\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; (Some ++ f) x = (Some ++ f) y;\n        x \\<notin> dom f; y \\<in> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>dom f = ran f;\n        \\<forall>x\\<in>ran f.\n           \\<forall>y\\<in>ran f. f x = f y \\<longrightarrow> x = y;\n        f ` ran f = Some ` ran f; (Some ++ f) x = (Some ++ f) y;\n        x \\<notin> dom f; y \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (auto intro:ranI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bij_completed_map [intro]:\n  \"\\<lbrakk> dom f = ran f; inj_on f (dom f) \\<rbrakk> \\<Longrightarrow>\n   bij_betw (Some ++ f) UNIV (range Some)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom f = ran f; inj_on f (dom f)\\<rbrakk>\n    \\<Longrightarrow> bij_betw (Some ++ f) UNIV (range Some)", "apply (auto simp add:bij_betw_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f)\\<rbrakk>\n       \\<Longrightarrow> (Some ++ f) xa \\<in> range Some\n 2. \\<And>xa.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f)\\<rbrakk>\n       \\<Longrightarrow> Some xa \\<in> range (Some ++ f)", "apply (rename_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f)\\<rbrakk>\n       \\<Longrightarrow> (Some ++ f) x \\<in> range Some\n 2. \\<And>xa.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f)\\<rbrakk>\n       \\<Longrightarrow> Some xa \\<in> range (Some ++ f)", "apply (case_tac \"x \\<in> dom f\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f); x \\<in> dom f\\<rbrakk>\n       \\<Longrightarrow> (Some ++ f) x \\<in> range Some\n 2. \\<And>x.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> (Some ++ f) x \\<in> range Some\n 3. \\<And>xa.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f)\\<rbrakk>\n       \\<Longrightarrow> Some xa \\<in> range (Some ++ f)", "apply (simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f); x \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> f x \\<in> range Some\n 2. \\<And>x.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> (Some ++ f) x \\<in> range Some\n 3. \\<And>xa.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f)\\<rbrakk>\n       \\<Longrightarrow> Some xa \\<in> range (Some ++ f)", "apply (metis domD rangeI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f); x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> (Some ++ f) x \\<in> range Some\n 2. \\<And>xa.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f)\\<rbrakk>\n       \\<Longrightarrow> Some xa \\<in> range (Some ++ f)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f)\\<rbrakk>\n       \\<Longrightarrow> Some xa \\<in> range (Some ++ f)", "apply (simp add:image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>dom f = ran f; inj_on f (ran f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. Some xa = (Some ++ f) x", "apply (metis (full_types) dom_image_ran dom_left_map_add image_iff map_add_dom_app_simps(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bij_map_Some:\n  \"bij_betw f a (Some ` b) \\<Longrightarrow> bij_betw (the \\<circ> f) a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw f a (Some ` b) \\<Longrightarrow> bij_betw (the \\<circ> f) a b", "apply (simp add:bij_betw_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f a \\<and> f ` a = Some ` b \\<Longrightarrow>\n    inj_on (the \\<circ> f) a \\<and> (\\<lambda>x. the (f x)) ` a = b", "apply (safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>inj_on f a; f ` a = Some ` b\\<rbrakk>\n    \\<Longrightarrow> inj_on (the \\<circ> f) a\n 2. \\<And>x xa.\n       \\<lbrakk>inj_on f a; f ` a = Some ` b; xa \\<in> a\\<rbrakk>\n       \\<Longrightarrow> the (f xa) \\<in> b\n 3. \\<And>x.\n       \\<lbrakk>inj_on f a; f ` a = Some ` b; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x. the (f x)) ` a", "apply (metis (hide_lams, no_types) comp_inj_on_iff f_the_inv_into_f inj_on_inverseI option.sel)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>inj_on f a; f ` a = Some ` b; xa \\<in> a\\<rbrakk>\n       \\<Longrightarrow> the (f xa) \\<in> b\n 2. \\<And>x.\n       \\<lbrakk>inj_on f a; f ` a = Some ` b; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x. the (f x)) ` a", "apply (metis (hide_lams, no_types) image_iff option.sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f a; f ` a = Some ` b; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x. the (f x)) ` a", "apply (metis Option.these_def Some_image_these_eq image_image these_image_Some_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ran_map_add [simp]:\n  \"m`(dom m \\<inter> dom n) = n`(dom m \\<inter> dom n) \\<Longrightarrow>\n   ran(m++n) = ran n \\<union> ran m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m ` (dom m \\<inter> dom n) =\n    n ` (dom m \\<inter> dom n) \\<Longrightarrow>\n    ran (m ++ n) = ran n \\<union> ran m", "apply (auto simp add:ran_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        n a = Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. (m ++ n) a = Some x\n 2. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. (m ++ n) a = Some x", "apply (metis map_add_find_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. (m ++ n) a = Some x", "apply (rename_tac x a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. (m ++ n) a = Some x", "apply (case_tac \"a \\<in> dom n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; a \\<in> dom n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. (m ++ n) a = Some x\n 2. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; a \\<notin> dom n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. (m ++ n) a = Some x", "apply (subgoal_tac \"\\<exists> b. n b = Some x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; a \\<in> dom n; \\<exists>b. n b = Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. (m ++ n) a = Some x\n 2. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; a \\<in> dom n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. n b = Some x\n 3. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; a \\<notin> dom n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. (m ++ n) a = Some x", "apply (auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a b y.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; n b = Some x; n a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. (m ++ n) a = Some x\n 2. \\<And>x a y.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; n a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. n b = Some x\n 3. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; \\<forall>a. (m ++ n) a \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. n a = Some y", "apply (rename_tac x a b y)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a b y.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; n b = Some x; n a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. (m ++ n) a = Some x\n 2. \\<And>x a y.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; n a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. n b = Some x\n 3. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; \\<forall>a. (m ++ n) a \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. n a = Some y", "apply (rule_tac x=\"b\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a b y.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; n b = Some x; n a = Some y\\<rbrakk>\n       \\<Longrightarrow> (m ++ n) b = Some x\n 2. \\<And>x a y.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; n a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. n b = Some x\n 3. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; \\<forall>a. (m ++ n) a \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. n a = Some y", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a y.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; n a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. n b = Some x\n 2. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; \\<forall>a. (m ++ n) a \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. n a = Some y", "apply (metis (hide_lams, no_types) IntI domI image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>m ` (dom m \\<inter> dom n) = n ` (dom m \\<inter> dom n);\n        m a = Some x; \\<forall>a. (m ++ n) a \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. n a = Some y", "apply (metis (full_types) map_add_None map_add_dom_app_simps(1) map_add_dom_app_simps(3) not_None_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ran_maplets [simp]:\n  \"\\<lbrakk> length xs = length ys; distinct xs \\<rbrakk> \\<Longrightarrow> ran [xs [\\<mapsto>] ys] = set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys; distinct xs\\<rbrakk>\n    \\<Longrightarrow> ran [xs [\\<mapsto>] ys] = set ys", "by (induct rule:list_induct2, simp_all)"], ["", "lemma inj_map_add:\n  \"\\<lbrakk> inj_on f (dom f); inj_on g (dom g); ran f \\<inter> ran g = {} \\<rbrakk> \\<Longrightarrow>\n   inj_on (f ++ g) (dom f \\<union> dom g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f (dom f); inj_on g (dom g);\n     ran f \\<inter> ran g = {}\\<rbrakk>\n    \\<Longrightarrow> inj_on (f ++ g) (dom f \\<union> dom g)", "apply (auto simp add:inj_on_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y ya yb.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; (f ++ g) x = (f ++ g) y; f x = Some ya;\n        f y = Some yb\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y ya yb.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; f x = Some ya; g y = Some yb;\n        g x = Some yb\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y ya.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; g y = Some ya; g x = None;\n        f x = Some ya\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y ya yb.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; Some ya = (f ++ g) y; g x = (f ++ g) y;\n        f y = Some yb\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y yb.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; g x = Some yb; g y = Some yb\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (metis (full_types) disjoint_iff_not_equal domI dom_left_map_add map_add_dom_app_simps(3) ranI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y ya yb.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; f x = Some ya; g y = Some yb;\n        g x = Some yb\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y ya.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; g y = Some ya; g x = None;\n        f x = Some ya\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y ya yb.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; Some ya = (f ++ g) y; g x = (f ++ g) y;\n        f y = Some yb\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y yb.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; g x = Some yb; g y = Some yb\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (metis domI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; g y = Some ya; g x = None;\n        f x = Some ya\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y ya yb.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; Some ya = (f ++ g) y; g x = (f ++ g) y;\n        f y = Some yb\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y yb.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; g x = Some yb; g y = Some yb\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (metis disjoint_iff_not_equal ranI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y ya yb.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; Some ya = (f ++ g) y; g x = (f ++ g) y;\n        f y = Some yb\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y yb.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; g x = Some yb; g y = Some yb\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (metis disjoint_iff_not_equal domIff map_add_Some_iff ranI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y yb.\n       \\<lbrakk>\\<forall>x\\<in>dom f.\n                   \\<forall>y\\<in>dom f. f x = f y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>dom g.\n           \\<forall>y\\<in>dom g. g x = g y \\<longrightarrow> x = y;\n        ran f \\<inter> ran g = {}; g x = Some yb; g y = Some yb\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (metis domI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_inv_add [simp]:\n  assumes \"inj_on f (dom f)\" \"inj_on g (dom g)\"\n          \"dom f \\<inter> dom g = {}\" \"ran f \\<inter> ran g = {}\"\n  shows \"map_inv (f ++ g) = map_inv f ++ map_inv g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_inv (f ++ g) = map_inv f ++ map_inv g", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "from assms"], ["proof (chain)\npicking this:\n  inj_on f (dom f)\n  inj_on g (dom g)\n  dom f \\<inter> dom g = {}\n  ran f \\<inter> ran g = {}", "have minj: \"inj_on (f ++ g) (dom (f ++ g))\""], ["proof (prove)\nusing this:\n  inj_on f (dom f)\n  inj_on g (dom g)\n  dom f \\<inter> dom g = {}\n  ran f \\<inter> ran g = {}\n\ngoal (1 subgoal):\n 1. inj_on (f ++ g) (dom (f ++ g))", "by (simp, metis inj_map_add sup_commute)"], ["proof (state)\nthis:\n  inj_on (f ++ g) (dom (f ++ g))\n\ngoal (1 subgoal):\n 1. \\<And>x. map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "have \"x \\<in> ran g \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> ran g \\<Longrightarrow>\n    map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> ran g \\<Longrightarrow>\n    map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "assume ran:\"x \\<in> ran g\""], ["proof (state)\nthis:\n  x \\<in> ran g\n\ngoal (1 subgoal):\n 1. x \\<in> ran g \\<Longrightarrow>\n    map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "then"], ["proof (chain)\npicking this:\n  x \\<in> ran g", "obtain y where dom:\"g y = Some x\" \"y \\<in> dom g\""], ["proof (prove)\nusing this:\n  x \\<in> ran g\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>g y = Some x; y \\<in> dom g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:ran_def)"], ["proof (state)\nthis:\n  g y = Some x\n  y \\<in> dom g\n\ngoal (1 subgoal):\n 1. x \\<in> ran g \\<Longrightarrow>\n    map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "hence \"(f ++ g) y = Some x\""], ["proof (prove)\nusing this:\n  g y = Some x\n  y \\<in> dom g\n\ngoal (1 subgoal):\n 1. (f ++ g) y = Some x", "by simp"], ["proof (state)\nthis:\n  (f ++ g) y = Some x\n\ngoal (1 subgoal):\n 1. x \\<in> ran g \\<Longrightarrow>\n    map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "with assms minj ran dom"], ["proof (chain)\npicking this:\n  inj_on f (dom f)\n  inj_on g (dom g)\n  dom f \\<inter> dom g = {}\n  ran f \\<inter> ran g = {}\n  inj_on (f ++ g) (dom (f ++ g))\n  x \\<in> ran g\n  g y = Some x\n  y \\<in> dom g\n  (f ++ g) y = Some x", "show \"map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\""], ["proof (prove)\nusing this:\n  inj_on f (dom f)\n  inj_on g (dom g)\n  dom f \\<inter> dom g = {}\n  ran f \\<inter> ran g = {}\n  inj_on (f ++ g) (dom (f ++ g))\n  x \\<in> ran g\n  g y = Some x\n  y \\<in> dom g\n  (f ++ g) y = Some x\n\ngoal (1 subgoal):\n 1. map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "by simp"], ["proof (state)\nthis:\n  map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> ran g \\<Longrightarrow>\n  map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n\ngoal (1 subgoal):\n 1. \\<And>x. map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "moreover"], ["proof (state)\nthis:\n  x \\<in> ran g \\<Longrightarrow>\n  map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n\ngoal (1 subgoal):\n 1. \\<And>x. map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "have \"\\<lbrakk> x \\<notin> ran g; x \\<in> ran f \\<rbrakk> \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n    \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n    \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "assume ran:\"x \\<notin> ran g\" \"x \\<in> ran f\""], ["proof (state)\nthis:\n  x \\<notin> ran g\n  x \\<in> ran f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n    \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "with assms"], ["proof (chain)\npicking this:\n  inj_on f (dom f)\n  inj_on g (dom g)\n  dom f \\<inter> dom g = {}\n  ran f \\<inter> ran g = {}\n  x \\<notin> ran g\n  x \\<in> ran f", "obtain y where dom:\"f y = Some x\" \"y \\<in> dom f\" \"y \\<notin> dom g\""], ["proof (prove)\nusing this:\n  inj_on f (dom f)\n  inj_on g (dom g)\n  dom f \\<inter> dom g = {}\n  ran f \\<inter> ran g = {}\n  x \\<notin> ran g\n  x \\<in> ran f\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>f y = Some x; y \\<in> dom f; y \\<notin> dom g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:ran_def)"], ["proof (state)\nthis:\n  f y = Some x\n  y \\<in> dom f\n  y \\<notin> dom g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n    \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "with ran"], ["proof (chain)\npicking this:\n  x \\<notin> ran g\n  x \\<in> ran f\n  f y = Some x\n  y \\<in> dom f\n  y \\<notin> dom g", "have \"(f ++ g) y = Some x\""], ["proof (prove)\nusing this:\n  x \\<notin> ran g\n  x \\<in> ran f\n  f y = Some x\n  y \\<in> dom f\n  y \\<notin> dom g\n\ngoal (1 subgoal):\n 1. (f ++ g) y = Some x", "by (simp)"], ["proof (state)\nthis:\n  (f ++ g) y = Some x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n    \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "with assms minj ran dom"], ["proof (chain)\npicking this:\n  inj_on f (dom f)\n  inj_on g (dom g)\n  dom f \\<inter> dom g = {}\n  ran f \\<inter> ran g = {}\n  inj_on (f ++ g) (dom (f ++ g))\n  x \\<notin> ran g\n  x \\<in> ran f\n  f y = Some x\n  y \\<in> dom f\n  y \\<notin> dom g\n  (f ++ g) y = Some x", "show \"map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\""], ["proof (prove)\nusing this:\n  inj_on f (dom f)\n  inj_on g (dom g)\n  dom f \\<inter> dom g = {}\n  ran f \\<inter> ran g = {}\n  inj_on (f ++ g) (dom (f ++ g))\n  x \\<notin> ran g\n  x \\<in> ran f\n  f y = Some x\n  y \\<in> dom f\n  y \\<notin> dom g\n  (f ++ g) y = Some x\n\ngoal (1 subgoal):\n 1. map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "by simp"], ["proof (state)\nthis:\n  map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n  \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n\ngoal (1 subgoal):\n 1. \\<And>x. map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n  \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n\ngoal (1 subgoal):\n 1. \\<And>x. map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "from assms minj"], ["proof (chain)\npicking this:\n  inj_on f (dom f)\n  inj_on g (dom g)\n  dom f \\<inter> dom g = {}\n  ran f \\<inter> ran g = {}\n  inj_on (f ++ g) (dom (f ++ g))", "have \"\\<lbrakk> x \\<notin> ran g; x \\<notin> ran f \\<rbrakk> \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\""], ["proof (prove)\nusing this:\n  inj_on f (dom f)\n  inj_on g (dom g)\n  dom f \\<inter> dom g = {}\n  ran f \\<inter> ran g = {}\n  inj_on (f ++ g) (dom (f ++ g))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> ran g; x \\<notin> ran f\\<rbrakk>\n    \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "apply (auto simp add:map_inv_def ran_def map_add_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>a. g a \\<noteq> Some x;\n        \\<forall>a. f a \\<noteq> Some x; inj_on f (dom f); inj_on g (dom g);\n        dom f \\<inter> dom g = {};\n        {b. \\<exists>a. f a = Some b} \\<inter>\n        {b. \\<exists>a. g a = Some b} =\n        {};\n        inj_on\n         (\\<lambda>x.\n             case g x of None \\<Rightarrow> f x\n             | Some y \\<Rightarrow> Some y)\n         (dom (\\<lambda>x.\n                  case g x of None \\<Rightarrow> f x\n                  | Some y \\<Rightarrow> Some y));\n        (case g a of None \\<Rightarrow> f a | Some x \\<Rightarrow> Some x) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis dom_left_map_add map_add_def map_add_dom_app_simps(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<notin> ran g; x \\<notin> ran f\\<rbrakk>\n  \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n\ngoal (1 subgoal):\n 1. \\<And>x. map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> ran g \\<Longrightarrow>\n  map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n  \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n  \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n  \\<lbrakk>x \\<notin> ran g; x \\<notin> ran f\\<rbrakk>\n  \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "show \"map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\""], ["proof (prove)\nusing this:\n  x \\<in> ran g \\<Longrightarrow>\n  map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n  \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n  \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n  \\<lbrakk>x \\<notin> ran g; x \\<notin> ran f\\<rbrakk>\n  \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n\ngoal (1 subgoal):\n 1. map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "apply (case_tac \"x \\<in> ran g\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> ran g \\<Longrightarrow>\n             map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n     \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     \\<lbrakk>x \\<notin> ran g; x \\<notin> ran f\\<rbrakk>\n     \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     x \\<in> ran g\\<rbrakk>\n    \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n 2. \\<lbrakk>x \\<in> ran g \\<Longrightarrow>\n             map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n     \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     \\<lbrakk>x \\<notin> ran g; x \\<notin> ran f\\<rbrakk>\n     \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     x \\<notin> ran g\\<rbrakk>\n    \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> ran g \\<Longrightarrow>\n             map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n     \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     \\<lbrakk>x \\<notin> ran g; x \\<notin> ran f\\<rbrakk>\n     \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     x \\<notin> ran g\\<rbrakk>\n    \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "apply (case_tac \"x \\<in> ran f\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> ran g \\<Longrightarrow>\n             map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n     \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     \\<lbrakk>x \\<notin> ran g; x \\<notin> ran f\\<rbrakk>\n     \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n    \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n 2. \\<lbrakk>x \\<in> ran g \\<Longrightarrow>\n             map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     \\<lbrakk>x \\<notin> ran g; x \\<in> ran f\\<rbrakk>\n     \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     \\<lbrakk>x \\<notin> ran g; x \\<notin> ran f\\<rbrakk>\n     \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x;\n     x \\<notin> ran g; x \\<notin> ran f\\<rbrakk>\n    \\<Longrightarrow> map_inv (f ++ g) x = (map_inv f ++ map_inv g) x", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_inv (f ++ g) x = (map_inv f ++ map_inv g) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_add_lookup [simp]:\n  \"x \\<notin> dom f \\<Longrightarrow> ([x \\<mapsto> y] ++ f) x = Some y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom f \\<Longrightarrow> ([x \\<mapsto> y] ++ f) x = Some y", "by (simp add:map_add_def dom_def)"], ["", "lemma map_add_Some: \"Some ++ f = map_id_on (- dom f) ++ f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some ++ f = map_id_on (- dom f) ++ f", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (Some ++ f) x = (map_id_on (- dom f) ++ f) x", "apply (rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (Some ++ f) x = (map_id_on (- dom f) ++ f) x", "apply (case_tac \"x \\<in> dom f\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> dom f \\<Longrightarrow>\n       (Some ++ f) x = (map_id_on (- dom f) ++ f) x\n 2. \\<And>x.\n       x \\<notin> dom f \\<Longrightarrow>\n       (Some ++ f) x = (map_id_on (- dom f) ++ f) x", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distinct_map_dom:\n  \"x \\<notin> set xs \\<Longrightarrow> x \\<notin> dom [xs [\\<mapsto>] ys]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> x \\<notin> dom [xs [\\<mapsto>] ys]", "by (simp add:dom_def)"], ["", "lemma distinct_map_ran:\n  \"\\<lbrakk> distinct xs; y \\<notin> set ys; length xs = length ys \\<rbrakk> \\<Longrightarrow>\n   y \\<notin> ran ([xs [\\<mapsto>] ys])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; y \\<notin> set ys; length xs = length ys\\<rbrakk>\n    \\<Longrightarrow> y \\<notin> ran [xs [\\<mapsto>] ys]", "apply (simp add:map_upds_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; y \\<notin> set ys; length xs = length ys\\<rbrakk>\n    \\<Longrightarrow> y \\<notin> ran (map_of (rev (zip xs ys)))", "apply (subgoal_tac \"distinct (map fst (rev (zip xs ys)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; y \\<notin> set ys; length xs = length ys;\n     distinct (map fst (rev (zip xs ys)))\\<rbrakk>\n    \\<Longrightarrow> y \\<notin> ran (map_of (rev (zip xs ys)))\n 2. \\<lbrakk>distinct xs; y \\<notin> set ys; length xs = length ys\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (rev (zip xs ys)))", "apply (simp add:ran_distinct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; y \\<notin> set ys; length xs = length ys;\n     distinct (map fst (rev (zip xs ys)))\\<rbrakk>\n    \\<Longrightarrow> y \\<notin> snd ` set (zip xs ys)\n 2. \\<lbrakk>distinct xs; y \\<notin> set ys; length xs = length ys\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (rev (zip xs ys)))", "apply (metis (hide_lams, no_types) image_iff set_zip_rightD surjective_pairing)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; y \\<notin> set ys; length xs = length ys\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (rev (zip xs ys)))", "apply (simp add:zip_rev[THEN sym])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma maplets_lookup[rule_format,dest]:\n  \"\\<lbrakk> length xs = length ys; distinct xs \\<rbrakk> \\<Longrightarrow>\n     \\<forall> y. [xs [\\<mapsto>] ys] x = Some y \\<longrightarrow> y \\<in> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys; distinct xs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y.\n                         [xs [\\<mapsto>] ys] x = Some y \\<longrightarrow>\n                         y \\<in> set ys", "by (induct rule:list_induct2, auto)"], ["", "lemma maplets_distinct_inj [intro]:\n  \"\\<lbrakk> length xs = length ys; distinct xs; distinct ys; set xs \\<inter> set ys = {} \\<rbrakk> \\<Longrightarrow>\n   inj_on [xs [\\<mapsto>] ys] (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys; distinct xs; distinct ys;\n     set xs \\<inter> set ys = {}\\<rbrakk>\n    \\<Longrightarrow> inj_on [xs [\\<mapsto>] ys] (set xs)", "apply (induct rule:list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; distinct []; set [] \\<inter> set [] = {}\\<rbrakk>\n    \\<Longrightarrow> inj_on [[] [\\<mapsto>] []] (set [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>distinct xs; distinct ys;\n         set xs \\<inter> set ys = {}\\<rbrakk>\n        \\<Longrightarrow> inj_on [xs [\\<mapsto>] ys] (set xs);\n        distinct (x # xs); distinct (y # ys);\n        set (x # xs) \\<inter> set (y # ys) = {}\\<rbrakk>\n       \\<Longrightarrow> inj_on [x # xs [\\<mapsto>] y # ys] (set (x # xs))", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> inj_on [xs [\\<mapsto>] ys, x \\<mapsto> y]\n                          (set xs) \\<and>\n                         Some y\n                         \\<notin> [xs [\\<mapsto>] ys] `\n                                  (set xs \\<inter> {xa. xa \\<noteq> x})", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> inj_on [xs [\\<mapsto>] ys, x \\<mapsto> y] (set xs)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> Some y\n                         \\<notin> [xs [\\<mapsto>] ys] `\n                                  (set xs \\<inter> {xa. xa \\<noteq> x})", "apply (rule inj_onI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys xa ya.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {};\n        xa \\<in> set xs; ya \\<in> set xs;\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] xa =\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] ya\\<rbrakk>\n       \\<Longrightarrow> xa = ya\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> Some y\n                         \\<notin> [xs [\\<mapsto>] ys] `\n                                  (set xs \\<inter> {xa. xa \\<noteq> x})", "apply (rename_tac x xs y ys xa ya)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys xa ya.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {};\n        xa \\<in> set xs; ya \\<in> set xs;\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] xa =\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] ya\\<rbrakk>\n       \\<Longrightarrow> xa = ya\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> Some y\n                         \\<notin> [xs [\\<mapsto>] ys] `\n                                  (set xs \\<inter> {xa. xa \\<noteq> x})", "apply (case_tac \"xa = x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs y ys xa ya.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {};\n        xa \\<in> set xs; ya \\<in> set xs;\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] xa =\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] ya;\n        xa = x\\<rbrakk>\n       \\<Longrightarrow> xa = ya\n 2. \\<And>x xs y ys xa ya.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {};\n        xa \\<in> set xs; ya \\<in> set xs;\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] xa =\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] ya;\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> xa = ya\n 3. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> Some y\n                         \\<notin> [xs [\\<mapsto>] ys] `\n                                  (set xs \\<inter> {xa. xa \\<noteq> x})", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys xa ya.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {};\n        xa \\<in> set xs; ya \\<in> set xs;\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] xa =\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] ya;\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> xa = ya\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> Some y\n                         \\<notin> [xs [\\<mapsto>] ys] `\n                                  (set xs \\<inter> {xa. xa \\<noteq> x})", "apply (case_tac \"xa = y\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs y ys xa ya.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {};\n        xa \\<in> set xs; ya \\<in> set xs;\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] xa =\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] ya;\n        xa \\<noteq> x; xa = y\\<rbrakk>\n       \\<Longrightarrow> xa = ya\n 2. \\<And>x xs y ys xa ya.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {};\n        xa \\<in> set xs; ya \\<in> set xs;\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] xa =\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] ya;\n        xa \\<noteq> x; xa \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xa = ya\n 3. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> Some y\n                         \\<notin> [xs [\\<mapsto>] ys] `\n                                  (set xs \\<inter> {xa. xa \\<noteq> x})", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys xa ya.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {};\n        xa \\<in> set xs; ya \\<in> set xs;\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] xa =\n        [xs [\\<mapsto>] ys, x \\<mapsto> y] ya;\n        xa \\<noteq> x; xa \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xa = ya\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> Some y\n                         \\<notin> [xs [\\<mapsto>] ys] `\n                                  (set xs \\<inter> {xa. xa \\<noteq> x})", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys xa ya.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {};\n        xa \\<in> set xs; ya \\<in> set xs;\n        [xs [\\<mapsto>] ys] xa =\n        (if ya = x then Some y else [xs [\\<mapsto>] ys] ya);\n        xa \\<noteq> x; xa \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xa = ya\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> Some y\n                         \\<notin> [xs [\\<mapsto>] ys] `\n                                  (set xs \\<inter> {xa. xa \\<noteq> x})", "apply (case_tac \"ya = x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs y ys xa ya.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {};\n        xa \\<in> set xs; ya \\<in> set xs;\n        [xs [\\<mapsto>] ys] xa =\n        (if ya = x then Some y else [xs [\\<mapsto>] ys] ya);\n        xa \\<noteq> x; xa \\<noteq> y; ya = x\\<rbrakk>\n       \\<Longrightarrow> xa = ya\n 2. \\<And>x xs y ys xa ya.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {};\n        xa \\<in> set xs; ya \\<in> set xs;\n        [xs [\\<mapsto>] ys] xa =\n        (if ya = x then Some y else [xs [\\<mapsto>] ys] ya);\n        xa \\<noteq> x; xa \\<noteq> y; ya \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> xa = ya\n 3. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> Some y\n                         \\<notin> [xs [\\<mapsto>] ys] `\n                                  (set xs \\<inter> {xa. xa \\<noteq> x})", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys xa ya.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {};\n        xa \\<in> set xs; ya \\<in> set xs;\n        [xs [\\<mapsto>] ys] xa =\n        (if ya = x then Some y else [xs [\\<mapsto>] ys] ya);\n        xa \\<noteq> x; xa \\<noteq> y; ya \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> xa = ya\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> Some y\n                         \\<notin> [xs [\\<mapsto>] ys] `\n                                  (set xs \\<inter> {xa. xa \\<noteq> x})", "apply (simp add:inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> Some y\n                         \\<notin> [xs [\\<mapsto>] ys] `\n                                  (set xs \\<inter> {xa. xa \\<noteq> x})", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys xa.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs; distinct xs; y \\<notin> set ys; distinct ys;\n        y \\<noteq> x; y \\<notin> set xs; x \\<notin> set ys;\n        set xs \\<inter> set ys = {}; Some y = [xs [\\<mapsto>] ys] xa;\n        xa \\<in> set xs; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rename_tac x xs y ys xa)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys xa.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs; distinct xs; y \\<notin> set ys; distinct ys;\n        y \\<noteq> x; y \\<notin> set xs; x \\<notin> set ys;\n        set xs \\<inter> set ys = {}; Some y = [xs [\\<mapsto>] ys] xa;\n        xa \\<in> set xs; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"xa = y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys xa.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs; distinct xs; y \\<notin> set ys; distinct ys;\n        y \\<noteq> x; y \\<notin> set xs; x \\<notin> set ys;\n        set xs \\<inter> set ys = {}; Some y = [xs [\\<mapsto>] ys] xa;\n        xa \\<in> set xs; xa \\<noteq> x; xa = y\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x xs y ys xa.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs; distinct xs; y \\<notin> set ys; distinct ys;\n        y \\<noteq> x; y \\<notin> set xs; x \\<notin> set ys;\n        set xs \\<inter> set ys = {}; Some y = [xs [\\<mapsto>] ys] xa;\n        xa \\<in> set xs; xa \\<noteq> x; xa \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys xa.\n       \\<lbrakk>length xs = length ys; inj_on [xs [\\<mapsto>] ys] (set xs);\n        x \\<notin> set xs; distinct xs; y \\<notin> set ys; distinct ys;\n        y \\<noteq> x; y \\<notin> set xs; x \\<notin> set ys;\n        set xs \\<inter> set ys = {}; Some y = [xs [\\<mapsto>] ys] xa;\n        xa \\<in> set xs; xa \\<noteq> x; xa \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis maplets_lookup)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_inv_maplet[simp]: \"map_inv [x \\<mapsto> y] = [y \\<mapsto> x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_inv [x \\<mapsto> y] = [y \\<mapsto> x]", "by (auto simp add:map_inv_def)"], ["", "lemma map_inv_maplets [simp]:\n  \"\\<lbrakk> length xs = length ys; distinct xs; distinct ys; set xs \\<inter> set ys = {} \\<rbrakk> \\<Longrightarrow>\n  map_inv [xs [\\<mapsto>] ys] = [ys [\\<mapsto>] xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys; distinct xs; distinct ys;\n     set xs \\<inter> set ys = {}\\<rbrakk>\n    \\<Longrightarrow> map_inv [xs [\\<mapsto>] ys] = [ys [\\<mapsto>] xs]", "apply (induct rule:list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; distinct []; set [] \\<inter> set [] = {}\\<rbrakk>\n    \\<Longrightarrow> map_inv [[] [\\<mapsto>] []] = [[] [\\<mapsto>] []]\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>distinct xs; distinct ys;\n         set xs \\<inter> set ys = {}\\<rbrakk>\n        \\<Longrightarrow> map_inv [xs [\\<mapsto>] ys] = [ys [\\<mapsto>] xs];\n        distinct (x # xs); distinct (y # ys);\n        set (x # xs) \\<inter> set (y # ys) = {}\\<rbrakk>\n       \\<Longrightarrow> map_inv [x # xs [\\<mapsto>] y # ys] =\n                         [y # ys [\\<mapsto>] x # xs]", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        map_inv [xs [\\<mapsto>] ys] = [ys [\\<mapsto>] xs];\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> map_inv [xs [\\<mapsto>] ys, x \\<mapsto> y] =\n                         [ys [\\<mapsto>] xs, y \\<mapsto> x]", "apply (rename_tac x xs y ys)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        map_inv [xs [\\<mapsto>] ys] = [ys [\\<mapsto>] xs];\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> map_inv [xs [\\<mapsto>] ys, x \\<mapsto> y] =\n                         [ys [\\<mapsto>] xs, y \\<mapsto> x]", "apply (subgoal_tac \"map_inv ([xs [\\<mapsto>] ys] ++ [x \\<mapsto> y]) = map_inv [xs [\\<mapsto>] ys] ++ map_inv [x \\<mapsto> y]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        map_inv [xs [\\<mapsto>] ys] = [ys [\\<mapsto>] xs];\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {};\n        map_inv ([xs [\\<mapsto>] ys] ++ [x \\<mapsto> y]) =\n        map_inv [xs [\\<mapsto>] ys] ++ map_inv [x \\<mapsto> y]\\<rbrakk>\n       \\<Longrightarrow> map_inv [xs [\\<mapsto>] ys, x \\<mapsto> y] =\n                         [ys [\\<mapsto>] xs, y \\<mapsto> x]\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        map_inv [xs [\\<mapsto>] ys] = [ys [\\<mapsto>] xs];\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> map_inv ([xs [\\<mapsto>] ys] ++ [x \\<mapsto> y]) =\n                         map_inv [xs [\\<mapsto>] ys] ++\n                         map_inv [x \\<mapsto> y]", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        map_inv [xs [\\<mapsto>] ys] = [ys [\\<mapsto>] xs];\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> map_inv ([xs [\\<mapsto>] ys] ++ [x \\<mapsto> y]) =\n                         map_inv [xs [\\<mapsto>] ys] ++\n                         map_inv [x \\<mapsto> y]", "apply (rule map_inv_add)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        map_inv [xs [\\<mapsto>] ys] = [ys [\\<mapsto>] xs];\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> inj_on [xs [\\<mapsto>] ys]\n                          (dom [xs [\\<mapsto>] ys])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        map_inv [xs [\\<mapsto>] ys] = [ys [\\<mapsto>] xs];\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> inj_on [x \\<mapsto> y] (dom [x \\<mapsto> y])\n 3. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        map_inv [xs [\\<mapsto>] ys] = [ys [\\<mapsto>] xs];\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> dom [xs [\\<mapsto>] ys] \\<inter>\n                         dom [x \\<mapsto> y] =\n                         {}\n 4. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        map_inv [xs [\\<mapsto>] ys] = [ys [\\<mapsto>] xs];\n        x \\<notin> set xs \\<and> distinct xs;\n        y \\<notin> set ys \\<and> distinct ys;\n        y \\<noteq> x \\<and>\n        y \\<notin> set xs \\<and>\n        x \\<notin> set ys \\<and> set xs \\<inter> set ys = {}\\<rbrakk>\n       \\<Longrightarrow> ran [xs [\\<mapsto>] ys] \\<inter>\n                         ran [x \\<mapsto> y] =\n                         {}", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma maplets_lookup_nth [rule_format,simp]:\n  \"\\<lbrakk> length xs = length ys; distinct xs \\<rbrakk> \\<Longrightarrow>\n   \\<forall> i < length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys; distinct xs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length ys.\n                         [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i)", "apply (induct rule:list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    \\<forall>i<length []. [[] [\\<mapsto>] []] ([] ! i) = Some ([] ! i)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        distinct xs \\<Longrightarrow>\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (y # ys).\n                            [x # xs [\\<mapsto>] y # ys] ((x # xs) ! i) =\n                            Some ((y # ys) ! i)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        x \\<notin> set xs; distinct xs; (x # xs) ! i = x;\n        i < Suc (length ys)\\<rbrakk>\n       \\<Longrightarrow> y = (y # ys) ! i\n 2. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        x \\<notin> set xs; distinct xs; (x # xs) ! i \\<noteq> x;\n        i < Suc (length ys)\\<rbrakk>\n       \\<Longrightarrow> [xs [\\<mapsto>] ys] ((x # xs) ! i) =\n                         Some ((y # ys) ! i)", "apply (rename_tac x xs y ys i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        x \\<notin> set xs; distinct xs; (x # xs) ! i = x;\n        i < Suc (length ys)\\<rbrakk>\n       \\<Longrightarrow> y = (y # ys) ! i\n 2. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        x \\<notin> set xs; distinct xs; (x # xs) ! i \\<noteq> x;\n        i < Suc (length ys)\\<rbrakk>\n       \\<Longrightarrow> [xs [\\<mapsto>] ys] ((x # xs) ! i) =\n                         Some ((y # ys) ! i)", "apply (case_tac i)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        x \\<notin> set xs; distinct xs; (x # xs) ! i = x;\n        i < Suc (length ys); i = 0\\<rbrakk>\n       \\<Longrightarrow> y = (y # ys) ! i\n 2. \\<And>x xs y ys i nat.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        x \\<notin> set xs; distinct xs; (x # xs) ! i = x;\n        i < Suc (length ys); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> y = (y # ys) ! i\n 3. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        x \\<notin> set xs; distinct xs; (x # xs) ! i \\<noteq> x;\n        i < Suc (length ys)\\<rbrakk>\n       \\<Longrightarrow> [xs [\\<mapsto>] ys] ((x # xs) ! i) =\n                         Some ((y # ys) ! i)", "apply (simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys i nat.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        x \\<notin> set xs; distinct xs; xs ! nat = x; nat < length ys;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> y = ys ! nat\n 2. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        x \\<notin> set xs; distinct xs; (x # xs) ! i \\<noteq> x;\n        i < Suc (length ys)\\<rbrakk>\n       \\<Longrightarrow> [xs [\\<mapsto>] ys] ((x # xs) ! i) =\n                         Some ((y # ys) ! i)", "apply (metis nth_mem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        x \\<notin> set xs; distinct xs; (x # xs) ! i \\<noteq> x;\n        i < Suc (length ys)\\<rbrakk>\n       \\<Longrightarrow> [xs [\\<mapsto>] ys] ((x # xs) ! i) =\n                         Some ((y # ys) ! i)", "apply (rename_tac x xs y ys i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        x \\<notin> set xs; distinct xs; (x # xs) ! i \\<noteq> x;\n        i < Suc (length ys)\\<rbrakk>\n       \\<Longrightarrow> [xs [\\<mapsto>] ys] ((x # xs) ! i) =\n                         Some ((y # ys) ! i)", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        x \\<notin> set xs; distinct xs; (x # xs) ! i \\<noteq> x;\n        i < Suc (length ys); i = 0\\<rbrakk>\n       \\<Longrightarrow> [xs [\\<mapsto>] ys] ((x # xs) ! i) =\n                         Some ((y # ys) ! i)\n 2. \\<And>x xs y ys i nat.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length ys. [xs [\\<mapsto>] ys] (xs ! i) = Some (ys ! i);\n        x \\<notin> set xs; distinct xs; (x # xs) ! i \\<noteq> x;\n        i < Suc (length ys); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> [xs [\\<mapsto>] ys] ((x # xs) ! i) =\n                         Some ((y # ys) ! i)", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem inv_map_inv:\n  \"\\<lbrakk> inj_on f (dom f); ran f = dom f \\<rbrakk>\n  \\<Longrightarrow> inv (the \\<circ> (Some ++ f)) = the \\<circ> map_inv (Some ++ f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f (dom f); ran f = dom f\\<rbrakk>\n    \\<Longrightarrow> inv (the \\<circ> Some ++ f) =\n                      the \\<circ> map_inv (Some ++ f)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f\\<rbrakk>\n       \\<Longrightarrow> inv (the \\<circ> Some ++ f) x =\n                         (the \\<circ> map_inv (Some ++ f)) x", "apply (simp add:map_add_Some)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f\\<rbrakk>\n       \\<Longrightarrow> inv (the \\<circ> map_id_on (- dom f) ++ f) x =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (simp add:inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (case_tac \"\\<exists> y. f y = Some x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<exists>y. f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)\n 2. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<nexists>y. f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)\n 2. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<nexists>y. f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (rename_tac x y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)\n 2. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<nexists>y. f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (subgoal_tac \"x \\<in> ran f\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x;\n        x \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)\n 2. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ran f\n 3. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<nexists>y. f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (subgoal_tac \"y \\<in> dom f\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x;\n        x \\<in> ran f; y \\<in> dom f\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)\n 2. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x;\n        x \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> y \\<in> dom f\n 3. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ran f\n 4. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<nexists>y. f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x;\n        x \\<in> dom f; y \\<in> dom f\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         y\n 2. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x;\n        x \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> y \\<in> dom f\n 3. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ran f\n 4. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<nexists>y. f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (rule some_equality)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x;\n        x \\<in> dom f; y \\<in> dom f\\<rbrakk>\n       \\<Longrightarrow> the ((map_id_on (- dom f) ++ f) y) = x\n 2. \\<And>x y xa.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x;\n        x \\<in> dom f; y \\<in> dom f;\n        the ((map_id_on (- dom f) ++ f) xa) = x\\<rbrakk>\n       \\<Longrightarrow> xa = y\n 3. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x;\n        x \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> y \\<in> dom f\n 4. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ran f\n 5. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<nexists>y. f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y xa.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x;\n        x \\<in> dom f; y \\<in> dom f;\n        the ((map_id_on (- dom f) ++ f) xa) = x\\<rbrakk>\n       \\<Longrightarrow> xa = y\n 2. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x;\n        x \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> y \\<in> dom f\n 3. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ran f\n 4. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<nexists>y. f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (metis (hide_lams, mono_tags) domD domI dom_left_map_add inj_on_contraD map_add_Some map_add_dom_app_simps(3) option.sel)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x;\n        x \\<in> ran f\\<rbrakk>\n       \\<Longrightarrow> y \\<in> dom f\n 2. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ran f\n 3. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<nexists>y. f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (simp add:dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f; f y = Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ran f\n 2. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<nexists>y. f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (metis ranI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<nexists>y. f y = Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<forall>y. f y \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<forall>y. f y \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)", "apply (subgoal_tac \"x \\<notin> ran f\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<forall>y. f y \\<noteq> Some x; x \\<notin> ran f\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         the ((map_id_on (- dom f) ++ map_inv f) x)\n 2. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<forall>y. f y \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> ran f", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<forall>y. f y \\<noteq> Some x; x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> (SOME xa.\n                             the ((map_id_on (- dom f) ++ f) xa) = x) =\n                         x\n 2. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<forall>y. f y \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> ran f", "apply (rule some_equality)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<forall>y. f y \\<noteq> Some x; x \\<notin> dom f\\<rbrakk>\n       \\<Longrightarrow> the ((map_id_on (- dom f) ++ f) x) = x\n 2. \\<And>x xa.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<forall>y. f y \\<noteq> Some x; x \\<notin> dom f;\n        the ((map_id_on (- dom f) ++ f) xa) = x\\<rbrakk>\n       \\<Longrightarrow> xa = x\n 3. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<forall>y. f y \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> ran f", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<forall>y. f y \\<noteq> Some x; x \\<notin> dom f;\n        the ((map_id_on (- dom f) ++ f) xa) = x\\<rbrakk>\n       \\<Longrightarrow> xa = x\n 2. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<forall>y. f y \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> ran f", "apply (metis domD dom_left_map_add map_add_Some map_add_dom_app_simps(3) option.sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f (dom f); ran f = dom f;\n        \\<forall>y. f y \\<noteq> Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> ran f", "apply (metis dom_image_ran image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_comp_dom: \"dom (g \\<circ>\\<^sub>m f) \\<subseteq> dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (g \\<circ>\\<^sub>m f) \\<subseteq> dom f", "by (metis (lifting, full_types) Collect_mono dom_def map_comp_simps(1))"], ["", "lemma map_comp_assoc: \"f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h) = f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h) =\n    f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n       (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n       (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x", "show \"(f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x = (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n    (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x", "proof (cases \"h x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. h x = None \\<Longrightarrow>\n    (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n    (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x\n 2. \\<And>a.\n       h x = Some a \\<Longrightarrow>\n       (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n       (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x", "case None"], ["proof (state)\nthis:\n  h x = None\n\ngoal (2 subgoals):\n 1. h x = None \\<Longrightarrow>\n    (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n    (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x\n 2. \\<And>a.\n       h x = Some a \\<Longrightarrow>\n       (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n       (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  h x = None\n\ngoal (1 subgoal):\n 1. (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n    (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x", "by (auto simp add: map_comp_def)"], ["proof (state)\nthis:\n  (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n  (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       h x = Some a \\<Longrightarrow>\n       (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n       (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       h x = Some a \\<Longrightarrow>\n       (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n       (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x", "case (Some y)"], ["proof (state)\nthis:\n  h x = Some y\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       h x = Some a \\<Longrightarrow>\n       (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n       (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  h x = Some y\n\ngoal (1 subgoal):\n 1. (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n    (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x", "by (auto simp add: map_comp_def)"], ["proof (state)\nthis:\n  (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n  (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f \\<circ>\\<^sub>m (g \\<circ>\\<^sub>m h)) x =\n  (f \\<circ>\\<^sub>m g \\<circ>\\<^sub>m h) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_comp_runit [simp]: \"f \\<circ>\\<^sub>m Some = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ>\\<^sub>m Some = f", "by (simp add: map_comp_def)"], ["", "lemma map_comp_lunit [simp]: \"Some \\<circ>\\<^sub>m f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some \\<circ>\\<^sub>m f = f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (Some \\<circ>\\<^sub>m f) x = f x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (Some \\<circ>\\<^sub>m f) x = f x", "show \"(Some \\<circ>\\<^sub>m f) x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Some \\<circ>\\<^sub>m f) x = f x", "proof (cases \"f x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f x = None \\<Longrightarrow> (Some \\<circ>\\<^sub>m f) x = f x\n 2. \\<And>a. f x = Some a \\<Longrightarrow> (Some \\<circ>\\<^sub>m f) x = f x", "case None"], ["proof (state)\nthis:\n  f x = None\n\ngoal (2 subgoals):\n 1. f x = None \\<Longrightarrow> (Some \\<circ>\\<^sub>m f) x = f x\n 2. \\<And>a. f x = Some a \\<Longrightarrow> (Some \\<circ>\\<^sub>m f) x = f x", "thus ?thesis"], ["proof (prove)\nusing this:\n  f x = None\n\ngoal (1 subgoal):\n 1. (Some \\<circ>\\<^sub>m f) x = f x", "by (simp add: map_comp_def)"], ["proof (state)\nthis:\n  (Some \\<circ>\\<^sub>m f) x = f x\n\ngoal (1 subgoal):\n 1. \\<And>a. f x = Some a \\<Longrightarrow> (Some \\<circ>\\<^sub>m f) x = f x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. f x = Some a \\<Longrightarrow> (Some \\<circ>\\<^sub>m f) x = f x", "case (Some y)"], ["proof (state)\nthis:\n  f x = Some y\n\ngoal (1 subgoal):\n 1. \\<And>a. f x = Some a \\<Longrightarrow> (Some \\<circ>\\<^sub>m f) x = f x", "thus ?thesis"], ["proof (prove)\nusing this:\n  f x = Some y\n\ngoal (1 subgoal):\n 1. (Some \\<circ>\\<^sub>m f) x = f x", "by (simp add: map_comp_def)"], ["proof (state)\nthis:\n  (Some \\<circ>\\<^sub>m f) x = f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Some \\<circ>\\<^sub>m f) x = f x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_comp_apply [simp]: \"(f \\<circ>\\<^sub>m g) x = g(x) >>= f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ>\\<^sub>m g) x = g x \\<bind> f", "by (auto simp add: map_comp_def option.case_eq_if)"], ["", "subsection \\<open> Merging of compatible maps \\<close>"], ["", "definition comp_map :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> ('a \\<rightharpoonup> 'b) \\<Rightarrow> bool\" (infixl \"\\<parallel>\\<^sub>m\" 60) where\n\"comp_map f g = (\\<forall> x \\<in> dom(f) \\<inter> dom(g). the(f(x)) = the(g(x)))\""], ["", "lemma comp_map_unit: \"Map.empty \\<parallel>\\<^sub>m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map.empty \\<parallel>\\<^sub>m f", "by (simp add: comp_map_def)"], ["", "lemma comp_map_refl: \"f \\<parallel>\\<^sub>m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<parallel>\\<^sub>m f", "by (simp add: comp_map_def)"], ["", "lemma comp_map_sym: \"f \\<parallel>\\<^sub>m g \\<Longrightarrow> g \\<parallel>\\<^sub>m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<parallel>\\<^sub>m g \\<Longrightarrow> g \\<parallel>\\<^sub>m f", "by (simp add: comp_map_def)"], ["", "definition merge :: \"('a \\<rightharpoonup> 'b) set \\<Rightarrow> 'a \\<rightharpoonup> 'b\" where\n\"merge fs =\n  (\\<lambda> x. if (\\<exists> f \\<in> fs. x \\<in> dom(f)) then (THE y. \\<forall> f \\<in> fs. x \\<in> dom(f) \\<longrightarrow> f(x) = y) else None)\""], ["", "lemma merge_empty: \"merge {} = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge {} = Map.empty", "by (simp add: merge_def)"], ["", "lemma merge_singleton: \"merge {f} = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge {f} = f", "apply (auto intro!: ext simp add: merge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. None \\<noteq> f x \\<Longrightarrow> \\<exists>y. f x = Some y", "using option.collapse"], ["proof (prove)\nusing this:\n  ?option \\<noteq> None \\<Longrightarrow> Some (the ?option) = ?option\n\ngoal (1 subgoal):\n 1. \\<And>x. None \\<noteq> f x \\<Longrightarrow> \\<exists>y. f x = Some y", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open> Conversion between lists and maps \\<close>"], ["", "definition map_of_list :: \"'a list \\<Rightarrow> (nat \\<rightharpoonup> 'a)\" where\n\"map_of_list xs = (\\<lambda> i. if (i < length xs) then Some (xs!i) else None)\""], ["", "lemma map_of_list_nil [simp]: \"map_of_list [] = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of_list [] = Map.empty", "by (simp add: map_of_list_def)"], ["", "lemma dom_map_of_list [simp]: \"dom (map_of_list xs) = {0..<length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of_list xs) = {0..<length xs}", "by (auto simp add: map_of_list_def dom_def)"], ["", "lemma ran_map_of_list [simp]: \"ran (map_of_list xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (map_of_list xs) = set xs", "apply (simp add: ran_def map_of_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {b. \\<exists>a.\n           (a < length xs \\<longrightarrow> xs ! a = b) \\<and>\n           a < length xs} =\n    set xs", "apply (safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a. a < length xs \\<Longrightarrow> xs ! a \\<in> set xs\n 2. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       \\<exists>a.\n          (a < length xs \\<longrightarrow> xs ! a = x) \\<and> a < length xs", "apply (force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       \\<exists>a.\n          (a < length xs \\<longrightarrow> xs ! a = x) \\<and> a < length xs", "apply (meson in_set_conv_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition list_of_map :: \"(nat \\<rightharpoonup> 'a) \\<Rightarrow> 'a list\" where\n\"list_of_map f = (if (f = Map.empty) then [] else map (the \\<circ> f) [0 ..< Suc(GREATEST x. x \\<in> dom f)])\""], ["", "lemma list_of_map_empty [simp]: \"list_of_map Map.empty = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_map Map.empty = []", "by (simp add: list_of_map_def)"], ["", "definition list_of_map' :: \"(nat \\<rightharpoonup> 'a) \\<rightharpoonup> 'a list\" where\n\"list_of_map' f = (if (\\<exists> n. dom f = {0..<n}) then Some (list_of_map f) else None)\""], ["", "lemma map_of_list_inv [simp]: \"list_of_map (map_of_list xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_map (map_of_list xs) = xs", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_of_map (map_of_list xs) = xs\n 2. xs \\<noteq> [] \\<Longrightarrow> list_of_map (map_of_list xs) = xs", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_of_map (map_of_list xs) = xs\n 2. xs \\<noteq> [] \\<Longrightarrow> list_of_map (map_of_list xs) = xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. list_of_map (map_of_list xs) = xs", "by (simp)"], ["proof (state)\nthis:\n  list_of_map (map_of_list xs) = xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_of_map (map_of_list xs) = xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_of_map (map_of_list xs) = xs", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_of_map (map_of_list xs) = xs", "moreover"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_of_map (map_of_list xs) = xs", "hence \"(GREATEST x. x \\<in> dom (map_of_list xs)) = length xs - 1\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (GREATEST x. x \\<in> dom (map_of_list xs)) = length xs - 1", "by (auto intro: Greatest_equality)"], ["proof (state)\nthis:\n  (GREATEST x. x \\<in> dom (map_of_list xs)) = length xs - 1\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_of_map (map_of_list xs) = xs", "moreover"], ["proof (state)\nthis:\n  (GREATEST x. x \\<in> dom (map_of_list xs)) = length xs - 1\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_of_map (map_of_list xs) = xs", "from False"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "have \"map_of_list xs \\<noteq> Map.empty\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. map_of_list xs \\<noteq> Map.empty", "by (metis ran_empty ran_map_of_list set_empty)"], ["proof (state)\nthis:\n  map_of_list xs \\<noteq> Map.empty\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_of_map (map_of_list xs) = xs", "ultimately"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  (GREATEST x. x \\<in> dom (map_of_list xs)) = length xs - 1\n  map_of_list xs \\<noteq> Map.empty", "show ?thesis"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  (GREATEST x. x \\<in> dom (map_of_list xs)) = length xs - 1\n  map_of_list xs \\<noteq> Map.empty\n\ngoal (1 subgoal):\n 1. list_of_map (map_of_list xs) = xs", "by (auto simp add: list_of_map_def map_of_list_def intro: nth_equalityI)"], ["proof (state)\nthis:\n  list_of_map (map_of_list xs) = xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Map Comprehension \\<close>"], ["", "text \\<open> Map comprehension simply converts a relation built through set comprehension into a map. \\<close>"], ["", "syntax\n  \"_Mapcompr\" :: \"'a \\<Rightarrow> 'b \\<Rightarrow> idts \\<Rightarrow> bool \\<Rightarrow> 'a \\<rightharpoonup> 'b\"    (\"(1[_ \\<mapsto> _ |/_./ _])\")"], ["", "translations\n  \"_Mapcompr F G xs P\" == \"CONST graph_map {(F, G) | xs. P}\""], ["", "lemma map_compr_eta:\n  \"[x \\<mapsto> y | x y. (x, y) \\<in>\\<^sub>m f] = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x \\<mapsto> y |x y. (x, y) \\<in>\\<^sub>m f] = f", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. [x \\<mapsto> y |x y. (x, y) \\<in>\\<^sub>m f] x = f x", "apply (auto simp add: graph_map_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> fst ` {(x, y). f x = Some y} \\<Longrightarrow> None = f x", "apply (metis (mono_tags, lifting) Domain.DomainI fst_eq_Domain mem_Collect_eq old.prod.case option.distinct(1) option.expand option.sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_compr_simple:\n  \"[x \\<mapsto> F x y | x y. (x, y) \\<in>\\<^sub>m f] = (\\<lambda> x. do { y \\<leftarrow> f(x); Some(F x y) })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x \\<mapsto> F x y |x y. (x, y) \\<in>\\<^sub>m f] =\n    (\\<lambda>x. f x \\<bind> (\\<lambda>y. Some (F x y)))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       [x \\<mapsto> F x y |x y. (x, y) \\<in>\\<^sub>m f] x =\n       f x \\<bind> (\\<lambda>y. Some (F x y))", "apply (auto simp add: graph_map_def image_Collect)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_compr_dom_simple [simp]:\n  \"dom [x \\<mapsto> f x | x. P x] = {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom [x \\<mapsto> f x |x. P x] = {x. P x}", "by (force simp add: graph_map_dom image_Collect)"], ["", "lemma map_compr_ran_simple [simp]:\n  \"ran [x \\<mapsto> f x | x. P x] = {f x | x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran [x \\<mapsto> f x |x. P x] = {f x |x. P x}", "apply (auto simp add: graph_map_def ran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       P xa \\<Longrightarrow>\n       \\<exists>a.\n          (a \\<in> fst ` {(x, f x) |x. P x} \\<longrightarrow>\n           (SOME y. y = f a \\<and> P a) = f xa) \\<and>\n          a \\<in> fst ` {(x, f x) |x. P x}", "apply (metis (mono_tags, lifting) fst_eqD image_eqI mem_Collect_eq someI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_compr_eval_simple [simp]:\n  \"[x \\<mapsto> f x | x. P x] x = (if (P x) then Some (f x) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x \\<mapsto> f x |x. P x] x = (if P x then Some (f x) else None)", "by (auto simp add: graph_map_def image_Collect)"], ["", "subsection \\<open> Sorted lists from maps \\<close>"], ["", "definition sorted_list_of_map :: \"('a::linorder \\<rightharpoonup> 'b) \\<Rightarrow> ('a \\<times> 'b) list\" where\n\"sorted_list_of_map f = map (\\<lambda> k. (k, the (f k))) (sorted_list_of_set(dom(f)))\""], ["", "lemma sorted_list_of_map_empty [simp]:\n  \"sorted_list_of_map Map.empty = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_map Map.empty = []", "by (simp add: sorted_list_of_map_def)"], ["", "lemma sorted_list_of_map_inv:\n  assumes \"finite(dom(f))\"\n  shows \"map_of (sorted_list_of_map f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (sorted_list_of_map f) = f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (sorted_list_of_map f) = f", "obtain A where \"finite A\" \"A = dom(f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>finite A; A = dom f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: assms)"], ["proof (state)\nthis:\n  finite A\n  A = dom f\n\ngoal (1 subgoal):\n 1. map_of (sorted_list_of_map f) = f", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite A\n  A = dom f\n\ngoal (1 subgoal):\n 1. map_of (sorted_list_of_map f) = f", "proof (induct A rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} = dom f \\<Longrightarrow> map_of (sorted_list_of_map f) = f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F = dom f \\<Longrightarrow> map_of (sorted_list_of_map f) = f;\n        insert x F = dom f\\<rbrakk>\n       \\<Longrightarrow> map_of (sorted_list_of_map f) = f", "case empty"], ["proof (state)\nthis:\n  {} = dom f\n\ngoal (2 subgoals):\n 1. {} = dom f \\<Longrightarrow> map_of (sorted_list_of_map f) = f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F = dom f \\<Longrightarrow> map_of (sorted_list_of_map f) = f;\n        insert x F = dom f\\<rbrakk>\n       \\<Longrightarrow> map_of (sorted_list_of_map f) = f", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} = dom f\n\ngoal (1 subgoal):\n 1. map_of (sorted_list_of_map f) = f", "by (simp add: sorted_list_of_map_def, metis dom_empty empty_iff map_le_antisym map_le_def)"], ["proof (state)\nthis:\n  map_of (sorted_list_of_map f) = f\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F = dom f \\<Longrightarrow> map_of (sorted_list_of_map f) = f;\n        insert x F = dom f\\<rbrakk>\n       \\<Longrightarrow> map_of (sorted_list_of_map f) = f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F = dom f \\<Longrightarrow> map_of (sorted_list_of_map f) = f;\n        insert x F = dom f\\<rbrakk>\n       \\<Longrightarrow> map_of (sorted_list_of_map f) = f", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  A = dom f \\<Longrightarrow> map_of (sorted_list_of_map f) = f\n  insert x A = dom f\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F = dom f \\<Longrightarrow> map_of (sorted_list_of_map f) = f;\n        insert x F = dom f\\<rbrakk>\n       \\<Longrightarrow> map_of (sorted_list_of_map f) = f", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  A = dom f \\<Longrightarrow> map_of (sorted_list_of_map f) = f\n  insert x A = dom f\n\ngoal (1 subgoal):\n 1. map_of (sorted_list_of_map f) = f", "by (simp add: assms sorted_list_of_map_def map_of_map_keys)"], ["proof (state)\nthis:\n  map_of (sorted_list_of_map f) = f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of (sorted_list_of_map f) = f\n\ngoal:\nNo subgoals!", "qed"], ["", "declare map_member.simps [simp del]"], ["", "subsection \\<open> Extra map lemmas \\<close>"], ["", "lemma map_eqI:\n  \"\\<lbrakk> dom f = dom g; \\<forall> x\\<in>dom(f). the(f x) = the(g x) \\<rbrakk> \\<Longrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom f = dom g;\n     \\<forall>x\\<in>dom f. the (f x) = the (g x)\\<rbrakk>\n    \\<Longrightarrow> f = g", "by (metis domIff map_le_antisym map_le_def option.expand)"], ["", "lemma map_restrict_dom [simp]: \"f |` dom f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f |` dom f = f", "by (simp add: map_eqI)"], ["", "lemma map_restrict_dom_compl: \"f |` (- dom f) = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f |` (- dom f) = Map.empty", "by (metis dom_eq_empty_conv dom_restrict inf_compl_bot)"], ["", "lemma restrict_map_neg_disj:\n  \"dom(f) \\<inter> A = {} \\<Longrightarrow> f |` (- A) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom f \\<inter> A = {} \\<Longrightarrow> f |` (- A) = f", "by (auto simp add: restrict_map_def, rule ext, auto, metis disjoint_iff_not_equal domIff)"], ["", "lemma map_plus_restrict_dist: \"(f ++ g) |` A = (f |` A) ++ (g |` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ++ g) |` A = f |` A ++ g |` A", "by (auto simp add: restrict_map_def map_add_def)"], ["", "lemma map_plus_eq_left:\n  assumes \"f ++ h = g ++ h\"\n  shows \"(f |` (- dom h)) = (g |` (- dom h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f |` (- dom h) = g |` (- dom h)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f |` (- dom h) = g |` (- dom h)", "have \"h |` (- dom h) = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h |` (- dom h) = Map.empty", "by (metis Compl_disjoint dom_eq_empty_conv dom_restrict)"], ["proof (state)\nthis:\n  h |` (- dom h) = Map.empty\n\ngoal (1 subgoal):\n 1. f |` (- dom h) = g |` (- dom h)", "then"], ["proof (chain)\npicking this:\n  h |` (- dom h) = Map.empty", "have f2: \"f |` (- dom h) = (f ++ h) |` (- dom h)\""], ["proof (prove)\nusing this:\n  h |` (- dom h) = Map.empty\n\ngoal (1 subgoal):\n 1. f |` (- dom h) = (f ++ h) |` (- dom h)", "by (simp add: map_plus_restrict_dist)"], ["proof (state)\nthis:\n  f |` (- dom h) = (f ++ h) |` (- dom h)\n\ngoal (1 subgoal):\n 1. f |` (- dom h) = g |` (- dom h)", "have \"h |` (- dom h) = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h |` (- dom h) = Map.empty", "by (metis (no_types) Compl_disjoint dom_eq_empty_conv dom_restrict)"], ["proof (state)\nthis:\n  h |` (- dom h) = Map.empty\n\ngoal (1 subgoal):\n 1. f |` (- dom h) = g |` (- dom h)", "then"], ["proof (chain)\npicking this:\n  h |` (- dom h) = Map.empty", "show ?thesis"], ["proof (prove)\nusing this:\n  h |` (- dom h) = Map.empty\n\ngoal (1 subgoal):\n 1. f |` (- dom h) = g |` (- dom h)", "using f2 assms"], ["proof (prove)\nusing this:\n  h |` (- dom h) = Map.empty\n  f |` (- dom h) = (f ++ h) |` (- dom h)\n  f ++ h = g ++ h\n\ngoal (1 subgoal):\n 1. f |` (- dom h) = g |` (- dom h)", "by (simp add: map_plus_restrict_dist)"], ["proof (state)\nthis:\n  f |` (- dom h) = g |` (- dom h)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_add_split:\n  \"dom(f) = A \\<union> B \\<Longrightarrow> (f |` A) ++ (f |` B) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom f = A \\<union> B \\<Longrightarrow> f |` A ++ f |` B = f", "by (rule ext, auto simp add: map_add_def restrict_map_def option.case_eq_if)"], ["", "lemma map_le_via_restrict:\n  \"f \\<subseteq>\\<^sub>m g \\<longleftrightarrow> g |` dom(f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<subseteq>\\<^sub>m g) = (g |` dom f = f)", "by (auto simp add: map_le_def restrict_map_def dom_def fun_eq_iff)"], ["", "lemma map_add_cancel:\n  \"f \\<subseteq>\\<^sub>m g \\<Longrightarrow> f ++ (g -- f) = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<subseteq>\\<^sub>m g \\<Longrightarrow> f ++ (g -- f) = g", "by (auto simp add: map_le_def map_add_def map_minus_def fun_eq_iff option.case_eq_if)\n     (metis domIff)"], ["", "lemma map_le_iff_add: \"f \\<subseteq>\\<^sub>m g \\<longleftrightarrow> (\\<exists> h. dom(f) \\<inter> dom(h) = {} \\<and> f ++ h = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<subseteq>\\<^sub>m g) =\n    (\\<exists>h. dom f \\<inter> dom h = {} \\<and> f ++ h = g)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f \\<subseteq>\\<^sub>m g \\<Longrightarrow>\n    \\<exists>h. dom f \\<inter> dom h = {} \\<and> f ++ h = g\n 2. \\<And>h.\n       \\<lbrakk>dom f \\<inter> dom h = {}; g = f ++ h\\<rbrakk>\n       \\<Longrightarrow> f \\<subseteq>\\<^sub>m f ++ h", "apply (rule_tac x=\"g -- f\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f \\<subseteq>\\<^sub>m g \\<Longrightarrow>\n    dom f \\<inter> dom (g -- f) = {} \\<and> f ++ (g -- f) = g\n 2. \\<And>h.\n       \\<lbrakk>dom f \\<inter> dom h = {}; g = f ++ h\\<rbrakk>\n       \\<Longrightarrow> f \\<subseteq>\\<^sub>m f ++ h", "apply (metis (no_types, lifting) Int_emptyI domIff map_add_cancel map_le_def map_minus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>dom f \\<inter> dom h = {}; g = f ++ h\\<rbrakk>\n       \\<Longrightarrow> f \\<subseteq>\\<^sub>m f ++ h", "apply (simp add: map_add_comm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_add_comm_weak: \"(\\<forall> k \\<in> dom m1 \\<inter> dom m2. m1(k) = m2(k)) \\<Longrightarrow> m1 ++ m2 = m2 ++ m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>dom m1 \\<inter> dom m2. m1 k = m2 k \\<Longrightarrow>\n    m1 ++ m2 = m2 ++ m1", "by (auto simp add: map_add_def option.case_eq_if fun_eq_iff)\n     (metis IntI domI option.inject)"], ["", "end"]]}