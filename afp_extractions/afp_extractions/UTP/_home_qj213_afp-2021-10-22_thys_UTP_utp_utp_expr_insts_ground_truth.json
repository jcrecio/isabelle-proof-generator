{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/utp/utp_expr_insts.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["lemma power_rep_eq [ueval]: \"\\<lbrakk>P ^ n\\<rbrakk>\\<^sub>e = (\\<lambda> b. \\<lbrakk>P\\<rbrakk>\\<^sub>e b ^ n)\"", "lemma of_nat_uexpr_rep_eq [ueval]: \"\\<lbrakk>of_nat x\\<rbrakk>\\<^sub>e b = of_nat x\"", "lemma lit_uminus [lit_simps]: \"\\<guillemotleft>- x\\<guillemotright> = - \\<guillemotleft>x\\<guillemotright>\"", "lemma lit_minus [lit_simps]: \"\\<guillemotleft>x - y\\<guillemotright> = \\<guillemotleft>x\\<guillemotright> - \\<guillemotleft>y\\<guillemotright>\"", "lemma lit_times [lit_simps]: \"\\<guillemotleft>x * y\\<guillemotright> = \\<guillemotleft>x\\<guillemotright> * \\<guillemotleft>y\\<guillemotright>\"", "lemma lit_divide [lit_simps]: \"\\<guillemotleft>x / y\\<guillemotright> = \\<guillemotleft>x\\<guillemotright> / \\<guillemotleft>y\\<guillemotright>\"", "lemma lit_div [lit_simps]: \"\\<guillemotleft>x div y\\<guillemotright> = \\<guillemotleft>x\\<guillemotright> div \\<guillemotleft>y\\<guillemotright>\"", "lemma lit_power [lit_simps]: \"\\<guillemotleft>x ^ n\\<guillemotright> = \\<guillemotleft>x\\<guillemotright> ^ n\"", "lemma mkuexpr_lens_get [mkuexpr]: \"mk\\<^sub>e get\\<^bsub>x\\<^esub> = &x\"", "lemma mkuexpr_zero [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. 0) = 0\"", "lemma mkuexpr_one [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. 1) = 1\"", "lemma mkuexpr_numeral [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. numeral n) = numeral n\"", "lemma mkuexpr_lit [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. k) = \\<guillemotleft>k\\<guillemotright>\"", "lemma mkuexpr_pair [mkuexpr]: \"mk\\<^sub>e (\\<lambda>s. (f s, g s)) = (mk\\<^sub>e f, mk\\<^sub>e g)\\<^sub>u\"", "lemma mkuexpr_plus [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. f s + g s) = mk\\<^sub>e f + mk\\<^sub>e g\"", "lemma mkuexpr_uminus [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. - f s) = - mk\\<^sub>e f\"", "lemma mkuexpr_minus [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. f s - g s) = mk\\<^sub>e f - mk\\<^sub>e g\"", "lemma mkuexpr_times [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. f s * g s) = mk\\<^sub>e f * mk\\<^sub>e g\"", "lemma mkuexpr_divide [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. f s / g s) = mk\\<^sub>e f / mk\\<^sub>e g\""], "translations": [["", "lemma power_rep_eq [ueval]: \"\\<lbrakk>P ^ n\\<rbrakk>\\<^sub>e = (\\<lambda> b. \\<lbrakk>P\\<rbrakk>\\<^sub>e b ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P ^ n\\<rbrakk>\\<^sub>e =\n    (\\<lambda>b. \\<lbrakk>P\\<rbrakk>\\<^sub>e b ^ n)", "by (induct n, simp_all add: lit.rep_eq one_uexpr_def bop.rep_eq times_uexpr_def)"], ["", "lemma of_nat_uexpr_rep_eq [ueval]: \"\\<lbrakk>of_nat x\\<rbrakk>\\<^sub>e b = of_nat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>of_nat x\\<rbrakk>\\<^sub>e b = of_nat x", "by (induct x, simp_all add: uexpr_defs ueval)"], ["", "lemma lit_uminus [lit_simps]: \"\\<guillemotleft>- x\\<guillemotright> = - \\<guillemotleft>x\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>- x\\<guillemotright> =\n    - \\<guillemotleft>x\\<guillemotright>", "by (simp add: uexpr_defs, transfer, simp)"], ["", "lemma lit_minus [lit_simps]: \"\\<guillemotleft>x - y\\<guillemotright> = \\<guillemotleft>x\\<guillemotright> - \\<guillemotleft>y\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>x - y\\<guillemotright> =\n    \\<guillemotleft>x\\<guillemotright> - \\<guillemotleft>y\\<guillemotright>", "by (simp add: uexpr_defs, transfer, simp)"], ["", "lemma lit_times [lit_simps]: \"\\<guillemotleft>x * y\\<guillemotright> = \\<guillemotleft>x\\<guillemotright> * \\<guillemotleft>y\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>x * y\\<guillemotright> =\n    \\<guillemotleft>x\\<guillemotright> * \\<guillemotleft>y\\<guillemotright>", "by (simp add: uexpr_defs, transfer, simp)"], ["", "lemma lit_divide [lit_simps]: \"\\<guillemotleft>x / y\\<guillemotright> = \\<guillemotleft>x\\<guillemotright> / \\<guillemotleft>y\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>x / y\\<guillemotright> =\n    \\<guillemotleft>x\\<guillemotright> / \\<guillemotleft>y\\<guillemotright>", "by (simp add: uexpr_defs, transfer, simp)"], ["", "lemma lit_div [lit_simps]: \"\\<guillemotleft>x div y\\<guillemotright> = \\<guillemotleft>x\\<guillemotright> div \\<guillemotleft>y\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>x div y\\<guillemotright> =\n    \\<guillemotleft>x\\<guillemotright> div\n    \\<guillemotleft>y\\<guillemotright>", "by (simp add: uexpr_defs, transfer, simp)"], ["", "lemma lit_power [lit_simps]: \"\\<guillemotleft>x ^ n\\<guillemotright> = \\<guillemotleft>x\\<guillemotright> ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>x ^ n\\<guillemotright> =\n    \\<guillemotleft>x\\<guillemotright> ^ n", "by (simp add: lit.rep_eq power_rep_eq uexpr_eq_iff)"], ["", "subsection \\<open> Expression construction from HOL terms \\<close>"], ["", "text \\<open> Sometimes it is convenient to cast HOL terms to UTP expressions, and these simplifications\n  automate this process. \\<close>"], ["", "named_theorems mkuexpr"], ["", "lemma mkuexpr_lens_get [mkuexpr]: \"mk\\<^sub>e get\\<^bsub>x\\<^esub> = &x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk\\<^sub>e get\\<^bsub>x\\<^esub> = &x", "by (transfer, simp add: pr_var_def)"], ["", "lemma mkuexpr_zero [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk\\<^sub>e (\\<lambda>s. 0::'a) = 0", "by (simp add: zero_uexpr_def, transfer, simp)"], ["", "lemma mkuexpr_one [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. 1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk\\<^sub>e (\\<lambda>s. 1::'a) = 1", "by (simp add: one_uexpr_def, transfer, simp)"], ["", "lemma mkuexpr_numeral [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk\\<^sub>e (\\<lambda>s. numeral n) = numeral n", "using lit_numeral_2"], ["proof (prove)\nusing this:\n  mk\\<^sub>e (\\<lambda>b. numeral ?v) = numeral ?v\n\ngoal (1 subgoal):\n 1. mk\\<^sub>e (\\<lambda>s. numeral n) = numeral n", "by blast"], ["", "lemma mkuexpr_lit [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. k) = \\<guillemotleft>k\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk\\<^sub>e (\\<lambda>s. k) = \\<guillemotleft>k\\<guillemotright>", "by (transfer, simp)"], ["", "lemma mkuexpr_pair [mkuexpr]: \"mk\\<^sub>e (\\<lambda>s. (f s, g s)) = (mk\\<^sub>e f, mk\\<^sub>e g)\\<^sub>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk\\<^sub>e (\\<lambda>s. (f s, g s)) =\n    (mk\\<^sub>e f, mk\\<^sub>e g)\\<^sub>u", "by (transfer, simp)"], ["", "lemma mkuexpr_plus [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. f s + g s) = mk\\<^sub>e f + mk\\<^sub>e g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk\\<^sub>e (\\<lambda>s. f s + g s) = mk\\<^sub>e f + mk\\<^sub>e g", "by (simp add: plus_uexpr_def, transfer, simp)"], ["", "lemma mkuexpr_uminus [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. - f s) = - mk\\<^sub>e f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk\\<^sub>e (\\<lambda>s. - f s) = - mk\\<^sub>e f", "by (simp add: uminus_uexpr_def, transfer, simp)"], ["", "lemma mkuexpr_minus [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. f s - g s) = mk\\<^sub>e f - mk\\<^sub>e g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk\\<^sub>e (\\<lambda>s. f s - g s) = mk\\<^sub>e f - mk\\<^sub>e g", "by (simp add: minus_uexpr_def, transfer, simp)"], ["", "lemma mkuexpr_times [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. f s * g s) = mk\\<^sub>e f * mk\\<^sub>e g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk\\<^sub>e (\\<lambda>s. f s * g s) = mk\\<^sub>e f * mk\\<^sub>e g", "by (simp add: times_uexpr_def, transfer, simp)"], ["", "lemma mkuexpr_divide [mkuexpr]: \"mk\\<^sub>e (\\<lambda> s. f s / g s) = mk\\<^sub>e f / mk\\<^sub>e g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk\\<^sub>e (\\<lambda>s. f s / g s) = mk\\<^sub>e f / mk\\<^sub>e g", "by (simp add: divide_uexpr_def, transfer, simp)"], ["", "end"]]}