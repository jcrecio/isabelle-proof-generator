{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/utp/utp_expr.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["lemma uexpr_eq_iff:\n  \"e = f \\<longleftrightarrow> (\\<forall> b. \\<lbrakk>e\\<rbrakk>\\<^sub>e b = \\<lbrakk>f\\<rbrakk>\\<^sub>e b)\"", "lemma lit_ueval [ueval]: \"\\<lbrakk>\\<guillemotleft>x\\<guillemotright>\\<rbrakk>\\<^sub>eb = x\"", "lemma var_ueval [ueval]: \"\\<lbrakk>var x\\<rbrakk>\\<^sub>eb = get\\<^bsub>x\\<^esub> b\"", "lemma uop_ueval [ueval]: \"\\<lbrakk>uop f x\\<rbrakk>\\<^sub>eb = f (\\<lbrakk>x\\<rbrakk>\\<^sub>eb)\"", "lemma bop_ueval [ueval]: \"\\<lbrakk>bop f x y\\<rbrakk>\\<^sub>eb = f (\\<lbrakk>x\\<rbrakk>\\<^sub>eb) (\\<lbrakk>y\\<rbrakk>\\<^sub>eb)\"", "lemma trop_ueval [ueval]: \"\\<lbrakk>trop f x y z\\<rbrakk>\\<^sub>eb = f (\\<lbrakk>x\\<rbrakk>\\<^sub>eb) (\\<lbrakk>y\\<rbrakk>\\<^sub>eb) (\\<lbrakk>z\\<rbrakk>\\<^sub>eb)\"", "lemma qtop_ueval [ueval]: \"\\<lbrakk>qtop f x y z w\\<rbrakk>\\<^sub>eb = f (\\<lbrakk>x\\<rbrakk>\\<^sub>eb) (\\<lbrakk>y\\<rbrakk>\\<^sub>eb) (\\<lbrakk>z\\<rbrakk>\\<^sub>eb) (\\<lbrakk>w\\<rbrakk>\\<^sub>eb)\"", "lemma uop_const [simp]: \"uop id u = u\"", "lemma bop_const_1 [simp]: \"bop (\\<lambda>x y. y) u v = v\"", "lemma bop_const_2 [simp]: \"bop (\\<lambda>x y. x) u v = u\"", "lemma uexpr_fst [simp]: \"\\<pi>\\<^sub>1((e, f)\\<^sub>u) = e\"", "lemma uexpr_snd [simp]: \"\\<pi>\\<^sub>2((e, f)\\<^sub>u) = f\"", "lemma lit_fun_simps [lit_simps]:\n  \"\\<guillemotleft>i x y z u\\<guillemotright> = qtop i \\<guillemotleft>x\\<guillemotright> \\<guillemotleft>y\\<guillemotright> \\<guillemotleft>z\\<guillemotright> \\<guillemotleft>u\\<guillemotright>\"\n  \"\\<guillemotleft>h x y z\\<guillemotright> = trop h \\<guillemotleft>x\\<guillemotright> \\<guillemotleft>y\\<guillemotright> \\<guillemotleft>z\\<guillemotright>\"\n  \"\\<guillemotleft>g x y\\<guillemotright> = bop g \\<guillemotleft>x\\<guillemotright> \\<guillemotleft>y\\<guillemotright>\"\n  \"\\<guillemotleft>f x\\<guillemotright> = uop f \\<guillemotleft>x\\<guillemotright>\"", "lemma numeral_uexpr_rep_eq [ueval]: \"\\<lbrakk>numeral x\\<rbrakk>\\<^sub>e b = numeral x\"", "lemma numeral_uexpr_simp: \"numeral x = \\<guillemotleft>numeral x\\<guillemotright>\"", "lemma lit_zero [lit_simps]: \"\\<guillemotleft>0\\<guillemotright> = 0\"", "lemma lit_one [lit_simps]: \"\\<guillemotleft>1\\<guillemotright> = 1\"", "lemma lit_plus [lit_simps]: \"\\<guillemotleft>x + y\\<guillemotright> = \\<guillemotleft>x\\<guillemotright> + \\<guillemotleft>y\\<guillemotright>\"", "lemma lit_numeral [lit_simps]: \"\\<guillemotleft>numeral n\\<guillemotright> = numeral n\"", "lemma lit_numeral_1: \"uop numeral x = Abs_uexpr (\\<lambda>b. numeral (\\<lbrakk>x\\<rbrakk>\\<^sub>e b))\"", "lemma lit_numeral_2: \"Abs_uexpr (\\<lambda> b. numeral v) = numeral v\"", "lemma \"(1::(int, '\\<alpha>) uexpr) + \\<guillemotleft>2\\<guillemotright> = 4 \\<longleftrightarrow> \\<guillemotleft>3\\<guillemotright> = 4\""], "translations": [["", "lemma uexpr_eq_iff:\n  \"e = f \\<longleftrightarrow> (\\<forall> b. \\<lbrakk>e\\<rbrakk>\\<^sub>e b = \\<lbrakk>f\\<rbrakk>\\<^sub>e b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e = f) =\n    (\\<forall>b.\n        \\<lbrakk>e\\<rbrakk>\\<^sub>e b = \\<lbrakk>f\\<rbrakk>\\<^sub>e b)", "using Rep_uexpr_inject[of e f, THEN sym]"], ["proof (prove)\nusing this:\n  (e = f) = (\\<lbrakk>e\\<rbrakk>\\<^sub>e = \\<lbrakk>f\\<rbrakk>\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (e = f) =\n    (\\<forall>b.\n        \\<lbrakk>e\\<rbrakk>\\<^sub>e b = \\<lbrakk>f\\<rbrakk>\\<^sub>e b)", "by (auto)"], ["", "text \\<open> The term @{term \"\\<lbrakk>e\\<rbrakk>\\<^sub>e b\"} effectively refers to the semantic interpretation of the expression\n  under the state-space valuation (or variables binding) @{term b}. It can be used, in concert\n  with the lifting package, to interpret UTP constructs to their HOL equivalents. We create some\n  theorem sets to store such transfer theorems. \\<close>"], ["", "named_theorems uexpr_defs and ueval and lit_simps and lit_norm"], ["", "subsection \\<open> Core expression constructs \\<close>"], ["", "text \\<open> A variable expression corresponds to the lens $get$ function associated with a variable. \n  Specifically, given a lens the expression always returns that portion of the state-space\n  referred to by the lens. \\<close>"], ["", "lift_definition var :: \"('t \\<Longrightarrow> '\\<alpha>) \\<Rightarrow> ('t, '\\<alpha>) uexpr\" is lens_get"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open> A literal is simply a constant function expression, always returning the same value\n  for any binding. \\<close>"], ["", "lift_definition lit :: \"'t \\<Rightarrow> ('t, '\\<alpha>) uexpr\" (\"\\<guillemotleft>_\\<guillemotright>\") is \"\\<lambda> v b. v\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open> We define lifting for unary, binary, ternary, and quaternary expression constructs, that \n  simply take a HOL function with correct number of arguments and apply it function to all possible \n  results of the expressions. \\<close>"], ["", "lift_definition uop :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a, '\\<alpha>) uexpr \\<Rightarrow> ('b, '\\<alpha>) uexpr\"\n  is \"\\<lambda> f e b. f (e b)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition bop ::\n  \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> ('a, '\\<alpha>) uexpr \\<Rightarrow> ('b, '\\<alpha>) uexpr \\<Rightarrow> ('c, '\\<alpha>) uexpr\"\n  is \"\\<lambda> f u v b. f (u b) (v b)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition trop ::\n  \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd) \\<Rightarrow> ('a, '\\<alpha>) uexpr \\<Rightarrow> ('b, '\\<alpha>) uexpr \\<Rightarrow> ('c, '\\<alpha>) uexpr \\<Rightarrow> ('d, '\\<alpha>) uexpr\"\n  is \"\\<lambda> f u v w b. f (u b) (v b) (w b)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition qtop ::\n  \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd \\<Rightarrow> 'e) \\<Rightarrow>\n   ('a, '\\<alpha>) uexpr \\<Rightarrow> ('b, '\\<alpha>) uexpr \\<Rightarrow> ('c, '\\<alpha>) uexpr \\<Rightarrow> ('d, '\\<alpha>) uexpr \\<Rightarrow>\n   ('e, '\\<alpha>) uexpr\"\n  is \"\\<lambda> f u v w x b. f (u b) (v b) (w b) (x b)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open> We also define a UTP expression version of function ($\\lambda$) abstraction, that takes\n  a function producing an expression and produces an expression producing a function. \\<close>"], ["", "lift_definition ulambda :: \"('a \\<Rightarrow> ('b, '\\<alpha>) uexpr) \\<Rightarrow> ('a \\<Rightarrow> 'b, '\\<alpha>) uexpr\"\nis \"\\<lambda> f A x. f x A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open> We set up syntax for the conditional. This is effectively an infix version of\n  if-then-else where the condition is in the middle. \\<close>"], ["", "definition uIf :: \"bool \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" where\n[uexpr_defs]: \"uIf = If\""], ["", "abbreviation cond ::\n  \"('a,'\\<alpha>) uexpr \\<Rightarrow> (bool, '\\<alpha>) uexpr \\<Rightarrow> ('a,'\\<alpha>) uexpr \\<Rightarrow> ('a,'\\<alpha>) uexpr\"\n  (\"(3_ \\<triangleleft> _ \\<triangleright>/ _)\" [52,0,53] 52)\nwhere \"P \\<triangleleft> b \\<triangleright> Q \\<equiv> trop uIf b P Q\""], ["", "text \\<open> UTP expression is equality is simply HOL equality lifted using the @{term bop} binary \n  expression constructor. \\<close>"], ["", "definition eq_upred :: \"('a, '\\<alpha>) uexpr \\<Rightarrow> ('a, '\\<alpha>) uexpr \\<Rightarrow> (bool, '\\<alpha>) uexpr\" (infixl \"=\\<^sub>u\" 50)\nwhere [uexpr_defs]: \"eq_upred x y = bop HOL.eq x y\""], ["", "text \\<open> A literal is the expression @{term \"\\<guillemotleft>v\\<guillemotright>\"}, where @{term v} is any HOL term. Actually, the\n  literal construct is very versatile and also allows us to refer to HOL variables within UTP\n  expressions, and has a variety of other uses. It can therefore also be considered as a kind\n  of quotation mechanism. \n\n  We also set up syntax for UTP variable expressions. \\<close>"], ["", "syntax\n  \"_uuvar\" :: \"svar \\<Rightarrow> logic\" (\"_\")"], ["", "translations\n  \"_uuvar x\" == \"CONST var x\""], ["", "text \\<open> Since we already have a parser for variables, we can directly reuse it and simply apply\n  the @{term var} expression construct to lift the resulting variable to an expression. \\<close>"], ["", "subsection \\<open> Type class instantiations \\<close>"], ["", "text \\<open> Isabelle/HOL of course provides a large hierarchy of type classes that provide constructs\n  such as numerals and the arithmetic operators. Fortunately we can directly make use of these\n  for UTP expressions, and thus we now perform a long list of appropriate instantiations. We\n  first lift the core arithemtic constants and operators using a mixture of literals, unary, and binary\n  expression constructors. \\<close>"], ["", "instantiation uexpr :: (zero, type) zero\nbegin"], ["", "definition zero_uexpr_def [uexpr_defs]: \"0 = lit 0\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, zero_class)", ".."], ["", "end"], ["", "instantiation uexpr :: (one, type) one\nbegin"], ["", "definition one_uexpr_def [uexpr_defs]: \"1 = lit 1\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, one_class)", ".."], ["", "end"], ["", "instantiation uexpr :: (plus, type) plus\nbegin"], ["", "definition plus_uexpr_def [uexpr_defs]: \"u + v = bop (+) u v\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, plus_class)", ".."], ["", "end"], ["", "instance uexpr :: (semigroup_add, type) semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, semigroup_add_class)", "by (intro_classes) (simp add: plus_uexpr_def zero_uexpr_def, transfer, simp add: add.assoc)+"], ["", "text \\<open> The following instantiation sets up numerals. This will allow us to have Isabelle number\n  representations (i.e. 3,7,42,198 etc.) to UTP expressions directly. \\<close>"], ["", "instance uexpr :: (numeral, type) numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, numeral_class)", "by (intro_classes, simp add: plus_uexpr_def, transfer, simp add: add.assoc)"], ["", "text \\<open> We can also define the order relation on expressions. Now, unlike the previous group and ring \n  constructs, the order relations @{term \"(\\<le>)\"} and @{term \"(\\<le>)\"} return a @{type bool} type.\n  This order is not therefore the lifted order which allows us to compare the valuation of two\n  expressions, but rather the order on expressions themselves. Notably, this instantiation will\n  later allow us to talk about predicate refinements and complete lattices. \\<close>"], ["", "instantiation uexpr :: (ord, type) ord\nbegin"], ["", "lift_definition less_eq_uexpr :: \"('a, 'b) uexpr \\<Rightarrow> ('a, 'b) uexpr \\<Rightarrow> bool\"\n  is \"\\<lambda> P Q. (\\<forall> A. P A \\<le> Q A)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition less_uexpr :: \"('a, 'b) uexpr \\<Rightarrow> ('a, 'b) uexpr \\<Rightarrow> bool\"\n  where [uexpr_defs]: \"less_uexpr P Q = (P \\<le> Q \\<and> \\<not> Q \\<le> P)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, ord_class)", ".."], ["", "end"], ["", "text \\<open> UTP expressions whose return type is a partial ordered type, are also partially ordered\n  as the following instantiation demonstrates. \\<close>"], ["", "instance uexpr :: (order, type) order"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, order_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "fix x y z :: \"('a, 'b) uexpr\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"(x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by (simp add: less_uexpr_def)"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "by (transfer, auto)"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x \\<le> y \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "by (transfer, blast intro:order.trans)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x \\<le> y \\<Longrightarrow> y \\<le> x \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "by (transfer, rule ext, simp add: eq_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Syntax translations \\<close>"], ["", "text \\<open> The follows a large number of translations that lift HOL functions to UTP expressions\n  using the various expression constructors defined above. Much of the time we try to keep\n  the HOL syntax but add a \"u\" subscript. \\<close>"], ["", "text \\<open> This operator allows us to get the characteristic set of a type. Essentially this is \n  @{term \"UNIV\"}, but it retains the type syntactically for pretty printing. \\<close>"], ["", "definition set_of :: \"'a itself \\<Rightarrow> 'a set\" where\n[uexpr_defs]: \"set_of t = UNIV\""], ["", "text \\<open> We add new non-terminals for UTP tuples and maplets. \\<close>"], ["", "nonterminal utuple_args and umaplet and umaplets"], ["", "syntax \\<comment> \\<open> Core expression constructs \\<close>\n  \"_ucoerce\"    :: \"logic \\<Rightarrow> type \\<Rightarrow> logic\" (infix \":\\<^sub>u\" 50)\n  \"_ulambda\"    :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic\" (\"\\<lambda> _ \\<bullet> _\" [0, 10] 10)\n  \"_ulens_ovrd\" :: \"logic \\<Rightarrow> logic \\<Rightarrow> salpha \\<Rightarrow> logic\" (\"_ \\<oplus> _ on _\" [85, 0, 86] 86)\n  \"_ulens_get\"  :: \"logic \\<Rightarrow> svar \\<Rightarrow> logic\" (\"_:_\" [900,901] 901)\n  \"_umem\"       :: \"('a, '\\<alpha>) uexpr \\<Rightarrow> ('a set, '\\<alpha>) uexpr \\<Rightarrow> (bool, '\\<alpha>) uexpr\" (infix \"\\<in>\\<^sub>u\" 50)"], ["", "translations\n  \"\\<lambda> x \\<bullet> p\" == \"CONST ulambda (\\<lambda> x. p)\"\n  \"x :\\<^sub>u 'a\" == \"x :: ('a, _) uexpr\"\n  \"_ulens_ovrd f g a\" => \"CONST bop (CONST lens_override a) f g\"\n  \"_ulens_ovrd f g a\" <= \"CONST bop (\\<lambda>x y. CONST lens_override x1 y1 a) f g\"\n  \"_ulens_get x y\" == \"CONST uop (CONST lens_get y) x\"\n  \"x \\<in>\\<^sub>u A\" == \"CONST bop (\\<in>) x A\""], ["", "syntax \\<comment> \\<open> Tuples \\<close>\n  \"_utuple\"     :: \"('a, '\\<alpha>) uexpr \\<Rightarrow> utuple_args \\<Rightarrow> ('a * 'b, '\\<alpha>) uexpr\" (\"(1'(_,/ _')\\<^sub>u)\")\n  \"_utuple_arg\"  :: \"('a, '\\<alpha>) uexpr \\<Rightarrow> utuple_args\" (\"_\")\n  \"_utuple_args\" :: \"('a, '\\<alpha>) uexpr => utuple_args \\<Rightarrow> utuple_args\"     (\"_,/ _\")\n  \"_uunit\"      :: \"('a, '\\<alpha>) uexpr\" (\"'(')\\<^sub>u\")\n  \"_ufst\"       :: \"('a \\<times> 'b, '\\<alpha>) uexpr \\<Rightarrow> ('a, '\\<alpha>) uexpr\" (\"\\<pi>\\<^sub>1'(_')\")\n  \"_usnd\"       :: \"('a \\<times> 'b, '\\<alpha>) uexpr \\<Rightarrow> ('b, '\\<alpha>) uexpr\" (\"\\<pi>\\<^sub>2'(_')\")"], ["", "translations\n  \"()\\<^sub>u\"      == \"\\<guillemotleft>()\\<guillemotright>\"\n  \"(x, y)\\<^sub>u\"  == \"CONST bop (CONST Pair) x y\"\n  \"_utuple x (_utuple_args y z)\" == \"_utuple x (_utuple_arg (_utuple y z))\"\n  \"\\<pi>\\<^sub>1(x)\"    == \"CONST uop CONST fst x\"\n  \"\\<pi>\\<^sub>2(x)\"    == \"CONST uop CONST snd x\""], ["", "syntax \\<comment> \\<open> Orders \\<close>\n  \"_uless\"      :: \"logic \\<Rightarrow> logic \\<Rightarrow> logic\" (infix \"<\\<^sub>u\" 50)\n  \"_uleq\"       :: \"logic \\<Rightarrow> logic \\<Rightarrow> logic\" (infix \"\\<le>\\<^sub>u\" 50)\n  \"_ugreat\"     :: \"logic \\<Rightarrow> logic \\<Rightarrow> logic\" (infix \">\\<^sub>u\" 50)\n  \"_ugeq\"       :: \"logic \\<Rightarrow> logic \\<Rightarrow> logic\" (infix \"\\<ge>\\<^sub>u\" 50)"], ["", "translations\n  \"x <\\<^sub>u y\"   == \"CONST bop (<) x y\"\n  \"x \\<le>\\<^sub>u y\"   == \"CONST bop (\\<le>) x y\"\n  \"x >\\<^sub>u y\"   => \"y <\\<^sub>u x\"\n  \"x \\<ge>\\<^sub>u y\"   => \"y \\<le>\\<^sub>u x\""], ["", "subsection \\<open> Evaluation laws for expressions \\<close>"], ["", "text \\<open> The following laws show how to evaluate the core expressions constructs in terms of which\n  the above definitions are defined. Thus, using these theorems together, we can convert any UTP \n  expression into a pure HOL expression. All these theorems are marked as \\emph{ueval} theorems\n  which can be used for evaluation. \\<close>"], ["", "lemma lit_ueval [ueval]: \"\\<lbrakk>\\<guillemotleft>x\\<guillemotright>\\<rbrakk>\\<^sub>eb = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>x\\<guillemotright>\\<rbrakk>\\<^sub>e b = x", "by (transfer, simp)"], ["", "lemma var_ueval [ueval]: \"\\<lbrakk>var x\\<rbrakk>\\<^sub>eb = get\\<^bsub>x\\<^esub> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x\\<rbrakk>\\<^sub>e b = get\\<^bsub>x\\<^esub> b", "by (transfer, simp)"], ["", "lemma uop_ueval [ueval]: \"\\<lbrakk>uop f x\\<rbrakk>\\<^sub>eb = f (\\<lbrakk>x\\<rbrakk>\\<^sub>eb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uop f x\\<rbrakk>\\<^sub>e b = f (\\<lbrakk>x\\<rbrakk>\\<^sub>e b)", "by (transfer, simp)"], ["", "lemma bop_ueval [ueval]: \"\\<lbrakk>bop f x y\\<rbrakk>\\<^sub>eb = f (\\<lbrakk>x\\<rbrakk>\\<^sub>eb) (\\<lbrakk>y\\<rbrakk>\\<^sub>eb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bop f x y\\<rbrakk>\\<^sub>e b =\n    f (\\<lbrakk>x\\<rbrakk>\\<^sub>e b) (\\<lbrakk>y\\<rbrakk>\\<^sub>e b)", "by (transfer, simp)"], ["", "lemma trop_ueval [ueval]: \"\\<lbrakk>trop f x y z\\<rbrakk>\\<^sub>eb = f (\\<lbrakk>x\\<rbrakk>\\<^sub>eb) (\\<lbrakk>y\\<rbrakk>\\<^sub>eb) (\\<lbrakk>z\\<rbrakk>\\<^sub>eb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trop f x y z\\<rbrakk>\\<^sub>e b =\n    f (\\<lbrakk>x\\<rbrakk>\\<^sub>e b) (\\<lbrakk>y\\<rbrakk>\\<^sub>e b)\n     (\\<lbrakk>z\\<rbrakk>\\<^sub>e b)", "by (transfer, simp)"], ["", "lemma qtop_ueval [ueval]: \"\\<lbrakk>qtop f x y z w\\<rbrakk>\\<^sub>eb = f (\\<lbrakk>x\\<rbrakk>\\<^sub>eb) (\\<lbrakk>y\\<rbrakk>\\<^sub>eb) (\\<lbrakk>z\\<rbrakk>\\<^sub>eb) (\\<lbrakk>w\\<rbrakk>\\<^sub>eb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qtop f x y z w\\<rbrakk>\\<^sub>e b =\n    f (\\<lbrakk>x\\<rbrakk>\\<^sub>e b) (\\<lbrakk>y\\<rbrakk>\\<^sub>e b)\n     (\\<lbrakk>z\\<rbrakk>\\<^sub>e b) (\\<lbrakk>w\\<rbrakk>\\<^sub>e b)", "by (transfer, simp)"], ["", "subsection \\<open> Misc laws \\<close>"], ["", "text \\<open> We also prove a few useful algebraic and expansion laws for expressions. \\<close>"], ["", "lemma uop_const [simp]: \"uop id u = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uop id u = u", "by (transfer, simp)"], ["", "lemma bop_const_1 [simp]: \"bop (\\<lambda>x y. y) u v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bop (\\<lambda>x y. y) u v = v", "by (transfer, simp)"], ["", "lemma bop_const_2 [simp]: \"bop (\\<lambda>x y. x) u v = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bop (\\<lambda>x y. x) u v = u", "by (transfer, simp)"], ["", "lemma uexpr_fst [simp]: \"\\<pi>\\<^sub>1((e, f)\\<^sub>u) = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>1((e, f)\\<^sub>u) = e", "by (transfer, simp)"], ["", "lemma uexpr_snd [simp]: \"\\<pi>\\<^sub>2((e, f)\\<^sub>u) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>2((e, f)\\<^sub>u) = f", "by (transfer, simp)"], ["", "subsection \\<open> Literalise tactics \\<close>"], ["", "text \\<open> The following tactic converts literal HOL expressions to UTP expressions and vice-versa\n        via a collection of simplification rules. The two tactics are called \"literalise\", which\n        converts UTP to expressions to HOL expressions -- i.e. it pushes them into literals --\n        and unliteralise that reverses this. We collect the equations in a theorem attribute\n        called \"lit\\_simps\". \\<close>"], ["", "lemma lit_fun_simps [lit_simps]:\n  \"\\<guillemotleft>i x y z u\\<guillemotright> = qtop i \\<guillemotleft>x\\<guillemotright> \\<guillemotleft>y\\<guillemotright> \\<guillemotleft>z\\<guillemotright> \\<guillemotleft>u\\<guillemotright>\"\n  \"\\<guillemotleft>h x y z\\<guillemotright> = trop h \\<guillemotleft>x\\<guillemotright> \\<guillemotleft>y\\<guillemotright> \\<guillemotleft>z\\<guillemotright>\"\n  \"\\<guillemotleft>g x y\\<guillemotright> = bop g \\<guillemotleft>x\\<guillemotright> \\<guillemotleft>y\\<guillemotright>\"\n  \"\\<guillemotleft>f x\\<guillemotright> = uop f \\<guillemotleft>x\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<guillemotleft>i x y z u\\<guillemotright> =\n     qtop i \\<guillemotleft>x\\<guillemotright>\n      \\<guillemotleft>y\\<guillemotright> \\<guillemotleft>z\\<guillemotright>\n      \\<guillemotleft>u\\<guillemotright> &&&\n     \\<guillemotleft>h x y z\\<guillemotright> =\n     trop h \\<guillemotleft>x\\<guillemotright>\n      \\<guillemotleft>y\\<guillemotright>\n      \\<guillemotleft>z\\<guillemotright>) &&&\n    \\<guillemotleft>g x y\\<guillemotright> =\n    bop g \\<guillemotleft>x\\<guillemotright>\n     \\<guillemotleft>y\\<guillemotright> &&&\n    \\<guillemotleft>f x\\<guillemotright> =\n    uop f \\<guillemotleft>x\\<guillemotright>", "by (transfer, simp)+"], ["", "text \\<open> The following two theorems also set up interpretation of numerals, meaning a UTP numeral\n  can always be converted to a HOL numeral. \\<close>"], ["", "lemma numeral_uexpr_rep_eq [ueval]: \"\\<lbrakk>numeral x\\<rbrakk>\\<^sub>e b = numeral x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>numeral x\\<rbrakk>\\<^sub>e b = numeral x", "apply (induct x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Numeral1\\<rbrakk>\\<^sub>e b = Numeral1\n 2. \\<And>x.\n       \\<lbrakk>numeral x\\<rbrakk>\\<^sub>e b = numeral x \\<Longrightarrow>\n       \\<lbrakk>numeral (num.Bit0 x)\\<rbrakk>\\<^sub>e b =\n       numeral (num.Bit0 x)\n 3. \\<And>x.\n       \\<lbrakk>numeral x\\<rbrakk>\\<^sub>e b = numeral x \\<Longrightarrow>\n       \\<lbrakk>numeral (num.Bit1 x)\\<rbrakk>\\<^sub>e b =\n       numeral (num.Bit1 x)", "apply (simp add: lit.rep_eq one_uexpr_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>numeral x\\<rbrakk>\\<^sub>e b = numeral x \\<Longrightarrow>\n       \\<lbrakk>numeral (num.Bit0 x)\\<rbrakk>\\<^sub>e b =\n       numeral (num.Bit0 x)\n 2. \\<And>x.\n       \\<lbrakk>numeral x\\<rbrakk>\\<^sub>e b = numeral x \\<Longrightarrow>\n       \\<lbrakk>numeral (num.Bit1 x)\\<rbrakk>\\<^sub>e b =\n       numeral (num.Bit1 x)", "apply (simp add: bop.rep_eq numeral_Bit0 plus_uexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>numeral x\\<rbrakk>\\<^sub>e b = numeral x \\<Longrightarrow>\n       \\<lbrakk>numeral (num.Bit1 x)\\<rbrakk>\\<^sub>e b =\n       numeral (num.Bit1 x)", "apply (simp add: bop.rep_eq lit.rep_eq numeral_code(3) one_uexpr_def plus_uexpr_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma numeral_uexpr_simp: \"numeral x = \\<guillemotleft>numeral x\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral x = \\<guillemotleft>numeral x\\<guillemotright>", "by (simp add: uexpr_eq_iff numeral_uexpr_rep_eq lit.rep_eq)"], ["", "lemma lit_zero [lit_simps]: \"\\<guillemotleft>0\\<guillemotright> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>0::'a\\<guillemotright> = 0", "by (simp add:uexpr_defs)"], ["", "lemma lit_one [lit_simps]: \"\\<guillemotleft>1\\<guillemotright> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>1::'a\\<guillemotright> = 1", "by (simp add: uexpr_defs)"], ["", "lemma lit_plus [lit_simps]: \"\\<guillemotleft>x + y\\<guillemotright> = \\<guillemotleft>x\\<guillemotright> + \\<guillemotleft>y\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>x + y\\<guillemotright> =\n    \\<guillemotleft>x\\<guillemotright> + \\<guillemotleft>y\\<guillemotright>", "by (simp add: uexpr_defs, transfer, simp)"], ["", "lemma lit_numeral [lit_simps]: \"\\<guillemotleft>numeral n\\<guillemotright> = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>numeral n\\<guillemotright> = numeral n", "by (simp add: numeral_uexpr_simp)"], ["", "text \\<open> In general unliteralising converts function applications to corresponding expression\n  liftings. Since some operators, like + and *, have specific operators we also have to\n  use @{thm uexpr_defs} in reverse to correctly interpret these. Moreover, numerals must be handled\n  separately by first simplifying them and then converting them into UTP expression numerals;\n  hence the following two simplification rules. \\<close>"], ["", "lemma lit_numeral_1: \"uop numeral x = Abs_uexpr (\\<lambda>b. numeral (\\<lbrakk>x\\<rbrakk>\\<^sub>e b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uop numeral x =\n    mk\\<^sub>e (\\<lambda>b. numeral (\\<lbrakk>x\\<rbrakk>\\<^sub>e b))", "by (simp add: uop_def)"], ["", "lemma lit_numeral_2: \"Abs_uexpr (\\<lambda> b. numeral v) = numeral v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk\\<^sub>e (\\<lambda>b. numeral v) = numeral v", "by (metis lit.abs_eq lit_numeral)"], ["", "method literalise = (unfold lit_simps[THEN sym])"], ["", "method unliteralise = (unfold lit_simps uexpr_defs[THEN sym];\n                     (unfold lit_numeral_1 ; (unfold uexpr_defs ueval); (unfold lit_numeral_2))?)+"], ["", "text \\<open> The following tactic can be used to evaluate literal expressions. It first literalises UTP \n  expressions, that is pushes as many operators into literals as possible. Then it tries to simplify,\n  and final unliteralises at the end. \\<close>"], ["", "method uexpr_simp uses simps = ((literalise)?, simp add: lit_norm simps, (unliteralise)?)"], ["", "(* Example *)"], ["", "lemma \"(1::(int, '\\<alpha>) uexpr) + \\<guillemotleft>2\\<guillemotright> = 4 \\<longleftrightarrow> \\<guillemotleft>3\\<guillemotright> = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + \\<guillemotleft>2\\<guillemotright> = 4) =\n    (\\<guillemotleft>3::'a\\<guillemotright> = 4)", "apply (literalise)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<guillemotleft>1 + 2\\<guillemotright> =\n     \\<guillemotleft>4\\<guillemotright>) =\n    (\\<guillemotleft>3::'a\\<guillemotright> =\n     \\<guillemotleft>4::'a\\<guillemotright>)", "apply (uexpr_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (3 = 4) = (3 = 4)", "oops"], ["", "end"]]}