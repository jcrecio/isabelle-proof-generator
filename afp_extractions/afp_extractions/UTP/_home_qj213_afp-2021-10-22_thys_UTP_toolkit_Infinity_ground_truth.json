{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/toolkit/Infinity.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["lemmas infinite_UNIV_int [simp]", "theorem infinite_UNIV_real [simp]:\n\"infinite (UNIV :: real set)\"", "theorem infinite_UNIV_fun1 [simp]:\n\"infinite (UNIV :: 'a set) \\<Longrightarrow>\n card (UNIV :: 'b set) \\<noteq> Suc 0 \\<Longrightarrow>\n infinite (UNIV :: ('a \\<Rightarrow> 'b) set)\"", "theorem infinite_UNIV_fun2 [simp]:\n\"infinite (UNIV :: 'b set) \\<Longrightarrow>\n infinite (UNIV :: ('a \\<Rightarrow> 'b) set)\"", "theorem infinite_UNIV_set [simp]:\n\"infinite (UNIV :: 'a set) \\<Longrightarrow>\n infinite (UNIV :: 'a set set)\"", "theorem infinite_UNIV_prod1 [simp]:\n\"infinite (UNIV :: 'a set) \\<Longrightarrow>\n infinite (UNIV :: ('a \\<times> 'b) set)\"", "theorem infinite_UNIV_prod2 [simp]:\n\"infinite (UNIV :: 'b set) \\<Longrightarrow>\n infinite (UNIV :: ('a \\<times> 'b) set)\"", "theorem infinite_UNIV_sum1 [simp]:\n\"infinite (UNIV :: 'a set) \\<Longrightarrow>\n infinite (UNIV :: ('a + 'b) set)\"", "theorem infinite_UNIV_sum2 [simp]:\n\"infinite (UNIV :: 'b set) \\<Longrightarrow>\n infinite (UNIV :: ('a + 'b) set)\"", "theorem infinite_UNIV_list [simp]:\n\"infinite (UNIV :: 'a list set)\"", "theorem infinite_UNIV_option [simp]:\n\"infinite (UNIV :: 'a set) \\<Longrightarrow>\n infinite (UNIV :: 'a option set)\"", "theorem infinite_image [intro]:\n\"infinite A \\<Longrightarrow> inj_on f A \\<Longrightarrow> infinite (f ` A)\"", "theorem infinite_transfer (*[intro]*) :\n\"infinite B \\<Longrightarrow> B \\<subseteq> f ` A \\<Longrightarrow> infinite A\""], "translations": [["", "lemmas infinite_UNIV_int [simp]"], ["", "theorem infinite_UNIV_real [simp]:\n\"infinite (UNIV :: real set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "by (rule infinite_UNIV_char_0)"], ["", "theorem infinite_UNIV_fun1 [simp]:\n\"infinite (UNIV :: 'a set) \\<Longrightarrow>\n card (UNIV :: 'b set) \\<noteq> Suc 0 \\<Longrightarrow>\n infinite (UNIV :: ('a \\<Rightarrow> 'b) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite UNIV; card UNIV \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> infinite UNIV", "apply (erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>card UNIV \\<noteq> Suc 0; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> finite UNIV", "apply (erule finite_fun_UNIVD1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card UNIV \\<noteq> Suc 0 \\<Longrightarrow> card UNIV \\<noteq> Suc 0", "apply (assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem infinite_UNIV_fun2 [simp]:\n\"infinite (UNIV :: 'b set) \\<Longrightarrow>\n infinite (UNIV :: ('a \\<Rightarrow> 'b) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV \\<Longrightarrow> infinite UNIV", "apply (erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finite UNIV", "apply (erule finite_fun_UNIVD2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem infinite_UNIV_set [simp]:\n\"infinite (UNIV :: 'a set) \\<Longrightarrow>\n infinite (UNIV :: 'a set set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV \\<Longrightarrow> infinite UNIV", "apply (erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finite UNIV", "apply (simp add: Finite_Set.finite_set)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem infinite_UNIV_prod1 [simp]:\n\"infinite (UNIV :: 'a set) \\<Longrightarrow>\n infinite (UNIV :: ('a \\<times> 'b) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV \\<Longrightarrow> infinite UNIV", "apply (erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finite UNIV", "apply (simp add: finite_prod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem infinite_UNIV_prod2 [simp]:\n\"infinite (UNIV :: 'b set) \\<Longrightarrow>\n infinite (UNIV :: ('a \\<times> 'b) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV \\<Longrightarrow> infinite UNIV", "apply (erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finite UNIV", "apply (simp add: finite_prod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem infinite_UNIV_sum1 [simp]:\n\"infinite (UNIV :: 'a set) \\<Longrightarrow>\n infinite (UNIV :: ('a + 'b) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV \\<Longrightarrow> infinite UNIV", "apply (erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finite UNIV", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem infinite_UNIV_sum2 [simp]:\n\"infinite (UNIV :: 'b set) \\<Longrightarrow>\n infinite (UNIV :: ('a + 'b) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV \\<Longrightarrow> infinite UNIV", "apply (erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finite UNIV", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem infinite_UNIV_list [simp]:\n\"infinite (UNIV :: 'a list set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "apply (rule infinite_UNIV_listI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem infinite_UNIV_option [simp]:\n\"infinite (UNIV :: 'a set) \\<Longrightarrow>\n infinite (UNIV :: 'a option set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV \\<Longrightarrow> infinite UNIV", "apply (erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finite UNIV", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem infinite_image [intro]:\n\"infinite A \\<Longrightarrow> inj_on f A \\<Longrightarrow> infinite (f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite A; inj_on f A\\<rbrakk>\n    \\<Longrightarrow> infinite (f ` A)", "apply (metis finite_imageD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem infinite_transfer (*[intro]*) :\n\"infinite B \\<Longrightarrow> B \\<subseteq> f ` A \\<Longrightarrow> infinite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite B; B \\<subseteq> f ` A\\<rbrakk>\n    \\<Longrightarrow> infinite A", "using infinite_super"], ["proof (prove)\nusing this:\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite B; B \\<subseteq> f ` A\\<rbrakk>\n    \\<Longrightarrow> infinite A", "apply (blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open> Instantiations \\<close>"], ["", "text \\<open>\n  The instantiations for product and sum types have stronger caveats than in\n  principle needed. Namely, it would be sufficient for one type of a product\n  or sum to be infinite. A corresponding rule, however, cannot be formulated\n  using type classes. Generally, classes are not entirely adequate for the\n  purpose of deriving the infinity of HOL types, which is perhaps why a class\n  such as @{class infinite} was omitted from the Isabelle/HOL library.\n\\<close>"], ["", "instance nat :: infinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, infinite_class)", "by (intro_classes, simp)"], ["", "instance int :: infinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(int, infinite_class)", "by (intro_classes, simp)"], ["", "instance real :: infinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real, infinite_class)", "by (intro_classes, simp)"], ["", "instance \"fun\" :: (type, infinite) infinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, infinite_class)", "by (intro_classes, simp)"], ["", "instance set :: (infinite) infinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, infinite_class)", "by (intro_classes, simp)"], ["", "instance prod :: (infinite, infinite) infinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, infinite_class)", "by (intro_classes, simp)"], ["", "instance sum :: (infinite, infinite) infinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, infinite_class)", "by (intro_classes, simp)"], ["", "instance list :: (type) infinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, infinite_class)", "by (intro_classes, simp)"], ["", "instance option :: (infinite) infinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a option, infinite_class)", "by (intro_classes, simp)"], ["", "subclass (in infinite) two"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.two TYPE('a)", "by (intro_classes, auto)"], ["", "end"]]}