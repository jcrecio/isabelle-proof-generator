{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/utp/utp_pred.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["theorem upred_ref_iff [uexpr_transfer_laws]:\n\"(P \\<sqsubseteq> Q) = (\\<forall>b. \\<lbrakk>Q\\<rbrakk>\\<^sub>e b \\<longrightarrow> \\<lbrakk>P\\<rbrakk>\\<^sub>e b)\"", "lemma top_uexpr_rep_eq [simp]: \n  \"\\<lbrakk>Orderings.bot\\<rbrakk>\\<^sub>e b = False\"", "lemma bot_uexpr_rep_eq [simp]: \n  \"\\<lbrakk>Orderings.top\\<rbrakk>\\<^sub>e b = True\"", "lemma true_alt_def: \"true = \\<guillemotleft>True\\<guillemotright>\"", "lemma false_alt_def: \"false = \\<guillemotleft>False\\<guillemotright>\"", "lemma unrest_allE:\n  \"\\<lbrakk> \\<Sigma> \\<sharp> P; P = true \\<Longrightarrow> Q; P = false \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\"", "lemma unrest_true [unrest]: \"x \\<sharp> true\"", "lemma unrest_false [unrest]: \"x \\<sharp> false\"", "lemma unrest_conj [unrest]: \"\\<lbrakk> x \\<sharp> (P :: '\\<alpha> upred); x \\<sharp> Q \\<rbrakk> \\<Longrightarrow> x \\<sharp> P \\<and> Q\"", "lemma unrest_disj [unrest]: \"\\<lbrakk> x \\<sharp> (P :: '\\<alpha> upred); x \\<sharp> Q \\<rbrakk> \\<Longrightarrow> x \\<sharp> P \\<or> Q\"", "lemma unrest_UINF [unrest]:\n  \"\\<lbrakk> (\\<And> i. x \\<sharp> P(i)); (\\<And> i. x \\<sharp> Q(i)) \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<Sqinter> i | P(i) \\<bullet> Q(i))\"", "lemma unrest_USUP [unrest]:\n  \"\\<lbrakk> (\\<And> i. x \\<sharp> P(i)); (\\<And> i. x \\<sharp> Q(i)) \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<Squnion> i | P(i) \\<bullet> Q(i))\"", "lemma unrest_UINF_mem [unrest]:\n  \"\\<lbrakk>(\\<And> i. i \\<in> A \\<Longrightarrow> x \\<sharp> P(i)) \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<Sqinter> i\\<in>A \\<bullet> P(i))\"", "lemma unrest_USUP_mem [unrest]:\n  \"\\<lbrakk>(\\<And> i. i \\<in> A \\<Longrightarrow> x \\<sharp> P(i)) \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<Squnion> i\\<in>A \\<bullet> P(i))\"", "lemma unrest_impl [unrest]: \"\\<lbrakk> x \\<sharp> P; x \\<sharp> Q \\<rbrakk> \\<Longrightarrow> x \\<sharp> P \\<Rightarrow> Q\"", "lemma unrest_iff [unrest]: \"\\<lbrakk> x \\<sharp> P; x \\<sharp> Q \\<rbrakk> \\<Longrightarrow> x \\<sharp> P \\<Leftrightarrow> Q\"", "lemma unrest_not [unrest]: \"x \\<sharp> (P :: '\\<alpha> upred) \\<Longrightarrow> x \\<sharp> (\\<not> P)\"", "lemma unrest_ex_in [unrest]:\n  \"\\<lbrakk> mwb_lens y; x \\<subseteq>\\<^sub>L y \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<exists> y \\<bullet> P)\"", "lemma unrest_ex_diff [unrest]:\n  assumes \"x \\<bowtie> y\" \"y \\<sharp> P\"\n  shows \"y \\<sharp> (\\<exists> x \\<bullet> P)\"", "lemma unrest_all_in [unrest]:\n  \"\\<lbrakk> mwb_lens y; x \\<subseteq>\\<^sub>L y \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<forall> y \\<bullet> P)\"", "lemma unrest_all_diff [unrest]:\n  assumes \"x \\<bowtie> y\" \"y \\<sharp> P\"\n  shows \"y \\<sharp> (\\<forall> x \\<bullet> P)\"", "lemma unrest_var_res_diff [unrest]:\n  assumes \"x \\<bowtie> y\"\n  shows \"y \\<sharp> (P \\<restriction>\\<^sub>v x)\"", "lemma unrest_var_res_in [unrest]:\n  assumes \"mwb_lens x\" \"y \\<subseteq>\\<^sub>L x\" \"y \\<sharp> P\"\n  shows \"y \\<sharp> (P \\<restriction>\\<^sub>v x)\"", "lemma unrest_shEx [unrest]:\n  assumes \"\\<And> y. x \\<sharp> P(y)\"\n  shows \"x \\<sharp> (\\<^bold>\\<exists> y \\<bullet> P(y))\"", "lemma unrest_shAll [unrest]:\n  assumes \"\\<And> y. x \\<sharp> P(y)\"\n  shows \"x \\<sharp> (\\<^bold>\\<forall> y \\<bullet> P(y))\"", "lemma unrest_closure [unrest]:\n  \"x \\<sharp> [P]\\<^sub>u\"", "lemma usedBy_not [unrest]:\n  \"\\<lbrakk> x \\<natural> P \\<rbrakk> \\<Longrightarrow> x \\<natural> (\\<not> P)\"", "lemma usedBy_conj [unrest]:\n  \"\\<lbrakk> x \\<natural> P; x \\<natural> Q \\<rbrakk> \\<Longrightarrow> x \\<natural> (P \\<and> Q)\"", "lemma usedBy_disj [unrest]:\n  \"\\<lbrakk> x \\<natural> P; x \\<natural> Q \\<rbrakk> \\<Longrightarrow> x \\<natural> (P \\<or> Q)\"", "lemma usedBy_impl [unrest]:\n  \"\\<lbrakk> x \\<natural> P; x \\<natural> Q \\<rbrakk> \\<Longrightarrow> x \\<natural> (P \\<Rightarrow> Q)\"", "lemma usedBy_iff [unrest]:\n  \"\\<lbrakk> x \\<natural> P; x \\<natural> Q \\<rbrakk> \\<Longrightarrow> x \\<natural> (P \\<Leftrightarrow> Q)\"", "lemma subst_mono: \"P \\<sqsubseteq> Q \\<Longrightarrow> (\\<sigma> \\<dagger> P) \\<sqsubseteq> (\\<sigma> \\<dagger> Q)\"", "lemma subst_true [usubst]: \"\\<sigma> \\<dagger> true = true\"", "lemma subst_false [usubst]: \"\\<sigma> \\<dagger> false = false\"", "lemma subst_not [usubst]: \"\\<sigma> \\<dagger> (\\<not> P) = (\\<not> \\<sigma> \\<dagger> P)\"", "lemma subst_impl [usubst]: \"\\<sigma> \\<dagger> (P \\<Rightarrow> Q) = (\\<sigma> \\<dagger> P \\<Rightarrow> \\<sigma> \\<dagger> Q)\"", "lemma subst_iff [usubst]: \"\\<sigma> \\<dagger> (P \\<Leftrightarrow> Q) = (\\<sigma> \\<dagger> P \\<Leftrightarrow> \\<sigma> \\<dagger> Q)\"", "lemma subst_disj [usubst]: \"\\<sigma> \\<dagger> (P \\<or> Q) = (\\<sigma> \\<dagger> P \\<or> \\<sigma> \\<dagger> Q)\"", "lemma subst_conj [usubst]: \"\\<sigma> \\<dagger> (P \\<and> Q) = (\\<sigma> \\<dagger> P \\<and> \\<sigma> \\<dagger> Q)\"", "lemma subst_sup [usubst]: \"\\<sigma> \\<dagger> (P \\<sqinter> Q) = (\\<sigma> \\<dagger> P \\<sqinter> \\<sigma> \\<dagger> Q)\"", "lemma subst_inf [usubst]: \"\\<sigma> \\<dagger> (P \\<squnion> Q) = (\\<sigma> \\<dagger> P \\<squnion> \\<sigma> \\<dagger> Q)\"", "lemma subst_UINF [usubst]: \"\\<sigma> \\<dagger> (\\<Sqinter> i | P(i) \\<bullet> Q(i)) = (\\<Sqinter> i | (\\<sigma> \\<dagger> P(i)) \\<bullet> (\\<sigma> \\<dagger> Q(i)))\"", "lemma subst_USUP [usubst]: \"\\<sigma> \\<dagger> (\\<Squnion> i | P(i) \\<bullet> Q(i)) = (\\<Squnion> i | (\\<sigma> \\<dagger> P(i)) \\<bullet> (\\<sigma> \\<dagger> Q(i)))\"", "lemma subst_closure [usubst]: \"\\<sigma> \\<dagger> [P]\\<^sub>u = [P]\\<^sub>u\"", "lemma subst_shEx [usubst]: \"\\<sigma> \\<dagger> (\\<^bold>\\<exists> x \\<bullet> P(x)) = (\\<^bold>\\<exists> x \\<bullet> \\<sigma> \\<dagger> P(x))\"", "lemma subst_shAll [usubst]: \"\\<sigma> \\<dagger> (\\<^bold>\\<forall> x \\<bullet> P(x)) = (\\<^bold>\\<forall> x \\<bullet> \\<sigma> \\<dagger> P(x))\"", "lemma subst_ex_same [usubst]:\n  \"mwb_lens x \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> (\\<exists> x \\<bullet> P) = \\<sigma> \\<dagger> (\\<exists> x \\<bullet> P)\"", "lemma subst_ex_same' [usubst]:\n  \"mwb_lens x \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> (\\<exists> &x \\<bullet> P) = \\<sigma> \\<dagger> (\\<exists> &x \\<bullet> P)\"", "lemma subst_ex_indep [usubst]:\n  assumes \"x \\<bowtie> y\" \"y \\<sharp> v\"\n  shows \"(\\<exists> y \\<bullet> P)\\<lbrakk>v/x\\<rbrakk> = (\\<exists> y \\<bullet> P\\<lbrakk>v/x\\<rbrakk>)\"", "lemma subst_ex_unrest [usubst]:\n  \"x \\<sharp> \\<sigma> \\<Longrightarrow> \\<sigma> \\<dagger> (\\<exists> x \\<bullet> P) = (\\<exists> x \\<bullet> \\<sigma> \\<dagger> P)\"", "lemma subst_all_same [usubst]:\n  \"mwb_lens x \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> (\\<forall> x \\<bullet> P) = \\<sigma> \\<dagger> (\\<forall> x \\<bullet> P)\"", "lemma subst_all_indep [usubst]:\n  assumes \"x \\<bowtie> y\" \"y \\<sharp> v\"\n  shows \"(\\<forall> y \\<bullet> P)\\<lbrakk>v/x\\<rbrakk> = (\\<forall> y \\<bullet> P\\<lbrakk>v/x\\<rbrakk>)\"", "lemma msubst_true [usubst]: \"true\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = true\"", "lemma msubst_false [usubst]: \"false\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = false\"", "lemma msubst_not [usubst]: \"(\\<not> P(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = (\\<not> ((P x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk>))\"", "lemma msubst_not_2 [usubst]: \"(\\<not> P x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> = (\\<not> ((P x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk>))\"", "lemma msubst_disj [usubst]: \"(P(x) \\<or> Q(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = ((P(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk> \\<or> (Q(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk>)\"", "lemma msubst_disj_2 [usubst]: \"(P x y \\<or> Q x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> = ((P x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> \\<or> (Q x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk>)\"", "lemma msubst_conj [usubst]: \"(P(x) \\<and> Q(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = ((P(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk> \\<and> (Q(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk>)\"", "lemma msubst_conj_2 [usubst]: \"(P x y \\<and> Q x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> = ((P x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> \\<and> (Q x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk>)\"", "lemma msubst_implies [usubst]:\n  \"(P x \\<Rightarrow> Q x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = ((P x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk> \\<Rightarrow> (Q x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk>)\"", "lemma msubst_implies_2 [usubst]:\n  \"(P x y \\<Rightarrow> Q x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> = ((P x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> \\<Rightarrow> (Q x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk>)\"", "lemma msubst_shAll [usubst]:\n  \"(\\<^bold>\\<forall> x \\<bullet> P x y)\\<lbrakk>y\\<rightarrow>v\\<rbrakk> = (\\<^bold>\\<forall> x \\<bullet> (P x y)\\<lbrakk>y\\<rightarrow>v\\<rbrakk>)\"", "lemma msubst_shAll_2 [usubst]:\n  \"(\\<^bold>\\<forall> x \\<bullet> P x y z)\\<lbrakk>(y,z)\\<rightarrow>v\\<rbrakk> = (\\<^bold>\\<forall> x \\<bullet> (P x y z)\\<lbrakk>(y,z)\\<rightarrow>v\\<rbrakk>)\""], "translations": [["", "theorem upred_ref_iff [uexpr_transfer_laws]:\n\"(P \\<sqsubseteq> Q) = (\\<forall>b. \\<lbrakk>Q\\<rbrakk>\\<^sub>e b \\<longrightarrow> \\<lbrakk>P\\<rbrakk>\\<^sub>e b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<sqsubseteq> Q) =\n    (\\<forall>b.\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e b \\<longrightarrow>\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e b)", "apply (transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Q P.\n       (\\<forall>A. Q A \\<le> P A) = (\\<forall>b. Q b \\<longrightarrow> P b)", "apply (clarsimp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open> Next we introduce the lattice operators, which is again done by lifting. \\<close>"], ["", "instantiation uexpr :: (lattice, type) lattice\nbegin"], ["", "lift_definition sup_uexpr :: \"('a, 'b) uexpr \\<Rightarrow> ('a, 'b) uexpr \\<Rightarrow> ('a, 'b) uexpr\"\n  is \"\\<lambda>P Q A. Lattices.sup (P A) (Q A)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition inf_uexpr :: \"('a, 'b) uexpr \\<Rightarrow> ('a, 'b) uexpr \\<Rightarrow> ('a, 'b) uexpr\"\n  is \"\\<lambda>P Q A. Lattices.inf (P A) (Q A)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, lattice_class)", "by (intro_classes) (transfer, auto)+"], ["", "end"], ["", "instantiation uexpr :: (bounded_lattice, type) bounded_lattice\nbegin"], ["", "lift_definition bot_uexpr :: \"('a, 'b) uexpr\" is \"\\<lambda> A. Orderings.bot\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition top_uexpr :: \"('a, 'b) uexpr\" is \"\\<lambda> A. Orderings.top\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, bounded_lattice_class)", "by (intro_classes) (transfer, auto)+"], ["", "end"], ["", "lemma top_uexpr_rep_eq [simp]: \n  \"\\<lbrakk>Orderings.bot\\<rbrakk>\\<^sub>e b = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<top>\\<rbrakk>\\<^sub>e b = False", "by (transfer, auto)"], ["", "lemma bot_uexpr_rep_eq [simp]: \n  \"\\<lbrakk>Orderings.top\\<rbrakk>\\<^sub>e b = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bottom>\\<rbrakk>\\<^sub>e b = True", "by (transfer, auto)"], ["", "instance uexpr :: (distrib_lattice, type) distrib_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, distrib_lattice_class)", "by (intro_classes) (transfer, rule ext, auto simp add: sup_inf_distrib1)"], ["", "text \\<open> Finally we show that predicates form a Boolean algebra (under the lattice operators),\n  a complete lattice, a completely distribute lattice, and a complete boolean algebra. This\n  equip us with a very complete theory for basic logical propositions. \\<close>"], ["", "instance uexpr :: (boolean_algebra, type) boolean_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, boolean_algebra_class)", "apply (intro_classes, unfold uexpr_defs; transfer, rule ext)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x A. x A \\<squnion> - x A = \\<top>\n 2. \\<And>x A. x A \\<sqinter> - x A = \\<bottom>\n 3. \\<And>x y b. x b - y b = x b \\<squnion> - y b", "apply (simp_all add: sup_inf_distrib1 diff_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instantiation uexpr :: (complete_lattice, type) complete_lattice\nbegin"], ["", "lift_definition Inf_uexpr :: \"('a, 'b) uexpr set \\<Rightarrow> ('a, 'b) uexpr\"\n  is \"\\<lambda> PS A. INF P\\<in>PS. P(A)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition Sup_uexpr :: \"('a, 'b) uexpr set \\<Rightarrow> ('a, 'b) uexpr\"\n  is \"\\<lambda> PS A. SUP P\\<in>PS. P(A)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, complete_lattice_class)", "by (intro_classes)\n     (transfer, auto intro: INF_lower SUP_upper simp add: INF_greatest SUP_least)+"], ["", "end"], ["", "instance uexpr :: (complete_distrib_lattice, type) complete_distrib_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, complete_distrib_lattice_class)", "by (intro_classes; transfer; auto simp add: INF_SUP_set)"], ["", "instance uexpr :: (complete_boolean_algebra, type) complete_boolean_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) uexpr, complete_boolean_algebra_class)", ".."], ["", "text \\<open> From the complete lattice, we can also define and give syntax for the fixed-point operators. \n  Like the lattice operators, these are reversed in UTP. \\<close>"], ["", "syntax\n  \"_mu\" :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic\" (\"\\<mu> _ \\<bullet> _\" [0, 10] 10)\n  \"_nu\" :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic\" (\"\\<nu> _ \\<bullet> _\" [0, 10] 10)"], ["", "notation gfp (\"\\<mu>\")"], ["", "notation lfp (\"\\<nu>\")"], ["", "translations\n  \"\\<nu> X \\<bullet> P\" == \"CONST lfp (\\<lambda> X. P)\"\n  \"\\<mu> X \\<bullet> P\" == \"CONST gfp (\\<lambda> X. P)\""], ["", "text \\<open> With the lattice operators defined, we can proceed to give definitions for the\n        standard predicate operators in terms of them. \\<close>"], ["", "definition \"true_upred  = (Orderings.top :: '\\<alpha> upred)\""], ["", "definition \"false_upred = (Orderings.bot :: '\\<alpha> upred)\""], ["", "definition \"conj_upred  = (Lattices.inf :: '\\<alpha> upred \\<Rightarrow> '\\<alpha> upred \\<Rightarrow> '\\<alpha> upred)\""], ["", "definition \"disj_upred  = (Lattices.sup :: '\\<alpha> upred \\<Rightarrow> '\\<alpha> upred \\<Rightarrow> '\\<alpha> upred)\""], ["", "definition \"not_upred   = (uminus :: '\\<alpha> upred \\<Rightarrow> '\\<alpha> upred)\""], ["", "definition \"diff_upred  = (minus :: '\\<alpha> upred \\<Rightarrow> '\\<alpha> upred \\<Rightarrow> '\\<alpha> upred)\""], ["", "abbreviation Conj_upred :: \"'\\<alpha> upred set \\<Rightarrow> '\\<alpha> upred\" (\"\\<And>_\" [900] 900) where\n\"\\<And> A \\<equiv> \\<Squnion> A\""], ["", "abbreviation Disj_upred :: \"'\\<alpha> upred set \\<Rightarrow> '\\<alpha> upred\" (\"\\<Or>_\" [900] 900) where\n\"\\<Or> A \\<equiv> \\<Sqinter> A\""], ["", "notation\n  conj_upred (infixr \"\\<and>\\<^sub>p\" 35) and\n  disj_upred (infixr \"\\<or>\\<^sub>p\" 30)"], ["", "text \\<open> Perhaps slightly confusingly, the UTP infimum is the HOL supremum and vice-versa. This is\n  because, again, in UTP the lattice is inverted due to the definition of refinement and a desire\n  to have miracle at the top, and abort at the bottom. \\<close>"], ["", "lift_definition UINF :: \"('a \\<Rightarrow> '\\<alpha> upred) \\<Rightarrow> ('a \\<Rightarrow> ('b::complete_lattice, '\\<alpha>) uexpr) \\<Rightarrow> ('b, '\\<alpha>) uexpr\"\nis \"\\<lambda> P F b. Sup {\\<lbrakk>F x\\<rbrakk>\\<^sub>eb | x. \\<lbrakk>P x\\<rbrakk>\\<^sub>eb}\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition USUP :: \"('a \\<Rightarrow> '\\<alpha> upred) \\<Rightarrow> ('a \\<Rightarrow> ('b::complete_lattice, '\\<alpha>) uexpr) \\<Rightarrow> ('b, '\\<alpha>) uexpr\"\nis \"\\<lambda> P F b. Inf {\\<lbrakk>F x\\<rbrakk>\\<^sub>eb | x. \\<lbrakk>P x\\<rbrakk>\\<^sub>eb}\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "syntax\n  \"_USup\"     :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic\"            (\"\\<And> _ \\<bullet> _\" [0, 10] 10)\n  \"_USup\"     :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic\"            (\"\\<Squnion> _ \\<bullet> _\" [0, 10] 10)\n  \"_USup_mem\" :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic \\<Rightarrow> logic\"   (\"\\<And> _ \\<in> _ \\<bullet> _\" [0, 10] 10)\n  \"_USup_mem\" :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic \\<Rightarrow> logic\"   (\"\\<Squnion> _ \\<in> _ \\<bullet> _\" [0, 10] 10)\n  \"_USUP\"     :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic \\<Rightarrow> logic\"   (\"\\<And> _ | _ \\<bullet> _\" [0, 0, 10] 10)\n  \"_USUP\"     :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic \\<Rightarrow> logic\"   (\"\\<Squnion> _ | _ \\<bullet> _\" [0, 0, 10] 10)\n  \"_UInf\"     :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic\"            (\"\\<Or> _ \\<bullet> _\" [0, 10] 10)\n  \"_UInf\"     :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic\"            (\"\\<Sqinter> _ \\<bullet> _\" [0, 10] 10)\n  \"_UInf_mem\" :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic \\<Rightarrow> logic\"   (\"\\<Or> _ \\<in> _ \\<bullet> _\" [0, 10] 10)\n  \"_UInf_mem\" :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic \\<Rightarrow> logic\"   (\"\\<Sqinter> _ \\<in> _ \\<bullet> _\" [0, 10] 10)\n  \"_UINF\"     :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic \\<Rightarrow> logic\"   (\"\\<Or> _ | _ \\<bullet> _\" [0, 10] 10)\n  \"_UINF\"     :: \"pttrn \\<Rightarrow> logic \\<Rightarrow> logic \\<Rightarrow> logic\"   (\"\\<Sqinter> _ | _ \\<bullet> _\" [0, 10] 10)"], ["", "translations\n  \"\\<Sqinter> x | P \\<bullet> F\" => \"CONST UINF (\\<lambda> x. P) (\\<lambda> x. F)\"\n  \"\\<Sqinter> x \\<bullet> F\"     == \"\\<Sqinter> x | true \\<bullet> F\"\n  \"\\<Sqinter> x \\<bullet> F\"     == \"\\<Sqinter> x | true \\<bullet> F\"\n  \"\\<Sqinter> x \\<in> A \\<bullet> F\" => \"\\<Sqinter> x | \\<guillemotleft>x\\<guillemotright> \\<in>\\<^sub>u \\<guillemotleft>A\\<guillemotright> \\<bullet> F\"\n  \"\\<Sqinter> x \\<in> A \\<bullet> F\" <= \"\\<Sqinter> x | \\<guillemotleft>y\\<guillemotright> \\<in>\\<^sub>u \\<guillemotleft>A\\<guillemotright> \\<bullet> F\"\n  \"\\<Sqinter> x | P \\<bullet> F\" <= \"CONST UINF (\\<lambda> y. P) (\\<lambda> x. F)\"\n  \"\\<Sqinter> x | P \\<bullet> F(x)\" <= \"CONST UINF (\\<lambda> x. P) F\"\n  \"\\<Squnion> x | P \\<bullet> F\" => \"CONST USUP (\\<lambda> x. P) (\\<lambda> x. F)\"\n  \"\\<Squnion> x \\<bullet> F\"     == \"\\<Squnion> x | true \\<bullet> F\"\n  \"\\<Squnion> x \\<in> A \\<bullet> F\" => \"\\<Squnion> x | \\<guillemotleft>x\\<guillemotright> \\<in>\\<^sub>u \\<guillemotleft>A\\<guillemotright> \\<bullet> F\"\n  \"\\<Squnion> x \\<in> A \\<bullet> F\" <= \"\\<Squnion> x | \\<guillemotleft>y\\<guillemotright> \\<in>\\<^sub>u \\<guillemotleft>A\\<guillemotright> \\<bullet> F\"\n  \"\\<Squnion> x | P \\<bullet> F\" <= \"CONST USUP (\\<lambda> y. P) (\\<lambda> x. F)\"\n  \"\\<Squnion> x | P \\<bullet> F(x)\" <= \"CONST USUP (\\<lambda> x. P) F\""], ["", "text \\<open> We also define the other predicate operators \\<close>"], ["", "lift_definition impl::\"'\\<alpha> upred \\<Rightarrow> '\\<alpha> upred \\<Rightarrow> '\\<alpha> upred\" is\n\"\\<lambda> P Q A. P A \\<longrightarrow> Q A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition iff_upred ::\"'\\<alpha> upred \\<Rightarrow> '\\<alpha> upred \\<Rightarrow> '\\<alpha> upred\" is\n\"\\<lambda> P Q A. P A \\<longleftrightarrow> Q A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition ex :: \"('a \\<Longrightarrow> '\\<alpha>) \\<Rightarrow> '\\<alpha> upred \\<Rightarrow> '\\<alpha> upred\" is\n\"\\<lambda> x P b. (\\<exists> v. P(put\\<^bsub>x\\<^esub> b v))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition shEx ::\"['\\<beta> \\<Rightarrow>'\\<alpha> upred] \\<Rightarrow> '\\<alpha> upred\" is\n\"\\<lambda> P A. \\<exists> x. (P x) A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition all :: \"('a \\<Longrightarrow> '\\<alpha>) \\<Rightarrow> '\\<alpha> upred \\<Rightarrow> '\\<alpha> upred\" is\n\"\\<lambda> x P b. (\\<forall> v. P(put\\<^bsub>x\\<^esub> b v))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition shAll ::\"['\\<beta> \\<Rightarrow>'\\<alpha> upred] \\<Rightarrow> '\\<alpha> upred\" is\n\"\\<lambda> P A. \\<forall> x. (P x) A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open> We define the following operator which is dual of existential quantification. It hides the\n  valuation of variables other than $x$ through existential quantification. \\<close>"], ["", "lift_definition var_res :: \"'\\<alpha> upred \\<Rightarrow> ('a \\<Longrightarrow> '\\<alpha>) \\<Rightarrow> '\\<alpha> upred\" is\n\"\\<lambda> P x b. \\<exists> b'. P (b' \\<oplus>\\<^sub>L b on x)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "translations\n  \"_uvar_res P a\" \\<rightleftharpoons> \"CONST var_res P a\""], ["", "text \\<open> We have to add a u subscript to the closure operator as I don't want to override the syntax\n        for HOL lists (we'll be using them later). \\<close>"], ["", "lift_definition closure::\"'\\<alpha> upred \\<Rightarrow> '\\<alpha> upred\" (\"[_]\\<^sub>u\") is\n\"\\<lambda> P A. \\<forall>A'. P A'\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition taut :: \"'\\<alpha> upred \\<Rightarrow> bool\" (\"`_`\")\nis \"\\<lambda> P. \\<forall> A. P A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open> Configuration for UTP tactics \\<close>"], ["", "update_uexpr_rep_eq_thms \\<comment> \\<open> Reread @{text rep_eq} theorems. \\<close>"], ["", "declare utp_pred.taut.rep_eq [upred_defs]"], ["", "adhoc_overloading\n  utrue \"true_upred\" and\n  ufalse \"false_upred\" and\n  unot \"not_upred\" and\n  uconj \"conj_upred\" and\n  udisj \"disj_upred\" and\n  uimpl impl and\n  uiff iff_upred and\n  uex ex and\n  uall all and\n  ushEx shEx and\n  ushAll shAll"], ["", "syntax\n  \"_uneq\"       :: \"logic \\<Rightarrow> logic \\<Rightarrow> logic\" (infixl \"\\<noteq>\\<^sub>u\" 50)\n  \"_unmem\"      :: \"('a, '\\<alpha>) uexpr \\<Rightarrow> ('a set, '\\<alpha>) uexpr \\<Rightarrow> (bool, '\\<alpha>) uexpr\" (infix \"\\<notin>\\<^sub>u\" 50)"], ["", "translations\n  \"x \\<noteq>\\<^sub>u y\" == \"CONST unot (x =\\<^sub>u y)\"\n  \"x \\<notin>\\<^sub>u A\" == \"CONST unot (CONST bop (\\<in>) x A)\""], ["", "declare true_upred_def [upred_defs]"], ["", "declare false_upred_def [upred_defs]"], ["", "declare conj_upred_def [upred_defs]"], ["", "declare disj_upred_def [upred_defs]"], ["", "declare not_upred_def [upred_defs]"], ["", "declare diff_upred_def [upred_defs]"], ["", "declare subst_upd_uvar_def [upred_defs]"], ["", "declare cond_subst_def [upred_defs]"], ["", "declare par_subst_def [upred_defs]"], ["", "declare subst_del_def [upred_defs]"], ["", "declare unrest_usubst_def [upred_defs]"], ["", "declare uexpr_defs [upred_defs]"], ["", "lemma true_alt_def: \"true = \\<guillemotleft>True\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. true = \\<guillemotleft>True\\<guillemotright>", "by (pred_auto)"], ["", "lemma false_alt_def: \"false = \\<guillemotleft>False\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. false = \\<guillemotleft>False\\<guillemotright>", "by (pred_auto)"], ["", "declare true_alt_def[THEN sym,simp]"], ["", "declare false_alt_def[THEN sym,simp]"], ["", "subsection \\<open> Unrestriction Laws \\<close>"], ["", "lemma unrest_allE:\n  \"\\<lbrakk> \\<Sigma> \\<sharp> P; P = true \\<Longrightarrow> Q; P = false \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Sigma> \\<sharp> P; P = true \\<Longrightarrow> Q;\n     P = false \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by (pred_auto)"], ["", "lemma unrest_true [unrest]: \"x \\<sharp> true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> true", "by (pred_auto)"], ["", "lemma unrest_false [unrest]: \"x \\<sharp> false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> false", "by (pred_auto)"], ["", "lemma unrest_conj [unrest]: \"\\<lbrakk> x \\<sharp> (P :: '\\<alpha> upred); x \\<sharp> Q \\<rbrakk> \\<Longrightarrow> x \\<sharp> P \\<and> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> P; x \\<sharp> Q\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> P \\<and> Q", "by (pred_auto)"], ["", "lemma unrest_disj [unrest]: \"\\<lbrakk> x \\<sharp> (P :: '\\<alpha> upred); x \\<sharp> Q \\<rbrakk> \\<Longrightarrow> x \\<sharp> P \\<or> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> P; x \\<sharp> Q\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> P \\<or> Q", "by (pred_auto)"], ["", "lemma unrest_UINF [unrest]:\n  \"\\<lbrakk> (\\<And> i. x \\<sharp> P(i)); (\\<And> i. x \\<sharp> Q(i)) \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<Sqinter> i | P(i) \\<bullet> Q(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i. x \\<sharp> P i; \\<And>i. x \\<sharp> Q i\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> UINF P Q", "by (pred_auto)"], ["", "lemma unrest_USUP [unrest]:\n  \"\\<lbrakk> (\\<And> i. x \\<sharp> P(i)); (\\<And> i. x \\<sharp> Q(i)) \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<Squnion> i | P(i) \\<bullet> Q(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i. x \\<sharp> P i; \\<And>i. x \\<sharp> Q i\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> USUP P Q", "by (pred_auto)"], ["", "lemma unrest_UINF_mem [unrest]:\n  \"\\<lbrakk>(\\<And> i. i \\<in> A \\<Longrightarrow> x \\<sharp> P(i)) \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<Sqinter> i\\<in>A \\<bullet> P(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> A \\<Longrightarrow> x \\<sharp> P i) \\<Longrightarrow>\n    x \\<sharp> (\\<Sqinter> i \\<in> A \\<bullet> P i)", "by (pred_simp, metis)"], ["", "lemma unrest_USUP_mem [unrest]:\n  \"\\<lbrakk>(\\<And> i. i \\<in> A \\<Longrightarrow> x \\<sharp> P(i)) \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<Squnion> i\\<in>A \\<bullet> P(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> A \\<Longrightarrow> x \\<sharp> P i) \\<Longrightarrow>\n    x \\<sharp> (\\<Squnion> i \\<in> A \\<bullet> P i)", "by (pred_simp, metis)"], ["", "lemma unrest_impl [unrest]: \"\\<lbrakk> x \\<sharp> P; x \\<sharp> Q \\<rbrakk> \\<Longrightarrow> x \\<sharp> P \\<Rightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> P; x \\<sharp> Q\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> P \\<Rightarrow> Q", "by (pred_auto)"], ["", "lemma unrest_iff [unrest]: \"\\<lbrakk> x \\<sharp> P; x \\<sharp> Q \\<rbrakk> \\<Longrightarrow> x \\<sharp> P \\<Leftrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> P; x \\<sharp> Q\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> P \\<Leftrightarrow> Q", "by (pred_auto)"], ["", "lemma unrest_not [unrest]: \"x \\<sharp> (P :: '\\<alpha> upred) \\<Longrightarrow> x \\<sharp> (\\<not> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> P \\<Longrightarrow> x \\<sharp> \\<not> P", "by (pred_auto)"], ["", "text \\<open> The sublens proviso can be thought of as membership below. \\<close>"], ["", "lemma unrest_ex_in [unrest]:\n  \"\\<lbrakk> mwb_lens y; x \\<subseteq>\\<^sub>L y \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<exists> y \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens y; x \\<subseteq>\\<^sub>L y\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> (\\<exists> y \\<bullet> P)", "by (pred_auto)"], ["", "declare sublens_refl [simp]"], ["", "declare lens_plus_ub [simp]"], ["", "declare lens_plus_right_sublens [simp]"], ["", "declare comp_wb_lens [simp]"], ["", "declare comp_mwb_lens [simp]"], ["", "declare plus_mwb_lens [simp]"], ["", "lemma unrest_ex_diff [unrest]:\n  assumes \"x \\<bowtie> y\" \"y \\<sharp> P\"\n  shows \"y \\<sharp> (\\<exists> x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sharp> (\\<exists> x \\<bullet> P)", "using assms lens_indep_comm"], ["proof (prove)\nusing this:\n  x \\<bowtie> y\n  y \\<sharp> P\n  ?x \\<bowtie> ?y \\<Longrightarrow>\n  put\\<^bsub>?x\\<^esub> (put\\<^bsub>?y\\<^esub> ?\\<sigma> ?v) ?u =\n  put\\<^bsub>?y\\<^esub> (put\\<^bsub>?x\\<^esub> ?\\<sigma> ?u) ?v\n\ngoal (1 subgoal):\n 1. y \\<sharp> (\\<exists> x \\<bullet> P)", "by (rel_simp', fastforce)"], ["", "lemma unrest_all_in [unrest]:\n  \"\\<lbrakk> mwb_lens y; x \\<subseteq>\\<^sub>L y \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<forall> y \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens y; x \\<subseteq>\\<^sub>L y\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> (\\<forall> y \\<bullet> P)", "by (pred_auto)"], ["", "lemma unrest_all_diff [unrest]:\n  assumes \"x \\<bowtie> y\" \"y \\<sharp> P\"\n  shows \"y \\<sharp> (\\<forall> x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sharp> (\\<forall> x \\<bullet> P)", "using assms"], ["proof (prove)\nusing this:\n  x \\<bowtie> y\n  y \\<sharp> P\n\ngoal (1 subgoal):\n 1. y \\<sharp> (\\<forall> x \\<bullet> P)", "by (pred_simp, simp_all add: lens_indep_comm)"], ["", "lemma unrest_var_res_diff [unrest]:\n  assumes \"x \\<bowtie> y\"\n  shows \"y \\<sharp> (P \\<restriction>\\<^sub>v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sharp> P \\<restriction>\\<^sub>v x", "using assms"], ["proof (prove)\nusing this:\n  x \\<bowtie> y\n\ngoal (1 subgoal):\n 1. y \\<sharp> P \\<restriction>\\<^sub>v x", "by (pred_auto)"], ["", "lemma unrest_var_res_in [unrest]:\n  assumes \"mwb_lens x\" \"y \\<subseteq>\\<^sub>L x\" \"y \\<sharp> P\"\n  shows \"y \\<sharp> (P \\<restriction>\\<^sub>v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sharp> P \\<restriction>\\<^sub>v x", "using assms"], ["proof (prove)\nusing this:\n  mwb_lens x\n  y \\<subseteq>\\<^sub>L x\n  y \\<sharp> P\n\ngoal (1 subgoal):\n 1. y \\<sharp> P \\<restriction>\\<^sub>v x", "apply (pred_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Z b v b'.\n       \\<lbrakk>\\<forall>b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>x\\<^esub> b\n                      (put\\<^bsub>Z\\<^esub> (get\\<^bsub>x\\<^esub> b) v)) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e b;\n        \\<lparr>lens_get =\n                  get\\<^bsub>Z\\<^esub> \\<circ> get\\<^bsub>x\\<^esub>,\n           lens_put =\n             \\<lambda>\\<sigma> v.\n                put\\<^bsub>x\\<^esub> \\<sigma>\n                 (put\\<^bsub>Z\\<^esub> (get\\<^bsub>x\\<^esub> \\<sigma>)\n                   v)\\<rparr> \\<subseteq>\\<^sub>L\n        x;\n        \\<lparr>lens_get =\n                  get\\<^bsub>Z\\<^esub> \\<circ> get\\<^bsub>x\\<^esub>,\n           lens_put =\n             \\<lambda>\\<sigma> v.\n                put\\<^bsub>x\\<^esub> \\<sigma>\n                 (put\\<^bsub>Z\\<^esub> (get\\<^bsub>x\\<^esub> \\<sigma>)\n                   v)\\<rparr> \\<sharp>\n        P;\n        vwb_lens Z;\n        y =\n        \\<lparr>lens_get =\n                  get\\<^bsub>Z\\<^esub> \\<circ> get\\<^bsub>x\\<^esub>,\n           lens_put =\n             \\<lambda>\\<sigma> v.\n                put\\<^bsub>x\\<^esub> \\<sigma>\n                 (put\\<^bsub>Z\\<^esub> (get\\<^bsub>x\\<^esub> \\<sigma>)\n                   v)\\<rparr>;\n        mwb_lens x;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>x\\<^esub> b'\n           (put\\<^bsub>Z\\<^esub> (get\\<^bsub>x\\<^esub> b) v))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (put\\<^bsub>x\\<^esub> b'\n                               (get\\<^bsub>x\\<^esub> b))\n 2. \\<And>Z b v b'.\n       \\<lbrakk>\\<forall>b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>x\\<^esub> b\n                      (put\\<^bsub>Z\\<^esub> (get\\<^bsub>x\\<^esub> b) v)) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e b;\n        \\<lparr>lens_get =\n                  get\\<^bsub>Z\\<^esub> \\<circ> get\\<^bsub>x\\<^esub>,\n           lens_put =\n             \\<lambda>\\<sigma> v.\n                put\\<^bsub>x\\<^esub> \\<sigma>\n                 (put\\<^bsub>Z\\<^esub> (get\\<^bsub>x\\<^esub> \\<sigma>)\n                   v)\\<rparr> \\<subseteq>\\<^sub>L\n        x;\n        \\<lparr>lens_get =\n                  get\\<^bsub>Z\\<^esub> \\<circ> get\\<^bsub>x\\<^esub>,\n           lens_put =\n             \\<lambda>\\<sigma> v.\n                put\\<^bsub>x\\<^esub> \\<sigma>\n                 (put\\<^bsub>Z\\<^esub> (get\\<^bsub>x\\<^esub> \\<sigma>)\n                   v)\\<rparr> \\<sharp>\n        P;\n        vwb_lens Z;\n        y =\n        \\<lparr>lens_get =\n                  get\\<^bsub>Z\\<^esub> \\<circ> get\\<^bsub>x\\<^esub>,\n           lens_put =\n             \\<lambda>\\<sigma> v.\n                put\\<^bsub>x\\<^esub> \\<sigma>\n                 (put\\<^bsub>Z\\<^esub> (get\\<^bsub>x\\<^esub> \\<sigma>)\n                   v)\\<rparr>;\n        mwb_lens x;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>x\\<^esub> b' (get\\<^bsub>x\\<^esub> b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (put\\<^bsub>x\\<^esub> b'\n                               (put\\<^bsub>Z\\<^esub>\n                                 (get\\<^bsub>x\\<^esub> b) v))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z b v b'.\n       \\<lbrakk>\\<forall>b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>x\\<^esub> b\n                      (put\\<^bsub>Z\\<^esub> (get\\<^bsub>x\\<^esub> b) v)) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e b;\n        \\<lparr>lens_get =\n                  get\\<^bsub>Z\\<^esub> \\<circ> get\\<^bsub>x\\<^esub>,\n           lens_put =\n             \\<lambda>\\<sigma> v.\n                put\\<^bsub>x\\<^esub> \\<sigma>\n                 (put\\<^bsub>Z\\<^esub> (get\\<^bsub>x\\<^esub> \\<sigma>)\n                   v)\\<rparr> \\<subseteq>\\<^sub>L\n        x;\n        \\<lparr>lens_get =\n                  get\\<^bsub>Z\\<^esub> \\<circ> get\\<^bsub>x\\<^esub>,\n           lens_put =\n             \\<lambda>\\<sigma> v.\n                put\\<^bsub>x\\<^esub> \\<sigma>\n                 (put\\<^bsub>Z\\<^esub> (get\\<^bsub>x\\<^esub> \\<sigma>)\n                   v)\\<rparr> \\<sharp>\n        P;\n        vwb_lens Z;\n        y =\n        \\<lparr>lens_get =\n                  get\\<^bsub>Z\\<^esub> \\<circ> get\\<^bsub>x\\<^esub>,\n           lens_put =\n             \\<lambda>\\<sigma> v.\n                put\\<^bsub>x\\<^esub> \\<sigma>\n                 (put\\<^bsub>Z\\<^esub> (get\\<^bsub>x\\<^esub> \\<sigma>)\n                   v)\\<rparr>;\n        mwb_lens x;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>x\\<^esub> b' (get\\<^bsub>x\\<^esub> b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (put\\<^bsub>x\\<^esub> b'\n                               (put\\<^bsub>Z\\<^esub>\n                                 (get\\<^bsub>x\\<^esub> b) v))", "apply (metis (no_types, lifting) mwb_lens_weak weak_lens.put_get)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unrest_shEx [unrest]:\n  assumes \"\\<And> y. x \\<sharp> P(y)\"\n  shows \"x \\<sharp> (\\<^bold>\\<exists> y \\<bullet> P(y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> ushEx P", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> P ?y\n\ngoal (1 subgoal):\n 1. x \\<sharp> ushEx P", "by (pred_auto)"], ["", "lemma unrest_shAll [unrest]:\n  assumes \"\\<And> y. x \\<sharp> P(y)\"\n  shows \"x \\<sharp> (\\<^bold>\\<forall> y \\<bullet> P(y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> ushAll P", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> P ?y\n\ngoal (1 subgoal):\n 1. x \\<sharp> ushAll P", "by (pred_auto)"], ["", "lemma unrest_closure [unrest]:\n  \"x \\<sharp> [P]\\<^sub>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> [P]\\<^sub>u", "by (pred_auto)"], ["", "subsection \\<open> Used-by laws \\<close>"], ["", "lemma usedBy_not [unrest]:\n  \"\\<lbrakk> x \\<natural> P \\<rbrakk> \\<Longrightarrow> x \\<natural> (\\<not> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<natural> P \\<Longrightarrow> x \\<natural> \\<not> P", "by (pred_simp)"], ["", "lemma usedBy_conj [unrest]:\n  \"\\<lbrakk> x \\<natural> P; x \\<natural> Q \\<rbrakk> \\<Longrightarrow> x \\<natural> (P \\<and> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<natural> P; x \\<natural> Q\\<rbrakk>\n    \\<Longrightarrow> x \\<natural> P \\<and> Q", "by (pred_simp)"], ["", "lemma usedBy_disj [unrest]:\n  \"\\<lbrakk> x \\<natural> P; x \\<natural> Q \\<rbrakk> \\<Longrightarrow> x \\<natural> (P \\<or> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<natural> P; x \\<natural> Q\\<rbrakk>\n    \\<Longrightarrow> x \\<natural> P \\<or> Q", "by (pred_simp)"], ["", "lemma usedBy_impl [unrest]:\n  \"\\<lbrakk> x \\<natural> P; x \\<natural> Q \\<rbrakk> \\<Longrightarrow> x \\<natural> (P \\<Rightarrow> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<natural> P; x \\<natural> Q\\<rbrakk>\n    \\<Longrightarrow> x \\<natural> P \\<Rightarrow> Q", "by (pred_simp)"], ["", "lemma usedBy_iff [unrest]:\n  \"\\<lbrakk> x \\<natural> P; x \\<natural> Q \\<rbrakk> \\<Longrightarrow> x \\<natural> (P \\<Leftrightarrow> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<natural> P; x \\<natural> Q\\<rbrakk>\n    \\<Longrightarrow> x \\<natural> P \\<Leftrightarrow> Q", "by (pred_simp)"], ["", "subsection \\<open> Substitution Laws \\<close>"], ["", "text \\<open> Substitution is monotone \\<close>"], ["", "lemma subst_mono: \"P \\<sqsubseteq> Q \\<Longrightarrow> (\\<sigma> \\<dagger> P) \\<sqsubseteq> (\\<sigma> \\<dagger> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> Q \\<Longrightarrow>\n    \\<sigma> \\<dagger> P \\<sqsubseteq> \\<sigma> \\<dagger> Q", "by (pred_auto)"], ["", "lemma subst_true [usubst]: \"\\<sigma> \\<dagger> true = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> true = true", "by (pred_auto)"], ["", "lemma subst_false [usubst]: \"\\<sigma> \\<dagger> false = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> false = false", "by (pred_auto)"], ["", "lemma subst_not [usubst]: \"\\<sigma> \\<dagger> (\\<not> P) = (\\<not> \\<sigma> \\<dagger> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (\\<not> P) = (\\<not> \\<sigma> \\<dagger> P)", "by (pred_auto)"], ["", "lemma subst_impl [usubst]: \"\\<sigma> \\<dagger> (P \\<Rightarrow> Q) = (\\<sigma> \\<dagger> P \\<Rightarrow> \\<sigma> \\<dagger> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (P \\<Rightarrow> Q) =\n    (\\<sigma> \\<dagger> P \\<Rightarrow> \\<sigma> \\<dagger> Q)", "by (pred_auto)"], ["", "lemma subst_iff [usubst]: \"\\<sigma> \\<dagger> (P \\<Leftrightarrow> Q) = (\\<sigma> \\<dagger> P \\<Leftrightarrow> \\<sigma> \\<dagger> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (P \\<Leftrightarrow> Q) =\n    (\\<sigma> \\<dagger> P \\<Leftrightarrow> \\<sigma> \\<dagger> Q)", "by (pred_auto)"], ["", "lemma subst_disj [usubst]: \"\\<sigma> \\<dagger> (P \\<or> Q) = (\\<sigma> \\<dagger> P \\<or> \\<sigma> \\<dagger> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (P \\<or> Q) =\n    (\\<sigma> \\<dagger> P \\<or> \\<sigma> \\<dagger> Q)", "by (pred_auto)"], ["", "lemma subst_conj [usubst]: \"\\<sigma> \\<dagger> (P \\<and> Q) = (\\<sigma> \\<dagger> P \\<and> \\<sigma> \\<dagger> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (P \\<and> Q) =\n    (\\<sigma> \\<dagger> P \\<and> \\<sigma> \\<dagger> Q)", "by (pred_auto)"], ["", "lemma subst_sup [usubst]: \"\\<sigma> \\<dagger> (P \\<sqinter> Q) = (\\<sigma> \\<dagger> P \\<sqinter> \\<sigma> \\<dagger> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (P \\<sqinter> Q) =\n    \\<sigma> \\<dagger> P \\<sqinter> \\<sigma> \\<dagger> Q", "by (pred_auto)"], ["", "lemma subst_inf [usubst]: \"\\<sigma> \\<dagger> (P \\<squnion> Q) = (\\<sigma> \\<dagger> P \\<squnion> \\<sigma> \\<dagger> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (P \\<squnion> Q) =\n    \\<sigma> \\<dagger> P \\<squnion> \\<sigma> \\<dagger> Q", "by (pred_auto)"], ["", "lemma subst_UINF [usubst]: \"\\<sigma> \\<dagger> (\\<Sqinter> i | P(i) \\<bullet> Q(i)) = (\\<Sqinter> i | (\\<sigma> \\<dagger> P(i)) \\<bullet> (\\<sigma> \\<dagger> Q(i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> UINF P Q =\n    (\\<Sqinter> i | \\<sigma> \\<dagger> P i \\<bullet> \\<sigma> \\<dagger> Q i)", "by (pred_auto)"], ["", "lemma subst_USUP [usubst]: \"\\<sigma> \\<dagger> (\\<Squnion> i | P(i) \\<bullet> Q(i)) = (\\<Squnion> i | (\\<sigma> \\<dagger> P(i)) \\<bullet> (\\<sigma> \\<dagger> Q(i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> USUP P Q =\n    (\\<Squnion> i | \\<sigma> \\<dagger> P i \\<bullet> \\<sigma> \\<dagger> Q i)", "by (pred_auto)"], ["", "lemma subst_closure [usubst]: \"\\<sigma> \\<dagger> [P]\\<^sub>u = [P]\\<^sub>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> [P]\\<^sub>u = [P]\\<^sub>u", "by (pred_auto)"], ["", "lemma subst_shEx [usubst]: \"\\<sigma> \\<dagger> (\\<^bold>\\<exists> x \\<bullet> P(x)) = (\\<^bold>\\<exists> x \\<bullet> \\<sigma> \\<dagger> P(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> ushEx P =\n    (\\<^bold>\\<exists> x \\<bullet> \\<sigma> \\<dagger> P x)", "by (pred_auto)"], ["", "lemma subst_shAll [usubst]: \"\\<sigma> \\<dagger> (\\<^bold>\\<forall> x \\<bullet> P(x)) = (\\<^bold>\\<forall> x \\<bullet> \\<sigma> \\<dagger> P(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> ushAll P =\n    (\\<^bold>\\<forall> x \\<bullet> \\<sigma> \\<dagger> P x)", "by (pred_auto)"], ["", "text \\<open> TODO: Generalise the quantifier substitution laws to n-ary substitutions \\<close>"], ["", "lemma subst_ex_same [usubst]:\n  \"mwb_lens x \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> (\\<exists> x \\<bullet> P) = \\<sigma> \\<dagger> (\\<exists> x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow>\n    \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> (\\<exists> x \\<bullet> P) =\n    \\<sigma> \\<dagger> (\\<exists> x \\<bullet> P)", "by (pred_auto)"], ["", "lemma subst_ex_same' [usubst]:\n  \"mwb_lens x \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> (\\<exists> &x \\<bullet> P) = \\<sigma> \\<dagger> (\\<exists> &x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow>\n    \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> (\\<exists> &x \\<bullet> P) =\n    \\<sigma> \\<dagger> (\\<exists> &x \\<bullet> P)", "by (pred_auto)"], ["", "lemma subst_ex_indep [usubst]:\n  assumes \"x \\<bowtie> y\" \"y \\<sharp> v\"\n  shows \"(\\<exists> y \\<bullet> P)\\<lbrakk>v/x\\<rbrakk> = (\\<exists> y \\<bullet> P\\<lbrakk>v/x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists> y \\<bullet> P)\\<lbrakk>v/x\\<rbrakk> =\n    (\\<exists> y \\<bullet> P\\<lbrakk>v/x\\<rbrakk>)", "using assms"], ["proof (prove)\nusing this:\n  x \\<bowtie> y\n  y \\<sharp> v\n\ngoal (1 subgoal):\n 1. (\\<exists> y \\<bullet> P)\\<lbrakk>v/x\\<rbrakk> =\n    (\\<exists> y \\<bullet> P\\<lbrakk>v/x\\<rbrakk>)", "apply (pred_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b va.\n       \\<lbrakk>\\<forall>b va.\n                   \\<lbrakk>v\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b va) =\n                   \\<lbrakk>v\\<rbrakk>\\<^sub>e b;\n        x \\<bowtie> y; y \\<sharp> v;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>y\\<^esub>\n           (put\\<^bsub>x\\<^esub> b (\\<lbrakk>v\\<rbrakk>\\<^sub>e b))\n           va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>va.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (put\\<^bsub>x\\<^esub>\n                               (put\\<^bsub>y\\<^esub> b va)\n                               (\\<lbrakk>v\\<rbrakk>\\<^sub>e b))\n 2. \\<And>b va.\n       \\<lbrakk>\\<forall>b va.\n                   \\<lbrakk>v\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b va) =\n                   \\<lbrakk>v\\<rbrakk>\\<^sub>e b;\n        x \\<bowtie> y; y \\<sharp> v;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> b va)\n           (\\<lbrakk>v\\<rbrakk>\\<^sub>e b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>va.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (put\\<^bsub>y\\<^esub>\n                               (put\\<^bsub>x\\<^esub> b\n                                 (\\<lbrakk>v\\<rbrakk>\\<^sub>e b))\n                               va)", "using lens_indep_comm"], ["proof (prove)\nusing this:\n  ?x \\<bowtie> ?y \\<Longrightarrow>\n  put\\<^bsub>?x\\<^esub> (put\\<^bsub>?y\\<^esub> ?\\<sigma> ?v) ?u =\n  put\\<^bsub>?y\\<^esub> (put\\<^bsub>?x\\<^esub> ?\\<sigma> ?u) ?v\n\ngoal (2 subgoals):\n 1. \\<And>b va.\n       \\<lbrakk>\\<forall>b va.\n                   \\<lbrakk>v\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b va) =\n                   \\<lbrakk>v\\<rbrakk>\\<^sub>e b;\n        x \\<bowtie> y; y \\<sharp> v;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>y\\<^esub>\n           (put\\<^bsub>x\\<^esub> b (\\<lbrakk>v\\<rbrakk>\\<^sub>e b))\n           va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>va.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (put\\<^bsub>x\\<^esub>\n                               (put\\<^bsub>y\\<^esub> b va)\n                               (\\<lbrakk>v\\<rbrakk>\\<^sub>e b))\n 2. \\<And>b va.\n       \\<lbrakk>\\<forall>b va.\n                   \\<lbrakk>v\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b va) =\n                   \\<lbrakk>v\\<rbrakk>\\<^sub>e b;\n        x \\<bowtie> y; y \\<sharp> v;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> b va)\n           (\\<lbrakk>v\\<rbrakk>\\<^sub>e b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>va.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (put\\<^bsub>y\\<^esub>\n                               (put\\<^bsub>x\\<^esub> b\n                                 (\\<lbrakk>v\\<rbrakk>\\<^sub>e b))\n                               va)", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subst_ex_unrest [usubst]:\n  \"x \\<sharp> \\<sigma> \\<Longrightarrow> \\<sigma> \\<dagger> (\\<exists> x \\<bullet> P) = (\\<exists> x \\<bullet> \\<sigma> \\<dagger> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> \\<sigma> \\<Longrightarrow>\n    \\<sigma> \\<dagger> (\\<exists> x \\<bullet> P) =\n    (\\<exists> x \\<bullet> \\<sigma> \\<dagger> P)", "by (pred_auto)"], ["", "lemma subst_all_same [usubst]:\n  \"mwb_lens x \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> (\\<forall> x \\<bullet> P) = \\<sigma> \\<dagger> (\\<forall> x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow>\n    \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> (\\<forall> x \\<bullet> P) =\n    \\<sigma> \\<dagger> (\\<forall> x \\<bullet> P)", "by (simp add: id_subst subst_unrest unrest_all_in)"], ["", "lemma subst_all_indep [usubst]:\n  assumes \"x \\<bowtie> y\" \"y \\<sharp> v\"\n  shows \"(\\<forall> y \\<bullet> P)\\<lbrakk>v/x\\<rbrakk> = (\\<forall> y \\<bullet> P\\<lbrakk>v/x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall> y \\<bullet> P)\\<lbrakk>v/x\\<rbrakk> =\n    (\\<forall> y \\<bullet> P\\<lbrakk>v/x\\<rbrakk>)", "using assms"], ["proof (prove)\nusing this:\n  x \\<bowtie> y\n  y \\<sharp> v\n\ngoal (1 subgoal):\n 1. (\\<forall> y \\<bullet> P)\\<lbrakk>v/x\\<rbrakk> =\n    (\\<forall> y \\<bullet> P\\<lbrakk>v/x\\<rbrakk>)", "by (pred_simp, simp_all add: lens_indep_comm)"], ["", "lemma msubst_true [usubst]: \"true\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. true\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = true", "by (pred_auto)"], ["", "lemma msubst_false [usubst]: \"false\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. false\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = false", "by (pred_auto)"], ["", "lemma msubst_not [usubst]: \"(\\<not> P(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = (\\<not> ((P x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> P x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = (\\<not> msubst P v)", "by (pred_auto)"], ["", "lemma msubst_not_2 [usubst]: \"(\\<not> P x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> = (\\<not> ((P x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> P x y)\\<lbrakk>(x, y)\\<rightarrow>v\\<rbrakk> =\n    (\\<not> P x y\\<lbrakk>(x, y)\\<rightarrow>v\\<rbrakk>)", "by (pred_auto)+"], ["", "lemma msubst_disj [usubst]: \"(P(x) \\<or> Q(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = ((P(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk> \\<or> (Q(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P x \\<or> Q x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk> =\n    (msubst P v \\<or> msubst Q v)", "by (pred_auto)"], ["", "lemma msubst_disj_2 [usubst]: \"(P x y \\<or> Q x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> = ((P x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> \\<or> (Q x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P x y \\<or> Q x y)\\<lbrakk>(x, y)\\<rightarrow>v\\<rbrakk> =\n    (P x y\\<lbrakk>(x, y)\\<rightarrow>v\\<rbrakk> \\<or>\n     Q x y\\<lbrakk>(x, y)\\<rightarrow>v\\<rbrakk>)", "by (pred_auto)+"], ["", "lemma msubst_conj [usubst]: \"(P(x) \\<and> Q(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = ((P(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk> \\<and> (Q(x))\\<lbrakk>x\\<rightarrow>v\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P x \\<and> Q x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk> =\n    (msubst P v \\<and> msubst Q v)", "by (pred_auto)"], ["", "lemma msubst_conj_2 [usubst]: \"(P x y \\<and> Q x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> = ((P x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> \\<and> (Q x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P x y \\<and> Q x y)\\<lbrakk>(x, y)\\<rightarrow>v\\<rbrakk> =\n    (P x y\\<lbrakk>(x, y)\\<rightarrow>v\\<rbrakk> \\<and>\n     Q x y\\<lbrakk>(x, y)\\<rightarrow>v\\<rbrakk>)", "by (pred_auto)+"], ["", "lemma msubst_implies [usubst]:\n  \"(P x \\<Rightarrow> Q x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk> = ((P x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk> \\<Rightarrow> (Q x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P x \\<Rightarrow> Q x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk> =\n    (msubst P v \\<Rightarrow> msubst Q v)", "by (pred_auto)"], ["", "lemma msubst_implies_2 [usubst]:\n  \"(P x y \\<Rightarrow> Q x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> = ((P x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk> \\<Rightarrow> (Q x y)\\<lbrakk>(x,y)\\<rightarrow>v\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P x y \\<Rightarrow> Q x y)\\<lbrakk>(x, y)\\<rightarrow>v\\<rbrakk> =\n    (P x y\\<lbrakk>(x, y)\\<rightarrow>v\\<rbrakk> \\<Rightarrow>\n     Q x y\\<lbrakk>(x, y)\\<rightarrow>v\\<rbrakk>)", "by (pred_auto)+"], ["", "lemma msubst_shAll [usubst]:\n  \"(\\<^bold>\\<forall> x \\<bullet> P x y)\\<lbrakk>y\\<rightarrow>v\\<rbrakk> = (\\<^bold>\\<forall> x \\<bullet> (P x y)\\<lbrakk>y\\<rightarrow>v\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>\\<forall> x \\<bullet> P x y)\\<lbrakk>y\\<rightarrow>v\\<rbrakk> =\n    (\\<^bold>\\<forall> x \\<bullet> msubst (P x) v)", "by (pred_auto)"], ["", "lemma msubst_shAll_2 [usubst]:\n  \"(\\<^bold>\\<forall> x \\<bullet> P x y z)\\<lbrakk>(y,z)\\<rightarrow>v\\<rbrakk> = (\\<^bold>\\<forall> x \\<bullet> (P x y z)\\<lbrakk>(y,z)\\<rightarrow>v\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>\\<forall> x \\<bullet> P x y z)\\<lbrakk>(y,\n    z)\\<rightarrow>v\\<rbrakk> =\n    (\\<^bold>\\<forall> x \\<bullet> P x y z\\<lbrakk>(y,\n                                   z)\\<rightarrow>v\\<rbrakk>)", "by (pred_auto)+"], ["", "subsection \\<open> Sandbox for conjectures \\<close>"], ["", "definition utp_sandbox :: \"'\\<alpha> upred \\<Rightarrow> bool\" (\"TRY'(_')\") where\n\"TRY(P) = (P = undefined)\""], ["", "translations\n  \"P\" <= \"CONST utp_sandbox P\""], ["", "end"]]}