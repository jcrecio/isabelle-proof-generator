{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/utp/utp_rel_opsem.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["lemma trans_trel:\n  \"\\<lbrakk> (\\<sigma>, P) \\<rightarrow>\\<^sub>u (\\<rho>, Q); (\\<rho>, Q) \\<rightarrow>\\<^sub>u (\\<phi>, R) \\<rbrakk> \\<Longrightarrow> (\\<sigma>, P) \\<rightarrow>\\<^sub>u (\\<phi>, R)\"", "lemma skip_trel: \"(\\<sigma>, II) \\<rightarrow>\\<^sub>u (\\<sigma>, II)\"", "lemma assigns_trel: \"(\\<sigma>, \\<langle>\\<rho>\\<rangle>\\<^sub>a) \\<rightarrow>\\<^sub>u (\\<rho> \\<circ> \\<sigma>, II)\"", "lemma assign_trel:\n  \"(\\<sigma>, x := v) \\<rightarrow>\\<^sub>u (\\<sigma>(&x \\<mapsto>\\<^sub>s \\<sigma> \\<dagger> v), II)\"", "lemma seq_trel:\n  assumes \"(\\<sigma>, P) \\<rightarrow>\\<^sub>u (\\<rho>, Q)\"\n  shows \"(\\<sigma>, P ;; R) \\<rightarrow>\\<^sub>u (\\<rho>, Q ;; R)\"", "lemma seq_skip_trel:\n  \"(\\<sigma>, II ;; P) \\<rightarrow>\\<^sub>u (\\<sigma>, P)\"", "lemma nondet_left_trel:\n  \"(\\<sigma>, P \\<sqinter> Q) \\<rightarrow>\\<^sub>u (\\<sigma>, P)\"", "lemma nondet_right_trel:\n  \"(\\<sigma>, P \\<sqinter> Q) \\<rightarrow>\\<^sub>u (\\<sigma>, Q)\"", "lemma rcond_true_trel:\n  assumes \"\\<sigma> \\<dagger> b = true\"\n  shows \"(\\<sigma>, P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) \\<rightarrow>\\<^sub>u (\\<sigma>, P)\"", "lemma rcond_false_trel:\n  assumes \"\\<sigma> \\<dagger> b = false\"\n  shows \"(\\<sigma>, P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) \\<rightarrow>\\<^sub>u (\\<sigma>, Q)\"", "lemma while_true_trel:\n  assumes \"\\<sigma> \\<dagger> b = true\"\n  shows \"(\\<sigma>, while b do P od) \\<rightarrow>\\<^sub>u (\\<sigma>, P ;; while b do P od)\"", "lemma while_false_trel:\n  assumes \"\\<sigma> \\<dagger> b = false\"\n  shows \"(\\<sigma>, while b do P od) \\<rightarrow>\\<^sub>u (\\<sigma>, II)\"", "theorem hoare_opsem_link:\n  \"\\<lbrace>p\\<rbrace>Q\\<lbrace>r\\<rbrace>\\<^sub>u = (\\<forall> \\<sigma>\\<^sub>0 \\<sigma>\\<^sub>1. `\\<sigma>\\<^sub>0 \\<dagger> p` \\<and> (\\<sigma>\\<^sub>0, Q) \\<rightarrow>\\<^sub>u (\\<sigma>\\<^sub>1, II) \\<longrightarrow> `\\<sigma>\\<^sub>1 \\<dagger> r`)\""], "translations": [["", "lemma trans_trel:\n  \"\\<lbrakk> (\\<sigma>, P) \\<rightarrow>\\<^sub>u (\\<rho>, Q); (\\<rho>, Q) \\<rightarrow>\\<^sub>u (\\<phi>, R) \\<rbrakk> \\<Longrightarrow> (\\<sigma>, P) \\<rightarrow>\\<^sub>u (\\<phi>, R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<sigma>, P) \\<rightarrow>\\<^sub>u (\\<rho>, Q);\n     (\\<rho>, Q) \\<rightarrow>\\<^sub>u (\\<phi>, R)\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma>, P) \\<rightarrow>\\<^sub>u (\\<phi>, R)", "by auto"], ["", "lemma skip_trel: \"(\\<sigma>, II) \\<rightarrow>\\<^sub>u (\\<sigma>, II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, II) \\<rightarrow>\\<^sub>u (\\<sigma>, II)", "by simp"], ["", "lemma assigns_trel: \"(\\<sigma>, \\<langle>\\<rho>\\<rangle>\\<^sub>a) \\<rightarrow>\\<^sub>u (\\<rho> \\<circ> \\<sigma>, II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, \\<langle>\\<rho>\\<rangle>\\<^sub>a) \\<rightarrow>\\<^sub>u\n    (\\<rho> \\<circ> \\<sigma>, II)", "by (simp add: assigns_comp)"], ["", "lemma assign_trel:\n  \"(\\<sigma>, x := v) \\<rightarrow>\\<^sub>u (\\<sigma>(&x \\<mapsto>\\<^sub>s \\<sigma> \\<dagger> v), II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, x := v) \\<rightarrow>\\<^sub>u\n    (\\<sigma>(&x \\<mapsto>\\<^sub>s \\<sigma> \\<dagger> v), II)", "by (simp add: assigns_comp usubst)"], ["", "lemma seq_trel:\n  assumes \"(\\<sigma>, P) \\<rightarrow>\\<^sub>u (\\<rho>, Q)\"\n  shows \"(\\<sigma>, P ;; R) \\<rightarrow>\\<^sub>u (\\<rho>, Q ;; R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, P ;; R) \\<rightarrow>\\<^sub>u (\\<rho>, Q ;; R)", "by (metis (no_types, lifting) assms order_refl seqr_assoc seqr_mono trel.simps)"], ["", "lemma seq_skip_trel:\n  \"(\\<sigma>, II ;; P) \\<rightarrow>\\<^sub>u (\\<sigma>, P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, II ;; P) \\<rightarrow>\\<^sub>u (\\<sigma>, P)", "by simp"], ["", "lemma nondet_left_trel:\n  \"(\\<sigma>, P \\<sqinter> Q) \\<rightarrow>\\<^sub>u (\\<sigma>, P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, P \\<sqinter> Q) \\<rightarrow>\\<^sub>u (\\<sigma>, P)", "by (metis (no_types, hide_lams) disj_comm disj_upred_def semilattice_sup_class.sup.absorb_iff1 semilattice_sup_class.sup.left_idem seqr_or_distr trel.simps)"], ["", "lemma nondet_right_trel:\n  \"(\\<sigma>, P \\<sqinter> Q) \\<rightarrow>\\<^sub>u (\\<sigma>, Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, P \\<sqinter> Q) \\<rightarrow>\\<^sub>u (\\<sigma>, Q)", "by (simp add: seqr_mono)"], ["", "lemma rcond_true_trel:\n  assumes \"\\<sigma> \\<dagger> b = true\"\n  shows \"(\\<sigma>, P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) \\<rightarrow>\\<^sub>u (\\<sigma>, P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>,\n     P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) \\<rightarrow>\\<^sub>u\n    (\\<sigma>, P)", "using assms"], ["proof (prove)\nusing this:\n  \\<sigma> \\<dagger> b = true\n\ngoal (1 subgoal):\n 1. (\\<sigma>,\n     P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) \\<rightarrow>\\<^sub>u\n    (\\<sigma>, P)", "by (simp add: assigns_r_comp usubst alpha cond_unit_T)"], ["", "lemma rcond_false_trel:\n  assumes \"\\<sigma> \\<dagger> b = false\"\n  shows \"(\\<sigma>, P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) \\<rightarrow>\\<^sub>u (\\<sigma>, Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>,\n     P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) \\<rightarrow>\\<^sub>u\n    (\\<sigma>, Q)", "using assms"], ["proof (prove)\nusing this:\n  \\<sigma> \\<dagger> b = false\n\ngoal (1 subgoal):\n 1. (\\<sigma>,\n     P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) \\<rightarrow>\\<^sub>u\n    (\\<sigma>, Q)", "by (simp add: assigns_r_comp usubst alpha cond_unit_F)"], ["", "lemma while_true_trel:\n  assumes \"\\<sigma> \\<dagger> b = true\"\n  shows \"(\\<sigma>, while b do P od) \\<rightarrow>\\<^sub>u (\\<sigma>, P ;; while b do P od)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, while\\<^sup>\\<top> b do P od) \\<rightarrow>\\<^sub>u\n    (\\<sigma>, P ;; while\\<^sup>\\<top> b do P od)", "by (metis assms rcond_true_trel while_unfold)"], ["", "lemma while_false_trel:\n  assumes \"\\<sigma> \\<dagger> b = false\"\n  shows \"(\\<sigma>, while b do P od) \\<rightarrow>\\<^sub>u (\\<sigma>, II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, while\\<^sup>\\<top> b do P od) \\<rightarrow>\\<^sub>u\n    (\\<sigma>, II)", "by (metis assms rcond_false_trel while_unfold)"], ["", "text \\<open> Theorem linking Hoare calculus and operational semantics. If we start $Q$ in a state $\\sigma_0$\n  satisfying $p$, and $Q$ reaches final state $\\sigma_1$ then $r$ holds in this final state. \\<close>"], ["", "theorem hoare_opsem_link:\n  \"\\<lbrace>p\\<rbrace>Q\\<lbrace>r\\<rbrace>\\<^sub>u = (\\<forall> \\<sigma>\\<^sub>0 \\<sigma>\\<^sub>1. `\\<sigma>\\<^sub>0 \\<dagger> p` \\<and> (\\<sigma>\\<^sub>0, Q) \\<rightarrow>\\<^sub>u (\\<sigma>\\<^sub>1, II) \\<longrightarrow> `\\<sigma>\\<^sub>1 \\<dagger> r`)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>p\\<rbrace> Q \\<lbrace>r\\<rbrace>\\<^sub>u =\n    (\\<forall>\\<sigma>\\<^sub>0 \\<sigma>\\<^sub>1.\n        `\\<sigma>\\<^sub>0 \\<dagger> p` \\<and>\n        (\\<sigma>\\<^sub>0, Q) \\<rightarrow>\\<^sub>u\n        (\\<sigma>\\<^sub>1, II) \\<longrightarrow>\n        `\\<sigma>\\<^sub>1 \\<dagger> r`)", "apply (rel_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>\\<sigma>\\<^sub>0 \\<sigma>\\<^sub>1.\n                   (\\<forall>b.\n                       \\<lbrakk>p\\<rbrakk>\\<^sub>e\n                        (\\<sigma>\\<^sub>0 b)) \\<and>\n                   (\\<forall>a.\n                       \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                        (\\<sigma>\\<^sub>0 a,\n                         \\<sigma>\\<^sub>1 a)) \\<longrightarrow>\n                   (\\<forall>b.\n                       \\<lbrakk>r\\<rbrakk>\\<^sub>e (\\<sigma>\\<^sub>1 b));\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<lbrakk>p\\<rbrakk>\\<^sub>e a\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>r\\<rbrakk>\\<^sub>e b", "apply (rename_tac a b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>\\<sigma>\\<^sub>0 \\<sigma>\\<^sub>1.\n                   (\\<forall>b.\n                       \\<lbrakk>p\\<rbrakk>\\<^sub>e\n                        (\\<sigma>\\<^sub>0 b)) \\<and>\n                   (\\<forall>a.\n                       \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                        (\\<sigma>\\<^sub>0 a,\n                         \\<sigma>\\<^sub>1 a)) \\<longrightarrow>\n                   (\\<forall>b.\n                       \\<lbrakk>r\\<rbrakk>\\<^sub>e (\\<sigma>\\<^sub>1 b));\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<lbrakk>p\\<rbrakk>\\<^sub>e a\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>r\\<rbrakk>\\<^sub>e b", "apply (drule_tac x=\"\\<lambda> _. a\" in spec, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<lbrakk>p\\<rbrakk>\\<^sub>e a;\n        \\<forall>\\<sigma>\\<^sub>1.\n           (\\<forall>aa.\n               \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                (a, \\<sigma>\\<^sub>1 aa)) \\<longrightarrow>\n           (\\<forall>b.\n               \\<lbrakk>r\\<rbrakk>\\<^sub>e (\\<sigma>\\<^sub>1 b))\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>r\\<rbrakk>\\<^sub>e b", "apply (drule_tac x=\"\\<lambda> _. b\" in spec, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare trel.simps [simp del]"], ["", "end"]]}