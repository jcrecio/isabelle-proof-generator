{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/utp/utp_var.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["lemma in_var_weak_lens [simp]:\n  \"weak_lens x \\<Longrightarrow> weak_lens (in_var x)\"", "lemma in_var_semi_uvar [simp]:\n  \"mwb_lens x \\<Longrightarrow> mwb_lens (in_var x)\"", "lemma pr_var_weak_lens [simp]:\n  \"weak_lens x \\<Longrightarrow> weak_lens (pr_var x)\"", "lemma pr_var_mwb_lens [simp]:\n  \"mwb_lens x \\<Longrightarrow> mwb_lens (pr_var x)\"", "lemma pr_var_vwb_lens [simp]: \n  \"vwb_lens x \\<Longrightarrow> vwb_lens (pr_var x)\"", "lemma in_var_uvar [simp]:\n  \"vwb_lens x \\<Longrightarrow> vwb_lens (in_var x)\"", "lemma out_var_weak_lens [simp]:\n  \"weak_lens x \\<Longrightarrow> weak_lens (out_var x)\"", "lemma out_var_semi_uvar [simp]:\n  \"mwb_lens x \\<Longrightarrow> mwb_lens (out_var x)\"", "lemma out_var_uvar [simp]:\n  \"vwb_lens x \\<Longrightarrow> vwb_lens (out_var x)\"", "lemma in_out_indep [simp]:\n  \"in_var x \\<bowtie> out_var y\"", "lemma out_in_indep [simp]:\n  \"out_var x \\<bowtie> in_var y\"", "lemma in_var_indep [simp]:\n  \"x \\<bowtie> y \\<Longrightarrow> in_var x \\<bowtie> in_var y\"", "lemma out_var_indep [simp]:\n  \"x \\<bowtie> y \\<Longrightarrow> out_var x \\<bowtie> out_var y\"", "lemma pr_var_indeps [simp]: \n  \"x \\<bowtie> y \\<Longrightarrow> pr_var x \\<bowtie> y\"\n  \"x \\<bowtie> y \\<Longrightarrow> x \\<bowtie> pr_var y\"", "lemma prod_lens_indep_in_var [simp]:\n  \"a \\<bowtie> x \\<Longrightarrow> a \\<times>\\<^sub>L b \\<bowtie> in_var x\"", "lemma prod_lens_indep_out_var [simp]:\n  \"b \\<bowtie> x \\<Longrightarrow> a \\<times>\\<^sub>L b \\<bowtie> out_var x\"", "lemma in_var_pr_var [simp]:\n  \"in_var (pr_var x) = in_var x\"", "lemma out_var_pr_var [simp]:\n  \"out_var (pr_var x) = out_var x\"", "lemma pr_var_idem [simp]: \n  \"pr_var (pr_var x) = pr_var x\"", "lemma pr_var_lens_plus [simp]: \n  \"pr_var (x +\\<^sub>L y) = (x +\\<^sub>L y)\"", "lemma pr_var_lens_comp_1 [simp]: \n  \"pr_var x ;\\<^sub>L y = pr_var (x ;\\<^sub>L y)\"", "lemma in_var_plus [simp]: \"in_var (x +\\<^sub>L y) = in_var x +\\<^sub>L in_var y\"", "lemma out_var_plus [simp]: \"out_var (x +\\<^sub>L y) = out_var x +\\<^sub>L out_var y\"", "lemma in_var_sublens [simp]:\n  \"y \\<subseteq>\\<^sub>L x \\<Longrightarrow> in_var y \\<subseteq>\\<^sub>L in_var x\"", "lemma out_var_sublens [simp]:\n  \"y \\<subseteq>\\<^sub>L x \\<Longrightarrow> out_var y \\<subseteq>\\<^sub>L out_var x\"", "lemma pr_var_sublens [simp]:\n  \"y \\<subseteq>\\<^sub>L x \\<Longrightarrow> pr_var y \\<subseteq>\\<^sub>L pr_var x\"", "lemma var_lookup_in [simp]: \"lens_get (in_var x) (A, A') = lens_get x A\"", "lemma var_lookup_out [simp]: \"lens_get (out_var x) (A, A') = lens_get x A'\"", "lemma var_update_in [simp]: \"lens_put (in_var x) (A, A') v = (lens_put x A v, A')\"", "lemma var_update_out [simp]: \"lens_put (out_var x) (A, A') v = (A, lens_put x A' v)\"", "lemma get_lens_plus [simp]: \"get\\<^bsub>x +\\<^sub>L y\\<^esub> s = (get\\<^bsub>x\\<^esub> s, get\\<^bsub>y\\<^esub> s)\""], "translations": [["", "lemma in_var_weak_lens [simp]:\n  \"weak_lens x \\<Longrightarrow> weak_lens (in_var x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_lens x \\<Longrightarrow> weak_lens (in_var x)", "by (simp add: comp_weak_lens in_var_def)"], ["", "lemma in_var_semi_uvar [simp]:\n  \"mwb_lens x \\<Longrightarrow> mwb_lens (in_var x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow> mwb_lens (in_var x)", "by (simp add: comp_mwb_lens in_var_def)"], ["", "lemma pr_var_weak_lens [simp]:\n  \"weak_lens x \\<Longrightarrow> weak_lens (pr_var x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_lens x \\<Longrightarrow> weak_lens (pr_var x)", "by (simp add: pr_var_def)"], ["", "lemma pr_var_mwb_lens [simp]:\n  \"mwb_lens x \\<Longrightarrow> mwb_lens (pr_var x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow> mwb_lens (pr_var x)", "by (simp add: pr_var_def)"], ["", "lemma pr_var_vwb_lens [simp]: \n  \"vwb_lens x \\<Longrightarrow> vwb_lens (pr_var x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow> vwb_lens (pr_var x)", "by (simp add: pr_var_def)"], ["", "lemma in_var_uvar [simp]:\n  \"vwb_lens x \\<Longrightarrow> vwb_lens (in_var x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow> vwb_lens (in_var x)", "by (simp add: in_var_def)"], ["", "lemma out_var_weak_lens [simp]:\n  \"weak_lens x \\<Longrightarrow> weak_lens (out_var x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_lens x \\<Longrightarrow> weak_lens (out_var x)", "by (simp add: comp_weak_lens out_var_def)"], ["", "lemma out_var_semi_uvar [simp]:\n  \"mwb_lens x \\<Longrightarrow> mwb_lens (out_var x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow> mwb_lens (out_var x)", "by (simp add: comp_mwb_lens out_var_def)"], ["", "lemma out_var_uvar [simp]:\n  \"vwb_lens x \\<Longrightarrow> vwb_lens (out_var x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow> vwb_lens (out_var x)", "by (simp add: out_var_def)"], ["", "text \\<open> Moreover, we can show that input and output variables are independent, since they refer\n  to different sections of the alphabet. \\<close>"], ["", "lemma in_out_indep [simp]:\n  \"in_var x \\<bowtie> out_var y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_var x \\<bowtie> out_var y", "by (simp add: lens_indep_def in_var_def out_var_def fst_lens_def snd_lens_def lens_comp_def)"], ["", "lemma out_in_indep [simp]:\n  \"out_var x \\<bowtie> in_var y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out_var x \\<bowtie> in_var y", "by (simp add: lens_indep_def in_var_def out_var_def fst_lens_def snd_lens_def lens_comp_def)"], ["", "lemma in_var_indep [simp]:\n  \"x \\<bowtie> y \\<Longrightarrow> in_var x \\<bowtie> in_var y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bowtie> y \\<Longrightarrow> in_var x \\<bowtie> in_var y", "by (simp add: in_var_def out_var_def)"], ["", "lemma out_var_indep [simp]:\n  \"x \\<bowtie> y \\<Longrightarrow> out_var x \\<bowtie> out_var y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bowtie> y \\<Longrightarrow> out_var x \\<bowtie> out_var y", "by (simp add: out_var_def)"], ["", "lemma pr_var_indeps [simp]: \n  \"x \\<bowtie> y \\<Longrightarrow> pr_var x \\<bowtie> y\"\n  \"x \\<bowtie> y \\<Longrightarrow> x \\<bowtie> pr_var y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<bowtie> y \\<Longrightarrow> pr_var x \\<bowtie> y) &&&\n    (x \\<bowtie> y \\<Longrightarrow> x \\<bowtie> pr_var y)", "by (simp_all add: pr_var_def)"], ["", "lemma prod_lens_indep_in_var [simp]:\n  \"a \\<bowtie> x \\<Longrightarrow> a \\<times>\\<^sub>L b \\<bowtie> in_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<bowtie> x \\<Longrightarrow> a \\<times>\\<^sub>L b \\<bowtie> in_var x", "by (metis in_var_def in_var_indep out_in_indep out_var_def plus_pres_lens_indep prod_as_plus)"], ["", "lemma prod_lens_indep_out_var [simp]:\n  \"b \\<bowtie> x \\<Longrightarrow> a \\<times>\\<^sub>L b \\<bowtie> out_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<bowtie> x \\<Longrightarrow> a \\<times>\\<^sub>L b \\<bowtie> out_var x", "by (metis in_out_indep in_var_def out_var_def out_var_indep plus_pres_lens_indep prod_as_plus)"], ["", "lemma in_var_pr_var [simp]:\n  \"in_var (pr_var x) = in_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_var (pr_var x) = in_var x", "by (simp add: pr_var_def)"], ["", "lemma out_var_pr_var [simp]:\n  \"out_var (pr_var x) = out_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out_var (pr_var x) = out_var x", "by (simp add: pr_var_def)"], ["", "lemma pr_var_idem [simp]: \n  \"pr_var (pr_var x) = pr_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pr_var (pr_var x) = pr_var x", "by (simp add: pr_var_def)"], ["", "lemma pr_var_lens_plus [simp]: \n  \"pr_var (x +\\<^sub>L y) = (x +\\<^sub>L y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pr_var (x +\\<^sub>L y) = x +\\<^sub>L y", "by (simp add: pr_var_def)"], ["", "lemma pr_var_lens_comp_1 [simp]: \n  \"pr_var x ;\\<^sub>L y = pr_var (x ;\\<^sub>L y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pr_var x ;\\<^sub>L y = pr_var (x ;\\<^sub>L y)", "by (simp add: pr_var_def)"], ["", "lemma in_var_plus [simp]: \"in_var (x +\\<^sub>L y) = in_var x +\\<^sub>L in_var y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_var (x +\\<^sub>L y) = in_var x +\\<^sub>L in_var y", "by (simp add: in_var_def)"], ["", "lemma out_var_plus [simp]: \"out_var (x +\\<^sub>L y) = out_var x +\\<^sub>L out_var y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out_var (x +\\<^sub>L y) = out_var x +\\<^sub>L out_var y", "by (simp add: out_var_def)"], ["", "text \\<open> Similar properties follow for sublens \\<close>"], ["", "lemma in_var_sublens [simp]:\n  \"y \\<subseteq>\\<^sub>L x \\<Longrightarrow> in_var y \\<subseteq>\\<^sub>L in_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<subseteq>\\<^sub>L x \\<Longrightarrow>\n    in_var y \\<subseteq>\\<^sub>L in_var x", "by (metis (no_types, hide_lams) in_var_def lens_comp_assoc sublens_def)"], ["", "lemma out_var_sublens [simp]:\n  \"y \\<subseteq>\\<^sub>L x \\<Longrightarrow> out_var y \\<subseteq>\\<^sub>L out_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<subseteq>\\<^sub>L x \\<Longrightarrow>\n    out_var y \\<subseteq>\\<^sub>L out_var x", "by (metis (no_types, hide_lams) out_var_def lens_comp_assoc sublens_def)"], ["", "lemma pr_var_sublens [simp]:\n  \"y \\<subseteq>\\<^sub>L x \\<Longrightarrow> pr_var y \\<subseteq>\\<^sub>L pr_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<subseteq>\\<^sub>L x \\<Longrightarrow>\n    pr_var y \\<subseteq>\\<^sub>L pr_var x", "by (simp add: pr_var_def)"], ["", "subsection \\<open> Lens simplifications \\<close>"], ["", "text \\<open> We also define some lookup abstraction simplifications. \\<close>"], ["", "lemma var_lookup_in [simp]: \"lens_get (in_var x) (A, A') = lens_get x A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get\\<^bsub>in_var x\\<^esub> (A, A') = get\\<^bsub>x\\<^esub> A", "by (simp add: in_var_def fst_lens_def lens_comp_def)"], ["", "lemma var_lookup_out [simp]: \"lens_get (out_var x) (A, A') = lens_get x A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get\\<^bsub>out_var x\\<^esub> (A, A') = get\\<^bsub>x\\<^esub> A'", "by (simp add: out_var_def snd_lens_def lens_comp_def)"], ["", "lemma var_update_in [simp]: \"lens_put (in_var x) (A, A') v = (lens_put x A v, A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put\\<^bsub>in_var x\\<^esub> (A, A') v = (put\\<^bsub>x\\<^esub> A v, A')", "by (simp add: in_var_def fst_lens_def lens_comp_def)"], ["", "lemma var_update_out [simp]: \"lens_put (out_var x) (A, A') v = (A, lens_put x A' v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put\\<^bsub>out_var x\\<^esub> (A, A') v = (A, put\\<^bsub>x\\<^esub> A' v)", "by (simp add: out_var_def snd_lens_def lens_comp_def)"], ["", "lemma get_lens_plus [simp]: \"get\\<^bsub>x +\\<^sub>L y\\<^esub> s = (get\\<^bsub>x\\<^esub> s, get\\<^bsub>y\\<^esub> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get\\<^bsub>x +\\<^sub>L y\\<^esub> s =\n    (get\\<^bsub>x\\<^esub> s, get\\<^bsub>y\\<^esub> s)", "by (simp add: lens_defs)"], ["", "subsection \\<open> Syntax translations \\<close>"], ["", "text \\<open> In order to support nice syntax for variables, we here set up some translations. The first\n  step is to introduce a collection of non-terminals. \\<close>"], ["", "nonterminal svid and svids and svar and svars and salpha"], ["", "text \\<open> These non-terminals correspond to the following syntactic entities. Non-terminal \n  @{typ \"svid\"} is an atomic variable identifier, and @{typ \"svids\"} is a list of identifier. \n  @{typ \"svar\"} is a decorated variable, such as an input or output variable, and @{typ \"svars\"} is \n  a list of decorated variables. @{typ \"salpha\"} is an alphabet or set of variables. Such sets can \n  be constructed only through lens composition due to typing restrictions. Next we introduce some \n  syntax constructors. \\<close>"], ["", "syntax \\<comment> \\<open> Identifiers \\<close>\n  \"_svid\"         :: \"id \\<Rightarrow> svid\" (\"_\" [999] 999)\n  \"_svid_unit\"    :: \"svid \\<Rightarrow> svids\" (\"_\")\n  \"_svid_list\"    :: \"svid \\<Rightarrow> svids \\<Rightarrow> svids\" (\"_,/ _\")\n  \"_svid_alpha\"   :: \"svid\" (\"\\<^bold>v\")\n  \"_svid_dot\"     :: \"svid \\<Rightarrow> svid \\<Rightarrow> svid\" (\"_:_\" [998,999] 998)\n  \"_mk_svid_list\" :: \"svids \\<Rightarrow> logic\" \\<comment> \\<open> Helper function for summing a list of identifiers \\<close>"], ["", "text \\<open> A variable identifier can either be a HOL identifier, the complete set of variables in the\n  alphabet $\\textbf{v}$, or a composite identifier separated by colons, which\n  corresponds to a sort of qualification. The final option is effectively a lens composition. \\<close>"], ["", "syntax \\<comment> \\<open> Decorations \\<close>\n  \"_spvar\"       :: \"svid \\<Rightarrow> svar\" (\"&_\" [990] 990)\n  \"_sinvar\"      :: \"svid \\<Rightarrow> svar\" (\"$_\" [990] 990)\n  \"_soutvar\"     :: \"svid \\<Rightarrow> svar\" (\"$_\\<acute>\" [990] 990)"], ["", "text \\<open> A variable can be decorated with an ampersand, to indicate it is a predicate variable, with \n  a dollar to indicate its an unprimed relational variable, or a dollar and ``acute'' symbol to \n  indicate its a primed relational variable. Isabelle's parser is extensible so additional\n  decorations can be and are added later. \\<close>"], ["", "syntax \\<comment> \\<open> Variable sets \\<close>\n  \"_salphaid\"    :: \"svid \\<Rightarrow> salpha\" (\"_\" [990] 990)\n  \"_salphavar\"   :: \"svar \\<Rightarrow> salpha\" (\"_\" [990] 990)\n  \"_salphaparen\" :: \"salpha \\<Rightarrow> salpha\" (\"'(_')\")\n  \"_salphacomp\"  :: \"salpha \\<Rightarrow> salpha \\<Rightarrow> salpha\" (infixr \";\" 75)\n  \"_salphaprod\"  :: \"salpha \\<Rightarrow> salpha \\<Rightarrow> salpha\" (infixr \"\\<times>\" 85)\n  \"_salpha_all\"  :: \"salpha\" (\"\\<Sigma>\")\n  \"_salpha_none\" :: \"salpha\" (\"\\<emptyset>\")\n  \"_svar_nil\"    :: \"svar \\<Rightarrow> svars\" (\"_\")\n  \"_svar_cons\"   :: \"svar \\<Rightarrow> svars \\<Rightarrow> svars\" (\"_,/ _\")\n  \"_salphaset\"   :: \"svars \\<Rightarrow> salpha\" (\"{_}\")\n  \"_salphamk\"    :: \"logic \\<Rightarrow> salpha\""], ["", "text \\<open> The terminals of an alphabet are either HOL identifiers or UTP variable identifiers. \n  We support two ways of constructing alphabets; by composition of smaller alphabets using\n  a semi-colon or by a set-style construction $\\{a,b,c\\}$ with a list of UTP variables. \\<close>"], ["", "syntax \\<comment> \\<open> Quotations \\<close>\n  \"_ualpha_set\"  :: \"svars \\<Rightarrow> logic\" (\"{_}\\<^sub>\\<alpha>\")  \n  \"_svar\"        :: \"svar \\<Rightarrow> logic\" (\"'(_')\\<^sub>v\")"], ["", "text \\<open> For various reasons, the syntax constructors above all yield specific grammar categories and\n  will not parser at the HOL top level (basically this is to do with us wanting to reuse the syntax\n  for expressions). As a result we provide some quotation constructors above. \n\n  Next we need to construct the syntax translations rules. First we need a few polymorphic constants. \\<close>"], ["", "consts\n  svar :: \"'v \\<Rightarrow> 'e\"\n  ivar :: \"'v \\<Rightarrow> 'e\"\n  ovar :: \"'v \\<Rightarrow> 'e\""], ["", "adhoc_overloading\n  svar pr_var and ivar in_var and ovar out_var"], ["", "text \\<open> The functions above turn a representation of a variable (type @{typ \"'v\"}), including\n  its name and type, into some lens type @{typ \"'e\"}. @{term \"svar\"} constructs a predicate variable,\n  @{term \"ivar\"} and input variables, and @{term \"ovar\"} and output variable. The functions bridge \n  between the model and encoding of the variable and its interpretation as a lens in order to integrate it \n  into the general lens-based framework. Overriding these functions is then all we need to make \n  use of any kind of variables in terms of interfacing it with the system. Although in core UTP\n  variables are always modelled using record field, we can overload these constants to allow other\n  kinds of variables, such as deep variables with explicit syntax and type information.\n\n  Finally, we set up the translations rules. \\<close>"], ["", "translations\n  \\<comment> \\<open> Identifiers \\<close>\n  \"_svid x\" \\<rightharpoonup> \"x\"\n  \"_svid_alpha\" \\<rightleftharpoons> \"\\<Sigma>\"\n  \"_svid_dot x y\" \\<rightharpoonup> \"y ;\\<^sub>L x\"\n  \"_mk_svid_list (_svid_unit x)\" \\<rightharpoonup> \"x\"\n  \"_mk_svid_list (_svid_list x xs)\" \\<rightharpoonup> \"x +\\<^sub>L _mk_svid_list xs\"\n\n  \\<comment> \\<open> Decorations \\<close>\n  \"_spvar \\<Sigma>\"  \\<leftharpoondown>  \"CONST svar CONST id_lens\"\n  \"_sinvar \\<Sigma>\"  \\<leftharpoondown> \"CONST ivar 1\\<^sub>L\"\n  \"_soutvar \\<Sigma>\" \\<leftharpoondown> \"CONST ovar 1\\<^sub>L\"\n  \"_spvar (_svid_dot x y)\" \\<leftharpoondown> \"CONST svar (CONST lens_comp y x)\"\n  \"_sinvar (_svid_dot x y)\" \\<leftharpoondown> \"CONST ivar (CONST lens_comp y x)\"\n  \"_soutvar (_svid_dot x y)\" \\<leftharpoondown> \"CONST ovar (CONST lens_comp y x)\"\n  \"_svid_dot (_svid_dot x y) z\" \\<leftharpoondown> \"_svid_dot (CONST lens_comp y x) z\"\n\n  \"_spvar x\" \\<rightleftharpoons> \"CONST svar x\"\n  \"_sinvar x\" \\<rightleftharpoons> \"CONST ivar x\"\n  \"_soutvar x\" \\<rightleftharpoons> \"CONST ovar x\"\n\n  \\<comment> \\<open> Alphabets \\<close>\n  \"_salphaparen a\" \\<rightharpoonup> \"a\"\n  \"_salphaid x\" \\<rightharpoonup> \"x\"\n  \"_salphacomp x y\" \\<rightharpoonup> \"x +\\<^sub>L y\"\n  \"_salphaprod a b\" \\<rightleftharpoons> \"a \\<times>\\<^sub>L b\"\n  \"_salphavar x\" \\<rightharpoonup> \"x\"\n  \"_svar_nil x\" \\<rightharpoonup> \"x\"\n  \"_svar_cons x xs\" \\<rightharpoonup> \"x +\\<^sub>L xs\"\n  \"_salphaset A\" \\<rightharpoonup> \"A\"  \n  \"(_svar_cons x (_salphamk y))\" \\<leftharpoondown> \"_salphamk (x +\\<^sub>L y)\" \n  \"x\" \\<leftharpoondown> \"_salphamk x\"\n  \"_salpha_all\" \\<rightleftharpoons> \"1\\<^sub>L\"\n  \"_salpha_none\" \\<rightleftharpoons> \"0\\<^sub>L\"\n\n  \\<comment> \\<open> Quotations \\<close>\n  \"_ualpha_set A\" \\<rightharpoonup> \"A\"\n  \"_svar x\" \\<rightharpoonup> \"x\""], ["", "text \\<open> The translation rules mainly convert syntax into lens constructions, using a mixture\n  of lens operators and the bespoke variable definitions. Notably, a colon variable identifier\n  qualification becomes a lens composition, and variable sets are constructed using len sum. \n  The translation rules are carefully crafted to ensure both parsing and pretty printing. \n\n  Finally we create the following useful utility translation function that allows us to construct a \n  UTP variable (lens) type given a return and alphabet type. \\<close>"], ["", "syntax\n  \"_uvar_ty\"      :: \"type \\<Rightarrow> type \\<Rightarrow> type\""], ["", "parse_translation \\<open>\nlet\n  fun uvar_ty_tr [ty] = Syntax.const @{type_syntax lens} $ ty $ Syntax.const @{type_syntax dummy}\n    | uvar_ty_tr ts = raise TERM (\"uvar_ty_tr\", ts);\nin [(@{syntax_const \"_uvar_ty\"}, K uvar_ty_tr)] end\n\\<close>"], ["", "end"]]}