{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/utp/utp_theory.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["lemma upred_weak_complete_lattice [simp]: \"weak_complete_lattice \\<P>\"", "lemma upred_lattice_eq [simp]:\n  \"(.=\\<^bsub>\\<P>\\<^esub>) = (=)\"", "lemma upred_lattice_le [simp]:\n  \"le \\<P> P Q = (P \\<sqsubseteq> Q)\"", "lemma upred_lattice_carrier [simp]:\n  \"carrier \\<P> = UNIV\"", "lemma Healthy_fixed_points [simp]: \"fps \\<P> H = \\<lbrakk>H\\<rbrakk>\\<^sub>H\"", "lemma upred_lattice_Idempotent [simp]: \"Idem\\<^bsub>\\<P>\\<^esub> H = Idempotent H\"", "lemma upred_lattice_Monotonic [simp]: \"Mono\\<^bsub>\\<P>\\<^esub> H = Monotonic H\"", "lemma utp_order_carrier [simp]:\n  \"carrier (utp_order H) = \\<lbrakk>H\\<rbrakk>\\<^sub>H\"", "lemma utp_order_eq [simp]:\n  \"eq (utp_order T) = (=)\"", "lemma utp_order_le [simp]:\n  \"le (utp_order T) = (\\<sqsubseteq>)\"", "lemma utp_partial_order: \"partial_order (utp_order T)\"", "lemma utp_weak_partial_order: \"weak_partial_order (utp_order T)\"", "lemma mono_Monotone_utp_order:\n  \"mono f \\<Longrightarrow> Monotone (utp_order T) f\"", "lemma isotone_utp_orderI: \"Monotonic H \\<Longrightarrow> isotone (utp_order X) (utp_order Y) H\"", "lemma Mono_utp_orderI:\n  \"\\<lbrakk> \\<And> P Q. \\<lbrakk> P \\<sqsubseteq> Q; P is H; Q is H \\<rbrakk> \\<Longrightarrow> F(P) \\<sqsubseteq> F(Q) \\<rbrakk> \\<Longrightarrow> Mono\\<^bsub>utp_order H\\<^esub> F\"", "lemma utp_order_fpl: \"utp_order H = fpl \\<P> H\"", "lemma HCond_Idempotent [closure,intro]: \"Idempotent \\<H>\"", "lemma upred_lattice_inf:\n  \"Lattice.inf \\<P> A = \\<Sqinter> A\"", "lemma LFP_healthy_comp: \"\\<^bold>\\<mu> F = \\<^bold>\\<mu> (F \\<circ> \\<H>)\"", "lemma GFP_healthy_comp: \"\\<^bold>\\<nu> F = \\<^bold>\\<nu> (F \\<circ> \\<H>)\"", "lemma top_healthy [closure]: \"\\<^bold>\\<top> is \\<H>\"", "lemma bottom_healthy [closure]: \"\\<^bold>\\<bottom> is \\<H>\"", "lemma utp_top: \"P is \\<H> \\<Longrightarrow> P \\<sqsubseteq> \\<^bold>\\<top>\"", "lemma utp_bottom: \"P is \\<H> \\<Longrightarrow> \\<^bold>\\<bottom> \\<sqsubseteq> P\"", "lemma upred_top: \"\\<top>\\<^bsub>\\<P>\\<^esub> = false\"", "lemma upred_bottom: \"\\<bottom>\\<^bsub>\\<P>\\<^esub> = true\"", "lemma healthy_top: \"\\<^bold>\\<top> = \\<H>(false)\"", "lemma healthy_bottom: \"\\<^bold>\\<bottom> = \\<H>(true)\"", "lemma healthy_inf:\n  assumes \"A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\"\n  shows \"\\<^bold>\\<Sqinter> A = \\<H> (\\<Sqinter> A)\"", "lemma healthy_inf_cont:\n    assumes \"A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\" \"A \\<noteq> {}\"\n    shows \"\\<^bold>\\<Sqinter> A = \\<Sqinter> A\"", "lemma healthy_inf_def:\n    assumes \"A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\"\n    shows \"\\<^bold>\\<Sqinter> A = (if (A = {}) then \\<^bold>\\<top> else (\\<Sqinter> A))\"", "lemma healthy_meet_cont:\n    assumes \"P is \\<H>\" \"Q is \\<H>\"\n    shows \"P \\<^bold>\\<sqinter> Q = P \\<sqinter> Q\"", "lemma meet_is_healthy [closure]:\n    assumes \"P is \\<H>\" \"Q is \\<H>\"\n    shows \"P \\<sqinter> Q is \\<H>\"", "lemma meet_bottom [simp]:\n    assumes \"P is \\<H>\"\n    shows \"P \\<sqinter> \\<^bold>\\<bottom> = \\<^bold>\\<bottom>\"", "lemma meet_top [simp]:\n    assumes \"P is \\<H>\"\n    shows \"P \\<sqinter> \\<^bold>\\<top> = P\"", "theorem utp_lfp_def:\n    assumes \"Monotonic F\" \"F \\<in> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H \\<rightarrow> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\"\n    shows \"\\<^bold>\\<mu> F = (\\<mu> X \\<bullet> F(\\<H>(X)))\"", "lemma UINF_ind_Healthy [closure]:\n    assumes \"\\<And> i. P(i) is \\<H>\"\n    shows \"(\\<Sqinter> i \\<bullet> P(i)) is \\<H>\"", "lemma upower_Suc_Healthy [closure]:\n  assumes \"P is \\<H>\"\n  shows \"P \\<^bold>^ Suc n is \\<H>\"", "lemma seq_cont_Sup_distl:\n    assumes \"P is \\<H>\" \"A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\" \"A \\<noteq> {}\"\n    shows \"P ;; (\\<^bold>\\<Sqinter> A) = \\<^bold>\\<Sqinter> {P ;; Q | Q. Q \\<in> A }\"", "lemma seq_cont_Sup_distr:\n    assumes \"Q is \\<H>\" \"A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\" \"A \\<noteq> {}\"\n    shows \"(\\<^bold>\\<Sqinter> A) ;; Q = \\<^bold>\\<Sqinter> {P ;; Q | P. P \\<in> A }\"", "lemma uplus_healthy [closure]:\n    assumes \"P is \\<H>\"  \n    shows \"P\\<^sup>+ is \\<H>\"", "lemma Unit_self [simp]:\n  \"\\<I>\\<I> ;; \\<I>\\<I> = \\<I>\\<I>\"", "lemma utest_intro:\n  \"\\<I>\\<I> \\<sqsubseteq> P \\<Longrightarrow> utp_test P\"", "lemma utest_Unit [closure]:\n  \"utp_test \\<I>\\<I>\"", "lemma utest_Top [closure]: \"utp_test \\<^bold>\\<top>\"", "lemma Top_test_Right_Zero:\n  assumes \"b is \\<H>\" \"utp_test b\"\n  shows \"b ;; \\<^bold>\\<top> = \\<^bold>\\<top>\"", "lemma mk_conn_orderA [simp]: \"\\<X>\\<^bsub>H1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H2\\<^esub> = utp_order H1\"", "lemma mk_conn_orderB [simp]: \"\\<Y>\\<^bsub>H1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H2\\<^esub> = utp_order H2\"", "lemma mk_conn_lower [simp]:  \"\\<pi>\\<^sub>*\\<^bsub>H1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H2\\<^esub> = \\<H>\\<^sub>1\"", "lemma mk_conn_upper [simp]:  \"\\<pi>\\<^sup>*\\<^bsub>H1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H2\\<^esub> = \\<H>\\<^sub>2\"", "lemma galois_comp: \"(H\\<^sub>2 \\<Leftarrow>\\<langle>\\<H>\\<^sub>3,\\<H>\\<^sub>4\\<rangle>\\<Rightarrow> H\\<^sub>3) \\<circ>\\<^sub>g (H\\<^sub>1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H\\<^sub>2) = H\\<^sub>1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1\\<circ>\\<H>\\<^sub>3,\\<H>\\<^sub>4\\<circ>\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H\\<^sub>3\"", "lemma Idempotent_ex: \"mwb_lens x \\<Longrightarrow> Idempotent (ex x)\"", "lemma Monotonic_ex: \"mwb_lens x \\<Longrightarrow> Monotonic (ex x)\"", "lemma ex_closed_unrest:\n  \"vwb_lens x \\<Longrightarrow> \\<lbrakk>ex x\\<rbrakk>\\<^sub>H = {P. x \\<sharp> P}\"", "theorem ex_retract:\n  assumes \"vwb_lens x\" \"Idempotent H\" \"ex x \\<circ> H = H \\<circ> ex x\"\n  shows \"retract ((ex x \\<circ> H) \\<Leftarrow>\\<langle>ex x, H\\<rangle>\\<Rightarrow> H)\""], "translations": [["", "lemma upred_weak_complete_lattice [simp]: \"weak_complete_lattice \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_complete_lattice \\<P>", "by (simp add: upred_lattice.weak.weak_complete_lattice_axioms)"], ["", "lemma upred_lattice_eq [simp]:\n  \"(.=\\<^bsub>\\<P>\\<^esub>) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (.=\\<^bsub>\\<P>\\<^esub>) = (=)", "by (simp add: upred_lattice_def)"], ["", "lemma upred_lattice_le [simp]:\n  \"le \\<P> P Q = (P \\<sqsubseteq> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le \\<P> P Q = (P \\<sqsubseteq> Q)", "by (simp add: upred_lattice_def)"], ["", "lemma upred_lattice_carrier [simp]:\n  \"carrier \\<P> = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier \\<P> = UNIV", "by (simp add: upred_lattice_def)"], ["", "lemma Healthy_fixed_points [simp]: \"fps \\<P> H = \\<lbrakk>H\\<rbrakk>\\<^sub>H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps \\<P> H = \\<lbrakk>H\\<rbrakk>\\<^sub>H", "by (simp add: fps_def upred_lattice_def Healthy_def)"], ["", "lemma upred_lattice_Idempotent [simp]: \"Idem\\<^bsub>\\<P>\\<^esub> H = Idempotent H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Idem\\<^bsub>\\<P>\\<^esub> H = Idempotent H", "using upred_lattice.weak_partial_order_axioms"], ["proof (prove)\nusing this:\n  weak_partial_order \\<P>\n\ngoal (1 subgoal):\n 1. Idem\\<^bsub>\\<P>\\<^esub> H = Idempotent H", "by (auto simp add: idempotent_def Idempotent_def)"], ["", "lemma upred_lattice_Monotonic [simp]: \"Mono\\<^bsub>\\<P>\\<^esub> H = Monotonic H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mono\\<^bsub>\\<P>\\<^esub> H = Monotonic H", "using upred_lattice.weak_partial_order_axioms"], ["proof (prove)\nusing this:\n  weak_partial_order \\<P>\n\ngoal (1 subgoal):\n 1. Mono\\<^bsub>\\<P>\\<^esub> H = Monotonic H", "by (auto simp add: isotone_def mono_def)"], ["", "subsection \\<open> UTP theories hierarchy \\<close>"], ["", "definition utp_order :: \"('\\<alpha> \\<times> '\\<alpha>) health \\<Rightarrow> '\\<alpha> hrel gorder\" where\n\"utp_order H = \\<lparr> carrier = {P. P is H}, eq = (=), le = (\\<sqsubseteq>) \\<rparr>\""], ["", "text \\<open> Constant @{term utp_order} obtains the order structure associated with a UTP theory.\n  Its carrier is the set of healthy predicates, equality is HOL equality, and the order is\n  refinement. \\<close>"], ["", "lemma utp_order_carrier [simp]:\n  \"carrier (utp_order H) = \\<lbrakk>H\\<rbrakk>\\<^sub>H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier (utp_order H) = \\<lbrakk>H\\<rbrakk>\\<^sub>H", "by (simp add: utp_order_def)"], ["", "lemma utp_order_eq [simp]:\n  \"eq (utp_order T) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (.=\\<^bsub>utp_order T\\<^esub>) = (=)", "by (simp add: utp_order_def)"], ["", "lemma utp_order_le [simp]:\n  \"le (utp_order T) = (\\<sqsubseteq>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le (utp_order T) = (\\<sqsubseteq>)", "by (simp add: utp_order_def)"], ["", "lemma utp_partial_order: \"partial_order (utp_order T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_order (utp_order T)", "by (unfold_locales, simp_all add: utp_order_def)"], ["", "lemma utp_weak_partial_order: \"weak_partial_order (utp_order T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_partial_order (utp_order T)", "by (unfold_locales, simp_all add: utp_order_def)"], ["", "lemma mono_Monotone_utp_order:\n  \"mono f \\<Longrightarrow> Monotone (utp_order T) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotonic f \\<Longrightarrow> Mono\\<^bsub>utp_order T\\<^esub> f", "apply (auto simp add: isotone_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Monotonic f \\<Longrightarrow> weak_partial_order (utp_order T)\n 2. \\<And>x y.\n       \\<lbrakk>Monotonic f; x is T; y is T; x \\<sqsubseteq> y\\<rbrakk>\n       \\<Longrightarrow> f x \\<sqsubseteq> f y", "apply (metis partial_order_def utp_partial_order)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>Monotonic f; x is T; y is T; x \\<sqsubseteq> y\\<rbrakk>\n       \\<Longrightarrow> f x \\<sqsubseteq> f y", "apply (metis monoD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma isotone_utp_orderI: \"Monotonic H \\<Longrightarrow> isotone (utp_order X) (utp_order Y) H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotonic H \\<Longrightarrow> isotone (utp_order X) (utp_order Y) H", "by (auto simp add: mono_def isotone_def utp_weak_partial_order)"], ["", "lemma Mono_utp_orderI:\n  \"\\<lbrakk> \\<And> P Q. \\<lbrakk> P \\<sqsubseteq> Q; P is H; Q is H \\<rbrakk> \\<Longrightarrow> F(P) \\<sqsubseteq> F(Q) \\<rbrakk> \\<Longrightarrow> Mono\\<^bsub>utp_order H\\<^esub> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>P \\<sqsubseteq> Q; P is H; Q is H\\<rbrakk>\n        \\<Longrightarrow> F P \\<sqsubseteq> F Q) \\<Longrightarrow>\n    Mono\\<^bsub>utp_order H\\<^esub> F", "by (auto simp add: isotone_def utp_weak_partial_order)"], ["", "text \\<open> The UTP order can equivalently be characterised as the fixed point lattice, @{const fpl}. \\<close>"], ["", "lemma utp_order_fpl: \"utp_order H = fpl \\<P> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. utp_order H = fpl \\<P> H", "by (auto simp add: utp_order_def upred_lattice_def fps_def Healthy_def)"], ["", "subsection \\<open> UTP theory hierarchy \\<close>"], ["", "text \\<open> We next define a hierarchy of locales that characterise different classes of UTP theory.\n  Minimally we require that a UTP theory's healthiness condition is idempotent. \\<close>"], ["", "locale utp_theory =\n  fixes hcond :: \"'\\<alpha> hrel \\<Rightarrow> '\\<alpha> hrel\" (\"\\<H>\")\n  assumes HCond_Idem: \"\\<H>(\\<H>(P)) = \\<H>(P)\"\nbegin"], ["", "abbreviation thy_order :: \"'\\<alpha> hrel gorder\" where\n  \"thy_order \\<equiv> utp_order \\<H>\""], ["", "lemma HCond_Idempotent [closure,intro]: \"Idempotent \\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Idempotent \\<H>", "by (simp add: Idempotent_def HCond_Idem)"], ["", "sublocale utp_po: partial_order \"utp_order \\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_order thy_order", "by (unfold_locales, simp_all add: utp_order_def)"], ["", "text \\<open> We need to remove some transitivity rules to stop them being applied in calculations \\<close>"], ["", "declare utp_po.trans [trans del]"], ["", "end"], ["", "locale utp_theory_lattice = utp_theory + \n  assumes uthy_lattice: \"complete_lattice (utp_order \\<H>)\"\nbegin"], ["", "sublocale complete_lattice \"utp_order \\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete_lattice thy_order", "by (simp add: uthy_lattice)"], ["", "declare top_closed [simp del]"], ["", "declare bottom_closed [simp del]"], ["", "text \\<open> The healthiness conditions of a UTP theory lattice form a complete lattice, and allows us to make\n  use of complete lattice results from HOL-Algebra~\\cite{Ballarin17}, such as the Knaster-Tarski theorem. We can also\n  retrieve lattice operators as below. \\<close>"], ["", "abbreviation utp_top (\"\\<^bold>\\<top>\")\nwhere \"utp_top \\<equiv> top (utp_order \\<H>)\""], ["", "abbreviation utp_bottom (\"\\<^bold>\\<bottom>\")\nwhere \"utp_bottom \\<equiv> bottom (utp_order \\<H>)\""], ["", "abbreviation utp_join (infixl \"\\<^bold>\\<squnion>\" 65) where\n\"utp_join \\<equiv> join (utp_order \\<H>)\""], ["", "abbreviation utp_meet (infixl \"\\<^bold>\\<sqinter>\" 70) where\n\"utp_meet \\<equiv> meet (utp_order \\<H>)\""], ["", "abbreviation utp_sup (\"\\<^bold>\\<Squnion>_\" [90] 90) where\n\"utp_sup \\<equiv> Lattice.sup (utp_order \\<H>)\""], ["", "abbreviation utp_inf (\"\\<^bold>\\<Sqinter>_\" [90] 90) where\n\"utp_inf \\<equiv> Lattice.inf (utp_order \\<H>)\""], ["", "abbreviation utp_gfp (\"\\<^bold>\\<nu>\") where\n\"utp_gfp \\<equiv> GREATEST_FP (utp_order \\<H>)\""], ["", "abbreviation utp_lfp (\"\\<^bold>\\<mu>\") where\n\"utp_lfp \\<equiv> LEAST_FP (utp_order \\<H>)\""], ["", "end"], ["", "syntax\n  \"_tmu\" :: \"logic \\<Rightarrow> pttrn \\<Rightarrow> logic \\<Rightarrow> logic\" (\"\\<^bold>\\<mu>\\<index> _ \\<bullet> _\" [0, 10] 10)\n  \"_tnu\" :: \"logic \\<Rightarrow> pttrn \\<Rightarrow> logic \\<Rightarrow> logic\" (\"\\<^bold>\\<nu>\\<index> _ \\<bullet> _\" [0, 10] 10)"], ["", "notation gfp (\"\\<mu>\")"], ["", "notation lfp (\"\\<nu>\")"], ["", "translations\n  \"\\<^bold>\\<mu>\\<^bsub>H\\<^esub> X \\<bullet> P\" == \"CONST LEAST_FP (CONST utp_order H) (\\<lambda> X. P)\"  \n  \"\\<^bold>\\<nu>\\<^bsub>H\\<^esub> X \\<bullet> P\" == \"CONST GREATEST_FP (CONST utp_order H) (\\<lambda> X. P)\""], ["", "lemma upred_lattice_inf:\n  \"Lattice.inf \\<P> A = \\<Sqinter> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lattice.inf \\<P> A = \\<Or>A", "by (metis Sup_least Sup_upper UNIV_I antisym_conv subsetI upred_lattice.weak.inf_greatest upred_lattice.weak.inf_lower upred_lattice_carrier upred_lattice_le)"], ["", "text \\<open> We can then derive a number of properties about these operators, as below. \\<close>"], ["", "context utp_theory_lattice\nbegin"], ["", "lemma LFP_healthy_comp: \"\\<^bold>\\<mu> F = \\<^bold>\\<mu> (F \\<circ> \\<H>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<mu> F = \\<^bold>\\<mu> (F \\<circ> \\<H>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>\\<mu> F = \\<^bold>\\<mu> (F \\<circ> \\<H>)", "have \"{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} = {P. (P is \\<H>) \\<and> F (\\<H> P) \\<sqsubseteq> P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} =\n    {P. (P is \\<H>) \\<and> F (\\<H> P) \\<sqsubseteq> P}", "by (auto simp add: Healthy_def)"], ["proof (state)\nthis:\n  {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} =\n  {P. (P is \\<H>) \\<and> F (\\<H> P) \\<sqsubseteq> P}\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<mu> F = \\<^bold>\\<mu> (F \\<circ> \\<H>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} =\n  {P. (P is \\<H>) \\<and> F (\\<H> P) \\<sqsubseteq> P}\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<mu> F = \\<^bold>\\<mu> (F \\<circ> \\<H>)", "by (simp add: LEAST_FP_def)"], ["proof (state)\nthis:\n  \\<^bold>\\<mu> F = \\<^bold>\\<mu> (F \\<circ> \\<H>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma GFP_healthy_comp: \"\\<^bold>\\<nu> F = \\<^bold>\\<nu> (F \\<circ> \\<H>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<nu> F = \\<^bold>\\<nu> (F \\<circ> \\<H>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>\\<nu> F = \\<^bold>\\<nu> (F \\<circ> \\<H>)", "have \"{P. (P is \\<H>) \\<and> P \\<sqsubseteq> F P} = {P. (P is \\<H>) \\<and> P \\<sqsubseteq> F (\\<H> P)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P. (P is \\<H>) \\<and> P \\<sqsubseteq> F P} =\n    {P. (P is \\<H>) \\<and> P \\<sqsubseteq> F (\\<H> P)}", "by (auto simp add: Healthy_def)"], ["proof (state)\nthis:\n  {P. (P is \\<H>) \\<and> P \\<sqsubseteq> F P} =\n  {P. (P is \\<H>) \\<and> P \\<sqsubseteq> F (\\<H> P)}\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<nu> F = \\<^bold>\\<nu> (F \\<circ> \\<H>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {P. (P is \\<H>) \\<and> P \\<sqsubseteq> F P} =\n  {P. (P is \\<H>) \\<and> P \\<sqsubseteq> F (\\<H> P)}\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<nu> F = \\<^bold>\\<nu> (F \\<circ> \\<H>)", "by (simp add: GREATEST_FP_def)"], ["proof (state)\nthis:\n  \\<^bold>\\<nu> F = \\<^bold>\\<nu> (F \\<circ> \\<H>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma top_healthy [closure]: \"\\<^bold>\\<top> is \\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<top> is \\<H>", "using weak.top_closed"], ["proof (prove)\nusing this:\n  \\<^bold>\\<top> \\<in> carrier thy_order\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<top> is \\<H>", "by auto"], ["", "lemma bottom_healthy [closure]: \"\\<^bold>\\<bottom> is \\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<bottom> is \\<H>", "using weak.bottom_closed"], ["proof (prove)\nusing this:\n  \\<^bold>\\<bottom> \\<in> carrier thy_order\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<bottom> is \\<H>", "by auto"], ["", "lemma utp_top: \"P is \\<H> \\<Longrightarrow> P \\<sqsubseteq> \\<^bold>\\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P is \\<H> \\<Longrightarrow> P \\<sqsubseteq> \\<^bold>\\<top>", "using weak.top_higher"], ["proof (prove)\nusing this:\n  ?x \\<in> carrier thy_order \\<Longrightarrow>\n  le thy_order ?x \\<^bold>\\<top>\n\ngoal (1 subgoal):\n 1. P is \\<H> \\<Longrightarrow> P \\<sqsubseteq> \\<^bold>\\<top>", "by auto"], ["", "lemma utp_bottom: \"P is \\<H> \\<Longrightarrow> \\<^bold>\\<bottom> \\<sqsubseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P is \\<H> \\<Longrightarrow> \\<^bold>\\<bottom> \\<sqsubseteq> P", "using weak.bottom_lower"], ["proof (prove)\nusing this:\n  ?x \\<in> carrier thy_order \\<Longrightarrow>\n  le thy_order \\<^bold>\\<bottom> ?x\n\ngoal (1 subgoal):\n 1. P is \\<H> \\<Longrightarrow> \\<^bold>\\<bottom> \\<sqsubseteq> P", "by auto"], ["", "end"], ["", "lemma upred_top: \"\\<top>\\<^bsub>\\<P>\\<^esub> = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top>\\<^bsub>\\<P>\\<^esub> = false", "using ball_UNIV greatest_def"], ["proof (prove)\nusing this:\n  Ball UNIV ?P = All ?P\n  greatest ?L ?g ?A =\n  (?A \\<subseteq> carrier ?L \\<and>\n   ?g \\<in> ?A \\<and> (\\<forall>x\\<in>?A. le ?L x ?g))\n\ngoal (1 subgoal):\n 1. \\<top>\\<^bsub>\\<P>\\<^esub> = false", "by fastforce"], ["", "lemma upred_bottom: \"\\<bottom>\\<^bsub>\\<P>\\<^esub> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom>\\<^bsub>\\<P>\\<^esub> = true", "by fastforce"], ["", "text \\<open> One way of obtaining a complete lattice is showing that the healthiness conditions\n  are monotone, which the below locale characterises. \\<close>"], ["", "locale utp_theory_mono = utp_theory +\n  assumes HCond_Mono [closure,intro]: \"Monotonic \\<H>\""], ["", "sublocale utp_theory_mono \\<subseteq> utp_theory_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. utp_theory_lattice \\<H>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. utp_theory_lattice \\<H>", "interpret weak_complete_lattice \"fpl \\<P> \\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_complete_lattice (fpl \\<P> \\<H>)", "by (rule Knaster_Tarski, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. utp_theory_lattice \\<H>", "have \"complete_lattice (fpl \\<P> \\<H>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete_lattice (fpl \\<P> \\<H>)", "by (unfold_locales, simp add: fps_def sup_exists, (blast intro: sup_exists inf_exists)+)"], ["proof (state)\nthis:\n  complete_lattice (fpl \\<P> \\<H>)\n\ngoal (1 subgoal):\n 1. utp_theory_lattice \\<H>", "hence \"complete_lattice (utp_order \\<H>)\""], ["proof (prove)\nusing this:\n  complete_lattice (fpl \\<P> \\<H>)\n\ngoal (1 subgoal):\n 1. complete_lattice thy_order", "by (simp add: utp_order_def, simp add: upred_lattice_def)"], ["proof (state)\nthis:\n  complete_lattice thy_order\n\ngoal (1 subgoal):\n 1. utp_theory_lattice \\<H>", "thus \"utp_theory_lattice \\<H>\""], ["proof (prove)\nusing this:\n  complete_lattice thy_order\n\ngoal (1 subgoal):\n 1. utp_theory_lattice \\<H>", "by (simp add: utp_theory_axioms utp_theory_lattice.intro utp_theory_lattice_axioms.intro)"], ["proof (state)\nthis:\n  utp_theory_lattice \\<H>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> In a monotone theory, the top and bottom can always be obtained by applying the healthiness\n  condition to the predicate top and bottom, respectively. \\<close>"], ["", "context utp_theory_mono\nbegin"], ["", "lemma healthy_top: \"\\<^bold>\\<top> = \\<H>(false)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<top> = \\<H> false", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>\\<top> = \\<H> false", "have \"\\<^bold>\\<top> = \\<top>\\<^bsub>fpl \\<P> \\<H>\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<top> = \\<top>\\<^bsub>fpl \\<P> \\<H>\\<^esub>", "by (simp add: utp_order_fpl)"], ["proof (state)\nthis:\n  \\<^bold>\\<top> = \\<top>\\<^bsub>fpl \\<P> \\<H>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<top> = \\<H> false", "also"], ["proof (state)\nthis:\n  \\<^bold>\\<top> = \\<top>\\<^bsub>fpl \\<P> \\<H>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<top> = \\<H> false", "have \"... = \\<H> \\<top>\\<^bsub>\\<P>\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top>\\<^bsub>fpl \\<P> \\<H>\\<^esub> = \\<H> \\<top>\\<^bsub>\\<P>\\<^esub>", "using Knaster_Tarski_idem_extremes(1)[of \\<P> \\<H>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>weak_complete_lattice \\<P>; Mono\\<^bsub>\\<P>\\<^esub> \\<H>;\n   Idem\\<^bsub>\\<P>\\<^esub> \\<H>;\n   \\<H> \\<in> carrier \\<P> \\<rightarrow> carrier \\<P>\\<rbrakk>\n  \\<Longrightarrow> \\<top>\\<^bsub>fpl \\<P> \\<H>\\<^esub> .=\\<^bsub>\\<P>\\<^esub>\n                    \\<H> \\<top>\\<^bsub>\\<P>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<top>\\<^bsub>fpl \\<P> \\<H>\\<^esub> = \\<H> \\<top>\\<^bsub>\\<P>\\<^esub>", "by (simp add: HCond_Idempotent HCond_Mono)"], ["proof (state)\nthis:\n  \\<top>\\<^bsub>fpl \\<P> \\<H>\\<^esub> = \\<H> \\<top>\\<^bsub>\\<P>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<top> = \\<H> false", "also"], ["proof (state)\nthis:\n  \\<top>\\<^bsub>fpl \\<P> \\<H>\\<^esub> = \\<H> \\<top>\\<^bsub>\\<P>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<top> = \\<H> false", "have \"... = \\<H> false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<H> \\<top>\\<^bsub>\\<P>\\<^esub> = \\<H> false", "by (simp add: upred_top)"], ["proof (state)\nthis:\n  \\<H> \\<top>\\<^bsub>\\<P>\\<^esub> = \\<H> false\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<top> = \\<H> false", "finally"], ["proof (chain)\npicking this:\n  \\<^bold>\\<top> = \\<H> false", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>\\<top> = \\<H> false\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<top> = \\<H> false", "."], ["proof (state)\nthis:\n  \\<^bold>\\<top> = \\<H> false\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma healthy_bottom: \"\\<^bold>\\<bottom> = \\<H>(true)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<bottom> = \\<H> true", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>\\<bottom> = \\<H> true", "have \"\\<^bold>\\<bottom> = \\<bottom>\\<^bsub>fpl \\<P> \\<H>\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<bottom> = \\<bottom>\\<^bsub>fpl \\<P> \\<H>\\<^esub>", "by (simp add: utp_order_fpl)"], ["proof (state)\nthis:\n  \\<^bold>\\<bottom> = \\<bottom>\\<^bsub>fpl \\<P> \\<H>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<bottom> = \\<H> true", "also"], ["proof (state)\nthis:\n  \\<^bold>\\<bottom> = \\<bottom>\\<^bsub>fpl \\<P> \\<H>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<bottom> = \\<H> true", "have \"... = \\<H> \\<bottom>\\<^bsub>\\<P>\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom>\\<^bsub>fpl \\<P> \\<H>\\<^esub> =\n    \\<H> \\<bottom>\\<^bsub>\\<P>\\<^esub>", "using Knaster_Tarski_idem_extremes(2)[of \\<P> \\<H>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>weak_complete_lattice \\<P>; Mono\\<^bsub>\\<P>\\<^esub> \\<H>;\n   Idem\\<^bsub>\\<P>\\<^esub> \\<H>;\n   \\<H> \\<in> carrier \\<P> \\<rightarrow> carrier \\<P>\\<rbrakk>\n  \\<Longrightarrow> \\<bottom>\\<^bsub>fpl \\<P> \\<H>\\<^esub> .=\\<^bsub>\\<P>\\<^esub>\n                    \\<H> \\<bottom>\\<^bsub>\\<P>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<bottom>\\<^bsub>fpl \\<P> \\<H>\\<^esub> =\n    \\<H> \\<bottom>\\<^bsub>\\<P>\\<^esub>", "by (simp add: HCond_Idempotent HCond_Mono)"], ["proof (state)\nthis:\n  \\<bottom>\\<^bsub>fpl \\<P> \\<H>\\<^esub> =\n  \\<H> \\<bottom>\\<^bsub>\\<P>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<bottom> = \\<H> true", "also"], ["proof (state)\nthis:\n  \\<bottom>\\<^bsub>fpl \\<P> \\<H>\\<^esub> =\n  \\<H> \\<bottom>\\<^bsub>\\<P>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<bottom> = \\<H> true", "have \"... = \\<H> true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<H> \\<bottom>\\<^bsub>\\<P>\\<^esub> = \\<H> true", "by (simp add: upred_bottom)"], ["proof (state)\nthis:\n  \\<H> \\<bottom>\\<^bsub>\\<P>\\<^esub> = \\<H> true\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<bottom> = \\<H> true", "finally"], ["proof (chain)\npicking this:\n  \\<^bold>\\<bottom> = \\<H> true", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>\\<bottom> = \\<H> true\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<bottom> = \\<H> true", "."], ["proof (state)\nthis:\n  \\<^bold>\\<bottom> = \\<H> true\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma healthy_inf:\n  assumes \"A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\"\n  shows \"\\<^bold>\\<Sqinter> A = \\<H> (\\<Sqinter> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A = \\<H> (\\<Or>A)", "using Knaster_Tarski_idem_inf_eq[OF upred_weak_complete_lattice, of \"\\<H>\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Mono\\<^bsub>\\<P>\\<^esub> \\<H>; Idem\\<^bsub>\\<P>\\<^esub> \\<H>;\n   \\<H> \\<in> carrier \\<P> \\<rightarrow> carrier \\<P>;\n   ?A \\<subseteq> fps \\<P> \\<H>\\<rbrakk>\n  \\<Longrightarrow> Lattice.inf (fpl \\<P> \\<H>) ?A .=\\<^bsub>\\<P>\\<^esub>\n                    \\<H> (Lattice.inf \\<P> ?A)\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A = \\<H> (\\<Or>A)", "by (simp, metis HCond_Idempotent HCond_Mono assms partial_object.simps(3) upred_lattice_def upred_lattice_inf utp_order_def)"], ["", "end"], ["", "locale utp_theory_continuous = utp_theory +\n  assumes HCond_Cont [closure,intro]: \"Continuous \\<H>\""], ["", "sublocale utp_theory_continuous \\<subseteq> utp_theory_mono"], ["proof (prove)\ngoal (1 subgoal):\n 1. utp_theory_mono \\<H>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Monotonic \\<H>", "show \"Monotonic \\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotonic \\<H>", "by (simp add: Continuous_Monotonic HCond_Cont)"], ["proof (state)\nthis:\n  Monotonic \\<H>\n\ngoal:\nNo subgoals!", "qed"], ["", "context utp_theory_continuous\nbegin"], ["", "lemma healthy_inf_cont:\n    assumes \"A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\" \"A \\<noteq> {}\"\n    shows \"\\<^bold>\\<Sqinter> A = \\<Sqinter> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A = \\<Or>A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A = \\<Or>A", "have \"\\<^bold>\\<Sqinter> A = \\<Sqinter> (\\<H>`A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A = \\<Or>(\\<H> ` A)", "using Continuous_def HCond_Cont assms(1) assms(2) healthy_inf"], ["proof (prove)\nusing this:\n  Continuous ?H =\n  (\\<forall>A. \\<not> A = {} \\<longrightarrow> ?H (\\<Or>A) = \\<Or>(?H ` A))\n  Continuous \\<H>\n  A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\n  \\<not> A = {}\n  ?A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H \\<Longrightarrow>\n  \\<^bold>\\<Sqinter>?A = \\<H> (\\<Or>?A)\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A = \\<Or>(\\<H> ` A)", "by auto"], ["proof (state)\nthis:\n  \\<^bold>\\<Sqinter>A = \\<Or>(\\<H> ` A)\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A = \\<Or>A", "also"], ["proof (state)\nthis:\n  \\<^bold>\\<Sqinter>A = \\<Or>(\\<H> ` A)\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A = \\<Or>A", "have \"... = \\<Sqinter> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Or>(\\<H> ` A) = \\<Or>A", "by (unfold Healthy_carrier_image[OF assms(1)], simp)"], ["proof (state)\nthis:\n  \\<Or>(\\<H> ` A) = \\<Or>A\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A = \\<Or>A", "finally"], ["proof (chain)\npicking this:\n  \\<^bold>\\<Sqinter>A = \\<Or>A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>\\<Sqinter>A = \\<Or>A\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A = \\<Or>A", "."], ["proof (state)\nthis:\n  \\<^bold>\\<Sqinter>A = \\<Or>A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma healthy_inf_def:\n    assumes \"A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\"\n    shows \"\\<^bold>\\<Sqinter> A = (if (A = {}) then \\<^bold>\\<top> else (\\<Sqinter> A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A = (if A = {} then \\<^bold>\\<top> else \\<Or>A)", "using assms healthy_inf_cont weak.weak_inf_empty"], ["proof (prove)\nusing this:\n  A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\n  \\<lbrakk>?A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H;\n   \\<not> ?A = {}\\<rbrakk>\n  \\<Longrightarrow> \\<^bold>\\<Sqinter>?A = \\<Or>?A\n  \\<^bold>\\<Sqinter>{} .=\\<^bsub>thy_order\\<^esub> \\<^bold>\\<top>\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A = (if A = {} then \\<^bold>\\<top> else \\<Or>A)", "by auto"], ["", "lemma healthy_meet_cont:\n    assumes \"P is \\<H>\" \"Q is \\<H>\"\n    shows \"P \\<^bold>\\<sqinter> Q = P \\<sqinter> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<^bold>\\<sqinter> Q = P \\<sqinter> Q", "using healthy_inf_cont[of \"{P, Q}\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>{P, Q} \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H;\n   \\<not> {P, Q} = {}\\<rbrakk>\n  \\<Longrightarrow> \\<^bold>\\<Sqinter>{P, Q} = \\<Or>{P, Q}\n  P is \\<H>\n  Q is \\<H>\n\ngoal (1 subgoal):\n 1. P \\<^bold>\\<sqinter> Q = P \\<sqinter> Q", "by (simp add: Healthy_if meet_def)"], ["", "lemma meet_is_healthy [closure]:\n    assumes \"P is \\<H>\" \"Q is \\<H>\"\n    shows \"P \\<sqinter> Q is \\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqinter> Q is \\<H>", "by (metis Continuous_Disjunctous Disjunctuous_def HCond_Cont Healthy_def' assms(1) assms(2))"], ["", "lemma meet_bottom [simp]:\n    assumes \"P is \\<H>\"\n    shows \"P \\<sqinter> \\<^bold>\\<bottom> = \\<^bold>\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqinter> \\<^bold>\\<bottom> = \\<^bold>\\<bottom>", "by (simp add: assms semilattice_sup_class.sup_absorb2 utp_bottom)"], ["", "lemma meet_top [simp]:\n    assumes \"P is \\<H>\"\n    shows \"P \\<sqinter> \\<^bold>\\<top> = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqinter> \\<^bold>\\<top> = P", "by (simp add: assms semilattice_sup_class.sup_absorb1 utp_top)"], ["", "text \\<open> The UTP theory lfp operator can be rewritten to the alphabetised predicate lfp when\n    in a continuous context. \\<close>"], ["", "theorem utp_lfp_def:\n    assumes \"Monotonic F\" \"F \\<in> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H \\<rightarrow> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\"\n    shows \"\\<^bold>\\<mu> F = (\\<mu> X \\<bullet> F(\\<H>(X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<mu> F = (\\<mu> X \\<bullet> F (\\<H> X))", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<mu> X \\<bullet> F (\\<H> X)) \\<sqsubseteq> \\<^bold>\\<mu> F\n 2. \\<^bold>\\<mu> F \\<sqsubseteq> (\\<mu> X \\<bullet> F (\\<H> X))", "have ne: \"{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} = {}", "have \"F \\<^bold>\\<top> \\<sqsubseteq> \\<^bold>\\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<^bold>\\<top> \\<sqsubseteq> \\<^bold>\\<top>", "using assms(2) utp_top weak.top_closed"], ["proof (prove)\nusing this:\n  F \\<in> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H \\<rightarrow>\n          \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\n  ?P is \\<H> \\<Longrightarrow> ?P \\<sqsubseteq> \\<^bold>\\<top>\n  \\<^bold>\\<top> \\<in> carrier thy_order\n\ngoal (1 subgoal):\n 1. F \\<^bold>\\<top> \\<sqsubseteq> \\<^bold>\\<top>", "by force"], ["proof (state)\nthis:\n  F \\<^bold>\\<top> \\<sqsubseteq> \\<^bold>\\<top>\n\ngoal (1 subgoal):\n 1. \\<not> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  F \\<^bold>\\<top> \\<sqsubseteq> \\<^bold>\\<top>\n\ngoal (1 subgoal):\n 1. \\<not> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} = {}", "by (auto, rule_tac x=\"\\<^bold>\\<top>\" in exI, auto simp add: top_healthy)"], ["proof (state)\nthis:\n  \\<not> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} = {}\n\ngoal (2 subgoals):\n 1. (\\<mu> X \\<bullet> F (\\<H> X)) \\<sqsubseteq> \\<^bold>\\<mu> F\n 2. \\<^bold>\\<mu> F \\<sqsubseteq> (\\<mu> X \\<bullet> F (\\<H> X))", "show \"\\<^bold>\\<mu> F \\<sqsubseteq> (\\<mu> X \\<bullet> F (\\<H> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<mu> F \\<sqsubseteq> (\\<mu> X \\<bullet> F (\\<H> X))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>\\<mu> F \\<sqsubseteq> (\\<mu> X \\<bullet> F (\\<H> X))", "have \"\\<Sqinter>{P. (P is \\<H>) \\<and> F(P) \\<sqsubseteq> P} \\<sqsubseteq> \\<Sqinter>{P. F(\\<H>(P)) \\<sqsubseteq> P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq>\n    \\<Or>{P. F (\\<H> P) \\<sqsubseteq> P}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq>\n    \\<Or>{P. F (\\<H> P) \\<sqsubseteq> P}", "have 1: \"\\<And> P. F(\\<H>(P)) = \\<H>(F(\\<H>(P)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P. F (\\<H> P) = \\<H> (F (\\<H> P))", "by (metis HCond_Idem Healthy_def assms(2) funcset_mem mem_Collect_eq)"], ["proof (state)\nthis:\n  F (\\<H> ?P) = \\<H> (F (\\<H> ?P))\n\ngoal (1 subgoal):\n 1. \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq>\n    \\<Or>{P. F (\\<H> P) \\<sqsubseteq> P}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq>\n    \\<Or>{P. F (\\<H> P) \\<sqsubseteq> P}", "proof (rule Sup_least, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       F (\\<H> x) \\<sqsubseteq> x \\<Longrightarrow>\n       \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq> x", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       F (\\<H> x) \\<sqsubseteq> x \\<Longrightarrow>\n       \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq> x", "assume a: \"F (\\<H> P) \\<sqsubseteq> P\""], ["proof (state)\nthis:\n  F (\\<H> P) \\<sqsubseteq> P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       F (\\<H> x) \\<sqsubseteq> x \\<Longrightarrow>\n       \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq> x", "hence F: \"(F (\\<H> P)) \\<sqsubseteq> (\\<H> P)\""], ["proof (prove)\nusing this:\n  F (\\<H> P) \\<sqsubseteq> P\n\ngoal (1 subgoal):\n 1. F (\\<H> P) \\<sqsubseteq> \\<H> P", "by (metis 1 HCond_Mono mono_def)"], ["proof (state)\nthis:\n  F (\\<H> P) \\<sqsubseteq> \\<H> P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       F (\\<H> x) \\<sqsubseteq> x \\<Longrightarrow>\n       \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq> x", "show \"\\<Sqinter>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq> P", "proof (rule Sup_upper2[of \"F (\\<H> P)\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. F (\\<H> P) \\<in> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P}\n 2. F (\\<H> P) \\<sqsubseteq> P", "show \"F (\\<H> P) \\<in> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (\\<H> P) \\<in> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P}", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. F (\\<H> P) is \\<H>\n 2. F (F (\\<H> P)) \\<sqsubseteq> F (\\<H> P)", "show \"F (\\<H> P) is \\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (\\<H> P) is \\<H>", "by (metis 1 Healthy_def)"], ["proof (state)\nthis:\n  F (\\<H> P) is \\<H>\n\ngoal (1 subgoal):\n 1. F (F (\\<H> P)) \\<sqsubseteq> F (\\<H> P)", "show \"F (F (\\<H> P)) \\<sqsubseteq> F (\\<H> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (F (\\<H> P)) \\<sqsubseteq> F (\\<H> P)", "using F mono_def assms(1)"], ["proof (prove)\nusing this:\n  F (\\<H> P) \\<sqsubseteq> \\<H> P\n  mono ?f = (\\<forall>x y. x \\<le> y \\<longrightarrow> ?f x \\<le> ?f y)\n  Monotonic F\n\ngoal (1 subgoal):\n 1. F (F (\\<H> P)) \\<sqsubseteq> F (\\<H> P)", "by blast"], ["proof (state)\nthis:\n  F (F (\\<H> P)) \\<sqsubseteq> F (\\<H> P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F (\\<H> P) \\<in> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P}\n\ngoal (1 subgoal):\n 1. F (\\<H> P) \\<sqsubseteq> P", "show \"F (\\<H> P) \\<sqsubseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (\\<H> P) \\<sqsubseteq> P", "by (simp add: a)"], ["proof (state)\nthis:\n  F (\\<H> P) \\<sqsubseteq> P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq> P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq>\n  \\<Or>{P. F (\\<H> P) \\<sqsubseteq> P}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq>\n  \\<Or>{P. F (\\<H> P) \\<sqsubseteq> P}\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<mu> F \\<sqsubseteq> (\\<mu> X \\<bullet> F (\\<H> X))", "with ne"], ["proof (chain)\npicking this:\n  \\<not> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} = {}\n  \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq>\n  \\<Or>{P. F (\\<H> P) \\<sqsubseteq> P}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} = {}\n  \\<Or>{P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} \\<sqsubseteq>\n  \\<Or>{P. F (\\<H> P) \\<sqsubseteq> P}\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<mu> F \\<sqsubseteq> (\\<mu> X \\<bullet> F (\\<H> X))", "by (simp add: LEAST_FP_def gfp_def, subst healthy_inf_cont, auto simp add: lfp_def)"], ["proof (state)\nthis:\n  \\<^bold>\\<mu> F \\<sqsubseteq> (\\<mu> X \\<bullet> F (\\<H> X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>\\<mu> F \\<sqsubseteq> (\\<mu> X \\<bullet> F (\\<H> X))\n\ngoal (1 subgoal):\n 1. (\\<mu> X \\<bullet> F (\\<H> X)) \\<sqsubseteq> \\<^bold>\\<mu> F", "from ne"], ["proof (chain)\npicking this:\n  \\<not> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} = {}", "show \"(\\<mu> X \\<bullet> F (\\<H> X)) \\<sqsubseteq> \\<^bold>\\<mu> F\""], ["proof (prove)\nusing this:\n  \\<not> {P. (P is \\<H>) \\<and> F P \\<sqsubseteq> P} = {}\n\ngoal (1 subgoal):\n 1. (\\<mu> X \\<bullet> F (\\<H> X)) \\<sqsubseteq> \\<^bold>\\<mu> F", "apply (simp add: LEAST_FP_def gfp_def, subst healthy_inf_cont, auto simp add: lfp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x is \\<H>; F x \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> \\<Or>{u. F (\\<H> u) \\<sqsubseteq> u} \\<sqsubseteq>\n                         \\<Or>{u. (u is \\<H>) \\<and> F u \\<sqsubseteq> u}", "apply (rule Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x is \\<H>; F x \\<sqsubseteq> x;\n        xa \\<in> {u. (u is \\<H>) \\<and> F u \\<sqsubseteq> u}\\<rbrakk>\n       \\<Longrightarrow> \\<Or>{u. F (\\<H> u) \\<sqsubseteq> u} \\<sqsubseteq>\n                         xa", "apply (auto simp add: Healthy_def Sup_upper)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<mu> X \\<bullet> F (\\<H> X)) \\<sqsubseteq> \\<^bold>\\<mu> F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma UINF_ind_Healthy [closure]:\n    assumes \"\\<And> i. P(i) is \\<H>\"\n    shows \"(\\<Sqinter> i \\<bullet> P(i)) is \\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> i \\<bullet> P i) is \\<H>", "by (simp add: closure assms)"], ["", "end"], ["", "text \\<open> In another direction, we can also characterise UTP theories that are relational. Minimally\n  this requires that the healthiness condition is closed under sequential composition. \\<close>"], ["", "locale utp_theory_rel =\n  utp_theory +\n  assumes Healthy_Sequence [closure]: \"\\<lbrakk> P is \\<H>; Q is \\<H> \\<rbrakk> \\<Longrightarrow> (P ;; Q) is \\<H>\"\nbegin"], ["", "lemma upower_Suc_Healthy [closure]:\n  assumes \"P is \\<H>\"\n  shows \"P \\<^bold>^ Suc n is \\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power.power II (;;) P (Suc n) is \\<H>", "by (induct n, simp_all add: closure assms upred_semiring.power_Suc)"], ["", "end"], ["", "locale utp_theory_cont_rel = utp_theory_rel + utp_theory_continuous\nbegin"], ["", "lemma seq_cont_Sup_distl:\n    assumes \"P is \\<H>\" \"A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\" \"A \\<noteq> {}\"\n    shows \"P ;; (\\<^bold>\\<Sqinter> A) = \\<^bold>\\<Sqinter> {P ;; Q | Q. Q \\<in> A }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; \\<^bold>\\<Sqinter>A =\n    \\<^bold>\\<Sqinter>{uu_. \\<exists>Q. uu_ = P ;; Q \\<and> Q \\<in> A}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P ;; \\<^bold>\\<Sqinter>A =\n    \\<^bold>\\<Sqinter>{uu_. \\<exists>Q. uu_ = P ;; Q \\<and> Q \\<in> A}", "have \"{P ;; Q | Q. Q \\<in> A } \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_. \\<exists>Q. uu_ = P ;; Q \\<and> Q \\<in> A}\n    \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H", "using Healthy_Sequence assms(1) assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?P is \\<H>; ?Q is \\<H>\\<rbrakk>\n  \\<Longrightarrow> ?P ;; ?Q is \\<H>\n  P is \\<H>\n  A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\n\ngoal (1 subgoal):\n 1. {uu_. \\<exists>Q. uu_ = P ;; Q \\<and> Q \\<in> A}\n    \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H", "by (auto)"], ["proof (state)\nthis:\n  {uu_. \\<exists>Q. uu_ = P ;; Q \\<and> Q \\<in> A}\n  \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\n\ngoal (1 subgoal):\n 1. P ;; \\<^bold>\\<Sqinter>A =\n    \\<^bold>\\<Sqinter>{uu_. \\<exists>Q. uu_ = P ;; Q \\<and> Q \\<in> A}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {uu_. \\<exists>Q. uu_ = P ;; Q \\<and> Q \\<in> A}\n  \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\n\ngoal (1 subgoal):\n 1. P ;; \\<^bold>\\<Sqinter>A =\n    \\<^bold>\\<Sqinter>{uu_. \\<exists>Q. uu_ = P ;; Q \\<and> Q \\<in> A}", "by (simp add: healthy_inf_cont seq_Sup_distl setcompr_eq_image assms)"], ["proof (state)\nthis:\n  P ;; \\<^bold>\\<Sqinter>A =\n  \\<^bold>\\<Sqinter>{uu_. \\<exists>Q. uu_ = P ;; Q \\<and> Q \\<in> A}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma seq_cont_Sup_distr:\n    assumes \"Q is \\<H>\" \"A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\" \"A \\<noteq> {}\"\n    shows \"(\\<^bold>\\<Sqinter> A) ;; Q = \\<^bold>\\<Sqinter> {P ;; Q | P. P \\<in> A }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A ;; Q =\n    \\<^bold>\\<Sqinter>{uu_. \\<exists>P. uu_ = P ;; Q \\<and> P \\<in> A}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A ;; Q =\n    \\<^bold>\\<Sqinter>{uu_. \\<exists>P. uu_ = P ;; Q \\<and> P \\<in> A}", "have \"{P ;; Q | P. P \\<in> A } \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_. \\<exists>P. uu_ = P ;; Q \\<and> P \\<in> A}\n    \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H", "using Healthy_Sequence assms(1) assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?P is \\<H>; ?Q is \\<H>\\<rbrakk>\n  \\<Longrightarrow> ?P ;; ?Q is \\<H>\n  Q is \\<H>\n  A \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\n\ngoal (1 subgoal):\n 1. {uu_. \\<exists>P. uu_ = P ;; Q \\<and> P \\<in> A}\n    \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H", "by (auto)"], ["proof (state)\nthis:\n  {uu_. \\<exists>P. uu_ = P ;; Q \\<and> P \\<in> A}\n  \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A ;; Q =\n    \\<^bold>\\<Sqinter>{uu_. \\<exists>P. uu_ = P ;; Q \\<and> P \\<in> A}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {uu_. \\<exists>P. uu_ = P ;; Q \\<and> P \\<in> A}\n  \\<subseteq> \\<lbrakk>\\<H>\\<rbrakk>\\<^sub>H\n\ngoal (1 subgoal):\n 1. \\<^bold>\\<Sqinter>A ;; Q =\n    \\<^bold>\\<Sqinter>{uu_. \\<exists>P. uu_ = P ;; Q \\<and> P \\<in> A}", "by (simp add: healthy_inf_cont seq_Sup_distr setcompr_eq_image assms)"], ["proof (state)\nthis:\n  \\<^bold>\\<Sqinter>A ;; Q =\n  \\<^bold>\\<Sqinter>{uu_. \\<exists>P. uu_ = P ;; Q \\<and> P \\<in> A}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uplus_healthy [closure]:\n    assumes \"P is \\<H>\"  \n    shows \"P\\<^sup>+ is \\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>+ is \\<H>", "by (simp add: uplus_power_def closure assms)"], ["", "end"], ["", "text \\<open> There also exist UTP theories with units. Not all theories have both a left and a right unit \n  (e.g. H1-H2 designs) and so we split up the locale into two cases. \\<close>"], ["", "locale utp_theory_units =\n  utp_theory_rel +\n  fixes utp_unit (\"\\<I>\\<I>\")\n  assumes Healthy_Unit [closure]: \"\\<I>\\<I> is \\<H>\"\nbegin"], ["", "text \\<open> We can characterise the theory Kleene star by lifting the relational one. \\<close>"], ["", "definition utp_star (\"_\\<^bold>\\<star>\" [999] 999) where\n[upred_defs]: \"utp_star P = (P\\<^sup>\\<star> ;; \\<I>\\<I>)\""], ["", "text \\<open> We can then characterise tests as refinements of units. \\<close>"], ["", "definition utp_test :: \"'a hrel \\<Rightarrow> bool\" where\n[upred_defs]: \"utp_test b = (\\<I>\\<I> \\<sqsubseteq> b)\""], ["", "end"], ["", "locale utp_theory_left_unital =\n  utp_theory_units +\n  assumes Unit_Left: \"P is \\<H> \\<Longrightarrow> (\\<I>\\<I> ;; P) = P\""], ["", "locale utp_theory_right_unital =\n  utp_theory_units +\n  assumes Unit_Right: \"P is \\<H> \\<Longrightarrow> (P ;; \\<I>\\<I>) = P\""], ["", "locale utp_theory_unital =\n  utp_theory_left_unital + utp_theory_right_unital\nbegin"], ["", "lemma Unit_self [simp]:\n  \"\\<I>\\<I> ;; \\<I>\\<I> = \\<I>\\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>\\<I> ;; \\<I>\\<I> = \\<I>\\<I>", "by (simp add: Healthy_Unit Unit_Right)"], ["", "lemma utest_intro:\n  \"\\<I>\\<I> \\<sqsubseteq> P \\<Longrightarrow> utp_test P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>\\<I> \\<sqsubseteq> P \\<Longrightarrow> utp_test P", "by (simp add: utp_test_def)"], ["", "lemma utest_Unit [closure]:\n  \"utp_test \\<I>\\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. utp_test \\<I>\\<I>", "by (simp add: utp_test_def)"], ["", "end"], ["", "locale utp_theory_mono_unital = utp_theory_unital + utp_theory_mono\nbegin"], ["", "lemma utest_Top [closure]: \"utp_test \\<^bold>\\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. utp_test \\<^bold>\\<top>", "by (simp add: Healthy_Unit utp_test_def utp_top)"], ["", "end"], ["", "locale utp_theory_cont_unital = utp_theory_cont_rel + utp_theory_unital"], ["", "sublocale utp_theory_cont_unital \\<subseteq> utp_theory_mono_unital"], ["proof (prove)\ngoal (1 subgoal):\n 1. utp_theory_mono_unital \\<H> \\<I>\\<I>", "by (simp add: utp_theory_mono_axioms utp_theory_mono_unital_def utp_theory_unital_axioms)"], ["", "locale utp_theory_unital_zerol =\n  utp_theory_unital +\n  utp_theory_lattice +\n  assumes Top_Left_Zero: \"P is \\<H> \\<Longrightarrow> \\<^bold>\\<top> ;; P = \\<^bold>\\<top>\""], ["", "locale utp_theory_cont_unital_zerol =\n  utp_theory_cont_unital + utp_theory_unital_zerol\nbegin"], ["", "lemma Top_test_Right_Zero:\n  assumes \"b is \\<H>\" \"utp_test b\"\n  shows \"b ;; \\<^bold>\\<top> = \\<^bold>\\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ;; \\<^bold>\\<top> = \\<^bold>\\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b ;; \\<^bold>\\<top> = \\<^bold>\\<top>", "have \"b \\<sqinter> \\<I>\\<I> = \\<I>\\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sqinter> \\<I>\\<I> = \\<I>\\<I>", "by (meson assms(2) semilattice_sup_class.le_iff_sup utp_test_def)"], ["proof (state)\nthis:\n  b \\<sqinter> \\<I>\\<I> = \\<I>\\<I>\n\ngoal (1 subgoal):\n 1. b ;; \\<^bold>\\<top> = \\<^bold>\\<top>", "then"], ["proof (chain)\npicking this:\n  b \\<sqinter> \\<I>\\<I> = \\<I>\\<I>", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<sqinter> \\<I>\\<I> = \\<I>\\<I>\n\ngoal (1 subgoal):\n 1. b ;; \\<^bold>\\<top> = \\<^bold>\\<top>", "by (metis (no_types) Top_Left_Zero Unit_Left assms(1) meet_top top_healthy upred_semiring.distrib_right)"], ["proof (state)\nthis:\n  b ;; \\<^bold>\\<top> = \\<^bold>\\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open> Theory of relations \\<close>"], ["", "interpretation rel_theory: utp_theory_mono_unital id skip_r\n  rewrites \"rel_theory.utp_top = false\"\n  and \"rel_theory.utp_bottom = true\"\n  and \"carrier (utp_order id) = UNIV\"\n  and \"(P is id) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (utp_theory_mono_unital id II &&&\n     \\<top>\\<^bsub>utp_order id\\<^esub> = false) &&&\n    \\<bottom>\\<^bsub>utp_order id\\<^esub> = true &&&\n    carrier (utp_order id) = UNIV &&& (P is id) = True", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. utp_theory_mono_unital id II\n 2. \\<top>\\<^bsub>utp_order id\\<^esub> = false\n 3. \\<bottom>\\<^bsub>utp_order id\\<^esub> = true\n 4. carrier (utp_order id) = UNIV\n 5. (P is id) = True", "show \"utp_theory_mono_unital id II\""], ["proof (prove)\ngoal (1 subgoal):\n 1. utp_theory_mono_unital id II", "by (unfold_locales, simp_all add: Healthy_def)"], ["proof (state)\nthis:\n  utp_theory_mono_unital id II\n\ngoal (4 subgoals):\n 1. \\<top>\\<^bsub>utp_order id\\<^esub> = false\n 2. \\<bottom>\\<^bsub>utp_order id\\<^esub> = true\n 3. carrier (utp_order id) = UNIV\n 4. (P is id) = True", "then"], ["proof (chain)\npicking this:\n  utp_theory_mono_unital id II", "interpret utp_theory_mono_unital id skip_r"], ["proof (prove)\nusing this:\n  utp_theory_mono_unital id II\n\ngoal (1 subgoal):\n 1. utp_theory_mono_unital id II", "by simp"], ["proof (state)\ngoal (4 subgoals):\n 1. utp_top = false\n 2. utp_bottom = true\n 3. carrier thy_order = UNIV\n 4. (P is id) = True", "show \"utp_top = false\" \"utp_bottom = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. utp_top = false &&& utp_bottom = true", "by (simp_all add: healthy_top healthy_bottom)"], ["proof (state)\nthis:\n  utp_top = false\n  utp_bottom = true\n\ngoal (2 subgoals):\n 1. carrier thy_order = UNIV\n 2. (P is id) = True", "show \"carrier (utp_order id) = UNIV\" \"(P is id) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier thy_order = UNIV &&& (P is id) = True", "by (auto simp add: utp_order_def Healthy_def)"], ["proof (state)\nthis:\n  carrier thy_order = UNIV\n  (P is id) = True\n\ngoal:\nNo subgoals!", "qed"], ["", "thm rel_theory.GFP_unfold"], ["", "subsection \\<open> Theory links \\<close>"], ["", "text \\<open> We can also describe links between theories, such a Galois connections and retractions,\n  using the following notation. \\<close>"], ["", "definition mk_conn (\"_ \\<Leftarrow>\\<langle>_,_\\<rangle>\\<Rightarrow> _\" [90,0,0,91] 91) where\n\"H1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H2 \\<equiv> \\<lparr> orderA = utp_order H1, orderB = utp_order H2, lower = \\<H>\\<^sub>2, upper = \\<H>\\<^sub>1 \\<rparr>\""], ["", "lemma mk_conn_orderA [simp]: \"\\<X>\\<^bsub>H1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H2\\<^esub> = utp_order H1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<X>\\<^bsub>H1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H2\\<^esub> =\n    utp_order H1", "by (simp add:mk_conn_def)"], ["", "lemma mk_conn_orderB [simp]: \"\\<Y>\\<^bsub>H1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H2\\<^esub> = utp_order H2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Y>\\<^bsub>H1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H2\\<^esub> =\n    utp_order H2", "by (simp add:mk_conn_def)"], ["", "lemma mk_conn_lower [simp]:  \"\\<pi>\\<^sub>*\\<^bsub>H1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H2\\<^esub> = \\<H>\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>*\\<^bsub>H1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H2\\<^esub> =\n    \\<H>\\<^sub>1", "by (simp add: mk_conn_def)"], ["", "lemma mk_conn_upper [simp]:  \"\\<pi>\\<^sup>*\\<^bsub>H1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H2\\<^esub> = \\<H>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sup>*\\<^bsub>H1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H2\\<^esub> =\n    \\<H>\\<^sub>2", "by (simp add: mk_conn_def)"], ["", "lemma galois_comp: \"(H\\<^sub>2 \\<Leftarrow>\\<langle>\\<H>\\<^sub>3,\\<H>\\<^sub>4\\<rangle>\\<Rightarrow> H\\<^sub>3) \\<circ>\\<^sub>g (H\\<^sub>1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H\\<^sub>2) = H\\<^sub>1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1\\<circ>\\<H>\\<^sub>3,\\<H>\\<^sub>4\\<circ>\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H\\<^sub>3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H\\<^sub>2 \\<Leftarrow>\\<langle>\\<H>\\<^sub>3,\\<H>\\<^sub>4\\<rangle>\\<Rightarrow> H\\<^sub>3 \\<circ>\\<^sub>g\n    H\\<^sub>1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1,\\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H\\<^sub>2 =\n    H\\<^sub>1 \\<Leftarrow>\\<langle>\\<H>\\<^sub>1 \\<circ>\n                                   \\<H>\\<^sub>3,\\<H>\\<^sub>4 \\<circ>\n          \\<H>\\<^sub>2\\<rangle>\\<Rightarrow> H\\<^sub>3", "by (simp add: comp_galcon_def mk_conn_def)"], ["", "text \\<open> Example Galois connection / retract: Existential quantification \\<close>"], ["", "lemma Idempotent_ex: \"mwb_lens x \\<Longrightarrow> Idempotent (ex x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow> Idempotent (uex x)", "by (simp add: Idempotent_def exists_twice)"], ["", "lemma Monotonic_ex: \"mwb_lens x \\<Longrightarrow> Monotonic (ex x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow> Monotonic (uex x)", "by (simp add: mono_def ex_mono)"], ["", "lemma ex_closed_unrest:\n  \"vwb_lens x \\<Longrightarrow> \\<lbrakk>ex x\\<rbrakk>\\<^sub>H = {P. x \\<sharp> P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow>\n    \\<lbrakk>uex x\\<rbrakk>\\<^sub>H = {P. x \\<sharp> P}", "by (simp add: Healthy_def unrest_as_exists)"], ["", "text \\<open> Any theory can be composed with an existential quantification to produce a Galois connection \\<close>"], ["", "theorem ex_retract:\n  assumes \"vwb_lens x\" \"Idempotent H\" \"ex x \\<circ> H = H \\<circ> ex x\"\n  shows \"retract ((ex x \\<circ> H) \\<Leftarrow>\\<langle>ex x, H\\<rangle>\\<Rightarrow> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. retract\n     ((uex x \\<circ>\n       H) \\<Leftarrow>\\<langle>uex x,H\\<rangle>\\<Rightarrow> H)", "proof (unfold_locales, simp_all)"], ["proof (state)\ngoal (4 subgoals):\n 1. H \\<in> \\<lbrakk>uex x \\<circ> H\\<rbrakk>\\<^sub>H \\<rightarrow>\n            \\<lbrakk>H\\<rbrakk>\\<^sub>H\n 2. uex x\n    \\<in> \\<lbrakk>H\\<rbrakk>\\<^sub>H \\<rightarrow>\n          \\<lbrakk>uex x \\<circ> H\\<rbrakk>\\<^sub>H\n 3. \\<And>xa y.\n       \\<lbrakk>xa is uex x \\<circ> H; y is H\\<rbrakk>\n       \\<Longrightarrow> (H xa \\<sqsubseteq> y) =\n                         (xa \\<sqsubseteq> (\\<exists> x \\<bullet> y))\n 4. \\<And>xa.\n       xa is uex x \\<circ> H \\<Longrightarrow>\n       (\\<exists> x \\<bullet> H xa) \\<sqsubseteq> xa", "show \"H \\<in> \\<lbrakk>ex x \\<circ> H\\<rbrakk>\\<^sub>H \\<rightarrow> \\<lbrakk>H\\<rbrakk>\\<^sub>H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<in> \\<lbrakk>uex x \\<circ> H\\<rbrakk>\\<^sub>H \\<rightarrow>\n            \\<lbrakk>H\\<rbrakk>\\<^sub>H", "using Healthy_Idempotent assms"], ["proof (prove)\nusing this:\n  Idempotent ?H \\<Longrightarrow> ?H ?P is ?H\n  vwb_lens x\n  Idempotent H\n  uex x \\<circ> H = H \\<circ> uex x\n\ngoal (1 subgoal):\n 1. H \\<in> \\<lbrakk>uex x \\<circ> H\\<rbrakk>\\<^sub>H \\<rightarrow>\n            \\<lbrakk>H\\<rbrakk>\\<^sub>H", "by blast"], ["proof (state)\nthis:\n  H \\<in> \\<lbrakk>uex x \\<circ> H\\<rbrakk>\\<^sub>H \\<rightarrow>\n          \\<lbrakk>H\\<rbrakk>\\<^sub>H\n\ngoal (3 subgoals):\n 1. uex x\n    \\<in> \\<lbrakk>H\\<rbrakk>\\<^sub>H \\<rightarrow>\n          \\<lbrakk>uex x \\<circ> H\\<rbrakk>\\<^sub>H\n 2. \\<And>xa y.\n       \\<lbrakk>xa is uex x \\<circ> H; y is H\\<rbrakk>\n       \\<Longrightarrow> (H xa \\<sqsubseteq> y) =\n                         (xa \\<sqsubseteq> (\\<exists> x \\<bullet> y))\n 3. \\<And>xa.\n       xa is uex x \\<circ> H \\<Longrightarrow>\n       (\\<exists> x \\<bullet> H xa) \\<sqsubseteq> xa", "from assms(1) assms(3)[THEN sym]"], ["proof (chain)\npicking this:\n  vwb_lens x\n  H \\<circ> uex x = uex x \\<circ> H", "show \"ex x \\<in> \\<lbrakk>H\\<rbrakk>\\<^sub>H \\<rightarrow> \\<lbrakk>ex x \\<circ> H\\<rbrakk>\\<^sub>H\""], ["proof (prove)\nusing this:\n  vwb_lens x\n  H \\<circ> uex x = uex x \\<circ> H\n\ngoal (1 subgoal):\n 1. uex x\n    \\<in> \\<lbrakk>H\\<rbrakk>\\<^sub>H \\<rightarrow>\n          \\<lbrakk>uex x \\<circ> H\\<rbrakk>\\<^sub>H", "by (simp add: Pi_iff Healthy_def fun_eq_iff exists_twice)"], ["proof (state)\nthis:\n  uex x\n  \\<in> \\<lbrakk>H\\<rbrakk>\\<^sub>H \\<rightarrow>\n        \\<lbrakk>uex x \\<circ> H\\<rbrakk>\\<^sub>H\n\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa is uex x \\<circ> H; y is H\\<rbrakk>\n       \\<Longrightarrow> (H xa \\<sqsubseteq> y) =\n                         (xa \\<sqsubseteq> (\\<exists> x \\<bullet> y))\n 2. \\<And>xa.\n       xa is uex x \\<circ> H \\<Longrightarrow>\n       (\\<exists> x \\<bullet> H xa) \\<sqsubseteq> xa", "fix P Q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa is uex x \\<circ> H; y is H\\<rbrakk>\n       \\<Longrightarrow> (H xa \\<sqsubseteq> y) =\n                         (xa \\<sqsubseteq> (\\<exists> x \\<bullet> y))\n 2. \\<And>xa.\n       xa is uex x \\<circ> H \\<Longrightarrow>\n       (\\<exists> x \\<bullet> H xa) \\<sqsubseteq> xa", "assume \"P is (ex x \\<circ> H)\" \"Q is H\""], ["proof (state)\nthis:\n  P is uex x \\<circ> H\n  Q is H\n\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa is uex x \\<circ> H; y is H\\<rbrakk>\n       \\<Longrightarrow> (H xa \\<sqsubseteq> y) =\n                         (xa \\<sqsubseteq> (\\<exists> x \\<bullet> y))\n 2. \\<And>xa.\n       xa is uex x \\<circ> H \\<Longrightarrow>\n       (\\<exists> x \\<bullet> H xa) \\<sqsubseteq> xa", "thus \"(H P \\<sqsubseteq> Q) = (P \\<sqsubseteq> (\\<exists> x \\<bullet> Q))\""], ["proof (prove)\nusing this:\n  P is uex x \\<circ> H\n  Q is H\n\ngoal (1 subgoal):\n 1. (H P \\<sqsubseteq> Q) = (P \\<sqsubseteq> (\\<exists> x \\<bullet> Q))", "by (metis (no_types, lifting) Healthy_Idempotent Healthy_if assms comp_apply dual_order.trans ex_weakens utp_pred_laws.ex_mono vwb_lens_wb)"], ["proof (state)\nthis:\n  (H P \\<sqsubseteq> Q) = (P \\<sqsubseteq> (\\<exists> x \\<bullet> Q))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa is uex x \\<circ> H \\<Longrightarrow>\n       (\\<exists> x \\<bullet> H xa) \\<sqsubseteq> xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa is uex x \\<circ> H \\<Longrightarrow>\n       (\\<exists> x \\<bullet> H xa) \\<sqsubseteq> xa", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa is uex x \\<circ> H \\<Longrightarrow>\n       (\\<exists> x \\<bullet> H xa) \\<sqsubseteq> xa", "assume \"P is (ex x \\<circ> H)\""], ["proof (state)\nthis:\n  P is uex x \\<circ> H\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa is uex x \\<circ> H \\<Longrightarrow>\n       (\\<exists> x \\<bullet> H xa) \\<sqsubseteq> xa", "thus \"(\\<exists> x \\<bullet> H P) \\<sqsubseteq> P\""], ["proof (prove)\nusing this:\n  P is uex x \\<circ> H\n\ngoal (1 subgoal):\n 1. (\\<exists> x \\<bullet> H P) \\<sqsubseteq> P", "by (simp add: Healthy_def)"], ["proof (state)\nthis:\n  (\\<exists> x \\<bullet> H P) \\<sqsubseteq> P\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary ex_retract_id:\n  assumes \"vwb_lens x\"\n  shows \"retract (ex x \\<Leftarrow>\\<langle>ex x, id\\<rangle>\\<Rightarrow> id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. retract (uex x \\<Leftarrow>\\<langle>uex x,id\\<rangle>\\<Rightarrow> id)", "using assms ex_retract[where H=\"id\"]"], ["proof (prove)\nusing this:\n  vwb_lens x\n  \\<lbrakk>vwb_lens ?x; Idempotent id;\n   uex ?x \\<circ> id = id \\<circ> uex ?x\\<rbrakk>\n  \\<Longrightarrow> retract\n                     ((uex ?x \\<circ>\n                       id) \\<Leftarrow>\\<langle>uex\n           ?x,id\\<rangle>\\<Rightarrow> id)\n\ngoal (1 subgoal):\n 1. retract (uex x \\<Leftarrow>\\<langle>uex x,id\\<rangle>\\<Rightarrow> id)", "by (auto)"], ["", "end"]]}