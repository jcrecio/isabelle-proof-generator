{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/utp/utp_alphabet.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["lemma aext_twice: \"(P \\<oplus>\\<^sub>p a) \\<oplus>\\<^sub>p b = P \\<oplus>\\<^sub>p (a ;\\<^sub>L b)\"", "lemma aext_id [simp]: \"P \\<oplus>\\<^sub>p 1\\<^sub>L = P\"", "lemma aext_lit [simp]: \"\\<guillemotleft>v\\<guillemotright> \\<oplus>\\<^sub>p a = \\<guillemotleft>v\\<guillemotright>\"", "lemma aext_zero [simp]: \"0 \\<oplus>\\<^sub>p a = 0\"", "lemma aext_one [simp]: \"1 \\<oplus>\\<^sub>p a = 1\"", "lemma aext_numeral [simp]: \"numeral n \\<oplus>\\<^sub>p a = numeral n\"", "lemma aext_true [simp]: \"true \\<oplus>\\<^sub>p a = true\"", "lemma aext_false [simp]: \"false \\<oplus>\\<^sub>p a = false\"", "lemma aext_not [alpha]: \"(\\<not> P) \\<oplus>\\<^sub>p x = (\\<not> (P \\<oplus>\\<^sub>p x))\"", "lemma aext_and [alpha]: \"(P \\<and> Q) \\<oplus>\\<^sub>p x = (P \\<oplus>\\<^sub>p x \\<and> Q \\<oplus>\\<^sub>p x)\"", "lemma aext_or [alpha]: \"(P \\<or> Q) \\<oplus>\\<^sub>p x = (P \\<oplus>\\<^sub>p x \\<or> Q \\<oplus>\\<^sub>p x)\"", "lemma aext_imp [alpha]: \"(P \\<Rightarrow> Q) \\<oplus>\\<^sub>p x = (P \\<oplus>\\<^sub>p x \\<Rightarrow> Q \\<oplus>\\<^sub>p x)\"", "lemma aext_iff [alpha]: \"(P \\<Leftrightarrow> Q) \\<oplus>\\<^sub>p x = (P \\<oplus>\\<^sub>p x \\<Leftrightarrow> Q \\<oplus>\\<^sub>p x)\"", "lemma aext_shAll [alpha]: \"(\\<^bold>\\<forall> x \\<bullet> P(x)) \\<oplus>\\<^sub>p a = (\\<^bold>\\<forall> x \\<bullet> P(x) \\<oplus>\\<^sub>p a)\"", "lemma aext_UINF_ind [alpha]: \"(\\<Sqinter> x \\<bullet> P x) \\<oplus>\\<^sub>p a =(\\<Sqinter> x \\<bullet> (P x \\<oplus>\\<^sub>p a))\"", "lemma aext_UINF_mem [alpha]: \"(\\<Sqinter> x\\<in>A \\<bullet> P x) \\<oplus>\\<^sub>p a =(\\<Sqinter> x\\<in>A \\<bullet> (P x \\<oplus>\\<^sub>p a))\"", "lemma aext_uop [alpha]: \"uop f u \\<oplus>\\<^sub>p a = uop f (u \\<oplus>\\<^sub>p a)\"", "lemma aext_bop [alpha]: \"bop f u v \\<oplus>\\<^sub>p a = bop f (u \\<oplus>\\<^sub>p a) (v \\<oplus>\\<^sub>p a)\"", "lemma aext_trop [alpha]: \"trop f u v w \\<oplus>\\<^sub>p a = trop f (u \\<oplus>\\<^sub>p a) (v \\<oplus>\\<^sub>p a) (w \\<oplus>\\<^sub>p a)\"", "lemma aext_qtop [alpha]: \"qtop f u v w x \\<oplus>\\<^sub>p a = qtop f (u \\<oplus>\\<^sub>p a) (v \\<oplus>\\<^sub>p a) (w \\<oplus>\\<^sub>p a) (x \\<oplus>\\<^sub>p a)\"", "lemma aext_plus [alpha]:\n  \"(x + y) \\<oplus>\\<^sub>p a = (x \\<oplus>\\<^sub>p a) + (y \\<oplus>\\<^sub>p a)\"", "lemma aext_minus [alpha]:\n  \"(x - y) \\<oplus>\\<^sub>p a = (x \\<oplus>\\<^sub>p a) - (y \\<oplus>\\<^sub>p a)\"", "lemma aext_uminus [simp]:\n  \"(- x) \\<oplus>\\<^sub>p a = - (x \\<oplus>\\<^sub>p a)\"", "lemma aext_times [alpha]:\n  \"(x * y) \\<oplus>\\<^sub>p a = (x \\<oplus>\\<^sub>p a) * (y \\<oplus>\\<^sub>p a)\"", "lemma aext_divide [alpha]:\n  \"(x / y) \\<oplus>\\<^sub>p a = (x \\<oplus>\\<^sub>p a) / (y \\<oplus>\\<^sub>p a)\"", "lemma aext_var [alpha]:\n  \"var x \\<oplus>\\<^sub>p a = var (x ;\\<^sub>L a)\"", "lemma aext_ulambda [alpha]: \"((\\<lambda> x \\<bullet> P(x)) \\<oplus>\\<^sub>p a) = (\\<lambda> x \\<bullet> P(x) \\<oplus>\\<^sub>p a)\"", "lemma aext_mono: \"P \\<sqsubseteq> Q \\<Longrightarrow> P \\<oplus>\\<^sub>p a \\<sqsubseteq> Q \\<oplus>\\<^sub>p a\"", "lemma aext_cont [alpha]: \"vwb_lens a \\<Longrightarrow> (\\<Sqinter> A) \\<oplus>\\<^sub>p a = (\\<Sqinter> P\\<in>A.  P \\<oplus>\\<^sub>p a)\"", "lemma unrest_aext [unrest]:\n  \"\\<lbrakk> mwb_lens a; x \\<sharp> p \\<rbrakk> \\<Longrightarrow> unrest (x ;\\<^sub>L a) (p \\<oplus>\\<^sub>p a)\"", "lemma unrest_aext_indep [unrest]:\n  \"a \\<bowtie> b \\<Longrightarrow> b \\<sharp> (p \\<oplus>\\<^sub>p a)\"", "lemma arestr_id [simp]: \"P \\<restriction>\\<^sub>e 1\\<^sub>L = P\"", "lemma arestr_aext [simp]: \"mwb_lens a \\<Longrightarrow> (P \\<oplus>\\<^sub>p a) \\<restriction>\\<^sub>e a = P\"", "lemma aext_arestr [alpha]:\n  assumes \"mwb_lens a\" \"bij_lens (a +\\<^sub>L b)\" \"a \\<bowtie> b\" \"b \\<sharp> P\"\n  shows \"(P \\<restriction>\\<^sub>e a) \\<oplus>\\<^sub>p a = P\"", "lemma aext_arestr' [alpha]:\n  assumes \"a \\<natural> P\"\n  shows \"(P \\<restriction>\\<^sub>e a) \\<oplus>\\<^sub>p a = P\"", "lemma arestr_lit [simp]: \"\\<guillemotleft>v\\<guillemotright> \\<restriction>\\<^sub>e a = \\<guillemotleft>v\\<guillemotright>\"", "lemma arestr_zero [simp]: \"0 \\<restriction>\\<^sub>e a = 0\"", "lemma arestr_one [simp]: \"1 \\<restriction>\\<^sub>e a = 1\"", "lemma arestr_numeral [simp]: \"numeral n \\<restriction>\\<^sub>e a = numeral n\"", "lemma arestr_var [alpha]:\n  \"var x \\<restriction>\\<^sub>e a = var (x /\\<^sub>L a)\"", "lemma arestr_true [simp]: \"true \\<restriction>\\<^sub>e a = true\"", "lemma arestr_false [simp]: \"false \\<restriction>\\<^sub>e a = false\"", "lemma arestr_not [alpha]: \"(\\<not> P)\\<restriction>\\<^sub>ea = (\\<not> (P\\<restriction>\\<^sub>ea))\"", "lemma arestr_and [alpha]: \"(P \\<and> Q)\\<restriction>\\<^sub>ex = (P\\<restriction>\\<^sub>ex \\<and> Q\\<restriction>\\<^sub>ex)\"", "lemma arestr_or [alpha]: \"(P \\<or> Q)\\<restriction>\\<^sub>ex = (P\\<restriction>\\<^sub>ex \\<or> Q\\<restriction>\\<^sub>ex)\"", "lemma arestr_imp [alpha]: \"(P \\<Rightarrow> Q)\\<restriction>\\<^sub>ex = (P\\<restriction>\\<^sub>ex \\<Rightarrow> Q\\<restriction>\\<^sub>ex)\"", "lemma upred_aext_ares [alpha]: \n  \"vwb_lens a \\<Longrightarrow> P \\<oplus>\\<^sub>p a \\<restriction>\\<^sub>p a = P\"", "lemma upred_ares_aext [alpha]:\n  \"a \\<natural> P \\<Longrightarrow> (P \\<restriction>\\<^sub>p a) \\<oplus>\\<^sub>p a = P\"", "lemma upred_arestr_lit [simp]: \"\\<guillemotleft>v\\<guillemotright> \\<restriction>\\<^sub>p a = \\<guillemotleft>v\\<guillemotright>\"", "lemma upred_arestr_true [simp]: \"true \\<restriction>\\<^sub>p a = true\"", "lemma upred_arestr_false [simp]: \"false \\<restriction>\\<^sub>p a = false\"", "lemma upred_arestr_or [alpha]: \"(P \\<or> Q)\\<restriction>\\<^sub>px = (P\\<restriction>\\<^sub>px \\<or> Q\\<restriction>\\<^sub>px)\"", "lemma alpha_in_var [alpha]: \"x ;\\<^sub>L fst\\<^sub>L = in_var x\"", "lemma alpha_out_var [alpha]: \"x ;\\<^sub>L snd\\<^sub>L = out_var x\"", "lemma in_var_prod_lens [alpha]:\n  \"wb_lens Y \\<Longrightarrow> in_var x ;\\<^sub>L (X \\<times>\\<^sub>L Y) = in_var (x ;\\<^sub>L X)\"", "lemma out_var_prod_lens [alpha]:\n  \"wb_lens X \\<Longrightarrow> out_var x ;\\<^sub>L (X \\<times>\\<^sub>L Y) = out_var (x ;\\<^sub>L Y)\"", "lemma id_subst_ext [usubst]:\n  \"wb_lens x \\<Longrightarrow> id \\<oplus>\\<^sub>s x = id\"", "lemma upd_subst_ext [alpha]:\n  \"vwb_lens x \\<Longrightarrow> \\<sigma>(y \\<mapsto>\\<^sub>s v) \\<oplus>\\<^sub>s x = (\\<sigma> \\<oplus>\\<^sub>s x)(&x:y \\<mapsto>\\<^sub>s v \\<oplus>\\<^sub>p x)\"", "lemma apply_subst_ext [alpha]:\n  \"vwb_lens x \\<Longrightarrow> (\\<sigma> \\<dagger> e) \\<oplus>\\<^sub>p x = (\\<sigma> \\<oplus>\\<^sub>s x) \\<dagger> (e \\<oplus>\\<^sub>p x)\"", "lemma aext_upred_eq [alpha]:\n  \"((e =\\<^sub>u f) \\<oplus>\\<^sub>p a) = ((e \\<oplus>\\<^sub>p a) =\\<^sub>u (f \\<oplus>\\<^sub>p a))\"", "lemma subst_aext_comp [usubst]:\n  \"vwb_lens a \\<Longrightarrow> (\\<sigma> \\<oplus>\\<^sub>s a) \\<circ> (\\<rho> \\<oplus>\\<^sub>s a) = (\\<sigma> \\<circ> \\<rho>) \\<oplus>\\<^sub>s a\"", "lemma id_subst_res [usubst]:\n  \"mwb_lens x \\<Longrightarrow> id \\<restriction>\\<^sub>s x = id\"", "lemma upd_subst_res [alpha]:\n  \"mwb_lens x \\<Longrightarrow> \\<sigma>(&x:y \\<mapsto>\\<^sub>s v) \\<restriction>\\<^sub>s x = (\\<sigma> \\<restriction>\\<^sub>s x)(&y \\<mapsto>\\<^sub>s v \\<restriction>\\<^sub>e x)\"", "lemma subst_ext_res [usubst]:\n  \"mwb_lens x \\<Longrightarrow> (\\<sigma> \\<oplus>\\<^sub>s x) \\<restriction>\\<^sub>s x = \\<sigma>\"", "lemma unrest_subst_alpha_ext [unrest]:\n  \"x \\<bowtie> y \\<Longrightarrow> x \\<sharp> (P \\<oplus>\\<^sub>s y)\""], "translations": [["", "lemma aext_twice: \"(P \\<oplus>\\<^sub>p a) \\<oplus>\\<^sub>p b = P \\<oplus>\\<^sub>p (a ;\\<^sub>L b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<oplus>\\<^sub>p a) \\<oplus>\\<^sub>p b =\n    P \\<oplus>\\<^sub>p (a ;\\<^sub>L b)", "by (pred_auto)"], ["", "text \\<open> The bijective @{term \"1\\<^sub>L\"} lens identifies the source and view types. Thus an alphabet\n  extension using this has no effect. \\<close>"], ["", "lemma aext_id [simp]: \"P \\<oplus>\\<^sub>p 1\\<^sub>L = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<oplus>\\<^sub>p \\<Sigma> = P", "by (pred_auto)"], ["", "text \\<open> Literals do not depend on any variables, and thus applying an alphabet extension only\n  alters the predicate's type, and not its valuation .\\<close>"], ["", "lemma aext_lit [simp]: \"\\<guillemotleft>v\\<guillemotright> \\<oplus>\\<^sub>p a = \\<guillemotleft>v\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>v\\<guillemotright> \\<oplus>\\<^sub>p a =\n    \\<guillemotleft>v\\<guillemotright>", "by (pred_auto)"], ["", "lemma aext_zero [simp]: \"0 \\<oplus>\\<^sub>p a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<oplus>\\<^sub>p a = 0", "by (pred_auto)"], ["", "lemma aext_one [simp]: \"1 \\<oplus>\\<^sub>p a = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<oplus>\\<^sub>p a = 1", "by (pred_auto)"], ["", "lemma aext_numeral [simp]: \"numeral n \\<oplus>\\<^sub>p a = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n \\<oplus>\\<^sub>p a = numeral n", "by (pred_auto)"], ["", "lemma aext_true [simp]: \"true \\<oplus>\\<^sub>p a = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. true \\<oplus>\\<^sub>p a = true", "by (pred_auto)"], ["", "lemma aext_false [simp]: \"false \\<oplus>\\<^sub>p a = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. false \\<oplus>\\<^sub>p a = false", "by (pred_auto)"], ["", "lemma aext_not [alpha]: \"(\\<not> P) \\<oplus>\\<^sub>p x = (\\<not> (P \\<oplus>\\<^sub>p x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> P) \\<oplus>\\<^sub>p x = (\\<not> P \\<oplus>\\<^sub>p x)", "by (pred_auto)"], ["", "lemma aext_and [alpha]: \"(P \\<and> Q) \\<oplus>\\<^sub>p x = (P \\<oplus>\\<^sub>p x \\<and> Q \\<oplus>\\<^sub>p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> Q) \\<oplus>\\<^sub>p x =\n    (P \\<oplus>\\<^sub>p x \\<and> Q \\<oplus>\\<^sub>p x)", "by (pred_auto)"], ["", "lemma aext_or [alpha]: \"(P \\<or> Q) \\<oplus>\\<^sub>p x = (P \\<oplus>\\<^sub>p x \\<or> Q \\<oplus>\\<^sub>p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q) \\<oplus>\\<^sub>p x =\n    (P \\<oplus>\\<^sub>p x \\<or> Q \\<oplus>\\<^sub>p x)", "by (pred_auto)"], ["", "lemma aext_imp [alpha]: \"(P \\<Rightarrow> Q) \\<oplus>\\<^sub>p x = (P \\<oplus>\\<^sub>p x \\<Rightarrow> Q \\<oplus>\\<^sub>p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Rightarrow> Q) \\<oplus>\\<^sub>p x =\n    (P \\<oplus>\\<^sub>p x \\<Rightarrow> Q \\<oplus>\\<^sub>p x)", "by (pred_auto)"], ["", "lemma aext_iff [alpha]: \"(P \\<Leftrightarrow> Q) \\<oplus>\\<^sub>p x = (P \\<oplus>\\<^sub>p x \\<Leftrightarrow> Q \\<oplus>\\<^sub>p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Leftrightarrow> Q) \\<oplus>\\<^sub>p x =\n    (P \\<oplus>\\<^sub>p x \\<Leftrightarrow> Q \\<oplus>\\<^sub>p x)", "by (pred_auto)"], ["", "lemma aext_shAll [alpha]: \"(\\<^bold>\\<forall> x \\<bullet> P(x)) \\<oplus>\\<^sub>p a = (\\<^bold>\\<forall> x \\<bullet> P(x) \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ushAll P \\<oplus>\\<^sub>p a =\n    (\\<^bold>\\<forall> x \\<bullet> P x \\<oplus>\\<^sub>p a)", "by (pred_auto)"], ["", "lemma aext_UINF_ind [alpha]: \"(\\<Sqinter> x \\<bullet> P x) \\<oplus>\\<^sub>p a =(\\<Sqinter> x \\<bullet> (P x \\<oplus>\\<^sub>p a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> x \\<bullet> P x) \\<oplus>\\<^sub>p a =\n    (\\<Sqinter> x \\<bullet> P x \\<oplus>\\<^sub>p a)", "by (pred_auto)"], ["", "lemma aext_UINF_mem [alpha]: \"(\\<Sqinter> x\\<in>A \\<bullet> P x) \\<oplus>\\<^sub>p a =(\\<Sqinter> x\\<in>A \\<bullet> (P x \\<oplus>\\<^sub>p a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> x \\<in> A \\<bullet> P x) \\<oplus>\\<^sub>p a =\n    (\\<Sqinter> x \\<in> A \\<bullet> P x \\<oplus>\\<^sub>p a)", "by (pred_auto)"], ["", "text \\<open> Alphabet extension distributes through the function liftings. \\<close>"], ["", "lemma aext_uop [alpha]: \"uop f u \\<oplus>\\<^sub>p a = uop f (u \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uop f u \\<oplus>\\<^sub>p a = uop f (u \\<oplus>\\<^sub>p a)", "by (pred_auto)"], ["", "lemma aext_bop [alpha]: \"bop f u v \\<oplus>\\<^sub>p a = bop f (u \\<oplus>\\<^sub>p a) (v \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bop f u v \\<oplus>\\<^sub>p a =\n    bop f (u \\<oplus>\\<^sub>p a) (v \\<oplus>\\<^sub>p a)", "by (pred_auto)"], ["", "lemma aext_trop [alpha]: \"trop f u v w \\<oplus>\\<^sub>p a = trop f (u \\<oplus>\\<^sub>p a) (v \\<oplus>\\<^sub>p a) (w \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trop f u v w \\<oplus>\\<^sub>p a =\n    trop f (u \\<oplus>\\<^sub>p a) (v \\<oplus>\\<^sub>p a)\n     (w \\<oplus>\\<^sub>p a)", "by (pred_auto)"], ["", "lemma aext_qtop [alpha]: \"qtop f u v w x \\<oplus>\\<^sub>p a = qtop f (u \\<oplus>\\<^sub>p a) (v \\<oplus>\\<^sub>p a) (w \\<oplus>\\<^sub>p a) (x \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qtop f u v w x \\<oplus>\\<^sub>p a =\n    qtop f (u \\<oplus>\\<^sub>p a) (v \\<oplus>\\<^sub>p a)\n     (w \\<oplus>\\<^sub>p a) (x \\<oplus>\\<^sub>p a)", "by (pred_auto)"], ["", "lemma aext_plus [alpha]:\n  \"(x + y) \\<oplus>\\<^sub>p a = (x \\<oplus>\\<^sub>p a) + (y \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) \\<oplus>\\<^sub>p a = x \\<oplus>\\<^sub>p a + y \\<oplus>\\<^sub>p a", "by (pred_auto)"], ["", "lemma aext_minus [alpha]:\n  \"(x - y) \\<oplus>\\<^sub>p a = (x \\<oplus>\\<^sub>p a) - (y \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - y) \\<oplus>\\<^sub>p a = x \\<oplus>\\<^sub>p a - y \\<oplus>\\<^sub>p a", "by (pred_auto)"], ["", "lemma aext_uminus [simp]:\n  \"(- x) \\<oplus>\\<^sub>p a = - (x \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- x) \\<oplus>\\<^sub>p a = - x \\<oplus>\\<^sub>p a", "by (pred_auto)"], ["", "lemma aext_times [alpha]:\n  \"(x * y) \\<oplus>\\<^sub>p a = (x \\<oplus>\\<^sub>p a) * (y \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y) \\<oplus>\\<^sub>p a = x \\<oplus>\\<^sub>p a * y \\<oplus>\\<^sub>p a", "by (pred_auto)"], ["", "lemma aext_divide [alpha]:\n  \"(x / y) \\<oplus>\\<^sub>p a = (x \\<oplus>\\<^sub>p a) / (y \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x / y) \\<oplus>\\<^sub>p a = x \\<oplus>\\<^sub>p a / y \\<oplus>\\<^sub>p a", "by (pred_auto)"], ["", "text \\<open> Extending a variable expression over $x$ is equivalent to composing $x$ with the alphabet,\n  thus effectively yielding a variable whose source is the large alphabet. \\<close>"], ["", "lemma aext_var [alpha]:\n  \"var x \\<oplus>\\<^sub>p a = var (x ;\\<^sub>L a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<oplus>\\<^sub>p a = x ;\\<^sub>L a", "by (pred_auto)"], ["", "lemma aext_ulambda [alpha]: \"((\\<lambda> x \\<bullet> P(x)) \\<oplus>\\<^sub>p a) = (\\<lambda> x \\<bullet> P(x) \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ulambda P \\<oplus>\\<^sub>p a =\n    (\\<lambda> x \\<bullet> P x \\<oplus>\\<^sub>p a)", "by (pred_auto)"], ["", "text \\<open> Alphabet extension is monotonic and continuous. \\<close>"], ["", "lemma aext_mono: \"P \\<sqsubseteq> Q \\<Longrightarrow> P \\<oplus>\\<^sub>p a \\<sqsubseteq> Q \\<oplus>\\<^sub>p a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> Q \\<Longrightarrow>\n    P \\<oplus>\\<^sub>p a \\<sqsubseteq> Q \\<oplus>\\<^sub>p a", "by (pred_auto)"], ["", "lemma aext_cont [alpha]: \"vwb_lens a \\<Longrightarrow> (\\<Sqinter> A) \\<oplus>\\<^sub>p a = (\\<Sqinter> P\\<in>A.  P \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens a \\<Longrightarrow>\n    \\<Sqinter>A \\<oplus>\\<^sub>p a =\n    (\\<Sqinter>P\\<in>A. P \\<oplus>\\<^sub>p a)", "by (pred_simp)"], ["", "text \\<open> If a variable is unrestricted in a predicate, then the extended variable is unrestricted\n  in the predicate with an alphabet extension. \\<close>"], ["", "lemma unrest_aext [unrest]:\n  \"\\<lbrakk> mwb_lens a; x \\<sharp> p \\<rbrakk> \\<Longrightarrow> unrest (x ;\\<^sub>L a) (p \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens a; x \\<sharp> p\\<rbrakk>\n    \\<Longrightarrow> x ;\\<^sub>L a \\<sharp> p \\<oplus>\\<^sub>p a", "by (transfer, simp add: lens_comp_def)"], ["", "text \\<open> If a given variable (or alphabet) $b$ is independent of the extension lens $a$, that is, it is\n  outside the original state-space of $p$, then it follows that once $p$ is extended by $a$ then\n  $b$ cannot be restricted. \\<close>"], ["", "lemma unrest_aext_indep [unrest]:\n  \"a \\<bowtie> b \\<Longrightarrow> b \\<sharp> (p \\<oplus>\\<^sub>p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<bowtie> b \\<Longrightarrow> b \\<sharp> p \\<oplus>\\<^sub>p a", "by pred_auto"], ["", "subsection \\<open> Expression Alphabet Restriction \\<close>"], ["", "text \\<open> Restrict an alphabet by application of a lens that demonstrates how the smaller alphabet\n  ($\\beta$) injects into the larger alphabet ($\\alpha$). Unlike extension, this operation\n  can lose information if the expressions refers to variables in the larger alphabet. \\<close>"], ["", "lift_definition arestr :: \"('a, '\\<alpha>) uexpr \\<Rightarrow> ('\\<beta>, '\\<alpha>) lens \\<Rightarrow> ('a, '\\<beta>) uexpr\" (infixr \"\\<restriction>\\<^sub>e\" 90)\nis \"\\<lambda> P x b. P (create\\<^bsub>x\\<^esub> b)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "update_uexpr_rep_eq_thms"], ["", "lemma arestr_id [simp]: \"P \\<restriction>\\<^sub>e 1\\<^sub>L = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<restriction>\\<^sub>e \\<Sigma> = P", "by (pred_auto)"], ["", "lemma arestr_aext [simp]: \"mwb_lens a \\<Longrightarrow> (P \\<oplus>\\<^sub>p a) \\<restriction>\\<^sub>e a = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens a \\<Longrightarrow>\n    P \\<oplus>\\<^sub>p a \\<restriction>\\<^sub>e a = P", "by (pred_auto)"], ["", "text \\<open> If an expression's alphabet can be divided into two disjoint sections and the expression\n  does not depend on the second half then restricting the expression to the first half is\n  loss-less. \\<close>"], ["", "lemma aext_arestr [alpha]:\n  assumes \"mwb_lens a\" \"bij_lens (a +\\<^sub>L b)\" \"a \\<bowtie> b\" \"b \\<sharp> P\"\n  shows \"(P \\<restriction>\\<^sub>e a) \\<oplus>\\<^sub>p a = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<restriction>\\<^sub>e a) \\<oplus>\\<^sub>p a = P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (P \\<restriction>\\<^sub>e a) \\<oplus>\\<^sub>p a = P", "from assms(2)"], ["proof (chain)\npicking this:\n  bij_lens (a +\\<^sub>L b)", "have \"1\\<^sub>L \\<subseteq>\\<^sub>L a +\\<^sub>L b\""], ["proof (prove)\nusing this:\n  bij_lens (a +\\<^sub>L b)\n\ngoal (1 subgoal):\n 1. \\<Sigma> \\<subseteq>\\<^sub>L a +\\<^sub>L b", "by (simp add: bij_lens_equiv_id lens_equiv_def)"], ["proof (state)\nthis:\n  \\<Sigma> \\<subseteq>\\<^sub>L a +\\<^sub>L b\n\ngoal (1 subgoal):\n 1. (P \\<restriction>\\<^sub>e a) \\<oplus>\\<^sub>p a = P", "with assms(1,3,4)"], ["proof (chain)\npicking this:\n  mwb_lens a\n  a \\<bowtie> b\n  b \\<sharp> P\n  \\<Sigma> \\<subseteq>\\<^sub>L a +\\<^sub>L b", "show ?thesis"], ["proof (prove)\nusing this:\n  mwb_lens a\n  a \\<bowtie> b\n  b \\<sharp> P\n  \\<Sigma> \\<subseteq>\\<^sub>L a +\\<^sub>L b\n\ngoal (1 subgoal):\n 1. (P \\<restriction>\\<^sub>e a) \\<oplus>\\<^sub>p a = P", "apply (auto simp add: id_lens_def lens_plus_def sublens_def lens_comp_def prod.case_eq_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z.\n       \\<lbrakk>mwb_lens a; a \\<bowtie> b; b \\<sharp> P; vwb_lens Z;\n        id =\n        get\\<^bsub>Z\\<^esub> \\<circ>\n        (\\<lambda>\\<sigma>.\n            (get\\<^bsub>a\\<^esub> \\<sigma>, get\\<^bsub>b\\<^esub> \\<sigma>));\n        (\\<lambda>_. id) =\n        (\\<lambda>\\<sigma> v.\n            put\\<^bsub>a\\<^esub>\n             (put\\<^bsub>b\\<^esub> \\<sigma>\n               (snd (put\\<^bsub>Z\\<^esub>\n                      (get\\<^bsub>a\\<^esub> \\<sigma>,\n                       get\\<^bsub>b\\<^esub> \\<sigma>)\n                      v)))\n             (fst (put\\<^bsub>Z\\<^esub>\n                    (get\\<^bsub>a\\<^esub> \\<sigma>,\n                     get\\<^bsub>b\\<^esub> \\<sigma>)\n                    v)))\\<rbrakk>\n       \\<Longrightarrow> (P \\<restriction>\\<^sub>e a) \\<oplus>\\<^sub>p a = P", "apply (pred_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z ba.\n       \\<lbrakk>mwb_lens a; a \\<bowtie> b;\n        \\<forall>ba v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (put\\<^bsub>b\\<^esub> ba v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e ba;\n        vwb_lens Z;\n        \\<forall>x.\n           x =\n           get\\<^bsub>Z\\<^esub>\n            (get\\<^bsub>a\\<^esub> x, get\\<^bsub>b\\<^esub> x);\n        \\<forall>x xa.\n           xa =\n           put\\<^bsub>a\\<^esub>\n            (put\\<^bsub>b\\<^esub> x\n              (snd (put\\<^bsub>Z\\<^esub>\n                     (get\\<^bsub>a\\<^esub> x, get\\<^bsub>b\\<^esub> x) xa)))\n            (fst (put\\<^bsub>Z\\<^esub>\n                   (get\\<^bsub>a\\<^esub> x, get\\<^bsub>b\\<^esub> x)\n                   xa))\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                          (put\\<^bsub>a\\<^esub> src\\<^bsub>a\\<^esub>\n                            (get\\<^bsub>a\\<^esub> ba)) =\n                         \\<lbrakk>P\\<rbrakk>\\<^sub>e ba", "apply (metis lens_indep_comm mwb_lens_weak weak_lens.put_get)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (P \\<restriction>\\<^sub>e a) \\<oplus>\\<^sub>p a = P\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Alternative formulation of the above law using used-by instead of unrestriction. \\<close>"], ["", "lemma aext_arestr' [alpha]:\n  assumes \"a \\<natural> P\"\n  shows \"(P \\<restriction>\\<^sub>e a) \\<oplus>\\<^sub>p a = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<restriction>\\<^sub>e a) \\<oplus>\\<^sub>p a = P", "by (rel_simp, metis assms lens_override_def usedBy_uexpr.rep_eq)"], ["", "lemma arestr_lit [simp]: \"\\<guillemotleft>v\\<guillemotright> \\<restriction>\\<^sub>e a = \\<guillemotleft>v\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>v\\<guillemotright> \\<restriction>\\<^sub>e a =\n    \\<guillemotleft>v\\<guillemotright>", "by (pred_auto)"], ["", "lemma arestr_zero [simp]: \"0 \\<restriction>\\<^sub>e a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<restriction>\\<^sub>e a = 0", "by (pred_auto)"], ["", "lemma arestr_one [simp]: \"1 \\<restriction>\\<^sub>e a = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<restriction>\\<^sub>e a = 1", "by (pred_auto)"], ["", "lemma arestr_numeral [simp]: \"numeral n \\<restriction>\\<^sub>e a = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n \\<restriction>\\<^sub>e a = numeral n", "by (pred_auto)"], ["", "lemma arestr_var [alpha]:\n  \"var x \\<restriction>\\<^sub>e a = var (x /\\<^sub>L a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<restriction>\\<^sub>e a = x /\\<^sub>L a", "by (pred_auto)"], ["", "lemma arestr_true [simp]: \"true \\<restriction>\\<^sub>e a = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. true \\<restriction>\\<^sub>e a = true", "by (pred_auto)"], ["", "lemma arestr_false [simp]: \"false \\<restriction>\\<^sub>e a = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. false \\<restriction>\\<^sub>e a = false", "by (pred_auto)"], ["", "lemma arestr_not [alpha]: \"(\\<not> P)\\<restriction>\\<^sub>ea = (\\<not> (P\\<restriction>\\<^sub>ea))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> P) \\<restriction>\\<^sub>e a =\n    (\\<not> P \\<restriction>\\<^sub>e a)", "by (pred_auto)"], ["", "lemma arestr_and [alpha]: \"(P \\<and> Q)\\<restriction>\\<^sub>ex = (P\\<restriction>\\<^sub>ex \\<and> Q\\<restriction>\\<^sub>ex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> Q) \\<restriction>\\<^sub>e x =\n    (P \\<restriction>\\<^sub>e x \\<and> Q \\<restriction>\\<^sub>e x)", "by (pred_auto)"], ["", "lemma arestr_or [alpha]: \"(P \\<or> Q)\\<restriction>\\<^sub>ex = (P\\<restriction>\\<^sub>ex \\<or> Q\\<restriction>\\<^sub>ex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q) \\<restriction>\\<^sub>e x =\n    (P \\<restriction>\\<^sub>e x \\<or> Q \\<restriction>\\<^sub>e x)", "by (pred_auto)"], ["", "lemma arestr_imp [alpha]: \"(P \\<Rightarrow> Q)\\<restriction>\\<^sub>ex = (P\\<restriction>\\<^sub>ex \\<Rightarrow> Q\\<restriction>\\<^sub>ex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Rightarrow> Q) \\<restriction>\\<^sub>e x =\n    (P \\<restriction>\\<^sub>e x \\<Rightarrow> Q \\<restriction>\\<^sub>e x)", "by (pred_auto)"], ["", "subsection \\<open> Predicate Alphabet Restriction \\<close>"], ["", "text \\<open> In order to restrict the variables of a predicate, we also need to existentially quantify\n  away the other variables. We can't do this at the level of expressions, as quantifiers are not\n  applicable here. Consequently, we need a specialised version of alphabet restriction for\n  predicates. It both restricts the variables using quantification and then removes them\n  from the alphabet type using expression restriction. \\<close>"], ["", "definition upred_ares :: \"'\\<alpha> upred \\<Rightarrow> ('\\<beta> \\<Longrightarrow> '\\<alpha>) \\<Rightarrow> '\\<beta> upred\" \nwhere [upred_defs]: \"upred_ares P a = (P \\<restriction>\\<^sub>v a) \\<restriction>\\<^sub>e a\""], ["", "syntax\n  \"_upred_ares\" :: \"logic \\<Rightarrow> salpha \\<Rightarrow> logic\" (infixl \"\\<restriction>\\<^sub>p\" 90)"], ["", "translations\n  \"_upred_ares P a\" == \"CONST upred_ares P a\""], ["", "lemma upred_aext_ares [alpha]: \n  \"vwb_lens a \\<Longrightarrow> P \\<oplus>\\<^sub>p a \\<restriction>\\<^sub>p a = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens a \\<Longrightarrow>\n    P \\<oplus>\\<^sub>p a \\<restriction>\\<^sub>p a = P", "by (pred_auto)"], ["", "lemma upred_ares_aext [alpha]:\n  \"a \\<natural> P \\<Longrightarrow> (P \\<restriction>\\<^sub>p a) \\<oplus>\\<^sub>p a = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<natural> P \\<Longrightarrow>\n    (P \\<restriction>\\<^sub>p a) \\<oplus>\\<^sub>p a = P", "by (pred_auto)"], ["", "lemma upred_arestr_lit [simp]: \"\\<guillemotleft>v\\<guillemotright> \\<restriction>\\<^sub>p a = \\<guillemotleft>v\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>v\\<guillemotright> \\<restriction>\\<^sub>p a =\n    \\<guillemotleft>v\\<guillemotright>", "by (pred_auto)"], ["", "lemma upred_arestr_true [simp]: \"true \\<restriction>\\<^sub>p a = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. true \\<restriction>\\<^sub>p a = true", "by (pred_auto)"], ["", "lemma upred_arestr_false [simp]: \"false \\<restriction>\\<^sub>p a = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. false \\<restriction>\\<^sub>p a = false", "by (pred_auto)"], ["", "lemma upred_arestr_or [alpha]: \"(P \\<or> Q)\\<restriction>\\<^sub>px = (P\\<restriction>\\<^sub>px \\<or> Q\\<restriction>\\<^sub>px)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q) \\<restriction>\\<^sub>p x =\n    (P \\<restriction>\\<^sub>p x \\<or> Q \\<restriction>\\<^sub>p x)", "by (pred_auto)"], ["", "subsection \\<open> Alphabet Lens Laws \\<close>"], ["", "lemma alpha_in_var [alpha]: \"x ;\\<^sub>L fst\\<^sub>L = in_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ;\\<^sub>L fst\\<^sub>L = $x", "by (simp add: in_var_def)"], ["", "lemma alpha_out_var [alpha]: \"x ;\\<^sub>L snd\\<^sub>L = out_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ;\\<^sub>L snd\\<^sub>L = $x\\<acute>", "by (simp add: out_var_def)"], ["", "lemma in_var_prod_lens [alpha]:\n  \"wb_lens Y \\<Longrightarrow> in_var x ;\\<^sub>L (X \\<times>\\<^sub>L Y) = in_var (x ;\\<^sub>L X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens Y \\<Longrightarrow> $x ;\\<^sub>L X \\<times> Y = $X:x", "by (simp add: in_var_def prod_as_plus lens_comp_assoc[THEN sym] fst_lens_plus)"], ["", "lemma out_var_prod_lens [alpha]:\n  \"wb_lens X \\<Longrightarrow> out_var x ;\\<^sub>L (X \\<times>\\<^sub>L Y) = out_var (x ;\\<^sub>L Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens X \\<Longrightarrow>\n    $x\\<acute> ;\\<^sub>L X \\<times> Y = $Y:x\\<acute>", "apply (simp add: out_var_def prod_as_plus lens_comp_assoc[THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens X \\<Longrightarrow>\n    x ;\\<^sub>L\n    (snd\\<^sub>L ;\\<^sub>L\n     (X ;\\<^sub>L fst\\<^sub>L +\\<^sub>L Y ;\\<^sub>L snd\\<^sub>L)) =\n    x ;\\<^sub>L (Y ;\\<^sub>L snd\\<^sub>L)", "apply (subst snd_lens_plus)"], ["proof (prove)\ngoal (3 subgoals):\n 1. wb_lens X \\<Longrightarrow> wb_lens (X ;\\<^sub>L fst\\<^sub>L)\n 2. wb_lens X \\<Longrightarrow>\n    X ;\\<^sub>L fst\\<^sub>L \\<bowtie> Y ;\\<^sub>L snd\\<^sub>L\n 3. wb_lens X \\<Longrightarrow>\n    x ;\\<^sub>L (Y ;\\<^sub>L snd\\<^sub>L) =\n    x ;\\<^sub>L (Y ;\\<^sub>L snd\\<^sub>L)", "using comp_wb_lens fst_vwb_lens vwb_lens_wb"], ["proof (prove)\nusing this:\n  \\<lbrakk>wb_lens ?x; wb_lens ?y\\<rbrakk>\n  \\<Longrightarrow> wb_lens (?x ;\\<^sub>L ?y)\n  vwb_lens fst\\<^sub>L\n  vwb_lens ?x \\<Longrightarrow> wb_lens ?x\n\ngoal (3 subgoals):\n 1. wb_lens X \\<Longrightarrow> wb_lens (X ;\\<^sub>L fst\\<^sub>L)\n 2. wb_lens X \\<Longrightarrow>\n    X ;\\<^sub>L fst\\<^sub>L \\<bowtie> Y ;\\<^sub>L snd\\<^sub>L\n 3. wb_lens X \\<Longrightarrow>\n    x ;\\<^sub>L (Y ;\\<^sub>L snd\\<^sub>L) =\n    x ;\\<^sub>L (Y ;\\<^sub>L snd\\<^sub>L)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. wb_lens X \\<Longrightarrow>\n    X ;\\<^sub>L fst\\<^sub>L \\<bowtie> Y ;\\<^sub>L snd\\<^sub>L\n 2. wb_lens X \\<Longrightarrow>\n    x ;\\<^sub>L (Y ;\\<^sub>L snd\\<^sub>L) =\n    x ;\\<^sub>L (Y ;\\<^sub>L snd\\<^sub>L)", "apply (simp add: alpha_in_var alpha_out_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens X \\<Longrightarrow>\n    x ;\\<^sub>L (Y ;\\<^sub>L snd\\<^sub>L) =\n    x ;\\<^sub>L (Y ;\\<^sub>L snd\\<^sub>L)", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open> Substitution Alphabet Extension \\<close>"], ["", "text \\<open> This allows us to extend the alphabet of a substitution, in a similar way to expressions. \\<close>"], ["", "definition subst_ext :: \"'\\<alpha> usubst \\<Rightarrow> ('\\<alpha> \\<Longrightarrow> '\\<beta>) \\<Rightarrow> '\\<beta> usubst\" (infix \"\\<oplus>\\<^sub>s\" 65) where\n[upred_defs]: \"\\<sigma> \\<oplus>\\<^sub>s x = (\\<lambda> s. put\\<^bsub>x\\<^esub> s (\\<sigma> (get\\<^bsub>x\\<^esub> s)))\""], ["", "lemma id_subst_ext [usubst]:\n  \"wb_lens x \\<Longrightarrow> id \\<oplus>\\<^sub>s x = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens x \\<Longrightarrow> id \\<oplus>\\<^sub>s x = id", "by pred_auto"], ["", "lemma upd_subst_ext [alpha]:\n  \"vwb_lens x \\<Longrightarrow> \\<sigma>(y \\<mapsto>\\<^sub>s v) \\<oplus>\\<^sub>s x = (\\<sigma> \\<oplus>\\<^sub>s x)(&x:y \\<mapsto>\\<^sub>s v \\<oplus>\\<^sub>p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow>\n    \\<sigma>(y \\<mapsto>\\<^sub>s v) \\<oplus>\\<^sub>s x =\n    (\\<sigma> \\<oplus>\\<^sub>s x)(&x:y \\<mapsto>\\<^sub>s\n    v \\<oplus>\\<^sub>p x)", "by pred_auto"], ["", "lemma apply_subst_ext [alpha]:\n  \"vwb_lens x \\<Longrightarrow> (\\<sigma> \\<dagger> e) \\<oplus>\\<^sub>p x = (\\<sigma> \\<oplus>\\<^sub>s x) \\<dagger> (e \\<oplus>\\<^sub>p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow>\n    (\\<sigma> \\<dagger> e) \\<oplus>\\<^sub>p x =\n    (\\<sigma> \\<oplus>\\<^sub>s x) \\<dagger> e \\<oplus>\\<^sub>p x", "by (pred_auto)"], ["", "lemma aext_upred_eq [alpha]:\n  \"((e =\\<^sub>u f) \\<oplus>\\<^sub>p a) = ((e \\<oplus>\\<^sub>p a) =\\<^sub>u (f \\<oplus>\\<^sub>p a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e =\\<^sub>u f) \\<oplus>\\<^sub>p a =\n    (e \\<oplus>\\<^sub>p a =\\<^sub>u f \\<oplus>\\<^sub>p a)", "by (pred_auto)"], ["", "lemma subst_aext_comp [usubst]:\n  \"vwb_lens a \\<Longrightarrow> (\\<sigma> \\<oplus>\\<^sub>s a) \\<circ> (\\<rho> \\<oplus>\\<^sub>s a) = (\\<sigma> \\<circ> \\<rho>) \\<oplus>\\<^sub>s a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens a \\<Longrightarrow>\n    \\<sigma> \\<oplus>\\<^sub>s a \\<circ> \\<rho> \\<oplus>\\<^sub>s a =\n    (\\<sigma> \\<circ> \\<rho>) \\<oplus>\\<^sub>s a", "by pred_auto"], ["", "subsection \\<open> Substitution Alphabet Restriction \\<close>"], ["", "text \\<open> This allows us to reduce the alphabet of a substitution, in a similar way to expressions. \\<close>"], ["", "definition subst_res :: \"'\\<alpha> usubst \\<Rightarrow> ('\\<beta> \\<Longrightarrow> '\\<alpha>) \\<Rightarrow> '\\<beta> usubst\" (infix \"\\<restriction>\\<^sub>s\" 65) where\n[upred_defs]: \"\\<sigma> \\<restriction>\\<^sub>s x = (\\<lambda> s. get\\<^bsub>x\\<^esub> (\\<sigma> (create\\<^bsub>x\\<^esub> s)))\""], ["", "lemma id_subst_res [usubst]:\n  \"mwb_lens x \\<Longrightarrow> id \\<restriction>\\<^sub>s x = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow> id \\<restriction>\\<^sub>s x = id", "by pred_auto"], ["", "lemma upd_subst_res [alpha]:\n  \"mwb_lens x \\<Longrightarrow> \\<sigma>(&x:y \\<mapsto>\\<^sub>s v) \\<restriction>\\<^sub>s x = (\\<sigma> \\<restriction>\\<^sub>s x)(&y \\<mapsto>\\<^sub>s v \\<restriction>\\<^sub>e x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow>\n    \\<sigma>(&x:y \\<mapsto>\\<^sub>s v) \\<restriction>\\<^sub>s x =\n    (\\<sigma> \\<restriction>\\<^sub>s x)(&y \\<mapsto>\\<^sub>s\n    v \\<restriction>\\<^sub>e x)", "by (pred_auto)"], ["", "lemma subst_ext_res [usubst]:\n  \"mwb_lens x \\<Longrightarrow> (\\<sigma> \\<oplus>\\<^sub>s x) \\<restriction>\\<^sub>s x = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow>\n    (\\<sigma> \\<oplus>\\<^sub>s x) \\<restriction>\\<^sub>s x = \\<sigma>", "by (pred_auto)"], ["", "lemma unrest_subst_alpha_ext [unrest]:\n  \"x \\<bowtie> y \\<Longrightarrow> x \\<sharp> (P \\<oplus>\\<^sub>s y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bowtie> y \\<Longrightarrow> x \\<sharp> P \\<oplus>\\<^sub>s y", "by (pred_simp robust, metis lens_indep_def)"], ["", "end"]]}