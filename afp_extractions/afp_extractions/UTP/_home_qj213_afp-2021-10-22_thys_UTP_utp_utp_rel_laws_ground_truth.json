{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/utp/utp_rel_laws.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["lemma comp_cond_left_distr:\n  \"((P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) ;; R) = ((P ;; R) \\<triangleleft> b \\<triangleright>\\<^sub>r (Q ;; R))\"", "lemma cond_seq_left_distr:\n  \"out\\<alpha> \\<sharp> b \\<Longrightarrow> ((P \\<triangleleft> b \\<triangleright> Q) ;; R) = ((P ;; R) \\<triangleleft> b \\<triangleright> (Q ;; R))\"", "lemma cond_seq_right_distr:\n  \"in\\<alpha> \\<sharp> b \\<Longrightarrow> (P ;; (Q \\<triangleleft> b \\<triangleright> R)) = ((P ;; Q) \\<triangleleft> b \\<triangleright> (P ;; R))\"", "lemma rcond_rassume_expand: \"P \\<triangleleft> b \\<triangleright>\\<^sub>r Q = ([b]\\<^sup>\\<top> ;; P) \\<sqinter> ([(\\<not> b)]\\<^sup>\\<top> ;; Q)\"", "theorem precond_equiv:\n  \"P = (P ;; true) \\<longleftrightarrow> (out\\<alpha> \\<sharp> P)\"", "theorem postcond_equiv:\n  \"P = (true ;; P) \\<longleftrightarrow> (in\\<alpha> \\<sharp> P)\"", "lemma precond_right_unit: \"out\\<alpha> \\<sharp> p \\<Longrightarrow> (p ;; true) = p\"", "lemma postcond_left_unit: \"in\\<alpha> \\<sharp> p \\<Longrightarrow> (true ;; p) = p\"", "theorem precond_left_zero:\n  assumes \"out\\<alpha> \\<sharp> p\" \"p \\<noteq> false\"\n  shows \"(true ;; p) = true\"", "theorem feasibile_iff_true_right_zero:\n  \"P ;; true = true \\<longleftrightarrow> `\\<exists> out\\<alpha> \\<bullet> P`\"", "lemma seqr_assoc: \"(P ;; Q) ;; R = P ;; (Q ;; R)\"", "lemma seqr_left_unit [simp]:\n  \"II ;; P = P\"", "lemma seqr_right_unit [simp]:\n  \"P ;; II = P\"", "lemma seqr_left_zero [simp]:\n  \"false ;; P = false\"", "lemma seqr_right_zero [simp]:\n  \"P ;; false = false\"", "lemma impl_seqr_mono: \"\\<lbrakk> `P \\<Rightarrow> Q`; `R \\<Rightarrow> S` \\<rbrakk> \\<Longrightarrow> `(P ;; R) \\<Rightarrow> (Q ;; S)`\"", "lemma seqr_mono:\n  \"\\<lbrakk> P\\<^sub>1 \\<sqsubseteq> P\\<^sub>2; Q\\<^sub>1 \\<sqsubseteq> Q\\<^sub>2 \\<rbrakk> \\<Longrightarrow> (P\\<^sub>1 ;; Q\\<^sub>1) \\<sqsubseteq> (P\\<^sub>2 ;; Q\\<^sub>2)\"", "lemma seqr_monotonic:\n  \"\\<lbrakk> mono P; mono Q \\<rbrakk> \\<Longrightarrow> mono (\\<lambda> X. P X ;; Q X)\"", "lemma Monotonic_seqr_tail [closure]:\n  assumes \"Monotonic F\"\n  shows \"Monotonic (\\<lambda> X. P ;; F(X))\"", "lemma seqr_exists_left:\n  \"((\\<exists> $x \\<bullet> P) ;; Q) = (\\<exists> $x \\<bullet> (P ;; Q))\"", "lemma seqr_exists_right:\n  \"(P ;; (\\<exists> $x\\<acute> \\<bullet> Q)) = (\\<exists> $x\\<acute> \\<bullet> (P ;; Q))\"", "lemma seqr_or_distl:\n  \"((P \\<or> Q) ;; R) = ((P ;; R) \\<or> (Q ;; R))\"", "lemma seqr_or_distr:\n  \"(P ;; (Q \\<or> R)) = ((P ;; Q) \\<or> (P ;; R))\"", "lemma seqr_inf_distl:\n  \"((P \\<sqinter> Q) ;; R) = ((P ;; R) \\<sqinter> (Q ;; R))\"", "lemma seqr_inf_distr:\n  \"(P ;; (Q \\<sqinter> R)) = ((P ;; Q) \\<sqinter> (P ;; R))\"", "lemma seqr_and_distr_ufunc:\n  \"ufunctional P \\<Longrightarrow> (P ;; (Q \\<and> R)) = ((P ;; Q) \\<and> (P ;; R))\"", "lemma seqr_and_distl_uinj:\n  \"uinj R \\<Longrightarrow> ((P \\<and> Q) ;; R) = ((P ;; R) \\<and> (Q ;; R))\"", "lemma seqr_unfold:\n  \"(P ;; Q) = (\\<^bold>\\<exists> v \\<bullet> P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$\\<^bold>v\\<acute>\\<rbrakk> \\<and> Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$\\<^bold>v\\<rbrakk>)\"", "lemma seqr_middle:\n  assumes \"vwb_lens x\"\n  shows \"(P ;; Q) = (\\<^bold>\\<exists> v \\<bullet> P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<rbrakk>)\"", "lemma seqr_left_one_point:\n  assumes \"vwb_lens x\"\n  shows \"((P \\<and> $x\\<acute> =\\<^sub>u \\<guillemotleft>v\\<guillemotright>) ;; Q) = (P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<rbrakk>)\"", "lemma seqr_right_one_point:\n  assumes \"vwb_lens x\"\n  shows \"(P ;; ($x =\\<^sub>u \\<guillemotleft>v\\<guillemotright> \\<and> Q)) = (P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<rbrakk>)\"", "lemma seqr_left_one_point_true:\n  assumes \"vwb_lens x\"\n  shows \"((P \\<and> $x\\<acute>) ;; Q) = (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>true/$x\\<rbrakk>)\"", "lemma seqr_left_one_point_false:\n  assumes \"vwb_lens x\"\n  shows \"((P \\<and> \\<not>$x\\<acute>) ;; Q) = (P\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>false/$x\\<rbrakk>)\"", "lemma seqr_right_one_point_true:\n  assumes \"vwb_lens x\"\n  shows \"(P ;; ($x \\<and> Q)) = (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>true/$x\\<rbrakk>)\"", "lemma seqr_right_one_point_false:\n  assumes \"vwb_lens x\"\n  shows \"(P ;; (\\<not>$x \\<and> Q)) = (P\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>false/$x\\<rbrakk>)\"", "lemma seqr_insert_ident_left:\n  assumes \"vwb_lens x\" \"$x\\<acute> \\<sharp> P\" \"$x \\<sharp> Q\"\n  shows \"(($x\\<acute> =\\<^sub>u $x \\<and> P) ;; Q) = (P ;; Q)\"", "lemma seqr_insert_ident_right:\n  assumes \"vwb_lens x\" \"$x\\<acute> \\<sharp> P\" \"$x \\<sharp> Q\"\n  shows \"(P ;; ($x\\<acute> =\\<^sub>u $x \\<and> Q)) = (P ;; Q)\"", "lemma seq_var_ident_lift:\n  assumes \"vwb_lens x\" \"$x\\<acute> \\<sharp> P\" \"$x \\<sharp> Q\"\n  shows \"(($x\\<acute> =\\<^sub>u $x \\<and> P) ;; ($x\\<acute> =\\<^sub>u $x \\<and> Q)) = ($x\\<acute> =\\<^sub>u $x \\<and> (P ;; Q))\"", "lemma seqr_bool_split:\n  assumes \"vwb_lens x\"\n  shows \"P ;; Q = (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>true/$x\\<rbrakk> \\<or> P\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>false/$x\\<rbrakk>)\"", "lemma cond_inter_var_split:\n  assumes \"vwb_lens x\"\n  shows \"(P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R = (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or> Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)\"", "theorem seqr_pre_transfer: \"in\\<alpha> \\<sharp> q \\<Longrightarrow> ((P \\<and> q) ;; R) = (P ;; (q\\<^sup>- \\<and> R))\"", "theorem seqr_pre_transfer':\n  \"((P \\<and> \\<lceil>q\\<rceil>\\<^sub>>) ;; R) = (P ;; (\\<lceil>q\\<rceil>\\<^sub>< \\<and> R))\"", "theorem seqr_post_out: \"in\\<alpha> \\<sharp> r \\<Longrightarrow> (P ;; (Q \\<and> r)) = ((P ;; Q) \\<and> r)\"", "lemma seqr_post_var_out:\n  fixes x :: \"(bool \\<Longrightarrow> '\\<alpha>)\"\n  shows \"(P ;; (Q \\<and> $x\\<acute>)) = ((P ;; Q) \\<and> $x\\<acute>)\"", "theorem seqr_post_transfer: \"out\\<alpha> \\<sharp> q \\<Longrightarrow> (P ;; (q \\<and> R)) = ((P \\<and> q\\<^sup>-) ;; R)\"", "lemma seqr_pre_out: \"out\\<alpha> \\<sharp> p \\<Longrightarrow> ((p \\<and> Q) ;; R) = (p \\<and> (Q ;; R))\"", "lemma seqr_pre_var_out:\n  fixes x :: \"(bool \\<Longrightarrow> '\\<alpha>)\"\n  shows \"(($x \\<and> P) ;; Q) = ($x \\<and> (P ;; Q))\"", "lemma seqr_true_lemma:\n  \"(P = (\\<not> ((\\<not> P) ;; true))) = (P = (P ;; true))\"", "lemma seqr_to_conj: \"\\<lbrakk> out\\<alpha> \\<sharp> P; in\\<alpha> \\<sharp> Q \\<rbrakk> \\<Longrightarrow> (P ;; Q) = (P \\<and> Q)\"", "lemma shEx_lift_seq_1 [uquant_lift]:\n  \"((\\<^bold>\\<exists> x \\<bullet> P x) ;; Q) = (\\<^bold>\\<exists> x \\<bullet> (P x ;; Q))\"", "lemma shEx_mem_lift_seq_1 [uquant_lift]:\n  assumes \"out\\<alpha> \\<sharp> A\"\n  shows \"((\\<^bold>\\<exists> x \\<in> A \\<bullet> P x) ;; Q) = (\\<^bold>\\<exists> x \\<in> A \\<bullet> (P x ;; Q))\"", "lemma shEx_lift_seq_2 [uquant_lift]:\n  \"(P ;; (\\<^bold>\\<exists> x \\<bullet> Q x)) = (\\<^bold>\\<exists> x \\<bullet> (P ;; Q x))\"", "lemma shEx_mem_lift_seq_2 [uquant_lift]:\n  assumes \"in\\<alpha> \\<sharp> A\"\n  shows \"(P ;; (\\<^bold>\\<exists> x \\<in> A \\<bullet> Q x)) = (\\<^bold>\\<exists> x \\<in> A \\<bullet> (P ;; Q x))\"", "lemma iter_seqr_nil [simp]: \"(;; i : [] \\<bullet> P(i)) = II\"", "lemma iter_seqr_cons [simp]: \"(;; i : (x # xs) \\<bullet> P(i)) = P(x) ;; (;; i : xs \\<bullet> P(i))\"", "lemma seq_Sup_distl: \"P ;; (\\<Sqinter> A) = (\\<Sqinter> Q\\<in>A. P ;; Q)\"", "lemma seq_Sup_distr: \"(\\<Sqinter> A) ;; Q = (\\<Sqinter> P\\<in>A. P ;; Q)\"", "lemma seq_UINF_distl: \"P ;; (\\<Sqinter> Q\\<in>A \\<bullet> F(Q)) = (\\<Sqinter> Q\\<in>A \\<bullet> P ;; F(Q))\"", "lemma seq_UINF_distl': \"P ;; (\\<Sqinter> Q \\<bullet> F(Q)) = (\\<Sqinter> Q \\<bullet> P ;; F(Q))\"", "lemma seq_UINF_distr: \"(\\<Sqinter> P\\<in>A \\<bullet> F(P)) ;; Q = (\\<Sqinter> P\\<in>A \\<bullet> F(P) ;; Q)\"", "lemma seq_UINF_distr': \"(\\<Sqinter> P \\<bullet> F(P)) ;; Q = (\\<Sqinter> P \\<bullet> F(P) ;; Q)\"", "lemma seq_SUP_distl: \"P ;; (\\<Sqinter>i\\<in>A. Q(i)) = (\\<Sqinter>i\\<in>A. P ;; Q(i))\"", "lemma seq_SUP_distr: \"(\\<Sqinter>i\\<in>A. P(i)) ;; Q = (\\<Sqinter>i\\<in>A. P(i) ;; Q)\"", "lemma cond_skip: \"out\\<alpha> \\<sharp> b \\<Longrightarrow> (b \\<and> II) = (II \\<and> b\\<^sup>-)\"", "lemma pre_skip_post: \"(\\<lceil>b\\<rceil>\\<^sub>< \\<and> II) = (II \\<and> \\<lceil>b\\<rceil>\\<^sub>>)\"", "lemma skip_var:\n  fixes x :: \"(bool \\<Longrightarrow> '\\<alpha>)\"\n  shows \"($x \\<and> II) = (II \\<and> $x\\<acute>)\"", "lemma skip_r_unfold:\n  \"vwb_lens x \\<Longrightarrow> II = ($x\\<acute> =\\<^sub>u $x \\<and> II\\<restriction>\\<^sub>\\<alpha>x)\"", "lemma skip_r_alpha_eq:\n  \"II = ($\\<^bold>v\\<acute> =\\<^sub>u $\\<^bold>v)\"", "lemma skip_ra_unfold:\n  \"II\\<^bsub>x;y\\<^esub> = ($x\\<acute> =\\<^sub>u $x \\<and> II\\<^bsub>y\\<^esub>)\"", "lemma skip_res_as_ra:\n  \"\\<lbrakk> vwb_lens y; x +\\<^sub>L y \\<approx>\\<^sub>L 1\\<^sub>L; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> II\\<restriction>\\<^sub>\\<alpha>x = II\\<^bsub>y\\<^esub>\"", "lemma assigns_subst [usubst]:\n  \"\\<lceil>\\<sigma>\\<rceil>\\<^sub>s \\<dagger> \\<langle>\\<rho>\\<rangle>\\<^sub>a = \\<langle>\\<rho> \\<circ> \\<sigma>\\<rangle>\\<^sub>a\"", "lemma assigns_r_comp: \"(\\<langle>\\<sigma>\\<rangle>\\<^sub>a ;; P) = (\\<lceil>\\<sigma>\\<rceil>\\<^sub>s \\<dagger> P)\"", "lemma assigns_r_feasible:\n  \"(\\<langle>\\<sigma>\\<rangle>\\<^sub>a ;; true) = true\"", "lemma assign_subst [usubst]:\n  \"\\<lbrakk> mwb_lens x; mwb_lens y \\<rbrakk> \\<Longrightarrow> [$x \\<mapsto>\\<^sub>s \\<lceil>u\\<rceil>\\<^sub><] \\<dagger> (y := v) = (x, y) := (u, [x \\<mapsto>\\<^sub>s u] \\<dagger> v)\"", "lemma assign_vacuous_skip:\n  assumes \"vwb_lens x\"\n  shows \"(x := &x) = II\"", "lemma assign_vacuous_assume:\n  assumes \"mwb_lens x\"\n  shows \"[(&\\<^bold>v \\<in>\\<^sub>u \\<guillemotleft>\\<S>\\<^bsub>x\\<^esub>\\<guillemotright>)]\\<^sup>\\<top> ;; (x := &x) = [(&\\<^bold>v \\<in>\\<^sub>u \\<guillemotleft>\\<S>\\<^bsub>x\\<^esub>\\<guillemotright>)]\\<^sup>\\<top>\"", "lemma assign_simultaneous:\n  assumes \"vwb_lens y\" \"x \\<bowtie> y\"\n  shows \"(x,y) := (e, &y) = (x := e)\"", "lemma assigns_idem: \"mwb_lens x \\<Longrightarrow> (x,x) := (u,v) = (x := v)\"", "lemma assigns_comp: \"(\\<langle>f\\<rangle>\\<^sub>a ;; \\<langle>g\\<rangle>\\<^sub>a) = \\<langle>g \\<circ> f\\<rangle>\\<^sub>a\"", "lemma assigns_cond: \"(\\<langle>f\\<rangle>\\<^sub>a \\<triangleleft> b \\<triangleright>\\<^sub>r \\<langle>g\\<rangle>\\<^sub>a) = \\<langle>f \\<triangleleft> b \\<triangleright>\\<^sub>s g\\<rangle>\\<^sub>a\"", "lemma assigns_r_conv:\n  \"bij f \\<Longrightarrow> \\<langle>f\\<rangle>\\<^sub>a\\<^sup>- = \\<langle>inv f\\<rangle>\\<^sub>a\"", "lemma assign_pred_transfer:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"$x \\<sharp> b\" \"out\\<alpha> \\<sharp> b\"\n  shows \"(b \\<and> x := v) = (x := v \\<and> b\\<^sup>-)\"", "lemma assign_r_comp: \"x := u ;; P = P\\<lbrakk>\\<lceil>u\\<rceil>\\<^sub></$x\\<rbrakk>\"", "lemma assign_test: \"mwb_lens x \\<Longrightarrow> (x := \\<guillemotleft>u\\<guillemotright> ;; x := \\<guillemotleft>v\\<guillemotright>) = (x := \\<guillemotleft>v\\<guillemotright>)\"", "lemma assign_twice: \"\\<lbrakk> mwb_lens x; x \\<sharp> f \\<rbrakk> \\<Longrightarrow> (x := e ;; x := f) = (x := f)\"", "lemma assign_commute:\n  assumes \"x \\<bowtie> y\" \"x \\<sharp> f\" \"y \\<sharp> e\"\n  shows \"(x := e ;; y := f) = (y := f ;; x := e)\"", "lemma assign_cond:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"out\\<alpha> \\<sharp> b\"\n  shows \"(x := e ;; (P \\<triangleleft> b \\<triangleright> Q)) = ((x := e ;; P) \\<triangleleft> (b\\<lbrakk>\\<lceil>e\\<rceil>\\<^sub></$x\\<rbrakk>) \\<triangleright> (x := e ;; Q))\"", "lemma assign_rcond:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"(x := e ;; (P \\<triangleleft> b \\<triangleright>\\<^sub>r Q)) = ((x := e ;; P) \\<triangleleft> (b\\<lbrakk>e/x\\<rbrakk>) \\<triangleright>\\<^sub>r (x := e ;; Q))\"", "lemma assign_r_alt_def:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"x := v = II\\<lbrakk>\\<lceil>v\\<rceil>\\<^sub></$x\\<rbrakk>\"", "lemma assigns_r_ufunc: \"ufunctional \\<langle>f\\<rangle>\\<^sub>a\"", "lemma assigns_r_uinj: \"inj f \\<Longrightarrow> uinj \\<langle>f\\<rangle>\\<^sub>a\"", "lemma assigns_r_swap_uinj:\n  \"\\<lbrakk> vwb_lens x; vwb_lens y; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> uinj ((x,y) := (&y,&x))\"", "lemma assign_unfold:\n  \"vwb_lens x \\<Longrightarrow> (x := v) = ($x\\<acute> =\\<^sub>u \\<lceil>v\\<rceil>\\<^sub>< \\<and> II\\<restriction>\\<^sub>\\<alpha>x)\"", "lemma nd_assign_comp:\n  \"x \\<bowtie> y \\<Longrightarrow> x := * ;; y := * = x,y := *\"", "lemma nd_assign_assign:\n  \"\\<lbrakk> vwb_lens x; x \\<sharp> e \\<rbrakk> \\<Longrightarrow> x := * ;; x := e = x := e\"", "lemma convr_invol [simp]: \"p\\<^sup>-\\<^sup>- = p\"", "lemma lit_convr [simp]: \"\\<guillemotleft>v\\<guillemotright>\\<^sup>- = \\<guillemotleft>v\\<guillemotright>\"", "lemma uivar_convr [simp]:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"($x)\\<^sup>- = $x\\<acute>\"", "lemma uovar_convr [simp]:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"($x\\<acute>)\\<^sup>- = $x\"", "lemma uop_convr [simp]: \"(uop f u)\\<^sup>- = uop f (u\\<^sup>-)\"", "lemma bop_convr [simp]: \"(bop f u v)\\<^sup>- = bop f (u\\<^sup>-) (v\\<^sup>-)\"", "lemma eq_convr [simp]: \"(p =\\<^sub>u q)\\<^sup>- = (p\\<^sup>- =\\<^sub>u q\\<^sup>-)\"", "lemma not_convr [simp]: \"(\\<not> p)\\<^sup>- = (\\<not> p\\<^sup>-)\"", "lemma disj_convr [simp]: \"(p \\<or> q)\\<^sup>- = (q\\<^sup>- \\<or> p\\<^sup>-)\"", "lemma conj_convr [simp]: \"(p \\<and> q)\\<^sup>- = (q\\<^sup>- \\<and> p\\<^sup>-)\"", "lemma seqr_convr [simp]: \"(p ;; q)\\<^sup>- = (q\\<^sup>- ;; p\\<^sup>-)\"", "lemma pre_convr [simp]: \"\\<lceil>p\\<rceil>\\<^sub><\\<^sup>- = \\<lceil>p\\<rceil>\\<^sub>>\"", "lemma post_convr [simp]: \"\\<lceil>p\\<rceil>\\<^sub>>\\<^sup>- = \\<lceil>p\\<rceil>\\<^sub><\"", "lemma assume_false: \"[false]\\<^sup>\\<top> = false\"", "lemma assume_true: \"[true]\\<^sup>\\<top> = II\"", "lemma assume_seq: \"[b]\\<^sup>\\<top> ;; [c]\\<^sup>\\<top> = [(b \\<and> c)]\\<^sup>\\<top>\"", "lemma assert_false: \"{false}\\<^sub>\\<bottom> = true\"", "lemma assert_true: \"{true}\\<^sub>\\<bottom> = II\"", "lemma assert_seq: \"{b}\\<^sub>\\<bottom> ;; {c}\\<^sub>\\<bottom> = {(b \\<and> c)}\\<^sub>\\<bottom>\"", "lemma frame_all [frame]: \"\\<Sigma>:[P] = P\"", "lemma frame_none [frame]: \n  \"\\<emptyset>:[P] = (P \\<and> II)\"", "lemma frame_commute:\n  assumes \"$y \\<sharp> P\" \"$y\\<acute> \\<sharp> P\" \"$x \\<sharp> Q\" \"$x\\<acute> \\<sharp> Q\" \"x \\<bowtie> y\" \n  shows \"x:[P] ;; y:[Q] = y:[Q] ;; x:[P]\"", "lemma frame_contract_RID:\n  assumes \"vwb_lens x\" \"P is RID(x)\" \"x \\<bowtie> y\"\n  shows \"(x;y):[P] = y:[P]\"", "lemma frame_miracle [simp]:\n  \"x:[false] = false\"", "lemma frame_skip [simp]:\n  \"vwb_lens x \\<Longrightarrow> x:[II] = II\"", "lemma frame_assign_in [frame]:\n  \"\\<lbrakk> vwb_lens a; x \\<subseteq>\\<^sub>L a \\<rbrakk> \\<Longrightarrow> a:[x := v] = x := v\"", "lemma frame_conj_true [frame]:\n  \"\\<lbrakk> {$x,$x\\<acute>} \\<natural> P; vwb_lens x \\<rbrakk> \\<Longrightarrow> (P \\<and> x:[true]) = x:[P]\"", "lemma frame_is_assign [frame]:\n  \"vwb_lens x \\<Longrightarrow> x:[$x\\<acute> =\\<^sub>u \\<lceil>v\\<rceil>\\<^sub><] = x := v\"", "lemma frame_seq [frame]:\n  \"\\<lbrakk> vwb_lens x; {$x,$x\\<acute>} \\<natural> P; {$x,$x\\<acute>} \\<natural> Q \\<rbrakk> \\<Longrightarrow> x:[P ;; Q] = x:[P] ;; x:[Q]\"", "lemma frame_to_antiframe [frame]:\n  \"\\<lbrakk> x \\<bowtie> y; x +\\<^sub>L y = 1\\<^sub>L \\<rbrakk> \\<Longrightarrow> x:[P] = y:\\<lbrakk>P\\<rbrakk>\"", "lemma rel_frext_miracle [frame]: \n  \"a:[false]\\<^sup>+ = false\"", "lemma rel_frext_skip [frame]: \n  \"vwb_lens a \\<Longrightarrow> a:[II]\\<^sup>+ = II\"", "lemma rel_frext_seq [frame]:\n  \"vwb_lens a \\<Longrightarrow> a:[P ;; Q]\\<^sup>+ = (a:[P]\\<^sup>+ ;; a:[Q]\\<^sup>+)\"", "lemma rel_frext_assigns [frame]:\n  \"vwb_lens a \\<Longrightarrow> a:[\\<langle>\\<sigma>\\<rangle>\\<^sub>a]\\<^sup>+ = \\<langle>\\<sigma> \\<oplus>\\<^sub>s a\\<rangle>\\<^sub>a\"", "lemma rel_frext_rcond [frame]:\n  \"a:[P \\<triangleleft> b \\<triangleright>\\<^sub>r Q]\\<^sup>+ = (a:[P]\\<^sup>+ \\<triangleleft> b \\<oplus>\\<^sub>p a \\<triangleright>\\<^sub>r a:[Q]\\<^sup>+)\"", "lemma rel_frext_commute: \n  \"x \\<bowtie> y \\<Longrightarrow> x:[P]\\<^sup>+ ;; y:[Q]\\<^sup>+ = y:[Q]\\<^sup>+ ;; x:[P]\\<^sup>+\"", "lemma antiframe_disj [frame]: \"(x:\\<lbrakk>P\\<rbrakk> \\<or> x:\\<lbrakk>Q\\<rbrakk>) = x:\\<lbrakk>P \\<or> Q\\<rbrakk>\"", "lemma antiframe_seq [frame]:\n  \"\\<lbrakk> vwb_lens x; $x\\<acute> \\<sharp> P; $x \\<sharp> Q \\<rbrakk>  \\<Longrightarrow> (x:\\<lbrakk>P\\<rbrakk> ;; x:\\<lbrakk>Q\\<rbrakk>) = x:\\<lbrakk>P ;; Q\\<rbrakk>\"", "lemma nameset_skip: \"vwb_lens x \\<Longrightarrow> (ns x \\<bullet> II) = II\\<^bsub>x\\<^esub>\"", "lemma nameset_skip_ra: \"vwb_lens x \\<Longrightarrow> (ns x \\<bullet> II\\<^bsub>x\\<^esub>) = II\\<^bsub>x\\<^esub>\"", "theorem while_unfold:\n  \"while b do P od = ((P ;; while b do P od) \\<triangleleft> b \\<triangleright>\\<^sub>r II)\"", "theorem while_false: \"while false do P od = II\"", "theorem while_true: \"while true do P od = false\"", "theorem while_bot_unfold:\n  \"while\\<^sub>\\<bottom> b do P od = ((P ;; while\\<^sub>\\<bottom> b do P od) \\<triangleleft> b \\<triangleright>\\<^sub>r II)\"", "theorem while_bot_false: \"while\\<^sub>\\<bottom> false do P od = II\"", "theorem while_bot_true: \"while\\<^sub>\\<bottom> true do P od = (\\<mu> X \\<bullet> P ;; X)\"", "theorem while_infinite: \"P ;; true\\<^sub>h = true \\<Longrightarrow> while\\<^sub>\\<bottom> true do P od = true\"", "lemma upower_rep_eq:\n  \"\\<lbrakk>P \\<^bold>^ i\\<rbrakk>\\<^sub>e = (\\<lambda> b. b \\<in> ({p. \\<lbrakk>P\\<rbrakk>\\<^sub>e p} ^^ i))\"", "lemma upower_rep_eq_alt:\n  \"\\<lbrakk>power.power \\<langle>id\\<rangle>\\<^sub>a (;;) P i\\<rbrakk>\\<^sub>e = (\\<lambda>b. b \\<in> ({p. \\<lbrakk>P\\<rbrakk>\\<^sub>e p} ^^ i))\"", "lemma Sup_power_expand:\n  fixes P :: \"nat \\<Rightarrow> 'a::complete_lattice\"\n  shows \"P(0) \\<sqinter> (\\<Sqinter>i. P(i+1)) = (\\<Sqinter>i. P(i))\"", "lemma Sup_upto_Suc: \"(\\<Sqinter>i\\<in>{0..Suc n}. P \\<^bold>^ i) = (\\<Sqinter>i\\<in>{0..n}. P \\<^bold>^ i) \\<sqinter> P \\<^bold>^ Suc n\"", "lemma upower_inductl: \"Q \\<sqsubseteq> ((P ;; Q) \\<sqinter> R) \\<Longrightarrow> Q \\<sqsubseteq> P \\<^bold>^ n ;; R\"", "lemma upower_inductr:\n  assumes \"Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\"\n  shows \"Q \\<sqsubseteq> R ;; (P \\<^bold>^ n)\"", "lemma SUP_atLeastAtMost_first:\n  fixes P :: \"nat \\<Rightarrow> 'a::complete_lattice\"\n  assumes \"m \\<le> n\"\n  shows \"(\\<Sqinter>i\\<in>{m..n}. P(i)) = P(m) \\<sqinter> (\\<Sqinter>i\\<in>{Suc m..n}. P(i))\"", "lemma upower_seqr_iter: \"P \\<^bold>^ n = (;; Q : replicate n P \\<bullet> Q)\"", "lemma assigns_power: \"\\<langle>f\\<rangle>\\<^sub>a \\<^bold>^ n = \\<langle>f ^^ n\\<rangle>\\<^sub>a\"", "lemma ustar_rep_eq:\n  \"\\<lbrakk>P\\<^sup>\\<star>\\<rbrakk>\\<^sub>e = (\\<lambda>b. b \\<in> ({p. \\<lbrakk>P\\<rbrakk>\\<^sub>e p}\\<^sup>*))\"", "lemma uplus_power_def: \"P\\<^sup>+ = (\\<Sqinter> i \\<bullet> P \\<^bold>^ (Suc i))\"", "theorem RA1: \"(P ;; (Q ;; R)) = ((P ;; Q) ;; R)\"", "theorem RA2: \"(P ;; II) = P\" \"(II ;; P) = P\"", "theorem RA3: \"P\\<^sup>-\\<^sup>- = P\"", "theorem RA4: \"(P ;; Q)\\<^sup>- = (Q\\<^sup>- ;; P\\<^sup>-)\"", "theorem RA5: \"(P \\<or> Q)\\<^sup>- = (P\\<^sup>- \\<or> Q\\<^sup>-)\"", "theorem RA6: \"((P \\<or> Q) ;; R) = (P;;R \\<or> Q;;R)\"", "theorem RA7: \"((P\\<^sup>- ;; (\\<not>(P ;; Q))) \\<or> (\\<not>Q)) = (\\<not>Q)\"", "lemma ustar_alt_def: \"P\\<^sup>\\<star> = (\\<Sqinter> i \\<bullet> P \\<^bold>^ i)\"", "theorem ustar_sub_unfoldl: \"P\\<^sup>\\<star> \\<sqsubseteq> II \\<sqinter> (P;;P\\<^sup>\\<star>)\"", "theorem ustar_inductl:\n  assumes \"Q \\<sqsubseteq> R\" \"Q \\<sqsubseteq> P ;; Q\"\n  shows \"Q \\<sqsubseteq> P\\<^sup>\\<star> ;; R\"", "theorem ustar_inductr:\n  assumes \"Q \\<sqsubseteq> R\" \"Q \\<sqsubseteq> Q ;; P\"\n  shows \"Q \\<sqsubseteq> R ;; P\\<^sup>\\<star>\"", "lemma ustar_refines_nu: \"(\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II) \\<sqsubseteq> P\\<^sup>\\<star>\"", "lemma ustar_as_nu: \"P\\<^sup>\\<star> = (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II)\"", "lemma ustar_unfoldl: \"P\\<^sup>\\<star> = II \\<sqinter> (P ;; P\\<^sup>\\<star>)\"", "lemma while_star_form:\n  \"while b do P od = (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;; [(\\<not>b)]\\<^sup>\\<top>\"", "lemma uomega_induct:\n  \"P ;; P\\<^sup>\\<omega> \\<sqsubseteq> P\\<^sup>\\<omega>\"", "lemma skip_r_refine:\n  \"(p \\<Rightarrow> p) \\<sqsubseteq> II\"", "lemma conj_refine_left:\n  \"(Q \\<Rightarrow> P) \\<sqsubseteq> R \\<Longrightarrow> P \\<sqsubseteq> (Q \\<and> R)\"", "lemma pre_weak_rel:\n  assumes \"`Pre \\<Rightarrow> I`\"\n  and     \"(I \\<Rightarrow> Post) \\<sqsubseteq> P\"\n  shows \"(Pre \\<Rightarrow> Post) \\<sqsubseteq> P\"", "lemma cond_refine_rel: \n  assumes \"S \\<sqsubseteq> (\\<lceil>b\\<rceil>\\<^sub>< \\<and> P)\" \"S \\<sqsubseteq> (\\<lceil>\\<not>b\\<rceil>\\<^sub>< \\<and> Q)\"\n  shows \"S \\<sqsubseteq> P \\<triangleleft> b \\<triangleright>\\<^sub>r Q\"", "lemma seq_refine_pred:\n  assumes \"(\\<lceil>b\\<rceil>\\<^sub>< \\<Rightarrow> \\<lceil>s\\<rceil>\\<^sub>>) \\<sqsubseteq> P\" and \"(\\<lceil>s\\<rceil>\\<^sub>< \\<Rightarrow> \\<lceil>c\\<rceil>\\<^sub>>) \\<sqsubseteq> Q\"\n  shows \"(\\<lceil>b\\<rceil>\\<^sub>< \\<Rightarrow> \\<lceil>c\\<rceil>\\<^sub>>) \\<sqsubseteq> (P ;; Q)\"", "lemma seq_refine_unrest:\n  assumes \"out\\<alpha> \\<sharp> b\" \"in\\<alpha> \\<sharp> c\"\n  assumes \"(b \\<Rightarrow> \\<lceil>s\\<rceil>\\<^sub>>) \\<sqsubseteq> P\" and \"(\\<lceil>s\\<rceil>\\<^sub>< \\<Rightarrow> c) \\<sqsubseteq> Q\"\n  shows \"(b \\<Rightarrow> c) \\<sqsubseteq> (P ;; Q)\"", "lemma Dom_conv_Ran:\n  \"Dom(P\\<^sup>-) = Ran(P)\"", "lemma Ran_conv_Dom:\n  \"Ran(P\\<^sup>-) = Dom(P)\"", "lemma Dom_skip:\n  \"Dom(II) = true\"", "lemma Dom_assigns:\n  \"Dom(\\<langle>\\<sigma>\\<rangle>\\<^sub>a) = true\"", "lemma Dom_miracle:\n  \"Dom(false) = false\"", "lemma Dom_assume:\n  \"Dom([b]\\<^sup>\\<top>) = b\"", "lemma Dom_seq:\n  \"Dom(P ;; Q) = Dom(P ;; [Dom(Q)]\\<^sup>\\<top>)\"", "lemma Dom_disj:\n  \"Dom(P \\<or> Q) = (Dom(P) \\<or> Dom(Q))\"", "lemma Dom_inf:\n  \"Dom(P \\<sqinter> Q) = (Dom(P) \\<or> Dom(Q))\"", "lemma assume_Dom:\n  \"[Dom(P)]\\<^sup>\\<top> ;; P = P\""], "translations": [["", "lemma comp_cond_left_distr:\n  \"((P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) ;; R) = ((P ;; R) \\<triangleleft> b \\<triangleright>\\<^sub>r (Q ;; R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) ;; R =\n    P ;; R \\<triangleleft> b \\<triangleright>\\<^sub>r Q ;; R", "by (rel_auto)"], ["", "lemma cond_seq_left_distr:\n  \"out\\<alpha> \\<sharp> b \\<Longrightarrow> ((P \\<triangleleft> b \\<triangleright> Q) ;; R) = ((P ;; R) \\<triangleleft> b \\<triangleright> (Q ;; R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out\\<alpha> \\<sharp> b \\<Longrightarrow>\n    (P \\<triangleleft> b \\<triangleright> Q) ;; R =\n    P ;; R \\<triangleleft> b \\<triangleright> Q ;; R", "by (rel_auto)"], ["", "lemma cond_seq_right_distr:\n  \"in\\<alpha> \\<sharp> b \\<Longrightarrow> (P ;; (Q \\<triangleleft> b \\<triangleright> R)) = ((P ;; Q) \\<triangleleft> b \\<triangleright> (P ;; R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in\\<alpha> \\<sharp> b \\<Longrightarrow>\n    P ;; (Q \\<triangleleft> b \\<triangleright> R) =\n    P ;; Q \\<triangleleft> b \\<triangleright> P ;; R", "by (rel_auto)"], ["", "text \\<open> Alternative expression of conditional using assumptions and choice \\<close>"], ["", "lemma rcond_rassume_expand: \"P \\<triangleleft> b \\<triangleright>\\<^sub>r Q = ([b]\\<^sup>\\<top> ;; P) \\<sqinter> ([(\\<not> b)]\\<^sup>\\<top> ;; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<triangleleft> b \\<triangleright>\\<^sub>r Q =\n    (?[b] ;; P) \\<sqinter> (?[\\<not> b] ;; Q)", "by (rel_auto)"], ["", "subsection \\<open> Precondition and Postcondition Laws \\<close>"], ["", "theorem precond_equiv:\n  \"P = (P ;; true) \\<longleftrightarrow> (out\\<alpha> \\<sharp> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P = P ;; true) = (out\\<alpha> \\<sharp> P)", "by (rel_auto)"], ["", "theorem postcond_equiv:\n  \"P = (true ;; P) \\<longleftrightarrow> (in\\<alpha> \\<sharp> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P = true ;; P) = (in\\<alpha> \\<sharp> P)", "by (rel_auto)"], ["", "lemma precond_right_unit: \"out\\<alpha> \\<sharp> p \\<Longrightarrow> (p ;; true) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out\\<alpha> \\<sharp> p \\<Longrightarrow> p ;; true = p", "by (metis precond_equiv)"], ["", "lemma postcond_left_unit: \"in\\<alpha> \\<sharp> p \\<Longrightarrow> (true ;; p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in\\<alpha> \\<sharp> p \\<Longrightarrow> true ;; p = p", "by (metis postcond_equiv)"], ["", "theorem precond_left_zero:\n  assumes \"out\\<alpha> \\<sharp> p\" \"p \\<noteq> false\"\n  shows \"(true ;; p) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. true ;; p = true", "using assms"], ["proof (prove)\nusing this:\n  out\\<alpha> \\<sharp> p\n  \\<not> p = false\n\ngoal (1 subgoal):\n 1. true ;; p = true", "by (rel_auto)"], ["", "theorem feasibile_iff_true_right_zero:\n  \"P ;; true = true \\<longleftrightarrow> `\\<exists> out\\<alpha> \\<bullet> P`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P ;; true = true) = `\\<exists> out\\<alpha> \\<bullet> P`", "by (rel_auto)"], ["", "subsection \\<open> Sequential Composition Laws \\<close>"], ["", "lemma seqr_assoc: \"(P ;; Q) ;; R = P ;; (Q ;; R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P ;; Q) ;; R = P ;; Q ;; R", "by (rel_auto)"], ["", "lemma seqr_left_unit [simp]:\n  \"II ;; P = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. II ;; P = P", "by (rel_auto)"], ["", "lemma seqr_right_unit [simp]:\n  \"P ;; II = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; II = P", "by (rel_auto)"], ["", "lemma seqr_left_zero [simp]:\n  \"false ;; P = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. false ;; P = false", "by pred_auto"], ["", "lemma seqr_right_zero [simp]:\n  \"P ;; false = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; false = false", "by pred_auto"], ["", "lemma impl_seqr_mono: \"\\<lbrakk> `P \\<Rightarrow> Q`; `R \\<Rightarrow> S` \\<rbrakk> \\<Longrightarrow> `(P ;; R) \\<Rightarrow> (Q ;; S)`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>`P \\<Rightarrow> Q`; `R \\<Rightarrow> S`\\<rbrakk>\n    \\<Longrightarrow> `P ;; R \\<Rightarrow> Q ;; S`", "by (pred_blast)"], ["", "lemma seqr_mono:\n  \"\\<lbrakk> P\\<^sub>1 \\<sqsubseteq> P\\<^sub>2; Q\\<^sub>1 \\<sqsubseteq> Q\\<^sub>2 \\<rbrakk> \\<Longrightarrow> (P\\<^sub>1 ;; Q\\<^sub>1) \\<sqsubseteq> (P\\<^sub>2 ;; Q\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P\\<^sub>1 \\<sqsubseteq> P\\<^sub>2;\n     Q\\<^sub>1 \\<sqsubseteq> Q\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> P\\<^sub>1 ;; Q\\<^sub>1 \\<sqsubseteq>\n                      P\\<^sub>2 ;; Q\\<^sub>2", "by (rel_blast)"], ["", "lemma seqr_monotonic:\n  \"\\<lbrakk> mono P; mono Q \\<rbrakk> \\<Longrightarrow> mono (\\<lambda> X. P X ;; Q X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono P; mono Q\\<rbrakk>\n    \\<Longrightarrow> mono (\\<lambda>X. P X ;; Q X)", "by (simp add: mono_def, rel_blast)"], ["", "lemma Monotonic_seqr_tail [closure]:\n  assumes \"Monotonic F\"\n  shows \"Monotonic (\\<lambda> X. P ;; F(X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotonic (\\<lambda>X. P ;; F X)", "by (simp add: assms monoD monoI seqr_mono)"], ["", "lemma seqr_exists_left:\n  \"((\\<exists> $x \\<bullet> P) ;; Q) = (\\<exists> $x \\<bullet> (P ;; Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists> $x \\<bullet> P) ;; Q = (\\<exists> $x \\<bullet> P ;; Q)", "by (rel_auto)"], ["", "lemma seqr_exists_right:\n  \"(P ;; (\\<exists> $x\\<acute> \\<bullet> Q)) = (\\<exists> $x\\<acute> \\<bullet> (P ;; Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; (\\<exists> $x\\<acute> \\<bullet> Q) =\n    (\\<exists> $x\\<acute> \\<bullet> P ;; Q)", "by (rel_auto)"], ["", "lemma seqr_or_distl:\n  \"((P \\<or> Q) ;; R) = ((P ;; R) \\<or> (Q ;; R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q) ;; R = (P ;; R \\<or> Q ;; R)", "by (rel_auto)"], ["", "lemma seqr_or_distr:\n  \"(P ;; (Q \\<or> R)) = ((P ;; Q) \\<or> (P ;; R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; (Q \\<or> R) = (P ;; Q \\<or> P ;; R)", "by (rel_auto)"], ["", "lemma seqr_inf_distl:\n  \"((P \\<sqinter> Q) ;; R) = ((P ;; R) \\<sqinter> (Q ;; R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqinter> Q ;; R = (P ;; R) \\<sqinter> (Q ;; R)", "by (rel_auto)"], ["", "lemma seqr_inf_distr:\n  \"(P ;; (Q \\<sqinter> R)) = ((P ;; Q) \\<sqinter> (P ;; R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; Q \\<sqinter> R = (P ;; Q) \\<sqinter> (P ;; R)", "by (rel_auto)"], ["", "lemma seqr_and_distr_ufunc:\n  \"ufunctional P \\<Longrightarrow> (P ;; (Q \\<and> R)) = ((P ;; Q) \\<and> (P ;; R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ufunctional P \\<Longrightarrow>\n    P ;; (Q \\<and> R) = (P ;; Q \\<and> P ;; R)", "by (rel_auto)"], ["", "lemma seqr_and_distl_uinj:\n  \"uinj R \\<Longrightarrow> ((P \\<and> Q) ;; R) = ((P ;; R) \\<and> (Q ;; R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uinj R \\<Longrightarrow> (P \\<and> Q) ;; R = (P ;; R \\<and> Q ;; R)", "by (rel_auto)"], ["", "lemma seqr_unfold:\n  \"(P ;; Q) = (\\<^bold>\\<exists> v \\<bullet> P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$\\<^bold>v\\<acute>\\<rbrakk> \\<and> Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$\\<^bold>v\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; Q =\n    (\\<^bold>\\<exists> v \\<bullet> P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$\\<^bold>v\\<acute>\\<rbrakk> \\<and>\n                                   Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$\\<^bold>v\\<rbrakk>)", "by (rel_auto)"], ["", "lemma seqr_middle:\n  assumes \"vwb_lens x\"\n  shows \"(P ;; Q) = (\\<^bold>\\<exists> v \\<bullet> P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; Q =\n    (\\<^bold>\\<exists> v \\<bullet> P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<acute>\\<rbrakk> ;;\n                                   Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<rbrakk>)", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. P ;; Q =\n    (\\<^bold>\\<exists> v \\<bullet> P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<acute>\\<rbrakk> ;;\n                                   Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<rbrakk>)", "by (rel_auto', metis vwb_lens_wb wb_lens.source_stability)"], ["", "lemma seqr_left_one_point:\n  assumes \"vwb_lens x\"\n  shows \"((P \\<and> $x\\<acute> =\\<^sub>u \\<guillemotleft>v\\<guillemotright>) ;; Q) = (P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> $x\\<acute> =\\<^sub>u \\<guillemotleft>v\\<guillemotright>) ;;\n    Q =\n    P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<acute>\\<rbrakk> ;;\n    Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<rbrakk>", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. (P \\<and> $x\\<acute> =\\<^sub>u \\<guillemotleft>v\\<guillemotright>) ;;\n    Q =\n    P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<acute>\\<rbrakk> ;;\n    Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<rbrakk>", "by (rel_auto, metis vwb_lens_wb wb_lens.get_put)"], ["", "lemma seqr_right_one_point:\n  assumes \"vwb_lens x\"\n  shows \"(P ;; ($x =\\<^sub>u \\<guillemotleft>v\\<guillemotright> \\<and> Q)) = (P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; ($x =\\<^sub>u \\<guillemotleft>v\\<guillemotright> \\<and> Q) =\n    P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<acute>\\<rbrakk> ;;\n    Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<rbrakk>", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. P ;; ($x =\\<^sub>u \\<guillemotleft>v\\<guillemotright> \\<and> Q) =\n    P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<acute>\\<rbrakk> ;;\n    Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/$x\\<rbrakk>", "by (rel_auto, metis vwb_lens_wb wb_lens.get_put)"], ["", "lemma seqr_left_one_point_true:\n  assumes \"vwb_lens x\"\n  shows \"((P \\<and> $x\\<acute>) ;; Q) = (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>true/$x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> $x\\<acute>) ;; Q =\n    P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>true/$x\\<rbrakk>", "by (metis assms seqr_left_one_point true_alt_def upred_eq_true)"], ["", "lemma seqr_left_one_point_false:\n  assumes \"vwb_lens x\"\n  shows \"((P \\<and> \\<not>$x\\<acute>) ;; Q) = (P\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>false/$x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> \\<not> $x\\<acute>) ;; Q =\n    P\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>false/$x\\<rbrakk>", "by (metis assms false_alt_def seqr_left_one_point upred_eq_false)"], ["", "lemma seqr_right_one_point_true:\n  assumes \"vwb_lens x\"\n  shows \"(P ;; ($x \\<and> Q)) = (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>true/$x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; ($x \\<and> Q) =\n    P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>true/$x\\<rbrakk>", "by (metis assms seqr_right_one_point true_alt_def upred_eq_true)"], ["", "lemma seqr_right_one_point_false:\n  assumes \"vwb_lens x\"\n  shows \"(P ;; (\\<not>$x \\<and> Q)) = (P\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>false/$x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; (\\<not> $x \\<and> Q) =\n    P\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>false/$x\\<rbrakk>", "by (metis assms false_alt_def seqr_right_one_point upred_eq_false)"], ["", "lemma seqr_insert_ident_left:\n  assumes \"vwb_lens x\" \"$x\\<acute> \\<sharp> P\" \"$x \\<sharp> Q\"\n  shows \"(($x\\<acute> =\\<^sub>u $x \\<and> P) ;; Q) = (P ;; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($x\\<acute> =\\<^sub>u $x \\<and> P) ;; Q = P ;; Q", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n  $x\\<acute> \\<sharp> P\n  $x \\<sharp> Q\n\ngoal (1 subgoal):\n 1. ($x\\<acute> =\\<^sub>u $x \\<and> P) ;; Q = P ;; Q", "by (rel_simp, meson vwb_lens_wb wb_lens_weak weak_lens.put_get)"], ["", "lemma seqr_insert_ident_right:\n  assumes \"vwb_lens x\" \"$x\\<acute> \\<sharp> P\" \"$x \\<sharp> Q\"\n  shows \"(P ;; ($x\\<acute> =\\<^sub>u $x \\<and> Q)) = (P ;; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; ($x\\<acute> =\\<^sub>u $x \\<and> Q) = P ;; Q", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n  $x\\<acute> \\<sharp> P\n  $x \\<sharp> Q\n\ngoal (1 subgoal):\n 1. P ;; ($x\\<acute> =\\<^sub>u $x \\<and> Q) = P ;; Q", "by (rel_simp, metis (no_types, hide_lams) vwb_lens_def wb_lens_def weak_lens.put_get)"], ["", "lemma seq_var_ident_lift:\n  assumes \"vwb_lens x\" \"$x\\<acute> \\<sharp> P\" \"$x \\<sharp> Q\"\n  shows \"(($x\\<acute> =\\<^sub>u $x \\<and> P) ;; ($x\\<acute> =\\<^sub>u $x \\<and> Q)) = ($x\\<acute> =\\<^sub>u $x \\<and> (P ;; Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($x\\<acute> =\\<^sub>u $x \\<and> P) ;;\n    ($x\\<acute> =\\<^sub>u $x \\<and> Q) =\n    ($x\\<acute> =\\<^sub>u $x \\<and> P ;; Q)", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n  $x\\<acute> \\<sharp> P\n  $x \\<sharp> Q\n\ngoal (1 subgoal):\n 1. ($x\\<acute> =\\<^sub>u $x \\<and> P) ;;\n    ($x\\<acute> =\\<^sub>u $x \\<and> Q) =\n    ($x\\<acute> =\\<^sub>u $x \\<and> P ;; Q)", "by (rel_auto', metis (no_types, lifting) vwb_lens_wb wb_lens_weak weak_lens.put_get)"], ["", "lemma seqr_bool_split:\n  assumes \"vwb_lens x\"\n  shows \"P ;; Q = (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>true/$x\\<rbrakk> \\<or> P\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>false/$x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; Q =\n    (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>true/$x\\<rbrakk> \\<or>\n     P\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>false/$x\\<rbrakk>)", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. P ;; Q =\n    (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>true/$x\\<rbrakk> \\<or>\n     P\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; Q\\<lbrakk>false/$x\\<rbrakk>)", "by (subst seqr_middle[of x], simp_all)"], ["", "lemma cond_inter_var_split:\n  assumes \"vwb_lens x\"\n  shows \"(P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R = (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or> Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n    (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or>\n     Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n    (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or>\n     Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)", "have \"(P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R = (($x\\<acute> \\<and> P) ;; R \\<or> (\\<not> $x\\<acute> \\<and> Q) ;; R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n    (($x\\<acute> \\<and> P) ;; R \\<or> (\\<not> $x\\<acute> \\<and> Q) ;; R)", "by (simp add: cond_def seqr_or_distl)"], ["proof (state)\nthis:\n  (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n  (($x\\<acute> \\<and> P) ;; R \\<or> (\\<not> $x\\<acute> \\<and> Q) ;; R)\n\ngoal (1 subgoal):\n 1. (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n    (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or>\n     Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)", "also"], ["proof (state)\nthis:\n  (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n  (($x\\<acute> \\<and> P) ;; R \\<or> (\\<not> $x\\<acute> \\<and> Q) ;; R)\n\ngoal (1 subgoal):\n 1. (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n    (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or>\n     Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)", "have \"... = ((P \\<and> $x\\<acute>) ;; R \\<or> (Q \\<and> \\<not>$x\\<acute>) ;; R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (($x\\<acute> \\<and> P) ;; R \\<or> (\\<not> $x\\<acute> \\<and> Q) ;; R) =\n    ((P \\<and> $x\\<acute>) ;; R \\<or> (Q \\<and> \\<not> $x\\<acute>) ;; R)", "by (rel_auto)"], ["proof (state)\nthis:\n  (($x\\<acute> \\<and> P) ;; R \\<or> (\\<not> $x\\<acute> \\<and> Q) ;; R) =\n  ((P \\<and> $x\\<acute>) ;; R \\<or> (Q \\<and> \\<not> $x\\<acute>) ;; R)\n\ngoal (1 subgoal):\n 1. (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n    (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or>\n     Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)", "also"], ["proof (state)\nthis:\n  (($x\\<acute> \\<and> P) ;; R \\<or> (\\<not> $x\\<acute> \\<and> Q) ;; R) =\n  ((P \\<and> $x\\<acute>) ;; R \\<or> (Q \\<and> \\<not> $x\\<acute>) ;; R)\n\ngoal (1 subgoal):\n 1. (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n    (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or>\n     Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)", "have \"... = (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or> Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<and> $x\\<acute>) ;; R \\<or> (Q \\<and> \\<not> $x\\<acute>) ;; R) =\n    (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or>\n     Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)", "by (simp add: seqr_left_one_point_true seqr_left_one_point_false assms)"], ["proof (state)\nthis:\n  ((P \\<and> $x\\<acute>) ;; R \\<or> (Q \\<and> \\<not> $x\\<acute>) ;; R) =\n  (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or>\n   Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)\n\ngoal (1 subgoal):\n 1. (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n    (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or>\n     Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)", "finally"], ["proof (chain)\npicking this:\n  (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n  (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or>\n   Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)", "show ?thesis"], ["proof (prove)\nusing this:\n  (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n  (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or>\n   Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)\n\ngoal (1 subgoal):\n 1. (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n    (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or>\n     Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)", "."], ["proof (state)\nthis:\n  (P \\<triangleleft> $x\\<acute> \\<triangleright> Q) ;; R =\n  (P\\<lbrakk>true/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>true/$x\\<rbrakk> \\<or>\n   Q\\<lbrakk>false/$x\\<acute>\\<rbrakk> ;; R\\<lbrakk>false/$x\\<rbrakk>)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem seqr_pre_transfer: \"in\\<alpha> \\<sharp> q \\<Longrightarrow> ((P \\<and> q) ;; R) = (P ;; (q\\<^sup>- \\<and> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in\\<alpha> \\<sharp> q \\<Longrightarrow>\n    (P \\<and> q) ;; R = P ;; (q\\<^sup>- \\<and> R)", "by (rel_auto)"], ["", "theorem seqr_pre_transfer':\n  \"((P \\<and> \\<lceil>q\\<rceil>\\<^sub>>) ;; R) = (P ;; (\\<lceil>q\\<rceil>\\<^sub>< \\<and> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> \\<lceil>q\\<rceil>\\<^sub>>) ;; R =\n    P ;; (\\<lceil>q\\<rceil>\\<^sub>< \\<and> R)", "by (rel_auto)"], ["", "theorem seqr_post_out: \"in\\<alpha> \\<sharp> r \\<Longrightarrow> (P ;; (Q \\<and> r)) = ((P ;; Q) \\<and> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in\\<alpha> \\<sharp> r \\<Longrightarrow>\n    P ;; (Q \\<and> r) = (P ;; Q \\<and> r)", "by (rel_blast)"], ["", "lemma seqr_post_var_out:\n  fixes x :: \"(bool \\<Longrightarrow> '\\<alpha>)\"\n  shows \"(P ;; (Q \\<and> $x\\<acute>)) = ((P ;; Q) \\<and> $x\\<acute>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; (Q \\<and> $x\\<acute>) = (P ;; Q \\<and> $x\\<acute>)", "by (rel_auto)"], ["", "theorem seqr_post_transfer: \"out\\<alpha> \\<sharp> q \\<Longrightarrow> (P ;; (q \\<and> R)) = ((P \\<and> q\\<^sup>-) ;; R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out\\<alpha> \\<sharp> q \\<Longrightarrow>\n    P ;; (q \\<and> R) = (P \\<and> q\\<^sup>-) ;; R", "by (rel_auto)"], ["", "lemma seqr_pre_out: \"out\\<alpha> \\<sharp> p \\<Longrightarrow> ((p \\<and> Q) ;; R) = (p \\<and> (Q ;; R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out\\<alpha> \\<sharp> p \\<Longrightarrow>\n    (p \\<and> Q) ;; R = (p \\<and> Q ;; R)", "by (rel_blast)"], ["", "lemma seqr_pre_var_out:\n  fixes x :: \"(bool \\<Longrightarrow> '\\<alpha>)\"\n  shows \"(($x \\<and> P) ;; Q) = ($x \\<and> (P ;; Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($x \\<and> P) ;; Q = ($x \\<and> P ;; Q)", "by (rel_auto)"], ["", "lemma seqr_true_lemma:\n  \"(P = (\\<not> ((\\<not> P) ;; true))) = (P = (P ;; true))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P = (\\<not> (\\<not> P) ;; true)) = (P = P ;; true)", "by (rel_auto)"], ["", "lemma seqr_to_conj: \"\\<lbrakk> out\\<alpha> \\<sharp> P; in\\<alpha> \\<sharp> Q \\<rbrakk> \\<Longrightarrow> (P ;; Q) = (P \\<and> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>out\\<alpha> \\<sharp> P; in\\<alpha> \\<sharp> Q\\<rbrakk>\n    \\<Longrightarrow> P ;; Q = (P \\<and> Q)", "by (metis postcond_left_unit seqr_pre_out utp_pred_laws.inf_top.right_neutral)"], ["", "lemma shEx_lift_seq_1 [uquant_lift]:\n  \"((\\<^bold>\\<exists> x \\<bullet> P x) ;; Q) = (\\<^bold>\\<exists> x \\<bullet> (P x ;; Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ushEx P ;; Q = (\\<^bold>\\<exists> x \\<bullet> P x ;; Q)", "by rel_auto"], ["", "lemma shEx_mem_lift_seq_1 [uquant_lift]:\n  assumes \"out\\<alpha> \\<sharp> A\"\n  shows \"((\\<^bold>\\<exists> x \\<in> A \\<bullet> P x) ;; Q) = (\\<^bold>\\<exists> x \\<in> A \\<bullet> (P x ;; Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>\\<exists> x \\<bullet> \\<guillemotleft>x\\<guillemotright> \\<in>\\<^sub>u\n                                   A \\<and>\n                                   P x) ;;\n    Q =\n    (\\<^bold>\\<exists> x \\<bullet> \\<guillemotleft>x\\<guillemotright> \\<in>\\<^sub>u\n                                   A \\<and>\n                                   P x ;; Q)", "using assms"], ["proof (prove)\nusing this:\n  out\\<alpha> \\<sharp> A\n\ngoal (1 subgoal):\n 1. (\\<^bold>\\<exists> x \\<bullet> \\<guillemotleft>x\\<guillemotright> \\<in>\\<^sub>u\n                                   A \\<and>\n                                   P x) ;;\n    Q =\n    (\\<^bold>\\<exists> x \\<bullet> \\<guillemotleft>x\\<guillemotright> \\<in>\\<^sub>u\n                                   A \\<and>\n                                   P x ;; Q)", "by rel_blast"], ["", "lemma shEx_lift_seq_2 [uquant_lift]:\n  \"(P ;; (\\<^bold>\\<exists> x \\<bullet> Q x)) = (\\<^bold>\\<exists> x \\<bullet> (P ;; Q x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; ushEx Q = (\\<^bold>\\<exists> x \\<bullet> P ;; Q x)", "by rel_auto"], ["", "lemma shEx_mem_lift_seq_2 [uquant_lift]:\n  assumes \"in\\<alpha> \\<sharp> A\"\n  shows \"(P ;; (\\<^bold>\\<exists> x \\<in> A \\<bullet> Q x)) = (\\<^bold>\\<exists> x \\<in> A \\<bullet> (P ;; Q x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;;\n    (\\<^bold>\\<exists> x \\<bullet> \\<guillemotleft>x\\<guillemotright> \\<in>\\<^sub>u\n                                   A \\<and>\n                                   Q x) =\n    (\\<^bold>\\<exists> x \\<bullet> \\<guillemotleft>x\\<guillemotright> \\<in>\\<^sub>u\n                                   A \\<and>\n                                   P ;; Q x)", "using assms"], ["proof (prove)\nusing this:\n  in\\<alpha> \\<sharp> A\n\ngoal (1 subgoal):\n 1. P ;;\n    (\\<^bold>\\<exists> x \\<bullet> \\<guillemotleft>x\\<guillemotright> \\<in>\\<^sub>u\n                                   A \\<and>\n                                   Q x) =\n    (\\<^bold>\\<exists> x \\<bullet> \\<guillemotleft>x\\<guillemotright> \\<in>\\<^sub>u\n                                   A \\<and>\n                                   P ;; Q x)", "by rel_blast"], ["", "subsection \\<open> Iterated Sequential Composition Laws \\<close>"], ["", "lemma iter_seqr_nil [simp]: \"(;; i : [] \\<bullet> P(i)) = II\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seqr_iter [] P = II", "by (simp add: seqr_iter_def)"], ["", "lemma iter_seqr_cons [simp]: \"(;; i : (x # xs) \\<bullet> P(i)) = P(x) ;; (;; i : xs \\<bullet> P(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seqr_iter (x # xs) P = P x ;; seqr_iter xs P", "by (simp add: seqr_iter_def)"], ["", "subsection \\<open> Quantale Laws \\<close>"], ["", "lemma seq_Sup_distl: \"P ;; (\\<Sqinter> A) = (\\<Sqinter> Q\\<in>A. P ;; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; \\<Or>A = \\<Or>((;;) P ` A)", "by (transfer, auto)"], ["", "lemma seq_Sup_distr: \"(\\<Sqinter> A) ;; Q = (\\<Sqinter> P\\<in>A. P ;; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Or>A ;; Q = \\<Or>((\\<lambda>P. P ;; Q) ` A)", "by (transfer, auto)"], ["", "lemma seq_UINF_distl: \"P ;; (\\<Sqinter> Q\\<in>A \\<bullet> F(Q)) = (\\<Sqinter> Q\\<in>A \\<bullet> P ;; F(Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; (\\<Sqinter> Q \\<in> A \\<bullet> F Q) =\n    (\\<Sqinter> Q \\<in> A \\<bullet> P ;; F Q)", "by (simp add: UINF_as_Sup_collect seq_Sup_distl)"], ["", "lemma seq_UINF_distl': \"P ;; (\\<Sqinter> Q \\<bullet> F(Q)) = (\\<Sqinter> Q \\<bullet> P ;; F(Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; (\\<Sqinter> Q \\<bullet> F Q) = (\\<Sqinter> Q \\<bullet> P ;; F Q)", "by (metis UINF_mem_UNIV seq_UINF_distl)"], ["", "lemma seq_UINF_distr: \"(\\<Sqinter> P\\<in>A \\<bullet> F(P)) ;; Q = (\\<Sqinter> P\\<in>A \\<bullet> F(P) ;; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P \\<in> A \\<bullet> F P) ;; Q =\n    (\\<Sqinter> P \\<in> A \\<bullet> F P ;; Q)", "by (simp add: UINF_as_Sup_collect seq_Sup_distr)"], ["", "lemma seq_UINF_distr': \"(\\<Sqinter> P \\<bullet> F(P)) ;; Q = (\\<Sqinter> P \\<bullet> F(P) ;; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P \\<bullet> F P) ;; Q = (\\<Sqinter> P \\<bullet> F P ;; Q)", "by (metis UINF_mem_UNIV seq_UINF_distr)"], ["", "lemma seq_SUP_distl: \"P ;; (\\<Sqinter>i\\<in>A. Q(i)) = (\\<Sqinter>i\\<in>A. P ;; Q(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; \\<Or>(Q ` A) = \\<Or>((\\<lambda>i. P ;; Q i) ` A)", "by (metis image_image seq_Sup_distl)"], ["", "lemma seq_SUP_distr: \"(\\<Sqinter>i\\<in>A. P(i)) ;; Q = (\\<Sqinter>i\\<in>A. P(i) ;; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Or>(P ` A) ;; Q = \\<Or>((\\<lambda>i. P i ;; Q) ` A)", "by (simp add: seq_Sup_distr)"], ["", "subsection \\<open> Skip Laws \\<close>"], ["", "lemma cond_skip: \"out\\<alpha> \\<sharp> b \\<Longrightarrow> (b \\<and> II) = (II \\<and> b\\<^sup>-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out\\<alpha> \\<sharp> b \\<Longrightarrow>\n    (b \\<and> II) = (II \\<and> b\\<^sup>-)", "by (rel_auto)"], ["", "lemma pre_skip_post: \"(\\<lceil>b\\<rceil>\\<^sub>< \\<and> II) = (II \\<and> \\<lceil>b\\<rceil>\\<^sub>>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lceil>b\\<rceil>\\<^sub>< \\<and> II) =\n    (II \\<and> \\<lceil>b\\<rceil>\\<^sub>>)", "by (rel_auto)"], ["", "lemma skip_var:\n  fixes x :: \"(bool \\<Longrightarrow> '\\<alpha>)\"\n  shows \"($x \\<and> II) = (II \\<and> $x\\<acute>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($x \\<and> II) = (II \\<and> $x\\<acute>)", "by (rel_auto)"], ["", "lemma skip_r_unfold:\n  \"vwb_lens x \\<Longrightarrow> II = ($x\\<acute> =\\<^sub>u $x \\<and> II\\<restriction>\\<^sub>\\<alpha>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow>\n    II = ($x\\<acute> =\\<^sub>u $x \\<and> II \\<restriction>\\<^sub>\\<alpha> x)", "by (rel_simp, metis mwb_lens.put_put vwb_lens_mwb vwb_lens_wb wb_lens.get_put)"], ["", "lemma skip_r_alpha_eq:\n  \"II = ($\\<^bold>v\\<acute> =\\<^sub>u $\\<^bold>v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. II = ($\\<^bold>v\\<acute> =\\<^sub>u $\\<^bold>v)", "by (rel_auto)"], ["", "lemma skip_ra_unfold:\n  \"II\\<^bsub>x;y\\<^esub> = ($x\\<acute> =\\<^sub>u $x \\<and> II\\<^bsub>y\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. II\\<^bsub>x +\\<^sub>L y\\<^esub> =\n    ($x\\<acute> =\\<^sub>u $x \\<and> II\\<^bsub>y\\<^esub>)", "by (rel_auto)"], ["", "lemma skip_res_as_ra:\n  \"\\<lbrakk> vwb_lens y; x +\\<^sub>L y \\<approx>\\<^sub>L 1\\<^sub>L; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> II\\<restriction>\\<^sub>\\<alpha>x = II\\<^bsub>y\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens y; x +\\<^sub>L y \\<approx>\\<^sub>L \\<Sigma>;\n     x \\<bowtie> y\\<rbrakk>\n    \\<Longrightarrow> II \\<restriction>\\<^sub>\\<alpha> x =\n                      II\\<^bsub>y\\<^esub>", "apply (rel_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b Z Za v va.\n       \\<lbrakk>vwb_lens y; x \\<bowtie> y; vwb_lens Z; vwb_lens Za;\n        \\<forall>xa.\n           (get\\<^bsub>x\\<^esub> xa, get\\<^bsub>y\\<^esub> xa) =\n           get\\<^bsub>Z\\<^esub> xa;\n        \\<forall>xa a b.\n           put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> xa b) a =\n           put\\<^bsub>Z\\<^esub> xa (a, b);\n        \\<forall>x. x = get\\<^bsub>Za\\<^esub> (get\\<^bsub>Z\\<^esub> x);\n        \\<forall>x xa.\n           xa =\n           put\\<^bsub>Z\\<^esub> x\n            (put\\<^bsub>Za\\<^esub> (get\\<^bsub>Z\\<^esub> x) xa);\n        put\\<^bsub>x\\<^esub> b va = put\\<^bsub>x\\<^esub> a v\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>y\\<^esub> b = get\\<^bsub>y\\<^esub> a\n 2. \\<And>a b Z Za.\n       \\<lbrakk>vwb_lens y; x \\<bowtie> y; vwb_lens Z; vwb_lens Za;\n        \\<forall>xa.\n           (get\\<^bsub>x\\<^esub> xa, get\\<^bsub>y\\<^esub> xa) =\n           get\\<^bsub>Z\\<^esub> xa;\n        \\<forall>xa a b.\n           put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> xa b) a =\n           put\\<^bsub>Z\\<^esub> xa (a, b);\n        \\<forall>x. x = get\\<^bsub>Za\\<^esub> (get\\<^bsub>Z\\<^esub> x);\n        \\<forall>x xa.\n           xa =\n           put\\<^bsub>Z\\<^esub> x\n            (put\\<^bsub>Za\\<^esub> (get\\<^bsub>Z\\<^esub> x) xa);\n        get\\<^bsub>y\\<^esub> b = get\\<^bsub>y\\<^esub> a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v va.\n                            put\\<^bsub>x\\<^esub> b va =\n                            put\\<^bsub>x\\<^esub> a v", "apply (metis (no_types, lifting) lens_indep_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b Z Za.\n       \\<lbrakk>vwb_lens y; x \\<bowtie> y; vwb_lens Z; vwb_lens Za;\n        \\<forall>xa.\n           (get\\<^bsub>x\\<^esub> xa, get\\<^bsub>y\\<^esub> xa) =\n           get\\<^bsub>Z\\<^esub> xa;\n        \\<forall>xa a b.\n           put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> xa b) a =\n           put\\<^bsub>Z\\<^esub> xa (a, b);\n        \\<forall>x. x = get\\<^bsub>Za\\<^esub> (get\\<^bsub>Z\\<^esub> x);\n        \\<forall>x xa.\n           xa =\n           put\\<^bsub>Z\\<^esub> x\n            (put\\<^bsub>Za\\<^esub> (get\\<^bsub>Z\\<^esub> x) xa);\n        get\\<^bsub>y\\<^esub> b = get\\<^bsub>y\\<^esub> a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v va.\n                            put\\<^bsub>x\\<^esub> b va =\n                            put\\<^bsub>x\\<^esub> a v", "apply (metis vwb_lens.put_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open> Assignment Laws \\<close>"], ["", "lemma assigns_subst [usubst]:\n  \"\\<lceil>\\<sigma>\\<rceil>\\<^sub>s \\<dagger> \\<langle>\\<rho>\\<rangle>\\<^sub>a = \\<langle>\\<rho> \\<circ> \\<sigma>\\<rangle>\\<^sub>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>\\<sigma>\\<rceil>\\<^sub>s \\<dagger>\n    \\<langle>\\<rho>\\<rangle>\\<^sub>a =\n    \\<langle>\\<rho> \\<circ> \\<sigma>\\<rangle>\\<^sub>a", "by (rel_auto)"], ["", "lemma assigns_r_comp: \"(\\<langle>\\<sigma>\\<rangle>\\<^sub>a ;; P) = (\\<lceil>\\<sigma>\\<rceil>\\<^sub>s \\<dagger> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<sigma>\\<rangle>\\<^sub>a ;; P =\n    \\<lceil>\\<sigma>\\<rceil>\\<^sub>s \\<dagger> P", "by (rel_auto)"], ["", "lemma assigns_r_feasible:\n  \"(\\<langle>\\<sigma>\\<rangle>\\<^sub>a ;; true) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<sigma>\\<rangle>\\<^sub>a ;; true = true", "by (rel_auto)"], ["", "lemma assign_subst [usubst]:\n  \"\\<lbrakk> mwb_lens x; mwb_lens y \\<rbrakk> \\<Longrightarrow> [$x \\<mapsto>\\<^sub>s \\<lceil>u\\<rceil>\\<^sub><] \\<dagger> (y := v) = (x, y) := (u, [x \\<mapsto>\\<^sub>s u] \\<dagger> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens x; mwb_lens y\\<rbrakk>\n    \\<Longrightarrow> (y :=\n                       v)\\<lbrakk>\\<lceil>u\\<rceil>\\<^sub></$x\\<rbrakk> =\n                      x, y := u, v\\<lbrakk>u/x\\<rbrakk>", "by (rel_auto)"], ["", "lemma assign_vacuous_skip:\n  assumes \"vwb_lens x\"\n  shows \"(x := &x) = II\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x := &x = II", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. x := &x = II", "by rel_auto"], ["", "text \\<open> The following law shows the case for the above law when $x$ is only mainly-well behaved. We\n  require that the state is one of those in which $x$ is well defined using and assumption. \\<close>"], ["", "lemma assign_vacuous_assume:\n  assumes \"mwb_lens x\"\n  shows \"[(&\\<^bold>v \\<in>\\<^sub>u \\<guillemotleft>\\<S>\\<^bsub>x\\<^esub>\\<guillemotright>)]\\<^sup>\\<top> ;; (x := &x) = [(&\\<^bold>v \\<in>\\<^sub>u \\<guillemotleft>\\<S>\\<^bsub>x\\<^esub>\\<guillemotright>)]\\<^sup>\\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ?[&\\<^bold>v \\<in>\\<^sub>u\n      \\<guillemotleft>\\<S>\\<^bsub>x\\<^esub>\\<guillemotright>] ;;\n    x := &x =\n    ?[&\\<^bold>v \\<in>\\<^sub>u\n      \\<guillemotleft>\\<S>\\<^bsub>x\\<^esub>\\<guillemotright>]", "using assms"], ["proof (prove)\nusing this:\n  mwb_lens x\n\ngoal (1 subgoal):\n 1. ?[&\\<^bold>v \\<in>\\<^sub>u\n      \\<guillemotleft>\\<S>\\<^bsub>x\\<^esub>\\<guillemotright>] ;;\n    x := &x =\n    ?[&\\<^bold>v \\<in>\\<^sub>u\n      \\<guillemotleft>\\<S>\\<^bsub>x\\<^esub>\\<guillemotright>]", "by rel_auto"], ["", "lemma assign_simultaneous:\n  assumes \"vwb_lens y\" \"x \\<bowtie> y\"\n  shows \"(x,y) := (e, &y) = (x := e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x, y := e, &y = x := e", "by (simp add: assms usubst_upd_comm usubst_upd_var_id)"], ["", "lemma assigns_idem: \"mwb_lens x \\<Longrightarrow> (x,x) := (u,v) = (x := v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow> x, x := u, v = x := v", "by (simp add: usubst)"], ["", "lemma assigns_comp: \"(\\<langle>f\\<rangle>\\<^sub>a ;; \\<langle>g\\<rangle>\\<^sub>a) = \\<langle>g \\<circ> f\\<rangle>\\<^sub>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>f\\<rangle>\\<^sub>a ;; \\<langle>g\\<rangle>\\<^sub>a =\n    \\<langle>g \\<circ> f\\<rangle>\\<^sub>a", "by (simp add: assigns_r_comp usubst)"], ["", "lemma assigns_cond: \"(\\<langle>f\\<rangle>\\<^sub>a \\<triangleleft> b \\<triangleright>\\<^sub>r \\<langle>g\\<rangle>\\<^sub>a) = \\<langle>f \\<triangleleft> b \\<triangleright>\\<^sub>s g\\<rangle>\\<^sub>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>f\\<rangle>\\<^sub>a \\<triangleleft> b \\<triangleright>\\<^sub>r\n       \\<langle>g\\<rangle>\\<^sub>a =\n    \\<langle>f \\<triangleleft> b \\<triangleright>\\<^sub>s g\\<rangle>\\<^sub>a", "by (rel_auto)"], ["", "lemma assigns_r_conv:\n  \"bij f \\<Longrightarrow> \\<langle>f\\<rangle>\\<^sub>a\\<^sup>- = \\<langle>inv f\\<rangle>\\<^sub>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij f \\<Longrightarrow>\n    \\<langle>f\\<rangle>\\<^sub>a\\<^sup>- = \\<langle>inv f\\<rangle>\\<^sub>a", "by (rel_auto, simp_all add: bij_is_inj bij_is_surj surj_f_inv_f)"], ["", "lemma assign_pred_transfer:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"$x \\<sharp> b\" \"out\\<alpha> \\<sharp> b\"\n  shows \"(b \\<and> x := v) = (x := v \\<and> b\\<^sup>-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<and> x := v) = (x := v \\<and> b\\<^sup>-)", "using assms"], ["proof (prove)\nusing this:\n  $x \\<sharp> b\n  out\\<alpha> \\<sharp> b\n\ngoal (1 subgoal):\n 1. (b \\<and> x := v) = (x := v \\<and> b\\<^sup>-)", "by (rel_blast)"], ["", "lemma assign_r_comp: \"x := u ;; P = P\\<lbrakk>\\<lceil>u\\<rceil>\\<^sub></$x\\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x := u ;; P = P\\<lbrakk>\\<lceil>u\\<rceil>\\<^sub></$x\\<rbrakk>", "by (simp add: assigns_r_comp usubst alpha)"], ["", "lemma assign_test: \"mwb_lens x \\<Longrightarrow> (x := \\<guillemotleft>u\\<guillemotright> ;; x := \\<guillemotleft>v\\<guillemotright>) = (x := \\<guillemotleft>v\\<guillemotright>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow>\n    x := \\<guillemotleft>u\\<guillemotright> ;;\n    x := \\<guillemotleft>v\\<guillemotright> =\n    x := \\<guillemotleft>v\\<guillemotright>", "by (simp add: assigns_comp usubst)"], ["", "lemma assign_twice: \"\\<lbrakk> mwb_lens x; x \\<sharp> f \\<rbrakk> \\<Longrightarrow> (x := e ;; x := f) = (x := f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens x; x \\<sharp> f\\<rbrakk>\n    \\<Longrightarrow> x := e ;; x := f = x := f", "by (simp add: assigns_comp usubst unrest)"], ["", "lemma assign_commute:\n  assumes \"x \\<bowtie> y\" \"x \\<sharp> f\" \"y \\<sharp> e\"\n  shows \"(x := e ;; y := f) = (y := f ;; x := e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x := e ;; y := f = y := f ;; x := e", "using assms"], ["proof (prove)\nusing this:\n  x \\<bowtie> y\n  x \\<sharp> f\n  y \\<sharp> e\n\ngoal (1 subgoal):\n 1. x := e ;; y := f = y := f ;; x := e", "by (rel_simp, simp_all add: lens_indep_comm)"], ["", "lemma assign_cond:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"out\\<alpha> \\<sharp> b\"\n  shows \"(x := e ;; (P \\<triangleleft> b \\<triangleright> Q)) = ((x := e ;; P) \\<triangleleft> (b\\<lbrakk>\\<lceil>e\\<rceil>\\<^sub></$x\\<rbrakk>) \\<triangleright> (x := e ;; Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x := e ;; (P \\<triangleleft> b \\<triangleright> Q) =\n    x := e ;;\n    P \\<triangleleft> b\\<lbrakk>\\<lceil>e\\<rceil>\\<^sub></$x\\<rbrakk> \\<triangleright>\n       x := e ;; Q", "by (rel_auto)"], ["", "lemma assign_rcond:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"(x := e ;; (P \\<triangleleft> b \\<triangleright>\\<^sub>r Q)) = ((x := e ;; P) \\<triangleleft> (b\\<lbrakk>e/x\\<rbrakk>) \\<triangleright>\\<^sub>r (x := e ;; Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x := e ;; (P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) =\n    x := e ;;\n    P \\<triangleleft> b\\<lbrakk>e/x\\<rbrakk> \\<triangleright>\\<^sub>r\n       x := e ;; Q", "by (rel_auto)"], ["", "lemma assign_r_alt_def:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"x := v = II\\<lbrakk>\\<lceil>v\\<rceil>\\<^sub></$x\\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x := v = II\\<lbrakk>\\<lceil>v\\<rceil>\\<^sub></$x\\<rbrakk>", "by (rel_auto)"], ["", "lemma assigns_r_ufunc: \"ufunctional \\<langle>f\\<rangle>\\<^sub>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ufunctional \\<langle>f\\<rangle>\\<^sub>a", "by (rel_auto)"], ["", "lemma assigns_r_uinj: \"inj f \\<Longrightarrow> uinj \\<langle>f\\<rangle>\\<^sub>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f \\<Longrightarrow> uinj \\<langle>f\\<rangle>\\<^sub>a", "by (rel_simp, simp add: inj_eq)"], ["", "lemma assigns_r_swap_uinj:\n  \"\\<lbrakk> vwb_lens x; vwb_lens y; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> uinj ((x,y) := (&y,&x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens x; vwb_lens y; x \\<bowtie> y\\<rbrakk>\n    \\<Longrightarrow> uinj (x, y := &y, &x)", "by (metis assigns_r_uinj pr_var_def swap_usubst_inj)"], ["", "lemma assign_unfold:\n  \"vwb_lens x \\<Longrightarrow> (x := v) = ($x\\<acute> =\\<^sub>u \\<lceil>v\\<rceil>\\<^sub>< \\<and> II\\<restriction>\\<^sub>\\<alpha>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow>\n    x := v =\n    ($x\\<acute> =\\<^sub>u \\<lceil>v\\<rceil>\\<^sub>< \\<and>\n     II \\<restriction>\\<^sub>\\<alpha> x)", "apply (rel_auto, auto simp add: comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b va vaa.\n       \\<lbrakk>vwb_lens x;\n        get\\<^bsub>x\\<^esub> b = \\<lbrakk>v\\<rbrakk>\\<^sub>e a;\n        put\\<^bsub>x\\<^esub> b vaa = put\\<^bsub>x\\<^esub> a va\\<rbrakk>\n       \\<Longrightarrow> b =\n                         put\\<^bsub>x\\<^esub> a\n                          (\\<lbrakk>v\\<rbrakk>\\<^sub>e a)", "using vwb_lens.put_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>vwb_lens ?x; get\\<^bsub>?x\\<^esub> ?\\<sigma> = ?k;\n   put\\<^bsub>?x\\<^esub> ?\\<sigma> ?u =\n   put\\<^bsub>?x\\<^esub> ?\\<rho> ?v\\<rbrakk>\n  \\<Longrightarrow> put\\<^bsub>?x\\<^esub> ?\\<rho> ?k = ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>a b va vaa.\n       \\<lbrakk>vwb_lens x;\n        get\\<^bsub>x\\<^esub> b = \\<lbrakk>v\\<rbrakk>\\<^sub>e a;\n        put\\<^bsub>x\\<^esub> b vaa = put\\<^bsub>x\\<^esub> a va\\<rbrakk>\n       \\<Longrightarrow> b =\n                         put\\<^bsub>x\\<^esub> a\n                          (\\<lbrakk>v\\<rbrakk>\\<^sub>e a)", "by fastforce"], ["", "subsection \\<open> Non-deterministic Assignment Laws \\<close>"], ["", "lemma nd_assign_comp:\n  \"x \\<bowtie> y \\<Longrightarrow> x := * ;; y := * = x,y := *\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bowtie> y \\<Longrightarrow> x := * ;; y := * = x +\\<^sub>L y := *", "apply (rel_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xa xaa.\n       x \\<bowtie> y \\<Longrightarrow>\n       \\<exists>aa b.\n          put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> a xa) xaa =\n          put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a b) aa\n 2. \\<And>a aa ba.\n       x \\<bowtie> y \\<Longrightarrow>\n       \\<exists>ya.\n          (\\<exists>xa. ya = put\\<^bsub>x\\<^esub> a xa) \\<and>\n          (\\<exists>xa.\n              put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a ba) aa =\n              put\\<^bsub>y\\<^esub> ya xa)", "using lens_indep_comm"], ["proof (prove)\nusing this:\n  ?x \\<bowtie> ?y \\<Longrightarrow>\n  put\\<^bsub>?x\\<^esub> (put\\<^bsub>?y\\<^esub> ?\\<sigma> ?v) ?u =\n  put\\<^bsub>?y\\<^esub> (put\\<^bsub>?x\\<^esub> ?\\<sigma> ?u) ?v\n\ngoal (2 subgoals):\n 1. \\<And>a xa xaa.\n       x \\<bowtie> y \\<Longrightarrow>\n       \\<exists>aa b.\n          put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> a xa) xaa =\n          put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a b) aa\n 2. \\<And>a aa ba.\n       x \\<bowtie> y \\<Longrightarrow>\n       \\<exists>ya.\n          (\\<exists>xa. ya = put\\<^bsub>x\\<^esub> a xa) \\<and>\n          (\\<exists>xa.\n              put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a ba) aa =\n              put\\<^bsub>y\\<^esub> ya xa)", "by fastforce+"], ["", "lemma nd_assign_assign:\n  \"\\<lbrakk> vwb_lens x; x \\<sharp> e \\<rbrakk> \\<Longrightarrow> x := * ;; x := e = x := e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens x; x \\<sharp> e\\<rbrakk>\n    \\<Longrightarrow> x := * ;; x := e = x := e", "by (rel_auto)"], ["", "subsection \\<open> Converse Laws \\<close>"], ["", "lemma convr_invol [simp]: \"p\\<^sup>-\\<^sup>- = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<^sup>-\\<^sup>- = p", "by pred_auto"], ["", "lemma lit_convr [simp]: \"\\<guillemotleft>v\\<guillemotright>\\<^sup>- = \\<guillemotleft>v\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>v\\<guillemotright>\\<^sup>- =\n    \\<guillemotleft>v\\<guillemotright>", "by pred_auto"], ["", "lemma uivar_convr [simp]:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"($x)\\<^sup>- = $x\\<acute>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. $x\\<^sup>- = $x\\<acute>", "by pred_auto"], ["", "lemma uovar_convr [simp]:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"($x\\<acute>)\\<^sup>- = $x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. $x\\<acute>\\<^sup>- = $x", "by pred_auto"], ["", "lemma uop_convr [simp]: \"(uop f u)\\<^sup>- = uop f (u\\<^sup>-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uop f u\\<^sup>- = uop f (u\\<^sup>-)", "by (pred_auto)"], ["", "lemma bop_convr [simp]: \"(bop f u v)\\<^sup>- = bop f (u\\<^sup>-) (v\\<^sup>-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bop f u v\\<^sup>- = bop f (u\\<^sup>-) (v\\<^sup>-)", "by (pred_auto)"], ["", "lemma eq_convr [simp]: \"(p =\\<^sub>u q)\\<^sup>- = (p\\<^sup>- =\\<^sub>u q\\<^sup>-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p =\\<^sub>u q)\\<^sup>- = (p\\<^sup>- =\\<^sub>u q\\<^sup>-)", "by (pred_auto)"], ["", "lemma not_convr [simp]: \"(\\<not> p)\\<^sup>- = (\\<not> p\\<^sup>-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> p)\\<^sup>- = (\\<not> p\\<^sup>-)", "by (pred_auto)"], ["", "lemma disj_convr [simp]: \"(p \\<or> q)\\<^sup>- = (q\\<^sup>- \\<or> p\\<^sup>-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<or> q)\\<^sup>- = (q\\<^sup>- \\<or> p\\<^sup>-)", "by (pred_auto)"], ["", "lemma conj_convr [simp]: \"(p \\<and> q)\\<^sup>- = (q\\<^sup>- \\<and> p\\<^sup>-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<and> q)\\<^sup>- = (q\\<^sup>- \\<and> p\\<^sup>-)", "by (pred_auto)"], ["", "lemma seqr_convr [simp]: \"(p ;; q)\\<^sup>- = (q\\<^sup>- ;; p\\<^sup>-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p ;; q)\\<^sup>- = q\\<^sup>- ;; p\\<^sup>-", "by (rel_auto)"], ["", "lemma pre_convr [simp]: \"\\<lceil>p\\<rceil>\\<^sub><\\<^sup>- = \\<lceil>p\\<rceil>\\<^sub>>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>p\\<rceil>\\<^sub><\\<^sup>- = \\<lceil>p\\<rceil>\\<^sub>>", "by (rel_auto)"], ["", "lemma post_convr [simp]: \"\\<lceil>p\\<rceil>\\<^sub>>\\<^sup>- = \\<lceil>p\\<rceil>\\<^sub><\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>p\\<rceil>\\<^sub>>\\<^sup>- = \\<lceil>p\\<rceil>\\<^sub><", "by (rel_auto)"], ["", "subsection \\<open> Assertion and Assumption Laws \\<close>"], ["", "declare sublens_def [lens_defs del]"], ["", "lemma assume_false: \"[false]\\<^sup>\\<top> = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ?[false] = false", "by (rel_auto)"], ["", "lemma assume_true: \"[true]\\<^sup>\\<top> = II\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ?[true] = II", "by (rel_auto)"], ["", "lemma assume_seq: \"[b]\\<^sup>\\<top> ;; [c]\\<^sup>\\<top> = [(b \\<and> c)]\\<^sup>\\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ?[b] ;; ?[c] = ?[b \\<and> c]", "by (rel_auto)"], ["", "lemma assert_false: \"{false}\\<^sub>\\<bottom> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {false}\\<^sub>\\<bottom> = true", "by (rel_auto)"], ["", "lemma assert_true: \"{true}\\<^sub>\\<bottom> = II\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {true}\\<^sub>\\<bottom> = II", "by (rel_auto)"], ["", "lemma assert_seq: \"{b}\\<^sub>\\<bottom> ;; {c}\\<^sub>\\<bottom> = {(b \\<and> c)}\\<^sub>\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {b}\\<^sub>\\<bottom> ;; {c}\\<^sub>\\<bottom> =\n    {b \\<and> c}\\<^sub>\\<bottom>", "by (rel_auto)"], ["", "subsection \\<open> Frame and Antiframe Laws \\<close>"], ["", "named_theorems frame"], ["", "lemma frame_all [frame]: \"\\<Sigma>:[P] = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<Sigma>}:[P] = P", "by (rel_auto)"], ["", "lemma frame_none [frame]: \n  \"\\<emptyset>:[P] = (P \\<and> II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<emptyset>}:[P] = (P \\<and> II)", "by (rel_auto)"], ["", "lemma frame_commute:\n  assumes \"$y \\<sharp> P\" \"$y\\<acute> \\<sharp> P\" \"$x \\<sharp> Q\" \"$x\\<acute> \\<sharp> Q\" \"x \\<bowtie> y\" \n  shows \"x:[P] ;; y:[Q] = y:[Q] ;; x:[P]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x}:[P] ;; {y}:[Q] = {y}:[Q] ;; {x}:[P]", "apply (insert assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>$y \\<sharp> P; $y\\<acute> \\<sharp> P; $x \\<sharp> Q;\n     $x\\<acute> \\<sharp> Q; x \\<bowtie> y\\<rbrakk>\n    \\<Longrightarrow> {x}:[P] ;; {y}:[Q] = {y}:[Q] ;; {x}:[P]", "apply (rel_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ya.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, ya);\n        ya = put\\<^bsub>x\\<^esub> a (get\\<^bsub>x\\<^esub> ya);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (ya, b);\n        b = put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, ya) \\<and>\n                            ya =\n                            put\\<^bsub>y\\<^esub> a\n                             (get\\<^bsub>y\\<^esub> ya) \\<and>\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e (ya, b) \\<and>\n                            b =\n                            put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\n 2. \\<And>a b ya.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (ya, b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> a\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e (ya, b) \\<and>\n                            b =\n                            put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)", "apply (rename_tac s s' s\\<^sub>0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' s\\<^sub>0.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>P\\<rbrakk>\\<^sub>e (s, s\\<^sub>0);\n        s\\<^sub>0 = put\\<^bsub>x\\<^esub> s (get\\<^bsub>x\\<^esub> s\\<^sub>0);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (s\\<^sub>0, s');\n        s' =\n        put\\<^bsub>y\\<^esub> s\\<^sub>0 (get\\<^bsub>y\\<^esub> s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e (s, ya) \\<and>\n                            ya =\n                            put\\<^bsub>y\\<^esub> s\n                             (get\\<^bsub>y\\<^esub> ya) \\<and>\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e (ya, s') \\<and>\n                            s' =\n                            put\\<^bsub>x\\<^esub> ya\n                             (get\\<^bsub>x\\<^esub> s')\n 2. \\<And>a b ya.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (ya, b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> a\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e (ya, b) \\<and>\n                            b =\n                            put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)", "apply (subgoal_tac \"(s \\<oplus>\\<^sub>L s' on y) \\<oplus>\\<^sub>L s\\<^sub>0 on x = s\\<^sub>0 \\<oplus>\\<^sub>L s' on y\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s' s\\<^sub>0.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>P\\<rbrakk>\\<^sub>e (s, s\\<^sub>0);\n        s\\<^sub>0 = put\\<^bsub>x\\<^esub> s (get\\<^bsub>x\\<^esub> s\\<^sub>0);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (s\\<^sub>0, s');\n        s' = put\\<^bsub>y\\<^esub> s\\<^sub>0 (get\\<^bsub>y\\<^esub> s');\n        s \\<triangleleft>\\<^bsub>y\\<^esub>\n        s' \\<triangleleft>\\<^bsub>x\\<^esub>\n        s\\<^sub>0 =\n        s\\<^sub>0 \\<triangleleft>\\<^bsub>y\\<^esub> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e (s, ya) \\<and>\n                            ya =\n                            put\\<^bsub>y\\<^esub> s\n                             (get\\<^bsub>y\\<^esub> ya) \\<and>\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e (ya, s') \\<and>\n                            s' =\n                            put\\<^bsub>x\\<^esub> ya\n                             (get\\<^bsub>x\\<^esub> s')\n 2. \\<And>s s' s\\<^sub>0.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>P\\<rbrakk>\\<^sub>e (s, s\\<^sub>0);\n        s\\<^sub>0 = put\\<^bsub>x\\<^esub> s (get\\<^bsub>x\\<^esub> s\\<^sub>0);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (s\\<^sub>0, s');\n        s' =\n        put\\<^bsub>y\\<^esub> s\\<^sub>0 (get\\<^bsub>y\\<^esub> s')\\<rbrakk>\n       \\<Longrightarrow> s \\<triangleleft>\\<^bsub>y\\<^esub>\n                         s' \\<triangleleft>\\<^bsub>x\\<^esub>\n                         s\\<^sub>0 =\n                         s\\<^sub>0 \\<triangleleft>\\<^bsub>y\\<^esub> s'\n 3. \\<And>a b ya.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (ya, b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> a\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e (ya, b) \\<and>\n                            b =\n                            put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)", "apply (metis lens_indep_get lens_indep_sym lens_override_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' s\\<^sub>0.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>P\\<rbrakk>\\<^sub>e (s, s\\<^sub>0);\n        s\\<^sub>0 = put\\<^bsub>x\\<^esub> s (get\\<^bsub>x\\<^esub> s\\<^sub>0);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (s\\<^sub>0, s');\n        s' =\n        put\\<^bsub>y\\<^esub> s\\<^sub>0 (get\\<^bsub>y\\<^esub> s')\\<rbrakk>\n       \\<Longrightarrow> s \\<triangleleft>\\<^bsub>y\\<^esub>\n                         s' \\<triangleleft>\\<^bsub>x\\<^esub>\n                         s\\<^sub>0 =\n                         s\\<^sub>0 \\<triangleleft>\\<^bsub>y\\<^esub> s'\n 2. \\<And>a b ya.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (ya, b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> a\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e (ya, b) \\<and>\n                            b =\n                            put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)", "apply (simp add: lens_indep.lens_put_comm lens_override_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ya.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (ya, b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> a\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e (ya, b) \\<and>\n                            b =\n                            put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)", "apply (rename_tac s s' s\\<^sub>0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' s\\<^sub>0.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>Q\\<rbrakk>\\<^sub>e (s, s\\<^sub>0);\n        s\\<^sub>0 = put\\<^bsub>y\\<^esub> s (get\\<^bsub>y\\<^esub> s\\<^sub>0);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (s\\<^sub>0, s');\n        s' =\n        put\\<^bsub>x\\<^esub> s\\<^sub>0 (get\\<^bsub>x\\<^esub> s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e (s, ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> s\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e (ya, s') \\<and>\n                            s' =\n                            put\\<^bsub>y\\<^esub> ya\n                             (get\\<^bsub>y\\<^esub> s')", "apply (subgoal_tac \"put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> s (get\\<^bsub>x\\<^esub> (put\\<^bsub>x\\<^esub> s\\<^sub>0 (get\\<^bsub>x\\<^esub> s')))) (get\\<^bsub>y\\<^esub> (put\\<^bsub>y\\<^esub> s (get\\<^bsub>y\\<^esub> s\\<^sub>0))) \n                      = put\\<^bsub>x\\<^esub> s\\<^sub>0 (get\\<^bsub>x\\<^esub> s')\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' s\\<^sub>0.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>Q\\<rbrakk>\\<^sub>e (s, s\\<^sub>0);\n        s\\<^sub>0 = put\\<^bsub>y\\<^esub> s (get\\<^bsub>y\\<^esub> s\\<^sub>0);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (s\\<^sub>0, s');\n        s' = put\\<^bsub>x\\<^esub> s\\<^sub>0 (get\\<^bsub>x\\<^esub> s');\n        put\\<^bsub>y\\<^esub>\n         (put\\<^bsub>x\\<^esub> s\n           (get\\<^bsub>x\\<^esub>\n             (put\\<^bsub>x\\<^esub> s\\<^sub>0 (get\\<^bsub>x\\<^esub> s'))))\n         (get\\<^bsub>y\\<^esub>\n           (put\\<^bsub>y\\<^esub> s (get\\<^bsub>y\\<^esub> s\\<^sub>0))) =\n        put\\<^bsub>x\\<^esub> s\\<^sub>0 (get\\<^bsub>x\\<^esub> s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e (s, ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> s\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e (ya, s') \\<and>\n                            s' =\n                            put\\<^bsub>y\\<^esub> ya\n                             (get\\<^bsub>y\\<^esub> s')\n 2. \\<And>s s' s\\<^sub>0.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>Q\\<rbrakk>\\<^sub>e (s, s\\<^sub>0);\n        s\\<^sub>0 = put\\<^bsub>y\\<^esub> s (get\\<^bsub>y\\<^esub> s\\<^sub>0);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (s\\<^sub>0, s');\n        s' =\n        put\\<^bsub>x\\<^esub> s\\<^sub>0 (get\\<^bsub>x\\<^esub> s')\\<rbrakk>\n       \\<Longrightarrow> put\\<^bsub>y\\<^esub>\n                          (put\\<^bsub>x\\<^esub> s\n                            (get\\<^bsub>x\\<^esub>\n                              (put\\<^bsub>x\\<^esub> s\\<^sub>0\n                                (get\\<^bsub>x\\<^esub> s'))))\n                          (get\\<^bsub>y\\<^esub>\n                            (put\\<^bsub>y\\<^esub> s\n                              (get\\<^bsub>y\\<^esub> s\\<^sub>0))) =\n                         put\\<^bsub>x\\<^esub> s\\<^sub>0\n                          (get\\<^bsub>x\\<^esub> s')", "apply (metis lens_indep_get lens_indep_sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' s\\<^sub>0.\n       \\<lbrakk>\\<forall>a b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                    (put\\<^bsub>y\\<^esub> a v, b) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        x \\<bowtie> y; \\<lbrakk>Q\\<rbrakk>\\<^sub>e (s, s\\<^sub>0);\n        s\\<^sub>0 = put\\<^bsub>y\\<^esub> s (get\\<^bsub>y\\<^esub> s\\<^sub>0);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (s\\<^sub>0, s');\n        s' =\n        put\\<^bsub>x\\<^esub> s\\<^sub>0 (get\\<^bsub>x\\<^esub> s')\\<rbrakk>\n       \\<Longrightarrow> put\\<^bsub>y\\<^esub>\n                          (put\\<^bsub>x\\<^esub> s\n                            (get\\<^bsub>x\\<^esub>\n                              (put\\<^bsub>x\\<^esub> s\\<^sub>0\n                                (get\\<^bsub>x\\<^esub> s'))))\n                          (get\\<^bsub>y\\<^esub>\n                            (put\\<^bsub>y\\<^esub> s\n                              (get\\<^bsub>y\\<^esub> s\\<^sub>0))) =\n                         put\\<^bsub>x\\<^esub> s\\<^sub>0\n                          (get\\<^bsub>x\\<^esub> s')", "apply (metis lens_indep.lens_put_comm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma frame_contract_RID:\n  assumes \"vwb_lens x\" \"P is RID(x)\" \"x \\<bowtie> y\"\n  shows \"(x;y):[P] = y:[P]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y}:[P] = {y}:[P]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {x, y}:[P] = {y}:[P]", "from assms(1,3)"], ["proof (chain)\npicking this:\n  vwb_lens x\n  x \\<bowtie> y", "have \"(x;y):[RID(x)(P)] = y:[RID(x)(P)]\""], ["proof (prove)\nusing this:\n  vwb_lens x\n  x \\<bowtie> y\n\ngoal (1 subgoal):\n 1. {x, y}:[RID x P] = {y}:[RID x P]", "apply (rel_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b v va.\n       \\<lbrakk>vwb_lens x; x \\<bowtie> y;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>x\\<^esub> a v, put\\<^bsub>x\\<^esub> b va);\n        get\\<^bsub>x\\<^esub> b = get\\<^bsub>x\\<^esub> a;\n        b =\n        put\\<^bsub>x\\<^esub>\n         (put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> b))\n         (get\\<^bsub>x\\<^esub> a)\\<rbrakk>\n       \\<Longrightarrow> b = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> b)\n 2. \\<And>a b v va.\n       \\<lbrakk>vwb_lens x; x \\<bowtie> y;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>x\\<^esub> a v, put\\<^bsub>x\\<^esub> b va);\n        get\\<^bsub>x\\<^esub> b = get\\<^bsub>x\\<^esub> a;\n        b = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> b = put\\<^bsub>x\\<^esub> b (get\\<^bsub>x\\<^esub> a)", "apply (simp add: lens_indep.lens_put_comm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b v va.\n       \\<lbrakk>vwb_lens x; x \\<bowtie> y;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>x\\<^esub> a v, put\\<^bsub>x\\<^esub> b va);\n        get\\<^bsub>x\\<^esub> b = get\\<^bsub>x\\<^esub> a;\n        b = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> b = put\\<^bsub>x\\<^esub> b (get\\<^bsub>x\\<^esub> a)", "apply (metis (no_types) vwb_lens_wb wb_lens.get_put)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {x, y}:[RID x P] = {y}:[RID x P]\n\ngoal (1 subgoal):\n 1. {x, y}:[P] = {y}:[P]", "thus ?thesis"], ["proof (prove)\nusing this:\n  {x, y}:[RID x P] = {y}:[RID x P]\n\ngoal (1 subgoal):\n 1. {x, y}:[P] = {y}:[P]", "by (simp add: Healthy_if assms)"], ["proof (state)\nthis:\n  {x, y}:[P] = {y}:[P]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frame_miracle [simp]:\n  \"x:[false] = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x}:[false] = false", "by (rel_auto)"], ["", "lemma frame_skip [simp]:\n  \"vwb_lens x \\<Longrightarrow> x:[II] = II\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow> {x}:[II] = II", "by (rel_auto)"], ["", "lemma frame_assign_in [frame]:\n  \"\\<lbrakk> vwb_lens a; x \\<subseteq>\\<^sub>L a \\<rbrakk> \\<Longrightarrow> a:[x := v] = x := v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens a; x \\<subseteq>\\<^sub>L a\\<rbrakk>\n    \\<Longrightarrow> {a}:[x := v] = x := v", "by (rel_auto, simp_all add: lens_get_put_quasi_commute lens_put_of_quotient)"], ["", "lemma frame_conj_true [frame]:\n  \"\\<lbrakk> {$x,$x\\<acute>} \\<natural> P; vwb_lens x \\<rbrakk> \\<Longrightarrow> (P \\<and> x:[true]) = x:[P]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{$x, $x\\<acute>} \\<natural> P; vwb_lens x\\<rbrakk>\n    \\<Longrightarrow> (P \\<and> {x}:[true]) = {x}:[P]", "by (rel_auto)"], ["", "lemma frame_is_assign [frame]:\n  \"vwb_lens x \\<Longrightarrow> x:[$x\\<acute> =\\<^sub>u \\<lceil>v\\<rceil>\\<^sub><] = x := v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow>\n    {x}:[$x\\<acute> =\\<^sub>u \\<lceil>v\\<rceil>\\<^sub><] = x := v", "by (rel_auto)"], ["", "lemma frame_seq [frame]:\n  \"\\<lbrakk> vwb_lens x; {$x,$x\\<acute>} \\<natural> P; {$x,$x\\<acute>} \\<natural> Q \\<rbrakk> \\<Longrightarrow> x:[P ;; Q] = x:[P] ;; x:[Q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens x; {$x, $x\\<acute>} \\<natural> P;\n     {$x, $x\\<acute>} \\<natural> Q\\<rbrakk>\n    \\<Longrightarrow> {x}:[P ;; Q] = {x}:[P] ;; {x}:[Q]", "apply (rel_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b y.\n       \\<lbrakk>vwb_lens x;\n        \\<forall>a b aa ba.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e\n            (put\\<^bsub>x\\<^esub> aa (get\\<^bsub>x\\<^esub> a),\n             put\\<^bsub>x\\<^esub> ba (get\\<^bsub>x\\<^esub> b)) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b aa ba.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n            (put\\<^bsub>x\\<^esub> aa (get\\<^bsub>x\\<^esub> a),\n             put\\<^bsub>x\\<^esub> ba (get\\<^bsub>x\\<^esub> b)) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        b = put\\<^bsub>x\\<^esub> a (get\\<^bsub>x\\<^esub> b);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, y);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (y, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, y) \\<and>\n                            y =\n                            put\\<^bsub>x\\<^esub> a\n                             (get\\<^bsub>x\\<^esub> y) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e (y, b) \\<and>\n                            b =\n                            put\\<^bsub>x\\<^esub> y (get\\<^bsub>x\\<^esub> b)\n 2. \\<And>a b y.\n       \\<lbrakk>vwb_lens x;\n        \\<forall>a b aa ba.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e\n            (put\\<^bsub>x\\<^esub> aa (get\\<^bsub>x\\<^esub> a),\n             put\\<^bsub>x\\<^esub> ba (get\\<^bsub>x\\<^esub> b)) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b aa ba.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n            (put\\<^bsub>x\\<^esub> aa (get\\<^bsub>x\\<^esub> a),\n             put\\<^bsub>x\\<^esub> ba (get\\<^bsub>x\\<^esub> b)) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, y);\n        y = put\\<^bsub>x\\<^esub> a (get\\<^bsub>x\\<^esub> y);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (y, b);\n        b = put\\<^bsub>x\\<^esub> y (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> b = put\\<^bsub>x\\<^esub> a (get\\<^bsub>x\\<^esub> b)", "apply (metis mwb_lens.put_put vwb_lens_mwb vwb_lens_wb wb_lens_def weak_lens.put_get)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>vwb_lens x;\n        \\<forall>a b aa ba.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e\n            (put\\<^bsub>x\\<^esub> aa (get\\<^bsub>x\\<^esub> a),\n             put\\<^bsub>x\\<^esub> ba (get\\<^bsub>x\\<^esub> b)) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b aa ba.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n            (put\\<^bsub>x\\<^esub> aa (get\\<^bsub>x\\<^esub> a),\n             put\\<^bsub>x\\<^esub> ba (get\\<^bsub>x\\<^esub> b)) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, y);\n        y = put\\<^bsub>x\\<^esub> a (get\\<^bsub>x\\<^esub> y);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (y, b);\n        b = put\\<^bsub>x\\<^esub> y (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> b = put\\<^bsub>x\\<^esub> a (get\\<^bsub>x\\<^esub> b)", "apply (metis mwb_lens.put_put vwb_lens_mwb)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma frame_to_antiframe [frame]:\n  \"\\<lbrakk> x \\<bowtie> y; x +\\<^sub>L y = 1\\<^sub>L \\<rbrakk> \\<Longrightarrow> x:[P] = y:\\<lbrakk>P\\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<bowtie> y; x +\\<^sub>L y = \\<Sigma>\\<rbrakk>\n    \\<Longrightarrow> {x}:[P] = {y}:\\<lbrakk>P\\<rbrakk>", "by (rel_auto, metis lens_indep_def, metis lens_indep_def surj_pair)"], ["", "lemma rel_frext_miracle [frame]: \n  \"a:[false]\\<^sup>+ = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a:[false]\\<^sup>+ = false", "by (rel_auto)"], ["", "lemma rel_frext_skip [frame]: \n  \"vwb_lens a \\<Longrightarrow> a:[II]\\<^sup>+ = II\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens a \\<Longrightarrow> a:[II]\\<^sup>+ = II", "by (rel_auto)"], ["", "lemma rel_frext_seq [frame]:\n  \"vwb_lens a \\<Longrightarrow> a:[P ;; Q]\\<^sup>+ = (a:[P]\\<^sup>+ ;; a:[Q]\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens a \\<Longrightarrow>\n    a:[P ;; Q]\\<^sup>+ = a:[P]\\<^sup>+ ;; a:[Q]\\<^sup>+", "apply (rel_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b y.\n       \\<lbrakk>vwb_lens a;\n        b = put\\<^bsub>a\\<^esub> aa (get\\<^bsub>a\\<^esub> b);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (get\\<^bsub>a\\<^esub> aa, y);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (y, get\\<^bsub>a\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>a\\<^esub> aa,\n                              get\\<^bsub>a\\<^esub> y) \\<and>\n                            y =\n                            put\\<^bsub>a\\<^esub> aa\n                             (get\\<^bsub>a\\<^esub> y) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>a\\<^esub> y,\n                              get\\<^bsub>a\\<^esub> b) \\<and>\n                            b =\n                            put\\<^bsub>a\\<^esub> y (get\\<^bsub>a\\<^esub> b)\n 2. \\<And>aa b y.\n       \\<lbrakk>vwb_lens a;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>a\\<^esub> aa, get\\<^bsub>a\\<^esub> y);\n        y = put\\<^bsub>a\\<^esub> aa (get\\<^bsub>a\\<^esub> y);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>a\\<^esub> y, get\\<^bsub>a\\<^esub> b);\n        b = put\\<^bsub>a\\<^esub> y (get\\<^bsub>a\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> b =\n                         put\\<^bsub>a\\<^esub> aa (get\\<^bsub>a\\<^esub> b)", "apply (rename_tac s s' s\\<^sub>0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' s\\<^sub>0.\n       \\<lbrakk>vwb_lens a;\n        s' = put\\<^bsub>a\\<^esub> s (get\\<^bsub>a\\<^esub> s');\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (get\\<^bsub>a\\<^esub> s, s\\<^sub>0);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (s\\<^sub>0, get\\<^bsub>a\\<^esub> s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>a\\<^esub> s,\n                              get\\<^bsub>a\\<^esub> y) \\<and>\n                            y =\n                            put\\<^bsub>a\\<^esub> s\n                             (get\\<^bsub>a\\<^esub> y) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>a\\<^esub> y,\n                              get\\<^bsub>a\\<^esub> s') \\<and>\n                            s' =\n                            put\\<^bsub>a\\<^esub> y (get\\<^bsub>a\\<^esub> s')\n 2. \\<And>aa b y.\n       \\<lbrakk>vwb_lens a;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>a\\<^esub> aa, get\\<^bsub>a\\<^esub> y);\n        y = put\\<^bsub>a\\<^esub> aa (get\\<^bsub>a\\<^esub> y);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>a\\<^esub> y, get\\<^bsub>a\\<^esub> b);\n        b = put\\<^bsub>a\\<^esub> y (get\\<^bsub>a\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> b =\n                         put\\<^bsub>a\\<^esub> aa (get\\<^bsub>a\\<^esub> b)", "apply (rule_tac x=\"put\\<^bsub>a\\<^esub> s s\\<^sub>0\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' s\\<^sub>0.\n       \\<lbrakk>vwb_lens a;\n        s' = put\\<^bsub>a\\<^esub> s (get\\<^bsub>a\\<^esub> s');\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (get\\<^bsub>a\\<^esub> s, s\\<^sub>0);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (s\\<^sub>0, get\\<^bsub>a\\<^esub> s')\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                          (get\\<^bsub>a\\<^esub> s,\n                           get\\<^bsub>a\\<^esub>\n                            (put\\<^bsub>a\\<^esub> s s\\<^sub>0)) \\<and>\n                         put\\<^bsub>a\\<^esub> s s\\<^sub>0 =\n                         put\\<^bsub>a\\<^esub> s\n                          (get\\<^bsub>a\\<^esub>\n                            (put\\<^bsub>a\\<^esub> s s\\<^sub>0)) \\<and>\n                         \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                          (get\\<^bsub>a\\<^esub>\n                            (put\\<^bsub>a\\<^esub> s s\\<^sub>0),\n                           get\\<^bsub>a\\<^esub> s') \\<and>\n                         s' =\n                         put\\<^bsub>a\\<^esub>\n                          (put\\<^bsub>a\\<^esub> s s\\<^sub>0)\n                          (get\\<^bsub>a\\<^esub> s')\n 2. \\<And>aa b y.\n       \\<lbrakk>vwb_lens a;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>a\\<^esub> aa, get\\<^bsub>a\\<^esub> y);\n        y = put\\<^bsub>a\\<^esub> aa (get\\<^bsub>a\\<^esub> y);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>a\\<^esub> y, get\\<^bsub>a\\<^esub> b);\n        b = put\\<^bsub>a\\<^esub> y (get\\<^bsub>a\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> b =\n                         put\\<^bsub>a\\<^esub> aa (get\\<^bsub>a\\<^esub> b)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b y.\n       \\<lbrakk>vwb_lens a;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>a\\<^esub> aa, get\\<^bsub>a\\<^esub> y);\n        y = put\\<^bsub>a\\<^esub> aa (get\\<^bsub>a\\<^esub> y);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>a\\<^esub> y, get\\<^bsub>a\\<^esub> b);\n        b = put\\<^bsub>a\\<^esub> y (get\\<^bsub>a\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> b =\n                         put\\<^bsub>a\\<^esub> aa (get\\<^bsub>a\\<^esub> b)", "apply (metis mwb_lens.put_put vwb_lens_mwb)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rel_frext_assigns [frame]:\n  \"vwb_lens a \\<Longrightarrow> a:[\\<langle>\\<sigma>\\<rangle>\\<^sub>a]\\<^sup>+ = \\<langle>\\<sigma> \\<oplus>\\<^sub>s a\\<rangle>\\<^sub>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens a \\<Longrightarrow>\n    a:[\\<langle>\\<sigma>\\<rangle>\\<^sub>a]\\<^sup>+ =\n    \\<langle>\\<sigma> \\<oplus>\\<^sub>s a\\<rangle>\\<^sub>a", "by (rel_auto)"], ["", "lemma rel_frext_rcond [frame]:\n  \"a:[P \\<triangleleft> b \\<triangleright>\\<^sub>r Q]\\<^sup>+ = (a:[P]\\<^sup>+ \\<triangleleft> b \\<oplus>\\<^sub>p a \\<triangleright>\\<^sub>r a:[Q]\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a:[P \\<triangleleft> b \\<triangleright>\\<^sub>r Q]\\<^sup>+ =\n    a:[P]\\<^sup>+ \\<triangleleft> b \\<oplus>\\<^sub>p\n                                  a \\<triangleright>\\<^sub>r\n       a:[Q]\\<^sup>+", "by (rel_auto)"], ["", "lemma rel_frext_commute: \n  \"x \\<bowtie> y \\<Longrightarrow> x:[P]\\<^sup>+ ;; y:[Q]\\<^sup>+ = y:[Q]\\<^sup>+ ;; x:[P]\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bowtie> y \\<Longrightarrow>\n    x:[P]\\<^sup>+ ;; y:[Q]\\<^sup>+ = y:[Q]\\<^sup>+ ;; x:[P]\\<^sup>+", "apply (rel_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ya.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> a, get\\<^bsub>x\\<^esub> ya);\n        ya = put\\<^bsub>x\\<^esub> a (get\\<^bsub>x\\<^esub> ya);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> ya, get\\<^bsub>y\\<^esub> b);\n        b = put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>y\\<^esub> a,\n                              get\\<^bsub>y\\<^esub> ya) \\<and>\n                            ya =\n                            put\\<^bsub>y\\<^esub> a\n                             (get\\<^bsub>y\\<^esub> ya) \\<and>\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>x\\<^esub> ya,\n                              get\\<^bsub>x\\<^esub> b) \\<and>\n                            b =\n                            put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\n 2. \\<And>a b ya.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> a, get\\<^bsub>y\\<^esub> ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> ya, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>x\\<^esub> a,\n                              get\\<^bsub>x\\<^esub> ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> a\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>y\\<^esub> ya,\n                              get\\<^bsub>y\\<^esub> b) \\<and>\n                            b =\n                            put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)", "apply (rename_tac a c b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a c b.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> a, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> a (get\\<^bsub>x\\<^esub> b);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> b, get\\<^bsub>y\\<^esub> c);\n        c = put\\<^bsub>y\\<^esub> b (get\\<^bsub>y\\<^esub> c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>y\\<^esub> a,\n                              get\\<^bsub>y\\<^esub> ya) \\<and>\n                            ya =\n                            put\\<^bsub>y\\<^esub> a\n                             (get\\<^bsub>y\\<^esub> ya) \\<and>\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>x\\<^esub> ya,\n                              get\\<^bsub>x\\<^esub> c) \\<and>\n                            c =\n                            put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> c)\n 2. \\<And>a b ya.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> a, get\\<^bsub>y\\<^esub> ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> ya, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>x\\<^esub> a,\n                              get\\<^bsub>x\\<^esub> ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> a\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>y\\<^esub> ya,\n                              get\\<^bsub>y\\<^esub> b) \\<and>\n                            b =\n                            put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)", "apply (subgoal_tac \"\\<And>b a. get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> b a) = get\\<^bsub>y\\<^esub> b\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a c b.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> a, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> a (get\\<^bsub>x\\<^esub> b);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> b, get\\<^bsub>y\\<^esub> c);\n        c = put\\<^bsub>y\\<^esub> b (get\\<^bsub>y\\<^esub> c);\n        \\<And>b a.\n           get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> b a) =\n           get\\<^bsub>y\\<^esub> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>y\\<^esub> a,\n                              get\\<^bsub>y\\<^esub> ya) \\<and>\n                            ya =\n                            put\\<^bsub>y\\<^esub> a\n                             (get\\<^bsub>y\\<^esub> ya) \\<and>\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>x\\<^esub> ya,\n                              get\\<^bsub>x\\<^esub> c) \\<and>\n                            c =\n                            put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> c)\n 2. \\<And>a c b ba aa.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> a, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> a (get\\<^bsub>x\\<^esub> b);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> b, get\\<^bsub>y\\<^esub> c);\n        c = put\\<^bsub>y\\<^esub> b (get\\<^bsub>y\\<^esub> c)\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> ba aa) =\n                         get\\<^bsub>y\\<^esub> ba\n 3. \\<And>a b ya.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> a, get\\<^bsub>y\\<^esub> ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> ya, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>x\\<^esub> a,\n                              get\\<^bsub>x\\<^esub> ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> a\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>y\\<^esub> ya,\n                              get\\<^bsub>y\\<^esub> b) \\<and>\n                            b =\n                            put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)", "apply (metis (no_types, hide_lams) lens_indep_comm lens_indep_get)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a c b ba aa.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> a, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> a (get\\<^bsub>x\\<^esub> b);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> b, get\\<^bsub>y\\<^esub> c);\n        c = put\\<^bsub>y\\<^esub> b (get\\<^bsub>y\\<^esub> c)\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> ba aa) =\n                         get\\<^bsub>y\\<^esub> ba\n 2. \\<And>a b ya.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> a, get\\<^bsub>y\\<^esub> ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> ya, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>x\\<^esub> a,\n                              get\\<^bsub>x\\<^esub> ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> a\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>y\\<^esub> ya,\n                              get\\<^bsub>y\\<^esub> b) \\<and>\n                            b =\n                            put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)", "apply (simp add: lens_indep.lens_put_irr2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ya.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> a, get\\<^bsub>y\\<^esub> ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> ya, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>x\\<^esub> a,\n                              get\\<^bsub>x\\<^esub> ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> a\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>y\\<^esub> ya,\n                              get\\<^bsub>y\\<^esub> b) \\<and>\n                            b =\n                            put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)", "apply (subgoal_tac \"\\<And>b c. get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> b c) = get\\<^bsub>x\\<^esub> b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ya.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> a, get\\<^bsub>y\\<^esub> ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> ya, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b);\n        \\<And>b c.\n           get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> b c) =\n           get\\<^bsub>x\\<^esub> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>x\\<^esub> a,\n                              get\\<^bsub>x\\<^esub> ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> a\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>y\\<^esub> ya,\n                              get\\<^bsub>y\\<^esub> b) \\<and>\n                            b =\n                            put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)\n 2. \\<And>a b ya ba c.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> a, get\\<^bsub>y\\<^esub> ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> ya, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> ba c) =\n                         get\\<^bsub>x\\<^esub> ba", "apply (subgoal_tac \"\\<And>b a. get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> b a) = get\\<^bsub>y\\<^esub> b\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ya.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> a, get\\<^bsub>y\\<^esub> ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> ya, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b);\n        \\<And>b c.\n           get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> b c) =\n           get\\<^bsub>x\\<^esub> b;\n        \\<And>b a.\n           get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> b a) =\n           get\\<^bsub>y\\<^esub> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>x\\<^esub> a,\n                              get\\<^bsub>x\\<^esub> ya) \\<and>\n                            ya =\n                            put\\<^bsub>x\\<^esub> a\n                             (get\\<^bsub>x\\<^esub> ya) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n                             (get\\<^bsub>y\\<^esub> ya,\n                              get\\<^bsub>y\\<^esub> b) \\<and>\n                            b =\n                            put\\<^bsub>y\\<^esub> ya (get\\<^bsub>y\\<^esub> b)\n 2. \\<And>a b ya ba aa.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> a, get\\<^bsub>y\\<^esub> ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> ya, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b);\n        \\<And>b c.\n           get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> b c) =\n           get\\<^bsub>x\\<^esub> b\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> ba aa) =\n                         get\\<^bsub>y\\<^esub> ba\n 3. \\<And>a b ya ba c.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> a, get\\<^bsub>y\\<^esub> ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> ya, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> ba c) =\n                         get\\<^bsub>x\\<^esub> ba", "apply (metis (mono_tags, lifting) lens_indep_comm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ya ba aa.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> a, get\\<^bsub>y\\<^esub> ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> ya, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b);\n        \\<And>b c.\n           get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> b c) =\n           get\\<^bsub>x\\<^esub> b\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> ba aa) =\n                         get\\<^bsub>y\\<^esub> ba\n 2. \\<And>a b ya ba c.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>y\\<^esub> a, get\\<^bsub>y\\<^esub> ya);\n        ya = put\\<^bsub>y\\<^esub> a (get\\<^bsub>y\\<^esub> ya);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (get\\<^bsub>x\\<^esub> ya, get\\<^bsub>x\\<^esub> b);\n        b = put\\<^bsub>x\\<^esub> ya (get\\<^bsub>x\\<^esub> b)\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> ba c) =\n                         get\\<^bsub>x\\<^esub> ba", "apply (simp_all add: lens_indep.lens_put_irr2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma antiframe_disj [frame]: \"(x:\\<lbrakk>P\\<rbrakk> \\<or> x:\\<lbrakk>Q\\<rbrakk>) = x:\\<lbrakk>P \\<or> Q\\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({x}:\\<lbrakk>P\\<rbrakk> \\<or> {x}:\\<lbrakk>Q\\<rbrakk>) =\n    {x}:\\<lbrakk>P \\<or> Q\\<rbrakk>", "by (rel_auto)"], ["", "lemma antiframe_seq [frame]:\n  \"\\<lbrakk> vwb_lens x; $x\\<acute> \\<sharp> P; $x \\<sharp> Q \\<rbrakk>  \\<Longrightarrow> (x:\\<lbrakk>P\\<rbrakk> ;; x:\\<lbrakk>Q\\<rbrakk>) = x:\\<lbrakk>P ;; Q\\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens x; $x\\<acute> \\<sharp> P; $x \\<sharp> Q\\<rbrakk>\n    \\<Longrightarrow> {x}:\\<lbrakk>P\\<rbrakk> ;; {x}:\\<lbrakk>Q\\<rbrakk> =\n                      {x}:\\<lbrakk>P ;; Q\\<rbrakk>", "apply (rel_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b y.\n       \\<lbrakk>vwb_lens x;\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, y);\n        y = put\\<^bsub>x\\<^esub> y (get\\<^bsub>x\\<^esub> a);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (y, b);\n        b = put\\<^bsub>x\\<^esub> b (get\\<^bsub>x\\<^esub> y)\\<rbrakk>\n       \\<Longrightarrow> b = put\\<^bsub>x\\<^esub> b (get\\<^bsub>x\\<^esub> a)\n 2. \\<And>a b y.\n       \\<lbrakk>vwb_lens x;\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        b = put\\<^bsub>x\\<^esub> b (get\\<^bsub>x\\<^esub> a);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, y);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (y, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, y) \\<and>\n                            y =\n                            put\\<^bsub>x\\<^esub> y\n                             (get\\<^bsub>x\\<^esub> a) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e (y, b) \\<and>\n                            b =\n                            put\\<^bsub>x\\<^esub> b (get\\<^bsub>x\\<^esub> y)", "apply (metis vwb_lens_wb wb_lens_def weak_lens.put_get)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>vwb_lens x;\n        \\<forall>a b v.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, put\\<^bsub>x\\<^esub> b v) =\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, b);\n        \\<forall>a b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> a v, b) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (a, b);\n        b = put\\<^bsub>x\\<^esub> b (get\\<^bsub>x\\<^esub> a);\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, y);\n        \\<lbrakk>Q\\<rbrakk>\\<^sub>e (y, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e (a, y) \\<and>\n                            y =\n                            put\\<^bsub>x\\<^esub> y\n                             (get\\<^bsub>x\\<^esub> a) \\<and>\n                            \\<lbrakk>Q\\<rbrakk>\\<^sub>e (y, b) \\<and>\n                            b =\n                            put\\<^bsub>x\\<^esub> b (get\\<^bsub>x\\<^esub> y)", "apply (metis vwb_lens_wb wb_lens.put_twice wb_lens_def weak_lens.put_get)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nameset_skip: \"vwb_lens x \\<Longrightarrow> (ns x \\<bullet> II) = II\\<^bsub>x\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow> ns x \\<bullet> II = II\\<^bsub>x\\<^esub>", "by (rel_auto, meson vwb_lens_wb wb_lens.get_put)"], ["", "lemma nameset_skip_ra: \"vwb_lens x \\<Longrightarrow> (ns x \\<bullet> II\\<^bsub>x\\<^esub>) = II\\<^bsub>x\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow>\n    ns x \\<bullet> II\\<^bsub>x\\<^esub> = II\\<^bsub>x\\<^esub>", "by (rel_auto)"], ["", "declare sublens_def [lens_defs]"], ["", "subsection \\<open> While Loop Laws \\<close>"], ["", "theorem while_unfold:\n  \"while b do P od = ((P ;; while b do P od) \\<triangleleft> b \\<triangleright>\\<^sub>r II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    P ;;\n    while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    P ;;\n    while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "have m:\"mono (\\<lambda>X. (P ;; X) \\<triangleleft> b \\<triangleright>\\<^sub>r II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotonic\n     (\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "by (auto intro: monoI seqr_mono cond_mono)"], ["proof (state)\nthis:\n  Monotonic\n   (\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    P ;;\n    while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "have \"(while b do P od) = (\\<nu> X \\<bullet> (P ;; X) \\<triangleleft> b \\<triangleright>\\<^sub>r II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (\\<nu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "by (simp add: while_top_def)"], ["proof (state)\nthis:\n  while\\<^sup>\\<top> b do P od =\n  (\\<nu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    P ;;\n    while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "also"], ["proof (state)\nthis:\n  while\\<^sup>\\<top> b do P od =\n  (\\<nu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    P ;;\n    while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "have \"... = ((P ;; (\\<nu> X \\<bullet> (P ;; X) \\<triangleleft> b \\<triangleright>\\<^sub>r II)) \\<triangleleft> b \\<triangleright>\\<^sub>r II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r\n                          II) =\n    P ;;\n    (\\<nu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r\n                          II) \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "by (subst lfp_unfold, simp_all add: m)"], ["proof (state)\nthis:\n  (\\<nu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) =\n  P ;;\n  (\\<nu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r\n                        II) \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    P ;;\n    while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "also"], ["proof (state)\nthis:\n  (\\<nu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) =\n  P ;;\n  (\\<nu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r\n                        II) \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    P ;;\n    while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "have \"... = ((P ;; while b do P od) \\<triangleleft> b \\<triangleright>\\<^sub>r II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;;\n    (\\<nu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r\n                          II) \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II =\n    P ;;\n    while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "by (simp add: while_top_def)"], ["proof (state)\nthis:\n  P ;;\n  (\\<nu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r\n                        II) \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II =\n  P ;;\n  while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    P ;;\n    while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "finally"], ["proof (chain)\npicking this:\n  while\\<^sup>\\<top> b do P od =\n  P ;;\n  while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II", "show ?thesis"], ["proof (prove)\nusing this:\n  while\\<^sup>\\<top> b do P od =\n  P ;;\n  while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    P ;;\n    while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "."], ["proof (state)\nthis:\n  while\\<^sup>\\<top> b do P od =\n  P ;;\n  while\\<^sup>\\<top> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem while_false: \"while false do P od = II\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> false do P od = II", "by (subst while_unfold, rel_auto)"], ["", "theorem while_true: \"while true do P od = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> true do P od = false", "apply (simp add: while_top_def alpha)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> ((;;) P) = false", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. false \\<sqsubseteq> \\<nu> ((;;) P)\n 2. \\<nu> ((;;) P) \\<sqsubseteq> false", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. false \\<sqsubseteq> \\<nu> ((;;) P)", "apply (rule lfp_lowerbound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. false \\<sqsubseteq> P ;; false", "apply (rel_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem while_bot_unfold:\n  \"while\\<^sub>\\<bottom> b do P od = ((P ;; while\\<^sub>\\<bottom> b do P od) \\<triangleleft> b \\<triangleright>\\<^sub>r II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while\\<^sub>\\<bottom> b do P od =\n    P ;;\n    while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. while\\<^sub>\\<bottom> b do P od =\n    P ;;\n    while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "have m:\"mono (\\<lambda>X. (P ;; X) \\<triangleleft> b \\<triangleright>\\<^sub>r II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotonic\n     (\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "by (auto intro: monoI seqr_mono cond_mono)"], ["proof (state)\nthis:\n  Monotonic\n   (\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n\ngoal (1 subgoal):\n 1. while\\<^sub>\\<bottom> b do P od =\n    P ;;\n    while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "have \"(while\\<^sub>\\<bottom> b do P od) = (\\<mu> X \\<bullet> (P ;; X) \\<triangleleft> b \\<triangleright>\\<^sub>r II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while\\<^sub>\\<bottom> b do P od =\n    (\\<mu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "by (simp add: while_bot_def)"], ["proof (state)\nthis:\n  while\\<^sub>\\<bottom> b do P od =\n  (\\<mu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n\ngoal (1 subgoal):\n 1. while\\<^sub>\\<bottom> b do P od =\n    P ;;\n    while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "also"], ["proof (state)\nthis:\n  while\\<^sub>\\<bottom> b do P od =\n  (\\<mu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n\ngoal (1 subgoal):\n 1. while\\<^sub>\\<bottom> b do P od =\n    P ;;\n    while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "have \"... = ((P ;; (\\<mu> X \\<bullet> (P ;; X) \\<triangleleft> b \\<triangleright>\\<^sub>r II)) \\<triangleleft> b \\<triangleright>\\<^sub>r II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r\n                          II) =\n    P ;;\n    (\\<mu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r\n                          II) \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "by (subst gfp_unfold, simp_all add: m)"], ["proof (state)\nthis:\n  (\\<mu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) =\n  P ;;\n  (\\<mu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r\n                        II) \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II\n\ngoal (1 subgoal):\n 1. while\\<^sub>\\<bottom> b do P od =\n    P ;;\n    while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "also"], ["proof (state)\nthis:\n  (\\<mu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) =\n  P ;;\n  (\\<mu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r\n                        II) \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II\n\ngoal (1 subgoal):\n 1. while\\<^sub>\\<bottom> b do P od =\n    P ;;\n    while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "have \"... = ((P ;; while\\<^sub>\\<bottom> b do P od) \\<triangleleft> b \\<triangleright>\\<^sub>r II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;;\n    (\\<mu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r\n                          II) \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II =\n    P ;;\n    while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "by (simp add: while_bot_def)"], ["proof (state)\nthis:\n  P ;;\n  (\\<mu> X \\<bullet> P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r\n                        II) \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II =\n  P ;;\n  while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II\n\ngoal (1 subgoal):\n 1. while\\<^sub>\\<bottom> b do P od =\n    P ;;\n    while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "finally"], ["proof (chain)\npicking this:\n  while\\<^sub>\\<bottom> b do P od =\n  P ;;\n  while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II", "show ?thesis"], ["proof (prove)\nusing this:\n  while\\<^sub>\\<bottom> b do P od =\n  P ;;\n  while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II\n\ngoal (1 subgoal):\n 1. while\\<^sub>\\<bottom> b do P od =\n    P ;;\n    while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II", "."], ["proof (state)\nthis:\n  while\\<^sub>\\<bottom> b do P od =\n  P ;;\n  while\\<^sub>\\<bottom> b do P od \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem while_bot_false: \"while\\<^sub>\\<bottom> false do P od = II\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while\\<^sub>\\<bottom> false do P od = II", "by (simp add: while_bot_def mu_const alpha)"], ["", "theorem while_bot_true: \"while\\<^sub>\\<bottom> true do P od = (\\<mu> X \\<bullet> P ;; X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while\\<^sub>\\<bottom> true do P od = \\<mu> ((;;) P)", "by (simp add: while_bot_def alpha)"], ["", "text \\<open> An infinite loop with a feasible body corresponds to a program error (non-termination). \\<close>"], ["", "theorem while_infinite: \"P ;; true\\<^sub>h = true \\<Longrightarrow> while\\<^sub>\\<bottom> true do P od = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; true = true \\<Longrightarrow>\n    while\\<^sub>\\<bottom> true do P od = true", "apply (simp add: while_bot_true)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; true = true \\<Longrightarrow> \\<mu> ((;;) P) = true", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. P ;; true = true \\<Longrightarrow> true \\<sqsubseteq> \\<mu> ((;;) P)\n 2. P ;; true = true \\<Longrightarrow> \\<mu> ((;;) P) \\<sqsubseteq> true", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; true = true \\<Longrightarrow> \\<mu> ((;;) P) \\<sqsubseteq> true", "apply (rule gfp_upperbound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; true = true \\<Longrightarrow> P ;; true \\<sqsubseteq> true", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open> Algebraic Properties \\<close>"], ["", "interpretation upred_semiring: semiring_1\n  where times = seqr and one = skip_r and zero = false\\<^sub>h and plus = Lattices.sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_1 II (;;) (\\<sqinter>) false", "by (unfold_locales, (rel_auto)+)"], ["", "declare upred_semiring.power_Suc [simp del]"], ["", "text \\<open> We introduce the power syntax derived from semirings \\<close>"], ["", "abbreviation upower :: \"'\\<alpha> hrel \\<Rightarrow> nat \\<Rightarrow> '\\<alpha> hrel\" (infixr \"\\<^bold>^\" 80) where\n\"upower P n \\<equiv> upred_semiring.power P n\""], ["", "translations\n  \"P \\<^bold>^ i\" <= \"CONST power.power II op ;; P i\"\n  \"P \\<^bold>^ i\" <= \"(CONST power.power II op ;; P) i\""], ["", "text \\<open> Set up transfer tactic for powers \\<close>"], ["", "lemma upower_rep_eq:\n  \"\\<lbrakk>P \\<^bold>^ i\\<rbrakk>\\<^sub>e = (\\<lambda> b. b \\<in> ({p. \\<lbrakk>P\\<rbrakk>\\<^sub>e p} ^^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>power.power II (;;) P i\\<rbrakk>\\<^sub>e =\n    (\\<lambda>b. b \\<in> {p. \\<lbrakk>P\\<rbrakk>\\<^sub>e p} ^^ i)", "proof (induct i arbitrary: P)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>power.power II (;;) P 0\\<rbrakk>\\<^sub>e =\n       (\\<lambda>b. b \\<in> Collect \\<lbrakk>P\\<rbrakk>\\<^sub>e ^^ 0)\n 2. \\<And>i P.\n       (\\<And>P.\n           \\<lbrakk>power.power II (;;) P i\\<rbrakk>\\<^sub>e =\n           (\\<lambda>b.\n               b \\<in> Collect \\<lbrakk>P\\<rbrakk>\\<^sub>e ^^\n                       i)) \\<Longrightarrow>\n       \\<lbrakk>power.power II (;;) P (Suc i)\\<rbrakk>\\<^sub>e =\n       (\\<lambda>b. b \\<in> Collect \\<lbrakk>P\\<rbrakk>\\<^sub>e ^^ Suc i)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>power.power II (;;) P 0\\<rbrakk>\\<^sub>e =\n       (\\<lambda>b. b \\<in> Collect \\<lbrakk>P\\<rbrakk>\\<^sub>e ^^ 0)\n 2. \\<And>i P.\n       (\\<And>P.\n           \\<lbrakk>power.power II (;;) P i\\<rbrakk>\\<^sub>e =\n           (\\<lambda>b.\n               b \\<in> Collect \\<lbrakk>P\\<rbrakk>\\<^sub>e ^^\n                       i)) \\<Longrightarrow>\n       \\<lbrakk>power.power II (;;) P (Suc i)\\<rbrakk>\\<^sub>e =\n       (\\<lambda>b. b \\<in> Collect \\<lbrakk>P\\<rbrakk>\\<^sub>e ^^ Suc i)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>power.power II (;;) P 0\\<rbrakk>\\<^sub>e =\n    (\\<lambda>b. b \\<in> {a. \\<lbrakk>P\\<rbrakk>\\<^sub>e a} ^^ 0)", "by (auto, rel_auto)"], ["proof (state)\nthis:\n  \\<lbrakk>power.power II (;;) P 0\\<rbrakk>\\<^sub>e =\n  (\\<lambda>b. b \\<in> {a. \\<lbrakk>P\\<rbrakk>\\<^sub>e a} ^^ 0)\n\ngoal (1 subgoal):\n 1. \\<And>i P.\n       (\\<And>P.\n           \\<lbrakk>power.power II (;;) P i\\<rbrakk>\\<^sub>e =\n           (\\<lambda>b.\n               b \\<in> Collect \\<lbrakk>P\\<rbrakk>\\<^sub>e ^^\n                       i)) \\<Longrightarrow>\n       \\<lbrakk>power.power II (;;) P (Suc i)\\<rbrakk>\\<^sub>e =\n       (\\<lambda>b. b \\<in> Collect \\<lbrakk>P\\<rbrakk>\\<^sub>e ^^ Suc i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i P.\n       (\\<And>P.\n           \\<lbrakk>power.power II (;;) P i\\<rbrakk>\\<^sub>e =\n           (\\<lambda>b.\n               b \\<in> Collect \\<lbrakk>P\\<rbrakk>\\<^sub>e ^^\n                       i)) \\<Longrightarrow>\n       \\<lbrakk>power.power II (;;) P (Suc i)\\<rbrakk>\\<^sub>e =\n       (\\<lambda>b. b \\<in> Collect \\<lbrakk>P\\<rbrakk>\\<^sub>e ^^ Suc i)", "case (Suc i)"], ["proof (state)\nthis:\n  \\<lbrakk>power.power II (;;) ?P i\\<rbrakk>\\<^sub>e =\n  (\\<lambda>b. b \\<in> {a. \\<lbrakk>?P\\<rbrakk>\\<^sub>e a} ^^ i)\n\ngoal (1 subgoal):\n 1. \\<And>i P.\n       (\\<And>P.\n           \\<lbrakk>power.power II (;;) P i\\<rbrakk>\\<^sub>e =\n           (\\<lambda>b.\n               b \\<in> Collect \\<lbrakk>P\\<rbrakk>\\<^sub>e ^^\n                       i)) \\<Longrightarrow>\n       \\<lbrakk>power.power II (;;) P (Suc i)\\<rbrakk>\\<^sub>e =\n       (\\<lambda>b. b \\<in> Collect \\<lbrakk>P\\<rbrakk>\\<^sub>e ^^ Suc i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>power.power II (;;) P (Suc i)\\<rbrakk>\\<^sub>e =\n    (\\<lambda>b. b \\<in> {a. \\<lbrakk>P\\<rbrakk>\\<^sub>e a} ^^ Suc i)", "by (simp add: Suc seqr.rep_eq relpow_commute upred_semiring.power_Suc)"], ["proof (state)\nthis:\n  \\<lbrakk>power.power II (;;) P (Suc i)\\<rbrakk>\\<^sub>e =\n  (\\<lambda>b. b \\<in> {a. \\<lbrakk>P\\<rbrakk>\\<^sub>e a} ^^ Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upower_rep_eq_alt:\n  \"\\<lbrakk>power.power \\<langle>id\\<rangle>\\<^sub>a (;;) P i\\<rbrakk>\\<^sub>e = (\\<lambda>b. b \\<in> ({p. \\<lbrakk>P\\<rbrakk>\\<^sub>e p} ^^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>power.power \\<langle>id\\<rangle>\\<^sub>a (;;) P\n              i\\<rbrakk>\\<^sub>e =\n    (\\<lambda>b. b \\<in> {p. \\<lbrakk>P\\<rbrakk>\\<^sub>e p} ^^ i)", "by (metis skip_r_def upower_rep_eq)"], ["", "update_uexpr_rep_eq_thms"], ["", "lemma Sup_power_expand:\n  fixes P :: \"nat \\<Rightarrow> 'a::complete_lattice\"\n  shows \"P(0) \\<sqinter> (\\<Sqinter>i. P(i+1)) = (\\<Sqinter>i. P(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P 0 \\<sqinter> (\\<Sqinter>i. P (i + 1)) = \\<Sqinter>range P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P 0 \\<sqinter> (\\<Sqinter>i. P (i + 1)) = \\<Sqinter>range P", "have \"UNIV = insert (0::nat) {1..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = insert 0 {1..}", "by auto"], ["proof (state)\nthis:\n  UNIV = insert 0 {1..}\n\ngoal (1 subgoal):\n 1. P 0 \\<sqinter> (\\<Sqinter>i. P (i + 1)) = \\<Sqinter>range P", "moreover"], ["proof (state)\nthis:\n  UNIV = insert 0 {1..}\n\ngoal (1 subgoal):\n 1. P 0 \\<sqinter> (\\<Sqinter>i. P (i + 1)) = \\<Sqinter>range P", "have \"(\\<Sqinter>i. P(i)) = \\<Sqinter> (P ` UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>range P = \\<Sqinter>range P", "by (blast)"], ["proof (state)\nthis:\n  \\<Sqinter>range P = \\<Sqinter>range P\n\ngoal (1 subgoal):\n 1. P 0 \\<sqinter> (\\<Sqinter>i. P (i + 1)) = \\<Sqinter>range P", "moreover"], ["proof (state)\nthis:\n  \\<Sqinter>range P = \\<Sqinter>range P\n\ngoal (1 subgoal):\n 1. P 0 \\<sqinter> (\\<Sqinter>i. P (i + 1)) = \\<Sqinter>range P", "have \"\\<Sqinter> (P ` insert 0 {1..}) = P(0) \\<sqinter> \\<Sqinter> (P ` {1..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>(P ` insert 0 {1..}) = P 0 \\<sqinter> \\<Sqinter>(P ` {1..})", "by (simp)"], ["proof (state)\nthis:\n  \\<Sqinter>(P ` insert 0 {1..}) = P 0 \\<sqinter> \\<Sqinter>(P ` {1..})\n\ngoal (1 subgoal):\n 1. P 0 \\<sqinter> (\\<Sqinter>i. P (i + 1)) = \\<Sqinter>range P", "moreover"], ["proof (state)\nthis:\n  \\<Sqinter>(P ` insert 0 {1..}) = P 0 \\<sqinter> \\<Sqinter>(P ` {1..})\n\ngoal (1 subgoal):\n 1. P 0 \\<sqinter> (\\<Sqinter>i. P (i + 1)) = \\<Sqinter>range P", "have \"\\<Sqinter> (P ` {1..}) = (\\<Sqinter>i. P(i+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>(P ` {1..}) = (\\<Sqinter>i. P (i + 1))", "by (simp add: atLeast_Suc_greaterThan greaterThan_0)"], ["proof (state)\nthis:\n  \\<Sqinter>(P ` {1..}) = (\\<Sqinter>i. P (i + 1))\n\ngoal (1 subgoal):\n 1. P 0 \\<sqinter> (\\<Sqinter>i. P (i + 1)) = \\<Sqinter>range P", "ultimately"], ["proof (chain)\npicking this:\n  UNIV = insert 0 {1..}\n  \\<Sqinter>range P = \\<Sqinter>range P\n  \\<Sqinter>(P ` insert 0 {1..}) = P 0 \\<sqinter> \\<Sqinter>(P ` {1..})\n  \\<Sqinter>(P ` {1..}) = (\\<Sqinter>i. P (i + 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  UNIV = insert 0 {1..}\n  \\<Sqinter>range P = \\<Sqinter>range P\n  \\<Sqinter>(P ` insert 0 {1..}) = P 0 \\<sqinter> \\<Sqinter>(P ` {1..})\n  \\<Sqinter>(P ` {1..}) = (\\<Sqinter>i. P (i + 1))\n\ngoal (1 subgoal):\n 1. P 0 \\<sqinter> (\\<Sqinter>i. P (i + 1)) = \\<Sqinter>range P", "by (simp only:)"], ["proof (state)\nthis:\n  P 0 \\<sqinter> (\\<Sqinter>i. P (i + 1)) = \\<Sqinter>range P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sup_upto_Suc: \"(\\<Sqinter>i\\<in>{0..Suc n}. P \\<^bold>^ i) = (\\<Sqinter>i\\<in>{0..n}. P \\<^bold>^ i) \\<sqinter> P \\<^bold>^ Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Or>(power.power II (;;) P ` {0..Suc n}) =\n    \\<Or>(power.power II (;;) P ` {0..n}) \\<sqinter>\n    power.power II (;;) P (Suc n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Or>(power.power II (;;) P ` {0..Suc n}) =\n    \\<Or>(power.power II (;;) P ` {0..n}) \\<sqinter>\n    power.power II (;;) P (Suc n)", "have \"(\\<Sqinter>i\\<in>{0..Suc n}. P \\<^bold>^ i) = (\\<Sqinter>i\\<in>insert (Suc n) {0..n}. P \\<^bold>^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Or>(power.power II (;;) P ` {0..Suc n}) =\n    \\<Or>(power.power II (;;) P ` insert (Suc n) {0..n})", "by (simp add: atLeast0_atMost_Suc)"], ["proof (state)\nthis:\n  \\<Or>(power.power II (;;) P ` {0..Suc n}) =\n  \\<Or>(power.power II (;;) P ` insert (Suc n) {0..n})\n\ngoal (1 subgoal):\n 1. \\<Or>(power.power II (;;) P ` {0..Suc n}) =\n    \\<Or>(power.power II (;;) P ` {0..n}) \\<sqinter>\n    power.power II (;;) P (Suc n)", "also"], ["proof (state)\nthis:\n  \\<Or>(power.power II (;;) P ` {0..Suc n}) =\n  \\<Or>(power.power II (;;) P ` insert (Suc n) {0..n})\n\ngoal (1 subgoal):\n 1. \\<Or>(power.power II (;;) P ` {0..Suc n}) =\n    \\<Or>(power.power II (;;) P ` {0..n}) \\<sqinter>\n    power.power II (;;) P (Suc n)", "have \"... = P \\<^bold>^ Suc n \\<sqinter> (\\<Sqinter>i\\<in>{0..n}. P \\<^bold>^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Or>(power.power II (;;) P ` insert (Suc n) {0..n}) =\n    power.power II (;;) P (Suc n) \\<sqinter>\n    \\<Or>(power.power II (;;) P ` {0..n})", "by (simp)"], ["proof (state)\nthis:\n  \\<Or>(power.power II (;;) P ` insert (Suc n) {0..n}) =\n  power.power II (;;) P (Suc n) \\<sqinter>\n  \\<Or>(power.power II (;;) P ` {0..n})\n\ngoal (1 subgoal):\n 1. \\<Or>(power.power II (;;) P ` {0..Suc n}) =\n    \\<Or>(power.power II (;;) P ` {0..n}) \\<sqinter>\n    power.power II (;;) P (Suc n)", "finally"], ["proof (chain)\npicking this:\n  \\<Or>(power.power II (;;) P ` {0..Suc n}) =\n  power.power II (;;) P (Suc n) \\<sqinter>\n  \\<Or>(power.power II (;;) P ` {0..n})", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Or>(power.power II (;;) P ` {0..Suc n}) =\n  power.power II (;;) P (Suc n) \\<sqinter>\n  \\<Or>(power.power II (;;) P ` {0..n})\n\ngoal (1 subgoal):\n 1. \\<Or>(power.power II (;;) P ` {0..Suc n}) =\n    \\<Or>(power.power II (;;) P ` {0..n}) \\<sqinter>\n    power.power II (;;) P (Suc n)", "by (simp add: Lattices.sup_commute)"], ["proof (state)\nthis:\n  \\<Or>(power.power II (;;) P ` {0..Suc n}) =\n  \\<Or>(power.power II (;;) P ` {0..n}) \\<sqinter>\n  power.power II (;;) P (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> The following two proofs are adapted from the AFP entry \n  \\href{https://www.isa-afp.org/entries/Kleene_Algebra.shtml}{Kleene Algebra}. \n  See also~\\cite{Armstrong2012,Armstrong2015}. \\<close>"], ["", "lemma upower_inductl: \"Q \\<sqsubseteq> ((P ;; Q) \\<sqinter> R) \\<Longrightarrow> Q \\<sqsubseteq> P \\<^bold>^ n ;; R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R \\<Longrightarrow>\n    Q \\<sqsubseteq> power.power II (;;) P n ;; R", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R \\<Longrightarrow>\n    Q \\<sqsubseteq> power.power II (;;) P 0 ;; R\n 2. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R \\<Longrightarrow>\n                Q \\<sqsubseteq> power.power II (;;) P n ;; R;\n        Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> power.power II (;;) P (Suc n) ;; R", "case 0"], ["proof (state)\nthis:\n  Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R\n\ngoal (2 subgoals):\n 1. Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R \\<Longrightarrow>\n    Q \\<sqsubseteq> power.power II (;;) P 0 ;; R\n 2. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R \\<Longrightarrow>\n                Q \\<sqsubseteq> power.power II (;;) P n ;; R;\n        Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> power.power II (;;) P (Suc n) ;; R", "then"], ["proof (chain)\npicking this:\n  Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R", "show ?case"], ["proof (prove)\nusing this:\n  Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> power.power II (;;) P 0 ;; R", "by (auto)"], ["proof (state)\nthis:\n  Q \\<sqsubseteq> power.power II (;;) P 0 ;; R\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R \\<Longrightarrow>\n                Q \\<sqsubseteq> power.power II (;;) P n ;; R;\n        Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> power.power II (;;) P (Suc n) ;; R", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R \\<Longrightarrow>\n                Q \\<sqsubseteq> power.power II (;;) P n ;; R;\n        Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> power.power II (;;) P (Suc n) ;; R", "case (Suc n)"], ["proof (state)\nthis:\n  Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R \\<Longrightarrow>\n  Q \\<sqsubseteq> power.power II (;;) P n ;; R\n  Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R \\<Longrightarrow>\n                Q \\<sqsubseteq> power.power II (;;) P n ;; R;\n        Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> power.power II (;;) P (Suc n) ;; R", "then"], ["proof (chain)\npicking this:\n  Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R \\<Longrightarrow>\n  Q \\<sqsubseteq> power.power II (;;) P n ;; R\n  Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R", "show ?case"], ["proof (prove)\nusing this:\n  Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R \\<Longrightarrow>\n  Q \\<sqsubseteq> power.power II (;;) P n ;; R\n  Q \\<sqsubseteq> (P ;; Q) \\<sqinter> R\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> power.power II (;;) P (Suc n) ;; R", "by (auto simp add: upred_semiring.power_Suc, metis (no_types, hide_lams) dual_order.trans order_refl seqr_assoc seqr_mono)"], ["proof (state)\nthis:\n  Q \\<sqsubseteq> power.power II (;;) P (Suc n) ;; R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upower_inductr:\n  assumes \"Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\"\n  shows \"Q \\<sqsubseteq> R ;; (P \\<^bold>^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> R ;; power.power II (;;) P n", "using assms"], ["proof (prove)\nusing this:\n  Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> R ;; power.power II (;;) P n", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. Q \\<sqsubseteq> R \\<sqinter> (Q ;; P) \\<Longrightarrow>\n    Q \\<sqsubseteq> R ;; power.power II (;;) P 0\n 2. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> R \\<sqinter> (Q ;; P) \\<Longrightarrow>\n                Q \\<sqsubseteq> R ;; power.power II (;;) P n;\n        Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)", "case 0"], ["proof (state)\nthis:\n  Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\n\ngoal (2 subgoals):\n 1. Q \\<sqsubseteq> R \\<sqinter> (Q ;; P) \\<Longrightarrow>\n    Q \\<sqsubseteq> R ;; power.power II (;;) P 0\n 2. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> R \\<sqinter> (Q ;; P) \\<Longrightarrow>\n                Q \\<sqsubseteq> R ;; power.power II (;;) P n;\n        Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)", "then"], ["proof (chain)\npicking this:\n  Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)", "show ?case"], ["proof (prove)\nusing this:\n  Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> R ;; power.power II (;;) P 0", "by auto"], ["proof (state)\nthis:\n  Q \\<sqsubseteq> R ;; power.power II (;;) P 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> R \\<sqinter> (Q ;; P) \\<Longrightarrow>\n                Q \\<sqsubseteq> R ;; power.power II (;;) P n;\n        Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> R \\<sqinter> (Q ;; P) \\<Longrightarrow>\n                Q \\<sqsubseteq> R ;; power.power II (;;) P n;\n        Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  Q \\<sqsubseteq> R \\<sqinter> (Q ;; P) \\<Longrightarrow>\n  Q \\<sqsubseteq> R ;; power.power II (;;) P n\n  Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> R \\<sqinter> (Q ;; P) \\<Longrightarrow>\n                Q \\<sqsubseteq> R ;; power.power II (;;) P n;\n        Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)", "have \"R ;; P \\<^bold>^ Suc n = (R ;; P \\<^bold>^ n) ;; P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R ;; power.power II (;;) P (Suc n) = (R ;; power.power II (;;) P n) ;; P", "by (metis seqr_assoc upred_semiring.power_Suc2)"], ["proof (state)\nthis:\n  R ;; power.power II (;;) P (Suc n) = (R ;; power.power II (;;) P n) ;; P\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> R \\<sqinter> (Q ;; P) \\<Longrightarrow>\n                Q \\<sqsubseteq> R ;; power.power II (;;) P n;\n        Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)", "also"], ["proof (state)\nthis:\n  R ;; power.power II (;;) P (Suc n) = (R ;; power.power II (;;) P n) ;; P\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> R \\<sqinter> (Q ;; P) \\<Longrightarrow>\n                Q \\<sqsubseteq> R ;; power.power II (;;) P n;\n        Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)", "have \"Q ;; P \\<sqsubseteq> ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q ;; P \\<sqsubseteq> (R ;; power.power II (;;) P n) ;; P", "by (meson Suc.hyps assms eq_iff seqr_mono)"], ["proof (state)\nthis:\n  Q ;; P \\<sqsubseteq> (R ;; power.power II (;;) P n) ;; P\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> R \\<sqinter> (Q ;; P) \\<Longrightarrow>\n                Q \\<sqsubseteq> R ;; power.power II (;;) P n;\n        Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)", "also"], ["proof (state)\nthis:\n  Q ;; P \\<sqsubseteq> (R ;; power.power II (;;) P n) ;; P\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> R \\<sqinter> (Q ;; P) \\<Longrightarrow>\n                Q \\<sqsubseteq> R ;; power.power II (;;) P n;\n        Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)", "have \"Q \\<sqsubseteq> ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> Q ;; P", "using assms"], ["proof (prove)\nusing this:\n  Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> Q ;; P", "by auto"], ["proof (state)\nthis:\n  Q \\<sqsubseteq> Q ;; P\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>Q \\<sqsubseteq> R \\<sqinter> (Q ;; P) \\<Longrightarrow>\n                Q \\<sqsubseteq> R ;; power.power II (;;) P n;\n        Q \\<sqsubseteq> R \\<sqinter> (Q ;; P)\\<rbrakk>\n       \\<Longrightarrow> Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)", "finally"], ["proof (chain)\npicking this:\n  Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)", "."], ["proof (state)\nthis:\n  Q \\<sqsubseteq> R ;; power.power II (;;) P (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SUP_atLeastAtMost_first:\n  fixes P :: \"nat \\<Rightarrow> 'a::complete_lattice\"\n  assumes \"m \\<le> n\"\n  shows \"(\\<Sqinter>i\\<in>{m..n}. P(i)) = P(m) \\<sqinter> (\\<Sqinter>i\\<in>{Suc m..n}. P(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>(P ` {m..n}) = P m \\<sqinter> \\<Sqinter>(P ` {Suc m..n})", "by (metis SUP_insert assms atLeastAtMost_insertL)"], ["", "lemma upower_seqr_iter: \"P \\<^bold>^ n = (;; Q : replicate n P \\<bullet> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power.power II (;;) P n = (;; Q : replicate n P \\<bullet> Q)", "by (induct n, simp_all add: upred_semiring.power_Suc)"], ["", "lemma assigns_power: \"\\<langle>f\\<rangle>\\<^sub>a \\<^bold>^ n = \\<langle>f ^^ n\\<rangle>\\<^sub>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power.power II (;;) \\<langle>f\\<rangle>\\<^sub>a n =\n    \\<langle>f ^^ n\\<rangle>\\<^sub>a", "by (induct n, rel_auto+)"], ["", "subsection \\<open> Kleene Star \\<close>"], ["", "definition ustar :: \"'\\<alpha> hrel \\<Rightarrow> '\\<alpha> hrel\" (\"_\\<^sup>\\<star>\" [999] 999) where\n\"P\\<^sup>\\<star> = (\\<Sqinter>i\\<in>{0..} \\<bullet> P\\<^bold>^i)\""], ["", "lemma ustar_rep_eq:\n  \"\\<lbrakk>P\\<^sup>\\<star>\\<rbrakk>\\<^sub>e = (\\<lambda>b. b \\<in> ({p. \\<lbrakk>P\\<rbrakk>\\<^sub>e p}\\<^sup>*))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P\\<^sup>\\<star>\\<rbrakk>\\<^sub>e =\n    (\\<lambda>b. b \\<in> {p. \\<lbrakk>P\\<rbrakk>\\<^sub>e p}\\<^sup>*)", "by (simp add: ustar_def, rel_auto, simp_all add: relpow_imp_rtrancl rtrancl_imp_relpow)"], ["", "update_uexpr_rep_eq_thms"], ["", "subsection \\<open> Kleene Plus \\<close>"], ["", "purge_notation trancl (\"(_\\<^sup>+)\" [1000] 999)"], ["", "definition uplus :: \"'\\<alpha> hrel \\<Rightarrow> '\\<alpha> hrel\" (\"_\\<^sup>+\" [999] 999) where\n[upred_defs]: \"P\\<^sup>+ = P ;; P\\<^sup>\\<star>\""], ["", "lemma uplus_power_def: \"P\\<^sup>+ = (\\<Sqinter> i \\<bullet> P \\<^bold>^ (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>+ = (\\<Sqinter> i \\<bullet> power.power II (;;) P (Suc i))", "by (simp add: uplus_def ustar_def seq_UINF_distl' UINF_atLeast_Suc upred_semiring.power_Suc)"], ["", "subsection \\<open> Omega \\<close>"], ["", "definition uomega :: \"'\\<alpha> hrel \\<Rightarrow> '\\<alpha> hrel\" (\"_\\<^sup>\\<omega>\" [999] 999) where\n\"P\\<^sup>\\<omega> = (\\<mu> X \\<bullet> P ;; X)\""], ["", "subsection \\<open> Relation Algebra Laws \\<close>"], ["", "theorem RA1: \"(P ;; (Q ;; R)) = ((P ;; Q) ;; R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; Q ;; R = (P ;; Q) ;; R", "by (simp add: seqr_assoc)"], ["", "theorem RA2: \"(P ;; II) = P\" \"(II ;; P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; II = P &&& II ;; P = P", "by simp_all"], ["", "theorem RA3: \"P\\<^sup>-\\<^sup>- = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>-\\<^sup>- = P", "by simp"], ["", "theorem RA4: \"(P ;; Q)\\<^sup>- = (Q\\<^sup>- ;; P\\<^sup>-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P ;; Q)\\<^sup>- = Q\\<^sup>- ;; P\\<^sup>-", "by simp"], ["", "theorem RA5: \"(P \\<or> Q)\\<^sup>- = (P\\<^sup>- \\<or> Q\\<^sup>-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q)\\<^sup>- = (P\\<^sup>- \\<or> Q\\<^sup>-)", "by (rel_auto)"], ["", "theorem RA6: \"((P \\<or> Q) ;; R) = (P;;R \\<or> Q;;R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q) ;; R = (P ;; R \\<or> Q ;; R)", "using seqr_or_distl"], ["proof (prove)\nusing this:\n  (?P \\<or> ?Q) ;; ?R = (?P ;; ?R \\<or> ?Q ;; ?R)\n\ngoal (1 subgoal):\n 1. (P \\<or> Q) ;; R = (P ;; R \\<or> Q ;; R)", "by blast"], ["", "theorem RA7: \"((P\\<^sup>- ;; (\\<not>(P ;; Q))) \\<or> (\\<not>Q)) = (\\<not>Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P\\<^sup>- ;; (\\<not> P ;; Q) \\<or> \\<not> Q) = (\\<not> Q)", "by (rel_auto)"], ["", "subsection \\<open> Kleene Algebra Laws \\<close>"], ["", "lemma ustar_alt_def: \"P\\<^sup>\\<star> = (\\<Sqinter> i \\<bullet> P \\<^bold>^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>\\<star> = (\\<Sqinter> i \\<bullet> (power.power II (;;) P) i)", "by (simp add: ustar_def)"], ["", "theorem ustar_sub_unfoldl: \"P\\<^sup>\\<star> \\<sqsubseteq> II \\<sqinter> (P;;P\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>\\<star> \\<sqsubseteq> II \\<sqinter> (P ;; P\\<^sup>\\<star>)", "by (rel_simp, simp add: rtrancl_into_trancl2 trancl_into_rtrancl)"], ["", "theorem ustar_inductl:\n  assumes \"Q \\<sqsubseteq> R\" \"Q \\<sqsubseteq> P ;; Q\"\n  shows \"Q \\<sqsubseteq> P\\<^sup>\\<star> ;; R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> P\\<^sup>\\<star> ;; R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> P\\<^sup>\\<star> ;; R", "have \"P\\<^sup>\\<star> ;; R = (\\<Sqinter> i. P \\<^bold>^ i ;; R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>\\<star> ;; R =\n    \\<Or>range (\\<lambda>i. power.power II (;;) P i ;; R)", "by (simp add: ustar_def UINF_as_Sup_collect' seq_SUP_distr)"], ["proof (state)\nthis:\n  P\\<^sup>\\<star> ;; R =\n  \\<Or>range (\\<lambda>i. power.power II (;;) P i ;; R)\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> P\\<^sup>\\<star> ;; R", "also"], ["proof (state)\nthis:\n  P\\<^sup>\\<star> ;; R =\n  \\<Or>range (\\<lambda>i. power.power II (;;) P i ;; R)\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> P\\<^sup>\\<star> ;; R", "have \"Q \\<sqsubseteq> ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> \\<Or>range (\\<lambda>i. power.power II (;;) P i ;; R)", "by (simp add: SUP_least assms upower_inductl)"], ["proof (state)\nthis:\n  Q \\<sqsubseteq> \\<Or>range (\\<lambda>i. power.power II (;;) P i ;; R)\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> P\\<^sup>\\<star> ;; R", "finally"], ["proof (chain)\npicking this:\n  Q \\<sqsubseteq> P\\<^sup>\\<star> ;; R", "show ?thesis"], ["proof (prove)\nusing this:\n  Q \\<sqsubseteq> P\\<^sup>\\<star> ;; R\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> P\\<^sup>\\<star> ;; R", "."], ["proof (state)\nthis:\n  Q \\<sqsubseteq> P\\<^sup>\\<star> ;; R\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ustar_inductr:\n  assumes \"Q \\<sqsubseteq> R\" \"Q \\<sqsubseteq> Q ;; P\"\n  shows \"Q \\<sqsubseteq> R ;; P\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> R ;; P\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> R ;; P\\<^sup>\\<star>", "have \"R ;; P\\<^sup>\\<star> = (\\<Sqinter> i. R ;; P \\<^bold>^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R ;; P\\<^sup>\\<star> =\n    \\<Or>range (\\<lambda>i. R ;; power.power II (;;) P i)", "by (simp add: ustar_def UINF_as_Sup_collect' seq_SUP_distl)"], ["proof (state)\nthis:\n  R ;; P\\<^sup>\\<star> =\n  \\<Or>range (\\<lambda>i. R ;; power.power II (;;) P i)\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> R ;; P\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  R ;; P\\<^sup>\\<star> =\n  \\<Or>range (\\<lambda>i. R ;; power.power II (;;) P i)\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> R ;; P\\<^sup>\\<star>", "have \"Q \\<sqsubseteq> ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> \\<Or>range (\\<lambda>i. R ;; power.power II (;;) P i)", "by (simp add: SUP_least assms upower_inductr)"], ["proof (state)\nthis:\n  Q \\<sqsubseteq> \\<Or>range (\\<lambda>i. R ;; power.power II (;;) P i)\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> R ;; P\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  Q \\<sqsubseteq> R ;; P\\<^sup>\\<star>", "show ?thesis"], ["proof (prove)\nusing this:\n  Q \\<sqsubseteq> R ;; P\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> R ;; P\\<^sup>\\<star>", "."], ["proof (state)\nthis:\n  Q \\<sqsubseteq> R ;; P\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ustar_refines_nu: \"(\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II) \\<sqsubseteq> P\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II) \\<sqsubseteq> P\\<^sup>\\<star>", "by (metis (no_types, lifting) lfp_greatest semilattice_sup_class.le_sup_iff \n      semilattice_sup_class.sup_idem upred_semiring.mult_2_right \n      upred_semiring.one_add_one ustar_inductl)"], ["", "lemma ustar_as_nu: \"P\\<^sup>\\<star> = (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>\\<star> = (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II) \\<sqsubseteq> P\\<^sup>\\<star>\n 2. P\\<^sup>\\<star> \\<sqsubseteq> (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II)", "show \"(\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II) \\<sqsubseteq> P\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II) \\<sqsubseteq> P\\<^sup>\\<star>", "by (simp add: ustar_refines_nu)"], ["proof (state)\nthis:\n  (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II) \\<sqsubseteq> P\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. P\\<^sup>\\<star> \\<sqsubseteq> (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II)", "show \"P\\<^sup>\\<star> \\<sqsubseteq> (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>\\<star> \\<sqsubseteq> (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II)", "by (metis lfp_lowerbound upred_semiring.add_commute ustar_sub_unfoldl)"], ["proof (state)\nthis:\n  P\\<^sup>\\<star> \\<sqsubseteq> (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ustar_unfoldl: \"P\\<^sup>\\<star> = II \\<sqinter> (P ;; P\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>\\<star> = II \\<sqinter> (P ;; P\\<^sup>\\<star>)", "apply (simp add: ustar_as_nu)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II) =\n    II \\<sqinter> (P ;; (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II))", "apply (subst lfp_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Monotonic (\\<lambda>X. (P ;; X) \\<sqinter> II)\n 2. (P ;; (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II)) \\<sqinter> II =\n    II \\<sqinter> (P ;; (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II))", "apply (rule monoI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       y \\<sqsubseteq> x \\<Longrightarrow>\n       (P ;; y) \\<sqinter> II \\<sqsubseteq> (P ;; x) \\<sqinter> II\n 2. (P ;; (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II)) \\<sqinter> II =\n    II \\<sqinter> (P ;; (\\<nu> X \\<bullet> (P ;; X) \\<sqinter> II))", "apply (rel_auto)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open> While loop can be expressed using Kleene star \\<close>"], ["", "lemma while_star_form:\n  \"while b do P od = (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;; [(\\<not>b)]\\<^sup>\\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "have 1: \"Continuous (\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Continuous\n     (\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "by (rel_auto)"], ["proof (state)\nthis:\n  Continuous\n   (\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "have \"while b do P od = (\\<Sqinter>i. ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ i) false)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    \\<Or>range\n          (\\<lambda>i.\n              ((\\<lambda>X.\n                   P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n               i)\n               false)", "by (simp add: \"1\" false_upred_def sup_continuous_Continuous sup_continuous_lfp while_top_def)"], ["proof (state)\nthis:\n  while\\<^sup>\\<top> b do P od =\n  \\<Or>range\n        (\\<lambda>i.\n            ((\\<lambda>X.\n                 P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n             i)\n             false)\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "also"], ["proof (state)\nthis:\n  while\\<^sup>\\<top> b do P od =\n  \\<Or>range\n        (\\<lambda>i.\n            ((\\<lambda>X.\n                 P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n             i)\n             false)\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "have \"... = ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ 0) false \\<sqinter> (\\<Sqinter>i. ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ (i+1)) false)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Or>range\n          (\\<lambda>i.\n              ((\\<lambda>X.\n                   P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n               i)\n               false) =\n    ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n     0)\n     false \\<sqinter>\n    \\<Or>range\n          (\\<lambda>i.\n              ((\\<lambda>X.\n                   P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n               (i + 1))\n               false)", "by (subst Sup_power_expand, simp)"], ["proof (state)\nthis:\n  \\<Or>range\n        (\\<lambda>i.\n            ((\\<lambda>X.\n                 P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n             i)\n             false) =\n  ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ 0)\n   false \\<sqinter>\n  \\<Or>range\n        (\\<lambda>i.\n            ((\\<lambda>X.\n                 P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n             (i + 1))\n             false)\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "also"], ["proof (state)\nthis:\n  \\<Or>range\n        (\\<lambda>i.\n            ((\\<lambda>X.\n                 P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n             i)\n             false) =\n  ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ 0)\n   false \\<sqinter>\n  \\<Or>range\n        (\\<lambda>i.\n            ((\\<lambda>X.\n                 P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n             (i + 1))\n             false)\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "have \"... = (\\<Sqinter>i. ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ (i+1)) false)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n     0)\n     false \\<sqinter>\n    \\<Or>range\n          (\\<lambda>i.\n              ((\\<lambda>X.\n                   P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n               (i + 1))\n               false) =\n    \\<Or>range\n          (\\<lambda>i.\n              ((\\<lambda>X.\n                   P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n               (i + 1))\n               false)", "by (simp)"], ["proof (state)\nthis:\n  ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ 0)\n   false \\<sqinter>\n  \\<Or>range\n        (\\<lambda>i.\n            ((\\<lambda>X.\n                 P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n             (i + 1))\n             false) =\n  \\<Or>range\n        (\\<lambda>i.\n            ((\\<lambda>X.\n                 P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n             (i + 1))\n             false)\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "also"], ["proof (state)\nthis:\n  ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ 0)\n   false \\<sqinter>\n  \\<Or>range\n        (\\<lambda>i.\n            ((\\<lambda>X.\n                 P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n             (i + 1))\n             false) =\n  \\<Or>range\n        (\\<lambda>i.\n            ((\\<lambda>X.\n                 P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n             (i + 1))\n             false)\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "have \"... = (\\<Sqinter>i. (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^bold>^i ;; (false \\<triangleleft> b \\<triangleright>\\<^sub>r II))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Or>range\n          (\\<lambda>i.\n              ((\\<lambda>X.\n                   P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n               (i + 1))\n               false) =\n    \\<Or>range\n          (\\<lambda>i.\n              power.power II (;;)\n               (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n              (false \\<triangleleft> b \\<triangleright>\\<^sub>r II))", "proof (rule SUP_cong, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       P ;;\n       ((\\<lambda>X.\n            P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n        x)\n        false \\<triangleleft> b \\<triangleright>\\<^sub>r\n          II =\n       power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n        x ;;\n       (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       P ;;\n       ((\\<lambda>X.\n            P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n        x)\n        false \\<triangleleft> b \\<triangleright>\\<^sub>r\n          II =\n       power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n        x ;;\n       (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "show \"P ;; ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ i) false \\<triangleleft> b \\<triangleright>\\<^sub>r II = (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) \\<^bold>^ i ;; (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;;\n    ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n     i)\n     false \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II =\n    power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n     i ;;\n    (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. P ;;\n    ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n     0)\n     false \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II =\n    power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n     0 ;;\n    (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n 2. \\<And>i.\n       P ;;\n       ((\\<lambda>X.\n            P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n        i)\n        false \\<triangleleft> b \\<triangleright>\\<^sub>r\n          II =\n       power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n        i ;;\n       (false \\<triangleleft> b \\<triangleright>\\<^sub>r\n           II) \\<Longrightarrow>\n       P ;;\n       ((\\<lambda>X.\n            P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n        Suc i)\n        false \\<triangleleft> b \\<triangleright>\\<^sub>r\n          II =\n       power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n        (Suc i) ;;\n       (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. P ;;\n    ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n     0)\n     false \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II =\n    power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n     0 ;;\n    (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n 2. \\<And>i.\n       P ;;\n       ((\\<lambda>X.\n            P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n        i)\n        false \\<triangleleft> b \\<triangleright>\\<^sub>r\n          II =\n       power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n        i ;;\n       (false \\<triangleleft> b \\<triangleright>\\<^sub>r\n           II) \\<Longrightarrow>\n       P ;;\n       ((\\<lambda>X.\n            P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n        Suc i)\n        false \\<triangleleft> b \\<triangleright>\\<^sub>r\n          II =\n       power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n        (Suc i) ;;\n       (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;;\n    ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n     0)\n     false \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II =\n    power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n     0 ;;\n    (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "by simp"], ["proof (state)\nthis:\n  P ;;\n  ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ 0)\n   false \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II =\n  power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) 0 ;;\n  (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       P ;;\n       ((\\<lambda>X.\n            P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n        i)\n        false \\<triangleleft> b \\<triangleright>\\<^sub>r\n          II =\n       power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n        i ;;\n       (false \\<triangleleft> b \\<triangleright>\\<^sub>r\n           II) \\<Longrightarrow>\n       P ;;\n       ((\\<lambda>X.\n            P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n        Suc i)\n        false \\<triangleleft> b \\<triangleright>\\<^sub>r\n          II =\n       power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n        (Suc i) ;;\n       (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       P ;;\n       ((\\<lambda>X.\n            P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n        i)\n        false \\<triangleleft> b \\<triangleright>\\<^sub>r\n          II =\n       power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n        i ;;\n       (false \\<triangleleft> b \\<triangleright>\\<^sub>r\n           II) \\<Longrightarrow>\n       P ;;\n       ((\\<lambda>X.\n            P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n        Suc i)\n        false \\<triangleleft> b \\<triangleright>\\<^sub>r\n          II =\n       power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n        (Suc i) ;;\n       (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "case (Suc i)"], ["proof (state)\nthis:\n  P ;;\n  ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ i)\n   false \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II =\n  power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n  (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       P ;;\n       ((\\<lambda>X.\n            P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n        i)\n        false \\<triangleleft> b \\<triangleright>\\<^sub>r\n          II =\n       power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n        i ;;\n       (false \\<triangleleft> b \\<triangleright>\\<^sub>r\n           II) \\<Longrightarrow>\n       P ;;\n       ((\\<lambda>X.\n            P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n        Suc i)\n        false \\<triangleleft> b \\<triangleright>\\<^sub>r\n          II =\n       power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n        (Suc i) ;;\n       (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "then"], ["proof (chain)\npicking this:\n  P ;;\n  ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ i)\n   false \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II =\n  power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n  (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "show ?case"], ["proof (prove)\nusing this:\n  P ;;\n  ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ i)\n   false \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II =\n  power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n  (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n\ngoal (1 subgoal):\n 1. P ;;\n    ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n     Suc i)\n     false \\<triangleleft> b \\<triangleright>\\<^sub>r\n       II =\n    power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n     (Suc i) ;;\n    (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)", "by (simp add: upred_semiring.power_Suc)\n           (metis (no_types, lifting) RA1 comp_cond_left_distr cond_L6 upred_semiring.mult.left_neutral)"], ["proof (state)\nthis:\n  P ;;\n  ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n   Suc i)\n   false \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II =\n  power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n   (Suc i) ;;\n  (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P ;;\n  ((\\<lambda>X. P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^ i)\n   false \\<triangleleft> b \\<triangleright>\\<^sub>r\n     II =\n  power.power II (;;) (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n  (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Or>range\n        (\\<lambda>i.\n            ((\\<lambda>X.\n                 P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n             (i + 1))\n             false) =\n  \\<Or>range\n        (\\<lambda>i.\n            power.power II (;;)\n             (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n            (false \\<triangleleft> b \\<triangleright>\\<^sub>r II))\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "also"], ["proof (state)\nthis:\n  \\<Or>range\n        (\\<lambda>i.\n            ((\\<lambda>X.\n                 P ;; X \\<triangleleft> b \\<triangleright>\\<^sub>r II) ^^\n             (i + 1))\n             false) =\n  \\<Or>range\n        (\\<lambda>i.\n            power.power II (;;)\n             (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n            (false \\<triangleleft> b \\<triangleright>\\<^sub>r II))\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "have \"... = (\\<Sqinter>i\\<in>{0..} \\<bullet> (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^bold>^i ;; [(\\<not>b)]\\<^sup>\\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Or>range\n          (\\<lambda>i.\n              power.power II (;;)\n               (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n              (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)) =\n    (\\<Sqinter> i \\<in> {0..} \\<bullet> power.power II (;;)\n   (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n  ?[\\<not> b])", "by (rel_auto)"], ["proof (state)\nthis:\n  \\<Or>range\n        (\\<lambda>i.\n            power.power II (;;)\n             (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n            (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)) =\n  (\\<Sqinter> i \\<in> {0..} \\<bullet> power.power II (;;)\n (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n?[\\<not> b])\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "also"], ["proof (state)\nthis:\n  \\<Or>range\n        (\\<lambda>i.\n            power.power II (;;)\n             (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n            (false \\<triangleleft> b \\<triangleright>\\<^sub>r II)) =\n  (\\<Sqinter> i \\<in> {0..} \\<bullet> power.power II (;;)\n (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n?[\\<not> b])\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "have \"... = (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;; [(\\<not>b)]\\<^sup>\\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> i \\<in> {0..} \\<bullet> power.power II (;;)\n   (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n  ?[\\<not> b]) =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "by (metis seq_UINF_distr ustar_def)"], ["proof (state)\nthis:\n  (\\<Sqinter> i \\<in> {0..} \\<bullet> power.power II (;;)\n (P \\<triangleleft> b \\<triangleright>\\<^sub>r II) i ;;\n?[\\<not> b]) =\n  (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n  ?[\\<not> b]\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "finally"], ["proof (chain)\npicking this:\n  while\\<^sup>\\<top> b do P od =\n  (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n  ?[\\<not> b]", "show ?thesis"], ["proof (prove)\nusing this:\n  while\\<^sup>\\<top> b do P od =\n  (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n  ?[\\<not> b]\n\ngoal (1 subgoal):\n 1. while\\<^sup>\\<top> b do P od =\n    (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n    ?[\\<not> b]", "."], ["proof (state)\nthis:\n  while\\<^sup>\\<top> b do P od =\n  (P \\<triangleleft> b \\<triangleright>\\<^sub>r II)\\<^sup>\\<star> ;;\n  ?[\\<not> b]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Omega Algebra Laws \\<close>"], ["", "lemma uomega_induct:\n  \"P ;; P\\<^sup>\\<omega> \\<sqsubseteq> P\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; P\\<^sup>\\<omega> \\<sqsubseteq> P\\<^sup>\\<omega>", "by (simp add: uomega_def, metis eq_refl gfp_unfold monoI seqr_mono)"], ["", "subsection \\<open> Refinement Laws \\<close>"], ["", "lemma skip_r_refine:\n  \"(p \\<Rightarrow> p) \\<sqsubseteq> II\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<Rightarrow> p) \\<sqsubseteq> II", "by pred_blast"], ["", "lemma conj_refine_left:\n  \"(Q \\<Rightarrow> P) \\<sqsubseteq> R \\<Longrightarrow> P \\<sqsubseteq> (Q \\<and> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q \\<Rightarrow> P) \\<sqsubseteq> R \\<Longrightarrow>\n    P \\<sqsubseteq> (Q \\<and> R)", "by (rel_auto)"], ["", "lemma pre_weak_rel:\n  assumes \"`Pre \\<Rightarrow> I`\"\n  and     \"(I \\<Rightarrow> Post) \\<sqsubseteq> P\"\n  shows \"(Pre \\<Rightarrow> Post) \\<sqsubseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pre \\<Rightarrow> Post) \\<sqsubseteq> P", "using assms"], ["proof (prove)\nusing this:\n  `Pre \\<Rightarrow> I`\n  (I \\<Rightarrow> Post) \\<sqsubseteq> P\n\ngoal (1 subgoal):\n 1. (Pre \\<Rightarrow> Post) \\<sqsubseteq> P", "by(rel_auto)"], ["", "lemma cond_refine_rel: \n  assumes \"S \\<sqsubseteq> (\\<lceil>b\\<rceil>\\<^sub>< \\<and> P)\" \"S \\<sqsubseteq> (\\<lceil>\\<not>b\\<rceil>\\<^sub>< \\<and> Q)\"\n  shows \"S \\<sqsubseteq> P \\<triangleleft> b \\<triangleright>\\<^sub>r Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<sqsubseteq> P \\<triangleleft> b \\<triangleright>\\<^sub>r Q", "by (metis aext_not assms(1) assms(2) cond_def lift_rcond_def utp_pred_laws.le_sup_iff)"], ["", "lemma seq_refine_pred:\n  assumes \"(\\<lceil>b\\<rceil>\\<^sub>< \\<Rightarrow> \\<lceil>s\\<rceil>\\<^sub>>) \\<sqsubseteq> P\" and \"(\\<lceil>s\\<rceil>\\<^sub>< \\<Rightarrow> \\<lceil>c\\<rceil>\\<^sub>>) \\<sqsubseteq> Q\"\n  shows \"(\\<lceil>b\\<rceil>\\<^sub>< \\<Rightarrow> \\<lceil>c\\<rceil>\\<^sub>>) \\<sqsubseteq> (P ;; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lceil>b\\<rceil>\\<^sub>< \\<Rightarrow>\n     \\<lceil>c\\<rceil>\\<^sub>>) \\<sqsubseteq>\n    P ;; Q", "using assms"], ["proof (prove)\nusing this:\n  (\\<lceil>b\\<rceil>\\<^sub>< \\<Rightarrow>\n   \\<lceil>s\\<rceil>\\<^sub>>) \\<sqsubseteq>\n  P\n  (\\<lceil>s\\<rceil>\\<^sub>< \\<Rightarrow>\n   \\<lceil>c\\<rceil>\\<^sub>>) \\<sqsubseteq>\n  Q\n\ngoal (1 subgoal):\n 1. (\\<lceil>b\\<rceil>\\<^sub>< \\<Rightarrow>\n     \\<lceil>c\\<rceil>\\<^sub>>) \\<sqsubseteq>\n    P ;; Q", "by rel_auto"], ["", "lemma seq_refine_unrest:\n  assumes \"out\\<alpha> \\<sharp> b\" \"in\\<alpha> \\<sharp> c\"\n  assumes \"(b \\<Rightarrow> \\<lceil>s\\<rceil>\\<^sub>>) \\<sqsubseteq> P\" and \"(\\<lceil>s\\<rceil>\\<^sub>< \\<Rightarrow> c) \\<sqsubseteq> Q\"\n  shows \"(b \\<Rightarrow> c) \\<sqsubseteq> (P ;; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<Rightarrow> c) \\<sqsubseteq> P ;; Q", "using assms"], ["proof (prove)\nusing this:\n  out\\<alpha> \\<sharp> b\n  in\\<alpha> \\<sharp> c\n  (b \\<Rightarrow> \\<lceil>s\\<rceil>\\<^sub>>) \\<sqsubseteq> P\n  (\\<lceil>s\\<rceil>\\<^sub>< \\<Rightarrow> c) \\<sqsubseteq> Q\n\ngoal (1 subgoal):\n 1. (b \\<Rightarrow> c) \\<sqsubseteq> P ;; Q", "by rel_blast"], ["", "subsection \\<open> Domain and Range Laws \\<close>"], ["", "lemma Dom_conv_Ran:\n  \"Dom(P\\<^sup>-) = Ran(P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (P\\<^sup>-) = Ran P", "by (rel_auto)"], ["", "lemma Ran_conv_Dom:\n  \"Ran(P\\<^sup>-) = Dom(P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ran (P\\<^sup>-) = Dom P", "by (rel_auto)"], ["", "lemma Dom_skip:\n  \"Dom(II) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom II = true", "by (rel_auto)"], ["", "lemma Dom_assigns:\n  \"Dom(\\<langle>\\<sigma>\\<rangle>\\<^sub>a) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom \\<langle>\\<sigma>\\<rangle>\\<^sub>a = true", "by (rel_auto)"], ["", "lemma Dom_miracle:\n  \"Dom(false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom false = false", "by (rel_auto)"], ["", "lemma Dom_assume:\n  \"Dom([b]\\<^sup>\\<top>) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom ?[b] = b", "by (rel_auto)"], ["", "lemma Dom_seq:\n  \"Dom(P ;; Q) = Dom(P ;; [Dom(Q)]\\<^sup>\\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (P ;; Q) = Dom (P ;; ?[Dom Q])", "by (rel_auto)"], ["", "lemma Dom_disj:\n  \"Dom(P \\<or> Q) = (Dom(P) \\<or> Dom(Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (P \\<or> Q) = (Dom P \\<or> Dom Q)", "by (rel_auto)"], ["", "lemma Dom_inf:\n  \"Dom(P \\<sqinter> Q) = (Dom(P) \\<or> Dom(Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (P \\<sqinter> Q) = (Dom P \\<or> Dom Q)", "by (rel_auto)"], ["", "lemma assume_Dom:\n  \"[Dom(P)]\\<^sup>\\<top> ;; P = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ?[Dom P] ;; P = P", "by (rel_auto)"], ["", "end"]]}