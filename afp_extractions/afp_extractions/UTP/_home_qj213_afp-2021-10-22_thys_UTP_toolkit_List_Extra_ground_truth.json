{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/toolkit/List_Extra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["lemma foldr_snoc: \"foldr (\\<^bold>*) (xs @ [x]) k = (foldr (\\<^bold>*) xs k) \\<^bold>* x\"", "lemma nth_el_appendl[simp]: \"i < length xs \\<Longrightarrow> (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l = xs\\<langle>i\\<rangle>\\<^sub>l\"", "lemma nth_el_appendr[simp]: \"length xs \\<le> i \\<Longrightarrow> (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l = ys\\<langle>i - length xs\\<rangle>\\<^sub>l\"", "lemma map_nth_Cons_atLeastLessThan:\n  \"map (nth (x # xs)) [Suc m..<n] = map (nth xs) [m..<n - 1]\"", "lemma sorted_last [simp]: \"\\<lbrakk> x \\<in> set xs; sorted xs \\<rbrakk> \\<Longrightarrow> x \\<le> last xs\"", "lemma sorted_prefix:\n  assumes \"xs \\<le> ys\" \"sorted ys\"\n  shows \"sorted xs\"", "lemma sorted_map: \"\\<lbrakk> sorted xs; mono f \\<rbrakk> \\<Longrightarrow> sorted (map f xs)\"", "lemma sorted_distinct [intro]: \"\\<lbrakk> sorted (xs); distinct(xs) \\<rbrakk> \\<Longrightarrow> (\\<forall> i<length xs - 1. xs!i < xs!(i + 1))\"", "lemma sorted_is_sorted_list_of_set:\n  assumes \"is_sorted_list_of_set A xs\"\n  shows \"sorted(xs)\" and \"distinct(xs)\"", "lemma is_sorted_list_of_set_alt_def:\n  \"is_sorted_list_of_set A xs \\<longleftrightarrow> sorted (xs) \\<and> distinct (xs) \\<and> set(xs) = A\"", "lemma is_sorted_list_of_set:\n  \"finite A \\<Longrightarrow> is_sorted_list_of_set A (sorted_list_of_set A)\"", "lemma sorted_list_of_set_other_def:\n  \"finite A \\<Longrightarrow> sorted_list_of_set(A) = (THE xs. sorted(xs) \\<and> distinct(xs) \\<and> set xs = A)\"", "lemma sorted_list_of_set_alt [simp]:\n  \"finite A \\<Longrightarrow> sorted_list_of_set_alt(A) = sorted_list_of_set(A)\"", "lemma is_sorted_list_of_set_by_mono:\n  \"\\<lbrakk> R \\<subseteq> S; is_sorted_list_of_set_by R A xs \\<rbrakk> \\<Longrightarrow> is_sorted_list_of_set_by S A xs\"", "lemma lexord_mono':\n  \"\\<lbrakk> (\\<And> x y. f x y \\<longrightarrow> g x y); (xs, ys) \\<in> lexord {(x, y). f x y} \\<rbrakk> \\<Longrightarrow> (xs, ys) \\<in> lexord {(x, y). g x y}\"", "lemma fin_set_lexord_mono [mono]:\n  \"(\\<And> x y. f x y \\<longrightarrow> g x y) \\<Longrightarrow> (xs, ys) \\<in> fin_set_lexord {(x, y). f x y} \\<longrightarrow> (xs, ys) \\<in> fin_set_lexord {(x, y). g x y}\"", "lemma tl_element:\n  \"\\<lbrakk> x \\<in> set xs; x \\<noteq> hd(xs) \\<rbrakk> \\<Longrightarrow> x \\<in> set(tl(xs))\"", "lemma listsum_update:\n  fixes xs :: \"'a::ring list\"\n  assumes \"i < length xs\"\n  shows \"list_sum (xs[i := v]) = list_sum xs - xs ! i + v\"", "lemma dropWhile_sorted_le_above:\n  \"\\<lbrakk> sorted xs; x \\<in> set (dropWhile (\\<lambda> x. x \\<le> n) xs) \\<rbrakk> \\<Longrightarrow> x > n\"", "lemma set_dropWhile_le:\n  \"sorted xs \\<Longrightarrow> set (dropWhile (\\<lambda> x. x \\<le> n) xs) = {x\\<in>set xs. x > n}\"", "lemma set_takeWhile_less_sorted:\n  \"\\<lbrakk> sorted I; x \\<in> set I; x < n \\<rbrakk> \\<Longrightarrow> x \\<in> set (takeWhile (\\<lambda>x. x < n) I)\"", "lemma nth_le_takeWhile_ord: \"\\<lbrakk> sorted xs; i \\<ge> length (takeWhile (\\<lambda> x. x \\<le> n) xs); i < length xs \\<rbrakk> \\<Longrightarrow> n \\<le> xs ! i\"", "lemma length_takeWhile_less:\n  \"\\<lbrakk> a \\<in> set xs; \\<not> P a \\<rbrakk> \\<Longrightarrow> length (takeWhile P xs) < length xs\"", "lemma nth_length_takeWhile_less:\n  \"\\<lbrakk> sorted xs; distinct xs; (\\<exists> a \\<in> set xs. a \\<ge> n) \\<rbrakk> \\<Longrightarrow> xs ! length (takeWhile (\\<lambda>x. x < n) xs) \\<ge> n\"", "lemma length_gt_zero_butlast_concat:\n  assumes \"length ys > 0\"\n  shows \"butlast (xs @ ys) = xs @ (butlast ys)\"", "lemma length_eq_zero_butlast_concat:\n  assumes \"length ys = 0\"\n  shows \"butlast (xs @ ys) = butlast xs\"", "lemma butlast_single_element:\n  shows \"butlast [e] = []\"", "lemma last_single_element:\n  shows \"last [e] = e\"", "lemma length_zero_last_concat:\n  assumes \"length t = 0\"\n  shows \"last (s @ t) = last s\"", "lemma length_gt_zero_last_concat:\n  assumes \"length t > 0\"\n  shows \"last (s @ t) = last t\"", "lemma prefix_length_eq:\n  \"\\<lbrakk> length xs = length ys; prefix xs ys \\<rbrakk> \\<Longrightarrow> xs = ys\"", "lemma prefix_Cons_elim [elim]:\n  assumes \"prefix (x # xs) ys\"\n  obtains ys' where \"ys = x # ys'\" \"prefix xs ys'\"", "lemma prefix_map_inj:\n  \"\\<lbrakk> inj_on f (set xs \\<union> set ys); prefix (map f xs) (map f ys) \\<rbrakk> \\<Longrightarrow>\n   prefix xs ys\"", "lemma prefix_map_inj_eq [simp]:\n  \"inj_on f (set xs \\<union> set ys) \\<Longrightarrow>\n   prefix (map f xs) (map f ys) \\<longleftrightarrow> prefix xs ys\"", "lemma strict_prefix_Cons_elim [elim]:\n  assumes \"strict_prefix (x # xs) ys\"\n  obtains ys' where \"ys = x # ys'\" \"strict_prefix xs ys'\"", "lemma strict_prefix_map_inj:\n  \"\\<lbrakk> inj_on f (set xs \\<union> set ys); strict_prefix (map f xs) (map f ys) \\<rbrakk> \\<Longrightarrow>\n   strict_prefix xs ys\"", "lemma strict_prefix_map_inj_eq [simp]:\n  \"inj_on f (set xs \\<union> set ys) \\<Longrightarrow>\n   strict_prefix (map f xs) (map f ys) \\<longleftrightarrow> strict_prefix xs ys\"", "lemma prefix_drop:\n  \"\\<lbrakk> drop (length xs) ys = zs; prefix xs ys \\<rbrakk>\n   \\<Longrightarrow> ys = xs @ zs\"", "lemma list_append_prefixD [dest]: \"x @ y \\<le> z \\<Longrightarrow> x \\<le> z\"", "lemma prefix_not_empty:\n  assumes \"strict_prefix xs ys\" and \"xs \\<noteq> []\"\n  shows \"ys \\<noteq> []\"", "lemma prefix_not_empty_length_gt_zero:\n  assumes \"strict_prefix xs ys\" and \"xs \\<noteq> []\"\n  shows \"length ys > 0\"", "lemma butlast_prefix_suffix_not_empty:\n  assumes \"strict_prefix (butlast xs) ys\"\n  shows \"ys \\<noteq> []\"", "lemma prefix_and_concat_prefix_is_concat_prefix:\n  assumes \"prefix s t\" \"prefix (e @ t) u\"\n  shows \"prefix (e @ s) u\"", "lemma prefix_eq_exists:\n  \"prefix s t \\<longleftrightarrow> (\\<exists>xs . s @ xs = t)\"", "lemma strict_prefix_eq_exists:\n  \"strict_prefix s t \\<longleftrightarrow> (\\<exists>xs . s @ xs = t \\<and> (length xs) > 0)\"", "lemma butlast_strict_prefix_eq_butlast:\n  assumes \"length s = length t\" and \"strict_prefix (butlast s) t\"\n  shows \"strict_prefix (butlast s) t \\<longleftrightarrow> (butlast s) = (butlast t)\"", "lemma butlast_eq_if_eq_length_and_prefix:\n  assumes \"length s > 0\" \"length z > 0\"\n          \"length s = length z\" \"strict_prefix (butlast s) t\" \"strict_prefix (butlast z) t\"\n  shows   \"(butlast s) = (butlast z)\"", "lemma butlast_prefix_imp_length_not_gt:\n  assumes \"length s > 0\" \"strict_prefix (butlast s) t\"\n  shows \"\\<not> (length t < length s)\"", "lemma length_not_gt_iff_eq_length:\n  assumes \"length s > 0\" and \"strict_prefix (butlast s) t\"\n  shows \"(\\<not> (length s < length t)) = (length s = length t)\"", "lemma gcp_right [simp]: \"gcp xs [] = []\"", "lemma gcp_append [simp]: \"gcp (xs @ ys) (xs @ zs) = xs @ gcp ys zs\"", "lemma gcp_lb1: \"prefix (gcp xs ys) xs\"", "lemma gcp_lb2: \"prefix (gcp xs ys) ys\"", "lemma lexord_append:\n  assumes \"(xs\\<^sub>1 @ ys\\<^sub>1, xs\\<^sub>2 @ ys\\<^sub>2) \\<in> lexord R\" \"length(xs\\<^sub>1) = length(xs\\<^sub>2)\"\n  shows \"(xs\\<^sub>1, xs\\<^sub>2) \\<in> lexord R \\<or> (xs\\<^sub>1 = xs\\<^sub>2 \\<and> (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R)\"", "lemma strict_prefix_lexord_rel:\n  \"strict_prefix xs ys \\<Longrightarrow> (xs, ys) \\<in> lexord R\"", "lemma strict_prefix_lexord_left:\n  assumes \"trans R\" \"(xs, ys) \\<in> lexord R\" \"strict_prefix xs' xs\"\n  shows \"(xs', ys) \\<in> lexord R\"", "lemma prefix_lexord_right:\n  assumes \"trans R\" \"(xs, ys) \\<in> lexord R\" \"strict_prefix ys ys'\"\n  shows \"(xs, ys') \\<in> lexord R\"", "lemma lexord_eq_length:\n  assumes \"(xs, ys) \\<in> lexord R\" \"length xs = length ys\"\n  shows \"\\<exists> i. (xs!i, ys!i) \\<in> R \\<and> i < length xs \\<and> (\\<forall> j<i. xs!j = ys!j)\"", "lemma lexord_intro_elems:\n  assumes \"length xs > i\" \"length ys > i\" \"(xs!i, ys!i) \\<in> R\" \"\\<forall> j<i. xs!j = ys!j\"\n  shows \"(xs, ys) \\<in> lexord R\"", "lemma dist_concat_left_empty [simp]:\n  \"{} \\<^sup>\\<frown> ys = {}\"", "lemma dist_concat_right_empty [simp]:\n  \"xs \\<^sup>\\<frown> {} = {}\"", "lemma dist_concat_insert [simp]:\n\"insert l ls1 \\<^sup>\\<frown> ls2 = ((@) l ` ( ls2)) \\<union> (ls1 \\<^sup>\\<frown> ls2)\"", "lemma seq_extract_Nil [simp]: \"A \\<upharpoonleft>\\<^sub>l [] = []\"", "lemma seq_extract_Cons:\n  \"A \\<upharpoonleft>\\<^sub>l (x # xs) = (if 0 \\<in> A then [x] else []) @ {j. Suc j \\<in> A} \\<upharpoonleft>\\<^sub>l xs\"", "lemma seq_extract_empty [simp]: \"{} \\<upharpoonleft>\\<^sub>l xs = []\"", "lemma seq_extract_ident [simp]: \"{0..<length xs} \\<upharpoonleft>\\<^sub>l xs = xs\"", "lemma seq_extract_split:\n  assumes \"i \\<le> length xs\"\n  shows \"{0..<i} \\<upharpoonleft>\\<^sub>l xs @ {i..<length xs} \\<upharpoonleft>\\<^sub>l xs = xs\"", "lemma seq_extract_append:\n  \"A \\<upharpoonleft>\\<^sub>l (xs @ ys) = (A \\<upharpoonleft>\\<^sub>l xs) @ ({j. j + length xs \\<in> A} \\<upharpoonleft>\\<^sub>l ys)\"", "lemma seq_extract_range: \"A \\<upharpoonleft>\\<^sub>l xs = (A \\<inter> dom\\<^sub>l(xs)) \\<upharpoonleft>\\<^sub>l xs\"", "lemma seq_extract_out_of_range:\n  \"A \\<inter> dom\\<^sub>l(xs) = {} \\<Longrightarrow> A \\<upharpoonleft>\\<^sub>l xs = []\"", "lemma seq_extract_length [simp]:\n  \"length (A \\<upharpoonleft>\\<^sub>l xs) = card (A \\<inter> dom\\<^sub>l(xs))\"", "lemma seq_extract_Cons_atLeastLessThan:\n  assumes \"m < n\"\n  shows \"{m..<n} \\<upharpoonleft>\\<^sub>l (x # xs) = (if (m = 0) then x # ({0..<n-1} \\<upharpoonleft>\\<^sub>l xs) else {m-1..<n-1} \\<upharpoonleft>\\<^sub>l xs)\"", "lemma seq_extract_singleton:\n  assumes \"i < length xs\"\n  shows \"{i} \\<upharpoonleft>\\<^sub>l xs = [xs ! i]\"", "lemma seq_extract_as_map:\n  assumes \"m < n\" \"n \\<le> length xs\"\n  shows \"{m..<n} \\<upharpoonleft>\\<^sub>l xs = map (nth xs) [m..<n]\"", "lemma seq_append_as_extract:\n  \"xs = ys @ zs \\<longleftrightarrow> (\\<exists> i\\<le>length(xs). ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and> zs = {i..<length(xs)} \\<upharpoonleft>\\<^sub>l xs)\"", "lemma seq_filter_Cons_in [simp]: \n  \"x \\<in> cs \\<Longrightarrow> (x # xs) \\<restriction>\\<^sub>l cs = x # (xs \\<restriction>\\<^sub>l cs)\"", "lemma seq_filter_Cons_out [simp]: \n  \"x \\<notin> cs \\<Longrightarrow> (x # xs) \\<restriction>\\<^sub>l cs = (xs \\<restriction>\\<^sub>l cs)\"", "lemma seq_filter_Nil [simp]: \"[] \\<restriction>\\<^sub>l A = []\"", "lemma seq_filter_empty [simp]: \"xs \\<restriction>\\<^sub>l {} = []\"", "lemma seq_filter_append: \"(xs @ ys) \\<restriction>\\<^sub>l A = (xs \\<restriction>\\<^sub>l A) @ (ys \\<restriction>\\<^sub>l A)\"", "lemma seq_filter_UNIV [simp]: \"xs \\<restriction>\\<^sub>l UNIV = xs\"", "lemma seq_filter_twice [simp]: \"(xs \\<restriction>\\<^sub>l A) \\<restriction>\\<^sub>l B = xs \\<restriction>\\<^sub>l (A \\<inter> B)\"", "lemma minus_cancel [simp]: \"xs - xs = []\"", "lemma append_minus [simp]: \"(xs @ ys) - xs = ys\"", "lemma minus_right_nil [simp]: \"xs - [] = xs\"", "lemma list_concat_minus_list_concat: \"(s @ t) - (s @ z) = t - z\"", "lemma length_minus_list: \"y \\<le> x \\<Longrightarrow> length(x - y) = length(x) - length(y)\"", "lemma map_list_minus:\n  \"xs \\<le> ys \\<Longrightarrow> map f (ys - xs) = map f ys - map f xs\"", "lemma list_minus_first_tl [simp]: \n  \"[x] \\<le> xs \\<Longrightarrow> (xs - [x]) = tl xs\"", "lemma prefix_concat_minus:\n  assumes \"prefix xs ys\"\n  shows \"xs @ (ys - xs) = ys\"", "lemma prefix_minus_concat:\n  assumes \"prefix s t\"\n  shows \"(t - s) @ z = (t @ z) - s\"", "lemma strict_prefix_minus_not_empty:\n  assumes \"strict_prefix xs ys\"\n  shows \"ys - xs \\<noteq> []\"", "lemma strict_prefix_diff_minus:\n  assumes \"prefix xs ys\" and \"xs \\<noteq> ys\"\n  shows \"(ys - xs) \\<noteq> []\"", "lemma length_tl_list_minus_butlast_gt_zero:\n  assumes \"length s < length t\" and \"strict_prefix (butlast s) t\" and \"length s > 0\"\n  shows \"length (tl (t - (butlast s))) > 0\"", "lemma list_minus_butlast_eq_butlast_list:\n  assumes \"length t = length s\" and \"strict_prefix (butlast s) t\"\n  shows \"t - (butlast s) = [last t]\"", "lemma butlast_strict_prefix_length_lt_imp_last_tl_minus_butlast_eq_last:\n  assumes \"length s > 0\" \"strict_prefix (butlast s) t\" \"length s < length t\"\n  shows \"last (tl (t - (butlast s))) = (last t)\"", "lemma tl_list_minus_butlast_not_empty:\n  assumes \"strict_prefix (butlast s) t\" and \"length s > 0\" and \"length t > length s\"\n  shows \"tl (t - (butlast s)) \\<noteq> []\"", "lemma tl_list_minus_butlast_empty:\n  assumes \"strict_prefix (butlast s) t\" and \"length s > 0\" and \"length t = length s\"\n  shows \"tl (t - (butlast s)) = []\"", "lemma tl_list_minus_butlast_eq_empty:\n  assumes \"strict_prefix (butlast s) t\" and \"length s = length t\"\n  shows \"tl (t - (butlast s)) = []\"", "lemma length_list_minus:\n  assumes \"strict_prefix s t\"\n  shows \"length(t - s) = length(t) - length(s)\"", "lemma take_prefix: \"m \\<le> n \\<Longrightarrow> take m xs \\<le> take n xs\"", "lemma nths_atLeastAtMost_0_take: \"nths xs {0..m} = take (Suc m) xs\"", "lemma nths_atLeastLessThan_0_take: \"nths xs {0..<m} = take m xs\"", "lemma nths_atLeastAtMost_prefix: \"m \\<le> n \\<Longrightarrow> nths xs {0..m} \\<le> nths xs {0..n}\"", "lemma sorted_nths_atLeastAtMost_0: \"\\<lbrakk> m \\<le> n; sorted (nths xs {0..n}) \\<rbrakk> \\<Longrightarrow> sorted (nths xs {0..m})\"", "lemma sorted_nths_atLeastLessThan_0: \"\\<lbrakk> m \\<le> n; sorted (nths xs {0..<n}) \\<rbrakk> \\<Longrightarrow> sorted (nths xs {0..<m})\"", "lemma list_augment_as_update: \n  \"k < length xs \\<Longrightarrow> list_augment xs k x = list_update xs k x\"", "lemma nths_list_update_out: \"k \\<notin> A \\<Longrightarrow> nths (list_update xs k x) A = nths xs A\"", "lemma nths_list_augment_out: \"\\<lbrakk> k < length xs; k \\<notin> A \\<rbrakk> \\<Longrightarrow> nths (list_augment xs k x) A = nths xs A\""], "translations": [["", "lemma foldr_snoc: \"foldr (\\<^bold>*) (xs @ [x]) k = (foldr (\\<^bold>*) xs k) \\<^bold>* x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<^bold>*) (xs @ [x]) k = foldr (\\<^bold>*) xs k \\<^bold>* x", "by (induct xs, simp_all add: commute left_commute)"], ["", "end"], ["", "subsection \\<open> List Lookup \\<close>"], ["", "text \\<open>\n  The following variant of the standard \\<open>nth\\<close> function returns \\<open>\\<bottom>\\<close> if the index is \n  out of range.\n\\<close>"], ["", "primrec\n  nth_el :: \"'a list \\<Rightarrow> nat \\<Rightarrow> 'a option\" (\"_\\<langle>_\\<rangle>\\<^sub>l\" [90, 0] 91)\nwhere\n  \"[]\\<langle>i\\<rangle>\\<^sub>l = None\"\n| \"(x # xs)\\<langle>i\\<rangle>\\<^sub>l = (case i of 0 \\<Rightarrow> Some x | Suc j \\<Rightarrow> xs \\<langle>j\\<rangle>\\<^sub>l)\""], ["", "lemma nth_el_appendl[simp]: \"i < length xs \\<Longrightarrow> (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l = xs\\<langle>i\\<rangle>\\<^sub>l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l = xs\\<langle>i\\<rangle>\\<^sub>l", "apply (induct xs arbitrary: i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length [] \\<Longrightarrow>\n       ([] @ ys)\\<langle>i\\<rangle>\\<^sub>l = []\\<langle>i\\<rangle>\\<^sub>l\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                   xs\\<langle>i\\<rangle>\\<^sub>l;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ((a # xs) @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                         (a # xs)\\<langle>i\\<rangle>\\<^sub>l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                   xs\\<langle>i\\<rangle>\\<^sub>l;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ((a # xs) @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                         (a # xs)\\<langle>i\\<rangle>\\<^sub>l", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                   xs\\<langle>i\\<rangle>\\<^sub>l;\n        i < length (a # xs); i = 0\\<rbrakk>\n       \\<Longrightarrow> ((a # xs) @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                         (a # xs)\\<langle>i\\<rangle>\\<^sub>l\n 2. \\<And>a xs i nat.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                   xs\\<langle>i\\<rangle>\\<^sub>l;\n        i < length (a # xs); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> ((a # xs) @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                         (a # xs)\\<langle>i\\<rangle>\\<^sub>l", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_el_appendr[simp]: \"length xs \\<le> i \\<Longrightarrow> (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l = ys\\<langle>i - length xs\\<rangle>\\<^sub>l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> i \\<Longrightarrow>\n    (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n    ys\\<langle>i - length xs\\<rangle>\\<^sub>l", "apply (induct xs arbitrary: i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       length [] \\<le> i \\<Longrightarrow>\n       ([] @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n       ys\\<langle>i - length []\\<rangle>\\<^sub>l\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   length xs \\<le> i \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                   ys\\<langle>i - length xs\\<rangle>\\<^sub>l;\n        length (a # xs) \\<le> i\\<rbrakk>\n       \\<Longrightarrow> ((a # xs) @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                         ys\\<langle>i - length (a # xs)\\<rangle>\\<^sub>l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   length xs \\<le> i \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                   ys\\<langle>i - length xs\\<rangle>\\<^sub>l;\n        length (a # xs) \\<le> i\\<rbrakk>\n       \\<Longrightarrow> ((a # xs) @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                         ys\\<langle>i - length (a # xs)\\<rangle>\\<^sub>l", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   length xs \\<le> i \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                   ys\\<langle>i - length xs\\<rangle>\\<^sub>l;\n        length (a # xs) \\<le> i; i = 0\\<rbrakk>\n       \\<Longrightarrow> ((a # xs) @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                         ys\\<langle>i - length (a # xs)\\<rangle>\\<^sub>l\n 2. \\<And>a xs i nat.\n       \\<lbrakk>\\<And>i.\n                   length xs \\<le> i \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                   ys\\<langle>i - length xs\\<rangle>\\<^sub>l;\n        length (a # xs) \\<le> i; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> ((a # xs) @ ys)\\<langle>i\\<rangle>\\<^sub>l =\n                         ys\\<langle>i - length (a # xs)\\<rangle>\\<^sub>l", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open> Extra List Theorems \\<close>"], ["", "subsubsection \\<open> Map \\<close>"], ["", "lemma map_nth_Cons_atLeastLessThan:\n  \"map (nth (x # xs)) [Suc m..<n] = map (nth xs) [m..<n - 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]", "have \"nth xs = nth (x # xs) \\<circ> Suc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) xs = (!) (x # xs) \\<circ> Suc", "by auto"], ["proof (state)\nthis:\n  (!) xs = (!) (x # xs) \\<circ> Suc\n\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]", "hence \"map (nth xs) [m..<n - 1] = map (nth (x # xs) \\<circ> Suc) [m..<n - 1]\""], ["proof (prove)\nusing this:\n  (!) xs = (!) (x # xs) \\<circ> Suc\n\ngoal (1 subgoal):\n 1. map ((!) xs) [m..<n - 1] = map ((!) (x # xs) \\<circ> Suc) [m..<n - 1]", "by simp"], ["proof (state)\nthis:\n  map ((!) xs) [m..<n - 1] = map ((!) (x # xs) \\<circ> Suc) [m..<n - 1]\n\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]", "also"], ["proof (state)\nthis:\n  map ((!) xs) [m..<n - 1] = map ((!) (x # xs) \\<circ> Suc) [m..<n - 1]\n\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]", "have \"... = map (nth (x # xs)) (map Suc [m..<n - 1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (x # xs) \\<circ> Suc) [m..<n - 1] =\n    map ((!) (x # xs)) (map Suc [m..<n - 1])", "by simp"], ["proof (state)\nthis:\n  map ((!) (x # xs) \\<circ> Suc) [m..<n - 1] =\n  map ((!) (x # xs)) (map Suc [m..<n - 1])\n\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]", "also"], ["proof (state)\nthis:\n  map ((!) (x # xs) \\<circ> Suc) [m..<n - 1] =\n  map ((!) (x # xs)) (map Suc [m..<n - 1])\n\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]", "have \"... = map (nth (x # xs)) [Suc m..<n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) (map Suc [m..<n - 1]) =\n    map ((!) (x # xs)) [Suc m..<n]", "by (metis Suc_diff_1 le_0_eq length_upt list.simps(8) list.size(3) map_Suc_upt not_less upt_0)"], ["proof (state)\nthis:\n  map ((!) (x # xs)) (map Suc [m..<n - 1]) = map ((!) (x # xs)) [Suc m..<n]\n\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]", "finally"], ["proof (chain)\npicking this:\n  map ((!) xs) [m..<n - 1] = map ((!) (x # xs)) [Suc m..<n]", "show ?thesis"], ["proof (prove)\nusing this:\n  map ((!) xs) [m..<n - 1] = map ((!) (x # xs)) [Suc m..<n]\n\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]", ".."], ["proof (state)\nthis:\n  map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open> Sorted Lists \\<close>"], ["", "lemma sorted_last [simp]: \"\\<lbrakk> x \\<in> set xs; sorted xs \\<rbrakk> \\<Longrightarrow> x \\<le> last xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; sorted xs\\<rbrakk>\n    \\<Longrightarrow> x \\<le> last xs", "by (induct xs, auto)"], ["", "lemma sorted_prefix:\n  assumes \"xs \\<le> ys\" \"sorted ys\"\n  shows \"sorted xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted xs", "obtain zs where \"ys = xs @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>zs. ys = xs @ zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Prefix_Order.prefixE assms(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs \\<le> ?ys;\n   \\<And>zs. ?ys = ?xs @ zs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  xs \\<le> ys\n\ngoal (1 subgoal):\n 1. (\\<And>zs. ys = xs @ zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ys = xs @ zs\n\ngoal (1 subgoal):\n 1. sorted xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys = xs @ zs\n\ngoal (1 subgoal):\n 1. sorted xs", "using assms(2) sorted_append"], ["proof (prove)\nusing this:\n  ys = xs @ zs\n  sorted ys\n  sorted (?xs @ ?ys) =\n  (sorted ?xs \\<and>\n   sorted ?ys \\<and>\n   (\\<forall>x\\<in>set ?xs. \\<forall>y\\<in>set ?ys. x \\<le> y))\n\ngoal (1 subgoal):\n 1. sorted xs", "by blast"], ["proof (state)\nthis:\n  sorted xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_map: \"\\<lbrakk> sorted xs; mono f \\<rbrakk> \\<Longrightarrow> sorted (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; mono f\\<rbrakk> \\<Longrightarrow> sorted (map f xs)", "by (simp add: monoD sorted_iff_nth_mono)"], ["", "lemma sorted_distinct [intro]: \"\\<lbrakk> sorted (xs); distinct(xs) \\<rbrakk> \\<Longrightarrow> (\\<forall> i<length xs - 1. xs!i < xs!(i + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length xs - 1. xs ! i < xs ! (i + 1)", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted []; distinct []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length [] - 1. [] ! i < [] ! (i + 1)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>sorted xs; distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<forall>i<length xs - 1.\n                                     xs ! i < xs ! (i + 1);\n        sorted (a # xs); distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # xs) - 1.\n                            (a # xs) ! i < (a # xs) ! (i + 1)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<forall>i<length xs - Suc 0. xs ! i < xs ! Suc i;\n        \\<forall>x\\<in>set xs. a \\<le> x; sorted xs; a \\<notin> set xs;\n        distinct xs; i < length xs\\<rbrakk>\n       \\<Longrightarrow> (a # xs) ! i < xs ! i", "apply (metis (no_types, hide_lams) Suc_leI Suc_less_eq Suc_pred gr0_conv_Suc not_le not_less_iff_gr_or_eq nth_Cons_Suc nth_mem nth_non_equal_first_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open> Is the given list a permutation of the given set? \\<close>"], ["", "definition is_sorted_list_of_set :: \"('a::ord) set \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n\"is_sorted_list_of_set A xs = ((\\<forall> i<length(xs) - 1. xs!i < xs!(i + 1)) \\<and> set(xs) = A)\""], ["", "lemma sorted_is_sorted_list_of_set:\n  assumes \"is_sorted_list_of_set A xs\"\n  shows \"sorted(xs)\" and \"distinct(xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs &&& distinct xs", "using assms"], ["proof (prove)\nusing this:\n  is_sorted_list_of_set A xs\n\ngoal (1 subgoal):\n 1. sorted xs &&& distinct xs", "proof (induct xs arbitrary: A)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>A. is_sorted_list_of_set A [] \\<Longrightarrow> sorted []\n 2. \\<And>A. is_sorted_list_of_set A [] \\<Longrightarrow> distinct []\n 3. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted (a # xs)\n 4. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "show \"sorted []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted []", "by auto"], ["proof (state)\nthis:\n  sorted []\n\ngoal (3 subgoals):\n 1. \\<And>A. is_sorted_list_of_set A [] \\<Longrightarrow> distinct []\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted (a # xs)\n 3. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A. is_sorted_list_of_set A [] \\<Longrightarrow> distinct []\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted (a # xs)\n 3. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "show \"distinct []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct []", "by auto"], ["proof (state)\nthis:\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted (a # xs)\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted (a # xs)\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "fix A :: \"'a set\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted (a # xs)\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  is_sorted_list_of_set ?A xs \\<Longrightarrow> sorted xs\n  is_sorted_list_of_set ?A xs \\<Longrightarrow> distinct xs\n\ngoal (2 subgoals):\n 1. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted (a # xs)\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "note hyps = this"], ["proof (state)\nthis:\n  is_sorted_list_of_set ?A xs \\<Longrightarrow> sorted xs\n  is_sorted_list_of_set ?A xs \\<Longrightarrow> distinct xs\n\ngoal (2 subgoals):\n 1. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted (a # xs)\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "assume isl: \"is_sorted_list_of_set A (x # xs)\""], ["proof (state)\nthis:\n  is_sorted_list_of_set A (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted (a # xs)\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "hence srt: \"(\\<forall>i<length xs - Suc 0. xs ! i < xs ! Suc i)\""], ["proof (prove)\nusing this:\n  is_sorted_list_of_set A (x # xs)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length xs - Suc 0. xs ! i < xs ! Suc i", "using less_diff_conv"], ["proof (prove)\nusing this:\n  is_sorted_list_of_set A (x # xs)\n  (?i < ?j - ?k) = (?i + ?k < ?j)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length xs - Suc 0. xs ! i < xs ! Suc i", "by (auto simp add: is_sorted_list_of_set_def)"], ["proof (state)\nthis:\n  \\<forall>i<length xs - Suc 0. xs ! i < xs ! Suc i\n\ngoal (2 subgoals):\n 1. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted (a # xs)\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "with hyps(1)"], ["proof (chain)\npicking this:\n  is_sorted_list_of_set ?A xs \\<Longrightarrow> sorted xs\n  \\<forall>i<length xs - Suc 0. xs ! i < xs ! Suc i", "have srtd: \"sorted xs\""], ["proof (prove)\nusing this:\n  is_sorted_list_of_set ?A xs \\<Longrightarrow> sorted xs\n  \\<forall>i<length xs - Suc 0. xs ! i < xs ! Suc i\n\ngoal (1 subgoal):\n 1. sorted xs", "by (simp add: is_sorted_list_of_set_def)"], ["proof (state)\nthis:\n  sorted xs\n\ngoal (2 subgoals):\n 1. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted (a # xs)\n 2. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "with isl"], ["proof (chain)\npicking this:\n  is_sorted_list_of_set A (x # xs)\n  sorted xs", "show \"sorted (x # xs)\""], ["proof (prove)\nusing this:\n  is_sorted_list_of_set A (x # xs)\n  sorted xs\n\ngoal (1 subgoal):\n 1. sorted (x # xs)", "apply (auto simp add: is_sorted_list_of_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>sorted xs; xa \\<in> set xs;\n        \\<forall>i<length xs. (x # xs) ! i < xs ! i;\n        A = insert x (set xs)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> xa", "apply (metis (mono_tags, lifting) all_nth_imp_all_set less_le_trans linorder_not_less not_less_iff_gr_or_eq nth_Cons_0 sorted_iff_nth_mono zero_order(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "from srt hyps(2)"], ["proof (chain)\npicking this:\n  \\<forall>i<length xs - Suc 0. xs ! i < xs ! Suc i\n  is_sorted_list_of_set ?A xs \\<Longrightarrow> distinct xs", "have \"distinct xs\""], ["proof (prove)\nusing this:\n  \\<forall>i<length xs - Suc 0. xs ! i < xs ! Suc i\n  is_sorted_list_of_set ?A xs \\<Longrightarrow> distinct xs\n\ngoal (1 subgoal):\n 1. distinct xs", "by (simp add: is_sorted_list_of_set_def)"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs A.\n       \\<lbrakk>\\<And>A.\n                   is_sorted_list_of_set A xs \\<Longrightarrow> sorted xs;\n        \\<And>A. is_sorted_list_of_set A xs \\<Longrightarrow> distinct xs;\n        is_sorted_list_of_set A (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "with isl"], ["proof (chain)\npicking this:\n  is_sorted_list_of_set A (x # xs)\n  distinct xs", "show \"distinct (x # xs)\""], ["proof (prove)\nusing this:\n  is_sorted_list_of_set A (x # xs)\n  distinct xs\n\ngoal (1 subgoal):\n 1. distinct (x # xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_sorted_list_of_set A (x # xs); distinct xs\\<rbrakk>\n    \\<Longrightarrow> distinct (x # xs)", "have \"(\\<forall>n. \\<not> n < length (x # xs) - 1 \\<or> (x # xs) ! n < (x # xs) ! (n + 1)) \\<and> set (x # xs) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n.\n        \\<not> n < length (x # xs) - 1 \\<or>\n        (x # xs) ! n < (x # xs) ! (n + 1)) \\<and>\n    set (x # xs) = A", "by (meson \\<open>is_sorted_list_of_set A (x # xs)\\<close> is_sorted_list_of_set_def)"], ["proof (state)\nthis:\n  (\\<forall>n.\n      \\<not> n < length (x # xs) - 1 \\<or>\n      (x # xs) ! n < (x # xs) ! (n + 1)) \\<and>\n  set (x # xs) = A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_sorted_list_of_set A (x # xs); distinct xs\\<rbrakk>\n    \\<Longrightarrow> distinct (x # xs)", "then"], ["proof (chain)\npicking this:\n  (\\<forall>n.\n      \\<not> n < length (x # xs) - 1 \\<or>\n      (x # xs) ! n < (x # xs) ! (n + 1)) \\<and>\n  set (x # xs) = A", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>n.\n      \\<not> n < length (x # xs) - 1 \\<or>\n      (x # xs) ! n < (x # xs) ! (n + 1)) \\<and>\n  set (x # xs) = A\n\ngoal (1 subgoal):\n 1. distinct (x # xs)", "by (metis \\<open>distinct xs\\<close> add.commute add_diff_cancel_left' distinct.simps(2) leD length_Cons length_greater_0_conv length_pos_if_in_set less_le nth_Cons_0 nth_Cons_Suc plus_1_eq_Suc set_ConsD sorted.elims(2) srtd)"], ["proof (state)\nthis:\n  distinct (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_sorted_list_of_set_alt_def:\n  \"is_sorted_list_of_set A xs \\<longleftrightarrow> sorted (xs) \\<and> distinct (xs) \\<and> set(xs) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sorted_list_of_set A xs =\n    (sorted xs \\<and> distinct xs \\<and> set xs = A)", "apply (auto intro: sorted_is_sorted_list_of_set)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_sorted_list_of_set A xs; x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x.\n       \\<lbrakk>is_sorted_list_of_set A xs; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xs\n 3. \\<lbrakk>sorted xs; distinct xs; A = set xs\\<rbrakk>\n    \\<Longrightarrow> is_sorted_list_of_set (set xs) xs", "apply (auto simp add: is_sorted_list_of_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>sorted xs; distinct xs; A = set xs;\n        i < length xs - Suc 0\\<rbrakk>\n       \\<Longrightarrow> xs ! i < xs ! Suc i", "apply (metis Nat.add_0_right One_nat_def add_Suc_right sorted_distinct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition sorted_list_of_set_alt :: \"('a::ord) set \\<Rightarrow> 'a list\" where\n\"sorted_list_of_set_alt A =\n  (if (A = {}) then [] else (THE xs. is_sorted_list_of_set A xs))\""], ["", "lemma is_sorted_list_of_set:\n  \"finite A \\<Longrightarrow> is_sorted_list_of_set A (sorted_list_of_set A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    is_sorted_list_of_set A (sorted_list_of_set A)", "by (simp add: is_sorted_list_of_set_alt_def)"], ["", "lemma sorted_list_of_set_other_def:\n  \"finite A \\<Longrightarrow> sorted_list_of_set(A) = (THE xs. sorted(xs) \\<and> distinct(xs) \\<and> set xs = A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    sorted_list_of_set A =\n    (THE xs. sorted xs \\<and> distinct xs \\<and> set xs = A)", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    (THE xs. sorted xs \\<and> distinct xs \\<and> set xs = A) =\n    sorted_list_of_set A", "apply (rule the_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    sorted (sorted_list_of_set A) \\<and>\n    distinct (sorted_list_of_set A) \\<and> set (sorted_list_of_set A) = A\n 2. \\<And>xs.\n       \\<lbrakk>finite A;\n        sorted xs \\<and> distinct xs \\<and> set xs = A\\<rbrakk>\n       \\<Longrightarrow> xs = sorted_list_of_set A", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>sorted xs; distinct xs; A = set xs\\<rbrakk>\n       \\<Longrightarrow> xs = sorted_list_of_set (set xs)", "apply (simp add: sorted_distinct_set_unique)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sorted_list_of_set_alt [simp]:\n  \"finite A \\<Longrightarrow> sorted_list_of_set_alt(A) = sorted_list_of_set(A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    sorted_list_of_set_alt A = sorted_list_of_set A", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    sorted_list_of_set A = sorted_list_of_set_alt A", "apply (auto simp add: sorted_list_of_set_alt_def is_sorted_list_of_set_alt_def sorted_list_of_set_other_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open> Sorting lists according to a relation \\<close>"], ["", "definition is_sorted_list_of_set_by :: \"'a rel \\<Rightarrow> 'a set \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n\"is_sorted_list_of_set_by R A xs = ((\\<forall> i<length(xs) - 1. (xs!i, xs!(i + 1)) \\<in> R) \\<and> set(xs) = A)\""], ["", "definition sorted_list_of_set_by :: \"'a rel \\<Rightarrow> 'a set \\<Rightarrow> 'a list\" where\n\"sorted_list_of_set_by R A = (THE xs. is_sorted_list_of_set_by R A xs)\""], ["", "definition fin_set_lexord :: \"'a rel \\<Rightarrow> 'a set rel\" where\n\"fin_set_lexord R = {(A, B). finite A \\<and> finite B \\<and>\n                             (\\<exists> xs ys. is_sorted_list_of_set_by R A xs \\<and> is_sorted_list_of_set_by R B ys\n                              \\<and> (xs, ys) \\<in> lexord R)}\""], ["", "lemma is_sorted_list_of_set_by_mono:\n  \"\\<lbrakk> R \\<subseteq> S; is_sorted_list_of_set_by R A xs \\<rbrakk> \\<Longrightarrow> is_sorted_list_of_set_by S A xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R \\<subseteq> S; is_sorted_list_of_set_by R A xs\\<rbrakk>\n    \\<Longrightarrow> is_sorted_list_of_set_by S A xs", "by (auto simp add: is_sorted_list_of_set_by_def)"], ["", "lemma lexord_mono':\n  \"\\<lbrakk> (\\<And> x y. f x y \\<longrightarrow> g x y); (xs, ys) \\<in> lexord {(x, y). f x y} \\<rbrakk> \\<Longrightarrow> (xs, ys) \\<in> lexord {(x, y). g x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y. f x y \\<longrightarrow> g x y;\n     (xs, ys) \\<in> lexord {(x, y). f x y}\\<rbrakk>\n    \\<Longrightarrow> (xs, ys) \\<in> lexord {(x, y). g x y}", "by (metis case_prodD case_prodI lexord_take_index_conv mem_Collect_eq)"], ["", "lemma fin_set_lexord_mono [mono]:\n  \"(\\<And> x y. f x y \\<longrightarrow> g x y) \\<Longrightarrow> (xs, ys) \\<in> fin_set_lexord {(x, y). f x y} \\<longrightarrow> (xs, ys) \\<in> fin_set_lexord {(x, y). g x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. f x y \\<longrightarrow> g x y) \\<Longrightarrow>\n    (xs, ys) \\<in> fin_set_lexord {(x, y). f x y} \\<longrightarrow>\n    (xs, ys) \\<in> fin_set_lexord {(x, y). g x y}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y. f x y \\<longrightarrow> g x y;\n     (xs, ys) \\<in> fin_set_lexord {(x, y). f x y}\\<rbrakk>\n    \\<Longrightarrow> (xs, ys) \\<in> fin_set_lexord {(x, y). g x y}", "assume\n    fin: \"(xs, ys) \\<in> fin_set_lexord {(x, y). f x y}\" and\n    hyp: \"(\\<And> x y. f x y \\<longrightarrow> g x y)\""], ["proof (state)\nthis:\n  (xs, ys) \\<in> fin_set_lexord {(x, y). f x y}\n  f ?x ?y \\<longrightarrow> g ?x ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y. f x y \\<longrightarrow> g x y;\n     (xs, ys) \\<in> fin_set_lexord {(x, y). f x y}\\<rbrakk>\n    \\<Longrightarrow> (xs, ys) \\<in> fin_set_lexord {(x, y). g x y}", "from fin"], ["proof (chain)\npicking this:\n  (xs, ys) \\<in> fin_set_lexord {(x, y). f x y}", "have \"finite xs\" \"finite ys\""], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> fin_set_lexord {(x, y). f x y}\n\ngoal (1 subgoal):\n 1. finite xs &&& finite ys", "using fin_set_lexord_def"], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> fin_set_lexord {(x, y). f x y}\n  fin_set_lexord ?R =\n  {(A, B).\n   finite A \\<and>\n   finite B \\<and>\n   (\\<exists>xs ys.\n       is_sorted_list_of_set_by ?R A xs \\<and>\n       is_sorted_list_of_set_by ?R B ys \\<and> (xs, ys) \\<in> lexord ?R)}\n\ngoal (1 subgoal):\n 1. finite xs &&& finite ys", "by fastforce+"], ["proof (state)\nthis:\n  finite xs\n  finite ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y. f x y \\<longrightarrow> g x y;\n     (xs, ys) \\<in> fin_set_lexord {(x, y). f x y}\\<rbrakk>\n    \\<Longrightarrow> (xs, ys) \\<in> fin_set_lexord {(x, y). g x y}", "with fin hyp"], ["proof (chain)\npicking this:\n  (xs, ys) \\<in> fin_set_lexord {(x, y). f x y}\n  f ?x ?y \\<longrightarrow> g ?x ?y\n  finite xs\n  finite ys", "show \"(xs, ys) \\<in> fin_set_lexord {(x, y). g x y}\""], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> fin_set_lexord {(x, y). f x y}\n  f ?x ?y \\<longrightarrow> g ?x ?y\n  finite xs\n  finite ys\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> fin_set_lexord {(x, y). g x y}", "apply (auto simp add: fin_set_lexord_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xsa ysa.\n       \\<lbrakk>\\<And>x y. f x y \\<longrightarrow> g x y; finite xs;\n        finite ys; is_sorted_list_of_set_by {(x, y). f x y} xs xsa;\n        is_sorted_list_of_set_by {(x, y). f x y} ys ysa;\n        (xsa, ysa) \\<in> lexord {(x, y). f x y}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            is_sorted_list_of_set_by {(x, y). g x y} xs\n                             xsa \\<and>\n                            (\\<exists>ysa.\n                                is_sorted_list_of_set_by {(x, y). g x y} ys\n                                 ysa \\<and>\n                                (xsa, ysa) \\<in> lexord {(x, y). g x y})", "apply (rename_tac xs' ys')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs' ys'.\n       \\<lbrakk>\\<And>x y. f x y \\<longrightarrow> g x y; finite xs;\n        finite ys; is_sorted_list_of_set_by {(x, y). f x y} xs xs';\n        is_sorted_list_of_set_by {(x, y). f x y} ys ys';\n        (xs', ys') \\<in> lexord {(x, y). f x y}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            is_sorted_list_of_set_by {(x, y). g x y} xs\n                             xsa \\<and>\n                            (\\<exists>ysa.\n                                is_sorted_list_of_set_by {(x, y). g x y} ys\n                                 ysa \\<and>\n                                (xsa, ysa) \\<in> lexord {(x, y). g x y})", "apply (rule_tac x=\"xs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs' ys'.\n       \\<lbrakk>\\<And>x y. f x y \\<longrightarrow> g x y; finite xs;\n        finite ys; is_sorted_list_of_set_by {(x, y). f x y} xs xs';\n        is_sorted_list_of_set_by {(x, y). f x y} ys ys';\n        (xs', ys') \\<in> lexord {(x, y). f x y}\\<rbrakk>\n       \\<Longrightarrow> is_sorted_list_of_set_by {(x, y). g x y} xs\n                          xs' \\<and>\n                         (\\<exists>ysa.\n                             is_sorted_list_of_set_by {(x, y). g x y} ys\n                              ysa \\<and>\n                             (xs', ysa) \\<in> lexord {(x, y). g x y})", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs' ys'.\n       \\<lbrakk>\\<And>x y. f x y \\<longrightarrow> g x y; finite xs;\n        finite ys; is_sorted_list_of_set_by {(x, y). f x y} xs xs';\n        is_sorted_list_of_set_by {(x, y). f x y} ys ys';\n        (xs', ys') \\<in> lexord {(x, y). f x y}\\<rbrakk>\n       \\<Longrightarrow> is_sorted_list_of_set_by {(x, y). g x y} xs xs'\n 2. \\<And>xs' ys'.\n       \\<lbrakk>\\<And>x y. f x y \\<longrightarrow> g x y; finite xs;\n        finite ys; is_sorted_list_of_set_by {(x, y). f x y} xs xs';\n        is_sorted_list_of_set_by {(x, y). f x y} ys ys';\n        (xs', ys') \\<in> lexord {(x, y). f x y}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ysa.\n                            is_sorted_list_of_set_by {(x, y). g x y} ys\n                             ysa \\<and>\n                            (xs', ysa) \\<in> lexord {(x, y). g x y}", "apply (metis case_prodD case_prodI is_sorted_list_of_set_by_def mem_Collect_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs' ys'.\n       \\<lbrakk>\\<And>x y. f x y \\<longrightarrow> g x y; finite xs;\n        finite ys; is_sorted_list_of_set_by {(x, y). f x y} xs xs';\n        is_sorted_list_of_set_by {(x, y). f x y} ys ys';\n        (xs', ys') \\<in> lexord {(x, y). f x y}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ysa.\n                            is_sorted_list_of_set_by {(x, y). g x y} ys\n                             ysa \\<and>\n                            (xs', ysa) \\<in> lexord {(x, y). g x y}", "apply (metis case_prodD case_prodI is_sorted_list_of_set_by_def lexord_mono' mem_Collect_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (xs, ys) \\<in> fin_set_lexord {(x, y). g x y}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition distincts :: \"'a set \\<Rightarrow> 'a list set\" where\n\"distincts A = {xs \\<in> lists A. distinct(xs)}\""], ["", "lemma tl_element:\n  \"\\<lbrakk> x \\<in> set xs; x \\<noteq> hd(xs) \\<rbrakk> \\<Longrightarrow> x \\<in> set(tl(xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; x \\<noteq> hd xs\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (tl xs)", "by (metis in_set_insert insert_Nil list.collapse list.distinct(2) set_ConsD)"], ["", "subsubsection \\<open> List Update \\<close>"], ["", "lemma listsum_update:\n  fixes xs :: \"'a::ring list\"\n  assumes \"i < length xs\"\n  shows \"list_sum (xs[i := v]) = list_sum xs - xs ! i + v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_sum (xs[i := v]) = list_sum xs - xs ! i + v", "using assms"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. list_sum (xs[i := v]) = list_sum xs - xs ! i + v", "proof (induct xs arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length [] \\<Longrightarrow>\n       list_sum ([][i := v]) = list_sum [] - [] ! i + v\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   list_sum (xs[i := v]) = list_sum xs - xs ! i + v;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> list_sum ((a # xs)[i := v]) =\n                         list_sum (a # xs) - (a # xs) ! i + v", "case Nil"], ["proof (state)\nthis:\n  i < length []\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length [] \\<Longrightarrow>\n       list_sum ([][i := v]) = list_sum [] - [] ! i + v\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   list_sum (xs[i := v]) = list_sum xs - xs ! i + v;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> list_sum ((a # xs)[i := v]) =\n                         list_sum (a # xs) - (a # xs) ! i + v", "then"], ["proof (chain)\npicking this:\n  i < length []", "show ?case"], ["proof (prove)\nusing this:\n  i < length []\n\ngoal (1 subgoal):\n 1. list_sum ([][i := v]) = list_sum [] - [] ! i + v", "by (simp)"], ["proof (state)\nthis:\n  list_sum ([][i := v]) = list_sum [] - [] ! i + v\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   list_sum (xs[i := v]) = list_sum xs - xs ! i + v;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> list_sum ((a # xs)[i := v]) =\n                         list_sum (a # xs) - (a # xs) ! i + v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   list_sum (xs[i := v]) = list_sum xs - xs ! i + v;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> list_sum ((a # xs)[i := v]) =\n                         list_sum (a # xs) - (a # xs) ! i + v", "case (Cons a xs)"], ["proof (state)\nthis:\n  ?i < length xs \\<Longrightarrow>\n  list_sum (xs[?i := v]) = list_sum xs - xs ! ?i + v\n  i < length (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   list_sum (xs[i := v]) = list_sum xs - xs ! i + v;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> list_sum ((a # xs)[i := v]) =\n                         list_sum (a # xs) - (a # xs) ! i + v", "then"], ["proof (chain)\npicking this:\n  ?i < length xs \\<Longrightarrow>\n  list_sum (xs[?i := v]) = list_sum xs - xs ! ?i + v\n  i < length (a # xs)", "show ?case"], ["proof (prove)\nusing this:\n  ?i < length xs \\<Longrightarrow>\n  list_sum (xs[?i := v]) = list_sum xs - xs ! ?i + v\n  i < length (a # xs)\n\ngoal (1 subgoal):\n 1. list_sum ((a # xs)[i := v]) = list_sum (a # xs) - (a # xs) ! i + v", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length xs \\<Longrightarrow>\n                list_sum (xs[i := v]) = list_sum xs - xs ! i + v;\n     i < length (a # xs); i = 0\\<rbrakk>\n    \\<Longrightarrow> list_sum ((a # xs)[i := v]) =\n                      list_sum (a # xs) - (a # xs) ! i + v\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   list_sum (xs[i := v]) = list_sum xs - xs ! i + v;\n        i < length (a # xs); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_sum ((a # xs)[i := v]) =\n                         list_sum (a # xs) - (a # xs) ! i + v", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length xs \\<Longrightarrow>\n                list_sum (xs[i := v]) = list_sum xs - xs ! i + v;\n     i < length (a # xs); i = 0\\<rbrakk>\n    \\<Longrightarrow> list_sum ((a # xs)[i := v]) =\n                      list_sum (a # xs) - (a # xs) ! i + v\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   list_sum (xs[i := v]) = list_sum xs - xs ! i + v;\n        i < length (a # xs); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_sum ((a # xs)[i := v]) =\n                         list_sum (a # xs) - (a # xs) ! i + v", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. list_sum ((a # xs)[i := v]) = list_sum (a # xs) - (a # xs) ! i + v", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  list_sum ((a # xs)[i := v]) = list_sum (a # xs) - (a # xs) ! i + v\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   list_sum (xs[i := v]) = list_sum xs - xs ! i + v;\n        i < length (a # xs); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_sum ((a # xs)[i := v]) =\n                         list_sum (a # xs) - (a # xs) ! i + v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   list_sum (xs[i := v]) = list_sum xs - xs ! i + v;\n        i < length (a # xs); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_sum ((a # xs)[i := v]) =\n                         list_sum (a # xs) - (a # xs) ! i + v", "case (Suc i')"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   list_sum (xs[i := v]) = list_sum xs - xs ! i + v;\n        i < length (a # xs); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_sum ((a # xs)[i := v]) =\n                         list_sum (a # xs) - (a # xs) ! i + v", "with Cons"], ["proof (chain)\npicking this:\n  ?i < length xs \\<Longrightarrow>\n  list_sum (xs[?i := v]) = list_sum xs - xs ! ?i + v\n  i < length (a # xs)\n  i = Suc i'", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i < length xs \\<Longrightarrow>\n  list_sum (xs[?i := v]) = list_sum xs - xs ! ?i + v\n  i < length (a # xs)\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. list_sum ((a # xs)[i := v]) = list_sum (a # xs) - (a # xs) ! i + v", "by (auto)"], ["proof (state)\nthis:\n  list_sum ((a # xs)[i := v]) = list_sum (a # xs) - (a # xs) ! i + v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_sum ((a # xs)[i := v]) = list_sum (a # xs) - (a # xs) ! i + v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open> Drop While and Take While \\<close>"], ["", "lemma dropWhile_sorted_le_above:\n  \"\\<lbrakk> sorted xs; x \\<in> set (dropWhile (\\<lambda> x. x \\<le> n) xs) \\<rbrakk> \\<Longrightarrow> x > n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs;\n     x \\<in> set (dropWhile (\\<lambda>x. x \\<le> n) xs)\\<rbrakk>\n    \\<Longrightarrow> n < x", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted [];\n     x \\<in> set (dropWhile (\\<lambda>x. x \\<le> n) [])\\<rbrakk>\n    \\<Longrightarrow> n < x\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>sorted xs;\n                 x \\<in> set (dropWhile (\\<lambda>x. x \\<le> n) xs)\\<rbrakk>\n                \\<Longrightarrow> n < x;\n        sorted (a # xs);\n        x \\<in> set (dropWhile (\\<lambda>x. x \\<le> n) (a # xs))\\<rbrakk>\n       \\<Longrightarrow> n < x", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>x \\<in> set (dropWhile (\\<lambda>x. x \\<le> n)\n                              xs) \\<Longrightarrow>\n                n < x;\n        x \\<in> set (if a \\<le> n then dropWhile (\\<lambda>x. x \\<le> n) xs\n                     else a # xs);\n        \\<forall>x\\<in>set xs. a \\<le> x; sorted xs\\<rbrakk>\n       \\<Longrightarrow> n < x", "apply (rename_tac a xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>x \\<in> set (dropWhile (\\<lambda>x. x \\<le> n)\n                              xs) \\<Longrightarrow>\n                n < x;\n        x \\<in> set (if a \\<le> n then dropWhile (\\<lambda>x. x \\<le> n) xs\n                     else a # xs);\n        \\<forall>x\\<in>set xs. a \\<le> x; sorted xs\\<rbrakk>\n       \\<Longrightarrow> n < x", "apply (case_tac \"a \\<le> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>x \\<in> set (dropWhile (\\<lambda>x. x \\<le> n)\n                              xs) \\<Longrightarrow>\n                n < x;\n        x \\<in> set (if a \\<le> n then dropWhile (\\<lambda>x. x \\<le> n) xs\n                     else a # xs);\n        \\<forall>x\\<in>set xs. a \\<le> x; sorted xs; a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> n < x\n 2. \\<And>a xs.\n       \\<lbrakk>x \\<in> set (dropWhile (\\<lambda>x. x \\<le> n)\n                              xs) \\<Longrightarrow>\n                n < x;\n        x \\<in> set (if a \\<le> n then dropWhile (\\<lambda>x. x \\<le> n) xs\n                     else a # xs);\n        \\<forall>x\\<in>set xs. a \\<le> x; sorted xs;\n        \\<not> a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> n < x", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_dropWhile_le:\n  \"sorted xs \\<Longrightarrow> set (dropWhile (\\<lambda> x. x \\<le> n) xs) = {x\\<in>set xs. x > n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs \\<Longrightarrow>\n    set (dropWhile (\\<lambda>x. x \\<le> n) xs) = {x \\<in> set xs. n < x}", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sorted [] \\<Longrightarrow>\n    set (dropWhile (\\<lambda>x. x \\<le> n) []) = {x \\<in> set []. n < x}\n 2. \\<And>a xs.\n       \\<lbrakk>sorted xs \\<Longrightarrow>\n                set (dropWhile (\\<lambda>x. x \\<le> n) xs) =\n                {x \\<in> set xs. n < x};\n        sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (dropWhile (\\<lambda>x. x \\<le> n) (a # xs)) =\n                         {x \\<in> set (a # xs). n < x}", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>sorted xs \\<Longrightarrow>\n                set (dropWhile (\\<lambda>x. x \\<le> n) xs) =\n                {x \\<in> set xs. n < x};\n        sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (dropWhile (\\<lambda>x. x \\<le> n) (a # xs)) =\n                         {x \\<in> set (a # xs). n < x}", "apply (rename_tac x xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>sorted xs \\<Longrightarrow>\n                set (dropWhile (\\<lambda>x. x \\<le> n) xs) =\n                {x \\<in> set xs. n < x};\n        sorted (x # xs)\\<rbrakk>\n       \\<Longrightarrow> set (dropWhile (\\<lambda>x. x \\<le> n) (x # xs)) =\n                         {xa \\<in> set (x # xs). n < xa}", "apply (subgoal_tac \"sorted xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>sorted xs \\<Longrightarrow>\n                set (dropWhile (\\<lambda>x. x \\<le> n) xs) =\n                {x \\<in> set xs. n < x};\n        sorted (x # xs); sorted xs\\<rbrakk>\n       \\<Longrightarrow> set (dropWhile (\\<lambda>x. x \\<le> n) (x # xs)) =\n                         {xa \\<in> set (x # xs). n < xa}\n 2. \\<And>x xs.\n       \\<lbrakk>sorted xs \\<Longrightarrow>\n                set (dropWhile (\\<lambda>x. x \\<le> n) xs) =\n                {x \\<in> set xs. n < x};\n        sorted (x # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted xs", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>set (dropWhile (\\<lambda>x. x \\<le> n) xs) =\n                {x \\<in> set xs. n < x};\n        \\<forall>xa\\<in>set xs. x \\<le> xa; sorted xs\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> n \\<longrightarrow>\n                          {x \\<in> set xs. n < x} =\n                          {xa.\n                           (xa = x \\<or> xa \\<in> set xs) \\<and>\n                           n < xa}) \\<and>\n                         (\\<not> x \\<le> n \\<longrightarrow>\n                          insert x (set xs) =\n                          {xa.\n                           (xa = x \\<or> xa \\<in> set xs) \\<and> n < xa})\n 2. \\<And>x xs.\n       \\<lbrakk>sorted xs \\<Longrightarrow>\n                set (dropWhile (\\<lambda>x. x \\<le> n) xs) =\n                {x \\<in> set xs. n < x};\n        sorted (x # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted xs", "apply (safe)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xs xa.\n       \\<lbrakk>set (dropWhile (\\<lambda>x. x \\<le> n) xs) =\n                {x \\<in> set xs. n < x};\n        \\<forall>xa\\<in>set xs. x \\<le> xa; sorted xs; x \\<le> n;\n        n < x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xs\n 2. \\<And>x xs xa.\n       \\<lbrakk>set (dropWhile (\\<lambda>x. x \\<le> n) xs) =\n                {x \\<in> set xs. n < x};\n        \\<forall>xa\\<in>set xs. x \\<le> xa; sorted xs;\n        \\<not> x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> n < x\n 3. \\<And>x xs xa.\n       \\<lbrakk>set (dropWhile (\\<lambda>x. x \\<le> n) xs) =\n                {x \\<in> set xs. n < x};\n        \\<forall>xa\\<in>set xs. x \\<le> xa; sorted xs; \\<not> x \\<le> n;\n        xa \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> n < xa\n 4. \\<And>x xs.\n       \\<lbrakk>sorted xs \\<Longrightarrow>\n                set (dropWhile (\\<lambda>x. x \\<le> n) xs) =\n                {x \\<in> set xs. n < x};\n        sorted (x # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted xs", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_takeWhile_less_sorted:\n  \"\\<lbrakk> sorted I; x \\<in> set I; x < n \\<rbrakk> \\<Longrightarrow> x \\<in> set (takeWhile (\\<lambda>x. x < n) I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted I; x \\<in> set I; x < n\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (takeWhile (\\<lambda>x. x < n) I)", "proof (induct I arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted []; x \\<in> set []; x < n\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (takeWhile (\\<lambda>x. x < n) [])\n 2. \\<And>a I x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>sorted I; x \\<in> set I; x < n\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> set\n        (takeWhile (\\<lambda>x. x < n) I);\n        sorted (a # I); x \\<in> set (a # I); x < n\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (takeWhile (\\<lambda>x. x < n) (a # I))", "case Nil"], ["proof (state)\nthis:\n  sorted []\n  x \\<in> set []\n  x < n\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sorted []; x \\<in> set []; x < n\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (takeWhile (\\<lambda>x. x < n) [])\n 2. \\<And>a I x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>sorted I; x \\<in> set I; x < n\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> set\n        (takeWhile (\\<lambda>x. x < n) I);\n        sorted (a # I); x \\<in> set (a # I); x < n\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (takeWhile (\\<lambda>x. x < n) (a # I))", "thus ?case"], ["proof (prove)\nusing this:\n  sorted []\n  x \\<in> set []\n  x < n\n\ngoal (1 subgoal):\n 1. x \\<in> set (takeWhile (\\<lambda>x. x < n) [])", "by (simp)"], ["proof (state)\nthis:\n  x \\<in> set (takeWhile (\\<lambda>x. x < n) [])\n\ngoal (1 subgoal):\n 1. \\<And>a I x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>sorted I; x \\<in> set I; x < n\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> set\n        (takeWhile (\\<lambda>x. x < n) I);\n        sorted (a # I); x \\<in> set (a # I); x < n\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (takeWhile (\\<lambda>x. x < n) (a # I))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a I x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>sorted I; x \\<in> set I; x < n\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> set\n        (takeWhile (\\<lambda>x. x < n) I);\n        sorted (a # I); x \\<in> set (a # I); x < n\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (takeWhile (\\<lambda>x. x < n) (a # I))", "case (Cons a I)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted I; ?x \\<in> set I; ?x < n\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> set (takeWhile (\\<lambda>x. x < n) I)\n  sorted (a # I)\n  x \\<in> set (a # I)\n  x < n\n\ngoal (1 subgoal):\n 1. \\<And>a I x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>sorted I; x \\<in> set I; x < n\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> set\n        (takeWhile (\\<lambda>x. x < n) I);\n        sorted (a # I); x \\<in> set (a # I); x < n\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (takeWhile (\\<lambda>x. x < n) (a # I))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted I; ?x \\<in> set I; ?x < n\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> set (takeWhile (\\<lambda>x. x < n) I)\n  sorted (a # I)\n  x \\<in> set (a # I)\n  x < n\n\ngoal (1 subgoal):\n 1. x \\<in> set (takeWhile (\\<lambda>x. x < n) (a # I))", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (takeWhile (\\<lambda>x. x < n) (a # I))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_le_takeWhile_ord: \"\\<lbrakk> sorted xs; i \\<ge> length (takeWhile (\\<lambda> x. x \\<le> n) xs); i < length xs \\<rbrakk> \\<Longrightarrow> n \\<le> xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs;\n     length (takeWhile (\\<lambda>x. x \\<le> n) xs) \\<le> i;\n     i < length xs\\<rbrakk>\n    \\<Longrightarrow> n \\<le> xs ! i", "apply (induct xs arbitrary: i, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>length (takeWhile (\\<lambda>x. x \\<le> n) xs)\n                            \\<le> i;\n                    i < length xs\\<rbrakk>\n                   \\<Longrightarrow> n \\<le> xs ! i;\n        length\n         (if a \\<le> n then a # takeWhile (\\<lambda>x. x \\<le> n) xs\n          else [])\n        \\<le> i;\n        i < Suc (length xs); \\<forall>x\\<in>set xs. a \\<le> x;\n        sorted xs\\<rbrakk>\n       \\<Longrightarrow> n \\<le> (a # xs) ! i", "apply (rename_tac x xs i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>length (takeWhile (\\<lambda>x. x \\<le> n) xs)\n                            \\<le> i;\n                    i < length xs\\<rbrakk>\n                   \\<Longrightarrow> n \\<le> xs ! i;\n        length\n         (if x \\<le> n then x # takeWhile (\\<lambda>x. x \\<le> n) xs\n          else [])\n        \\<le> i;\n        i < Suc (length xs); \\<forall>xa\\<in>set xs. x \\<le> xa;\n        sorted xs\\<rbrakk>\n       \\<Longrightarrow> n \\<le> (x # xs) ! i", "apply (case_tac \"x \\<le> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>length (takeWhile (\\<lambda>x. x \\<le> n) xs)\n                            \\<le> i;\n                    i < length xs\\<rbrakk>\n                   \\<Longrightarrow> n \\<le> xs ! i;\n        length\n         (if x \\<le> n then x # takeWhile (\\<lambda>x. x \\<le> n) xs\n          else [])\n        \\<le> i;\n        i < Suc (length xs); \\<forall>xa\\<in>set xs. x \\<le> xa; sorted xs;\n        x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> n \\<le> (x # xs) ! i\n 2. \\<And>x xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>length (takeWhile (\\<lambda>x. x \\<le> n) xs)\n                            \\<le> i;\n                    i < length xs\\<rbrakk>\n                   \\<Longrightarrow> n \\<le> xs ! i;\n        length\n         (if x \\<le> n then x # takeWhile (\\<lambda>x. x \\<le> n) xs\n          else [])\n        \\<le> i;\n        i < Suc (length xs); \\<forall>xa\\<in>set xs. x \\<le> xa; sorted xs;\n        \\<not> x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> n \\<le> (x # xs) ! i", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>length (takeWhile (\\<lambda>x. x \\<le> n) xs)\n                            \\<le> i;\n                    i < length xs\\<rbrakk>\n                   \\<Longrightarrow> n \\<le> xs ! i;\n        i < Suc (length xs); \\<forall>xa\\<in>set xs. x \\<le> xa; sorted xs;\n        \\<not> x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> n \\<le> (x # xs) ! i", "apply (metis One_nat_def Suc_eq_plus1 le_less_linear le_less_trans less_imp_le list.size(4) nth_mem set_ConsD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_takeWhile_less:\n  \"\\<lbrakk> a \\<in> set xs; \\<not> P a \\<rbrakk> \\<Longrightarrow> length (takeWhile P xs) < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set xs; \\<not> P a\\<rbrakk>\n    \\<Longrightarrow> length (takeWhile P xs) < length xs", "by (metis in_set_conv_nth length_takeWhile_le nat_neq_iff not_less set_takeWhileD takeWhile_nth)"], ["", "lemma nth_length_takeWhile_less:\n  \"\\<lbrakk> sorted xs; distinct xs; (\\<exists> a \\<in> set xs. a \\<ge> n) \\<rbrakk> \\<Longrightarrow> xs ! length (takeWhile (\\<lambda>x. x < n) xs) \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; distinct xs;\n     \\<exists>a\\<in>set xs. n \\<le> a\\<rbrakk>\n    \\<Longrightarrow> n \\<le> xs ! length (takeWhile (\\<lambda>x. x < n) xs)", "by (induct xs, auto)"], ["", "subsubsection \\<open> Last and But Last \\<close>"], ["", "lemma length_gt_zero_butlast_concat:\n  assumes \"length ys > 0\"\n  shows \"butlast (xs @ ys) = xs @ (butlast ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (xs @ ys) = xs @ butlast ys", "using assms"], ["proof (prove)\nusing this:\n  0 < length ys\n\ngoal (1 subgoal):\n 1. butlast (xs @ ys) = xs @ butlast ys", "by (metis butlast_append length_greater_0_conv)"], ["", "lemma length_eq_zero_butlast_concat:\n  assumes \"length ys = 0\"\n  shows \"butlast (xs @ ys) = butlast xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (xs @ ys) = butlast xs", "using assms"], ["proof (prove)\nusing this:\n  length ys = 0\n\ngoal (1 subgoal):\n 1. butlast (xs @ ys) = butlast xs", "by (metis append_Nil2 length_0_conv)"], ["", "lemma butlast_single_element:\n  shows \"butlast [e] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast [e] = []", "by (metis butlast.simps(2))"], ["", "lemma last_single_element:\n  shows \"last [e] = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last [e] = e", "by (metis last.simps)"], ["", "lemma length_zero_last_concat:\n  assumes \"length t = 0\"\n  shows \"last (s @ t) = last s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (s @ t) = last s", "by (metis append_Nil2 assms length_0_conv)"], ["", "lemma length_gt_zero_last_concat:\n  assumes \"length t > 0\"\n  shows \"last (s @ t) = last t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (s @ t) = last t", "by (metis assms last_append length_greater_0_conv)"], ["", "subsubsection \\<open> Prefixes and Strict Prefixes \\<close>"], ["", "lemma prefix_length_eq:\n  \"\\<lbrakk> length xs = length ys; prefix xs ys \\<rbrakk> \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys; prefix xs ys\\<rbrakk>\n    \\<Longrightarrow> xs = ys", "by (metis not_equal_is_parallel parallel_def)"], ["", "lemma prefix_Cons_elim [elim]:\n  assumes \"prefix (x # xs) ys\"\n  obtains ys' where \"ys = x # ys'\" \"prefix xs ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys'.\n        \\<lbrakk>ys = x # ys'; prefix xs ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  prefix (x # xs) ys\n\ngoal (1 subgoal):\n 1. (\\<And>ys'.\n        \\<lbrakk>ys = x # ys'; prefix xs ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_Cons prefix_def)"], ["", "lemma prefix_map_inj:\n  \"\\<lbrakk> inj_on f (set xs \\<union> set ys); prefix (map f xs) (map f ys) \\<rbrakk> \\<Longrightarrow>\n   prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f (set xs \\<union> set ys);\n     prefix (map f xs) (map f ys)\\<rbrakk>\n    \\<Longrightarrow> prefix xs ys", "apply (induct xs arbitrary:ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>inj_on f (set [] \\<union> set ys);\n        prefix (map f []) (map f ys)\\<rbrakk>\n       \\<Longrightarrow> prefix [] ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>inj_on f (set xs \\<union> set ys);\n                    prefix (map f xs) (map f ys)\\<rbrakk>\n                   \\<Longrightarrow> prefix xs ys;\n        inj_on f (set (a # xs) \\<union> set ys);\n        prefix (map f (a # xs)) (map f ys)\\<rbrakk>\n       \\<Longrightarrow> prefix (a # xs) ys", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>inj_on f (set xs \\<union> set ys);\n                    prefix (map f xs) (map f ys)\\<rbrakk>\n                   \\<Longrightarrow> prefix xs ys;\n        inj_on f (set xs \\<union> set ys) \\<and>\n        f a \\<notin> f ` (set xs \\<union> set ys - {a});\n        prefix (f a # map f xs) (map f ys)\\<rbrakk>\n       \\<Longrightarrow> prefix (a # xs) ys", "apply (erule prefix_Cons_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys ys'.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>inj_on f (set xs \\<union> set ys);\n                    prefix (map f xs) (map f ys)\\<rbrakk>\n                   \\<Longrightarrow> prefix xs ys;\n        inj_on f (set xs \\<union> set ys) \\<and>\n        f a \\<notin> f ` (set xs \\<union> set ys - {a});\n        map f ys = f a # ys'; prefix (map f xs) ys'\\<rbrakk>\n       \\<Longrightarrow> prefix (a # xs) ys", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs z zs.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>inj_on f (set xs \\<union> set ys);\n                    prefix (map f xs) (map f ys)\\<rbrakk>\n                   \\<Longrightarrow> prefix xs ys;\n        prefix (map f xs) (map f zs);\n        f a \\<notin> f ` (insert z (set xs \\<union> set zs) - {a});\n        f z = f a; inj_on f (set xs \\<union> set zs);\n        f a \\<notin> f ` (set xs \\<union> set zs - {z})\\<rbrakk>\n       \\<Longrightarrow> a = z", "apply (metis image_insert insertI1 insert_Diff_if singletonE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prefix_map_inj_eq [simp]:\n  \"inj_on f (set xs \\<union> set ys) \\<Longrightarrow>\n   prefix (map f xs) (map f ys) \\<longleftrightarrow> prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (set xs \\<union> set ys) \\<Longrightarrow>\n    prefix (map f xs) (map f ys) = prefix xs ys", "using map_mono_prefix prefix_map_inj"], ["proof (prove)\nusing this:\n  prefix ?xs ?ys \\<Longrightarrow> prefix (map ?f ?xs) (map ?f ?ys)\n  \\<lbrakk>inj_on ?f (set ?xs \\<union> set ?ys);\n   prefix (map ?f ?xs) (map ?f ?ys)\\<rbrakk>\n  \\<Longrightarrow> prefix ?xs ?ys\n\ngoal (1 subgoal):\n 1. inj_on f (set xs \\<union> set ys) \\<Longrightarrow>\n    prefix (map f xs) (map f ys) = prefix xs ys", "by blast"], ["", "lemma strict_prefix_Cons_elim [elim]:\n  assumes \"strict_prefix (x # xs) ys\"\n  obtains ys' where \"ys = x # ys'\" \"strict_prefix xs ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys'.\n        \\<lbrakk>ys = x # ys'; strict_prefix xs ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  strict_prefix (x # xs) ys\n\ngoal (1 subgoal):\n 1. (\\<And>ys'.\n        \\<lbrakk>ys = x # ys'; strict_prefix xs ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Sublist.strict_prefixE' Sublist.strict_prefixI' append_Cons)"], ["", "lemma strict_prefix_map_inj:\n  \"\\<lbrakk> inj_on f (set xs \\<union> set ys); strict_prefix (map f xs) (map f ys) \\<rbrakk> \\<Longrightarrow>\n   strict_prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f (set xs \\<union> set ys);\n     strict_prefix (map f xs) (map f ys)\\<rbrakk>\n    \\<Longrightarrow> strict_prefix xs ys", "apply (induct xs arbitrary:ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>inj_on f (set [] \\<union> set ys);\n        strict_prefix (map f []) (map f ys)\\<rbrakk>\n       \\<Longrightarrow> strict_prefix [] ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>inj_on f (set xs \\<union> set ys);\n                    strict_prefix (map f xs) (map f ys)\\<rbrakk>\n                   \\<Longrightarrow> strict_prefix xs ys;\n        inj_on f (set (a # xs) \\<union> set ys);\n        strict_prefix (map f (a # xs)) (map f ys)\\<rbrakk>\n       \\<Longrightarrow> strict_prefix (a # xs) ys", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>inj_on f (set ys); strict_prefix [] (map f ys)\\<rbrakk>\n       \\<Longrightarrow> strict_prefix [] ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>inj_on f (set xs \\<union> set ys);\n                    strict_prefix (map f xs) (map f ys)\\<rbrakk>\n                   \\<Longrightarrow> strict_prefix xs ys;\n        strict_prefix (f a # map f xs) (map f ys);\n        inj_on f (set xs \\<union> set ys);\n        f a \\<notin> f ` (set xs \\<union> set ys - {a})\\<rbrakk>\n       \\<Longrightarrow> strict_prefix (a # xs) ys", "using prefix_bot.bot.not_eq_extremum"], ["proof (prove)\nusing this:\n  (?a \\<noteq> []) = strict_prefix [] ?a\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>inj_on f (set ys); strict_prefix [] (map f ys)\\<rbrakk>\n       \\<Longrightarrow> strict_prefix [] ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>inj_on f (set xs \\<union> set ys);\n                    strict_prefix (map f xs) (map f ys)\\<rbrakk>\n                   \\<Longrightarrow> strict_prefix xs ys;\n        strict_prefix (f a # map f xs) (map f ys);\n        inj_on f (set xs \\<union> set ys);\n        f a \\<notin> f ` (set xs \\<union> set ys - {a})\\<rbrakk>\n       \\<Longrightarrow> strict_prefix (a # xs) ys", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>inj_on f (set xs \\<union> set ys);\n                    strict_prefix (map f xs) (map f ys)\\<rbrakk>\n                   \\<Longrightarrow> strict_prefix xs ys;\n        strict_prefix (f a # map f xs) (map f ys);\n        inj_on f (set xs \\<union> set ys);\n        f a \\<notin> f ` (set xs \\<union> set ys - {a})\\<rbrakk>\n       \\<Longrightarrow> strict_prefix (a # xs) ys", "apply (erule strict_prefix_Cons_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys ys'.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>inj_on f (set xs \\<union> set ys);\n                    strict_prefix (map f xs) (map f ys)\\<rbrakk>\n                   \\<Longrightarrow> strict_prefix xs ys;\n        inj_on f (set xs \\<union> set ys);\n        f a \\<notin> f ` (set xs \\<union> set ys - {a});\n        map f ys = f a # ys'; strict_prefix (map f xs) ys'\\<rbrakk>\n       \\<Longrightarrow> strict_prefix (a # xs) ys", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs z zs.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>inj_on f (set xs \\<union> set ys);\n                    strict_prefix (map f xs) (map f ys)\\<rbrakk>\n                   \\<Longrightarrow> strict_prefix xs ys;\n        f a \\<notin> f ` (insert z (set xs \\<union> set zs) - {a});\n        strict_prefix (map f xs) (map f zs); f z = f a;\n        inj_on f (set xs \\<union> set zs);\n        f a \\<notin> f ` (set xs \\<union> set zs - {z})\\<rbrakk>\n       \\<Longrightarrow> a = z", "apply (metis (hide_lams, full_types) image_insert insertI1 insert_Diff_if singletonE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma strict_prefix_map_inj_eq [simp]:\n  \"inj_on f (set xs \\<union> set ys) \\<Longrightarrow>\n   strict_prefix (map f xs) (map f ys) \\<longleftrightarrow> strict_prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (set xs \\<union> set ys) \\<Longrightarrow>\n    strict_prefix (map f xs) (map f ys) = strict_prefix xs ys", "by (simp add: inj_on_map_eq_map strict_prefix_def)"], ["", "lemma prefix_drop:\n  \"\\<lbrakk> drop (length xs) ys = zs; prefix xs ys \\<rbrakk>\n   \\<Longrightarrow> ys = xs @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop (length xs) ys = zs; prefix xs ys\\<rbrakk>\n    \\<Longrightarrow> ys = xs @ zs", "by (metis append_eq_conv_conj prefix_def)"], ["", "lemma list_append_prefixD [dest]: \"x @ y \\<le> z \\<Longrightarrow> x \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x @ y \\<le> z \\<Longrightarrow> x \\<le> z", "using append_prefixD less_eq_list_def"], ["proof (prove)\nusing this:\n  prefix (?xs @ ?ys) ?zs \\<Longrightarrow> prefix ?xs ?zs\n  ?xs \\<le> ?ys \\<equiv> prefix ?xs ?ys\n\ngoal (1 subgoal):\n 1. x @ y \\<le> z \\<Longrightarrow> x \\<le> z", "by blast"], ["", "lemma prefix_not_empty:\n  assumes \"strict_prefix xs ys\" and \"xs \\<noteq> []\"\n  shows \"ys \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "using Sublist.strict_prefix_simps(1) assms(1)"], ["proof (prove)\nusing this:\n  strict_prefix ?xs [] = False\n  strict_prefix xs ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "by blast"], ["", "lemma prefix_not_empty_length_gt_zero:\n  assumes \"strict_prefix xs ys\" and \"xs \\<noteq> []\"\n  shows \"length ys > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length ys", "using assms prefix_not_empty"], ["proof (prove)\nusing this:\n  strict_prefix xs ys\n  xs \\<noteq> []\n  \\<lbrakk>strict_prefix ?xs ?ys; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length ys", "by auto"], ["", "lemma butlast_prefix_suffix_not_empty:\n  assumes \"strict_prefix (butlast xs) ys\"\n  shows \"ys \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "using assms prefix_not_empty_length_gt_zero"], ["proof (prove)\nusing this:\n  strict_prefix (butlast xs) ys\n  \\<lbrakk>strict_prefix ?xs ?ys; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> 0 < length ?ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "by fastforce"], ["", "lemma prefix_and_concat_prefix_is_concat_prefix:\n  assumes \"prefix s t\" \"prefix (e @ t) u\"\n  shows \"prefix (e @ s) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (e @ s) u", "using Sublist.same_prefix_prefix assms(1) assms(2) prefix_order.dual_order.trans"], ["proof (prove)\nusing this:\n  prefix (?xs @ ?ys) (?xs @ ?zs) = prefix ?ys ?zs\n  prefix s t\n  prefix (e @ t) u\n  \\<lbrakk>prefix ?b ?a; prefix ?c ?b\\<rbrakk>\n  \\<Longrightarrow> prefix ?c ?a\n\ngoal (1 subgoal):\n 1. prefix (e @ s) u", "by blast"], ["", "lemma prefix_eq_exists:\n  \"prefix s t \\<longleftrightarrow> (\\<exists>xs . s @ xs = t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix s t = (\\<exists>xs. s @ xs = t)", "using prefix_def"], ["proof (prove)\nusing this:\n  prefix ?xs ?ys = (\\<exists>zs. ?ys = ?xs @ zs)\n\ngoal (1 subgoal):\n 1. prefix s t = (\\<exists>xs. s @ xs = t)", "by auto"], ["", "lemma strict_prefix_eq_exists:\n  \"strict_prefix s t \\<longleftrightarrow> (\\<exists>xs . s @ xs = t \\<and> (length xs) > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_prefix s t = (\\<exists>xs. s @ xs = t \\<and> 0 < length xs)", "using prefix_def strict_prefix_def"], ["proof (prove)\nusing this:\n  prefix ?xs ?ys = (\\<exists>zs. ?ys = ?xs @ zs)\n  strict_prefix ?xs ?ys = (prefix ?xs ?ys \\<and> ?xs \\<noteq> ?ys)\n\ngoal (1 subgoal):\n 1. strict_prefix s t = (\\<exists>xs. s @ xs = t \\<and> 0 < length xs)", "by auto"], ["", "lemma butlast_strict_prefix_eq_butlast:\n  assumes \"length s = length t\" and \"strict_prefix (butlast s) t\"\n  shows \"strict_prefix (butlast s) t \\<longleftrightarrow> (butlast s) = (butlast t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_prefix (butlast s) t = (butlast s = butlast t)", "by (metis append_butlast_last_id append_eq_append_conv assms(1) assms(2) length_0_conv length_butlast strict_prefix_eq_exists)"], ["", "lemma butlast_eq_if_eq_length_and_prefix:\n  assumes \"length s > 0\" \"length z > 0\"\n          \"length s = length z\" \"strict_prefix (butlast s) t\" \"strict_prefix (butlast z) t\"\n  shows   \"(butlast s) = (butlast z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast s = butlast z", "using assms"], ["proof (prove)\nusing this:\n  0 < length s\n  0 < length z\n  length s = length z\n  strict_prefix (butlast s) t\n  strict_prefix (butlast z) t\n\ngoal (1 subgoal):\n 1. butlast s = butlast z", "by (auto simp add:strict_prefix_eq_exists)"], ["", "lemma butlast_prefix_imp_length_not_gt:\n  assumes \"length s > 0\" \"strict_prefix (butlast s) t\"\n  shows \"\\<not> (length t < length s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length t < length s", "using assms prefix_length_less"], ["proof (prove)\nusing this:\n  0 < length s\n  strict_prefix (butlast s) t\n  strict_prefix ?xs ?ys \\<Longrightarrow> length ?xs < length ?ys\n\ngoal (1 subgoal):\n 1. \\<not> length t < length s", "by fastforce"], ["", "lemma length_not_gt_iff_eq_length:\n  assumes \"length s > 0\" and \"strict_prefix (butlast s) t\"\n  shows \"(\\<not> (length s < length t)) = (length s = length t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> length s < length t) = (length s = length t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<not> length s < length t) = (length s = length t)", "have \"(\\<not> (length s < length t)) = ((length t < length s) \\<or> (length s = length t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> length s < length t) =\n    (length t < length s \\<or> length s = length t)", "by (metis not_less_iff_gr_or_eq)"], ["proof (state)\nthis:\n  (\\<not> length s < length t) =\n  (length t < length s \\<or> length s = length t)\n\ngoal (1 subgoal):\n 1. (\\<not> length s < length t) = (length s = length t)", "also"], ["proof (state)\nthis:\n  (\\<not> length s < length t) =\n  (length t < length s \\<or> length s = length t)\n\ngoal (1 subgoal):\n 1. (\\<not> length s < length t) = (length s = length t)", "have \"... = (length s = length t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length t < length s \\<or> length s = length t) = (length s = length t)", "using assms"], ["proof (prove)\nusing this:\n  0 < length s\n  strict_prefix (butlast s) t\n\ngoal (1 subgoal):\n 1. (length t < length s \\<or> length s = length t) = (length s = length t)", "by (simp add:butlast_prefix_imp_length_not_gt)"], ["proof (state)\nthis:\n  (length t < length s \\<or> length s = length t) = (length s = length t)\n\ngoal (1 subgoal):\n 1. (\\<not> length s < length t) = (length s = length t)", "finally"], ["proof (chain)\npicking this:\n  (\\<not> length s < length t) = (length s = length t)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<not> length s < length t) = (length s = length t)\n\ngoal (1 subgoal):\n 1. (\\<not> length s < length t) = (length s = length t)", "."], ["proof (state)\nthis:\n  (\\<not> length s < length t) = (length s = length t)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Greatest common prefix \\<close>"], ["", "fun gcp :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n\"gcp [] ys = []\" |\n\"gcp (x # xs) (y # ys) = (if (x = y) then x # gcp xs ys else [])\" |\n\"gcp _ _ = []\""], ["", "lemma gcp_right [simp]: \"gcp xs [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcp xs [] = []", "by (induct xs, auto)"], ["", "lemma gcp_append [simp]: \"gcp (xs @ ys) (xs @ zs) = xs @ gcp ys zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcp (xs @ ys) (xs @ zs) = xs @ gcp ys zs", "by (induct xs, auto)"], ["", "lemma gcp_lb1: \"prefix (gcp xs ys) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (gcp xs ys) xs", "apply (induct xs arbitrary: ys, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys. prefix (gcp xs ys) xs) \\<Longrightarrow>\n       prefix (gcp (a # xs) ys) (a # xs)", "apply (case_tac ys, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gcp_lb2: \"prefix (gcp xs ys) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (gcp xs ys) ys", "apply (induct ys arbitrary: xs, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ys xs.\n       (\\<And>xs. prefix (gcp xs ys) ys) \\<Longrightarrow>\n       prefix (gcp xs (a # ys)) (a # ys)", "apply (case_tac xs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation prefix_semilattice: semilattice_inf gcp prefix strict_prefix"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semilattice_inf gcp prefix strict_prefix", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. prefix (gcp x y) x\n 2. \\<And>x y. prefix (gcp x y) y\n 3. \\<And>x y z.\n       \\<lbrakk>prefix x y; prefix x z\\<rbrakk>\n       \\<Longrightarrow> prefix x (gcp y z)", "fix xs ys :: \"'a list\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. prefix (gcp x y) x\n 2. \\<And>x y. prefix (gcp x y) y\n 3. \\<And>x y z.\n       \\<lbrakk>prefix x y; prefix x z\\<rbrakk>\n       \\<Longrightarrow> prefix x (gcp y z)", "show \"prefix (gcp xs ys) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (gcp xs ys) xs", "by (induct xs arbitrary: ys, auto, case_tac ys, auto)"], ["proof (state)\nthis:\n  prefix (gcp xs ys) xs\n\ngoal (2 subgoals):\n 1. \\<And>x y. prefix (gcp x y) y\n 2. \\<And>x y z.\n       \\<lbrakk>prefix x y; prefix x z\\<rbrakk>\n       \\<Longrightarrow> prefix x (gcp y z)", "show \"prefix (gcp xs ys) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (gcp xs ys) ys", "by (induct ys arbitrary: xs, auto, case_tac xs, auto)"], ["proof (state)\nthis:\n  prefix (gcp xs ys) ys\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>prefix x y; prefix x z\\<rbrakk>\n       \\<Longrightarrow> prefix x (gcp y z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>prefix x y; prefix x z\\<rbrakk>\n       \\<Longrightarrow> prefix x (gcp y z)", "fix xs ys zs :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>prefix x y; prefix x z\\<rbrakk>\n       \\<Longrightarrow> prefix x (gcp y z)", "assume \"prefix xs ys\" \"prefix xs zs\""], ["proof (state)\nthis:\n  prefix xs ys\n  prefix xs zs\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>prefix x y; prefix x z\\<rbrakk>\n       \\<Longrightarrow> prefix x (gcp y z)", "thus \"prefix xs (gcp ys zs)\""], ["proof (prove)\nusing this:\n  prefix xs ys\n  prefix xs zs\n\ngoal (1 subgoal):\n 1. prefix xs (gcp ys zs)", "by (simp add: prefix_def, auto)"], ["proof (state)\nthis:\n  prefix xs (gcp ys zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open> Lexicographic Order \\<close>"], ["", "lemma lexord_append:\n  assumes \"(xs\\<^sub>1 @ ys\\<^sub>1, xs\\<^sub>2 @ ys\\<^sub>2) \\<in> lexord R\" \"length(xs\\<^sub>1) = length(xs\\<^sub>2)\"\n  shows \"(xs\\<^sub>1, xs\\<^sub>2) \\<in> lexord R \\<or> (xs\\<^sub>1 = xs\\<^sub>2 \\<and> (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs\\<^sub>1, xs\\<^sub>2) \\<in> lexord R \\<or>\n    xs\\<^sub>1 = xs\\<^sub>2 \\<and> (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "using assms"], ["proof (prove)\nusing this:\n  (xs\\<^sub>1 @ ys\\<^sub>1, xs\\<^sub>2 @ ys\\<^sub>2) \\<in> lexord R\n  length xs\\<^sub>1 = length xs\\<^sub>2\n\ngoal (1 subgoal):\n 1. (xs\\<^sub>1, xs\\<^sub>2) \\<in> lexord R \\<or>\n    xs\\<^sub>1 = xs\\<^sub>2 \\<and> (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "proof (induct xs\\<^sub>2 arbitrary: xs\\<^sub>1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs\\<^sub>1.\n       \\<lbrakk>(xs\\<^sub>1 @ ys\\<^sub>1, [] @ ys\\<^sub>2) \\<in> lexord R;\n        length xs\\<^sub>1 = length []\\<rbrakk>\n       \\<Longrightarrow> (xs\\<^sub>1, []) \\<in> lexord R \\<or>\n                         xs\\<^sub>1 = [] \\<and>\n                         (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n 2. \\<And>a xs\\<^sub>2 xs\\<^sub>1.\n       \\<lbrakk>\\<And>xs\\<^sub>1.\n                   \\<lbrakk>(xs\\<^sub>1 @ ys\\<^sub>1,\n                             xs\\<^sub>2 @ ys\\<^sub>2)\n                            \\<in> lexord R;\n                    length xs\\<^sub>1 = length xs\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> (xs\\<^sub>1, xs\\<^sub>2)\n                                     \\<in> lexord R \\<or>\n                                     xs\\<^sub>1 = xs\\<^sub>2 \\<and>\n                                     (ys\\<^sub>1, ys\\<^sub>2)\n                                     \\<in> lexord R;\n        (xs\\<^sub>1 @ ys\\<^sub>1, (a # xs\\<^sub>2) @ ys\\<^sub>2)\n        \\<in> lexord R;\n        length xs\\<^sub>1 = length (a # xs\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> (xs\\<^sub>1, a # xs\\<^sub>2) \\<in> lexord R \\<or>\n                         xs\\<^sub>1 = a # xs\\<^sub>2 \\<and>\n                         (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "case (Cons x\\<^sub>2 xs\\<^sub>2')"], ["proof (state)\nthis:\n  \\<lbrakk>(?xs\\<^sub>1 @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2)\n           \\<in> lexord R;\n   length ?xs\\<^sub>1 = length xs\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> (?xs\\<^sub>1, xs\\<^sub>2') \\<in> lexord R \\<or>\n                    ?xs\\<^sub>1 = xs\\<^sub>2' \\<and>\n                    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n  (xs\\<^sub>1 @ ys\\<^sub>1, (x\\<^sub>2 # xs\\<^sub>2') @ ys\\<^sub>2)\n  \\<in> lexord R\n  length xs\\<^sub>1 = length (x\\<^sub>2 # xs\\<^sub>2')\n\ngoal (2 subgoals):\n 1. \\<And>xs\\<^sub>1.\n       \\<lbrakk>(xs\\<^sub>1 @ ys\\<^sub>1, [] @ ys\\<^sub>2) \\<in> lexord R;\n        length xs\\<^sub>1 = length []\\<rbrakk>\n       \\<Longrightarrow> (xs\\<^sub>1, []) \\<in> lexord R \\<or>\n                         xs\\<^sub>1 = [] \\<and>\n                         (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n 2. \\<And>a xs\\<^sub>2 xs\\<^sub>1.\n       \\<lbrakk>\\<And>xs\\<^sub>1.\n                   \\<lbrakk>(xs\\<^sub>1 @ ys\\<^sub>1,\n                             xs\\<^sub>2 @ ys\\<^sub>2)\n                            \\<in> lexord R;\n                    length xs\\<^sub>1 = length xs\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> (xs\\<^sub>1, xs\\<^sub>2)\n                                     \\<in> lexord R \\<or>\n                                     xs\\<^sub>1 = xs\\<^sub>2 \\<and>\n                                     (ys\\<^sub>1, ys\\<^sub>2)\n                                     \\<in> lexord R;\n        (xs\\<^sub>1 @ ys\\<^sub>1, (a # xs\\<^sub>2) @ ys\\<^sub>2)\n        \\<in> lexord R;\n        length xs\\<^sub>1 = length (a # xs\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> (xs\\<^sub>1, a # xs\\<^sub>2) \\<in> lexord R \\<or>\n                         xs\\<^sub>1 = a # xs\\<^sub>2 \\<and>\n                         (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "note hyps = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?xs\\<^sub>1 @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2)\n           \\<in> lexord R;\n   length ?xs\\<^sub>1 = length xs\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> (?xs\\<^sub>1, xs\\<^sub>2') \\<in> lexord R \\<or>\n                    ?xs\\<^sub>1 = xs\\<^sub>2' \\<and>\n                    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n  (xs\\<^sub>1 @ ys\\<^sub>1, (x\\<^sub>2 # xs\\<^sub>2') @ ys\\<^sub>2)\n  \\<in> lexord R\n  length xs\\<^sub>1 = length (x\\<^sub>2 # xs\\<^sub>2')\n\ngoal (2 subgoals):\n 1. \\<And>xs\\<^sub>1.\n       \\<lbrakk>(xs\\<^sub>1 @ ys\\<^sub>1, [] @ ys\\<^sub>2) \\<in> lexord R;\n        length xs\\<^sub>1 = length []\\<rbrakk>\n       \\<Longrightarrow> (xs\\<^sub>1, []) \\<in> lexord R \\<or>\n                         xs\\<^sub>1 = [] \\<and>\n                         (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n 2. \\<And>a xs\\<^sub>2 xs\\<^sub>1.\n       \\<lbrakk>\\<And>xs\\<^sub>1.\n                   \\<lbrakk>(xs\\<^sub>1 @ ys\\<^sub>1,\n                             xs\\<^sub>2 @ ys\\<^sub>2)\n                            \\<in> lexord R;\n                    length xs\\<^sub>1 = length xs\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> (xs\\<^sub>1, xs\\<^sub>2)\n                                     \\<in> lexord R \\<or>\n                                     xs\\<^sub>1 = xs\\<^sub>2 \\<and>\n                                     (ys\\<^sub>1, ys\\<^sub>2)\n                                     \\<in> lexord R;\n        (xs\\<^sub>1 @ ys\\<^sub>1, (a # xs\\<^sub>2) @ ys\\<^sub>2)\n        \\<in> lexord R;\n        length xs\\<^sub>1 = length (a # xs\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> (xs\\<^sub>1, a # xs\\<^sub>2) \\<in> lexord R \\<or>\n                         xs\\<^sub>1 = a # xs\\<^sub>2 \\<and>\n                         (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "from hyps(3)"], ["proof (chain)\npicking this:\n  length xs\\<^sub>1 = length (x\\<^sub>2 # xs\\<^sub>2')", "obtain x\\<^sub>1 xs\\<^sub>1' where xs\\<^sub>1: \"xs\\<^sub>1 = x\\<^sub>1 # xs\\<^sub>1'\" \"length(xs\\<^sub>1') = length(xs\\<^sub>2')\""], ["proof (prove)\nusing this:\n  length xs\\<^sub>1 = length (x\\<^sub>2 # xs\\<^sub>2')\n\ngoal (1 subgoal):\n 1. (\\<And>x\\<^sub>1 xs\\<^sub>1''.\n        \\<lbrakk>xs\\<^sub>1 = x\\<^sub>1 # xs\\<^sub>1'';\n         length xs\\<^sub>1'' = length xs\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto, metis Suc_length_conv)"], ["proof (state)\nthis:\n  xs\\<^sub>1 = x\\<^sub>1 # xs\\<^sub>1'\n  length xs\\<^sub>1' = length xs\\<^sub>2'\n\ngoal (2 subgoals):\n 1. \\<And>xs\\<^sub>1.\n       \\<lbrakk>(xs\\<^sub>1 @ ys\\<^sub>1, [] @ ys\\<^sub>2) \\<in> lexord R;\n        length xs\\<^sub>1 = length []\\<rbrakk>\n       \\<Longrightarrow> (xs\\<^sub>1, []) \\<in> lexord R \\<or>\n                         xs\\<^sub>1 = [] \\<and>\n                         (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n 2. \\<And>a xs\\<^sub>2 xs\\<^sub>1.\n       \\<lbrakk>\\<And>xs\\<^sub>1.\n                   \\<lbrakk>(xs\\<^sub>1 @ ys\\<^sub>1,\n                             xs\\<^sub>2 @ ys\\<^sub>2)\n                            \\<in> lexord R;\n                    length xs\\<^sub>1 = length xs\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> (xs\\<^sub>1, xs\\<^sub>2)\n                                     \\<in> lexord R \\<or>\n                                     xs\\<^sub>1 = xs\\<^sub>2 \\<and>\n                                     (ys\\<^sub>1, ys\\<^sub>2)\n                                     \\<in> lexord R;\n        (xs\\<^sub>1 @ ys\\<^sub>1, (a # xs\\<^sub>2) @ ys\\<^sub>2)\n        \\<in> lexord R;\n        length xs\\<^sub>1 = length (a # xs\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> (xs\\<^sub>1, a # xs\\<^sub>2) \\<in> lexord R \\<or>\n                         xs\\<^sub>1 = a # xs\\<^sub>2 \\<and>\n                         (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "with hyps(2)"], ["proof (chain)\npicking this:\n  (xs\\<^sub>1 @ ys\\<^sub>1, (x\\<^sub>2 # xs\\<^sub>2') @ ys\\<^sub>2)\n  \\<in> lexord R\n  xs\\<^sub>1 = x\\<^sub>1 # xs\\<^sub>1'\n  length xs\\<^sub>1' = length xs\\<^sub>2'", "have xcases: \"(x\\<^sub>1, x\\<^sub>2) \\<in> R \\<or> (xs\\<^sub>1' @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2) \\<in> lexord R\""], ["proof (prove)\nusing this:\n  (xs\\<^sub>1 @ ys\\<^sub>1, (x\\<^sub>2 # xs\\<^sub>2') @ ys\\<^sub>2)\n  \\<in> lexord R\n  xs\\<^sub>1 = x\\<^sub>1 # xs\\<^sub>1'\n  length xs\\<^sub>1' = length xs\\<^sub>2'\n\ngoal (1 subgoal):\n 1. (x\\<^sub>1, x\\<^sub>2) \\<in> R \\<or>\n    (xs\\<^sub>1' @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2) \\<in> lexord R", "by (auto)"], ["proof (state)\nthis:\n  (x\\<^sub>1, x\\<^sub>2) \\<in> R \\<or>\n  (xs\\<^sub>1' @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2) \\<in> lexord R\n\ngoal (2 subgoals):\n 1. \\<And>xs\\<^sub>1.\n       \\<lbrakk>(xs\\<^sub>1 @ ys\\<^sub>1, [] @ ys\\<^sub>2) \\<in> lexord R;\n        length xs\\<^sub>1 = length []\\<rbrakk>\n       \\<Longrightarrow> (xs\\<^sub>1, []) \\<in> lexord R \\<or>\n                         xs\\<^sub>1 = [] \\<and>\n                         (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n 2. \\<And>a xs\\<^sub>2 xs\\<^sub>1.\n       \\<lbrakk>\\<And>xs\\<^sub>1.\n                   \\<lbrakk>(xs\\<^sub>1 @ ys\\<^sub>1,\n                             xs\\<^sub>2 @ ys\\<^sub>2)\n                            \\<in> lexord R;\n                    length xs\\<^sub>1 = length xs\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> (xs\\<^sub>1, xs\\<^sub>2)\n                                     \\<in> lexord R \\<or>\n                                     xs\\<^sub>1 = xs\\<^sub>2 \\<and>\n                                     (ys\\<^sub>1, ys\\<^sub>2)\n                                     \\<in> lexord R;\n        (xs\\<^sub>1 @ ys\\<^sub>1, (a # xs\\<^sub>2) @ ys\\<^sub>2)\n        \\<in> lexord R;\n        length xs\\<^sub>1 = length (a # xs\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> (xs\\<^sub>1, a # xs\\<^sub>2) \\<in> lexord R \\<or>\n                         xs\\<^sub>1 = a # xs\\<^sub>2 \\<and>\n                         (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "proof (cases \"(x\\<^sub>1, x\\<^sub>2) \\<in> R\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (x\\<^sub>1, x\\<^sub>2) \\<in> R \\<Longrightarrow>\n    (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n 2. (x\\<^sub>1, x\\<^sub>2) \\<notin> R \\<Longrightarrow>\n    (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "case True"], ["proof (state)\nthis:\n  (x\\<^sub>1, x\\<^sub>2) \\<in> R\n\ngoal (2 subgoals):\n 1. (x\\<^sub>1, x\\<^sub>2) \\<in> R \\<Longrightarrow>\n    (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n 2. (x\\<^sub>1, x\\<^sub>2) \\<notin> R \\<Longrightarrow>\n    (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "with xs\\<^sub>1"], ["proof (chain)\npicking this:\n  xs\\<^sub>1 = x\\<^sub>1 # xs\\<^sub>1'\n  length xs\\<^sub>1' = length xs\\<^sub>2'\n  (x\\<^sub>1, x\\<^sub>2) \\<in> R", "show ?thesis"], ["proof (prove)\nusing this:\n  xs\\<^sub>1 = x\\<^sub>1 # xs\\<^sub>1'\n  length xs\\<^sub>1' = length xs\\<^sub>2'\n  (x\\<^sub>1, x\\<^sub>2) \\<in> R\n\ngoal (1 subgoal):\n 1. (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "by (auto)"], ["proof (state)\nthis:\n  (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n  xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n  (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n\ngoal (1 subgoal):\n 1. (x\\<^sub>1, x\\<^sub>2) \\<notin> R \\<Longrightarrow>\n    (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (x\\<^sub>1, x\\<^sub>2) \\<notin> R \\<Longrightarrow>\n    (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "case False"], ["proof (state)\nthis:\n  (x\\<^sub>1, x\\<^sub>2) \\<notin> R\n\ngoal (1 subgoal):\n 1. (x\\<^sub>1, x\\<^sub>2) \\<notin> R \\<Longrightarrow>\n    (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "with xcases"], ["proof (chain)\npicking this:\n  (x\\<^sub>1, x\\<^sub>2) \\<in> R \\<or>\n  (xs\\<^sub>1' @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2) \\<in> lexord R\n  (x\\<^sub>1, x\\<^sub>2) \\<notin> R", "have \"(xs\\<^sub>1' @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2) \\<in> lexord R\""], ["proof (prove)\nusing this:\n  (x\\<^sub>1, x\\<^sub>2) \\<in> R \\<or>\n  (xs\\<^sub>1' @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2) \\<in> lexord R\n  (x\\<^sub>1, x\\<^sub>2) \\<notin> R\n\ngoal (1 subgoal):\n 1. (xs\\<^sub>1' @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2) \\<in> lexord R", "by (auto)"], ["proof (state)\nthis:\n  (xs\\<^sub>1' @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2) \\<in> lexord R\n\ngoal (1 subgoal):\n 1. (x\\<^sub>1, x\\<^sub>2) \\<notin> R \\<Longrightarrow>\n    (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "with hyps(1) xs\\<^sub>1"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?xs\\<^sub>1 @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2)\n           \\<in> lexord R;\n   length ?xs\\<^sub>1 = length xs\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> (?xs\\<^sub>1, xs\\<^sub>2') \\<in> lexord R \\<or>\n                    ?xs\\<^sub>1 = xs\\<^sub>2' \\<and>\n                    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n  xs\\<^sub>1 = x\\<^sub>1 # xs\\<^sub>1'\n  length xs\\<^sub>1' = length xs\\<^sub>2'\n  (xs\\<^sub>1' @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2) \\<in> lexord R", "have dichot: \"(xs\\<^sub>1', xs\\<^sub>2') \\<in> lexord R \\<or> (xs\\<^sub>1' = xs\\<^sub>2' \\<and> (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xs\\<^sub>1 @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2)\n           \\<in> lexord R;\n   length ?xs\\<^sub>1 = length xs\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> (?xs\\<^sub>1, xs\\<^sub>2') \\<in> lexord R \\<or>\n                    ?xs\\<^sub>1 = xs\\<^sub>2' \\<and>\n                    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n  xs\\<^sub>1 = x\\<^sub>1 # xs\\<^sub>1'\n  length xs\\<^sub>1' = length xs\\<^sub>2'\n  (xs\\<^sub>1' @ ys\\<^sub>1, xs\\<^sub>2' @ ys\\<^sub>2) \\<in> lexord R\n\ngoal (1 subgoal):\n 1. (xs\\<^sub>1', xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1' = xs\\<^sub>2' \\<and> (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "by (auto)"], ["proof (state)\nthis:\n  (xs\\<^sub>1', xs\\<^sub>2') \\<in> lexord R \\<or>\n  xs\\<^sub>1' = xs\\<^sub>2' \\<and> (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n\ngoal (1 subgoal):\n 1. (x\\<^sub>1, x\\<^sub>2) \\<notin> R \\<Longrightarrow>\n    (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "have \"x\\<^sub>1 = x\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sub>1 = x\\<^sub>2", "using False hyps(2) xs\\<^sub>1(1)"], ["proof (prove)\nusing this:\n  (x\\<^sub>1, x\\<^sub>2) \\<notin> R\n  (xs\\<^sub>1 @ ys\\<^sub>1, (x\\<^sub>2 # xs\\<^sub>2') @ ys\\<^sub>2)\n  \\<in> lexord R\n  xs\\<^sub>1 = x\\<^sub>1 # xs\\<^sub>1'\n\ngoal (1 subgoal):\n 1. x\\<^sub>1 = x\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  x\\<^sub>1 = x\\<^sub>2\n\ngoal (1 subgoal):\n 1. (x\\<^sub>1, x\\<^sub>2) \\<notin> R \\<Longrightarrow>\n    (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "with dichot xs\\<^sub>1"], ["proof (chain)\npicking this:\n  (xs\\<^sub>1', xs\\<^sub>2') \\<in> lexord R \\<or>\n  xs\\<^sub>1' = xs\\<^sub>2' \\<and> (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n  xs\\<^sub>1 = x\\<^sub>1 # xs\\<^sub>1'\n  length xs\\<^sub>1' = length xs\\<^sub>2'\n  x\\<^sub>1 = x\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  (xs\\<^sub>1', xs\\<^sub>2') \\<in> lexord R \\<or>\n  xs\\<^sub>1' = xs\\<^sub>2' \\<and> (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n  xs\\<^sub>1 = x\\<^sub>1 # xs\\<^sub>1'\n  length xs\\<^sub>1' = length xs\\<^sub>2'\n  x\\<^sub>1 = x\\<^sub>2\n\ngoal (1 subgoal):\n 1. (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n    xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n    (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "by (simp)"], ["proof (state)\nthis:\n  (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n  xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n  (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs\\<^sub>1, x\\<^sub>2 # xs\\<^sub>2') \\<in> lexord R \\<or>\n  xs\\<^sub>1 = x\\<^sub>2 # xs\\<^sub>2' \\<and>\n  (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n\ngoal (1 subgoal):\n 1. \\<And>xs\\<^sub>1.\n       \\<lbrakk>(xs\\<^sub>1 @ ys\\<^sub>1, [] @ ys\\<^sub>2) \\<in> lexord R;\n        length xs\\<^sub>1 = length []\\<rbrakk>\n       \\<Longrightarrow> (xs\\<^sub>1, []) \\<in> lexord R \\<or>\n                         xs\\<^sub>1 = [] \\<and>\n                         (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs\\<^sub>1.\n       \\<lbrakk>(xs\\<^sub>1 @ ys\\<^sub>1, [] @ ys\\<^sub>2) \\<in> lexord R;\n        length xs\\<^sub>1 = length []\\<rbrakk>\n       \\<Longrightarrow> (xs\\<^sub>1, []) \\<in> lexord R \\<or>\n                         xs\\<^sub>1 = [] \\<and>\n                         (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "case Nil"], ["proof (state)\nthis:\n  (xs\\<^sub>1 @ ys\\<^sub>1, [] @ ys\\<^sub>2) \\<in> lexord R\n  length xs\\<^sub>1 = length []\n\ngoal (1 subgoal):\n 1. \\<And>xs\\<^sub>1.\n       \\<lbrakk>(xs\\<^sub>1 @ ys\\<^sub>1, [] @ ys\\<^sub>2) \\<in> lexord R;\n        length xs\\<^sub>1 = length []\\<rbrakk>\n       \\<Longrightarrow> (xs\\<^sub>1, []) \\<in> lexord R \\<or>\n                         xs\\<^sub>1 = [] \\<and>\n                         (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "thus ?case"], ["proof (prove)\nusing this:\n  (xs\\<^sub>1 @ ys\\<^sub>1, [] @ ys\\<^sub>2) \\<in> lexord R\n  length xs\\<^sub>1 = length []\n\ngoal (1 subgoal):\n 1. (xs\\<^sub>1, []) \\<in> lexord R \\<or>\n    xs\\<^sub>1 = [] \\<and> (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R", "by auto"], ["proof (state)\nthis:\n  (xs\\<^sub>1, []) \\<in> lexord R \\<or>\n  xs\\<^sub>1 = [] \\<and> (ys\\<^sub>1, ys\\<^sub>2) \\<in> lexord R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strict_prefix_lexord_rel:\n  \"strict_prefix xs ys \\<Longrightarrow> (xs, ys) \\<in> lexord R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_prefix xs ys \\<Longrightarrow> (xs, ys) \\<in> lexord R", "by (metis Sublist.strict_prefixE' lexord_append_rightI)"], ["", "lemma strict_prefix_lexord_left:\n  assumes \"trans R\" \"(xs, ys) \\<in> lexord R\" \"strict_prefix xs' xs\"\n  shows \"(xs', ys) \\<in> lexord R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs', ys) \\<in> lexord R", "by (metis assms lexord_trans strict_prefix_lexord_rel)"], ["", "lemma prefix_lexord_right:\n  assumes \"trans R\" \"(xs, ys) \\<in> lexord R\" \"strict_prefix ys ys'\"\n  shows \"(xs, ys') \\<in> lexord R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, ys') \\<in> lexord R", "by (metis assms lexord_trans strict_prefix_lexord_rel)"], ["", "lemma lexord_eq_length:\n  assumes \"(xs, ys) \\<in> lexord R\" \"length xs = length ys\"\n  shows \"\\<exists> i. (xs!i, ys!i) \\<in> R \\<and> i < length xs \\<and> (\\<forall> j<i. xs!j = ys!j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       (xs ! i, ys ! i) \\<in> R \\<and>\n       i < length xs \\<and> (\\<forall>j<i. xs ! j = ys ! j)", "using assms"], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> lexord R\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       (xs ! i, ys ! i) \\<in> R \\<and>\n       i < length xs \\<and> (\\<forall>j<i. xs ! j = ys ! j)", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>([], ys) \\<in> lexord R; length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            ([] ! i, ys ! i) \\<in> R \\<and>\n                            i < length [] \\<and>\n                            (\\<forall>j<i. [] ! j = ys ! j)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>(xs, ys) \\<in> lexord R;\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i.\n  (xs ! i, ys ! i) \\<in> R \\<and>\n  i < length xs \\<and> (\\<forall>j<i. xs ! j = ys ! j);\n        (a # xs, ys) \\<in> lexord R; length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            ((a # xs) ! i, ys ! i) \\<in> R \\<and>\n                            i < length (a # xs) \\<and>\n                            (\\<forall>j<i. (a # xs) ! j = ys ! j)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>(xs, ?ys) \\<in> lexord R; length xs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       (xs ! i, ?ys ! i) \\<in> R \\<and>\n                       i < length xs \\<and> (\\<forall>j<i. xs ! j = ?ys ! j)\n  (x # xs, ys) \\<in> lexord R\n  length (x # xs) = length ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>([], ys) \\<in> lexord R; length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            ([] ! i, ys ! i) \\<in> R \\<and>\n                            i < length [] \\<and>\n                            (\\<forall>j<i. [] ! j = ys ! j)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>(xs, ys) \\<in> lexord R;\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i.\n  (xs ! i, ys ! i) \\<in> R \\<and>\n  i < length xs \\<and> (\\<forall>j<i. xs ! j = ys ! j);\n        (a # xs, ys) \\<in> lexord R; length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            ((a # xs) ! i, ys ! i) \\<in> R \\<and>\n                            i < length (a # xs) \\<and>\n                            (\\<forall>j<i. (a # xs) ! j = ys ! j)", "note hyps = this"], ["proof (state)\nthis:\n  \\<lbrakk>(xs, ?ys) \\<in> lexord R; length xs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       (xs ! i, ?ys ! i) \\<in> R \\<and>\n                       i < length xs \\<and> (\\<forall>j<i. xs ! j = ?ys ! j)\n  (x # xs, ys) \\<in> lexord R\n  length (x # xs) = length ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>([], ys) \\<in> lexord R; length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            ([] ! i, ys ! i) \\<in> R \\<and>\n                            i < length [] \\<and>\n                            (\\<forall>j<i. [] ! j = ys ! j)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>(xs, ys) \\<in> lexord R;\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i.\n  (xs ! i, ys ! i) \\<in> R \\<and>\n  i < length xs \\<and> (\\<forall>j<i. xs ! j = ys ! j);\n        (a # xs, ys) \\<in> lexord R; length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            ((a # xs) ! i, ys ! i) \\<in> R \\<and>\n                            i < length (a # xs) \\<and>\n                            (\\<forall>j<i. (a # xs) ! j = ys ! j)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(xs, ?ys) \\<in> lexord R; length xs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       (xs ! i, ?ys ! i) \\<in> R \\<and>\n                       i < length xs \\<and> (\\<forall>j<i. xs ! j = ?ys ! j)\n  (x # xs, ys) \\<in> lexord R\n  length (x # xs) = length ys", "obtain y ys' where ys: \"ys = y # ys'\" \"length ys' = length xs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(xs, ?ys) \\<in> lexord R; length xs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       (xs ! i, ?ys ! i) \\<in> R \\<and>\n                       i < length xs \\<and> (\\<forall>j<i. xs ! j = ?ys ! j)\n  (x # xs, ys) \\<in> lexord R\n  length (x # xs) = length ys\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'.\n        \\<lbrakk>ys = y # ys'; length ys' = length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_length_conv)"], ["proof (state)\nthis:\n  ys = y # ys'\n  length ys' = length xs\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>([], ys) \\<in> lexord R; length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            ([] ! i, ys ! i) \\<in> R \\<and>\n                            i < length [] \\<and>\n                            (\\<forall>j<i. [] ! j = ys ! j)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>(xs, ys) \\<in> lexord R;\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i.\n  (xs ! i, ys ! i) \\<in> R \\<and>\n  i < length xs \\<and> (\\<forall>j<i. xs ! j = ys ! j);\n        (a # xs, ys) \\<in> lexord R; length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            ((a # xs) ! i, ys ! i) \\<in> R \\<and>\n                            i < length (a # xs) \\<and>\n                            (\\<forall>j<i. (a # xs) ! j = ys ! j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n       i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)", "proof (cases \"(x, y) \\<in> R\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, y) \\<in> R \\<Longrightarrow>\n    \\<exists>i.\n       ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n       i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)\n 2. (x, y) \\<notin> R \\<Longrightarrow>\n    \\<exists>i.\n       ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n       i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)", "case True"], ["proof (state)\nthis:\n  (x, y) \\<in> R\n\ngoal (2 subgoals):\n 1. (x, y) \\<in> R \\<Longrightarrow>\n    \\<exists>i.\n       ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n       i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)\n 2. (x, y) \\<notin> R \\<Longrightarrow>\n    \\<exists>i.\n       ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n       i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)", "with ys"], ["proof (chain)\npicking this:\n  ys = y # ys'\n  length ys' = length xs\n  (x, y) \\<in> R", "show ?thesis"], ["proof (prove)\nusing this:\n  ys = y # ys'\n  length ys' = length xs\n  (x, y) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n       i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)", "by (rule_tac x=\"0\" in exI, simp)"], ["proof (state)\nthis:\n  \\<exists>i.\n     ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n     i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> R \\<Longrightarrow>\n    \\<exists>i.\n       ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n       i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<notin> R \\<Longrightarrow>\n    \\<exists>i.\n       ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n       i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)", "case False"], ["proof (state)\nthis:\n  (x, y) \\<notin> R\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> R \\<Longrightarrow>\n    \\<exists>i.\n       ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n       i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)", "with ys hyps(2)"], ["proof (chain)\npicking this:\n  ys = y # ys'\n  length ys' = length xs\n  (x # xs, ys) \\<in> lexord R\n  (x, y) \\<notin> R", "have xy: \"x = y\" \"(xs, ys') \\<in> lexord R\""], ["proof (prove)\nusing this:\n  ys = y # ys'\n  length ys' = length xs\n  (x # xs, ys) \\<in> lexord R\n  (x, y) \\<notin> R\n\ngoal (1 subgoal):\n 1. x = y &&& (xs, ys') \\<in> lexord R", "by auto"], ["proof (state)\nthis:\n  x = y\n  (xs, ys') \\<in> lexord R\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> R \\<Longrightarrow>\n    \\<exists>i.\n       ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n       i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)", "with hyps(1,3) ys"], ["proof (chain)\npicking this:\n  \\<lbrakk>(xs, ?ys) \\<in> lexord R; length xs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       (xs ! i, ?ys ! i) \\<in> R \\<and>\n                       i < length xs \\<and> (\\<forall>j<i. xs ! j = ?ys ! j)\n  length (x # xs) = length ys\n  ys = y # ys'\n  length ys' = length xs\n  x = y\n  (xs, ys') \\<in> lexord R", "obtain i where \"(xs!i, ys'!i) \\<in> R\" \"i < length xs\" \"(\\<forall> j<i. xs!j = ys'!j)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(xs, ?ys) \\<in> lexord R; length xs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       (xs ! i, ?ys ! i) \\<in> R \\<and>\n                       i < length xs \\<and> (\\<forall>j<i. xs ! j = ?ys ! j)\n  length (x # xs) = length ys\n  ys = y # ys'\n  length ys' = length xs\n  x = y\n  (xs, ys') \\<in> lexord R\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>(xs ! i, ys' ! i) \\<in> R; i < length xs;\n         \\<forall>j<i. xs ! j = ys' ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (xs ! i, ys' ! i) \\<in> R\n  i < length xs\n  \\<forall>j<i. xs ! j = ys' ! j\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> R \\<Longrightarrow>\n    \\<exists>i.\n       ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n       i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)", "with xy ys"], ["proof (chain)\npicking this:\n  x = y\n  (xs, ys') \\<in> lexord R\n  ys = y # ys'\n  length ys' = length xs\n  (xs ! i, ys' ! i) \\<in> R\n  i < length xs\n  \\<forall>j<i. xs ! j = ys' ! j", "show ?thesis"], ["proof (prove)\nusing this:\n  x = y\n  (xs, ys') \\<in> lexord R\n  ys = y # ys'\n  length ys' = length xs\n  (xs ! i, ys' ! i) \\<in> R\n  i < length xs\n  \\<forall>j<i. xs ! j = ys' ! j\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n       i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)", "apply (rule_tac x=\"Suc i\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = y; (xs, ys') \\<in> lexord R; ys = y # ys';\n     length ys' = length xs; (xs ! i, ys' ! i) \\<in> R; i < length xs;\n     \\<forall>j<i. xs ! j = ys' ! j\\<rbrakk>\n    \\<Longrightarrow> ((x # xs) ! Suc i, ys ! Suc i) \\<in> R \\<and>\n                      Suc i < length (x # xs) \\<and>\n                      (\\<forall>j<Suc i. (x # xs) ! j = ys ! j)", "apply (auto simp add: less_Suc_eq_0_disj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>i.\n     ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n     i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i.\n     ((x # xs) ! i, ys ! i) \\<in> R \\<and>\n     i < length (x # xs) \\<and> (\\<forall>j<i. (x # xs) ! j = ys ! j)\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>([], ys) \\<in> lexord R; length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            ([] ! i, ys ! i) \\<in> R \\<and>\n                            i < length [] \\<and>\n                            (\\<forall>j<i. [] ! j = ys ! j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>([], ys) \\<in> lexord R; length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            ([] ! i, ys ! i) \\<in> R \\<and>\n                            i < length [] \\<and>\n                            (\\<forall>j<i. [] ! j = ys ! j)", "case Nil"], ["proof (state)\nthis:\n  ([], ys) \\<in> lexord R\n  length [] = length ys\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>([], ys) \\<in> lexord R; length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            ([] ! i, ys ! i) \\<in> R \\<and>\n                            i < length [] \\<and>\n                            (\\<forall>j<i. [] ! j = ys ! j)", "thus ?case"], ["proof (prove)\nusing this:\n  ([], ys) \\<in> lexord R\n  length [] = length ys\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       ([] ! i, ys ! i) \\<in> R \\<and>\n       i < length [] \\<and> (\\<forall>j<i. [] ! j = ys ! j)", "by (auto)"], ["proof (state)\nthis:\n  \\<exists>i.\n     ([] ! i, ys ! i) \\<in> R \\<and>\n     i < length [] \\<and> (\\<forall>j<i. [] ! j = ys ! j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lexord_intro_elems:\n  assumes \"length xs > i\" \"length ys > i\" \"(xs!i, ys!i) \\<in> R\" \"\\<forall> j<i. xs!j = ys!j\"\n  shows \"(xs, ys) \\<in> lexord R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> lexord R", "using assms"], ["proof (prove)\nusing this:\n  i < length xs\n  i < length ys\n  (xs ! i, ys ! i) \\<in> R\n  \\<forall>j<i. xs ! j = ys ! j\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> lexord R", "proof (induct i arbitrary: xs ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>0 < length xs; 0 < length ys; (xs ! 0, ys ! 0) \\<in> R;\n        \\<forall>j<0. xs ! j = ys ! j\\<rbrakk>\n       \\<Longrightarrow> (xs, ys) \\<in> lexord R\n 2. \\<And>i xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>i < length xs; i < length ys;\n                    (xs ! i, ys ! i) \\<in> R;\n                    \\<forall>j<i. xs ! j = ys ! j\\<rbrakk>\n                   \\<Longrightarrow> (xs, ys) \\<in> lexord R;\n        Suc i < length xs; Suc i < length ys;\n        (xs ! Suc i, ys ! Suc i) \\<in> R;\n        \\<forall>j<Suc i. xs ! j = ys ! j\\<rbrakk>\n       \\<Longrightarrow> (xs, ys) \\<in> lexord R", "case 0"], ["proof (state)\nthis:\n  0 < length xs\n  0 < length ys\n  (xs ! 0, ys ! 0) \\<in> R\n  \\<forall>j<0. xs ! j = ys ! j\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>0 < length xs; 0 < length ys; (xs ! 0, ys ! 0) \\<in> R;\n        \\<forall>j<0. xs ! j = ys ! j\\<rbrakk>\n       \\<Longrightarrow> (xs, ys) \\<in> lexord R\n 2. \\<And>i xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>i < length xs; i < length ys;\n                    (xs ! i, ys ! i) \\<in> R;\n                    \\<forall>j<i. xs ! j = ys ! j\\<rbrakk>\n                   \\<Longrightarrow> (xs, ys) \\<in> lexord R;\n        Suc i < length xs; Suc i < length ys;\n        (xs ! Suc i, ys ! Suc i) \\<in> R;\n        \\<forall>j<Suc i. xs ! j = ys ! j\\<rbrakk>\n       \\<Longrightarrow> (xs, ys) \\<in> lexord R", "thus ?case"], ["proof (prove)\nusing this:\n  0 < length xs\n  0 < length ys\n  (xs ! 0, ys ! 0) \\<in> R\n  \\<forall>j<0. xs ! j = ys ! j\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> lexord R", "by (auto, metis lexord_cons_cons list.exhaust nth_Cons_0)"], ["proof (state)\nthis:\n  (xs, ys) \\<in> lexord R\n\ngoal (1 subgoal):\n 1. \\<And>i xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>i < length xs; i < length ys;\n                    (xs ! i, ys ! i) \\<in> R;\n                    \\<forall>j<i. xs ! j = ys ! j\\<rbrakk>\n                   \\<Longrightarrow> (xs, ys) \\<in> lexord R;\n        Suc i < length xs; Suc i < length ys;\n        (xs ! Suc i, ys ! Suc i) \\<in> R;\n        \\<forall>j<Suc i. xs ! j = ys ! j\\<rbrakk>\n       \\<Longrightarrow> (xs, ys) \\<in> lexord R", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>i < length xs; i < length ys;\n                    (xs ! i, ys ! i) \\<in> R;\n                    \\<forall>j<i. xs ! j = ys ! j\\<rbrakk>\n                   \\<Longrightarrow> (xs, ys) \\<in> lexord R;\n        Suc i < length xs; Suc i < length ys;\n        (xs ! Suc i, ys ! Suc i) \\<in> R;\n        \\<forall>j<Suc i. xs ! j = ys ! j\\<rbrakk>\n       \\<Longrightarrow> (xs, ys) \\<in> lexord R", "case (Suc i)"], ["proof (state)\nthis:\n  \\<lbrakk>i < length ?xs; i < length ?ys; (?xs ! i, ?ys ! i) \\<in> R;\n   \\<forall>j<i. ?xs ! j = ?ys ! j\\<rbrakk>\n  \\<Longrightarrow> (?xs, ?ys) \\<in> lexord R\n  Suc i < length xs\n  Suc i < length ys\n  (xs ! Suc i, ys ! Suc i) \\<in> R\n  \\<forall>j<Suc i. xs ! j = ys ! j\n\ngoal (1 subgoal):\n 1. \\<And>i xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>i < length xs; i < length ys;\n                    (xs ! i, ys ! i) \\<in> R;\n                    \\<forall>j<i. xs ! j = ys ! j\\<rbrakk>\n                   \\<Longrightarrow> (xs, ys) \\<in> lexord R;\n        Suc i < length xs; Suc i < length ys;\n        (xs ! Suc i, ys ! Suc i) \\<in> R;\n        \\<forall>j<Suc i. xs ! j = ys ! j\\<rbrakk>\n       \\<Longrightarrow> (xs, ys) \\<in> lexord R", "note hyps = this"], ["proof (state)\nthis:\n  \\<lbrakk>i < length ?xs; i < length ?ys; (?xs ! i, ?ys ! i) \\<in> R;\n   \\<forall>j<i. ?xs ! j = ?ys ! j\\<rbrakk>\n  \\<Longrightarrow> (?xs, ?ys) \\<in> lexord R\n  Suc i < length xs\n  Suc i < length ys\n  (xs ! Suc i, ys ! Suc i) \\<in> R\n  \\<forall>j<Suc i. xs ! j = ys ! j\n\ngoal (1 subgoal):\n 1. \\<And>i xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>i < length xs; i < length ys;\n                    (xs ! i, ys ! i) \\<in> R;\n                    \\<forall>j<i. xs ! j = ys ! j\\<rbrakk>\n                   \\<Longrightarrow> (xs, ys) \\<in> lexord R;\n        Suc i < length xs; Suc i < length ys;\n        (xs ! Suc i, ys ! Suc i) \\<in> R;\n        \\<forall>j<Suc i. xs ! j = ys ! j\\<rbrakk>\n       \\<Longrightarrow> (xs, ys) \\<in> lexord R", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < length ?xs; i < length ?ys; (?xs ! i, ?ys ! i) \\<in> R;\n   \\<forall>j<i. ?xs ! j = ?ys ! j\\<rbrakk>\n  \\<Longrightarrow> (?xs, ?ys) \\<in> lexord R\n  Suc i < length xs\n  Suc i < length ys\n  (xs ! Suc i, ys ! Suc i) \\<in> R\n  \\<forall>j<Suc i. xs ! j = ys ! j", "obtain x' y' xs' ys' where \"xs = x' # xs'\" \"ys = y' # ys'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i < length ?xs; i < length ?ys; (?xs ! i, ?ys ! i) \\<in> R;\n   \\<forall>j<i. ?xs ! j = ?ys ! j\\<rbrakk>\n  \\<Longrightarrow> (?xs, ?ys) \\<in> lexord R\n  Suc i < length xs\n  Suc i < length ys\n  (xs ! Suc i, ys ! Suc i) \\<in> R\n  \\<forall>j<Suc i. xs ! j = ys ! j\n\ngoal (1 subgoal):\n 1. (\\<And>x' xs' y' ys'.\n        \\<lbrakk>xs = x' # xs'; ys = y' # ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_length_conv Suc_lessE)"], ["proof (state)\nthis:\n  xs = x' # xs'\n  ys = y' # ys'\n\ngoal (1 subgoal):\n 1. \\<And>i xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>i < length xs; i < length ys;\n                    (xs ! i, ys ! i) \\<in> R;\n                    \\<forall>j<i. xs ! j = ys ! j\\<rbrakk>\n                   \\<Longrightarrow> (xs, ys) \\<in> lexord R;\n        Suc i < length xs; Suc i < length ys;\n        (xs ! Suc i, ys ! Suc i) \\<in> R;\n        \\<forall>j<Suc i. xs ! j = ys ! j\\<rbrakk>\n       \\<Longrightarrow> (xs, ys) \\<in> lexord R", "moreover"], ["proof (state)\nthis:\n  xs = x' # xs'\n  ys = y' # ys'\n\ngoal (1 subgoal):\n 1. \\<And>i xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>i < length xs; i < length ys;\n                    (xs ! i, ys ! i) \\<in> R;\n                    \\<forall>j<i. xs ! j = ys ! j\\<rbrakk>\n                   \\<Longrightarrow> (xs, ys) \\<in> lexord R;\n        Suc i < length xs; Suc i < length ys;\n        (xs ! Suc i, ys ! Suc i) \\<in> R;\n        \\<forall>j<Suc i. xs ! j = ys ! j\\<rbrakk>\n       \\<Longrightarrow> (xs, ys) \\<in> lexord R", "with hyps(5)"], ["proof (chain)\npicking this:\n  \\<forall>j<Suc i. xs ! j = ys ! j\n  xs = x' # xs'\n  ys = y' # ys'", "have \"\\<forall>j<i. xs' ! j = ys' ! j\""], ["proof (prove)\nusing this:\n  \\<forall>j<Suc i. xs ! j = ys ! j\n  xs = x' # xs'\n  ys = y' # ys'\n\ngoal (1 subgoal):\n 1. \\<forall>j<i. xs' ! j = ys' ! j", "by (auto)"], ["proof (state)\nthis:\n  \\<forall>j<i. xs' ! j = ys' ! j\n\ngoal (1 subgoal):\n 1. \\<And>i xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>i < length xs; i < length ys;\n                    (xs ! i, ys ! i) \\<in> R;\n                    \\<forall>j<i. xs ! j = ys ! j\\<rbrakk>\n                   \\<Longrightarrow> (xs, ys) \\<in> lexord R;\n        Suc i < length xs; Suc i < length ys;\n        (xs ! Suc i, ys ! Suc i) \\<in> R;\n        \\<forall>j<Suc i. xs ! j = ys ! j\\<rbrakk>\n       \\<Longrightarrow> (xs, ys) \\<in> lexord R", "ultimately"], ["proof (chain)\npicking this:\n  xs = x' # xs'\n  ys = y' # ys'\n  \\<forall>j<i. xs' ! j = ys' ! j", "show ?case"], ["proof (prove)\nusing this:\n  xs = x' # xs'\n  ys = y' # ys'\n  \\<forall>j<i. xs' ! j = ys' ! j\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> lexord R", "using hyps"], ["proof (prove)\nusing this:\n  xs = x' # xs'\n  ys = y' # ys'\n  \\<forall>j<i. xs' ! j = ys' ! j\n  \\<lbrakk>i < length ?xs; i < length ?ys; (?xs ! i, ?ys ! i) \\<in> R;\n   \\<forall>j<i. ?xs ! j = ?ys ! j\\<rbrakk>\n  \\<Longrightarrow> (?xs, ?ys) \\<in> lexord R\n  Suc i < length xs\n  Suc i < length ys\n  (xs ! Suc i, ys ! Suc i) \\<in> R\n  \\<forall>j<Suc i. xs ! j = ys ! j\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> lexord R", "by (auto)"], ["proof (state)\nthis:\n  (xs, ys) \\<in> lexord R\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Distributed Concatenation \\<close>"], ["", "definition uncurry :: \"('a \\<Rightarrow> 'b \\<Rightarrow>  'c) \\<Rightarrow> ('a \\<times> 'b \\<Rightarrow> 'c)\" where\n[simp]: \"uncurry f = (\\<lambda>(x, y). f x y)\""], ["", "definition dist_concat ::\n  \"'a list set \\<Rightarrow> 'a list set \\<Rightarrow> 'a list set\" (infixr \"\\<^sup>\\<frown>\" 100) where\n\"dist_concat ls1 ls2 = (uncurry (@) ` (ls1 \\<times> ls2))\""], ["", "lemma dist_concat_left_empty [simp]:\n  \"{} \\<^sup>\\<frown> ys = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<^sup>\\<frown> ys = {}", "by (simp add: dist_concat_def)"], ["", "lemma dist_concat_right_empty [simp]:\n  \"xs \\<^sup>\\<frown> {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<^sup>\\<frown> {} = {}", "by (simp add: dist_concat_def)"], ["", "lemma dist_concat_insert [simp]:\n\"insert l ls1 \\<^sup>\\<frown> ls2 = ((@) l ` ( ls2)) \\<union> (ls1 \\<^sup>\\<frown> ls2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert l ls1 \\<^sup>\\<frown> ls2 =\n    (@) l ` ls2 \\<union> ls1 \\<^sup>\\<frown> ls2", "by (auto simp add: dist_concat_def)"], ["", "subsection \\<open> List Domain and Range \\<close>"], ["", "abbreviation seq_dom :: \"'a list \\<Rightarrow> nat set\" (\"dom\\<^sub>l\") where\n\"seq_dom xs \\<equiv> {0..<length xs}\""], ["", "abbreviation seq_ran :: \"'a list \\<Rightarrow> 'a set\" (\"ran\\<^sub>l\") where\n\"seq_ran xs \\<equiv> set xs\""], ["", "subsection \\<open> Extracting List Elements \\<close>"], ["", "definition seq_extract :: \"nat set \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" (infix \"\\<upharpoonleft>\\<^sub>l\" 80) where\n\"seq_extract A xs = nths xs A\""], ["", "lemma seq_extract_Nil [simp]: \"A \\<upharpoonleft>\\<^sub>l [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<upharpoonleft>\\<^sub>l [] = []", "by (simp add: seq_extract_def)"], ["", "lemma seq_extract_Cons:\n  \"A \\<upharpoonleft>\\<^sub>l (x # xs) = (if 0 \\<in> A then [x] else []) @ {j. Suc j \\<in> A} \\<upharpoonleft>\\<^sub>l xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<upharpoonleft>\\<^sub>l (x # xs) =\n    (if 0 \\<in> A then [x] else []) @\n    {j. Suc j \\<in> A} \\<upharpoonleft>\\<^sub>l xs", "by (simp add: seq_extract_def nths_Cons)"], ["", "lemma seq_extract_empty [simp]: \"{} \\<upharpoonleft>\\<^sub>l xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<upharpoonleft>\\<^sub>l xs = []", "by (simp add: seq_extract_def)"], ["", "lemma seq_extract_ident [simp]: \"{0..<length xs} \\<upharpoonleft>\\<^sub>l xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom\\<^sub>l xs \\<upharpoonleft>\\<^sub>l xs = xs", "unfolding list_eq_iff_nth_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (dom\\<^sub>l xs \\<upharpoonleft>\\<^sub>l xs) = length xs \\<and>\n    (\\<forall>i<length (dom\\<^sub>l xs \\<upharpoonleft>\\<^sub>l xs).\n        (dom\\<^sub>l xs \\<upharpoonleft>\\<^sub>l xs) ! i = xs ! i)", "by (auto simp add: seq_extract_def length_nths atLeast0LessThan)"], ["", "lemma seq_extract_split:\n  assumes \"i \\<le> length xs\"\n  shows \"{0..<i} \\<upharpoonleft>\\<^sub>l xs @ {i..<length xs} \\<upharpoonleft>\\<^sub>l xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<i} \\<upharpoonleft>\\<^sub>l xs @\n    {i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n    xs", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> length xs\n\ngoal (1 subgoal):\n 1. {0..<i} \\<upharpoonleft>\\<^sub>l xs @\n    {i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n    xs", "proof (induct xs arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> length [] \\<Longrightarrow>\n       {0..<i} \\<upharpoonleft>\\<^sub>l [] @\n       {i..<length []} \\<upharpoonleft>\\<^sub>l [] =\n       []\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   {0..<i} \\<upharpoonleft>\\<^sub>l xs @\n                   {i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n                   xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {0..<i} \\<upharpoonleft>\\<^sub>l (a # xs) @\n                         {i..<length (a # xs)} \\<upharpoonleft>\\<^sub>l\n                         (a # xs) =\n                         a # xs", "case Nil"], ["proof (state)\nthis:\n  i \\<le> length []\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> length [] \\<Longrightarrow>\n       {0..<i} \\<upharpoonleft>\\<^sub>l [] @\n       {i..<length []} \\<upharpoonleft>\\<^sub>l [] =\n       []\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   {0..<i} \\<upharpoonleft>\\<^sub>l xs @\n                   {i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n                   xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {0..<i} \\<upharpoonleft>\\<^sub>l (a # xs) @\n                         {i..<length (a # xs)} \\<upharpoonleft>\\<^sub>l\n                         (a # xs) =\n                         a # xs", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<le> length []\n\ngoal (1 subgoal):\n 1. {0..<i} \\<upharpoonleft>\\<^sub>l [] @\n    {i..<length []} \\<upharpoonleft>\\<^sub>l [] =\n    []", "by (simp add: seq_extract_def)"], ["proof (state)\nthis:\n  {0..<i} \\<upharpoonleft>\\<^sub>l [] @\n  {i..<length []} \\<upharpoonleft>\\<^sub>l [] =\n  []\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   {0..<i} \\<upharpoonleft>\\<^sub>l xs @\n                   {i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n                   xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {0..<i} \\<upharpoonleft>\\<^sub>l (a # xs) @\n                         {i..<length (a # xs)} \\<upharpoonleft>\\<^sub>l\n                         (a # xs) =\n                         a # xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   {0..<i} \\<upharpoonleft>\\<^sub>l xs @\n                   {i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n                   xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {0..<i} \\<upharpoonleft>\\<^sub>l (a # xs) @\n                         {i..<length (a # xs)} \\<upharpoonleft>\\<^sub>l\n                         (a # xs) =\n                         a # xs", "case (Cons x xs)"], ["proof (state)\nthis:\n  ?i \\<le> length xs \\<Longrightarrow>\n  {0..<?i} \\<upharpoonleft>\\<^sub>l xs @\n  {?i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n  xs\n  i \\<le> length (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   {0..<i} \\<upharpoonleft>\\<^sub>l xs @\n                   {i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n                   xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {0..<i} \\<upharpoonleft>\\<^sub>l (a # xs) @\n                         {i..<length (a # xs)} \\<upharpoonleft>\\<^sub>l\n                         (a # xs) =\n                         a # xs", "note hyp = this"], ["proof (state)\nthis:\n  ?i \\<le> length xs \\<Longrightarrow>\n  {0..<?i} \\<upharpoonleft>\\<^sub>l xs @\n  {?i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n  xs\n  i \\<le> length (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   {0..<i} \\<upharpoonleft>\\<^sub>l xs @\n                   {i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n                   xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {0..<i} \\<upharpoonleft>\\<^sub>l (a # xs) @\n                         {i..<length (a # xs)} \\<upharpoonleft>\\<^sub>l\n                         (a # xs) =\n                         a # xs", "have \"{j. Suc j < i} = {0..<i - 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {j. Suc j < i} = {0..<i - 1}", "by (auto)"], ["proof (state)\nthis:\n  {j. Suc j < i} = {0..<i - 1}\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   {0..<i} \\<upharpoonleft>\\<^sub>l xs @\n                   {i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n                   xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {0..<i} \\<upharpoonleft>\\<^sub>l (a # xs) @\n                         {i..<length (a # xs)} \\<upharpoonleft>\\<^sub>l\n                         (a # xs) =\n                         a # xs", "moreover"], ["proof (state)\nthis:\n  {j. Suc j < i} = {0..<i - 1}\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   {0..<i} \\<upharpoonleft>\\<^sub>l xs @\n                   {i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n                   xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {0..<i} \\<upharpoonleft>\\<^sub>l (a # xs) @\n                         {i..<length (a # xs)} \\<upharpoonleft>\\<^sub>l\n                         (a # xs) =\n                         a # xs", "have \"{j. i \\<le> Suc j \\<and> j < length xs} = {i - 1..<length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {j. i \\<le> Suc j \\<and> j < length xs} = {i - 1..<length xs}", "by (auto)"], ["proof (state)\nthis:\n  {j. i \\<le> Suc j \\<and> j < length xs} = {i - 1..<length xs}\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   {0..<i} \\<upharpoonleft>\\<^sub>l xs @\n                   {i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n                   xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {0..<i} \\<upharpoonleft>\\<^sub>l (a # xs) @\n                         {i..<length (a # xs)} \\<upharpoonleft>\\<^sub>l\n                         (a # xs) =\n                         a # xs", "ultimately"], ["proof (chain)\npicking this:\n  {j. Suc j < i} = {0..<i - 1}\n  {j. i \\<le> Suc j \\<and> j < length xs} = {i - 1..<length xs}", "show ?case"], ["proof (prove)\nusing this:\n  {j. Suc j < i} = {0..<i - 1}\n  {j. i \\<le> Suc j \\<and> j < length xs} = {i - 1..<length xs}\n\ngoal (1 subgoal):\n 1. {0..<i} \\<upharpoonleft>\\<^sub>l (x # xs) @\n    {i..<length (x # xs)} \\<upharpoonleft>\\<^sub>l (x # xs) =\n    x # xs", "using hyp"], ["proof (prove)\nusing this:\n  {j. Suc j < i} = {0..<i - 1}\n  {j. i \\<le> Suc j \\<and> j < length xs} = {i - 1..<length xs}\n  ?i \\<le> length xs \\<Longrightarrow>\n  {0..<?i} \\<upharpoonleft>\\<^sub>l xs @\n  {?i..<length xs} \\<upharpoonleft>\\<^sub>l xs =\n  xs\n  i \\<le> length (x # xs)\n\ngoal (1 subgoal):\n 1. {0..<i} \\<upharpoonleft>\\<^sub>l (x # xs) @\n    {i..<length (x # xs)} \\<upharpoonleft>\\<^sub>l (x # xs) =\n    x # xs", "by (force simp add: seq_extract_def nths_Cons)"], ["proof (state)\nthis:\n  {0..<i} \\<upharpoonleft>\\<^sub>l (x # xs) @\n  {i..<length (x # xs)} \\<upharpoonleft>\\<^sub>l (x # xs) =\n  x # xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma seq_extract_append:\n  \"A \\<upharpoonleft>\\<^sub>l (xs @ ys) = (A \\<upharpoonleft>\\<^sub>l xs) @ ({j. j + length xs \\<in> A} \\<upharpoonleft>\\<^sub>l ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<upharpoonleft>\\<^sub>l (xs @ ys) =\n    A \\<upharpoonleft>\\<^sub>l xs @\n    {j. j + length xs \\<in> A} \\<upharpoonleft>\\<^sub>l ys", "by (simp add: seq_extract_def nths_append)"], ["", "lemma seq_extract_range: \"A \\<upharpoonleft>\\<^sub>l xs = (A \\<inter> dom\\<^sub>l(xs)) \\<upharpoonleft>\\<^sub>l xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<upharpoonleft>\\<^sub>l xs =\n    (A \\<inter> dom\\<^sub>l xs) \\<upharpoonleft>\\<^sub>l xs", "apply (auto simp add: seq_extract_def nths_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (filter (\\<lambda>p. snd p \\<in> A) (zip xs [0..<length xs])) =\n    map fst\n     (filter (\\<lambda>p. snd p \\<in> A \\<and> snd p < length xs)\n       (zip xs [0..<length xs]))", "apply (metis (no_types, lifting) atLeastLessThan_iff filter_cong in_set_zip nth_mem set_upt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma seq_extract_out_of_range:\n  \"A \\<inter> dom\\<^sub>l(xs) = {} \\<Longrightarrow> A \\<upharpoonleft>\\<^sub>l xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> dom\\<^sub>l xs = {} \\<Longrightarrow>\n    A \\<upharpoonleft>\\<^sub>l xs = []", "by (metis seq_extract_def seq_extract_range nths_empty)"], ["", "lemma seq_extract_length [simp]:\n  \"length (A \\<upharpoonleft>\\<^sub>l xs) = card (A \\<inter> dom\\<^sub>l(xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (A \\<upharpoonleft>\\<^sub>l xs) =\n    card (A \\<inter> dom\\<^sub>l xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (A \\<upharpoonleft>\\<^sub>l xs) =\n    card (A \\<inter> dom\\<^sub>l xs)", "have \"{i. i < length(xs) \\<and> i \\<in> A} = (A \\<inter> {0..<length(xs)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length xs \\<and> i \\<in> A} = A \\<inter> dom\\<^sub>l xs", "by (auto)"], ["proof (state)\nthis:\n  {i. i < length xs \\<and> i \\<in> A} = A \\<inter> dom\\<^sub>l xs\n\ngoal (1 subgoal):\n 1. length (A \\<upharpoonleft>\\<^sub>l xs) =\n    card (A \\<inter> dom\\<^sub>l xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {i. i < length xs \\<and> i \\<in> A} = A \\<inter> dom\\<^sub>l xs\n\ngoal (1 subgoal):\n 1. length (A \\<upharpoonleft>\\<^sub>l xs) =\n    card (A \\<inter> dom\\<^sub>l xs)", "by (simp add: seq_extract_def length_nths)"], ["proof (state)\nthis:\n  length (A \\<upharpoonleft>\\<^sub>l xs) = card (A \\<inter> dom\\<^sub>l xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma seq_extract_Cons_atLeastLessThan:\n  assumes \"m < n\"\n  shows \"{m..<n} \\<upharpoonleft>\\<^sub>l (x # xs) = (if (m = 0) then x # ({0..<n-1} \\<upharpoonleft>\\<^sub>l xs) else {m-1..<n-1} \\<upharpoonleft>\\<^sub>l xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m..<n} \\<upharpoonleft>\\<^sub>l (x # xs) =\n    (if m = 0 then x # {0..<n - 1} \\<upharpoonleft>\\<^sub>l xs\n     else {m - 1..<n - 1} \\<upharpoonleft>\\<^sub>l xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {m..<n} \\<upharpoonleft>\\<^sub>l (x # xs) =\n    (if m = 0 then x # {0..<n - 1} \\<upharpoonleft>\\<^sub>l xs\n     else {m - 1..<n - 1} \\<upharpoonleft>\\<^sub>l xs)", "have \"{j. Suc j < n} = {0..<n - Suc 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {j. Suc j < n} = {0..<n - Suc 0}", "by (auto)"], ["proof (state)\nthis:\n  {j. Suc j < n} = {0..<n - Suc 0}\n\ngoal (1 subgoal):\n 1. {m..<n} \\<upharpoonleft>\\<^sub>l (x # xs) =\n    (if m = 0 then x # {0..<n - 1} \\<upharpoonleft>\\<^sub>l xs\n     else {m - 1..<n - 1} \\<upharpoonleft>\\<^sub>l xs)", "moreover"], ["proof (state)\nthis:\n  {j. Suc j < n} = {0..<n - Suc 0}\n\ngoal (1 subgoal):\n 1. {m..<n} \\<upharpoonleft>\\<^sub>l (x # xs) =\n    (if m = 0 then x # {0..<n - 1} \\<upharpoonleft>\\<^sub>l xs\n     else {m - 1..<n - 1} \\<upharpoonleft>\\<^sub>l xs)", "have \"{j. m \\<le> Suc j \\<and> Suc j < n} = {m - Suc 0..<n - Suc 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {j. m \\<le> Suc j \\<and> Suc j < n} = {m - Suc 0..<n - Suc 0}", "by (auto)"], ["proof (state)\nthis:\n  {j. m \\<le> Suc j \\<and> Suc j < n} = {m - Suc 0..<n - Suc 0}\n\ngoal (1 subgoal):\n 1. {m..<n} \\<upharpoonleft>\\<^sub>l (x # xs) =\n    (if m = 0 then x # {0..<n - 1} \\<upharpoonleft>\\<^sub>l xs\n     else {m - 1..<n - 1} \\<upharpoonleft>\\<^sub>l xs)", "ultimately"], ["proof (chain)\npicking this:\n  {j. Suc j < n} = {0..<n - Suc 0}\n  {j. m \\<le> Suc j \\<and> Suc j < n} = {m - Suc 0..<n - Suc 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  {j. Suc j < n} = {0..<n - Suc 0}\n  {j. m \\<le> Suc j \\<and> Suc j < n} = {m - Suc 0..<n - Suc 0}\n\ngoal (1 subgoal):\n 1. {m..<n} \\<upharpoonleft>\\<^sub>l (x # xs) =\n    (if m = 0 then x # {0..<n - 1} \\<upharpoonleft>\\<^sub>l xs\n     else {m - 1..<n - 1} \\<upharpoonleft>\\<^sub>l xs)", "using assms"], ["proof (prove)\nusing this:\n  {j. Suc j < n} = {0..<n - Suc 0}\n  {j. m \\<le> Suc j \\<and> Suc j < n} = {m - Suc 0..<n - Suc 0}\n  m < n\n\ngoal (1 subgoal):\n 1. {m..<n} \\<upharpoonleft>\\<^sub>l (x # xs) =\n    (if m = 0 then x # {0..<n - 1} \\<upharpoonleft>\\<^sub>l xs\n     else {m - 1..<n - 1} \\<upharpoonleft>\\<^sub>l xs)", "by (auto simp add: seq_extract_Cons)"], ["proof (state)\nthis:\n  {m..<n} \\<upharpoonleft>\\<^sub>l (x # xs) =\n  (if m = 0 then x # {0..<n - 1} \\<upharpoonleft>\\<^sub>l xs\n   else {m - 1..<n - 1} \\<upharpoonleft>\\<^sub>l xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma seq_extract_singleton:\n  assumes \"i < length xs\"\n  shows \"{i} \\<upharpoonleft>\\<^sub>l xs = [xs ! i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i} \\<upharpoonleft>\\<^sub>l xs = [xs ! i]", "using assms"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. {i} \\<upharpoonleft>\\<^sub>l xs = [xs ! i]", "apply (induct xs arbitrary: i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length [] \\<Longrightarrow>\n       {i} \\<upharpoonleft>\\<^sub>l [] = [[] ! i]\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   {i} \\<upharpoonleft>\\<^sub>l xs = [xs ! i];\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {i} \\<upharpoonleft>\\<^sub>l (a # xs) =\n                         [(a # xs) ! i]", "apply (auto simp add: seq_extract_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   {i} \\<upharpoonleft>\\<^sub>l xs = [xs ! i];\n        i < Suc (length xs); 0 < i\\<rbrakk>\n       \\<Longrightarrow> {j. Suc j = i} \\<upharpoonleft>\\<^sub>l xs =\n                         [xs ! (i - Suc 0)]", "apply (rename_tac xs i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   {i} \\<upharpoonleft>\\<^sub>l xs = [xs ! i];\n        i < Suc (length xs); 0 < i\\<rbrakk>\n       \\<Longrightarrow> {j. Suc j = i} \\<upharpoonleft>\\<^sub>l xs =\n                         [xs ! (i - Suc 0)]", "apply (subgoal_tac \"{j. Suc j = i} = {i - 1}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   {i} \\<upharpoonleft>\\<^sub>l xs = [xs ! i];\n        i < Suc (length xs); 0 < i; {j. Suc j = i} = {i - 1}\\<rbrakk>\n       \\<Longrightarrow> {j. Suc j = i} \\<upharpoonleft>\\<^sub>l xs =\n                         [xs ! (i - Suc 0)]\n 2. \\<And>xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   {i} \\<upharpoonleft>\\<^sub>l xs = [xs ! i];\n        i < Suc (length xs); 0 < i\\<rbrakk>\n       \\<Longrightarrow> {j. Suc j = i} = {i - 1}", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma seq_extract_as_map:\n  assumes \"m < n\" \"n \\<le> length xs\"\n  shows \"{m..<n} \\<upharpoonleft>\\<^sub>l xs = map (nth xs) [m..<n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m..<n} \\<upharpoonleft>\\<^sub>l xs = map ((!) xs) [m..<n]", "using assms"], ["proof (prove)\nusing this:\n  m < n\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. {m..<n} \\<upharpoonleft>\\<^sub>l xs = map ((!) xs) [m..<n]", "proof (induct xs arbitrary: m n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m < n; n \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l [] =\n                         map ((!) []) [m..<n]\n 2. \\<And>a xs m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m < n; n \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l xs =\n                                     map ((!) xs) [m..<n];\n        m < n; n \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l (a # xs) =\n                         map ((!) (a # xs)) [m..<n]", "case Nil"], ["proof (state)\nthis:\n  m < n\n  n \\<le> length []\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m < n; n \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l [] =\n                         map ((!) []) [m..<n]\n 2. \\<And>a xs m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m < n; n \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l xs =\n                                     map ((!) xs) [m..<n];\n        m < n; n \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l (a # xs) =\n                         map ((!) (a # xs)) [m..<n]", "thus ?case"], ["proof (prove)\nusing this:\n  m < n\n  n \\<le> length []\n\ngoal (1 subgoal):\n 1. {m..<n} \\<upharpoonleft>\\<^sub>l [] = map ((!) []) [m..<n]", "by simp"], ["proof (state)\nthis:\n  {m..<n} \\<upharpoonleft>\\<^sub>l [] = map ((!) []) [m..<n]\n\ngoal (1 subgoal):\n 1. \\<And>a xs m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m < n; n \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l xs =\n                                     map ((!) xs) [m..<n];\n        m < n; n \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l (a # xs) =\n                         map ((!) (a # xs)) [m..<n]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m < n; n \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l xs =\n                                     map ((!) xs) [m..<n];\n        m < n; n \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l (a # xs) =\n                         map ((!) (a # xs)) [m..<n]", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?m < ?n; ?n \\<le> length xs\\<rbrakk>\n  \\<Longrightarrow> {?m..<?n} \\<upharpoonleft>\\<^sub>l xs =\n                    map ((!) xs) [?m..<?n]\n  m < n\n  n \\<le> length (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m < n; n \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l xs =\n                                     map ((!) xs) [m..<n];\n        m < n; n \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l (a # xs) =\n                         map ((!) (a # xs)) [m..<n]", "have \"[m..<n] = m # [m+1..<n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [m..<n] = m # [m + 1..<n]", "using Cons.prems(1) upt_eq_Cons_conv"], ["proof (prove)\nusing this:\n  m < n\n  ([?i..<?j] = ?x # ?xs) =\n  (?i < ?j \\<and> ?i = ?x \\<and> [?i + 1..<?j] = ?xs)\n\ngoal (1 subgoal):\n 1. [m..<n] = m # [m + 1..<n]", "by blast"], ["proof (state)\nthis:\n  [m..<n] = m # [m + 1..<n]\n\ngoal (1 subgoal):\n 1. \\<And>a xs m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m < n; n \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l xs =\n                                     map ((!) xs) [m..<n];\n        m < n; n \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l (a # xs) =\n                         map ((!) (a # xs)) [m..<n]", "moreover"], ["proof (state)\nthis:\n  [m..<n] = m # [m + 1..<n]\n\ngoal (1 subgoal):\n 1. \\<And>a xs m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m < n; n \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l xs =\n                                     map ((!) xs) [m..<n];\n        m < n; n \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l (a # xs) =\n                         map ((!) (a # xs)) [m..<n]", "have \"map (nth (x # xs)) [Suc m..<n] = map (nth xs) [m..<n-1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]", "by (simp add: map_nth_Cons_atLeastLessThan)"], ["proof (state)\nthis:\n  map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]\n\ngoal (1 subgoal):\n 1. \\<And>a xs m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m < n; n \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l xs =\n                                     map ((!) xs) [m..<n];\n        m < n; n \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> {m..<n} \\<upharpoonleft>\\<^sub>l (a # xs) =\n                         map ((!) (a # xs)) [m..<n]", "ultimately"], ["proof (chain)\npicking this:\n  [m..<n] = m # [m + 1..<n]\n  map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]", "show ?case"], ["proof (prove)\nusing this:\n  [m..<n] = m # [m + 1..<n]\n  map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]\n\ngoal (1 subgoal):\n 1. {m..<n} \\<upharpoonleft>\\<^sub>l (x # xs) = map ((!) (x # xs)) [m..<n]", "using Cons upt_rec"], ["proof (prove)\nusing this:\n  [m..<n] = m # [m + 1..<n]\n  map ((!) (x # xs)) [Suc m..<n] = map ((!) xs) [m..<n - 1]\n  \\<lbrakk>?m < ?n; ?n \\<le> length xs\\<rbrakk>\n  \\<Longrightarrow> {?m..<?n} \\<upharpoonleft>\\<^sub>l xs =\n                    map ((!) xs) [?m..<?n]\n  m < n\n  n \\<le> length (x # xs)\n  [?i..<?j] = (if ?i < ?j then ?i # [Suc ?i..<?j] else [])\n\ngoal (1 subgoal):\n 1. {m..<n} \\<upharpoonleft>\\<^sub>l (x # xs) = map ((!) (x # xs)) [m..<n]", "by (auto simp add: seq_extract_Cons_atLeastLessThan)"], ["proof (state)\nthis:\n  {m..<n} \\<upharpoonleft>\\<^sub>l (x # xs) = map ((!) (x # xs)) [m..<n]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma seq_append_as_extract:\n  \"xs = ys @ zs \\<longleftrightarrow> (\\<exists> i\\<le>length(xs). ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and> zs = {i..<length(xs)} \\<upharpoonleft>\\<^sub>l xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = ys @ zs) =\n    (\\<exists>i\\<le>length xs.\n        ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n        zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = ys @ zs \\<Longrightarrow>\n    \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs\n 2. \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs \\<Longrightarrow>\n    xs = ys @ zs", "assume xs: \"xs = ys @ zs\""], ["proof (state)\nthis:\n  xs = ys @ zs\n\ngoal (2 subgoals):\n 1. xs = ys @ zs \\<Longrightarrow>\n    \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs\n 2. \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs \\<Longrightarrow>\n    xs = ys @ zs", "moreover"], ["proof (state)\nthis:\n  xs = ys @ zs\n\ngoal (2 subgoals):\n 1. xs = ys @ zs \\<Longrightarrow>\n    \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs\n 2. \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs \\<Longrightarrow>\n    xs = ys @ zs", "have \"ys = {0..<length ys} \\<upharpoonleft>\\<^sub>l (ys @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = dom\\<^sub>l ys \\<upharpoonleft>\\<^sub>l (ys @ zs)", "by (simp add: seq_extract_append)"], ["proof (state)\nthis:\n  ys = dom\\<^sub>l ys \\<upharpoonleft>\\<^sub>l (ys @ zs)\n\ngoal (2 subgoals):\n 1. xs = ys @ zs \\<Longrightarrow>\n    \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs\n 2. \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs \\<Longrightarrow>\n    xs = ys @ zs", "moreover"], ["proof (state)\nthis:\n  ys = dom\\<^sub>l ys \\<upharpoonleft>\\<^sub>l (ys @ zs)\n\ngoal (2 subgoals):\n 1. xs = ys @ zs \\<Longrightarrow>\n    \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs\n 2. \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs \\<Longrightarrow>\n    xs = ys @ zs", "have \"zs = {length ys..<length ys + length zs} \\<upharpoonleft>\\<^sub>l (ys @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zs =\n    {length ys..<length ys + length zs} \\<upharpoonleft>\\<^sub>l (ys @ zs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zs =\n    {length ys..<length ys + length zs} \\<upharpoonleft>\\<^sub>l (ys @ zs)", "have \"{length ys..<length ys + length zs} \\<inter> {0..<length ys} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {length ys..<length ys + length zs} \\<inter> dom\\<^sub>l ys = {}", "by auto"], ["proof (state)\nthis:\n  {length ys..<length ys + length zs} \\<inter> dom\\<^sub>l ys = {}\n\ngoal (1 subgoal):\n 1. zs =\n    {length ys..<length ys + length zs} \\<upharpoonleft>\\<^sub>l (ys @ zs)", "moreover"], ["proof (state)\nthis:\n  {length ys..<length ys + length zs} \\<inter> dom\\<^sub>l ys = {}\n\ngoal (1 subgoal):\n 1. zs =\n    {length ys..<length ys + length zs} \\<upharpoonleft>\\<^sub>l (ys @ zs)", "have s1: \"{j. j < length zs} = {0..<length zs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {j. j < length zs} = dom\\<^sub>l zs", "by auto"], ["proof (state)\nthis:\n  {j. j < length zs} = dom\\<^sub>l zs\n\ngoal (1 subgoal):\n 1. zs =\n    {length ys..<length ys + length zs} \\<upharpoonleft>\\<^sub>l (ys @ zs)", "ultimately"], ["proof (chain)\npicking this:\n  {length ys..<length ys + length zs} \\<inter> dom\\<^sub>l ys = {}\n  {j. j < length zs} = dom\\<^sub>l zs", "show ?thesis"], ["proof (prove)\nusing this:\n  {length ys..<length ys + length zs} \\<inter> dom\\<^sub>l ys = {}\n  {j. j < length zs} = dom\\<^sub>l zs\n\ngoal (1 subgoal):\n 1. zs =\n    {length ys..<length ys + length zs} \\<upharpoonleft>\\<^sub>l (ys @ zs)", "by (simp add: seq_extract_append seq_extract_out_of_range)"], ["proof (state)\nthis:\n  zs =\n  {length ys..<length ys + length zs} \\<upharpoonleft>\\<^sub>l (ys @ zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zs =\n  {length ys..<length ys + length zs} \\<upharpoonleft>\\<^sub>l (ys @ zs)\n\ngoal (2 subgoals):\n 1. xs = ys @ zs \\<Longrightarrow>\n    \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs\n 2. \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs \\<Longrightarrow>\n    xs = ys @ zs", "ultimately"], ["proof (chain)\npicking this:\n  xs = ys @ zs\n  ys = dom\\<^sub>l ys \\<upharpoonleft>\\<^sub>l (ys @ zs)\n  zs =\n  {length ys..<length ys + length zs} \\<upharpoonleft>\\<^sub>l (ys @ zs)", "show \"(\\<exists> i\\<le>length(xs). ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and> zs = {i..<length(xs)} \\<upharpoonleft>\\<^sub>l xs)\""], ["proof (prove)\nusing this:\n  xs = ys @ zs\n  ys = dom\\<^sub>l ys \\<upharpoonleft>\\<^sub>l (ys @ zs)\n  zs =\n  {length ys..<length ys + length zs} \\<upharpoonleft>\\<^sub>l (ys @ zs)\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs", "by (rule_tac x=\"length ys\" in exI, auto)"], ["proof (state)\nthis:\n  \\<exists>i\\<le>length xs.\n     ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n     zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs \\<Longrightarrow>\n    xs = ys @ zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs \\<Longrightarrow>\n    xs = ys @ zs", "assume \"\\<exists>i\\<le>length xs. ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and> zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs\""], ["proof (state)\nthis:\n  \\<exists>i\\<le>length xs.\n     ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n     zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>length xs.\n       ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n       zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs \\<Longrightarrow>\n    xs = ys @ zs", "thus \"xs = ys @ zs\""], ["proof (prove)\nusing this:\n  \\<exists>i\\<le>length xs.\n     ys = {0..<i} \\<upharpoonleft>\\<^sub>l xs \\<and>\n     zs = {i..<length xs} \\<upharpoonleft>\\<^sub>l xs\n\ngoal (1 subgoal):\n 1. xs = ys @ zs", "by (auto simp add: seq_extract_split)"], ["proof (state)\nthis:\n  xs = ys @ zs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Filtering a list according to a set \\<close>"], ["", "definition seq_filter :: \"'a list \\<Rightarrow> 'a set \\<Rightarrow> 'a list\" (infix \"\\<restriction>\\<^sub>l\" 80) where\n\"seq_filter xs A = filter (\\<lambda> x. x \\<in> A) xs\""], ["", "lemma seq_filter_Cons_in [simp]: \n  \"x \\<in> cs \\<Longrightarrow> (x # xs) \\<restriction>\\<^sub>l cs = x # (xs \\<restriction>\\<^sub>l cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> cs \\<Longrightarrow>\n    (x # xs) \\<restriction>\\<^sub>l cs = x # xs \\<restriction>\\<^sub>l cs", "by (simp add: seq_filter_def)"], ["", "lemma seq_filter_Cons_out [simp]: \n  \"x \\<notin> cs \\<Longrightarrow> (x # xs) \\<restriction>\\<^sub>l cs = (xs \\<restriction>\\<^sub>l cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> cs \\<Longrightarrow>\n    (x # xs) \\<restriction>\\<^sub>l cs = xs \\<restriction>\\<^sub>l cs", "by (simp add: seq_filter_def)"], ["", "lemma seq_filter_Nil [simp]: \"[] \\<restriction>\\<^sub>l A = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<restriction>\\<^sub>l A = []", "by (simp add: seq_filter_def)"], ["", "lemma seq_filter_empty [simp]: \"xs \\<restriction>\\<^sub>l {} = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<restriction>\\<^sub>l {} = []", "by (simp add: seq_filter_def)"], ["", "lemma seq_filter_append: \"(xs @ ys) \\<restriction>\\<^sub>l A = (xs \\<restriction>\\<^sub>l A) @ (ys \\<restriction>\\<^sub>l A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ys) \\<restriction>\\<^sub>l A =\n    xs \\<restriction>\\<^sub>l A @ ys \\<restriction>\\<^sub>l A", "by (simp add: seq_filter_def)"], ["", "lemma seq_filter_UNIV [simp]: \"xs \\<restriction>\\<^sub>l UNIV = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<restriction>\\<^sub>l UNIV = xs", "by (simp add: seq_filter_def)"], ["", "lemma seq_filter_twice [simp]: \"(xs \\<restriction>\\<^sub>l A) \\<restriction>\\<^sub>l B = xs \\<restriction>\\<^sub>l (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<restriction>\\<^sub>l A) \\<restriction>\\<^sub>l B =\n    xs \\<restriction>\\<^sub>l (A \\<inter> B)", "by (simp add: seq_filter_def)"], ["", "subsection \\<open> Minus on lists \\<close>"], ["", "instantiation list :: (type) minus\nbegin"], ["", "text \\<open> We define list minus so that if the second list is not a prefix of the first, then an arbitrary\n        list longer than the combined length is produced. Thus we can always determined from the output\n        whether the minus is defined or not. \\<close>"], ["", "definition \"xs - ys = (if (prefix ys xs) then drop (length ys) xs else [])\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, minus_class)", ".."], ["", "end"], ["", "lemma minus_cancel [simp]: \"xs - xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs - xs = []", "by (simp add: minus_list_def)"], ["", "lemma append_minus [simp]: \"(xs @ ys) - xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ ys - xs = ys", "by (simp add: minus_list_def)"], ["", "lemma minus_right_nil [simp]: \"xs - [] = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs - [] = xs", "by (simp add: minus_list_def)"], ["", "lemma list_concat_minus_list_concat: \"(s @ t) - (s @ z) = t - z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s @ t - (s @ z) = t - z", "by (simp add: minus_list_def)"], ["", "lemma length_minus_list: \"y \\<le> x \\<Longrightarrow> length(x - y) = length(x) - length(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<Longrightarrow> length (x - y) = length x - length y", "by (simp add: less_eq_list_def minus_list_def)"], ["", "lemma map_list_minus:\n  \"xs \\<le> ys \\<Longrightarrow> map f (ys - xs) = map f ys - map f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<le> ys \\<Longrightarrow> map f (ys - xs) = map f ys - map f xs", "by (simp add: drop_map less_eq_list_def map_mono_prefix minus_list_def)"], ["", "lemma list_minus_first_tl [simp]: \n  \"[x] \\<le> xs \\<Longrightarrow> (xs - [x]) = tl xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x] \\<le> xs \\<Longrightarrow> xs - [x] = tl xs", "by (metis Prefix_Order.prefixE append.left_neutral append_minus list.sel(3) not_Cons_self2 tl_append2)"], ["", "text \\<open> Extra lemmas about @{term prefix} and @{term strict_prefix} \\<close>"], ["", "lemma prefix_concat_minus:\n  assumes \"prefix xs ys\"\n  shows \"xs @ (ys - xs) = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ ys - xs = ys", "using assms"], ["proof (prove)\nusing this:\n  prefix xs ys\n\ngoal (1 subgoal):\n 1. xs @ ys - xs = ys", "by (metis minus_list_def prefix_drop)"], ["", "lemma prefix_minus_concat:\n  assumes \"prefix s t\"\n  shows \"(t - s) @ z = (t @ z) - s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t - s) @ z = t @ z - s", "using assms"], ["proof (prove)\nusing this:\n  prefix s t\n\ngoal (1 subgoal):\n 1. (t - s) @ z = t @ z - s", "by (simp add: Sublist.prefix_length_le minus_list_def)"], ["", "lemma strict_prefix_minus_not_empty:\n  assumes \"strict_prefix xs ys\"\n  shows \"ys - xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys - xs \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  strict_prefix xs ys\n\ngoal (1 subgoal):\n 1. ys - xs \\<noteq> []", "by (metis append_Nil2 prefix_concat_minus strict_prefix_def)"], ["", "lemma strict_prefix_diff_minus:\n  assumes \"prefix xs ys\" and \"xs \\<noteq> ys\"\n  shows \"(ys - xs) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys - xs \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  prefix xs ys\n  xs \\<noteq> ys\n\ngoal (1 subgoal):\n 1. ys - xs \\<noteq> []", "by (simp add: strict_prefix_minus_not_empty)"], ["", "lemma length_tl_list_minus_butlast_gt_zero:\n  assumes \"length s < length t\" and \"strict_prefix (butlast s) t\" and \"length s > 0\"\n  shows \"length (tl (t - (butlast s))) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (tl (t - butlast s))", "using assms"], ["proof (prove)\nusing this:\n  length s < length t\n  strict_prefix (butlast s) t\n  0 < length s\n\ngoal (1 subgoal):\n 1. 0 < length (tl (t - butlast s))", "by (metis Nitpick.size_list_simp(2) butlast_snoc hd_Cons_tl length_butlast length_greater_0_conv length_tl less_trans nat_neq_iff strict_prefix_minus_not_empty prefix_order.dual_order.strict_implies_order prefix_concat_minus)"], ["", "lemma list_minus_butlast_eq_butlast_list:\n  assumes \"length t = length s\" and \"strict_prefix (butlast s) t\"\n  shows \"t - (butlast s) = [last t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t - butlast s = [last t]", "using assms"], ["proof (prove)\nusing this:\n  length t = length s\n  strict_prefix (butlast s) t\n\ngoal (1 subgoal):\n 1. t - butlast s = [last t]", "by (metis append_butlast_last_id append_eq_append_conv butlast.simps(1) length_butlast less_numeral_extra(3) list.size(3) prefix_order.dual_order.strict_implies_order prefix_concat_minus prefix_length_less)"], ["", "lemma butlast_strict_prefix_length_lt_imp_last_tl_minus_butlast_eq_last:\n  assumes \"length s > 0\" \"strict_prefix (butlast s) t\" \"length s < length t\"\n  shows \"last (tl (t - (butlast s))) = (last t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (tl (t - butlast s)) = last t", "using assms"], ["proof (prove)\nusing this:\n  0 < length s\n  strict_prefix (butlast s) t\n  length s < length t\n\ngoal (1 subgoal):\n 1. last (tl (t - butlast s)) = last t", "by (metis last_append last_tl length_tl_list_minus_butlast_gt_zero less_numeral_extra(3) list.size(3) append_minus strict_prefix_eq_exists)"], ["", "lemma tl_list_minus_butlast_not_empty:\n  assumes \"strict_prefix (butlast s) t\" and \"length s > 0\" and \"length t > length s\"\n  shows \"tl (t - (butlast s)) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (t - butlast s) \\<noteq> []", "using assms length_tl_list_minus_butlast_gt_zero"], ["proof (prove)\nusing this:\n  strict_prefix (butlast s) t\n  0 < length s\n  length s < length t\n  \\<lbrakk>length ?s < length ?t; strict_prefix (butlast ?s) ?t;\n   0 < length ?s\\<rbrakk>\n  \\<Longrightarrow> 0 < length (tl (?t - butlast ?s))\n\ngoal (1 subgoal):\n 1. tl (t - butlast s) \\<noteq> []", "by fastforce"], ["", "lemma tl_list_minus_butlast_empty:\n  assumes \"strict_prefix (butlast s) t\" and \"length s > 0\" and \"length t = length s\"\n  shows \"tl (t - (butlast s)) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (t - butlast s) = []", "using assms"], ["proof (prove)\nusing this:\n  strict_prefix (butlast s) t\n  0 < length s\n  length t = length s\n\ngoal (1 subgoal):\n 1. tl (t - butlast s) = []", "by (simp add: list_minus_butlast_eq_butlast_list)"], ["", "lemma tl_list_minus_butlast_eq_empty:\n  assumes \"strict_prefix (butlast s) t\" and \"length s = length t\"\n  shows \"tl (t - (butlast s)) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (t - butlast s) = []", "using assms"], ["proof (prove)\nusing this:\n  strict_prefix (butlast s) t\n  length s = length t\n\ngoal (1 subgoal):\n 1. tl (t - butlast s) = []", "by (metis list.sel(3) list_minus_butlast_eq_butlast_list)"], ["", "lemma length_list_minus:\n  assumes \"strict_prefix s t\"\n  shows \"length(t - s) = length(t) - length(s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (t - s) = length t - length s", "using assms"], ["proof (prove)\nusing this:\n  strict_prefix s t\n\ngoal (1 subgoal):\n 1. length (t - s) = length t - length s", "by (simp add: minus_list_def prefix_order.dual_order.strict_implies_order)"], ["", "subsection \\<open> Laws on @{term take}, @{term drop}, and @{term nths} \\<close>"], ["", "lemma take_prefix: \"m \\<le> n \\<Longrightarrow> take m xs \\<le> take n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> take m xs \\<le> take n xs", "by (metis Prefix_Order.prefixI append_take_drop_id min_absorb2 take_append take_take)"], ["", "lemma nths_atLeastAtMost_0_take: \"nths xs {0..m} = take (Suc m) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths xs {0..m} = take (Suc m) xs", "by (metis atLeast0AtMost lessThan_Suc_atMost nths_upt_eq_take)"], ["", "lemma nths_atLeastLessThan_0_take: \"nths xs {0..<m} = take m xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths xs {0..<m} = take m xs", "by (simp add: atLeast0LessThan)"], ["", "lemma nths_atLeastAtMost_prefix: \"m \\<le> n \\<Longrightarrow> nths xs {0..m} \\<le> nths xs {0..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> nths xs {0..m} \\<le> nths xs {0..n}", "by (simp add: nths_atLeastAtMost_0_take take_prefix)"], ["", "lemma sorted_nths_atLeastAtMost_0: \"\\<lbrakk> m \\<le> n; sorted (nths xs {0..n}) \\<rbrakk> \\<Longrightarrow> sorted (nths xs {0..m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n; sorted (nths xs {0..n})\\<rbrakk>\n    \\<Longrightarrow> sorted (nths xs {0..m})", "using nths_atLeastAtMost_prefix sorted_prefix"], ["proof (prove)\nusing this:\n  ?m \\<le> ?n \\<Longrightarrow> nths ?xs {0..?m} \\<le> nths ?xs {0..?n}\n  \\<lbrakk>?xs \\<le> ?ys; sorted ?ys\\<rbrakk> \\<Longrightarrow> sorted ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n; sorted (nths xs {0..n})\\<rbrakk>\n    \\<Longrightarrow> sorted (nths xs {0..m})", "by blast"], ["", "lemma sorted_nths_atLeastLessThan_0: \"\\<lbrakk> m \\<le> n; sorted (nths xs {0..<n}) \\<rbrakk> \\<Longrightarrow> sorted (nths xs {0..<m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n; sorted (nths xs {0..<n})\\<rbrakk>\n    \\<Longrightarrow> sorted (nths xs {0..<m})", "by (metis atLeast0LessThan nths_upt_eq_take sorted_prefix take_prefix)"], ["", "lemma list_augment_as_update: \n  \"k < length xs \\<Longrightarrow> list_augment xs k x = list_update xs k x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length xs \\<Longrightarrow> list_augment xs k x = xs[k := x]", "by (metis list_augment_def list_augment_idem list_update_overwrite)"], ["", "lemma nths_list_update_out: \"k \\<notin> A \\<Longrightarrow> nths (list_update xs k x) A = nths xs A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<notin> A \\<Longrightarrow> nths (xs[k := x]) A = nths xs A", "apply (induct xs arbitrary: k x A)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k x A.\n       k \\<notin> A \\<Longrightarrow> nths ([][k := x]) A = nths [] A\n 2. \\<And>a xs k x A.\n       \\<lbrakk>\\<And>k x A.\n                   k \\<notin> A \\<Longrightarrow>\n                   nths (xs[k := x]) A = nths xs A;\n        k \\<notin> A\\<rbrakk>\n       \\<Longrightarrow> nths ((a # xs)[k := x]) A = nths (a # xs) A", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs k x A.\n       \\<lbrakk>\\<And>k x A.\n                   k \\<notin> A \\<Longrightarrow>\n                   nths (xs[k := x]) A = nths xs A;\n        k \\<notin> A\\<rbrakk>\n       \\<Longrightarrow> nths\n                          (case k of 0 \\<Rightarrow> x # xs\n                           | Suc j \\<Rightarrow> a # xs[j := x])\n                          A =\n                         nths (a # xs) A", "apply (rename_tac a xs k x A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs k x A.\n       \\<lbrakk>\\<And>k x A.\n                   k \\<notin> A \\<Longrightarrow>\n                   nths (xs[k := x]) A = nths xs A;\n        k \\<notin> A\\<rbrakk>\n       \\<Longrightarrow> nths\n                          (case k of 0 \\<Rightarrow> x # xs\n                           | Suc j \\<Rightarrow> a # xs[j := x])\n                          A =\n                         nths (a # xs) A", "apply (case_tac k)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs k x A.\n       \\<lbrakk>\\<And>k x A.\n                   k \\<notin> A \\<Longrightarrow>\n                   nths (xs[k := x]) A = nths xs A;\n        k \\<notin> A; k = 0\\<rbrakk>\n       \\<Longrightarrow> nths\n                          (case k of 0 \\<Rightarrow> x # xs\n                           | Suc j \\<Rightarrow> a # xs[j := x])\n                          A =\n                         nths (a # xs) A\n 2. \\<And>a xs k x A nat.\n       \\<lbrakk>\\<And>k x A.\n                   k \\<notin> A \\<Longrightarrow>\n                   nths (xs[k := x]) A = nths xs A;\n        k \\<notin> A; k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> nths\n                          (case k of 0 \\<Rightarrow> x # xs\n                           | Suc j \\<Rightarrow> a # xs[j := x])\n                          A =\n                         nths (a # xs) A", "apply (auto simp add: nths_Cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nths_list_augment_out: \"\\<lbrakk> k < length xs; k \\<notin> A \\<rbrakk> \\<Longrightarrow> nths (list_augment xs k x) A = nths xs A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length xs; k \\<notin> A\\<rbrakk>\n    \\<Longrightarrow> nths (list_augment xs k x) A = nths xs A", "by (simp add: list_augment_as_update nths_list_update_out)"], ["", "end"]]}