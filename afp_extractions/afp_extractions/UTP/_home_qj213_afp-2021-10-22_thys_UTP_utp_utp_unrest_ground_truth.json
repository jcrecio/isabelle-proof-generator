{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/utp/utp_unrest.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["lemma unrest_expr_alt_def:\n  \"weak_lens x \\<Longrightarrow> (x \\<sharp> P) = (\\<forall> b b'. \\<lbrakk>P\\<rbrakk>\\<^sub>e (b \\<oplus>\\<^sub>L b' on x) = \\<lbrakk>P\\<rbrakk>\\<^sub>e b)\"", "lemma unrest_var_comp [unrest]:\n  \"\\<lbrakk> x \\<sharp> P; y \\<sharp> P \\<rbrakk> \\<Longrightarrow> x;y \\<sharp> P\"", "lemma unrest_svar [unrest]: \"(&x \\<sharp> P) \\<longleftrightarrow> (x \\<sharp> P)\"", "lemma unrest_lit [unrest]: \"x \\<sharp> \\<guillemotleft>v\\<guillemotright>\"", "lemma unrest_sublens:\n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"x \\<sharp> P\" \"y \\<subseteq>\\<^sub>L x\"\n  shows \"y \\<sharp> P\"", "lemma unrest_equiv:\n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"mwb_lens y\" \"x \\<approx>\\<^sub>L y\" \"x \\<sharp> P\"\n  shows \"y \\<sharp> P\"", "lemma bij_lens_unrest_all:\n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"bij_lens X\" \"X \\<sharp> P\"\n  shows \"\\<Sigma> \\<sharp> P\"", "lemma bij_lens_unrest_all_eq:\n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"bij_lens X\"\n  shows \"(\\<Sigma> \\<sharp> P) \\<longleftrightarrow> (X \\<sharp> P)\"", "lemma unrest_all_var:\n  fixes e :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"\\<Sigma> \\<sharp> e\"\n  shows \"x \\<sharp> e\"", "lemma unrest_plus_split:\n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"x \\<bowtie> y\" \"vwb_lens x\" \"vwb_lens y\"\n  shows \"unrest (x +\\<^sub>L y) P \\<longleftrightarrow> (x \\<sharp> P) \\<and> (y \\<sharp> P)\"", "lemma unrest_var [unrest]: \"\\<lbrakk> mwb_lens x; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> y \\<sharp> var x\"", "lemma unrest_iuvar [unrest]: \"\\<lbrakk> mwb_lens x; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> $y \\<sharp> $x\"", "lemma unrest_ouvar [unrest]: \"\\<lbrakk> mwb_lens x; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> $y\\<acute> \\<sharp> $x\\<acute>\"", "lemma unrest_iuvar_ouvar [unrest]:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"mwb_lens y\"\n  shows \"$x \\<sharp> $y\\<acute>\"", "lemma unrest_ouvar_iuvar [unrest]:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"mwb_lens y\"\n  shows \"$x\\<acute> \\<sharp> $y\"", "lemma unrest_uop [unrest]: \"x \\<sharp> e \\<Longrightarrow> x \\<sharp> uop f e\"", "lemma unrest_bop [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> bop f u v\"", "lemma unrest_trop [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v; x \\<sharp> w \\<rbrakk> \\<Longrightarrow> x \\<sharp> trop f u v w\"", "lemma unrest_qtop [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v; x \\<sharp> w; x \\<sharp> y \\<rbrakk> \\<Longrightarrow> x \\<sharp> qtop f u v w y\"", "lemma unrest_eq [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> u =\\<^sub>u v\"", "lemma unrest_zero [unrest]: \"x \\<sharp> 0\"", "lemma unrest_one [unrest]: \"x \\<sharp> 1\"", "lemma unrest_numeral [unrest]: \"x \\<sharp> (numeral n)\"", "lemma unrest_sgn [unrest]: \"x \\<sharp> u \\<Longrightarrow> x \\<sharp> sgn u\"", "lemma unrest_abs [unrest]: \"x \\<sharp> u \\<Longrightarrow> x \\<sharp> abs u\"", "lemma unrest_plus [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> u + v\"", "lemma unrest_uminus [unrest]: \"x \\<sharp> u \\<Longrightarrow> x \\<sharp> - u\"", "lemma unrest_minus [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> u - v\"", "lemma unrest_times [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> u * v\"", "lemma unrest_divide [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> u / v\"", "lemma unrest_case_prod [unrest]: \"\\<lbrakk> \\<And> i j. x \\<sharp> P i j \\<rbrakk> \\<Longrightarrow> x \\<sharp> case_prod P v\"", "lemma unrest_ulambda [unrest]:\n  \"\\<lbrakk> \\<And> x. v \\<sharp> F x \\<rbrakk> \\<Longrightarrow> v \\<sharp> (\\<lambda> x \\<bullet> F x)\""], "translations": [["", "lemma unrest_expr_alt_def:\n  \"weak_lens x \\<Longrightarrow> (x \\<sharp> P) = (\\<forall> b b'. \\<lbrakk>P\\<rbrakk>\\<^sub>e (b \\<oplus>\\<^sub>L b' on x) = \\<lbrakk>P\\<rbrakk>\\<^sub>e b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_lens x \\<Longrightarrow>\n    (x \\<sharp> P) =\n    (\\<forall>b b'.\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (b \\<triangleleft>\\<^bsub>x\\<^esub> b') =\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e b)", "by (transfer, metis lens_override_def weak_lens.put_get)"], ["", "subsection \\<open> Unrestriction laws \\<close>"], ["", "text \\<open> We now prove unrestriction laws for the key constructs of our expression model. Many\n  of these depend on lens properties and so variously employ the assumptions @{term mwb_lens} and\n  @{term vwb_lens}, depending on the number of assumptions from the lenses theory is required.\n\n  Firstly, we prove a general property -- if $x$ and $y$ are both unrestricted in $P$, then their composition\n  is also unrestricted in $P$. One can interpret the composition here as a union -- if the two sets\n  of variables $x$ and $y$ are unrestricted, then so is their union. \\<close>"], ["", "lemma unrest_var_comp [unrest]:\n  \"\\<lbrakk> x \\<sharp> P; y \\<sharp> P \\<rbrakk> \\<Longrightarrow> x;y \\<sharp> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> P; y \\<sharp> P\\<rbrakk>\n    \\<Longrightarrow> {x, y} \\<sharp> P", "by (transfer, simp add: lens_defs)"], ["", "lemma unrest_svar [unrest]: \"(&x \\<sharp> P) \\<longleftrightarrow> (x \\<sharp> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (&x \\<sharp> P) = (x \\<sharp> P)", "by (transfer, simp add: lens_defs)"], ["", "text \\<open> No lens is restricted by a literal, since it returns the same value for any state binding. \\<close>"], ["", "lemma unrest_lit [unrest]: \"x \\<sharp> \\<guillemotleft>v\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> \\<guillemotleft>v\\<guillemotright>", "by (transfer, simp)"], ["", "text \\<open> If one lens is smaller than another, then any unrestriction on the larger lens implies\n  unrestriction on the smaller. \\<close>"], ["", "lemma unrest_sublens:\n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"x \\<sharp> P\" \"y \\<subseteq>\\<^sub>L x\"\n  shows \"y \\<sharp> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sharp> P", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> P\n  y \\<subseteq>\\<^sub>L x\n\ngoal (1 subgoal):\n 1. y \\<sharp> P", "by (transfer, metis (no_types, lifting) lens.select_convs(2) lens_comp_def sublens_def)"], ["", "text \\<open> If two lenses are equivalent, and thus they characterise the same state-space regions,\n  then clearly unrestrictions over them are equivalent. \\<close>"], ["", "lemma unrest_equiv:\n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"mwb_lens y\" \"x \\<approx>\\<^sub>L y\" \"x \\<sharp> P\"\n  shows \"y \\<sharp> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sharp> P", "by (metis assms lens_equiv_def sublens_pres_mwb sublens_put_put unrest_uexpr.rep_eq)"], ["", "text \\<open> If we can show that an expression is unrestricted on a bijective lens, then is unrestricted\n  on the entire state-space. \\<close>"], ["", "lemma bij_lens_unrest_all:\n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"bij_lens X\" \"X \\<sharp> P\"\n  shows \"\\<Sigma> \\<sharp> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> \\<sharp> P", "using assms bij_lens_equiv_id lens_equiv_def unrest_sublens"], ["proof (prove)\nusing this:\n  bij_lens X\n  X \\<sharp> P\n  bij_lens ?X = ?X \\<approx>\\<^sub>L \\<Sigma>\n  ?X \\<approx>\\<^sub>L ?Y =\n  (?X \\<subseteq>\\<^sub>L ?Y \\<and> ?Y \\<subseteq>\\<^sub>L ?X)\n  \\<lbrakk>?x \\<sharp> ?P; ?y \\<subseteq>\\<^sub>L ?x\\<rbrakk>\n  \\<Longrightarrow> ?y \\<sharp> ?P\n\ngoal (1 subgoal):\n 1. \\<Sigma> \\<sharp> P", "by blast"], ["", "lemma bij_lens_unrest_all_eq:\n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"bij_lens X\"\n  shows \"(\\<Sigma> \\<sharp> P) \\<longleftrightarrow> (X \\<sharp> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sigma> \\<sharp> P) = (X \\<sharp> P)", "by (meson assms bij_lens_equiv_id lens_equiv_def unrest_sublens)"], ["", "text \\<open> If an expression is unrestricted by all variables, then it is unrestricted by any variable \\<close>"], ["", "lemma unrest_all_var:\n  fixes e :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"\\<Sigma> \\<sharp> e\"\n  shows \"x \\<sharp> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> e", "by (metis assms id_lens_def lens.simps(2) unrest_uexpr.rep_eq)"], ["", "text \\<open> We can split an unrestriction composed by lens plus \\<close>"], ["", "lemma unrest_plus_split:\n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"x \\<bowtie> y\" \"vwb_lens x\" \"vwb_lens y\"\n  shows \"unrest (x +\\<^sub>L y) P \\<longleftrightarrow> (x \\<sharp> P) \\<and> (y \\<sharp> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({x, y} \\<sharp> P) = ((x \\<sharp> P) \\<and> (y \\<sharp> P))", "using assms"], ["proof (prove)\nusing this:\n  x \\<bowtie> y\n  vwb_lens x\n  vwb_lens y\n\ngoal (1 subgoal):\n 1. ({x, y} \\<sharp> P) = ((x \\<sharp> P) \\<and> (y \\<sharp> P))", "by (meson lens_plus_right_sublens lens_plus_ub sublens_refl unrest_sublens unrest_var_comp vwb_lens_wb)"], ["", "text \\<open> The following laws demonstrate the primary motivation for lens independence: a variable\n  expression is unrestricted by another variable only when the two variables are independent. \n  Lens independence thus effectively allows us to semantically characterise when two variables,\n  or sets of variables, are different. \\<close>"], ["", "lemma unrest_var [unrest]: \"\\<lbrakk> mwb_lens x; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> y \\<sharp> var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens x; x \\<bowtie> y\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> x", "by (transfer, auto)"], ["", "lemma unrest_iuvar [unrest]: \"\\<lbrakk> mwb_lens x; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> $y \\<sharp> $x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens x; x \\<bowtie> y\\<rbrakk>\n    \\<Longrightarrow> $y \\<sharp> $x", "by (simp add: unrest_var)"], ["", "lemma unrest_ouvar [unrest]: \"\\<lbrakk> mwb_lens x; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> $y\\<acute> \\<sharp> $x\\<acute>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens x; x \\<bowtie> y\\<rbrakk>\n    \\<Longrightarrow> $y\\<acute> \\<sharp> $x\\<acute>", "by (simp add: unrest_var)"], ["", "text \\<open> The following laws follow automatically from independence of input and output variables. \\<close>"], ["", "lemma unrest_iuvar_ouvar [unrest]:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"mwb_lens y\"\n  shows \"$x \\<sharp> $y\\<acute>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. $x \\<sharp> $y\\<acute>", "by (metis prod.collapse unrest_uexpr.rep_eq var.rep_eq var_lookup_out var_update_in)"], ["", "lemma unrest_ouvar_iuvar [unrest]:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"mwb_lens y\"\n  shows \"$x\\<acute> \\<sharp> $y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. $x\\<acute> \\<sharp> $y", "by (metis prod.collapse unrest_uexpr.rep_eq var.rep_eq var_lookup_in var_update_out)"], ["", "text \\<open> Unrestriction distributes through the various function lifting expression constructs;\n  this allows us to prove unrestrictions for the majority of the expression language. \\<close>"], ["", "lemma unrest_uop [unrest]: \"x \\<sharp> e \\<Longrightarrow> x \\<sharp> uop f e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> e \\<Longrightarrow> x \\<sharp> uop f e", "by (transfer, simp)"], ["", "lemma unrest_bop [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> bop f u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> u; x \\<sharp> v\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> bop f u v", "by (transfer, simp)"], ["", "lemma unrest_trop [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v; x \\<sharp> w \\<rbrakk> \\<Longrightarrow> x \\<sharp> trop f u v w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> u; x \\<sharp> v; x \\<sharp> w\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> trop f u v w", "by (transfer, simp)"], ["", "lemma unrest_qtop [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v; x \\<sharp> w; x \\<sharp> y \\<rbrakk> \\<Longrightarrow> x \\<sharp> qtop f u v w y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> u; x \\<sharp> v; x \\<sharp> w; x \\<sharp> y\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> qtop f u v w y", "by (transfer, simp)"], ["", "text \\<open> For convenience, we also prove unrestriction rules for the bespoke operators on equality,\n  numbers, arithmetic etc. \\<close>"], ["", "lemma unrest_eq [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> u =\\<^sub>u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> u; x \\<sharp> v\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> u =\\<^sub>u v", "by (simp add: eq_upred_def, transfer, simp)"], ["", "lemma unrest_zero [unrest]: \"x \\<sharp> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> 0", "by (simp add: unrest_lit zero_uexpr_def)"], ["", "lemma unrest_one [unrest]: \"x \\<sharp> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> 1", "by (simp add: one_uexpr_def unrest_lit)"], ["", "lemma unrest_numeral [unrest]: \"x \\<sharp> (numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> numeral n", "by (simp add: numeral_uexpr_simp unrest_lit)"], ["", "lemma unrest_sgn [unrest]: \"x \\<sharp> u \\<Longrightarrow> x \\<sharp> sgn u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> u \\<Longrightarrow> x \\<sharp> sgn u", "by (simp add: sgn_uexpr_def unrest_uop)"], ["", "lemma unrest_abs [unrest]: \"x \\<sharp> u \\<Longrightarrow> x \\<sharp> abs u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> u \\<Longrightarrow> x \\<sharp> \\<bar>u\\<bar>", "by (simp add: abs_uexpr_def unrest_uop)"], ["", "lemma unrest_plus [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> u + v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> u; x \\<sharp> v\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> u + v", "by (simp add: plus_uexpr_def unrest)"], ["", "lemma unrest_uminus [unrest]: \"x \\<sharp> u \\<Longrightarrow> x \\<sharp> - u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> u \\<Longrightarrow> x \\<sharp> - u", "by (simp add: uminus_uexpr_def unrest)"], ["", "lemma unrest_minus [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> u - v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> u; x \\<sharp> v\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> u - v", "by (simp add: minus_uexpr_def unrest)"], ["", "lemma unrest_times [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> u * v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> u; x \\<sharp> v\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> u * v", "by (simp add: times_uexpr_def unrest)"], ["", "lemma unrest_divide [unrest]: \"\\<lbrakk> x \\<sharp> u; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> u / v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> u; x \\<sharp> v\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> u / v", "by (simp add: divide_uexpr_def unrest)"], ["", "lemma unrest_case_prod [unrest]: \"\\<lbrakk> \\<And> i j. x \\<sharp> P i j \\<rbrakk> \\<Longrightarrow> x \\<sharp> case_prod P v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j. x \\<sharp> P i j) \\<Longrightarrow>\n    x \\<sharp> (case v of (x, xa) \\<Rightarrow> P x xa)", "by (simp add: prod.split_sel_asm)"], ["", "text \\<open> For a $\\lambda$-term we need to show that the characteristic function expression does\n  not restrict $v$ for any input value $x$. \\<close>"], ["", "lemma unrest_ulambda [unrest]:\n  \"\\<lbrakk> \\<And> x. v \\<sharp> F x \\<rbrakk> \\<Longrightarrow> v \\<sharp> (\\<lambda> x \\<bullet> F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. v \\<sharp> F x) \\<Longrightarrow> v \\<sharp> ulambda F", "by (transfer, simp)"], ["", "end"]]}