{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/utp/utp_pred_laws.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["lemma taut_true [simp]: \"`true`\"", "lemma taut_false [simp]: \"`false` = False\"", "lemma taut_conj: \"`A \\<and> B` = (`A` \\<and> `B`)\"", "lemma taut_conj_elim [elim!]:\n  \"\\<lbrakk> `A \\<and> B`; \\<lbrakk> `A`; `B` \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma taut_refine_impl: \"\\<lbrakk> Q \\<sqsubseteq> P; `P` \\<rbrakk> \\<Longrightarrow> `Q`\"", "lemma taut_shEx_elim: \n  \"\\<lbrakk> `(\\<^bold>\\<exists> x \\<bullet> P x)`; \\<And> x. \\<Sigma> \\<sharp> P x; \\<And> x. `P x` \\<Longrightarrow> Q  \\<rbrakk> \\<Longrightarrow> Q\"", "lemma refine_prop_intro:\n  assumes \"\\<Sigma> \\<sharp> P\" \"\\<Sigma> \\<sharp> Q\" \"`Q` \\<Longrightarrow> `P`\"\n  shows \"P \\<sqsubseteq> Q\"", "lemma taut_not: \"\\<Sigma> \\<sharp> P \\<Longrightarrow> (\\<not> `P`) = `\\<not> P`\"", "lemma taut_shAll_intro:\n  \"\\<forall> x. `P x` \\<Longrightarrow> `\\<^bold>\\<forall> x \\<bullet> P x`\"", "lemma taut_shAll_intro_2:\n  \"\\<forall> x y. `P x y` \\<Longrightarrow> `\\<^bold>\\<forall> (x, y) \\<bullet> P x y`\"", "lemma taut_impl_intro:\n  \"\\<lbrakk> \\<Sigma> \\<sharp> P; `P` \\<Longrightarrow> `Q` \\<rbrakk> \\<Longrightarrow> `P \\<Rightarrow> Q`\"", "lemma upred_eval_taut:\n  \"`P\\<lbrakk>\\<guillemotleft>b\\<guillemotright>/&\\<^bold>v\\<rbrakk>` = \\<lbrakk>P\\<rbrakk>\\<^sub>eb\"", "lemma refBy_order: \"P \\<sqsubseteq> Q = `Q \\<Rightarrow> P`\"", "lemma conj_idem [simp]: \"((P::'\\<alpha> upred) \\<and> P) = P\"", "lemma disj_idem [simp]: \"((P::'\\<alpha> upred) \\<or> P) = P\"", "lemma conj_comm: \"((P::'\\<alpha> upred) \\<and> Q) = (Q \\<and> P)\"", "lemma disj_comm: \"((P::'\\<alpha> upred) \\<or> Q) = (Q \\<or> P)\"", "lemma conj_subst: \"P = R \\<Longrightarrow> ((P::'\\<alpha> upred) \\<and> Q) = (R \\<and> Q)\"", "lemma disj_subst: \"P = R \\<Longrightarrow> ((P::'\\<alpha> upred) \\<or> Q) = (R \\<or> Q)\"", "lemma conj_assoc:\"(((P::'\\<alpha> upred) \\<and> Q) \\<and> S) = (P \\<and> (Q \\<and> S))\"", "lemma disj_assoc:\"(((P::'\\<alpha> upred) \\<or> Q) \\<or> S) = (P \\<or> (Q \\<or> S))\"", "lemma conj_disj_abs:\"((P::'\\<alpha> upred) \\<and> (P \\<or> Q)) = P\"", "lemma disj_conj_abs:\"((P::'\\<alpha> upred) \\<or> (P \\<and> Q)) = P\"", "lemma conj_disj_distr:\"((P::'\\<alpha> upred) \\<and> (Q \\<or> R)) = ((P \\<and> Q) \\<or> (P \\<and> R))\"", "lemma disj_conj_distr:\"((P::'\\<alpha> upred) \\<or> (Q \\<and> R)) = ((P \\<or> Q) \\<and> (P \\<or> R))\"", "lemma true_disj_zero [simp]:\n  \"(P \\<or> true) = true\" \"(true \\<or> P) = true\"", "lemma true_conj_zero [simp]:\n  \"(P \\<and> false) = false\" \"(false \\<and> P) = false\"", "lemma false_sup [simp]: \"false \\<sqinter> P = P\" \"P \\<sqinter> false = P\"", "lemma true_inf [simp]: \"true \\<squnion> P = P\" \"P \\<squnion> true = P\"", "lemma imp_vacuous [simp]: \"(false \\<Rightarrow> u) = true\"", "lemma imp_true [simp]: \"(p \\<Rightarrow> true) = true\"", "lemma true_imp [simp]: \"(true \\<Rightarrow> p) = p\"", "lemma impl_mp1 [simp]: \"(P \\<and> (P \\<Rightarrow> Q)) = (P \\<and> Q)\"", "lemma impl_mp2 [simp]: \"((P \\<Rightarrow> Q) \\<and> P) = (Q \\<and> P)\"", "lemma impl_adjoin: \"((P \\<Rightarrow> Q) \\<and> R) = ((P \\<and> R \\<Rightarrow> Q \\<and> R) \\<and> R)\"", "lemma impl_refine_intro:\n  \"\\<lbrakk> Q\\<^sub>1 \\<sqsubseteq> P\\<^sub>1; P\\<^sub>2 \\<sqsubseteq> (P\\<^sub>1 \\<and> Q\\<^sub>2) \\<rbrakk> \\<Longrightarrow> (P\\<^sub>1 \\<Rightarrow> P\\<^sub>2) \\<sqsubseteq> (Q\\<^sub>1 \\<Rightarrow> Q\\<^sub>2)\"", "lemma spec_refine:\n  \"Q \\<sqsubseteq> (P \\<and> R) \\<Longrightarrow> (P \\<Rightarrow> Q) \\<sqsubseteq> R\"", "lemma impl_disjI: \"\\<lbrakk> `P \\<Rightarrow> R`; `Q \\<Rightarrow> R` \\<rbrakk> \\<Longrightarrow> `(P \\<or> Q) \\<Rightarrow> R`\"", "lemma conditional_iff:\n  \"(P \\<Rightarrow> Q) = (P \\<Rightarrow> R) \\<longleftrightarrow> `P \\<Rightarrow> (Q \\<Leftrightarrow> R)`\"", "lemma p_and_not_p [simp]: \"(P \\<and> \\<not> P) = false\"", "lemma p_or_not_p [simp]: \"(P \\<or> \\<not> P) = true\"", "lemma p_imp_p [simp]: \"(P \\<Rightarrow> P) = true\"", "lemma p_iff_p [simp]: \"(P \\<Leftrightarrow> P) = true\"", "lemma p_imp_false [simp]: \"(P \\<Rightarrow> false) = (\\<not> P)\"", "lemma not_conj_deMorgans [simp]: \"(\\<not> ((P::'\\<alpha> upred) \\<and> Q)) = ((\\<not> P) \\<or> (\\<not> Q))\"", "lemma not_disj_deMorgans [simp]: \"(\\<not> ((P::'\\<alpha> upred) \\<or> Q)) = ((\\<not> P) \\<and> (\\<not> Q))\"", "lemma conj_disj_not_abs [simp]: \"((P::'\\<alpha> upred) \\<and> ((\\<not>P) \\<or> Q)) = (P \\<and> Q)\"", "lemma subsumption1:\n  \"`P \\<Rightarrow> Q` \\<Longrightarrow> (P \\<or> Q) = Q\"", "lemma subsumption2:\n  \"`Q \\<Rightarrow> P` \\<Longrightarrow> (P \\<or> Q) = P\"", "lemma neg_conj_cancel1: \"(\\<not> P \\<and> (P \\<or> Q)) = (\\<not> P \\<and> Q :: '\\<alpha> upred)\"", "lemma neg_conj_cancel2: \"(\\<not> Q \\<and> (P \\<or> Q)) = (\\<not> Q \\<and> P :: '\\<alpha> upred)\"", "lemma double_negation [simp]: \"(\\<not> \\<not> (P::'\\<alpha> upred)) = P\"", "lemma true_not_false [simp]: \"true \\<noteq> false\" \"false \\<noteq> true\"", "lemma closure_conj_distr: \"([P]\\<^sub>u \\<and> [Q]\\<^sub>u) = [P \\<and> Q]\\<^sub>u\"", "lemma closure_imp_distr: \"`[P \\<Rightarrow> Q]\\<^sub>u \\<Rightarrow> [P]\\<^sub>u \\<Rightarrow> [Q]\\<^sub>u`\"", "lemma true_iff [simp]: \"(P \\<Leftrightarrow> true) = P\"", "lemma taut_iff_eq:\n  \"`P \\<Leftrightarrow> Q` \\<longleftrightarrow> (P = Q)\"", "lemma impl_alt_def: \"(P \\<Rightarrow> Q) = (\\<not> P \\<or> Q)\"", "lemma uinf_or:\n  fixes P Q :: \"'\\<alpha> upred\"\n  shows \"(P \\<sqinter> Q) = (P \\<or> Q)\"", "lemma usup_and:\n  fixes P Q :: \"'\\<alpha> upred\"\n  shows \"(P \\<squnion> Q) = (P \\<and> Q)\"", "lemma UINF_alt_def:\n  \"(\\<Sqinter> i | A(i) \\<bullet> P(i)) = (\\<Sqinter> i \\<bullet> A(i) \\<and> P(i))\"", "lemma USUP_true [simp]: \"(\\<Squnion> P | F(P) \\<bullet> true) = true\"", "lemma UINF_mem_UNIV [simp]: \"(\\<Sqinter> x\\<in>UNIV \\<bullet> P(x)) = (\\<Sqinter> x \\<bullet> P(x))\"", "lemma USUP_mem_UNIV [simp]: \"(\\<Squnion> x\\<in>UNIV \\<bullet> P(x)) = (\\<Squnion> x \\<bullet> P(x))\"", "lemma USUP_false [simp]: \"(\\<Squnion> i \\<bullet> false) = false\"", "lemma USUP_mem_false [simp]: \"I \\<noteq> {} \\<Longrightarrow> (\\<Squnion> i\\<in>I \\<bullet> false) = false\"", "lemma USUP_where_false [simp]: \"(\\<Squnion> i | false \\<bullet> P(i)) = true\"", "lemma UINF_true [simp]: \"(\\<Sqinter> i \\<bullet> true) = true\"", "lemma UINF_ind_const [simp]: \n  \"(\\<Sqinter> i \\<bullet> P) = P\"", "lemma UINF_mem_true [simp]: \"A \\<noteq> {} \\<Longrightarrow> (\\<Sqinter> i\\<in>A \\<bullet> true) = true\"", "lemma UINF_false [simp]: \"(\\<Sqinter> i | P(i) \\<bullet> false) = false\"", "lemma UINF_where_false [simp]: \"(\\<Sqinter> i | false \\<bullet> P(i)) = false\"", "lemma UINF_cong_eq:\n  \"\\<lbrakk> \\<And> x. P\\<^sub>1(x) = P\\<^sub>2(x); \\<And> x. `P\\<^sub>1(x) \\<Rightarrow> Q\\<^sub>1(x) =\\<^sub>u Q\\<^sub>2(x)` \\<rbrakk> \\<Longrightarrow>\n        (\\<Sqinter> x | P\\<^sub>1(x) \\<bullet> Q\\<^sub>1(x)) = (\\<Sqinter> x | P\\<^sub>2(x) \\<bullet> Q\\<^sub>2(x))\"", "lemma UINF_as_Sup: \"(\\<Sqinter> P \\<in> \\<P> \\<bullet> P) = \\<Sqinter> \\<P>\"", "lemma UINF_as_Sup_collect: \"(\\<Sqinter>P\\<in>A \\<bullet> f(P)) = (\\<Sqinter>P\\<in>A. f(P))\"", "lemma UINF_as_Sup_collect': \"(\\<Sqinter>P \\<bullet> f(P)) = (\\<Sqinter>P. f(P))\"", "lemma UINF_as_Sup_image: \"(\\<Sqinter> P | \\<guillemotleft>P\\<guillemotright> \\<in>\\<^sub>u \\<guillemotleft>A\\<guillemotright> \\<bullet> f(P)) = \\<Sqinter> (f ` A)\"", "lemma USUP_as_Inf: \"(\\<Squnion> P \\<in> \\<P> \\<bullet> P) = \\<Squnion> \\<P>\"", "lemma USUP_as_Inf_collect: \"(\\<Squnion>P\\<in>A \\<bullet> f(P)) = (\\<Squnion>P\\<in>A. f(P))\"", "lemma USUP_as_Inf_collect': \"(\\<Squnion>P \\<bullet> f(P)) = (\\<Squnion>P. f(P))\"", "lemma USUP_as_Inf_image: \"(\\<Squnion> P \\<in> \\<P> \\<bullet> f(P)) = \\<Squnion> (f ` \\<P>)\"", "lemma USUP_image_eq [simp]: \"USUP (\\<lambda>i. \\<guillemotleft>i\\<guillemotright> \\<in>\\<^sub>u \\<guillemotleft>f ` A\\<guillemotright>) g = (\\<Squnion> i\\<in>A \\<bullet> g(f(i)))\"", "lemma UINF_image_eq [simp]: \"UINF (\\<lambda>i. \\<guillemotleft>i\\<guillemotright> \\<in>\\<^sub>u \\<guillemotleft>f ` A\\<guillemotright>) g = (\\<Sqinter> i\\<in>A \\<bullet> g(f(i)))\"", "lemma subst_continuous [usubst]: \"\\<sigma> \\<dagger> (\\<Sqinter> A) = (\\<Sqinter> {\\<sigma> \\<dagger> P | P. P \\<in> A})\"", "lemma not_UINF: \"(\\<not> (\\<Sqinter> i\\<in>A\\<bullet> P(i))) = (\\<Squnion> i\\<in>A\\<bullet> \\<not> P(i))\"", "lemma not_USUP: \"(\\<not> (\\<Squnion> i\\<in>A\\<bullet> P(i))) = (\\<Sqinter> i\\<in>A\\<bullet> \\<not> P(i))\"", "lemma not_UINF_ind: \"(\\<not> (\\<Sqinter> i \\<bullet> P(i))) = (\\<Squnion> i \\<bullet> \\<not> P(i))\"", "lemma not_USUP_ind: \"(\\<not> (\\<Squnion> i \\<bullet> P(i))) = (\\<Sqinter> i \\<bullet> \\<not> P(i))\"", "lemma UINF_empty [simp]: \"(\\<Sqinter> i \\<in> {} \\<bullet> P(i)) = false\"", "lemma UINF_insert [simp]: \"(\\<Sqinter> i\\<in>insert x xs \\<bullet> P(i)) = (P(x) \\<sqinter> (\\<Sqinter> i\\<in>xs \\<bullet> P(i)))\"", "lemma UINF_atLeast_first:\n  \"P(n) \\<sqinter> (\\<Sqinter> i \\<in> {Suc n..} \\<bullet> P(i)) = (\\<Sqinter> i \\<in> {n..} \\<bullet> P(i))\"", "lemma UINF_atLeast_Suc:\n  \"(\\<Sqinter> i \\<in> {Suc m..} \\<bullet> P(i)) = (\\<Sqinter> i \\<in> {m..} \\<bullet> P(Suc i))\"", "lemma USUP_empty [simp]: \"(\\<Squnion> i \\<in> {} \\<bullet> P(i)) = true\"", "lemma USUP_insert [simp]: \"(\\<Squnion> i\\<in>insert x xs \\<bullet> P(i)) = (P(x) \\<squnion> (\\<Squnion> i\\<in>xs \\<bullet> P(i)))\"", "lemma USUP_atLeast_first:\n  \"(P(n) \\<and> (\\<Squnion> i \\<in> {Suc n..} \\<bullet> P(i))) = (\\<Squnion> i \\<in> {n..} \\<bullet> P(i))\"", "lemma USUP_atLeast_Suc:\n  \"(\\<Squnion> i \\<in> {Suc m..} \\<bullet> P(i)) = (\\<Squnion> i \\<in> {m..} \\<bullet> P(Suc i))\"", "lemma conj_UINF_dist:\n  \"(P \\<and> (\\<Sqinter> Q\\<in>S \\<bullet> F(Q))) = (\\<Sqinter> Q\\<in>S \\<bullet> P \\<and> F(Q))\"", "lemma conj_UINF_ind_dist:\n  \"(P \\<and> (\\<Sqinter> Q \\<bullet> F(Q))) = (\\<Sqinter> Q \\<bullet> P \\<and> F(Q))\"", "lemma disj_UINF_dist:\n  \"S \\<noteq> {} \\<Longrightarrow> (P \\<or> (\\<Sqinter> Q\\<in>S \\<bullet> F(Q))) = (\\<Sqinter> Q\\<in>S \\<bullet> P \\<or> F(Q))\"", "lemma UINF_conj_UINF [simp]: \n  \"((\\<Sqinter> i\\<in>I \\<bullet> P(i)) \\<or> (\\<Sqinter> i\\<in>I \\<bullet> Q(i))) = (\\<Sqinter> i\\<in>I \\<bullet> P(i) \\<or> Q(i))\"", "lemma conj_USUP_dist:\n  \"S \\<noteq> {} \\<Longrightarrow> (P \\<and> (\\<Squnion> Q\\<in>S \\<bullet> F(Q))) = (\\<Squnion> Q\\<in>S \\<bullet> P \\<and> F(Q))\"", "lemma USUP_conj_USUP [simp]: \"((\\<Squnion> P \\<in> A \\<bullet> F(P)) \\<and> (\\<Squnion> P \\<in> A \\<bullet> G(P))) = (\\<Squnion> P \\<in> A \\<bullet> F(P) \\<and> G(P))\"", "lemma UINF_all_cong [cong]:\n  assumes \"\\<And> P. F(P) = G(P)\"\n  shows \"(\\<Sqinter> P \\<bullet> F(P)) = (\\<Sqinter> P \\<bullet> G(P))\"", "lemma UINF_cong:\n  assumes \"\\<And> P. P \\<in> A \\<Longrightarrow> F(P) = G(P)\"\n  shows \"(\\<Sqinter> P\\<in>A \\<bullet> F(P)) = (\\<Sqinter> P\\<in>A \\<bullet> G(P))\"", "lemma USUP_all_cong:\n  assumes \"\\<And> P. F(P) = G(P)\"\n  shows \"(\\<Squnion> P \\<bullet> F(P)) = (\\<Squnion> P \\<bullet> G(P))\"", "lemma USUP_cong:\n  assumes \"\\<And> P. P \\<in> A \\<Longrightarrow> F(P) = G(P)\"\n  shows \"(\\<Squnion> P\\<in>A \\<bullet> F(P)) = (\\<Squnion> P\\<in>A \\<bullet> G(P))\"", "lemma UINF_subset_mono: \"A \\<subseteq> B \\<Longrightarrow> (\\<Sqinter> P\\<in>B \\<bullet> F(P)) \\<sqsubseteq> (\\<Sqinter> P\\<in>A \\<bullet> F(P))\"", "lemma USUP_subset_mono: \"A \\<subseteq> B \\<Longrightarrow> (\\<Squnion> P\\<in>A \\<bullet> F(P)) \\<sqsubseteq> (\\<Squnion> P\\<in>B \\<bullet> F(P))\"", "lemma UINF_impl: \"(\\<Sqinter> P\\<in>A \\<bullet> F(P) \\<Rightarrow> G(P)) = ((\\<Squnion> P\\<in>A \\<bullet> F(P)) \\<Rightarrow> (\\<Sqinter> P\\<in>A \\<bullet> G(P)))\"", "lemma USUP_is_forall: \"(\\<Squnion> x \\<bullet> P(x)) = (\\<^bold>\\<forall> x \\<bullet> P(x))\"", "lemma USUP_ind_is_forall: \"(\\<Squnion> x\\<in>A \\<bullet> P(x)) = (\\<^bold>\\<forall> x\\<in>\\<guillemotleft>A\\<guillemotright> \\<bullet> P(x))\"", "lemma UINF_is_exists: \"(\\<Sqinter> x \\<bullet> P(x)) = (\\<^bold>\\<exists> x \\<bullet> P(x))\"", "lemma UINF_all_nats [simp]:\n  fixes P :: \"nat \\<Rightarrow> '\\<alpha> upred\"\n  shows \"(\\<Sqinter> n \\<bullet> \\<Sqinter> i\\<in>{0..n} \\<bullet> P(i)) = (\\<Sqinter> n \\<bullet> P(n))\"", "lemma USUP_all_nats [simp]:\n  fixes P :: \"nat \\<Rightarrow> '\\<alpha> upred\"\n  shows \"(\\<Squnion> n \\<bullet> \\<Squnion> i\\<in>{0..n} \\<bullet> P(i)) = (\\<Squnion> n \\<bullet> P(n))\"", "lemma UINF_upto_expand_first:\n  \"m < n \\<Longrightarrow> (\\<Sqinter> i \\<in> {m..<n} \\<bullet> P(i)) = ((P(m) :: '\\<alpha> upred) \\<or> (\\<Sqinter> i \\<in> {Suc m..<n} \\<bullet> P(i)))\"", "lemma UINF_upto_expand_last:\n  \"(\\<Sqinter> i \\<in> {0..<Suc(n)} \\<bullet> P(i)) = ((\\<Sqinter> i \\<in> {0..<n} \\<bullet> P(i)) \\<or> P(n))\"", "lemma UINF_Suc_shift: \"(\\<Sqinter> i \\<in> {Suc 0..<Suc n} \\<bullet> P(i)) = (\\<Sqinter> i \\<in> {0..<n} \\<bullet> P(Suc i))\"", "lemma USUP_upto_expand_first:\n  \"(\\<Squnion> i \\<in> {0..<Suc(n)} \\<bullet> P(i)) = (P(0) \\<and> (\\<Squnion> i \\<in> {1..<Suc(n)} \\<bullet> P(i)))\"", "lemma USUP_Suc_shift: \"(\\<Squnion> i \\<in> {Suc 0..<Suc n} \\<bullet> P(i)) = (\\<Squnion> i \\<in> {0..<n} \\<bullet> P(Suc i))\"", "lemma UINF_list_conv:\n  \"(\\<Sqinter> i \\<in> {0..<length(xs)} \\<bullet> f (xs ! i)) = foldr (\\<or>) (map f xs) false\"", "lemma USUP_list_conv:\n  \"(\\<Squnion> i \\<in> {0..<length(xs)} \\<bullet> f (xs ! i)) = foldr (\\<and>) (map f xs) true\"", "lemma UINF_refines:\n  \"\\<lbrakk> \\<And> i. i\\<in>I \\<Longrightarrow> P \\<sqsubseteq> Q i \\<rbrakk> \\<Longrightarrow> P \\<sqsubseteq> (\\<Sqinter> i\\<in>I \\<bullet> Q i)\"", "lemma UINF_refines':\n  assumes \"\\<And> i. P \\<sqsubseteq> Q(i)\" \n  shows \"P \\<sqsubseteq> (\\<Sqinter> i \\<bullet> Q(i))\"", "lemma UINF_pred_ueq [simp]: \n  \"(\\<Sqinter> x | \\<guillemotleft>x\\<guillemotright> =\\<^sub>u v \\<bullet> P(x)) = (P x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk>\"", "lemma UINF_pred_lit_eq [simp]: \n  \"(\\<Sqinter> x | \\<guillemotleft>x = v\\<guillemotright> \\<bullet> P(x)) = (P v)\"", "lemma eq_upred_refl [simp]: \"(x =\\<^sub>u x) = true\"", "lemma eq_upred_sym: \"(x =\\<^sub>u y) = (y =\\<^sub>u x)\"", "lemma eq_cong_left:\n  assumes \"vwb_lens x\" \"$x \\<sharp> Q\" \"$x\\<acute> \\<sharp> Q\" \"$x \\<sharp> R\" \"$x\\<acute> \\<sharp> R\"\n  shows \"(($x\\<acute> =\\<^sub>u $x \\<and> Q) = ($x\\<acute> =\\<^sub>u $x \\<and> R)) \\<longleftrightarrow> (Q = R)\"", "lemma conj_eq_in_var_subst:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"vwb_lens x\"\n  shows \"(P \\<and> $x =\\<^sub>u v) = (P\\<lbrakk>v/$x\\<rbrakk> \\<and> $x =\\<^sub>u v)\"", "lemma conj_eq_out_var_subst:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"vwb_lens x\"\n  shows \"(P \\<and> $x\\<acute> =\\<^sub>u v) = (P\\<lbrakk>v/$x\\<acute>\\<rbrakk> \\<and> $x\\<acute> =\\<^sub>u v)\"", "lemma conj_pos_var_subst:\n  assumes \"vwb_lens x\"\n  shows \"($x \\<and> Q) = ($x \\<and> Q\\<lbrakk>true/$x\\<rbrakk>)\"", "lemma conj_neg_var_subst:\n  assumes \"vwb_lens x\"\n  shows \"(\\<not> $x \\<and> Q) = (\\<not> $x \\<and> Q\\<lbrakk>false/$x\\<rbrakk>)\"", "lemma upred_eq_true [simp]: \"(p =\\<^sub>u true) = p\"", "lemma upred_eq_false [simp]: \"(p =\\<^sub>u false) = (\\<not> p)\"", "lemma upred_true_eq [simp]: \"(true =\\<^sub>u p) = p\"", "lemma upred_false_eq [simp]: \"(false =\\<^sub>u p) = (\\<not> p)\"", "lemma conj_var_subst:\n  assumes \"vwb_lens x\"\n  shows \"(P \\<and> var x =\\<^sub>u v) = (P\\<lbrakk>v/x\\<rbrakk> \\<and> var x =\\<^sub>u v)\"", "lemma shEx_unbound [simp]: \"(\\<^bold>\\<exists> x \\<bullet> P) = P\"", "lemma shEx_bool [simp]: \"shEx P = (P True \\<or> P False)\"", "lemma shEx_commute: \"(\\<^bold>\\<exists> x \\<bullet> \\<^bold>\\<exists> y \\<bullet> P x y) = (\\<^bold>\\<exists> y \\<bullet> \\<^bold>\\<exists> x \\<bullet> P x y)\"", "lemma shEx_cong: \"\\<lbrakk> \\<And> x. P x = Q x \\<rbrakk> \\<Longrightarrow> shEx P = shEx Q\"", "lemma shEx_insert: \"(\\<^bold>\\<exists> x \\<in> insert\\<^sub>u y A \\<bullet> P(x)) = (P(x)\\<lbrakk>x\\<rightarrow>y\\<rbrakk> \\<or> (\\<^bold>\\<exists> x \\<in> A \\<bullet> P(x)))\"", "lemma shEx_one_point: \"(\\<^bold>\\<exists> x \\<bullet> \\<guillemotleft>x\\<guillemotright> =\\<^sub>u v \\<and> P(x)) = P(x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk>\"", "lemma shAll_unbound [simp]: \"(\\<^bold>\\<forall> x \\<bullet> P) = P\"", "lemma shAll_bool [simp]: \"shAll P = (P True \\<and> P False)\"", "lemma shAll_cong: \"\\<lbrakk> \\<And> x. P x = Q x \\<rbrakk> \\<Longrightarrow> shAll P = shAll Q\"", "lemma shEx_lift_conj_1 [uquant_lift]:\n  \"((\\<^bold>\\<exists> x \\<bullet> P(x)) \\<and> Q) = (\\<^bold>\\<exists> x \\<bullet> P(x) \\<and> Q)\"", "lemma shEx_lift_conj_2 [uquant_lift]:\n  \"(P \\<and> (\\<^bold>\\<exists> x \\<bullet> Q(x))) = (\\<^bold>\\<exists> x \\<bullet> P \\<and> Q(x))\"", "lemma eq_split_subst:\n  assumes \"vwb_lens x\"\n  shows \"(P = Q) \\<longleftrightarrow> (\\<forall> v. P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk> = Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>)\"", "lemma eq_split_substI:\n  assumes \"vwb_lens x\" \"\\<And> v. P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk> = Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>\"\n  shows \"P = Q\"", "lemma taut_split_subst:\n  assumes \"vwb_lens x\"\n  shows \"`P` \\<longleftrightarrow> (\\<forall> v. `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`)\"", "lemma eq_split:\n  assumes \"`P \\<Rightarrow> Q`\" \"`Q \\<Rightarrow> P`\"\n  shows \"P = Q\"", "lemma bool_eq_splitI:\n  assumes \"vwb_lens x\" \"P\\<lbrakk>true/x\\<rbrakk> = Q\\<lbrakk>true/x\\<rbrakk>\" \"P\\<lbrakk>false/x\\<rbrakk> = Q\\<lbrakk>false/x\\<rbrakk>\"\n  shows \"P = Q\"", "lemma subst_bool_split:\n  assumes \"vwb_lens x\"\n  shows \"`P` = `(P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>)`\"", "lemma subst_eq_replace:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"(p\\<lbrakk>u/x\\<rbrakk> \\<and> u =\\<^sub>u v) = (p\\<lbrakk>v/x\\<rbrakk> \\<and> u =\\<^sub>u v)\"", "lemma one_point:\n  assumes \"mwb_lens x\" \"x \\<sharp> v\"\n  shows \"(\\<exists> x \\<bullet> P \\<and> var x =\\<^sub>u v) = P\\<lbrakk>v/x\\<rbrakk>\"", "lemma exists_twice: \"mwb_lens x \\<Longrightarrow> (\\<exists> x \\<bullet> \\<exists> x \\<bullet> P) = (\\<exists> x \\<bullet> P)\"", "lemma all_twice: \"mwb_lens x \\<Longrightarrow> (\\<forall> x \\<bullet> \\<forall> x \\<bullet> P) = (\\<forall> x \\<bullet> P)\"", "lemma exists_sub: \"\\<lbrakk> mwb_lens y; x \\<subseteq>\\<^sub>L y \\<rbrakk> \\<Longrightarrow> (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) = (\\<exists> y \\<bullet> P)\"", "lemma all_sub: \"\\<lbrakk> mwb_lens y; x \\<subseteq>\\<^sub>L y \\<rbrakk> \\<Longrightarrow> (\\<forall> x \\<bullet> \\<forall> y \\<bullet> P) = (\\<forall> y \\<bullet> P)\"", "lemma ex_commute:\n  assumes \"x \\<bowtie> y\"\n  shows \"(\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) = (\\<exists> y \\<bullet> \\<exists> x \\<bullet> P)\"", "lemma all_commute:\n  assumes \"x \\<bowtie> y\"\n  shows \"(\\<forall> x \\<bullet> \\<forall> y \\<bullet> P) = (\\<forall> y \\<bullet> \\<forall> x \\<bullet> P)\"", "lemma ex_equiv:\n  assumes \"x \\<approx>\\<^sub>L y\"\n  shows \"(\\<exists> x \\<bullet> P) = (\\<exists> y \\<bullet> P)\"", "lemma all_equiv:\n  assumes \"x \\<approx>\\<^sub>L y\"\n  shows \"(\\<forall> x \\<bullet> P) = (\\<forall> y \\<bullet> P)\"", "lemma ex_zero:\n  \"(\\<exists> \\<emptyset> \\<bullet> P) = P\"", "lemma all_zero:\n  \"(\\<forall> \\<emptyset> \\<bullet> P) = P\"", "lemma ex_plus:\n  \"(\\<exists> y;x \\<bullet> P) = (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P)\"", "lemma all_plus:\n  \"(\\<forall> y;x \\<bullet> P) = (\\<forall> x \\<bullet> \\<forall> y \\<bullet> P)\"", "lemma closure_all:\n  \"[P]\\<^sub>u = (\\<forall> \\<Sigma> \\<bullet> P)\"", "lemma unrest_as_exists:\n  \"vwb_lens x \\<Longrightarrow> (x \\<sharp> P) \\<longleftrightarrow> ((\\<exists> x \\<bullet> P) = P)\"", "lemma ex_mono: \"P \\<sqsubseteq> Q \\<Longrightarrow> (\\<exists> x \\<bullet> P) \\<sqsubseteq> (\\<exists> x \\<bullet> Q)\"", "lemma ex_weakens: \"wb_lens x \\<Longrightarrow> (\\<exists> x \\<bullet> P) \\<sqsubseteq> P\"", "lemma all_mono: \"P \\<sqsubseteq> Q \\<Longrightarrow> (\\<forall> x \\<bullet> P) \\<sqsubseteq> (\\<forall> x \\<bullet> Q)\"", "lemma all_strengthens: \"wb_lens x \\<Longrightarrow> P \\<sqsubseteq> (\\<forall> x \\<bullet> P)\"", "lemma ex_unrest: \"x \\<sharp> P \\<Longrightarrow> (\\<exists> x \\<bullet> P) = P\"", "lemma all_unrest: \"x \\<sharp> P \\<Longrightarrow> (\\<forall> x \\<bullet> P) = P\"", "lemma not_ex_not: \"\\<not> (\\<exists> x \\<bullet> \\<not> P) = (\\<forall> x \\<bullet> P)\"", "lemma not_all_not: \"\\<not> (\\<forall> x \\<bullet> \\<not> P) = (\\<exists> x \\<bullet> P)\"", "lemma ex_conj_contr_left: \"x \\<sharp> P \\<Longrightarrow> (\\<exists> x \\<bullet> P \\<and> Q) = (P \\<and> (\\<exists> x \\<bullet> Q))\"", "lemma ex_conj_contr_right: \"x \\<sharp> Q \\<Longrightarrow> (\\<exists> x \\<bullet> P \\<and> Q) = ((\\<exists> x \\<bullet> P) \\<and> Q)\"", "lemma var_res_all: \n  \"P \\<restriction>\\<^sub>v \\<Sigma> = P\"", "lemma var_res_twice: \n  \"mwb_lens x \\<Longrightarrow> P \\<restriction>\\<^sub>v x \\<restriction>\\<^sub>v x = P \\<restriction>\\<^sub>v x\"", "lemma cond_def:\n  \"(P \\<triangleleft> b \\<triangleright> Q) = ((b \\<and> P) \\<or> ((\\<not> b) \\<and> Q))\"", "lemma cond_idem [simp]:\"(P \\<triangleleft> b \\<triangleright> P) = P\"", "lemma cond_true_false [simp]: \"true \\<triangleleft> b \\<triangleright> false = b\"", "lemma cond_symm:\"(P \\<triangleleft> b \\<triangleright> Q) = (Q \\<triangleleft> \\<not> b \\<triangleright> P)\"", "lemma cond_assoc: \"((P \\<triangleleft> b \\<triangleright> Q) \\<triangleleft> c \\<triangleright> R) = (P \\<triangleleft> b \\<and> c \\<triangleright> (Q \\<triangleleft> c \\<triangleright> R))\"", "lemma cond_distr: \"(P \\<triangleleft> b \\<triangleright> (Q \\<triangleleft> c \\<triangleright> R)) = ((P \\<triangleleft> b \\<triangleright> Q) \\<triangleleft> c \\<triangleright> (P \\<triangleleft> b \\<triangleright> R))\"", "lemma cond_unit_T [simp]:\"(P \\<triangleleft> true \\<triangleright> Q) = P\"", "lemma cond_unit_F [simp]:\"(P \\<triangleleft> false \\<triangleright> Q) = Q\"", "lemma cond_conj_not: \"((P \\<triangleleft> b \\<triangleright> Q) \\<and> (\\<not> b)) = (Q \\<and> (\\<not> b))\"", "lemma cond_and_T_integrate:\n  \"((P \\<and> b) \\<or> (Q \\<triangleleft> b \\<triangleright> R)) = ((P \\<or> Q) \\<triangleleft> b \\<triangleright> R)\"", "lemma cond_L6: \"(P \\<triangleleft> b \\<triangleright> (Q \\<triangleleft> b \\<triangleright> R)) = (P \\<triangleleft> b \\<triangleright> R)\"", "lemma cond_L7: \"(P \\<triangleleft> b \\<triangleright> (P \\<triangleleft> c \\<triangleright> Q)) = (P \\<triangleleft> b \\<or> c \\<triangleright> Q)\"", "lemma cond_and_distr: \"((P \\<and> Q) \\<triangleleft> b \\<triangleright> (R \\<and> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<and> (Q \\<triangleleft> b \\<triangleright> S))\"", "lemma cond_or_distr: \"((P \\<or> Q) \\<triangleleft> b \\<triangleright> (R \\<or> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<or> (Q \\<triangleleft> b \\<triangleright> S))\"", "lemma cond_imp_distr:\n\"((P \\<Rightarrow> Q) \\<triangleleft> b \\<triangleright> (R \\<Rightarrow> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<Rightarrow> (Q \\<triangleleft> b \\<triangleright> S))\"", "lemma cond_eq_distr:\n\"((P \\<Leftrightarrow> Q) \\<triangleleft> b \\<triangleright> (R \\<Leftrightarrow> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<Leftrightarrow> (Q \\<triangleleft> b \\<triangleright> S))\"", "lemma cond_conj_distr:\"(P \\<and> (Q \\<triangleleft> b \\<triangleright> S)) = ((P \\<and> Q) \\<triangleleft> b \\<triangleright> (P \\<and> S))\"", "lemma cond_disj_distr:\"(P \\<or> (Q \\<triangleleft> b \\<triangleright> S)) = ((P \\<or> Q) \\<triangleleft> b \\<triangleright> (P \\<or> S))\"", "lemma cond_neg: \"\\<not> (P \\<triangleleft> b \\<triangleright> Q) = ((\\<not> P) \\<triangleleft> b \\<triangleright> (\\<not> Q))\"", "lemma cond_conj: \"P \\<triangleleft> b \\<and> c \\<triangleright> Q = (P \\<triangleleft> c \\<triangleright> Q) \\<triangleleft> b \\<triangleright> Q\"", "lemma spec_cond_dist: \"(P \\<Rightarrow> (Q \\<triangleleft> b \\<triangleright> R)) = ((P \\<Rightarrow> Q) \\<triangleleft> b \\<triangleright> (P \\<Rightarrow> R))\"", "lemma cond_USUP_dist: \"(\\<Squnion> P\\<in>S \\<bullet> F(P)) \\<triangleleft> b \\<triangleright> (\\<Squnion> P\\<in>S \\<bullet> G(P)) = (\\<Squnion> P\\<in>S \\<bullet> F(P) \\<triangleleft> b \\<triangleright> G(P))\"", "lemma cond_UINF_dist: \"(\\<Sqinter> P\\<in>S \\<bullet> F(P)) \\<triangleleft> b \\<triangleright> (\\<Sqinter> P\\<in>S \\<bullet> G(P)) = (\\<Sqinter> P\\<in>S \\<bullet> F(P) \\<triangleleft> b \\<triangleright> G(P))\"", "lemma cond_var_subst_left:\n  assumes \"vwb_lens x\"\n  shows \"(P\\<lbrakk>true/x\\<rbrakk> \\<triangleleft> var x \\<triangleright> Q) = (P \\<triangleleft> var x \\<triangleright> Q)\"", "lemma cond_var_subst_right:\n  assumes \"vwb_lens x\"\n  shows \"(P \\<triangleleft> var x \\<triangleright> Q\\<lbrakk>false/x\\<rbrakk>) = (P \\<triangleleft> var x \\<triangleright> Q)\"", "lemma cond_var_split:\n  \"vwb_lens x \\<Longrightarrow> (P\\<lbrakk>true/x\\<rbrakk> \\<triangleleft> var x \\<triangleright> P\\<lbrakk>false/x\\<rbrakk>) = P\"", "lemma cond_assign_subst:\n  \"vwb_lens x \\<Longrightarrow> (P \\<triangleleft> utp_expr.var x =\\<^sub>u v \\<triangleright> Q) = (P\\<lbrakk>v/x\\<rbrakk> \\<triangleleft> utp_expr.var x =\\<^sub>u v \\<triangleright> Q)\"", "lemma conj_conds: \n  \"(P1 \\<triangleleft> b \\<triangleright> Q1 \\<and> P2 \\<triangleleft> b \\<triangleright> Q2) = (P1 \\<and> P2) \\<triangleleft> b \\<triangleright> (Q1 \\<and> Q2)\"", "lemma disj_conds:\n  \"(P1 \\<triangleleft> b \\<triangleright> Q1 \\<or> P2 \\<triangleleft> b \\<triangleright> Q2) = (P1 \\<or> P2) \\<triangleleft> b \\<triangleright> (Q1 \\<or> Q2)\"", "lemma cond_mono:\n  \"\\<lbrakk> P\\<^sub>1 \\<sqsubseteq> P\\<^sub>2; Q\\<^sub>1 \\<sqsubseteq> Q\\<^sub>2 \\<rbrakk> \\<Longrightarrow> (P\\<^sub>1 \\<triangleleft> b \\<triangleright> Q\\<^sub>1) \\<sqsubseteq> (P\\<^sub>2 \\<triangleleft> b \\<triangleright> Q\\<^sub>2)\"", "lemma cond_monotonic:\n  \"\\<lbrakk> mono P; mono Q \\<rbrakk> \\<Longrightarrow> mono (\\<lambda> X. P X \\<triangleleft> b \\<triangleright> Q X)\"", "lemma le_pred_refl [simp]:\n  fixes x :: \"('a::preorder, '\\<alpha>) uexpr\"\n  shows \"(x \\<le>\\<^sub>u x) = true\"", "lemma uzero_le_laws [simp]:\n  \"(0 :: ('a::{linordered_semidom}, '\\<alpha>) uexpr) \\<le>\\<^sub>u numeral x = true\"\n  \"(1 :: ('a::{linordered_semidom}, '\\<alpha>) uexpr) \\<le>\\<^sub>u numeral x = true\"\n  \"(0 :: ('a::{linordered_semidom}, '\\<alpha>) uexpr) \\<le>\\<^sub>u 1 = true\"", "lemma unumeral_le_1 [simp]:\n  assumes \"(numeral i :: 'a::{numeral,ord}) \\<le> numeral j\"\n  shows \"(numeral i :: ('a, '\\<alpha>) uexpr) \\<le>\\<^sub>u numeral j = true\"", "lemma unumeral_le_2 [simp]:\n  assumes \"(numeral i :: 'a::{numeral,linorder}) > numeral j\"\n  shows \"(numeral i :: ('a, '\\<alpha>) uexpr) \\<le>\\<^sub>u numeral j = false\"", "lemma uset_laws [simp]:\n  \"x \\<in>\\<^sub>u {}\\<^sub>u = false\"\n  \"x \\<in>\\<^sub>u {m..n}\\<^sub>u = (m \\<le>\\<^sub>u x \\<and> x \\<le>\\<^sub>u n)\"", "lemma ulit_eq [simp]: \"x = y \\<Longrightarrow> (\\<guillemotleft>x\\<guillemotright> =\\<^sub>u \\<guillemotleft>y\\<guillemotright>) = true\"", "lemma ulit_neq [simp]: \"x \\<noteq> y \\<Longrightarrow> (\\<guillemotleft>x\\<guillemotright> =\\<^sub>u \\<guillemotleft>y\\<guillemotright>) = false\"", "lemma uset_mems [simp]:\n  \"x \\<in>\\<^sub>u {y}\\<^sub>u = (x =\\<^sub>u y)\"\n  \"x \\<in>\\<^sub>u A \\<union>\\<^sub>u B = (x \\<in>\\<^sub>u A \\<or> x \\<in>\\<^sub>u B)\"\n  \"x \\<in>\\<^sub>u A \\<inter>\\<^sub>u B = (x \\<in>\\<^sub>u A \\<and> x \\<in>\\<^sub>u B)\"", "lemma obs_upred_refine_iff: \n  \"P \\<sqsubseteq> Q \\<longleftrightarrow> \\<lbrakk>Q\\<rbrakk>\\<^sub>o \\<subseteq> \\<lbrakk>P\\<rbrakk>\\<^sub>o\"", "lemma refine_by_obs:\n  assumes \"x \\<bowtie> y\" \"bij_lens (x +\\<^sub>L y)\" \"y \\<sharp> P\" \"y \\<sharp> Q\" \"{v. `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`} \\<subseteq> {v. `Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`}\"\n  shows \"Q \\<sqsubseteq> P\"", "lemma C1: \"(\\<exists> x \\<bullet> false) = false\"", "lemma C2: \"wb_lens x \\<Longrightarrow> `P \\<Rightarrow> (\\<exists> x \\<bullet> P)`\"", "lemma C3: \"mwb_lens x \\<Longrightarrow> (\\<exists> x \\<bullet> (P \\<and> (\\<exists> x \\<bullet> Q))) = ((\\<exists> x \\<bullet> P) \\<and> (\\<exists> x \\<bullet> Q))\"", "lemma C4a: \"x \\<approx>\\<^sub>L y \\<Longrightarrow> (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) = (\\<exists> y \\<bullet> \\<exists> x \\<bullet> P)\"", "lemma C4b: \"x \\<bowtie> y \\<Longrightarrow> (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) = (\\<exists> y \\<bullet> \\<exists> x \\<bullet> P)\"", "lemma C5:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"(&x =\\<^sub>u &x) = true\"", "lemma C6:\n  assumes \"wb_lens x\" \"x \\<bowtie> y\" \"x \\<bowtie> z\"\n  shows \"(&y =\\<^sub>u &z) = (\\<exists> x \\<bullet> &y =\\<^sub>u &x \\<and> &x =\\<^sub>u &z)\"", "lemma C7:\n  assumes \"weak_lens x\" \"x \\<bowtie> y\"\n  shows \"((\\<exists> x \\<bullet> &x =\\<^sub>u &y \\<and> P) \\<and> (\\<exists> x \\<bullet> &x =\\<^sub>u &y \\<and> \\<not> P)) = false\""], "translations": [["", "lemma taut_true [simp]: \"`true`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. `true`", "by (pred_auto)"], ["", "lemma taut_false [simp]: \"`false` = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. `false` = False", "by (pred_auto)"], ["", "lemma taut_conj: \"`A \\<and> B` = (`A` \\<and> `B`)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. `A \\<and> B` = (`A` \\<and> `B`)", "by (rel_auto)"], ["", "lemma taut_conj_elim [elim!]:\n  \"\\<lbrakk> `A \\<and> B`; \\<lbrakk> `A`; `B` \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>`A \\<and> B`;\n     \\<lbrakk>`A`; `B`\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (rel_auto)"], ["", "lemma taut_refine_impl: \"\\<lbrakk> Q \\<sqsubseteq> P; `P` \\<rbrakk> \\<Longrightarrow> `Q`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q \\<sqsubseteq> P; `P`\\<rbrakk> \\<Longrightarrow> `Q`", "by (rel_auto)"], ["", "lemma taut_shEx_elim: \n  \"\\<lbrakk> `(\\<^bold>\\<exists> x \\<bullet> P x)`; \\<And> x. \\<Sigma> \\<sharp> P x; \\<And> x. `P x` \\<Longrightarrow> Q  \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>`ushEx P`; \\<And>x. \\<Sigma> \\<sharp> P x;\n     \\<And>x. `P x` \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by (rel_blast)"], ["", "text \\<open> Linking refinement and HOL implication \\<close>"], ["", "lemma refine_prop_intro:\n  assumes \"\\<Sigma> \\<sharp> P\" \"\\<Sigma> \\<sharp> Q\" \"`Q` \\<Longrightarrow> `P`\"\n  shows \"P \\<sqsubseteq> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> Q", "using assms"], ["proof (prove)\nusing this:\n  \\<Sigma> \\<sharp> P\n  \\<Sigma> \\<sharp> Q\n  `Q` \\<Longrightarrow> `P`\n\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> Q", "by (pred_auto)"], ["", "lemma taut_not: \"\\<Sigma> \\<sharp> P \\<Longrightarrow> (\\<not> `P`) = `\\<not> P`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> \\<sharp> P \\<Longrightarrow> (\\<not> `P`) = `\\<not> P`", "by (rel_auto)"], ["", "lemma taut_shAll_intro:\n  \"\\<forall> x. `P x` \\<Longrightarrow> `\\<^bold>\\<forall> x \\<bullet> P x`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. `P x` \\<Longrightarrow> `ushAll P`", "by (rel_auto)"], ["", "lemma taut_shAll_intro_2:\n  \"\\<forall> x y. `P x y` \\<Longrightarrow> `\\<^bold>\\<forall> (x, y) \\<bullet> P x y`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. `P x y` \\<Longrightarrow>\n    `\\<^bold>\\<forall> (x, y) \\<bullet> P x y`", "by (rel_auto)"], ["", "lemma taut_impl_intro:\n  \"\\<lbrakk> \\<Sigma> \\<sharp> P; `P` \\<Longrightarrow> `Q` \\<rbrakk> \\<Longrightarrow> `P \\<Rightarrow> Q`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Sigma> \\<sharp> P; `P` \\<Longrightarrow> `Q`\\<rbrakk>\n    \\<Longrightarrow> `P \\<Rightarrow> Q`", "by (rel_auto)"], ["", "lemma upred_eval_taut:\n  \"`P\\<lbrakk>\\<guillemotleft>b\\<guillemotright>/&\\<^bold>v\\<rbrakk>` = \\<lbrakk>P\\<rbrakk>\\<^sub>eb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. `P\\<lbrakk>\\<guillemotleft>b\\<guillemotright>/&\\<^bold>v\\<rbrakk>` =\n    \\<lbrakk>P\\<rbrakk>\\<^sub>e b", "by (pred_auto)"], ["", "lemma refBy_order: \"P \\<sqsubseteq> Q = `Q \\<Rightarrow> P`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<sqsubseteq> Q) = `Q \\<Rightarrow> P`", "by (pred_auto)"], ["", "lemma conj_idem [simp]: \"((P::'\\<alpha> upred) \\<and> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> P) = P", "by (pred_auto)"], ["", "lemma disj_idem [simp]: \"((P::'\\<alpha> upred) \\<or> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> P) = P", "by (pred_auto)"], ["", "lemma conj_comm: \"((P::'\\<alpha> upred) \\<and> Q) = (Q \\<and> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> Q) = (Q \\<and> P)", "by (pred_auto)"], ["", "lemma disj_comm: \"((P::'\\<alpha> upred) \\<or> Q) = (Q \\<or> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q) = (Q \\<or> P)", "by (pred_auto)"], ["", "lemma conj_subst: \"P = R \\<Longrightarrow> ((P::'\\<alpha> upred) \\<and> Q) = (R \\<and> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = R \\<Longrightarrow> (P \\<and> Q) = (R \\<and> Q)", "by (pred_auto)"], ["", "lemma disj_subst: \"P = R \\<Longrightarrow> ((P::'\\<alpha> upred) \\<or> Q) = (R \\<or> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = R \\<Longrightarrow> (P \\<or> Q) = (R \\<or> Q)", "by (pred_auto)"], ["", "lemma conj_assoc:\"(((P::'\\<alpha> upred) \\<and> Q) \\<and> S) = (P \\<and> (Q \\<and> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<and> Q) \\<and> S) = (P \\<and> Q \\<and> S)", "by (pred_auto)"], ["", "lemma disj_assoc:\"(((P::'\\<alpha> upred) \\<or> Q) \\<or> S) = (P \\<or> (Q \\<or> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<or> Q) \\<or> S) = (P \\<or> Q \\<or> S)", "by (pred_auto)"], ["", "lemma conj_disj_abs:\"((P::'\\<alpha> upred) \\<and> (P \\<or> Q)) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> (P \\<or> Q)) = P", "by (pred_auto)"], ["", "lemma disj_conj_abs:\"((P::'\\<alpha> upred) \\<or> (P \\<and> Q)) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> P \\<and> Q) = P", "by (pred_auto)"], ["", "lemma conj_disj_distr:\"((P::'\\<alpha> upred) \\<and> (Q \\<or> R)) = ((P \\<and> Q) \\<or> (P \\<and> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> (Q \\<or> R)) = (P \\<and> Q \\<or> P \\<and> R)", "by (pred_auto)"], ["", "lemma disj_conj_distr:\"((P::'\\<alpha> upred) \\<or> (Q \\<and> R)) = ((P \\<or> Q) \\<and> (P \\<or> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q \\<and> R) = ((P \\<or> Q) \\<and> (P \\<or> R))", "by (pred_auto)"], ["", "lemma true_disj_zero [simp]:\n  \"(P \\<or> true) = true\" \"(true \\<or> P) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> true) = true &&& (true \\<or> P) = true", "by (pred_auto)+"], ["", "lemma true_conj_zero [simp]:\n  \"(P \\<and> false) = false\" \"(false \\<and> P) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> false) = false &&& (false \\<and> P) = false", "by (pred_auto)+"], ["", "lemma false_sup [simp]: \"false \\<sqinter> P = P\" \"P \\<sqinter> false = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. false \\<sqinter> P = P &&& P \\<sqinter> false = P", "by (pred_auto)+"], ["", "lemma true_inf [simp]: \"true \\<squnion> P = P\" \"P \\<squnion> true = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. true \\<squnion> P = P &&& P \\<squnion> true = P", "by (pred_auto)+"], ["", "lemma imp_vacuous [simp]: \"(false \\<Rightarrow> u) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false \\<Rightarrow> u) = true", "by (pred_auto)"], ["", "lemma imp_true [simp]: \"(p \\<Rightarrow> true) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<Rightarrow> true) = true", "by (pred_auto)"], ["", "lemma true_imp [simp]: \"(true \\<Rightarrow> p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true \\<Rightarrow> p) = p", "by (pred_auto)"], ["", "lemma impl_mp1 [simp]: \"(P \\<and> (P \\<Rightarrow> Q)) = (P \\<and> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> (P \\<Rightarrow> Q)) = (P \\<and> Q)", "by (pred_auto)"], ["", "lemma impl_mp2 [simp]: \"((P \\<Rightarrow> Q) \\<and> P) = (Q \\<and> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<Rightarrow> Q) \\<and> P) = (Q \\<and> P)", "by (pred_auto)"], ["", "lemma impl_adjoin: \"((P \\<Rightarrow> Q) \\<and> R) = ((P \\<and> R \\<Rightarrow> Q \\<and> R) \\<and> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<Rightarrow> Q) \\<and> R) =\n    ((P \\<and> R \\<Rightarrow> Q \\<and> R) \\<and> R)", "by (pred_auto)"], ["", "lemma impl_refine_intro:\n  \"\\<lbrakk> Q\\<^sub>1 \\<sqsubseteq> P\\<^sub>1; P\\<^sub>2 \\<sqsubseteq> (P\\<^sub>1 \\<and> Q\\<^sub>2) \\<rbrakk> \\<Longrightarrow> (P\\<^sub>1 \\<Rightarrow> P\\<^sub>2) \\<sqsubseteq> (Q\\<^sub>1 \\<Rightarrow> Q\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q\\<^sub>1 \\<sqsubseteq> P\\<^sub>1;\n     P\\<^sub>2 \\<sqsubseteq> (P\\<^sub>1 \\<and> Q\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> (P\\<^sub>1 \\<Rightarrow> P\\<^sub>2) \\<sqsubseteq>\n                      (Q\\<^sub>1 \\<Rightarrow> Q\\<^sub>2)", "by (pred_auto)"], ["", "lemma spec_refine:\n  \"Q \\<sqsubseteq> (P \\<and> R) \\<Longrightarrow> (P \\<Rightarrow> Q) \\<sqsubseteq> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> (P \\<and> R) \\<Longrightarrow>\n    (P \\<Rightarrow> Q) \\<sqsubseteq> R", "by (rel_auto)"], ["", "lemma impl_disjI: \"\\<lbrakk> `P \\<Rightarrow> R`; `Q \\<Rightarrow> R` \\<rbrakk> \\<Longrightarrow> `(P \\<or> Q) \\<Rightarrow> R`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>`P \\<Rightarrow> R`; `Q \\<Rightarrow> R`\\<rbrakk>\n    \\<Longrightarrow> `P \\<or> Q \\<Rightarrow> R`", "by (rel_auto)"], ["", "lemma conditional_iff:\n  \"(P \\<Rightarrow> Q) = (P \\<Rightarrow> R) \\<longleftrightarrow> `P \\<Rightarrow> (Q \\<Leftrightarrow> R)`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<Rightarrow> Q) = (P \\<Rightarrow> R)) =\n    `P \\<Rightarrow> Q \\<Leftrightarrow> R`", "by (pred_auto)"], ["", "lemma p_and_not_p [simp]: \"(P \\<and> \\<not> P) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> \\<not> P) = false", "by (pred_auto)"], ["", "lemma p_or_not_p [simp]: \"(P \\<or> \\<not> P) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> \\<not> P) = true", "by (pred_auto)"], ["", "lemma p_imp_p [simp]: \"(P \\<Rightarrow> P) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Rightarrow> P) = true", "by (pred_auto)"], ["", "lemma p_iff_p [simp]: \"(P \\<Leftrightarrow> P) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Leftrightarrow> P) = true", "by (pred_auto)"], ["", "lemma p_imp_false [simp]: \"(P \\<Rightarrow> false) = (\\<not> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Rightarrow> false) = (\\<not> P)", "by (pred_auto)"], ["", "lemma not_conj_deMorgans [simp]: \"(\\<not> ((P::'\\<alpha> upred) \\<and> Q)) = ((\\<not> P) \\<or> (\\<not> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (P \\<and> Q)) = (\\<not> P \\<or> \\<not> Q)", "by (pred_auto)"], ["", "lemma not_disj_deMorgans [simp]: \"(\\<not> ((P::'\\<alpha> upred) \\<or> Q)) = ((\\<not> P) \\<and> (\\<not> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (P \\<or> Q)) = (\\<not> P \\<and> \\<not> Q)", "by (pred_auto)"], ["", "lemma conj_disj_not_abs [simp]: \"((P::'\\<alpha> upred) \\<and> ((\\<not>P) \\<or> Q)) = (P \\<and> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> (\\<not> P \\<or> Q)) = (P \\<and> Q)", "by (pred_auto)"], ["", "lemma subsumption1:\n  \"`P \\<Rightarrow> Q` \\<Longrightarrow> (P \\<or> Q) = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. `P \\<Rightarrow> Q` \\<Longrightarrow> (P \\<or> Q) = Q", "by (pred_auto)"], ["", "lemma subsumption2:\n  \"`Q \\<Rightarrow> P` \\<Longrightarrow> (P \\<or> Q) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. `Q \\<Rightarrow> P` \\<Longrightarrow> (P \\<or> Q) = P", "by (pred_auto)"], ["", "lemma neg_conj_cancel1: \"(\\<not> P \\<and> (P \\<or> Q)) = (\\<not> P \\<and> Q :: '\\<alpha> upred)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> P \\<and> (P \\<or> Q)) = (\\<not> P \\<and> Q)", "by (pred_auto)"], ["", "lemma neg_conj_cancel2: \"(\\<not> Q \\<and> (P \\<or> Q)) = (\\<not> Q \\<and> P :: '\\<alpha> upred)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> Q \\<and> (P \\<or> Q)) = (\\<not> Q \\<and> P)", "by (pred_auto)"], ["", "lemma double_negation [simp]: \"(\\<not> \\<not> (P::'\\<alpha> upred)) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> \\<not> P) = P", "by (pred_auto)"], ["", "lemma true_not_false [simp]: \"true \\<noteq> false\" \"false \\<noteq> true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> true = false &&& \\<not> false = true", "by (pred_auto)+"], ["", "lemma closure_conj_distr: \"([P]\\<^sub>u \\<and> [Q]\\<^sub>u) = [P \\<and> Q]\\<^sub>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([P]\\<^sub>u \\<and> [Q]\\<^sub>u) = [P \\<and> Q]\\<^sub>u", "by (pred_auto)"], ["", "lemma closure_imp_distr: \"`[P \\<Rightarrow> Q]\\<^sub>u \\<Rightarrow> [P]\\<^sub>u \\<Rightarrow> [Q]\\<^sub>u`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. `[P \\<Rightarrow> Q]\\<^sub>u \\<Rightarrow>\n     [P]\\<^sub>u \\<Rightarrow> [Q]\\<^sub>u`", "by (pred_auto)"], ["", "lemma true_iff [simp]: \"(P \\<Leftrightarrow> true) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Leftrightarrow> true) = P", "by (pred_auto)"], ["", "lemma taut_iff_eq:\n  \"`P \\<Leftrightarrow> Q` \\<longleftrightarrow> (P = Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. `P \\<Leftrightarrow> Q` = (P = Q)", "by (pred_auto)"], ["", "lemma impl_alt_def: \"(P \\<Rightarrow> Q) = (\\<not> P \\<or> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Rightarrow> Q) = (\\<not> P \\<or> Q)", "by (pred_auto)"], ["", "subsection \\<open> Lattice laws \\<close>"], ["", "lemma uinf_or:\n  fixes P Q :: \"'\\<alpha> upred\"\n  shows \"(P \\<sqinter> Q) = (P \\<or> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqinter> Q = (P \\<or> Q)", "by (pred_auto)"], ["", "lemma usup_and:\n  fixes P Q :: \"'\\<alpha> upred\"\n  shows \"(P \\<squnion> Q) = (P \\<and> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<squnion> Q = (P \\<and> Q)", "by (pred_auto)"], ["", "lemma UINF_alt_def:\n  \"(\\<Sqinter> i | A(i) \\<bullet> P(i)) = (\\<Sqinter> i \\<bullet> A(i) \\<and> P(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UINF A P = (\\<Sqinter> i \\<bullet> A i \\<and> P i)", "by (rel_auto)"], ["", "lemma USUP_true [simp]: \"(\\<Squnion> P | F(P) \\<bullet> true) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. USUP F (\\<lambda>P. true) = true", "by (pred_auto)"], ["", "lemma UINF_mem_UNIV [simp]: \"(\\<Sqinter> x\\<in>UNIV \\<bullet> P(x)) = (\\<Sqinter> x \\<bullet> P(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> x \\<in> UNIV \\<bullet> P x) = (\\<Sqinter> x \\<bullet> P x)", "by (pred_auto)"], ["", "lemma USUP_mem_UNIV [simp]: \"(\\<Squnion> x\\<in>UNIV \\<bullet> P(x)) = (\\<Squnion> x \\<bullet> P(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> x \\<in> UNIV \\<bullet> P x) = (\\<Squnion> x \\<bullet> P x)", "by (pred_auto)"], ["", "lemma USUP_false [simp]: \"(\\<Squnion> i \\<bullet> false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> i \\<bullet> false) = false", "by (pred_simp)"], ["", "lemma USUP_mem_false [simp]: \"I \\<noteq> {} \\<Longrightarrow> (\\<Squnion> i\\<in>I \\<bullet> false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> I = {} \\<Longrightarrow>\n    (\\<Squnion> i \\<in> I \\<bullet> false) = false", "by (rel_simp)"], ["", "lemma USUP_where_false [simp]: \"(\\<Squnion> i | false \\<bullet> P(i)) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> i | false \\<bullet> P i) = true", "by (rel_auto)"], ["", "lemma UINF_true [simp]: \"(\\<Sqinter> i \\<bullet> true) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> i \\<bullet> true) = true", "by (pred_simp)"], ["", "lemma UINF_ind_const [simp]: \n  \"(\\<Sqinter> i \\<bullet> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> i \\<bullet> P) = P", "by (rel_auto)"], ["", "lemma UINF_mem_true [simp]: \"A \\<noteq> {} \\<Longrightarrow> (\\<Sqinter> i\\<in>A \\<bullet> true) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> A = {} \\<Longrightarrow>\n    (\\<Sqinter> i \\<in> A \\<bullet> true) = true", "by (pred_auto)"], ["", "lemma UINF_false [simp]: \"(\\<Sqinter> i | P(i) \\<bullet> false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UINF P (\\<lambda>i. false) = false", "by (pred_auto)"], ["", "lemma UINF_where_false [simp]: \"(\\<Sqinter> i | false \\<bullet> P(i)) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> i | false \\<bullet> P i) = false", "by (rel_auto)"], ["", "lemma UINF_cong_eq:\n  \"\\<lbrakk> \\<And> x. P\\<^sub>1(x) = P\\<^sub>2(x); \\<And> x. `P\\<^sub>1(x) \\<Rightarrow> Q\\<^sub>1(x) =\\<^sub>u Q\\<^sub>2(x)` \\<rbrakk> \\<Longrightarrow>\n        (\\<Sqinter> x | P\\<^sub>1(x) \\<bullet> Q\\<^sub>1(x)) = (\\<Sqinter> x | P\\<^sub>2(x) \\<bullet> Q\\<^sub>2(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. P\\<^sub>1 x = P\\<^sub>2 x;\n     \\<And>x.\n        `P\\<^sub>1 x \\<Rightarrow>\n         Q\\<^sub>1 x =\\<^sub>u Q\\<^sub>2 x`\\<rbrakk>\n    \\<Longrightarrow> UINF P\\<^sub>1 Q\\<^sub>1 = UINF P\\<^sub>2 Q\\<^sub>2", "by (unfold UINF_def, pred_simp, metis)"], ["", "lemma UINF_as_Sup: \"(\\<Sqinter> P \\<in> \\<P> \\<bullet> P) = \\<Sqinter> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P \\<in> \\<P> \\<bullet> P) = \\<Sqinter>\\<P>", "apply (simp add: upred_defs bop.rep_eq lit.rep_eq Sup_uexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P \\<in> \\<P> \\<bullet> P) =\n    mk\\<^sub>e\n     (\\<lambda>A. \\<Sqinter>x\\<in>\\<P>. \\<lbrakk>x\\<rbrakk>\\<^sub>e A)", "apply (pred_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Sqinter>{uu_.\n                  \\<exists>x.\n                     uu_ = \\<lbrakk>x\\<rbrakk>\\<^sub>e b \\<and>\n                     x \\<in> \\<P>} =\n       (\\<Sqinter>x\\<in>\\<P>. \\<lbrakk>x\\<rbrakk>\\<^sub>e b)", "apply (rule cong[of \"Sup\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. Sup = Sup\n 2. \\<And>b.\n       {uu_.\n        \\<exists>x.\n           uu_ = \\<lbrakk>x\\<rbrakk>\\<^sub>e b \\<and> x \\<in> \\<P>} =\n       (\\<lambda>x. \\<lbrakk>x\\<rbrakk>\\<^sub>e b) ` \\<P>", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma UINF_as_Sup_collect: \"(\\<Sqinter>P\\<in>A \\<bullet> f(P)) = (\\<Sqinter>P\\<in>A. f(P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P \\<in> A \\<bullet> f P) = \\<Sqinter>(f ` A)", "apply (simp add: upred_defs bop.rep_eq lit.rep_eq Sup_uexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P \\<in> A \\<bullet> f P) =\n    mk\\<^sub>e\n     (\\<lambda>Aa. \\<Sqinter>x\\<in>A. \\<lbrakk>f x\\<rbrakk>\\<^sub>e Aa)", "apply (pred_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Sqinter>{uu_.\n                  \\<exists>x.\n                     uu_ = \\<lbrakk>f x\\<rbrakk>\\<^sub>e b \\<and>\n                     x \\<in> A} =\n       (\\<Sqinter>x\\<in>A. \\<lbrakk>f x\\<rbrakk>\\<^sub>e b)", "apply (simp add: Setcompr_eq_image)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma UINF_as_Sup_collect': \"(\\<Sqinter>P \\<bullet> f(P)) = (\\<Sqinter>P. f(P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P \\<bullet> f P) = \\<Sqinter>range f", "apply (simp add: upred_defs bop.rep_eq lit.rep_eq Sup_uexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P | \\<bottom> \\<bullet> f P) =\n    mk\\<^sub>e (\\<lambda>A. \\<Sqinter>x. \\<lbrakk>f x\\<rbrakk>\\<^sub>e A)", "apply (pred_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Sqinter>{uu_. \\<exists>x. uu_ = \\<lbrakk>f x\\<rbrakk>\\<^sub>e b} =\n       (\\<Sqinter>x. \\<lbrakk>f x\\<rbrakk>\\<^sub>e b)", "apply (simp add: full_SetCompr_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma UINF_as_Sup_image: \"(\\<Sqinter> P | \\<guillemotleft>P\\<guillemotright> \\<in>\\<^sub>u \\<guillemotleft>A\\<guillemotright> \\<bullet> f(P)) = \\<Sqinter> (f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P \\<in> A \\<bullet> f P) = \\<Sqinter>(f ` A)", "apply (simp add: upred_defs bop.rep_eq lit.rep_eq Sup_uexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P \\<in> A \\<bullet> f P) =\n    mk\\<^sub>e\n     (\\<lambda>Aa. \\<Sqinter>x\\<in>A. \\<lbrakk>f x\\<rbrakk>\\<^sub>e Aa)", "apply (pred_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Sqinter>{uu_.\n                  \\<exists>x.\n                     uu_ = \\<lbrakk>f x\\<rbrakk>\\<^sub>e b \\<and>\n                     x \\<in> A} =\n       (\\<Sqinter>x\\<in>A. \\<lbrakk>f x\\<rbrakk>\\<^sub>e b)", "apply (rule cong[of \"Sup\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. Sup = Sup\n 2. \\<And>b.\n       {uu_.\n        \\<exists>x.\n           uu_ = \\<lbrakk>f x\\<rbrakk>\\<^sub>e b \\<and> x \\<in> A} =\n       (\\<lambda>x. \\<lbrakk>f x\\<rbrakk>\\<^sub>e b) ` A", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma USUP_as_Inf: \"(\\<Squnion> P \\<in> \\<P> \\<bullet> P) = \\<Squnion> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> P \\<in> \\<P> \\<bullet> P) = \\<Squnion>\\<P>", "apply (simp add: upred_defs bop.rep_eq lit.rep_eq Inf_uexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> P \\<in> \\<P> \\<bullet> P) =\n    mk\\<^sub>e\n     (\\<lambda>A. \\<Squnion>x\\<in>\\<P>. \\<lbrakk>x\\<rbrakk>\\<^sub>e A)", "apply (pred_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Squnion>{uu_.\n                  \\<exists>x.\n                     uu_ = \\<lbrakk>x\\<rbrakk>\\<^sub>e b \\<and>\n                     x \\<in> \\<P>} =\n       (\\<Squnion>x\\<in>\\<P>. \\<lbrakk>x\\<rbrakk>\\<^sub>e b)", "apply (rule cong[of \"Inf\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. Inf = Inf\n 2. \\<And>b.\n       {uu_.\n        \\<exists>x.\n           uu_ = \\<lbrakk>x\\<rbrakk>\\<^sub>e b \\<and> x \\<in> \\<P>} =\n       (\\<lambda>x. \\<lbrakk>x\\<rbrakk>\\<^sub>e b) ` \\<P>", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma USUP_as_Inf_collect: \"(\\<Squnion>P\\<in>A \\<bullet> f(P)) = (\\<Squnion>P\\<in>A. f(P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> P \\<in> A \\<bullet> f P) = \\<Squnion>(f ` A)", "apply (pred_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Squnion>{uu_.\n                  \\<exists>x.\n                     uu_ = \\<lbrakk>f x\\<rbrakk>\\<^sub>e b \\<and>\n                     x \\<in> A} =\n       (\\<Squnion>x\\<in>A. \\<lbrakk>f x\\<rbrakk>\\<^sub>e b)", "apply (simp add: Setcompr_eq_image)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma USUP_as_Inf_collect': \"(\\<Squnion>P \\<bullet> f(P)) = (\\<Squnion>P. f(P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> P \\<bullet> f P) = \\<Squnion>range f", "apply (simp add: upred_defs bop.rep_eq lit.rep_eq Sup_uexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> P | \\<bottom> \\<bullet> f P) = \\<Squnion>range f", "apply (pred_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Squnion>{uu_. \\<exists>x. uu_ = \\<lbrakk>f x\\<rbrakk>\\<^sub>e b} =\n       (\\<Squnion>x. \\<lbrakk>f x\\<rbrakk>\\<^sub>e b)", "apply (simp add: full_SetCompr_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma USUP_as_Inf_image: \"(\\<Squnion> P \\<in> \\<P> \\<bullet> f(P)) = \\<Squnion> (f ` \\<P>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> P \\<in> \\<P> \\<bullet> f P) = \\<Squnion>(f ` \\<P>)", "apply (simp add: upred_defs bop.rep_eq lit.rep_eq Inf_uexpr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> P \\<in> \\<P> \\<bullet> f P) =\n    mk\\<^sub>e\n     (\\<lambda>A. \\<Squnion>x\\<in>\\<P>. \\<lbrakk>f x\\<rbrakk>\\<^sub>e A)", "apply (pred_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Squnion>{uu_.\n                  \\<exists>x.\n                     uu_ = \\<lbrakk>f x\\<rbrakk>\\<^sub>e b \\<and>\n                     x \\<in> \\<P>} =\n       (\\<Squnion>x\\<in>\\<P>. \\<lbrakk>f x\\<rbrakk>\\<^sub>e b)", "apply (rule cong[of \"Inf\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. Inf = Inf\n 2. \\<And>b.\n       {uu_.\n        \\<exists>x.\n           uu_ = \\<lbrakk>f x\\<rbrakk>\\<^sub>e b \\<and> x \\<in> \\<P>} =\n       (\\<lambda>x. \\<lbrakk>f x\\<rbrakk>\\<^sub>e b) ` \\<P>", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma USUP_image_eq [simp]: \"USUP (\\<lambda>i. \\<guillemotleft>i\\<guillemotright> \\<in>\\<^sub>u \\<guillemotleft>f ` A\\<guillemotright>) g = (\\<Squnion> i\\<in>A \\<bullet> g(f(i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> i \\<in> f ` A \\<bullet> g i) =\n    (\\<Squnion> i \\<in> A \\<bullet> g (f i))", "by (pred_simp, rule_tac cong[of Inf Inf], auto)"], ["", "lemma UINF_image_eq [simp]: \"UINF (\\<lambda>i. \\<guillemotleft>i\\<guillemotright> \\<in>\\<^sub>u \\<guillemotleft>f ` A\\<guillemotright>) g = (\\<Sqinter> i\\<in>A \\<bullet> g(f(i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> i \\<in> f ` A \\<bullet> g i) =\n    (\\<Sqinter> i \\<in> A \\<bullet> g (f i))", "by (pred_simp, rule_tac cong[of Sup Sup], auto)"], ["", "lemma subst_continuous [usubst]: \"\\<sigma> \\<dagger> (\\<Sqinter> A) = (\\<Sqinter> {\\<sigma> \\<dagger> P | P. P \\<in> A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> \\<Sqinter>A =\n    \\<Sqinter>{uu_. \\<exists>P. uu_ = \\<sigma> \\<dagger> P \\<and> P \\<in> A}", "by (simp add: UINF_as_Sup[THEN sym] usubst setcompr_eq_image)"], ["", "lemma not_UINF: \"(\\<not> (\\<Sqinter> i\\<in>A\\<bullet> P(i))) = (\\<Squnion> i\\<in>A\\<bullet> \\<not> P(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (\\<Sqinter> i \\<in> A \\<bullet> P i)) =\n    (\\<Squnion> i \\<in> A \\<bullet> \\<not> P i)", "by (pred_auto)"], ["", "lemma not_USUP: \"(\\<not> (\\<Squnion> i\\<in>A\\<bullet> P(i))) = (\\<Sqinter> i\\<in>A\\<bullet> \\<not> P(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (\\<Squnion> i \\<in> A \\<bullet> P i)) =\n    (\\<Sqinter> i \\<in> A \\<bullet> \\<not> P i)", "by (pred_auto)"], ["", "lemma not_UINF_ind: \"(\\<not> (\\<Sqinter> i \\<bullet> P(i))) = (\\<Squnion> i \\<bullet> \\<not> P(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (\\<Sqinter> i \\<bullet> P i)) =\n    (\\<Squnion> i \\<bullet> \\<not> P i)", "by (pred_auto)"], ["", "lemma not_USUP_ind: \"(\\<not> (\\<Squnion> i \\<bullet> P(i))) = (\\<Sqinter> i \\<bullet> \\<not> P(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (\\<Squnion> i \\<bullet> P i)) =\n    (\\<Sqinter> i \\<bullet> \\<not> P i)", "by (pred_auto)"], ["", "lemma UINF_empty [simp]: \"(\\<Sqinter> i \\<in> {} \\<bullet> P(i)) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> i | \\<guillemotleft>i\\<guillemotright> \\<in>\\<^sub>u\n                    {}\\<^sub>u \\<bullet> P i) =\n    false", "by (pred_auto)"], ["", "lemma UINF_insert [simp]: \"(\\<Sqinter> i\\<in>insert x xs \\<bullet> P(i)) = (P(x) \\<sqinter> (\\<Sqinter> i\\<in>xs \\<bullet> P(i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> i \\<in> insert x xs \\<bullet> P i) =\n    P x \\<sqinter> (\\<Sqinter> i \\<in> xs \\<bullet> P i)", "apply (pred_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Sqinter>{uu_.\n                  \\<exists>xa.\n                     uu_ = \\<lbrakk>P xa\\<rbrakk>\\<^sub>e b \\<and>\n                     (xa = x \\<or> xa \\<in> xs)} =\n       \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<sqinter>\n       \\<Sqinter>{uu_.\n                  \\<exists>x.\n                     uu_ = \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<and>\n                     x \\<in> xs}", "apply (subst Sup_insert[THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Sqinter>{uu_.\n                  \\<exists>xa.\n                     uu_ = \\<lbrakk>P xa\\<rbrakk>\\<^sub>e b \\<and>\n                     (xa = x \\<or> xa \\<in> xs)} =\n       \\<Sqinter>insert (\\<lbrakk>P x\\<rbrakk>\\<^sub>e b)\n                  {uu_.\n                   \\<exists>x.\n                      uu_ = \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<and>\n                      x \\<in> xs}", "apply (rule_tac cong[of Sup Sup])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. Sup = Sup\n 2. \\<And>b.\n       {uu_.\n        \\<exists>xa.\n           uu_ = \\<lbrakk>P xa\\<rbrakk>\\<^sub>e b \\<and>\n           (xa = x \\<or> xa \\<in> xs)} =\n       insert (\\<lbrakk>P x\\<rbrakk>\\<^sub>e b)\n        {uu_.\n         \\<exists>x.\n            uu_ = \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<and> x \\<in> xs}", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma UINF_atLeast_first:\n  \"P(n) \\<sqinter> (\\<Sqinter> i \\<in> {Suc n..} \\<bullet> P(i)) = (\\<Sqinter> i \\<in> {n..} \\<bullet> P(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n \\<sqinter> (\\<Sqinter> i \\<in> {Suc n..} \\<bullet> P i) =\n    (\\<Sqinter> i \\<in> {n..} \\<bullet> P i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P n \\<sqinter> (\\<Sqinter> i \\<in> {Suc n..} \\<bullet> P i) =\n    (\\<Sqinter> i \\<in> {n..} \\<bullet> P i)", "have \"insert n {Suc n..} = {n..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert n {Suc n..} = {n..}", "by (auto)"], ["proof (state)\nthis:\n  insert n {Suc n..} = {n..}\n\ngoal (1 subgoal):\n 1. P n \\<sqinter> (\\<Sqinter> i \\<in> {Suc n..} \\<bullet> P i) =\n    (\\<Sqinter> i \\<in> {n..} \\<bullet> P i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  insert n {Suc n..} = {n..}\n\ngoal (1 subgoal):\n 1. P n \\<sqinter> (\\<Sqinter> i \\<in> {Suc n..} \\<bullet> P i) =\n    (\\<Sqinter> i \\<in> {n..} \\<bullet> P i)", "by (metis UINF_insert)"], ["proof (state)\nthis:\n  P n \\<sqinter> (\\<Sqinter> i \\<in> {Suc n..} \\<bullet> P i) =\n  (\\<Sqinter> i \\<in> {n..} \\<bullet> P i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma UINF_atLeast_Suc:\n  \"(\\<Sqinter> i \\<in> {Suc m..} \\<bullet> P(i)) = (\\<Sqinter> i \\<in> {m..} \\<bullet> P(Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> i \\<in> {Suc m..} \\<bullet> P i) =\n    (\\<Sqinter> i \\<in> {m..} \\<bullet> P (Suc i))", "by (rel_simp, metis (full_types) Suc_le_D not_less_eq_eq)"], ["", "lemma USUP_empty [simp]: \"(\\<Squnion> i \\<in> {} \\<bullet> P(i)) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> i | \\<guillemotleft>i\\<guillemotright> \\<in>\\<^sub>u\n                    {}\\<^sub>u \\<bullet> P i) =\n    true", "by (pred_auto)"], ["", "lemma USUP_insert [simp]: \"(\\<Squnion> i\\<in>insert x xs \\<bullet> P(i)) = (P(x) \\<squnion> (\\<Squnion> i\\<in>xs \\<bullet> P(i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> i \\<in> insert x xs \\<bullet> P i) =\n    P x \\<squnion> (\\<Squnion> i \\<in> xs \\<bullet> P i)", "apply (pred_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Squnion>{uu_.\n                  \\<exists>xa.\n                     uu_ = \\<lbrakk>P xa\\<rbrakk>\\<^sub>e b \\<and>\n                     (xa = x \\<or> xa \\<in> xs)} =\n       \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<squnion>\n       \\<Squnion>{uu_.\n                  \\<exists>x.\n                     uu_ = \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<and>\n                     x \\<in> xs}", "apply (subst Inf_insert[THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Squnion>{uu_.\n                  \\<exists>xa.\n                     uu_ = \\<lbrakk>P xa\\<rbrakk>\\<^sub>e b \\<and>\n                     (xa = x \\<or> xa \\<in> xs)} =\n       \\<Squnion>insert (\\<lbrakk>P x\\<rbrakk>\\<^sub>e b)\n                  {uu_.\n                   \\<exists>x.\n                      uu_ = \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<and>\n                      x \\<in> xs}", "apply (rule_tac cong[of Inf Inf])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. Inf = Inf\n 2. \\<And>b.\n       {uu_.\n        \\<exists>xa.\n           uu_ = \\<lbrakk>P xa\\<rbrakk>\\<^sub>e b \\<and>\n           (xa = x \\<or> xa \\<in> xs)} =\n       insert (\\<lbrakk>P x\\<rbrakk>\\<^sub>e b)\n        {uu_.\n         \\<exists>x.\n            uu_ = \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<and> x \\<in> xs}", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma USUP_atLeast_first:\n  \"(P(n) \\<and> (\\<Squnion> i \\<in> {Suc n..} \\<bullet> P(i))) = (\\<Squnion> i \\<in> {n..} \\<bullet> P(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P n \\<and> (\\<Squnion> i \\<in> {Suc n..} \\<bullet> P i)) =\n    (\\<Squnion> i \\<in> {n..} \\<bullet> P i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (P n \\<and> (\\<Squnion> i \\<in> {Suc n..} \\<bullet> P i)) =\n    (\\<Squnion> i \\<in> {n..} \\<bullet> P i)", "have \"insert n {Suc n..} = {n..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert n {Suc n..} = {n..}", "by (auto)"], ["proof (state)\nthis:\n  insert n {Suc n..} = {n..}\n\ngoal (1 subgoal):\n 1. (P n \\<and> (\\<Squnion> i \\<in> {Suc n..} \\<bullet> P i)) =\n    (\\<Squnion> i \\<in> {n..} \\<bullet> P i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  insert n {Suc n..} = {n..}\n\ngoal (1 subgoal):\n 1. (P n \\<and> (\\<Squnion> i \\<in> {Suc n..} \\<bullet> P i)) =\n    (\\<Squnion> i \\<in> {n..} \\<bullet> P i)", "by (metis USUP_insert conj_upred_def)"], ["proof (state)\nthis:\n  (P n \\<and> (\\<Squnion> i \\<in> {Suc n..} \\<bullet> P i)) =\n  (\\<Squnion> i \\<in> {n..} \\<bullet> P i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma USUP_atLeast_Suc:\n  \"(\\<Squnion> i \\<in> {Suc m..} \\<bullet> P(i)) = (\\<Squnion> i \\<in> {m..} \\<bullet> P(Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> i \\<in> {Suc m..} \\<bullet> P i) =\n    (\\<Squnion> i \\<in> {m..} \\<bullet> P (Suc i))", "by (rel_simp, metis (full_types) Suc_le_D not_less_eq_eq)"], ["", "lemma conj_UINF_dist:\n  \"(P \\<and> (\\<Sqinter> Q\\<in>S \\<bullet> F(Q))) = (\\<Sqinter> Q\\<in>S \\<bullet> P \\<and> F(Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> (\\<Sqinter> Q \\<in> S \\<bullet> F Q)) =\n    (\\<Sqinter> Q \\<in> S \\<bullet> P \\<and> F Q)", "by (simp add: upred_defs bop.rep_eq lit.rep_eq, pred_auto)"], ["", "lemma conj_UINF_ind_dist:\n  \"(P \\<and> (\\<Sqinter> Q \\<bullet> F(Q))) = (\\<Sqinter> Q \\<bullet> P \\<and> F(Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> (\\<Sqinter> Q \\<bullet> F Q)) =\n    (\\<Sqinter> Q \\<bullet> P \\<and> F Q)", "by pred_auto"], ["", "lemma disj_UINF_dist:\n  \"S \\<noteq> {} \\<Longrightarrow> (P \\<or> (\\<Sqinter> Q\\<in>S \\<bullet> F(Q))) = (\\<Sqinter> Q\\<in>S \\<bullet> P \\<or> F(Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> S = {} \\<Longrightarrow>\n    (P \\<or> (\\<Sqinter> Q \\<in> S \\<bullet> F Q)) =\n    (\\<Sqinter> Q \\<in> S \\<bullet> P \\<or> F Q)", "by (simp add: upred_defs bop.rep_eq lit.rep_eq, pred_auto)"], ["", "lemma UINF_conj_UINF [simp]: \n  \"((\\<Sqinter> i\\<in>I \\<bullet> P(i)) \\<or> (\\<Sqinter> i\\<in>I \\<bullet> Q(i))) = (\\<Sqinter> i\\<in>I \\<bullet> P(i) \\<or> Q(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sqinter> i \\<in> I \\<bullet> P i) \\<or>\n     (\\<Sqinter> i \\<in> I \\<bullet> Q i)) =\n    (\\<Sqinter> i \\<in> I \\<bullet> P i \\<or> Q i)", "by (rel_auto)"], ["", "lemma conj_USUP_dist:\n  \"S \\<noteq> {} \\<Longrightarrow> (P \\<and> (\\<Squnion> Q\\<in>S \\<bullet> F(Q))) = (\\<Squnion> Q\\<in>S \\<bullet> P \\<and> F(Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> S = {} \\<Longrightarrow>\n    (P \\<and> (\\<Squnion> Q \\<in> S \\<bullet> F Q)) =\n    (\\<Squnion> Q \\<in> S \\<bullet> P \\<and> F Q)", "by (subst uexpr_eq_iff, auto simp add: conj_upred_def USUP.rep_eq inf_uexpr.rep_eq bop.rep_eq lit.rep_eq)"], ["", "lemma USUP_conj_USUP [simp]: \"((\\<Squnion> P \\<in> A \\<bullet> F(P)) \\<and> (\\<Squnion> P \\<in> A \\<bullet> G(P))) = (\\<Squnion> P \\<in> A \\<bullet> F(P) \\<and> G(P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Squnion> P \\<in> A \\<bullet> F P) \\<and>\n     (\\<Squnion> P \\<in> A \\<bullet> G P)) =\n    (\\<Squnion> P \\<in> A \\<bullet> F P \\<and> G P)", "by (simp add: upred_defs bop.rep_eq lit.rep_eq, pred_auto)"], ["", "lemma UINF_all_cong [cong]:\n  assumes \"\\<And> P. F(P) = G(P)\"\n  shows \"(\\<Sqinter> P \\<bullet> F(P)) = (\\<Sqinter> P \\<bullet> G(P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P \\<bullet> F P) = (\\<Sqinter> P \\<bullet> G P)", "by (simp add: UINF_as_Sup_collect assms)"], ["", "lemma UINF_cong:\n  assumes \"\\<And> P. P \\<in> A \\<Longrightarrow> F(P) = G(P)\"\n  shows \"(\\<Sqinter> P\\<in>A \\<bullet> F(P)) = (\\<Sqinter> P\\<in>A \\<bullet> G(P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P \\<in> A \\<bullet> F P) =\n    (\\<Sqinter> P \\<in> A \\<bullet> G P)", "by (simp add: UINF_as_Sup_collect assms)"], ["", "lemma USUP_all_cong:\n  assumes \"\\<And> P. F(P) = G(P)\"\n  shows \"(\\<Squnion> P \\<bullet> F(P)) = (\\<Squnion> P \\<bullet> G(P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> P \\<bullet> F P) = (\\<Squnion> P \\<bullet> G P)", "by (simp add: assms)"], ["", "lemma USUP_cong:\n  assumes \"\\<And> P. P \\<in> A \\<Longrightarrow> F(P) = G(P)\"\n  shows \"(\\<Squnion> P\\<in>A \\<bullet> F(P)) = (\\<Squnion> P\\<in>A \\<bullet> G(P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> P \\<in> A \\<bullet> F P) =\n    (\\<Squnion> P \\<in> A \\<bullet> G P)", "by (simp add: USUP_as_Inf_collect assms)"], ["", "lemma UINF_subset_mono: \"A \\<subseteq> B \\<Longrightarrow> (\\<Sqinter> P\\<in>B \\<bullet> F(P)) \\<sqsubseteq> (\\<Sqinter> P\\<in>A \\<bullet> F(P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    (\\<Sqinter> P \\<in> B \\<bullet> F P) \\<sqsubseteq>\n    (\\<Sqinter> P \\<in> A \\<bullet> F P)", "by (simp add: SUP_subset_mono UINF_as_Sup_collect)"], ["", "lemma USUP_subset_mono: \"A \\<subseteq> B \\<Longrightarrow> (\\<Squnion> P\\<in>A \\<bullet> F(P)) \\<sqsubseteq> (\\<Squnion> P\\<in>B \\<bullet> F(P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    (\\<Squnion> P \\<in> A \\<bullet> F P) \\<sqsubseteq>\n    (\\<Squnion> P \\<in> B \\<bullet> F P)", "by (simp add: INF_superset_mono USUP_as_Inf_collect)"], ["", "lemma UINF_impl: \"(\\<Sqinter> P\\<in>A \\<bullet> F(P) \\<Rightarrow> G(P)) = ((\\<Squnion> P\\<in>A \\<bullet> F(P)) \\<Rightarrow> (\\<Sqinter> P\\<in>A \\<bullet> G(P)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P \\<in> A \\<bullet> F P \\<Rightarrow> G P) =\n    ((\\<Squnion> P \\<in> A \\<bullet> F P) \\<Rightarrow>\n     (\\<Sqinter> P \\<in> A \\<bullet> G P))", "by (pred_auto)"], ["", "lemma USUP_is_forall: \"(\\<Squnion> x \\<bullet> P(x)) = (\\<^bold>\\<forall> x \\<bullet> P(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> x \\<bullet> P x) = ushAll P", "by (pred_simp)"], ["", "lemma USUP_ind_is_forall: \"(\\<Squnion> x\\<in>A \\<bullet> P(x)) = (\\<^bold>\\<forall> x\\<in>\\<guillemotleft>A\\<guillemotright> \\<bullet> P(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> x \\<in> A \\<bullet> P x) =\n    (\\<^bold>\\<forall> x \\<bullet> \\<guillemotleft>x\\<guillemotright> \\<in>\\<^sub>u\n                                   \\<guillemotleft>A\\<guillemotright> \\<Rightarrow>\n                                   P x)", "by (pred_auto)"], ["", "lemma UINF_is_exists: \"(\\<Sqinter> x \\<bullet> P(x)) = (\\<^bold>\\<exists> x \\<bullet> P(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> x \\<bullet> P x) = ushEx P", "by (pred_simp)"], ["", "lemma UINF_all_nats [simp]:\n  fixes P :: \"nat \\<Rightarrow> '\\<alpha> upred\"\n  shows \"(\\<Sqinter> n \\<bullet> \\<Sqinter> i\\<in>{0..n} \\<bullet> P(i)) = (\\<Sqinter> n \\<bullet> P(n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> n \\<bullet> \\<Sqinter> i \\<in> {0..n} \\<bullet> P i) =\n    (\\<Sqinter> n \\<bullet> P n)", "by (pred_auto)"], ["", "lemma USUP_all_nats [simp]:\n  fixes P :: \"nat \\<Rightarrow> '\\<alpha> upred\"\n  shows \"(\\<Squnion> n \\<bullet> \\<Squnion> i\\<in>{0..n} \\<bullet> P(i)) = (\\<Squnion> n \\<bullet> P(n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> n \\<bullet> \\<Squnion> i \\<in> {0..n} \\<bullet> P i) =\n    (\\<Squnion> n \\<bullet> P n)", "by (pred_auto)"], ["", "lemma UINF_upto_expand_first:\n  \"m < n \\<Longrightarrow> (\\<Sqinter> i \\<in> {m..<n} \\<bullet> P(i)) = ((P(m) :: '\\<alpha> upred) \\<or> (\\<Sqinter> i \\<in> {Suc m..<n} \\<bullet> P(i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow>\n    (\\<Sqinter> i \\<in> {m..<n} \\<bullet> P i) =\n    (P m \\<or> (\\<Sqinter> i \\<in> {Suc m..<n} \\<bullet> P i))", "apply (rel_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b x.\n       \\<lbrakk>\\<lbrakk>P x\\<rbrakk>\\<^sub>e b; m \\<le> x; x < n;\n        \\<forall>x\\<ge>Suc m.\n           \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<longrightarrow>\n           \\<not> x < n\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>P m\\<rbrakk>\\<^sub>e b", "using Suc_leI le_eq_less_or_eq"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> Suc ?m \\<le> ?n\n  (?m \\<le> ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. \\<And>b x.\n       \\<lbrakk>\\<lbrakk>P x\\<rbrakk>\\<^sub>e b; m \\<le> x; x < n;\n        \\<forall>x\\<ge>Suc m.\n           \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<longrightarrow>\n           \\<not> x < n\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>P m\\<rbrakk>\\<^sub>e b", "by auto"], ["", "lemma UINF_upto_expand_last:\n  \"(\\<Sqinter> i \\<in> {0..<Suc(n)} \\<bullet> P(i)) = ((\\<Sqinter> i \\<in> {0..<n} \\<bullet> P(i)) \\<or> P(n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> i \\<in> {0..<Suc n} \\<bullet> P i) =\n    ((\\<Sqinter> i \\<in> {0..<n} \\<bullet> P i) \\<or> P n)", "apply (rel_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b x.\n       \\<lbrakk>\\<lbrakk>P x\\<rbrakk>\\<^sub>e b; x < Suc n;\n        \\<not> \\<lbrakk>P n\\<rbrakk>\\<^sub>e b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<and> x < n", "using less_SucE"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m < Suc ?n; ?m < ?n \\<Longrightarrow> ?P;\n   ?m = ?n \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<And>b x.\n       \\<lbrakk>\\<lbrakk>P x\\<rbrakk>\\<^sub>e b; x < Suc n;\n        \\<not> \\<lbrakk>P n\\<rbrakk>\\<^sub>e b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<and> x < n", "by blast"], ["", "lemma UINF_Suc_shift: \"(\\<Sqinter> i \\<in> {Suc 0..<Suc n} \\<bullet> P(i)) = (\\<Sqinter> i \\<in> {0..<n} \\<bullet> P(Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> i \\<in> {Suc 0..<Suc n} \\<bullet> P i) =\n    (\\<Sqinter> i \\<in> {0..<n} \\<bullet> P (Suc i))", "apply (rel_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Sqinter>{uu_.\n                  \\<exists>x.\n                     uu_ = \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<and>\n                     Suc 0 \\<le> x \\<and> x < Suc n} =\n       \\<Sqinter>{uu_.\n                  \\<exists>x.\n                     uu_ = \\<lbrakk>P (Suc x)\\<rbrakk>\\<^sub>e b \\<and>\n                     x < n}", "apply (rule cong[of Sup], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b xa.\n       \\<lbrakk>Suc 0 \\<le> xa; xa < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<lbrakk>P xa\\<rbrakk>\\<^sub>e b =\n                            \\<lbrakk>P (Suc x)\\<rbrakk>\\<^sub>e b \\<and>\n                            x < n", "using less_Suc_eq_0_disj"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m = 0 \\<or> (\\<exists>j. ?m = Suc j \\<and> j < ?n))\n\ngoal (1 subgoal):\n 1. \\<And>b xa.\n       \\<lbrakk>Suc 0 \\<le> xa; xa < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<lbrakk>P xa\\<rbrakk>\\<^sub>e b =\n                            \\<lbrakk>P (Suc x)\\<rbrakk>\\<^sub>e b \\<and>\n                            x < n", "by auto"], ["", "lemma USUP_upto_expand_first:\n  \"(\\<Squnion> i \\<in> {0..<Suc(n)} \\<bullet> P(i)) = (P(0) \\<and> (\\<Squnion> i \\<in> {1..<Suc(n)} \\<bullet> P(i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> i \\<in> {0..<Suc n} \\<bullet> P i) =\n    (P 0 \\<and> (\\<Squnion> i \\<in> {1..<Suc n} \\<bullet> P i))", "apply (rel_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b x.\n       \\<lbrakk>\\<lbrakk>P 0\\<rbrakk>\\<^sub>e b;\n        \\<forall>x\\<ge>Suc 0.\n           \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<or> \\<not> x < Suc n;\n        \\<not> \\<lbrakk>P x\\<rbrakk>\\<^sub>e b; x < Suc n\\<rbrakk>\n       \\<Longrightarrow> False", "using not_less"], ["proof (prove)\nusing this:\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. \\<And>b x.\n       \\<lbrakk>\\<lbrakk>P 0\\<rbrakk>\\<^sub>e b;\n        \\<forall>x\\<ge>Suc 0.\n           \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<or> \\<not> x < Suc n;\n        \\<not> \\<lbrakk>P x\\<rbrakk>\\<^sub>e b; x < Suc n\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["", "lemma USUP_Suc_shift: \"(\\<Squnion> i \\<in> {Suc 0..<Suc n} \\<bullet> P(i)) = (\\<Squnion> i \\<in> {0..<n} \\<bullet> P(Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> i \\<in> {Suc 0..<Suc n} \\<bullet> P i) =\n    (\\<Squnion> i \\<in> {0..<n} \\<bullet> P (Suc i))", "apply (rel_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<Squnion>{uu_.\n                  \\<exists>x.\n                     uu_ = \\<lbrakk>P x\\<rbrakk>\\<^sub>e b \\<and>\n                     Suc 0 \\<le> x \\<and> x < Suc n} =\n       \\<Squnion>{uu_.\n                  \\<exists>x.\n                     uu_ = \\<lbrakk>P (Suc x)\\<rbrakk>\\<^sub>e b \\<and>\n                     x < n}", "apply (rule cong[of Inf], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b xa.\n       \\<lbrakk>Suc 0 \\<le> xa; xa < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<lbrakk>P xa\\<rbrakk>\\<^sub>e b =\n                            \\<lbrakk>P (Suc x)\\<rbrakk>\\<^sub>e b \\<and>\n                            x < n", "using less_Suc_eq_0_disj"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m = 0 \\<or> (\\<exists>j. ?m = Suc j \\<and> j < ?n))\n\ngoal (1 subgoal):\n 1. \\<And>b xa.\n       \\<lbrakk>Suc 0 \\<le> xa; xa < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<lbrakk>P xa\\<rbrakk>\\<^sub>e b =\n                            \\<lbrakk>P (Suc x)\\<rbrakk>\\<^sub>e b \\<and>\n                            x < n", "by auto"], ["", "lemma UINF_list_conv:\n  \"(\\<Sqinter> i \\<in> {0..<length(xs)} \\<bullet> f (xs ! i)) = foldr (\\<or>) (map f xs) false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> i \\<in> dom\\<^sub>l xs \\<bullet> f (xs ! i)) =\n    foldr (\\<or>) (map f xs) false", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Sqinter> i \\<in> dom\\<^sub>l [] \\<bullet> f ([] ! i)) =\n    foldr (\\<or>) (map f []) false\n 2. \\<And>a xs.\n       (\\<Sqinter> i \\<in> dom\\<^sub>l xs \\<bullet> f (xs ! i)) =\n       foldr (\\<or>) (map f xs) false \\<Longrightarrow>\n       (\\<Sqinter> i \\<in> dom\\<^sub>l\n                            (a # xs) \\<bullet> f ((a # xs) ! i)) =\n       foldr (\\<or>) (map f (a # xs)) false", "apply (rel_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       (\\<Sqinter> i \\<in> dom\\<^sub>l xs \\<bullet> f (xs ! i)) =\n       foldr (\\<or>) (map f xs) false \\<Longrightarrow>\n       (\\<Sqinter> i \\<in> dom\\<^sub>l\n                            (a # xs) \\<bullet> f ((a # xs) ! i)) =\n       foldr (\\<or>) (map f (a # xs)) false", "apply (simp add: UINF_upto_expand_first UINF_Suc_shift)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma USUP_list_conv:\n  \"(\\<Squnion> i \\<in> {0..<length(xs)} \\<bullet> f (xs ! i)) = foldr (\\<and>) (map f xs) true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> i \\<in> dom\\<^sub>l xs \\<bullet> f (xs ! i)) =\n    foldr (\\<and>) (map f xs) true", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Squnion> i \\<in> dom\\<^sub>l [] \\<bullet> f ([] ! i)) =\n    foldr (\\<and>) (map f []) true\n 2. \\<And>a xs.\n       (\\<Squnion> i \\<in> dom\\<^sub>l xs \\<bullet> f (xs ! i)) =\n       foldr (\\<and>) (map f xs) true \\<Longrightarrow>\n       (\\<Squnion> i \\<in> dom\\<^sub>l\n                            (a # xs) \\<bullet> f ((a # xs) ! i)) =\n       foldr (\\<and>) (map f (a # xs)) true", "apply (rel_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       (\\<Squnion> i \\<in> dom\\<^sub>l xs \\<bullet> f (xs ! i)) =\n       foldr (\\<and>) (map f xs) true \\<Longrightarrow>\n       (\\<Squnion> i \\<in> dom\\<^sub>l\n                            (a # xs) \\<bullet> f ((a # xs) ! i)) =\n       foldr (\\<and>) (map f (a # xs)) true", "apply (simp_all add: USUP_upto_expand_first USUP_Suc_shift)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma UINF_refines:\n  \"\\<lbrakk> \\<And> i. i\\<in>I \\<Longrightarrow> P \\<sqsubseteq> Q i \\<rbrakk> \\<Longrightarrow> P \\<sqsubseteq> (\\<Sqinter> i\\<in>I \\<bullet> Q i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> I \\<Longrightarrow> P \\<sqsubseteq> Q i) \\<Longrightarrow>\n    P \\<sqsubseteq> (\\<Sqinter> i \\<in> I \\<bullet> Q i)", "by (simp add: UINF_as_Sup_collect, metis SUP_least)"], ["", "lemma UINF_refines':\n  assumes \"\\<And> i. P \\<sqsubseteq> Q(i)\" \n  shows \"P \\<sqsubseteq> (\\<Sqinter> i \\<bullet> Q(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> (\\<Sqinter> i \\<bullet> Q i)", "using assms"], ["proof (prove)\nusing this:\n  P \\<sqsubseteq> Q ?i\n\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> (\\<Sqinter> i \\<bullet> Q i)", "apply (rel_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>\\<And>i.\n                   \\<forall>A.\n                      \\<lbrakk>Q i\\<rbrakk>\\<^sub>e A\n                      \\<le> \\<lbrakk>P\\<rbrakk>\\<^sub>e A;\n        \\<And>i. P \\<sqsubseteq> Q i\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter>{uu_.\n                                    \\<exists>x.\n uu_ = \\<lbrakk>Q x\\<rbrakk>\\<^sub>e A}\n                         \\<le> \\<lbrakk>P\\<rbrakk>\\<^sub>e A", "using Sup_le_iff"], ["proof (prove)\nusing this:\n  (\\<Sqinter>?A \\<le> ?b) = (\\<forall>a\\<in>?A. a \\<le> ?b)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>\\<And>i.\n                   \\<forall>A.\n                      \\<lbrakk>Q i\\<rbrakk>\\<^sub>e A\n                      \\<le> \\<lbrakk>P\\<rbrakk>\\<^sub>e A;\n        \\<And>i. P \\<sqsubseteq> Q i\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter>{uu_.\n                                    \\<exists>x.\n uu_ = \\<lbrakk>Q x\\<rbrakk>\\<^sub>e A}\n                         \\<le> \\<lbrakk>P\\<rbrakk>\\<^sub>e A", "by fastforce"], ["", "lemma UINF_pred_ueq [simp]: \n  \"(\\<Sqinter> x | \\<guillemotleft>x\\<guillemotright> =\\<^sub>u v \\<bullet> P(x)) = (P x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> x | \\<guillemotleft>x\\<guillemotright> =\\<^sub>u\n                    v \\<bullet> P x) =\n    msubst P v", "by (pred_auto)"], ["", "lemma UINF_pred_lit_eq [simp]: \n  \"(\\<Sqinter> x | \\<guillemotleft>x = v\\<guillemotright> \\<bullet> P(x)) = (P v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> x | \\<guillemotleft>x = v\\<guillemotright> \\<bullet> P x) =\n    P v", "by (pred_auto)"], ["", "subsection \\<open> Equality laws \\<close>"], ["", "lemma eq_upred_refl [simp]: \"(x =\\<^sub>u x) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x =\\<^sub>u x) = true", "by (pred_auto)"], ["", "lemma eq_upred_sym: \"(x =\\<^sub>u y) = (y =\\<^sub>u x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x =\\<^sub>u y) = (y =\\<^sub>u x)", "by (pred_auto)"], ["", "lemma eq_cong_left:\n  assumes \"vwb_lens x\" \"$x \\<sharp> Q\" \"$x\\<acute> \\<sharp> Q\" \"$x \\<sharp> R\" \"$x\\<acute> \\<sharp> R\"\n  shows \"(($x\\<acute> =\\<^sub>u $x \\<and> Q) = ($x\\<acute> =\\<^sub>u $x \\<and> R)) \\<longleftrightarrow> (Q = R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (($x\\<acute> =\\<^sub>u $x \\<and> Q) =\n     ($x\\<acute> =\\<^sub>u $x \\<and> R)) =\n    (Q = R)", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n  $x \\<sharp> Q\n  $x\\<acute> \\<sharp> Q\n  $x \\<sharp> R\n  $x\\<acute> \\<sharp> R\n\ngoal (1 subgoal):\n 1. (($x\\<acute> =\\<^sub>u $x \\<and> Q) =\n     ($x\\<acute> =\\<^sub>u $x \\<and> R)) =\n    (Q = R)", "by (pred_simp, (meson mwb_lens_def vwb_lens_mwb weak_lens_def)+)"], ["", "lemma conj_eq_in_var_subst:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"vwb_lens x\"\n  shows \"(P \\<and> $x =\\<^sub>u v) = (P\\<lbrakk>v/$x\\<rbrakk> \\<and> $x =\\<^sub>u v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> $x =\\<^sub>u v) =\n    (P\\<lbrakk>v/$x\\<rbrakk> \\<and> $x =\\<^sub>u v)", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. (P \\<and> $x =\\<^sub>u v) =\n    (P\\<lbrakk>v/$x\\<rbrakk> \\<and> $x =\\<^sub>u v)", "by (pred_simp, (metis vwb_lens_wb wb_lens.get_put)+)"], ["", "lemma conj_eq_out_var_subst:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"vwb_lens x\"\n  shows \"(P \\<and> $x\\<acute> =\\<^sub>u v) = (P\\<lbrakk>v/$x\\<acute>\\<rbrakk> \\<and> $x\\<acute> =\\<^sub>u v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> $x\\<acute> =\\<^sub>u v) =\n    (P\\<lbrakk>v/$x\\<acute>\\<rbrakk> \\<and> $x\\<acute> =\\<^sub>u v)", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. (P \\<and> $x\\<acute> =\\<^sub>u v) =\n    (P\\<lbrakk>v/$x\\<acute>\\<rbrakk> \\<and> $x\\<acute> =\\<^sub>u v)", "by (pred_simp, (metis vwb_lens_wb wb_lens.get_put)+)"], ["", "lemma conj_pos_var_subst:\n  assumes \"vwb_lens x\"\n  shows \"($x \\<and> Q) = ($x \\<and> Q\\<lbrakk>true/$x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($x \\<and> Q) = ($x \\<and> Q\\<lbrakk>true/$x\\<rbrakk>)", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. ($x \\<and> Q) = ($x \\<and> Q\\<lbrakk>true/$x\\<rbrakk>)", "by (pred_auto, metis (full_types) vwb_lens_wb wb_lens.get_put, metis (full_types) vwb_lens_wb wb_lens.get_put)"], ["", "lemma conj_neg_var_subst:\n  assumes \"vwb_lens x\"\n  shows \"(\\<not> $x \\<and> Q) = (\\<not> $x \\<and> Q\\<lbrakk>false/$x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> $x \\<and> Q) = (\\<not> $x \\<and> Q\\<lbrakk>false/$x\\<rbrakk>)", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. (\\<not> $x \\<and> Q) = (\\<not> $x \\<and> Q\\<lbrakk>false/$x\\<rbrakk>)", "by (pred_auto, metis (full_types) vwb_lens_wb wb_lens.get_put, metis (full_types) vwb_lens_wb wb_lens.get_put)"], ["", "lemma upred_eq_true [simp]: \"(p =\\<^sub>u true) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p =\\<^sub>u true) = p", "by (pred_auto)"], ["", "lemma upred_eq_false [simp]: \"(p =\\<^sub>u false) = (\\<not> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p =\\<^sub>u false) = (\\<not> p)", "by (pred_auto)"], ["", "lemma upred_true_eq [simp]: \"(true =\\<^sub>u p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true =\\<^sub>u p) = p", "by (pred_auto)"], ["", "lemma upred_false_eq [simp]: \"(false =\\<^sub>u p) = (\\<not> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false =\\<^sub>u p) = (\\<not> p)", "by (pred_auto)"], ["", "lemma conj_var_subst:\n  assumes \"vwb_lens x\"\n  shows \"(P \\<and> var x =\\<^sub>u v) = (P\\<lbrakk>v/x\\<rbrakk> \\<and> var x =\\<^sub>u v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> x =\\<^sub>u v) = (P\\<lbrakk>v/x\\<rbrakk> \\<and> x =\\<^sub>u v)", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. (P \\<and> x =\\<^sub>u v) = (P\\<lbrakk>v/x\\<rbrakk> \\<and> x =\\<^sub>u v)", "by (pred_simp, (metis (full_types) vwb_lens_def wb_lens.get_put)+)"], ["", "subsection \\<open> HOL Variable Quantifiers \\<close>"], ["", "lemma shEx_unbound [simp]: \"(\\<^bold>\\<exists> x \\<bullet> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>\\<exists> x \\<bullet> P) = P", "by (pred_auto)"], ["", "lemma shEx_bool [simp]: \"shEx P = (P True \\<or> P False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ushEx P = (P True \\<or> P False)", "by (pred_simp, metis (full_types))"], ["", "lemma shEx_commute: \"(\\<^bold>\\<exists> x \\<bullet> \\<^bold>\\<exists> y \\<bullet> P x y) = (\\<^bold>\\<exists> y \\<bullet> \\<^bold>\\<exists> x \\<bullet> P x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>\\<exists> x \\<bullet> ushEx (P x)) =\n    (\\<^bold>\\<exists> y \\<bullet> \\<^bold>\\<exists> x \\<bullet> P x y)", "by (pred_auto)"], ["", "lemma shEx_cong: \"\\<lbrakk> \\<And> x. P x = Q x \\<rbrakk> \\<Longrightarrow> shEx P = shEx Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. P x = Q x) \\<Longrightarrow> ushEx P = ushEx Q", "by (pred_auto)"], ["", "lemma shEx_insert: \"(\\<^bold>\\<exists> x \\<in> insert\\<^sub>u y A \\<bullet> P(x)) = (P(x)\\<lbrakk>x\\<rightarrow>y\\<rbrakk> \\<or> (\\<^bold>\\<exists> x \\<in> A \\<bullet> P(x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>\\<exists> x \\<bullet> \\<guillemotleft>x\\<guillemotright> \\<in>\\<^sub>u\n                                   insert\\<^sub>u y A \\<and>\n                                   P x) =\n    (msubst P y \\<or>\n     (\\<^bold>\\<exists> x \\<bullet> \\<guillemotleft>x\\<guillemotright> \\<in>\\<^sub>u\n                                    A \\<and>\n                                    P x))", "by (pred_auto)"], ["", "lemma shEx_one_point: \"(\\<^bold>\\<exists> x \\<bullet> \\<guillemotleft>x\\<guillemotright> =\\<^sub>u v \\<and> P(x)) = P(x)\\<lbrakk>x\\<rightarrow>v\\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>\\<exists> x \\<bullet> \\<guillemotleft>x\\<guillemotright> =\\<^sub>u\n                                   v \\<and>\n                                   P x) =\n    msubst P v", "by (rel_auto)"], ["", "lemma shAll_unbound [simp]: \"(\\<^bold>\\<forall> x \\<bullet> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>\\<forall> x \\<bullet> P) = P", "by (pred_auto)"], ["", "lemma shAll_bool [simp]: \"shAll P = (P True \\<and> P False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ushAll P = (P True \\<and> P False)", "by (pred_simp, metis (full_types))"], ["", "lemma shAll_cong: \"\\<lbrakk> \\<And> x. P x = Q x \\<rbrakk> \\<Longrightarrow> shAll P = shAll Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. P x = Q x) \\<Longrightarrow> ushAll P = ushAll Q", "by (pred_auto)"], ["", "text \\<open> Quantifier lifting \\<close>"], ["", "named_theorems uquant_lift"], ["", "lemma shEx_lift_conj_1 [uquant_lift]:\n  \"((\\<^bold>\\<exists> x \\<bullet> P(x)) \\<and> Q) = (\\<^bold>\\<exists> x \\<bullet> P(x) \\<and> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ushEx P \\<and> Q) = (\\<^bold>\\<exists> x \\<bullet> P x \\<and> Q)", "by (pred_auto)"], ["", "lemma shEx_lift_conj_2 [uquant_lift]:\n  \"(P \\<and> (\\<^bold>\\<exists> x \\<bullet> Q(x))) = (\\<^bold>\\<exists> x \\<bullet> P \\<and> Q(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> ushEx Q) = (\\<^bold>\\<exists> x \\<bullet> P \\<and> Q x)", "by (pred_auto)"], ["", "subsection \\<open> Case Splitting \\<close>"], ["", "lemma eq_split_subst:\n  assumes \"vwb_lens x\"\n  shows \"(P = Q) \\<longleftrightarrow> (\\<forall> v. P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk> = Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P = Q) =\n    (\\<forall>v.\n        P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk> =\n        Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>)", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. (P = Q) =\n    (\\<forall>v.\n        P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk> =\n        Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>)", "by (pred_auto, metis vwb_lens_wb wb_lens.source_stability)"], ["", "lemma eq_split_substI:\n  assumes \"vwb_lens x\" \"\\<And> v. P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk> = Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>\"\n  shows \"P = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Q", "using assms(1) assms(2) eq_split_subst"], ["proof (prove)\nusing this:\n  vwb_lens x\n  P\\<lbrakk>\\<guillemotleft>?v\\<guillemotright>/x\\<rbrakk> =\n  Q\\<lbrakk>\\<guillemotleft>?v\\<guillemotright>/x\\<rbrakk>\n  vwb_lens ?x \\<Longrightarrow>\n  (?P = ?Q) =\n  (\\<forall>v.\n      ?P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/?x\\<rbrakk> =\n      ?Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/?x\\<rbrakk>)\n\ngoal (1 subgoal):\n 1. P = Q", "by blast"], ["", "lemma taut_split_subst:\n  assumes \"vwb_lens x\"\n  shows \"`P` \\<longleftrightarrow> (\\<forall> v. `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. `P` =\n    (\\<forall>v. `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`)", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. `P` =\n    (\\<forall>v. `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`)", "by (pred_auto, metis vwb_lens_wb wb_lens.source_stability)"], ["", "lemma eq_split:\n  assumes \"`P \\<Rightarrow> Q`\" \"`Q \\<Rightarrow> P`\"\n  shows \"P = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Q", "using assms"], ["proof (prove)\nusing this:\n  `P \\<Rightarrow> Q`\n  `Q \\<Rightarrow> P`\n\ngoal (1 subgoal):\n 1. P = Q", "by (pred_auto)"], ["", "lemma bool_eq_splitI:\n  assumes \"vwb_lens x\" \"P\\<lbrakk>true/x\\<rbrakk> = Q\\<lbrakk>true/x\\<rbrakk>\" \"P\\<lbrakk>false/x\\<rbrakk> = Q\\<lbrakk>false/x\\<rbrakk>\"\n  shows \"P = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Q", "by (metis (full_types) assms eq_split_subst false_alt_def true_alt_def)"], ["", "lemma subst_bool_split:\n  assumes \"vwb_lens x\"\n  shows \"`P` = `(P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>)`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. `P` = `P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>`", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. `P` = `P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>`", "from assms"], ["proof (chain)\npicking this:\n  vwb_lens x", "have \"`P` = (\\<forall> v. `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`)\""], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. `P` =\n    (\\<forall>v. `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`)", "by (subst taut_split_subst[of x], auto)"], ["proof (state)\nthis:\n  `P` =\n  (\\<forall>v. `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`)\n\ngoal (1 subgoal):\n 1. `P` = `P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>`", "also"], ["proof (state)\nthis:\n  `P` =\n  (\\<forall>v. `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`)\n\ngoal (1 subgoal):\n 1. `P` = `P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>`", "have \"... = (`P\\<lbrakk>\\<guillemotleft>True\\<guillemotright>/x\\<rbrakk>` \\<and> `P\\<lbrakk>\\<guillemotleft>False\\<guillemotright>/x\\<rbrakk>`)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`) =\n    (`P\\<lbrakk>\\<guillemotleft>True\\<guillemotright>/x\\<rbrakk>` \\<and>\n     `P\\<lbrakk>\\<guillemotleft>False\\<guillemotright>/x\\<rbrakk>`)", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  (\\<forall>v. `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`) =\n  (`P\\<lbrakk>\\<guillemotleft>True\\<guillemotright>/x\\<rbrakk>` \\<and>\n   `P\\<lbrakk>\\<guillemotleft>False\\<guillemotright>/x\\<rbrakk>`)\n\ngoal (1 subgoal):\n 1. `P` = `P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>`", "also"], ["proof (state)\nthis:\n  (\\<forall>v. `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`) =\n  (`P\\<lbrakk>\\<guillemotleft>True\\<guillemotright>/x\\<rbrakk>` \\<and>\n   `P\\<lbrakk>\\<guillemotleft>False\\<guillemotright>/x\\<rbrakk>`)\n\ngoal (1 subgoal):\n 1. `P` = `P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>`", "have \"... = `(P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>)`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`P\\<lbrakk>\\<guillemotleft>True\\<guillemotright>/x\\<rbrakk>` \\<and>\n     `P\\<lbrakk>\\<guillemotleft>False\\<guillemotright>/x\\<rbrakk>`) =\n    `P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>`", "by (pred_auto)"], ["proof (state)\nthis:\n  (`P\\<lbrakk>\\<guillemotleft>True\\<guillemotright>/x\\<rbrakk>` \\<and>\n   `P\\<lbrakk>\\<guillemotleft>False\\<guillemotright>/x\\<rbrakk>`) =\n  `P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>`\n\ngoal (1 subgoal):\n 1. `P` = `P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>`", "finally"], ["proof (chain)\npicking this:\n  `P` = `P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>`", "show ?thesis"], ["proof (prove)\nusing this:\n  `P` = `P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>`\n\ngoal (1 subgoal):\n 1. `P` = `P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>`", "."], ["proof (state)\nthis:\n  `P` = `P\\<lbrakk>false/x\\<rbrakk> \\<and> P\\<lbrakk>true/x\\<rbrakk>`\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_eq_replace:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"(p\\<lbrakk>u/x\\<rbrakk> \\<and> u =\\<^sub>u v) = (p\\<lbrakk>v/x\\<rbrakk> \\<and> u =\\<^sub>u v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p\\<lbrakk>u/x\\<rbrakk> \\<and> u =\\<^sub>u v) =\n    (p\\<lbrakk>v/x\\<rbrakk> \\<and> u =\\<^sub>u v)", "by (pred_auto)"], ["", "subsection \\<open> UTP Quantifiers \\<close>"], ["", "lemma one_point:\n  assumes \"mwb_lens x\" \"x \\<sharp> v\"\n  shows \"(\\<exists> x \\<bullet> P \\<and> var x =\\<^sub>u v) = P\\<lbrakk>v/x\\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists> x \\<bullet> P \\<and> x =\\<^sub>u v) = P\\<lbrakk>v/x\\<rbrakk>", "using assms"], ["proof (prove)\nusing this:\n  mwb_lens x\n  x \\<sharp> v\n\ngoal (1 subgoal):\n 1. (\\<exists> x \\<bullet> P \\<and> x =\\<^sub>u v) = P\\<lbrakk>v/x\\<rbrakk>", "by (pred_auto)"], ["", "lemma exists_twice: \"mwb_lens x \\<Longrightarrow> (\\<exists> x \\<bullet> \\<exists> x \\<bullet> P) = (\\<exists> x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow>\n    (\\<exists> x \\<bullet> \\<exists> x \\<bullet> P) =\n    (\\<exists> x \\<bullet> P)", "by (pred_auto)"], ["", "lemma all_twice: \"mwb_lens x \\<Longrightarrow> (\\<forall> x \\<bullet> \\<forall> x \\<bullet> P) = (\\<forall> x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow>\n    (\\<forall> x \\<bullet> \\<forall> x \\<bullet> P) =\n    (\\<forall> x \\<bullet> P)", "by (pred_auto)"], ["", "lemma exists_sub: \"\\<lbrakk> mwb_lens y; x \\<subseteq>\\<^sub>L y \\<rbrakk> \\<Longrightarrow> (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) = (\\<exists> y \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens y; x \\<subseteq>\\<^sub>L y\\<rbrakk>\n    \\<Longrightarrow> (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) =\n                      (\\<exists> y \\<bullet> P)", "by (pred_auto)"], ["", "lemma all_sub: \"\\<lbrakk> mwb_lens y; x \\<subseteq>\\<^sub>L y \\<rbrakk> \\<Longrightarrow> (\\<forall> x \\<bullet> \\<forall> y \\<bullet> P) = (\\<forall> y \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens y; x \\<subseteq>\\<^sub>L y\\<rbrakk>\n    \\<Longrightarrow> (\\<forall> x \\<bullet> \\<forall> y \\<bullet> P) =\n                      (\\<forall> y \\<bullet> P)", "by (pred_auto)"], ["", "lemma ex_commute:\n  assumes \"x \\<bowtie> y\"\n  shows \"(\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) = (\\<exists> y \\<bullet> \\<exists> x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) =\n    (\\<exists> y \\<bullet> \\<exists> x \\<bullet> P)", "using assms"], ["proof (prove)\nusing this:\n  x \\<bowtie> y\n\ngoal (1 subgoal):\n 1. (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) =\n    (\\<exists> y \\<bullet> \\<exists> x \\<bullet> P)", "apply (pred_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b v va.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> b v) va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v va.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (put\\<^bsub>x\\<^esub>\n                               (put\\<^bsub>y\\<^esub> b v) va)\n 2. \\<And>b v va.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> b v) va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v va.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (put\\<^bsub>y\\<^esub>\n                               (put\\<^bsub>x\\<^esub> b v) va)", "using lens_indep_comm"], ["proof (prove)\nusing this:\n  ?x \\<bowtie> ?y \\<Longrightarrow>\n  put\\<^bsub>?x\\<^esub> (put\\<^bsub>?y\\<^esub> ?\\<sigma> ?v) ?u =\n  put\\<^bsub>?y\\<^esub> (put\\<^bsub>?x\\<^esub> ?\\<sigma> ?u) ?v\n\ngoal (2 subgoals):\n 1. \\<And>b v va.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> b v) va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v va.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (put\\<^bsub>x\\<^esub>\n                               (put\\<^bsub>y\\<^esub> b v) va)\n 2. \\<And>b v va.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e\n         (put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> b v) va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v va.\n                            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                             (put\\<^bsub>y\\<^esub>\n                               (put\\<^bsub>x\\<^esub> b v) va)", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma all_commute:\n  assumes \"x \\<bowtie> y\"\n  shows \"(\\<forall> x \\<bullet> \\<forall> y \\<bullet> P) = (\\<forall> y \\<bullet> \\<forall> x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall> x \\<bullet> \\<forall> y \\<bullet> P) =\n    (\\<forall> y \\<bullet> \\<forall> x \\<bullet> P)", "using assms"], ["proof (prove)\nusing this:\n  x \\<bowtie> y\n\ngoal (1 subgoal):\n 1. (\\<forall> x \\<bullet> \\<forall> y \\<bullet> P) =\n    (\\<forall> y \\<bullet> \\<forall> x \\<bullet> P)", "apply (pred_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b v va.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<forall>v va.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e\n            (put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> b v) va)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                          (put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> b v)\n                            va)\n 2. \\<And>b v va.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<forall>v va.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e\n            (put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> b v) va)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                          (put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> b v)\n                            va)", "using lens_indep_comm"], ["proof (prove)\nusing this:\n  ?x \\<bowtie> ?y \\<Longrightarrow>\n  put\\<^bsub>?x\\<^esub> (put\\<^bsub>?y\\<^esub> ?\\<sigma> ?v) ?u =\n  put\\<^bsub>?y\\<^esub> (put\\<^bsub>?x\\<^esub> ?\\<sigma> ?u) ?v\n\ngoal (2 subgoals):\n 1. \\<And>b v va.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<forall>v va.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e\n            (put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> b v) va)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                          (put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> b v)\n                            va)\n 2. \\<And>b v va.\n       \\<lbrakk>x \\<bowtie> y;\n        \\<forall>v va.\n           \\<lbrakk>P\\<rbrakk>\\<^sub>e\n            (put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> b v) va)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                          (put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> b v)\n                            va)", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ex_equiv:\n  assumes \"x \\<approx>\\<^sub>L y\"\n  shows \"(\\<exists> x \\<bullet> P) = (\\<exists> y \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists> x \\<bullet> P) = (\\<exists> y \\<bullet> P)", "using assms"], ["proof (prove)\nusing this:\n  x \\<approx>\\<^sub>L y\n\ngoal (1 subgoal):\n 1. (\\<exists> x \\<bullet> P) = (\\<exists> y \\<bullet> P)", "by (pred_simp, metis (no_types, lifting) lens.select_convs(2))"], ["", "lemma all_equiv:\n  assumes \"x \\<approx>\\<^sub>L y\"\n  shows \"(\\<forall> x \\<bullet> P) = (\\<forall> y \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall> x \\<bullet> P) = (\\<forall> y \\<bullet> P)", "using assms"], ["proof (prove)\nusing this:\n  x \\<approx>\\<^sub>L y\n\ngoal (1 subgoal):\n 1. (\\<forall> x \\<bullet> P) = (\\<forall> y \\<bullet> P)", "by (pred_simp, metis (no_types, lifting) lens.select_convs(2))"], ["", "lemma ex_zero:\n  \"(\\<exists> \\<emptyset> \\<bullet> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists> \\<emptyset> \\<bullet> P) = P", "by (pred_auto)"], ["", "lemma all_zero:\n  \"(\\<forall> \\<emptyset> \\<bullet> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall> \\<emptyset> \\<bullet> P) = P", "by (pred_auto)"], ["", "lemma ex_plus:\n  \"(\\<exists> y;x \\<bullet> P) = (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists> {y, x} \\<bullet> P) =\n    (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P)", "by (pred_auto)"], ["", "lemma all_plus:\n  \"(\\<forall> y;x \\<bullet> P) = (\\<forall> x \\<bullet> \\<forall> y \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall> {y, x} \\<bullet> P) =\n    (\\<forall> x \\<bullet> \\<forall> y \\<bullet> P)", "by (pred_auto)"], ["", "lemma closure_all:\n  \"[P]\\<^sub>u = (\\<forall> \\<Sigma> \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [P]\\<^sub>u = (\\<forall> \\<Sigma> \\<bullet> P)", "by (pred_auto)"], ["", "lemma unrest_as_exists:\n  \"vwb_lens x \\<Longrightarrow> (x \\<sharp> P) \\<longleftrightarrow> ((\\<exists> x \\<bullet> P) = P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow>\n    (x \\<sharp> P) = ((\\<exists> x \\<bullet> P) = P)", "by (pred_simp, metis vwb_lens.put_eq)"], ["", "lemma ex_mono: \"P \\<sqsubseteq> Q \\<Longrightarrow> (\\<exists> x \\<bullet> P) \\<sqsubseteq> (\\<exists> x \\<bullet> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> Q \\<Longrightarrow>\n    (\\<exists> x \\<bullet> P) \\<sqsubseteq> (\\<exists> x \\<bullet> Q)", "by (pred_auto)"], ["", "lemma ex_weakens: \"wb_lens x \\<Longrightarrow> (\\<exists> x \\<bullet> P) \\<sqsubseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens x \\<Longrightarrow> (\\<exists> x \\<bullet> P) \\<sqsubseteq> P", "by (pred_simp, metis wb_lens.get_put)"], ["", "lemma all_mono: \"P \\<sqsubseteq> Q \\<Longrightarrow> (\\<forall> x \\<bullet> P) \\<sqsubseteq> (\\<forall> x \\<bullet> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> Q \\<Longrightarrow>\n    (\\<forall> x \\<bullet> P) \\<sqsubseteq> (\\<forall> x \\<bullet> Q)", "by (pred_auto)"], ["", "lemma all_strengthens: \"wb_lens x \\<Longrightarrow> P \\<sqsubseteq> (\\<forall> x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens x \\<Longrightarrow> P \\<sqsubseteq> (\\<forall> x \\<bullet> P)", "by (pred_simp, metis wb_lens.get_put)"], ["", "lemma ex_unrest: \"x \\<sharp> P \\<Longrightarrow> (\\<exists> x \\<bullet> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> P \\<Longrightarrow> (\\<exists> x \\<bullet> P) = P", "by (pred_auto)"], ["", "lemma all_unrest: \"x \\<sharp> P \\<Longrightarrow> (\\<forall> x \\<bullet> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> P \\<Longrightarrow> (\\<forall> x \\<bullet> P) = P", "by (pred_auto)"], ["", "lemma not_ex_not: \"\\<not> (\\<exists> x \\<bullet> \\<not> P) = (\\<forall> x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists> x \\<bullet> \\<not> P) = (\\<forall> x \\<bullet> P)", "by (pred_auto)"], ["", "lemma not_all_not: \"\\<not> (\\<forall> x \\<bullet> \\<not> P) = (\\<exists> x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall> x \\<bullet> \\<not> P) = (\\<exists> x \\<bullet> P)", "by (pred_auto)"], ["", "lemma ex_conj_contr_left: \"x \\<sharp> P \\<Longrightarrow> (\\<exists> x \\<bullet> P \\<and> Q) = (P \\<and> (\\<exists> x \\<bullet> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> P \\<Longrightarrow>\n    (\\<exists> x \\<bullet> P \\<and> Q) =\n    (P \\<and> (\\<exists> x \\<bullet> Q))", "by (pred_auto)"], ["", "lemma ex_conj_contr_right: \"x \\<sharp> Q \\<Longrightarrow> (\\<exists> x \\<bullet> P \\<and> Q) = ((\\<exists> x \\<bullet> P) \\<and> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> Q \\<Longrightarrow>\n    (\\<exists> x \\<bullet> P \\<and> Q) =\n    ((\\<exists> x \\<bullet> P) \\<and> Q)", "by (pred_auto)"], ["", "subsection \\<open> Variable Restriction \\<close>"], ["", "lemma var_res_all: \n  \"P \\<restriction>\\<^sub>v \\<Sigma> = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<restriction>\\<^sub>v \\<Sigma> = P", "by (rel_auto)"], ["", "lemma var_res_twice: \n  \"mwb_lens x \\<Longrightarrow> P \\<restriction>\\<^sub>v x \\<restriction>\\<^sub>v x = P \\<restriction>\\<^sub>v x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow>\n    P \\<restriction>\\<^sub>v x \\<restriction>\\<^sub>v x =\n    P \\<restriction>\\<^sub>v x", "by (pred_auto)"], ["", "subsection \\<open> Conditional laws \\<close>"], ["", "lemma cond_def:\n  \"(P \\<triangleleft> b \\<triangleright> Q) = ((b \\<and> P) \\<or> ((\\<not> b) \\<and> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<triangleleft> b \\<triangleright> Q =\n    (b \\<and> P \\<or> \\<not> b \\<and> Q)", "by (pred_auto)"], ["", "lemma cond_idem [simp]:\"(P \\<triangleleft> b \\<triangleright> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<triangleleft> b \\<triangleright> P = P", "by (pred_auto)"], ["", "lemma cond_true_false [simp]: \"true \\<triangleleft> b \\<triangleright> false = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. true \\<triangleleft> b \\<triangleright> false = b", "by (pred_auto)"], ["", "lemma cond_symm:\"(P \\<triangleleft> b \\<triangleright> Q) = (Q \\<triangleleft> \\<not> b \\<triangleright> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<triangleleft> b \\<triangleright> Q =\n    Q \\<triangleleft> \\<not> b \\<triangleright> P", "by (pred_auto)"], ["", "lemma cond_assoc: \"((P \\<triangleleft> b \\<triangleright> Q) \\<triangleleft> c \\<triangleright> R) = (P \\<triangleleft> b \\<and> c \\<triangleright> (Q \\<triangleleft> c \\<triangleright> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<triangleleft> b \\<triangleright>\n       Q \\<triangleleft> c \\<triangleright>\n       R =\n    P \\<triangleleft> b \\<and> c \\<triangleright>\n       (Q \\<triangleleft> c \\<triangleright> R)", "by (pred_auto)"], ["", "lemma cond_distr: \"(P \\<triangleleft> b \\<triangleright> (Q \\<triangleleft> c \\<triangleright> R)) = ((P \\<triangleleft> b \\<triangleright> Q) \\<triangleleft> c \\<triangleright> (P \\<triangleleft> b \\<triangleright> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<triangleleft> b \\<triangleright>\n       (Q \\<triangleleft> c \\<triangleright> R) =\n    P \\<triangleleft> b \\<triangleright>\n       Q \\<triangleleft> c \\<triangleright>\n       (P \\<triangleleft> b \\<triangleright> R)", "by (pred_auto)"], ["", "lemma cond_unit_T [simp]:\"(P \\<triangleleft> true \\<triangleright> Q) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<triangleleft> true \\<triangleright> Q = P", "by (pred_auto)"], ["", "lemma cond_unit_F [simp]:\"(P \\<triangleleft> false \\<triangleright> Q) = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<triangleleft> false \\<triangleright> Q = Q", "by (pred_auto)"], ["", "lemma cond_conj_not: \"((P \\<triangleleft> b \\<triangleright> Q) \\<and> (\\<not> b)) = (Q \\<and> (\\<not> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> b \\<triangleright> Q \\<and> \\<not> b) =\n    (Q \\<and> \\<not> b)", "by (rel_auto)"], ["", "lemma cond_and_T_integrate:\n  \"((P \\<and> b) \\<or> (Q \\<triangleleft> b \\<triangleright> R)) = ((P \\<or> Q) \\<triangleleft> b \\<triangleright> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> b \\<or> Q \\<triangleleft> b \\<triangleright> R) =\n    (P \\<or> Q) \\<triangleleft> b \\<triangleright> R", "by (pred_auto)"], ["", "lemma cond_L6: \"(P \\<triangleleft> b \\<triangleright> (Q \\<triangleleft> b \\<triangleright> R)) = (P \\<triangleleft> b \\<triangleright> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<triangleleft> b \\<triangleright>\n       (Q \\<triangleleft> b \\<triangleright> R) =\n    P \\<triangleleft> b \\<triangleright> R", "by (pred_auto)"], ["", "lemma cond_L7: \"(P \\<triangleleft> b \\<triangleright> (P \\<triangleleft> c \\<triangleright> Q)) = (P \\<triangleleft> b \\<or> c \\<triangleright> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<triangleleft> b \\<triangleright>\n       (P \\<triangleleft> c \\<triangleright> Q) =\n    P \\<triangleleft> b \\<or> c \\<triangleright> Q", "by (pred_auto)"], ["", "lemma cond_and_distr: \"((P \\<and> Q) \\<triangleleft> b \\<triangleright> (R \\<and> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<and> (Q \\<triangleleft> b \\<triangleright> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> Q) \\<triangleleft> b \\<triangleright> (R \\<and> S) =\n    (P \\<triangleleft> b \\<triangleright> R \\<and>\n     Q \\<triangleleft> b \\<triangleright> S)", "by (pred_auto)"], ["", "lemma cond_or_distr: \"((P \\<or> Q) \\<triangleleft> b \\<triangleright> (R \\<or> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<or> (Q \\<triangleleft> b \\<triangleright> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q) \\<triangleleft> b \\<triangleright> (R \\<or> S) =\n    (P \\<triangleleft> b \\<triangleright> R \\<or>\n     Q \\<triangleleft> b \\<triangleright> S)", "by (pred_auto)"], ["", "lemma cond_imp_distr:\n\"((P \\<Rightarrow> Q) \\<triangleleft> b \\<triangleright> (R \\<Rightarrow> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<Rightarrow> (Q \\<triangleleft> b \\<triangleright> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Rightarrow> Q) \\<triangleleft> b \\<triangleright>\n       (R \\<Rightarrow> S) =\n    (P \\<triangleleft> b \\<triangleright> R \\<Rightarrow>\n     Q \\<triangleleft> b \\<triangleright> S)", "by (pred_auto)"], ["", "lemma cond_eq_distr:\n\"((P \\<Leftrightarrow> Q) \\<triangleleft> b \\<triangleright> (R \\<Leftrightarrow> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<Leftrightarrow> (Q \\<triangleleft> b \\<triangleright> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Leftrightarrow> Q) \\<triangleleft> b \\<triangleright>\n       (R \\<Leftrightarrow> S) =\n    (P \\<triangleleft> b \\<triangleright> R \\<Leftrightarrow>\n     Q \\<triangleleft> b \\<triangleright> S)", "by (pred_auto)"], ["", "lemma cond_conj_distr:\"(P \\<and> (Q \\<triangleleft> b \\<triangleright> S)) = ((P \\<and> Q) \\<triangleleft> b \\<triangleright> (P \\<and> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> Q \\<triangleleft> b \\<triangleright> S) =\n    (P \\<and> Q) \\<triangleleft> b \\<triangleright> (P \\<and> S)", "by (pred_auto)"], ["", "lemma cond_disj_distr:\"(P \\<or> (Q \\<triangleleft> b \\<triangleright> S)) = ((P \\<or> Q) \\<triangleleft> b \\<triangleright> (P \\<or> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q \\<triangleleft> b \\<triangleright> S) =\n    (P \\<or> Q) \\<triangleleft> b \\<triangleright> (P \\<or> S)", "by (pred_auto)"], ["", "lemma cond_neg: \"\\<not> (P \\<triangleleft> b \\<triangleright> Q) = ((\\<not> P) \\<triangleleft> b \\<triangleright> (\\<not> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P \\<triangleleft> b \\<triangleright> Q =\n           (\\<not> P) \\<triangleleft> b \\<triangleright> (\\<not> Q)", "by (pred_auto)"], ["", "lemma cond_conj: \"P \\<triangleleft> b \\<and> c \\<triangleright> Q = (P \\<triangleleft> c \\<triangleright> Q) \\<triangleleft> b \\<triangleright> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<triangleleft> b \\<and> c \\<triangleright> Q =\n    P \\<triangleleft> c \\<triangleright>\n       Q \\<triangleleft> b \\<triangleright>\n       Q", "by (pred_auto)"], ["", "lemma spec_cond_dist: \"(P \\<Rightarrow> (Q \\<triangleleft> b \\<triangleright> R)) = ((P \\<Rightarrow> Q) \\<triangleleft> b \\<triangleright> (P \\<Rightarrow> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Rightarrow> Q \\<triangleleft> b \\<triangleright> R) =\n    (P \\<Rightarrow> Q) \\<triangleleft> b \\<triangleright>\n       (P \\<Rightarrow> R)", "by (pred_auto)"], ["", "lemma cond_USUP_dist: \"(\\<Squnion> P\\<in>S \\<bullet> F(P)) \\<triangleleft> b \\<triangleright> (\\<Squnion> P\\<in>S \\<bullet> G(P)) = (\\<Squnion> P\\<in>S \\<bullet> F(P) \\<triangleleft> b \\<triangleright> G(P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> P \\<in> S \\<bullet> F P) \\<triangleleft> b \\<triangleright>\n       (\\<Squnion> P \\<in> S \\<bullet> G P) =\n    (\\<Squnion> P \\<in> S \\<bullet> F P \\<triangleleft> b \\<triangleright>\n G P)", "by (pred_auto)"], ["", "lemma cond_UINF_dist: \"(\\<Sqinter> P\\<in>S \\<bullet> F(P)) \\<triangleleft> b \\<triangleright> (\\<Sqinter> P\\<in>S \\<bullet> G(P)) = (\\<Sqinter> P\\<in>S \\<bullet> F(P) \\<triangleleft> b \\<triangleright> G(P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter> P \\<in> S \\<bullet> F P) \\<triangleleft> b \\<triangleright>\n       (\\<Sqinter> P \\<in> S \\<bullet> G P) =\n    (\\<Sqinter> P \\<in> S \\<bullet> F P \\<triangleleft> b \\<triangleright>\n G P)", "by (pred_auto)"], ["", "lemma cond_var_subst_left:\n  assumes \"vwb_lens x\"\n  shows \"(P\\<lbrakk>true/x\\<rbrakk> \\<triangleleft> var x \\<triangleright> Q) = (P \\<triangleleft> var x \\<triangleright> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<lbrakk>true/x\\<rbrakk> \\<triangleleft> x \\<triangleright> Q =\n    P \\<triangleleft> x \\<triangleright> Q", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. P\\<lbrakk>true/x\\<rbrakk> \\<triangleleft> x \\<triangleright> Q =\n    P \\<triangleleft> x \\<triangleright> Q", "by (pred_auto, metis (full_types) vwb_lens_wb wb_lens.get_put)"], ["", "lemma cond_var_subst_right:\n  assumes \"vwb_lens x\"\n  shows \"(P \\<triangleleft> var x \\<triangleright> Q\\<lbrakk>false/x\\<rbrakk>) = (P \\<triangleleft> var x \\<triangleright> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<triangleleft> x \\<triangleright> Q\\<lbrakk>false/x\\<rbrakk> =\n    P \\<triangleleft> x \\<triangleright> Q", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n\ngoal (1 subgoal):\n 1. P \\<triangleleft> x \\<triangleright> Q\\<lbrakk>false/x\\<rbrakk> =\n    P \\<triangleleft> x \\<triangleright> Q", "by (pred_auto, metis (full_types) vwb_lens.put_eq)"], ["", "lemma cond_var_split:\n  \"vwb_lens x \\<Longrightarrow> (P\\<lbrakk>true/x\\<rbrakk> \\<triangleleft> var x \\<triangleright> P\\<lbrakk>false/x\\<rbrakk>) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow>\n    P\\<lbrakk>true/x\\<rbrakk> \\<triangleleft> x \\<triangleright>\n       P\\<lbrakk>false/x\\<rbrakk> =\n    P", "by (rel_simp, (metis (full_types) vwb_lens.put_eq)+)"], ["", "lemma cond_assign_subst:\n  \"vwb_lens x \\<Longrightarrow> (P \\<triangleleft> utp_expr.var x =\\<^sub>u v \\<triangleright> Q) = (P\\<lbrakk>v/x\\<rbrakk> \\<triangleleft> utp_expr.var x =\\<^sub>u v \\<triangleright> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow>\n    P \\<triangleleft> x =\\<^sub>u v \\<triangleright> Q =\n    P\\<lbrakk>v/x\\<rbrakk> \\<triangleleft> x =\\<^sub>u v \\<triangleright> Q", "apply (rel_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>vwb_lens x;\n        get\\<^bsub>x\\<^esub> b = \\<lbrakk>v\\<rbrakk>\\<^sub>e b\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>P\\<rbrakk>\\<^sub>e b =\n                         \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                          (put\\<^bsub>x\\<^esub> b\n                            (\\<lbrakk>v\\<rbrakk>\\<^sub>e b))", "using vwb_lens.put_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>vwb_lens ?x; get\\<^bsub>?x\\<^esub> ?\\<sigma> = ?k;\n   put\\<^bsub>?x\\<^esub> ?\\<sigma> ?u =\n   put\\<^bsub>?x\\<^esub> ?\\<rho> ?v\\<rbrakk>\n  \\<Longrightarrow> put\\<^bsub>?x\\<^esub> ?\\<rho> ?k = ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>vwb_lens x;\n        get\\<^bsub>x\\<^esub> b = \\<lbrakk>v\\<rbrakk>\\<^sub>e b\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>P\\<rbrakk>\\<^sub>e b =\n                         \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                          (put\\<^bsub>x\\<^esub> b\n                            (\\<lbrakk>v\\<rbrakk>\\<^sub>e b))", "by force"], ["", "lemma conj_conds: \n  \"(P1 \\<triangleleft> b \\<triangleright> Q1 \\<and> P2 \\<triangleleft> b \\<triangleright> Q2) = (P1 \\<and> P2) \\<triangleleft> b \\<triangleright> (Q1 \\<and> Q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P1 \\<triangleleft> b \\<triangleright> Q1 \\<and>\n     P2 \\<triangleleft> b \\<triangleright> Q2) =\n    (P1 \\<and> P2) \\<triangleleft> b \\<triangleright> (Q1 \\<and> Q2)", "by pred_auto"], ["", "lemma disj_conds:\n  \"(P1 \\<triangleleft> b \\<triangleright> Q1 \\<or> P2 \\<triangleleft> b \\<triangleright> Q2) = (P1 \\<or> P2) \\<triangleleft> b \\<triangleright> (Q1 \\<or> Q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P1 \\<triangleleft> b \\<triangleright> Q1 \\<or>\n     P2 \\<triangleleft> b \\<triangleright> Q2) =\n    (P1 \\<or> P2) \\<triangleleft> b \\<triangleright> (Q1 \\<or> Q2)", "by pred_auto"], ["", "lemma cond_mono:\n  \"\\<lbrakk> P\\<^sub>1 \\<sqsubseteq> P\\<^sub>2; Q\\<^sub>1 \\<sqsubseteq> Q\\<^sub>2 \\<rbrakk> \\<Longrightarrow> (P\\<^sub>1 \\<triangleleft> b \\<triangleright> Q\\<^sub>1) \\<sqsubseteq> (P\\<^sub>2 \\<triangleleft> b \\<triangleright> Q\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P\\<^sub>1 \\<sqsubseteq> P\\<^sub>2;\n     Q\\<^sub>1 \\<sqsubseteq> Q\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> P\\<^sub>1 \\<triangleleft> b \\<triangleright>\n                         Q\\<^sub>1 \\<sqsubseteq>\n                      P\\<^sub>2 \\<triangleleft> b \\<triangleright> Q\\<^sub>2", "by (rel_auto)"], ["", "lemma cond_monotonic:\n  \"\\<lbrakk> mono P; mono Q \\<rbrakk> \\<Longrightarrow> mono (\\<lambda> X. P X \\<triangleleft> b \\<triangleright> Q X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono P; mono Q\\<rbrakk>\n    \\<Longrightarrow> mono\n                       (\\<lambda>X.\n                           P X \\<triangleleft> b \\<triangleright> Q X)", "by (simp add: mono_def, rel_blast)"], ["", "subsection \\<open> Additional Expression Laws \\<close>"], ["", "lemma le_pred_refl [simp]:\n  fixes x :: \"('a::preorder, '\\<alpha>) uexpr\"\n  shows \"(x \\<le>\\<^sub>u x) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le>\\<^sub>u x) = true", "by (pred_auto)"], ["", "lemma uzero_le_laws [simp]:\n  \"(0 :: ('a::{linordered_semidom}, '\\<alpha>) uexpr) \\<le>\\<^sub>u numeral x = true\"\n  \"(1 :: ('a::{linordered_semidom}, '\\<alpha>) uexpr) \\<le>\\<^sub>u numeral x = true\"\n  \"(0 :: ('a::{linordered_semidom}, '\\<alpha>) uexpr) \\<le>\\<^sub>u 1 = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le>\\<^sub>u numeral x) = true &&&\n    (1 \\<le>\\<^sub>u numeral x) = true &&& (0 \\<le>\\<^sub>u 1) = true", "by (pred_simp)+"], ["", "lemma unumeral_le_1 [simp]:\n  assumes \"(numeral i :: 'a::{numeral,ord}) \\<le> numeral j\"\n  shows \"(numeral i :: ('a, '\\<alpha>) uexpr) \\<le>\\<^sub>u numeral j = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (numeral i \\<le>\\<^sub>u numeral j) = true", "using assms"], ["proof (prove)\nusing this:\n  numeral i \\<le> numeral j\n\ngoal (1 subgoal):\n 1. (numeral i \\<le>\\<^sub>u numeral j) = true", "by (pred_auto)"], ["", "lemma unumeral_le_2 [simp]:\n  assumes \"(numeral i :: 'a::{numeral,linorder}) > numeral j\"\n  shows \"(numeral i :: ('a, '\\<alpha>) uexpr) \\<le>\\<^sub>u numeral j = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (numeral i \\<le>\\<^sub>u numeral j) = false", "using assms"], ["proof (prove)\nusing this:\n  numeral j < numeral i\n\ngoal (1 subgoal):\n 1. (numeral i \\<le>\\<^sub>u numeral j) = false", "by (pred_auto)"], ["", "lemma uset_laws [simp]:\n  \"x \\<in>\\<^sub>u {}\\<^sub>u = false\"\n  \"x \\<in>\\<^sub>u {m..n}\\<^sub>u = (m \\<le>\\<^sub>u x \\<and> x \\<le>\\<^sub>u n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in>\\<^sub>u {}\\<^sub>u) = false &&&\n    (x \\<in>\\<^sub>u {m..n}\\<^sub>u) =\n    (m \\<le>\\<^sub>u x \\<and> x \\<le>\\<^sub>u n)", "by (pred_auto)+"], ["", "lemma ulit_eq [simp]: \"x = y \\<Longrightarrow> (\\<guillemotleft>x\\<guillemotright> =\\<^sub>u \\<guillemotleft>y\\<guillemotright>) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow>\n    (\\<guillemotleft>x\\<guillemotright> =\\<^sub>u\n     \\<guillemotleft>y\\<guillemotright>) =\n    true", "by (rel_auto)"], ["", "lemma ulit_neq [simp]: \"x \\<noteq> y \\<Longrightarrow> (\\<guillemotleft>x\\<guillemotright> =\\<^sub>u \\<guillemotleft>y\\<guillemotright>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x = y \\<Longrightarrow>\n    (\\<guillemotleft>x\\<guillemotright> =\\<^sub>u\n     \\<guillemotleft>y\\<guillemotright>) =\n    false", "by (rel_auto)"], ["", "lemma uset_mems [simp]:\n  \"x \\<in>\\<^sub>u {y}\\<^sub>u = (x =\\<^sub>u y)\"\n  \"x \\<in>\\<^sub>u A \\<union>\\<^sub>u B = (x \\<in>\\<^sub>u A \\<or> x \\<in>\\<^sub>u B)\"\n  \"x \\<in>\\<^sub>u A \\<inter>\\<^sub>u B = (x \\<in>\\<^sub>u A \\<and> x \\<in>\\<^sub>u B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in>\\<^sub>u {y}\\<^sub>u) = (x =\\<^sub>u y) &&&\n    (x \\<in>\\<^sub>u A \\<union>\\<^sub>u B) =\n    (x \\<in>\\<^sub>u A \\<or> x \\<in>\\<^sub>u B) &&&\n    (x \\<in>\\<^sub>u A \\<inter>\\<^sub>u B) =\n    (x \\<in>\\<^sub>u A \\<and> x \\<in>\\<^sub>u B)", "by (rel_auto)+"], ["", "subsection \\<open> Refinement By Observation \\<close>"], ["", "text \\<open> Function to obtain the set of observations of a predicate \\<close>"], ["", "definition obs_upred :: \"'\\<alpha> upred \\<Rightarrow> '\\<alpha> set\" (\"\\<lbrakk>_\\<rbrakk>\\<^sub>o\")\nwhere [upred_defs]: \"\\<lbrakk>P\\<rbrakk>\\<^sub>o = {b. \\<lbrakk>P\\<rbrakk>\\<^sub>eb}\""], ["", "lemma obs_upred_refine_iff: \n  \"P \\<sqsubseteq> Q \\<longleftrightarrow> \\<lbrakk>Q\\<rbrakk>\\<^sub>o \\<subseteq> \\<lbrakk>P\\<rbrakk>\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<sqsubseteq> Q) =\n    (\\<lbrakk>Q\\<rbrakk>\\<^sub>o \\<subseteq> \\<lbrakk>P\\<rbrakk>\\<^sub>o)", "by (pred_auto)"], ["", "text \\<open> A refinement can be demonstrated by considering only the observations of the predicates\n  which are relevant, i.e. not unrestricted, for them. In other words, if the alphabet can\n  be split into two disjoint segments, $x$ and $y$, and neither predicate refers to $y$ then\n  only $x$ need be considered when checking for observations. \\<close>"], ["", "lemma refine_by_obs:\n  assumes \"x \\<bowtie> y\" \"bij_lens (x +\\<^sub>L y)\" \"y \\<sharp> P\" \"y \\<sharp> Q\" \"{v. `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`} \\<subseteq> {v. `Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`}\"\n  shows \"Q \\<sqsubseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> P", "using assms(3-5)"], ["proof (prove)\nusing this:\n  y \\<sharp> P\n  y \\<sharp> Q\n  {v. `P\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`}\n  \\<subseteq> {v. `Q\\<lbrakk>\\<guillemotleft>v\\<guillemotright>/x\\<rbrakk>`}\n\ngoal (1 subgoal):\n 1. Q \\<sqsubseteq> P", "apply (simp add: obs_upred_refine_iff subset_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<sharp> P; y \\<sharp> Q;\n     \\<forall>xa.\n        `P\\<lbrakk>\\<guillemotleft>xa\\<guillemotright>/x\\<rbrakk>` \\<longrightarrow>\n        `Q\\<lbrakk>\\<guillemotleft>xa\\<guillemotright>/x\\<rbrakk>`\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>\\<lbrakk>P\\<rbrakk>\\<^sub>o.\n                         x \\<in> \\<lbrakk>Q\\<rbrakk>\\<^sub>o", "apply (pred_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b v) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e b;\n        \\<forall>b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e b;\n        \\<forall>xa.\n           (\\<forall>b.\n               \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                (put\\<^bsub>x\\<^esub> b xa)) \\<longrightarrow>\n           (\\<forall>b.\n               \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> b xa));\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e xa\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Q\\<rbrakk>\\<^sub>e xa", "apply (rename_tac b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<forall>b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b v) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e b;\n        \\<forall>b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e b;\n        \\<forall>xa.\n           (\\<forall>b.\n               \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                (put\\<^bsub>x\\<^esub> b xa)) \\<longrightarrow>\n           (\\<forall>b.\n               \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>x\\<^esub> b xa));\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e b\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Q\\<rbrakk>\\<^sub>e b", "apply (drule_tac x=\"get\\<^bsub>x\\<^esub>b\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<forall>b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b v) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e b;\n        \\<forall>b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e b;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e b;\n        (\\<forall>ba.\n            \\<lbrakk>P\\<rbrakk>\\<^sub>e\n             (put\\<^bsub>x\\<^esub> ba\n               (get\\<^bsub>x\\<^esub> b))) \\<longrightarrow>\n        (\\<forall>ba.\n            \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n             (put\\<^bsub>x\\<^esub> ba (get\\<^bsub>x\\<^esub> b)))\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Q\\<rbrakk>\\<^sub>e b", "apply (auto simp add: assms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b ba.\n       \\<lbrakk>\\<forall>b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b v) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e b;\n        \\<forall>b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e b;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e b;\n        \\<not> \\<lbrakk>Q\\<rbrakk>\\<^sub>e b\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>P\\<rbrakk>\\<^sub>e\n                          (put\\<^bsub>x\\<^esub> ba (get\\<^bsub>x\\<^esub> b))\n 2. \\<And>b.\n       \\<lbrakk>\\<forall>b v.\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b v) =\n                   \\<lbrakk>P\\<rbrakk>\\<^sub>e b;\n        \\<forall>b v.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e (put\\<^bsub>y\\<^esub> b v) =\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e b;\n        \\<lbrakk>P\\<rbrakk>\\<^sub>e b;\n        \\<forall>ba.\n           \\<lbrakk>Q\\<rbrakk>\\<^sub>e\n            (put\\<^bsub>x\\<^esub> ba (get\\<^bsub>x\\<^esub> b))\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Q\\<rbrakk>\\<^sub>e b", "apply (metis assms(1) assms(2) bij_lens.axioms(2) bij_lens_axioms_def lens_override_def lens_override_plus)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open> Cylindric Algebra \\<close>"], ["", "lemma C1: \"(\\<exists> x \\<bullet> false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists> x \\<bullet> false) = false", "by (pred_auto)"], ["", "lemma C2: \"wb_lens x \\<Longrightarrow> `P \\<Rightarrow> (\\<exists> x \\<bullet> P)`\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens x \\<Longrightarrow> `P \\<Rightarrow> (\\<exists> x \\<bullet> P)`", "by (pred_simp, metis wb_lens.get_put)"], ["", "lemma C3: \"mwb_lens x \\<Longrightarrow> (\\<exists> x \\<bullet> (P \\<and> (\\<exists> x \\<bullet> Q))) = ((\\<exists> x \\<bullet> P) \\<and> (\\<exists> x \\<bullet> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow>\n    (\\<exists> x \\<bullet> P \\<and> (\\<exists> x \\<bullet> Q)) =\n    ((\\<exists> x \\<bullet> P) \\<and> (\\<exists> x \\<bullet> Q))", "by (pred_auto)"], ["", "lemma C4a: \"x \\<approx>\\<^sub>L y \\<Longrightarrow> (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) = (\\<exists> y \\<bullet> \\<exists> x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<approx>\\<^sub>L y \\<Longrightarrow>\n    (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) =\n    (\\<exists> y \\<bullet> \\<exists> x \\<bullet> P)", "by (pred_simp, metis (no_types, lifting) lens.select_convs(2))+"], ["", "lemma C4b: \"x \\<bowtie> y \\<Longrightarrow> (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) = (\\<exists> y \\<bullet> \\<exists> x \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bowtie> y \\<Longrightarrow>\n    (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) =\n    (\\<exists> y \\<bullet> \\<exists> x \\<bullet> P)", "using ex_commute"], ["proof (prove)\nusing this:\n  ?x \\<bowtie> ?y \\<Longrightarrow>\n  (\\<exists> ?x \\<bullet> \\<exists> ?y \\<bullet> ?P) =\n  (\\<exists> ?y \\<bullet> \\<exists> ?x \\<bullet> ?P)\n\ngoal (1 subgoal):\n 1. x \\<bowtie> y \\<Longrightarrow>\n    (\\<exists> x \\<bullet> \\<exists> y \\<bullet> P) =\n    (\\<exists> y \\<bullet> \\<exists> x \\<bullet> P)", "by blast"], ["", "lemma C5:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"(&x =\\<^sub>u &x) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (&x =\\<^sub>u &x) = true", "by (pred_auto)"], ["", "lemma C6:\n  assumes \"wb_lens x\" \"x \\<bowtie> y\" \"x \\<bowtie> z\"\n  shows \"(&y =\\<^sub>u &z) = (\\<exists> x \\<bullet> &y =\\<^sub>u &x \\<and> &x =\\<^sub>u &z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (&y =\\<^sub>u &z) =\n    (\\<exists> x \\<bullet> &y =\\<^sub>u &x \\<and> &x =\\<^sub>u &z)", "using assms"], ["proof (prove)\nusing this:\n  wb_lens x\n  x \\<bowtie> y\n  x \\<bowtie> z\n\ngoal (1 subgoal):\n 1. (&y =\\<^sub>u &z) =\n    (\\<exists> x \\<bullet> &y =\\<^sub>u &x \\<and> &x =\\<^sub>u &z)", "by (pred_simp, (metis lens_indep_def)+)"], ["", "lemma C7:\n  assumes \"weak_lens x\" \"x \\<bowtie> y\"\n  shows \"((\\<exists> x \\<bullet> &x =\\<^sub>u &y \\<and> P) \\<and> (\\<exists> x \\<bullet> &x =\\<^sub>u &y \\<and> \\<not> P)) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists> x \\<bullet> &x =\\<^sub>u &y \\<and> P) \\<and>\n     (\\<exists> x \\<bullet> &x =\\<^sub>u &y \\<and> \\<not> P)) =\n    false", "using assms"], ["proof (prove)\nusing this:\n  weak_lens x\n  x \\<bowtie> y\n\ngoal (1 subgoal):\n 1. ((\\<exists> x \\<bullet> &x =\\<^sub>u &y \\<and> P) \\<and>\n     (\\<exists> x \\<bullet> &x =\\<^sub>u &y \\<and> \\<not> P)) =\n    false", "by (pred_simp, simp add: lens_indep_sym)"], ["", "end"]]}