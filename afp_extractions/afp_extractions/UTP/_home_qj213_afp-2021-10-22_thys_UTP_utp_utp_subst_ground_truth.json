{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/utp/utp_subst.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["lemma usubst_lookup_id [usubst]: \"\\<langle>id\\<rangle>\\<^sub>s x = var x\"", "lemma subst_upd_id_lam [usubst]: \"subst_upd (\\<lambda> x. x) x v = subst_upd id x v\"", "lemma usubst_lookup_upd [usubst]:\n  assumes \"weak_lens x\"\n  shows \"\\<langle>\\<sigma>(x \\<mapsto>\\<^sub>s v)\\<rangle>\\<^sub>s x = v\"", "lemma usubst_lookup_upd_pr_var [usubst]:\n  assumes \"weak_lens x\"\n  shows \"\\<langle>\\<sigma>(x \\<mapsto>\\<^sub>s v)\\<rangle>\\<^sub>s (pr_var x) = v\"", "lemma usubst_upd_idem [usubst]:\n  assumes \"mwb_lens x\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s u, x \\<mapsto>\\<^sub>s v) = \\<sigma>(x \\<mapsto>\\<^sub>s v)\"", "lemma usubst_upd_idem_sub [usubst]:\n  assumes \"x \\<subseteq>\\<^sub>L y\" \"mwb_lens y\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v) = \\<sigma>(y \\<mapsto>\\<^sub>s v)\"", "lemma usubst_upd_comm:\n  assumes \"x \\<bowtie> y\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v) = \\<sigma>(y \\<mapsto>\\<^sub>s v, x \\<mapsto>\\<^sub>s u)\"", "lemma usubst_upd_comm2:\n  assumes \"z \\<bowtie> y\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v, z \\<mapsto>\\<^sub>s s) = \\<sigma>(x \\<mapsto>\\<^sub>s u, z \\<mapsto>\\<^sub>s s, y \\<mapsto>\\<^sub>s v)\"", "lemma subst_upd_pr_var: \"s(&x \\<mapsto>\\<^sub>s v) = s(x \\<mapsto>\\<^sub>s v)\"", "lemma swap_usubst_inj:\n  fixes x y :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"vwb_lens x\" \"vwb_lens y\" \"x \\<bowtie> y\"\n  shows \"inj [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x]\"", "lemma usubst_upd_var_id [usubst]:\n  \"vwb_lens x \\<Longrightarrow> [x \\<mapsto>\\<^sub>s var x] = id\"", "lemma usubst_upd_pr_var_id [usubst]:\n  \"vwb_lens x \\<Longrightarrow> [x \\<mapsto>\\<^sub>s var (pr_var x)] = id\"", "lemma usubst_upd_comm_dash [usubst]:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"\\<sigma>($x\\<acute> \\<mapsto>\\<^sub>s v, $x \\<mapsto>\\<^sub>s u) = \\<sigma>($x \\<mapsto>\\<^sub>s u, $x\\<acute> \\<mapsto>\\<^sub>s v)\"", "lemma subst_upd_lens_plus [usubst]: \n  \"subst_upd \\<sigma> (x +\\<^sub>L y) \\<guillemotleft>(u,v)\\<guillemotright> = \\<sigma>(y \\<mapsto>\\<^sub>s \\<guillemotleft>v\\<guillemotright>, x \\<mapsto>\\<^sub>s \\<guillemotleft>u\\<guillemotright>)\"", "lemma subst_upd_in_lens_plus [usubst]: \n  \"subst_upd \\<sigma> (ivar (x +\\<^sub>L y)) \\<guillemotleft>(u,v)\\<guillemotright> = \\<sigma>($y \\<mapsto>\\<^sub>s \\<guillemotleft>v\\<guillemotright>, $x \\<mapsto>\\<^sub>s \\<guillemotleft>u\\<guillemotright>)\"", "lemma subst_upd_out_lens_plus [usubst]: \n  \"subst_upd \\<sigma> (ovar (x +\\<^sub>L y)) \\<guillemotleft>(u,v)\\<guillemotright> = \\<sigma>($y\\<acute> \\<mapsto>\\<^sub>s \\<guillemotleft>v\\<guillemotright>, $x\\<acute> \\<mapsto>\\<^sub>s \\<guillemotleft>u\\<guillemotright>)\"", "lemma usubst_lookup_upd_indep [usubst]:\n  assumes \"mwb_lens x\" \"x \\<bowtie> y\"\n  shows \"\\<langle>\\<sigma>(y \\<mapsto>\\<^sub>s v)\\<rangle>\\<^sub>s x = \\<langle>\\<sigma>\\<rangle>\\<^sub>s x\"", "lemma subst_upd_plus [usubst]: \n  \"x \\<bowtie> y \\<Longrightarrow> subst_upd s (x +\\<^sub>L y) e = s(x \\<mapsto>\\<^sub>s \\<pi>\\<^sub>1(e), y \\<mapsto>\\<^sub>s \\<pi>\\<^sub>2(e))\"", "lemma usubst_apply_unrest [usubst]:\n  \"\\<lbrakk> vwb_lens x; x \\<sharp> \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<langle>\\<sigma>\\<rangle>\\<^sub>s x = var x\"", "lemma subst_del_id [usubst]:\n  \"vwb_lens x \\<Longrightarrow> id -\\<^sub>s x = id\"", "lemma subst_del_upd_same [usubst]:\n  \"mwb_lens x \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) -\\<^sub>s x = \\<sigma> -\\<^sub>s x\"", "lemma subst_del_upd_diff [usubst]:\n  \"x \\<bowtie> y \\<Longrightarrow> \\<sigma>(y \\<mapsto>\\<^sub>s v) -\\<^sub>s x = (\\<sigma> -\\<^sub>s x)(y \\<mapsto>\\<^sub>s v)\"", "lemma subst_unrest [usubst]: \"x \\<sharp> P \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> P = \\<sigma> \\<dagger> P\"", "lemma subst_unrest_2 [usubst]: \n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"x \\<sharp> P\" \"x \\<bowtie> y\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s u,y \\<mapsto>\\<^sub>s v) \\<dagger> P = \\<sigma>(y \\<mapsto>\\<^sub>s v) \\<dagger> P\"", "lemma subst_unrest_3 [usubst]: \n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"x \\<sharp> P\" \"x \\<bowtie> y\" \"x \\<bowtie> z\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v, z \\<mapsto>\\<^sub>s w) \\<dagger> P = \\<sigma>(y \\<mapsto>\\<^sub>s v, z \\<mapsto>\\<^sub>s w) \\<dagger> P\"", "lemma subst_unrest_4 [usubst]: \n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"x \\<sharp> P\" \"x \\<bowtie> y\" \"x \\<bowtie> z\" \"x \\<bowtie> u\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s e, y \\<mapsto>\\<^sub>s f, z \\<mapsto>\\<^sub>s g, u \\<mapsto>\\<^sub>s h) \\<dagger> P = \\<sigma>(y \\<mapsto>\\<^sub>s f, z \\<mapsto>\\<^sub>s g, u \\<mapsto>\\<^sub>s h) \\<dagger> P\"", "lemma subst_unrest_5 [usubst]: \n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"x \\<sharp> P\" \"x \\<bowtie> y\" \"x \\<bowtie> z\" \"x \\<bowtie> u\" \"x \\<bowtie> v\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s e, y \\<mapsto>\\<^sub>s f, z \\<mapsto>\\<^sub>s g, u \\<mapsto>\\<^sub>s h, v \\<mapsto>\\<^sub>s i) \\<dagger> P = \\<sigma>(y \\<mapsto>\\<^sub>s f, z \\<mapsto>\\<^sub>s g, u \\<mapsto>\\<^sub>s h, v \\<mapsto>\\<^sub>s i) \\<dagger> P\"", "lemma subst_compose_upd [usubst]: \"x \\<sharp> \\<sigma> \\<Longrightarrow> \\<sigma> \\<circ> \\<rho>(x \\<mapsto>\\<^sub>s v) = (\\<sigma> \\<circ> \\<rho>)(x \\<mapsto>\\<^sub>s v) \"", "lemma subst_mono: \"mono (subst \\<sigma>)\"", "lemma id_subst [usubst]: \"id \\<dagger> v = v\"", "lemma subst_lit [usubst]: \"\\<sigma> \\<dagger> \\<guillemotleft>v\\<guillemotright> = \\<guillemotleft>v\\<guillemotright>\"", "lemma subst_var [usubst]: \"\\<sigma> \\<dagger> var x = \\<langle>\\<sigma>\\<rangle>\\<^sub>s x\"", "lemma usubst_ulambda [usubst]: \"\\<sigma> \\<dagger> (\\<lambda> x \\<bullet> P(x)) = (\\<lambda> x \\<bullet> \\<sigma> \\<dagger> P(x))\"", "lemma unrest_usubst_del [unrest]: \"\\<lbrakk> vwb_lens x; x \\<sharp> (\\<langle>\\<sigma>\\<rangle>\\<^sub>s x); x \\<sharp> \\<sigma> -\\<^sub>s x \\<rbrakk> \\<Longrightarrow>  x \\<sharp> (\\<sigma> \\<dagger> P)\"", "lemma subst_uop [usubst]: \"\\<sigma> \\<dagger> uop f v = uop f (\\<sigma> \\<dagger> v)\"", "lemma subst_bop [usubst]: \"\\<sigma> \\<dagger> bop f u v = bop f (\\<sigma> \\<dagger> u) (\\<sigma> \\<dagger> v)\"", "lemma subst_trop [usubst]: \"\\<sigma> \\<dagger> trop f u v w = trop f (\\<sigma> \\<dagger> u) (\\<sigma> \\<dagger> v) (\\<sigma> \\<dagger> w)\"", "lemma subst_qtop [usubst]: \"\\<sigma> \\<dagger> qtop f u v w x = qtop f (\\<sigma> \\<dagger> u) (\\<sigma> \\<dagger> v) (\\<sigma> \\<dagger> w) (\\<sigma> \\<dagger> x)\"", "lemma subst_case_prod [usubst]:\n  fixes P :: \"'i \\<Rightarrow> 'j \\<Rightarrow> ('a, '\\<alpha>) uexpr\"  \n  shows \"\\<sigma> \\<dagger> case_prod (\\<lambda> x y. P x y) v = case_prod (\\<lambda> x y. \\<sigma> \\<dagger> P x y) v\"", "lemma subst_plus [usubst]: \"\\<sigma> \\<dagger> (x + y) = \\<sigma> \\<dagger> x + \\<sigma> \\<dagger> y\"", "lemma subst_times [usubst]: \"\\<sigma> \\<dagger> (x * y) = \\<sigma> \\<dagger> x * \\<sigma> \\<dagger> y\"", "lemma subst_mod [usubst]: \"\\<sigma> \\<dagger> (x mod y) = \\<sigma> \\<dagger> x mod \\<sigma> \\<dagger> y\"", "lemma subst_div [usubst]: \"\\<sigma> \\<dagger> (x div y) = \\<sigma> \\<dagger> x div \\<sigma> \\<dagger> y\"", "lemma subst_minus [usubst]: \"\\<sigma> \\<dagger> (x - y) = \\<sigma> \\<dagger> x - \\<sigma> \\<dagger> y\"", "lemma subst_uminus [usubst]: \"\\<sigma> \\<dagger> (- x) = - (\\<sigma> \\<dagger> x)\"", "lemma usubst_sgn [usubst]: \"\\<sigma> \\<dagger> sgn x = sgn (\\<sigma> \\<dagger> x)\"", "lemma usubst_abs [usubst]: \"\\<sigma> \\<dagger> abs x = abs (\\<sigma> \\<dagger> x)\"", "lemma subst_zero [usubst]: \"\\<sigma> \\<dagger> 0 = 0\"", "lemma subst_one [usubst]: \"\\<sigma> \\<dagger> 1 = 1\"", "lemma subst_eq_upred [usubst]: \"\\<sigma> \\<dagger> (x =\\<^sub>u y) = (\\<sigma> \\<dagger> x =\\<^sub>u \\<sigma> \\<dagger> y)\"", "lemma subst_subst [usubst]: \"\\<sigma> \\<dagger> \\<rho> \\<dagger> e = (\\<rho> \\<circ> \\<sigma>) \\<dagger> e\"", "lemma subst_upd_comp [usubst]:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"\\<rho>(x \\<mapsto>\\<^sub>s v) \\<circ> \\<sigma> = (\\<rho> \\<circ> \\<sigma>)(x \\<mapsto>\\<^sub>s \\<sigma> \\<dagger> v)\"", "lemma subst_singleton:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"x \\<sharp> \\<sigma>\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> P = (\\<sigma> \\<dagger> P)\\<lbrakk>v/x\\<rbrakk>\"", "lemmas subst_to_singleton = subst_singleton id_subst", "lemma unrest_usubst_single [unrest]:\n  \"\\<lbrakk> mwb_lens x; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> P\\<lbrakk>v/x\\<rbrakk>\"", "lemma unrest_usubst_id [unrest]:\n  \"mwb_lens x \\<Longrightarrow> x \\<sharp> id\"", "lemma unrest_usubst_upd [unrest]:\n  \"\\<lbrakk> x \\<bowtie> y; x \\<sharp> \\<sigma>; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> \\<sigma>(y \\<mapsto>\\<^sub>s v)\"", "lemma unrest_subst [unrest]:\n  \"\\<lbrakk> x \\<sharp> P; x \\<sharp> \\<sigma> \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<sigma> \\<dagger> P)\"", "lemma usubst_cond_upd_1 [usubst]:\n  \"\\<sigma>(x \\<mapsto>\\<^sub>s u) \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho>(x \\<mapsto>\\<^sub>s v) = (\\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho>)(x \\<mapsto>\\<^sub>s u \\<triangleleft> b \\<triangleright> v)\"", "lemma usubst_cond_upd_2 [usubst]:\n  \"\\<lbrakk> vwb_lens x; x \\<sharp> \\<rho> \\<rbrakk> \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s u) \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho> = (\\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho>)(x \\<mapsto>\\<^sub>s u \\<triangleleft> b \\<triangleright> &x)\"", "lemma usubst_cond_upd_3 [usubst]:\n  \"\\<lbrakk> vwb_lens x; x \\<sharp> \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho>(x \\<mapsto>\\<^sub>s v) = (\\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho>)(x \\<mapsto>\\<^sub>s &x \\<triangleleft> b \\<triangleright> v)\"", "lemma usubst_cond_id [usubst]:\n  \"\\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s \\<sigma> = \\<sigma>\"", "lemma par_subst_id [usubst]:\n  \"\\<lbrakk> vwb_lens A; vwb_lens B \\<rbrakk> \\<Longrightarrow> id [A|B]\\<^sub>s id = id\"", "lemma par_subst_left_empty [usubst]:\n  \"\\<lbrakk> vwb_lens A \\<rbrakk> \\<Longrightarrow> \\<sigma> [\\<emptyset>|A]\\<^sub>s \\<rho> = id [\\<emptyset>|A]\\<^sub>s \\<rho>\"", "lemma par_subst_right_empty [usubst]:\n  \"\\<lbrakk> vwb_lens A \\<rbrakk> \\<Longrightarrow> \\<sigma> [A|\\<emptyset>]\\<^sub>s \\<rho> = \\<sigma> [A|\\<emptyset>]\\<^sub>s id\"", "lemma par_subst_comm:\n  \"\\<lbrakk> A \\<bowtie> B \\<rbrakk> \\<Longrightarrow> \\<sigma> [A|B]\\<^sub>s \\<rho> = \\<rho> [B|A]\\<^sub>s \\<sigma>\"", "lemma par_subst_upd_left_in [usubst]:\n  \"\\<lbrakk> vwb_lens A; A \\<bowtie> B; x \\<subseteq>\\<^sub>L A \\<rbrakk> \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) [A|B]\\<^sub>s \\<rho> = (\\<sigma> [A|B]\\<^sub>s \\<rho>)(x \\<mapsto>\\<^sub>s v)\"", "lemma par_subst_upd_left_out [usubst]:\n  \"\\<lbrakk> vwb_lens A; x \\<bowtie> A \\<rbrakk> \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) [A|B]\\<^sub>s \\<rho> = (\\<sigma> [A|B]\\<^sub>s \\<rho>)\"", "lemma par_subst_upd_right_in [usubst]:\n  \"\\<lbrakk> vwb_lens B; A \\<bowtie> B; x \\<subseteq>\\<^sub>L B \\<rbrakk> \\<Longrightarrow> \\<sigma> [A|B]\\<^sub>s \\<rho>(x \\<mapsto>\\<^sub>s v) = (\\<sigma> [A|B]\\<^sub>s \\<rho>)(x \\<mapsto>\\<^sub>s v)\"", "lemma par_subst_upd_right_out [usubst]:\n  \"\\<lbrakk> vwb_lens B; A \\<bowtie> B; x \\<bowtie> B \\<rbrakk> \\<Longrightarrow> \\<sigma> [A|B]\\<^sub>s \\<rho>(x \\<mapsto>\\<^sub>s v) = (\\<sigma> [A|B]\\<^sub>s \\<rho>)\""], "translations": [["", "lemma usubst_lookup_id [usubst]: \"\\<langle>id\\<rangle>\\<^sub>s x = var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>id\\<rangle>\\<^sub>s x = x", "by (transfer, simp)"], ["", "lemma subst_upd_id_lam [usubst]: \"subst_upd (\\<lambda> x. x) x v = subst_upd id x v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x)(x \\<mapsto>\\<^sub>s v) = [x \\<mapsto>\\<^sub>s v]", "by (simp add: id_def)"], ["", "text \\<open> A substitution update naturally yields the given expression. \\<close>"], ["", "lemma usubst_lookup_upd [usubst]:\n  assumes \"weak_lens x\"\n  shows \"\\<langle>\\<sigma>(x \\<mapsto>\\<^sub>s v)\\<rangle>\\<^sub>s x = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<sigma>(x \\<mapsto>\\<^sub>s v)\\<rangle>\\<^sub>s x = v", "using assms"], ["proof (prove)\nusing this:\n  weak_lens x\n\ngoal (1 subgoal):\n 1. \\<langle>\\<sigma>(x \\<mapsto>\\<^sub>s v)\\<rangle>\\<^sub>s x = v", "by (simp add: subst_upd_uvar_def, transfer) (simp)"], ["", "lemma usubst_lookup_upd_pr_var [usubst]:\n  assumes \"weak_lens x\"\n  shows \"\\<langle>\\<sigma>(x \\<mapsto>\\<^sub>s v)\\<rangle>\\<^sub>s (pr_var x) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<sigma>(x \\<mapsto>\\<^sub>s v)\\<rangle>\\<^sub>s (&x) = v", "using assms"], ["proof (prove)\nusing this:\n  weak_lens x\n\ngoal (1 subgoal):\n 1. \\<langle>\\<sigma>(x \\<mapsto>\\<^sub>s v)\\<rangle>\\<^sub>s (&x) = v", "by (simp add: subst_upd_uvar_def pr_var_def, transfer) (simp)"], ["", "text \\<open> Substitution update is idempotent. \\<close>"], ["", "lemma usubst_upd_idem [usubst]:\n  assumes \"mwb_lens x\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s u, x \\<mapsto>\\<^sub>s v) = \\<sigma>(x \\<mapsto>\\<^sub>s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s u, x \\<mapsto>\\<^sub>s v) = \\<sigma>(x \n    \\<mapsto>\\<^sub>s v)", "by (simp add: subst_upd_uvar_def assms comp_def)"], ["", "lemma usubst_upd_idem_sub [usubst]:\n  assumes \"x \\<subseteq>\\<^sub>L y\" \"mwb_lens y\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v) = \\<sigma>(y \\<mapsto>\\<^sub>s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v) = \\<sigma>(y \n    \\<mapsto>\\<^sub>s v)", "by (simp add: subst_upd_uvar_def assms comp_def fun_eq_iff sublens_put_put)"], ["", "text \\<open> Substitution updates commute when the lenses are independent. \\<close>"], ["", "lemma usubst_upd_comm:\n  assumes \"x \\<bowtie> y\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v) = \\<sigma>(y \\<mapsto>\\<^sub>s v, x \\<mapsto>\\<^sub>s u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v) = \\<sigma>(y \n    \\<mapsto>\\<^sub>s v, x \\<mapsto>\\<^sub>s u)", "using assms"], ["proof (prove)\nusing this:\n  x \\<bowtie> y\n\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v) = \\<sigma>(y \n    \\<mapsto>\\<^sub>s v, x \\<mapsto>\\<^sub>s u)", "by (rule_tac ext, auto simp add: subst_upd_uvar_def assms comp_def lens_indep_comm)"], ["", "lemma usubst_upd_comm2:\n  assumes \"z \\<bowtie> y\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v, z \\<mapsto>\\<^sub>s s) = \\<sigma>(x \\<mapsto>\\<^sub>s u, z \\<mapsto>\\<^sub>s s, y \\<mapsto>\\<^sub>s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v, z \n    \\<mapsto>\\<^sub>s s) = \\<sigma>(x \\<mapsto>\\<^sub>s u, z \n    \\<mapsto>\\<^sub>s s, y \\<mapsto>\\<^sub>s v)", "using assms"], ["proof (prove)\nusing this:\n  z \\<bowtie> y\n\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v, z \n    \\<mapsto>\\<^sub>s s) = \\<sigma>(x \\<mapsto>\\<^sub>s u, z \n    \\<mapsto>\\<^sub>s s, y \\<mapsto>\\<^sub>s v)", "by (rule_tac ext, auto simp add: subst_upd_uvar_def assms comp_def lens_indep_comm)"], ["", "lemma subst_upd_pr_var: \"s(&x \\<mapsto>\\<^sub>s v) = s(x \\<mapsto>\\<^sub>s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s(&x \\<mapsto>\\<^sub>s v) = s(x \\<mapsto>\\<^sub>s v)", "by (simp add: pr_var_def)"], ["", "text \\<open> A substitution which swaps two independent variables is an injective function. \\<close>"], ["", "lemma swap_usubst_inj:\n  fixes x y :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"vwb_lens x\" \"vwb_lens y\" \"x \\<bowtie> y\"\n  shows \"inj [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x]", "proof (rule injI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] xa =\n       [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] ya \\<Longrightarrow>\n       xa = ya", "fix b\\<^sub>1 :: '\\<alpha> and b\\<^sub>2 :: '\\<alpha>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] xa =\n       [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] ya \\<Longrightarrow>\n       xa = ya", "assume \"[x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] b\\<^sub>1 = [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] b\\<^sub>2\""], ["proof (state)\nthis:\n  [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] b\\<^sub>1 =\n  [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] b\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] xa =\n       [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] ya \\<Longrightarrow>\n       xa = ya", "hence a: \"put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> b\\<^sub>1 (\\<lbrakk>&y\\<rbrakk>\\<^sub>e b\\<^sub>1)) (\\<lbrakk>&x\\<rbrakk>\\<^sub>e b\\<^sub>1) = put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> b\\<^sub>2 (\\<lbrakk>&y\\<rbrakk>\\<^sub>e b\\<^sub>2)) (\\<lbrakk>&x\\<rbrakk>\\<^sub>e b\\<^sub>2)\""], ["proof (prove)\nusing this:\n  [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] b\\<^sub>1 =\n  [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] b\\<^sub>2\n\ngoal (1 subgoal):\n 1. put\\<^bsub>y\\<^esub>\n     (put\\<^bsub>x\\<^esub> b\\<^sub>1\n       (\\<lbrakk>&y\\<rbrakk>\\<^sub>e b\\<^sub>1))\n     (\\<lbrakk>&x\\<rbrakk>\\<^sub>e b\\<^sub>1) =\n    put\\<^bsub>y\\<^esub>\n     (put\\<^bsub>x\\<^esub> b\\<^sub>2\n       (\\<lbrakk>&y\\<rbrakk>\\<^sub>e b\\<^sub>2))\n     (\\<lbrakk>&x\\<rbrakk>\\<^sub>e b\\<^sub>2)", "by (auto simp add: subst_upd_uvar_def)"], ["proof (state)\nthis:\n  put\\<^bsub>y\\<^esub>\n   (put\\<^bsub>x\\<^esub> b\\<^sub>1 (\\<lbrakk>&y\\<rbrakk>\\<^sub>e b\\<^sub>1))\n   (\\<lbrakk>&x\\<rbrakk>\\<^sub>e b\\<^sub>1) =\n  put\\<^bsub>y\\<^esub>\n   (put\\<^bsub>x\\<^esub> b\\<^sub>2 (\\<lbrakk>&y\\<rbrakk>\\<^sub>e b\\<^sub>2))\n   (\\<lbrakk>&x\\<rbrakk>\\<^sub>e b\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] xa =\n       [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] ya \\<Longrightarrow>\n       xa = ya", "then"], ["proof (chain)\npicking this:\n  put\\<^bsub>y\\<^esub>\n   (put\\<^bsub>x\\<^esub> b\\<^sub>1 (\\<lbrakk>&y\\<rbrakk>\\<^sub>e b\\<^sub>1))\n   (\\<lbrakk>&x\\<rbrakk>\\<^sub>e b\\<^sub>1) =\n  put\\<^bsub>y\\<^esub>\n   (put\\<^bsub>x\\<^esub> b\\<^sub>2 (\\<lbrakk>&y\\<rbrakk>\\<^sub>e b\\<^sub>2))\n   (\\<lbrakk>&x\\<rbrakk>\\<^sub>e b\\<^sub>2)", "have \"(\\<forall>a b c. put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a b) c = put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> a c) b) \\<and> \n             (\\<forall>a b. get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a b) = get\\<^bsub>x\\<^esub> a) \\<and> (\\<forall>a b. get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> a b) = get\\<^bsub>y\\<^esub> a)\""], ["proof (prove)\nusing this:\n  put\\<^bsub>y\\<^esub>\n   (put\\<^bsub>x\\<^esub> b\\<^sub>1 (\\<lbrakk>&y\\<rbrakk>\\<^sub>e b\\<^sub>1))\n   (\\<lbrakk>&x\\<rbrakk>\\<^sub>e b\\<^sub>1) =\n  put\\<^bsub>y\\<^esub>\n   (put\\<^bsub>x\\<^esub> b\\<^sub>2 (\\<lbrakk>&y\\<rbrakk>\\<^sub>e b\\<^sub>2))\n   (\\<lbrakk>&x\\<rbrakk>\\<^sub>e b\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<forall>a b c.\n        put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a b) c =\n        put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> a c) b) \\<and>\n    (\\<forall>a b.\n        get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a b) =\n        get\\<^bsub>x\\<^esub> a) \\<and>\n    (\\<forall>a b.\n        get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> a b) =\n        get\\<^bsub>y\\<^esub> a)", "by (simp add: assms(3) lens_indep.lens_put_irr2 lens_indep_comm)"], ["proof (state)\nthis:\n  (\\<forall>a b c.\n      put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a b) c =\n      put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> a c) b) \\<and>\n  (\\<forall>a b.\n      get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a b) =\n      get\\<^bsub>x\\<^esub> a) \\<and>\n  (\\<forall>a b.\n      get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> a b) =\n      get\\<^bsub>y\\<^esub> a)\n\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] xa =\n       [x \\<mapsto>\\<^sub>s &y, y \\<mapsto>\\<^sub>s &x] ya \\<Longrightarrow>\n       xa = ya", "then"], ["proof (chain)\npicking this:\n  (\\<forall>a b c.\n      put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a b) c =\n      put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> a c) b) \\<and>\n  (\\<forall>a b.\n      get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a b) =\n      get\\<^bsub>x\\<^esub> a) \\<and>\n  (\\<forall>a b.\n      get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> a b) =\n      get\\<^bsub>y\\<^esub> a)", "show \"b\\<^sub>1 = b\\<^sub>2\""], ["proof (prove)\nusing this:\n  (\\<forall>a b c.\n      put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a b) c =\n      put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> a c) b) \\<and>\n  (\\<forall>a b.\n      get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> a b) =\n      get\\<^bsub>x\\<^esub> a) \\<and>\n  (\\<forall>a b.\n      get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> a b) =\n      get\\<^bsub>y\\<^esub> a)\n\ngoal (1 subgoal):\n 1. b\\<^sub>1 = b\\<^sub>2", "by (metis a assms(1) assms(2) pr_var_def var.rep_eq vwb_lens.source_determination vwb_lens_def wb_lens_def weak_lens.put_get)"], ["proof (state)\nthis:\n  b\\<^sub>1 = b\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma usubst_upd_var_id [usubst]:\n  \"vwb_lens x \\<Longrightarrow> [x \\<mapsto>\\<^sub>s var x] = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow> [x \\<mapsto>\\<^sub>s x] = id", "apply (simp add: subst_upd_uvar_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow>\n    (\\<lambda>b. put\\<^bsub>x\\<^esub> b (\\<lbrakk>x\\<rbrakk>\\<^sub>e b)) =\n    id", "apply (transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       vwb_lens x \\<Longrightarrow>\n       (\\<lambda>b. put\\<^bsub>x\\<^esub> b (get\\<^bsub>x\\<^esub> b)) = id", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x b.\n       vwb_lens x \\<Longrightarrow>\n       put\\<^bsub>x\\<^esub> b (get\\<^bsub>x\\<^esub> b) = id b", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma usubst_upd_pr_var_id [usubst]:\n  \"vwb_lens x \\<Longrightarrow> [x \\<mapsto>\\<^sub>s var (pr_var x)] = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow> [x \\<mapsto>\\<^sub>s &x] = id", "apply (simp add: subst_upd_uvar_def pr_var_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow>\n    (\\<lambda>b. put\\<^bsub>x\\<^esub> b (\\<lbrakk>x\\<rbrakk>\\<^sub>e b)) =\n    id", "apply (transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       vwb_lens x \\<Longrightarrow>\n       (\\<lambda>b. put\\<^bsub>x\\<^esub> b (get\\<^bsub>x\\<^esub> b)) = id", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x b.\n       vwb_lens x \\<Longrightarrow>\n       put\\<^bsub>x\\<^esub> b (get\\<^bsub>x\\<^esub> b) = id b", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma usubst_upd_comm_dash [usubst]:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"\\<sigma>($x\\<acute> \\<mapsto>\\<^sub>s v, $x \\<mapsto>\\<^sub>s u) = \\<sigma>($x \\<mapsto>\\<^sub>s u, $x\\<acute> \\<mapsto>\\<^sub>s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>($x\\<acute> \\<mapsto>\\<^sub>s v, $x \\<mapsto>\\<^sub>s u) =\n    \\<sigma>($x \\<mapsto>\\<^sub>s u, $x\\<acute> \\<mapsto>\\<^sub>s v)", "using out_in_indep usubst_upd_comm"], ["proof (prove)\nusing this:\n  $?x\\<acute> \\<bowtie> $?y\n  ?x \\<bowtie> ?y \\<Longrightarrow>\n  ?\\<sigma>(?x \\<mapsto>\\<^sub>s ?u, ?y \\<mapsto>\\<^sub>s ?v) = ?\\<sigma>\n  (?y \\<mapsto>\\<^sub>s ?v, ?x \\<mapsto>\\<^sub>s ?u)\n\ngoal (1 subgoal):\n 1. \\<sigma>($x\\<acute> \\<mapsto>\\<^sub>s v, $x \\<mapsto>\\<^sub>s u) =\n    \\<sigma>($x \\<mapsto>\\<^sub>s u, $x\\<acute> \\<mapsto>\\<^sub>s v)", "by blast"], ["", "lemma subst_upd_lens_plus [usubst]: \n  \"subst_upd \\<sigma> (x +\\<^sub>L y) \\<guillemotleft>(u,v)\\<guillemotright> = \\<sigma>(y \\<mapsto>\\<^sub>s \\<guillemotleft>v\\<guillemotright>, x \\<mapsto>\\<^sub>s \\<guillemotleft>u\\<guillemotright>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>(x +\\<^sub>L y \\<mapsto>\\<^sub>s\n    \\<guillemotleft>(u, v)\\<guillemotright>) = \\<sigma>(y \\<mapsto>\\<^sub>s\n    \\<guillemotleft>v\\<guillemotright>, x \\<mapsto>\\<^sub>s\n    \\<guillemotleft>u\\<guillemotright>)", "by (simp add: lens_defs uexpr_defs subst_upd_uvar_def, transfer, auto)"], ["", "lemma subst_upd_in_lens_plus [usubst]: \n  \"subst_upd \\<sigma> (ivar (x +\\<^sub>L y)) \\<guillemotleft>(u,v)\\<guillemotright> = \\<sigma>($y \\<mapsto>\\<^sub>s \\<guillemotleft>v\\<guillemotright>, $x \\<mapsto>\\<^sub>s \\<guillemotleft>u\\<guillemotright>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>($(x +\\<^sub>L y) \\<mapsto>\\<^sub>s\n    \\<guillemotleft>(u, v)\\<guillemotright>) = \\<sigma>($y \\<mapsto>\\<^sub>s\n    \\<guillemotleft>v\\<guillemotright>, $x \\<mapsto>\\<^sub>s\n    \\<guillemotleft>u\\<guillemotright>)", "by (simp add: lens_defs uexpr_defs subst_upd_uvar_def, transfer, auto simp add: prod.case_eq_if)"], ["", "lemma subst_upd_out_lens_plus [usubst]: \n  \"subst_upd \\<sigma> (ovar (x +\\<^sub>L y)) \\<guillemotleft>(u,v)\\<guillemotright> = \\<sigma>($y\\<acute> \\<mapsto>\\<^sub>s \\<guillemotleft>v\\<guillemotright>, $x\\<acute> \\<mapsto>\\<^sub>s \\<guillemotleft>u\\<guillemotright>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>($(x +\\<^sub>L y)\\<acute> \\<mapsto>\\<^sub>s\n    \\<guillemotleft>(u, v)\\<guillemotright>) = \\<sigma>($y\\<acute> \n    \\<mapsto>\\<^sub>s \\<guillemotleft>v\\<guillemotright>, $x\\<acute> \n    \\<mapsto>\\<^sub>s \\<guillemotleft>u\\<guillemotright>)", "by (simp add: lens_defs uexpr_defs subst_upd_uvar_def, transfer, auto simp add: prod.case_eq_if)"], ["", "lemma usubst_lookup_upd_indep [usubst]:\n  assumes \"mwb_lens x\" \"x \\<bowtie> y\"\n  shows \"\\<langle>\\<sigma>(y \\<mapsto>\\<^sub>s v)\\<rangle>\\<^sub>s x = \\<langle>\\<sigma>\\<rangle>\\<^sub>s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<sigma>(y \\<mapsto>\\<^sub>s v)\\<rangle>\\<^sub>s x =\n    \\<langle>\\<sigma>\\<rangle>\\<^sub>s x", "using assms"], ["proof (prove)\nusing this:\n  mwb_lens x\n  x \\<bowtie> y\n\ngoal (1 subgoal):\n 1. \\<langle>\\<sigma>(y \\<mapsto>\\<^sub>s v)\\<rangle>\\<^sub>s x =\n    \\<langle>\\<sigma>\\<rangle>\\<^sub>s x", "by (simp add: subst_upd_uvar_def, transfer, simp)"], ["", "lemma subst_upd_plus [usubst]: \n  \"x \\<bowtie> y \\<Longrightarrow> subst_upd s (x +\\<^sub>L y) e = s(x \\<mapsto>\\<^sub>s \\<pi>\\<^sub>1(e), y \\<mapsto>\\<^sub>s \\<pi>\\<^sub>2(e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bowtie> y \\<Longrightarrow>\n    s(x +\\<^sub>L y \\<mapsto>\\<^sub>s e) = s(x \\<mapsto>\\<^sub>s\n    \\<pi>\\<^sub>1(e), y \\<mapsto>\\<^sub>s \\<pi>\\<^sub>2(e))", "by (simp add: subst_upd_uvar_def lens_defs, transfer, auto simp add: fun_eq_iff prod.case_eq_if lens_indep_comm)"], ["", "text \\<open> If a variable is unrestricted in a substitution then it's application has no effect. \\<close>"], ["", "lemma usubst_apply_unrest [usubst]:\n  \"\\<lbrakk> vwb_lens x; x \\<sharp> \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<langle>\\<sigma>\\<rangle>\\<^sub>s x = var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens x; x \\<sharp> \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<langle>\\<sigma>\\<rangle>\\<^sub>s x = x", "by (simp add: unrest_usubst_def, transfer, auto simp add: fun_eq_iff, metis vwb_lens_wb wb_lens.get_put wb_lens_weak weak_lens.put_get)"], ["", "text \\<open> There follows various laws about deleting variables from a substitution. \\<close>"], ["", "lemma subst_del_id [usubst]:\n  \"vwb_lens x \\<Longrightarrow> id -\\<^sub>s x = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow> id -\\<^sub>s x = id", "by (simp add: subst_del_def subst_upd_uvar_def pr_var_def, transfer, auto)"], ["", "lemma subst_del_upd_same [usubst]:\n  \"mwb_lens x \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) -\\<^sub>s x = \\<sigma> -\\<^sub>s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow>\n    \\<sigma>(x \\<mapsto>\\<^sub>s v) -\\<^sub>s x = \\<sigma> -\\<^sub>s x", "by (simp add: subst_del_def subst_upd_uvar_def)"], ["", "lemma subst_del_upd_diff [usubst]:\n  \"x \\<bowtie> y \\<Longrightarrow> \\<sigma>(y \\<mapsto>\\<^sub>s v) -\\<^sub>s x = (\\<sigma> -\\<^sub>s x)(y \\<mapsto>\\<^sub>s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bowtie> y \\<Longrightarrow>\n    \\<sigma>(y \\<mapsto>\\<^sub>s v) -\\<^sub>s x = (\\<sigma> -\\<^sub>s x)(y \n    \\<mapsto>\\<^sub>s v)", "by (simp add: subst_del_def subst_upd_uvar_def lens_indep_comm)"], ["", "text \\<open> If a variable is unrestricted in an expression, then any substitution of that variable\n  has no effect on the expression .\\<close>"], ["", "lemma subst_unrest [usubst]: \"x \\<sharp> P \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> P = \\<sigma> \\<dagger> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> P \\<Longrightarrow>\n    \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> P = \\<sigma> \\<dagger> P", "by (simp add: subst_upd_uvar_def, transfer, auto)"], ["", "lemma subst_unrest_2 [usubst]: \n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"x \\<sharp> P\" \"x \\<bowtie> y\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s u,y \\<mapsto>\\<^sub>s v) \\<dagger> P = \\<sigma>(y \\<mapsto>\\<^sub>s v) \\<dagger> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v) \\<dagger> P =\n    \\<sigma>(y \\<mapsto>\\<^sub>s v) \\<dagger> P", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> P\n  x \\<bowtie> y\n\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v) \\<dagger> P =\n    \\<sigma>(y \\<mapsto>\\<^sub>s v) \\<dagger> P", "by (simp add: subst_upd_uvar_def, transfer, auto, metis lens_indep.lens_put_comm)"], ["", "lemma subst_unrest_3 [usubst]: \n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"x \\<sharp> P\" \"x \\<bowtie> y\" \"x \\<bowtie> z\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v, z \\<mapsto>\\<^sub>s w) \\<dagger> P = \\<sigma>(y \\<mapsto>\\<^sub>s v, z \\<mapsto>\\<^sub>s w) \\<dagger> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v, z \n    \\<mapsto>\\<^sub>s w) \\<dagger> P =\n    \\<sigma>(y \\<mapsto>\\<^sub>s v, z \\<mapsto>\\<^sub>s w) \\<dagger> P", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> P\n  x \\<bowtie> y\n  x \\<bowtie> z\n\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s u, y \\<mapsto>\\<^sub>s v, z \n    \\<mapsto>\\<^sub>s w) \\<dagger> P =\n    \\<sigma>(y \\<mapsto>\\<^sub>s v, z \\<mapsto>\\<^sub>s w) \\<dagger> P", "by (simp add: subst_upd_uvar_def, transfer, auto, metis (no_types, hide_lams) lens_indep_comm)"], ["", "lemma subst_unrest_4 [usubst]: \n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"x \\<sharp> P\" \"x \\<bowtie> y\" \"x \\<bowtie> z\" \"x \\<bowtie> u\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s e, y \\<mapsto>\\<^sub>s f, z \\<mapsto>\\<^sub>s g, u \\<mapsto>\\<^sub>s h) \\<dagger> P = \\<sigma>(y \\<mapsto>\\<^sub>s f, z \\<mapsto>\\<^sub>s g, u \\<mapsto>\\<^sub>s h) \\<dagger> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s e, y \\<mapsto>\\<^sub>s f, z \n    \\<mapsto>\\<^sub>s g, u \\<mapsto>\\<^sub>s h) \\<dagger> P =\n    \\<sigma>(y \\<mapsto>\\<^sub>s f, z \\<mapsto>\\<^sub>s g, u \n    \\<mapsto>\\<^sub>s h) \\<dagger> P", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> P\n  x \\<bowtie> y\n  x \\<bowtie> z\n  x \\<bowtie> u\n\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s e, y \\<mapsto>\\<^sub>s f, z \n    \\<mapsto>\\<^sub>s g, u \\<mapsto>\\<^sub>s h) \\<dagger> P =\n    \\<sigma>(y \\<mapsto>\\<^sub>s f, z \\<mapsto>\\<^sub>s g, u \n    \\<mapsto>\\<^sub>s h) \\<dagger> P", "by (simp add: subst_upd_uvar_def, transfer, auto, metis (no_types, hide_lams) lens_indep_comm)"], ["", "lemma subst_unrest_5 [usubst]: \n  fixes P :: \"('a, '\\<alpha>) uexpr\"\n  assumes \"x \\<sharp> P\" \"x \\<bowtie> y\" \"x \\<bowtie> z\" \"x \\<bowtie> u\" \"x \\<bowtie> v\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s e, y \\<mapsto>\\<^sub>s f, z \\<mapsto>\\<^sub>s g, u \\<mapsto>\\<^sub>s h, v \\<mapsto>\\<^sub>s i) \\<dagger> P = \\<sigma>(y \\<mapsto>\\<^sub>s f, z \\<mapsto>\\<^sub>s g, u \\<mapsto>\\<^sub>s h, v \\<mapsto>\\<^sub>s i) \\<dagger> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s e, y \\<mapsto>\\<^sub>s f, z \n    \\<mapsto>\\<^sub>s g, u \\<mapsto>\\<^sub>s h, v \\<mapsto>\\<^sub>s\n    i) \\<dagger> P =\n    \\<sigma>(y \\<mapsto>\\<^sub>s f, z \\<mapsto>\\<^sub>s g, u \n    \\<mapsto>\\<^sub>s h, v \\<mapsto>\\<^sub>s i) \\<dagger> P", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> P\n  x \\<bowtie> y\n  x \\<bowtie> z\n  x \\<bowtie> u\n  x \\<bowtie> v\n\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s e, y \\<mapsto>\\<^sub>s f, z \n    \\<mapsto>\\<^sub>s g, u \\<mapsto>\\<^sub>s h, v \\<mapsto>\\<^sub>s\n    i) \\<dagger> P =\n    \\<sigma>(y \\<mapsto>\\<^sub>s f, z \\<mapsto>\\<^sub>s g, u \n    \\<mapsto>\\<^sub>s h, v \\<mapsto>\\<^sub>s i) \\<dagger> P", "by (simp add: subst_upd_uvar_def, transfer, auto, metis (no_types, hide_lams) lens_indep_comm)"], ["", "lemma subst_compose_upd [usubst]: \"x \\<sharp> \\<sigma> \\<Longrightarrow> \\<sigma> \\<circ> \\<rho>(x \\<mapsto>\\<^sub>s v) = (\\<sigma> \\<circ> \\<rho>)(x \\<mapsto>\\<^sub>s v) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> \\<sigma> \\<Longrightarrow>\n    \\<sigma> \\<circ> \\<rho>(x \\<mapsto>\\<^sub>s v) =\n    (\\<sigma> \\<circ> \\<rho>)(x \\<mapsto>\\<^sub>s v)", "by (simp add: subst_upd_uvar_def, transfer, auto simp add: unrest_usubst_def)"], ["", "text \\<open> Any substitution is a monotonic function. \\<close>"], ["", "lemma subst_mono: \"mono (subst \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ((\\<dagger>) \\<sigma>)", "by (simp add: less_eq_uexpr.rep_eq mono_def subst.rep_eq)"], ["", "subsection \\<open> Substitution laws \\<close>"], ["", "text \\<open> We now prove the key laws that show how a substitution should be performed for every \n  expression operator, including the core function operators, literals, variables, and the \n  arithmetic operators. They are all added to the \\emph{usubst} theorem attribute so that\n  we can apply them using the substitution tactic. \\<close>"], ["", "lemma id_subst [usubst]: \"id \\<dagger> v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<dagger> v = v", "by (transfer, simp)"], ["", "lemma subst_lit [usubst]: \"\\<sigma> \\<dagger> \\<guillemotleft>v\\<guillemotright> = \\<guillemotleft>v\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> \\<guillemotleft>v\\<guillemotright> =\n    \\<guillemotleft>v\\<guillemotright>", "by (transfer, simp)"], ["", "lemma subst_var [usubst]: \"\\<sigma> \\<dagger> var x = \\<langle>\\<sigma>\\<rangle>\\<^sub>s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> x = \\<langle>\\<sigma>\\<rangle>\\<^sub>s x", "by (transfer, simp)"], ["", "lemma usubst_ulambda [usubst]: \"\\<sigma> \\<dagger> (\\<lambda> x \\<bullet> P(x)) = (\\<lambda> x \\<bullet> \\<sigma> \\<dagger> P(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> ulambda P =\n    (\\<lambda> x \\<bullet> \\<sigma> \\<dagger> P x)", "by (transfer, simp)"], ["", "lemma unrest_usubst_del [unrest]: \"\\<lbrakk> vwb_lens x; x \\<sharp> (\\<langle>\\<sigma>\\<rangle>\\<^sub>s x); x \\<sharp> \\<sigma> -\\<^sub>s x \\<rbrakk> \\<Longrightarrow>  x \\<sharp> (\\<sigma> \\<dagger> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens x; x \\<sharp> \\<langle>\\<sigma>\\<rangle>\\<^sub>s x;\n     x \\<sharp> \\<sigma> -\\<^sub>s x\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> \\<sigma> \\<dagger> P", "by (simp add: subst_del_def subst_upd_uvar_def unrest_uexpr_def unrest_usubst_def subst.rep_eq usubst_lookup.rep_eq)\n     (metis vwb_lens.put_eq)"], ["", "text \\<open> We add the symmetric definition of input and output variables to substitution laws\n        so that the variables are correctly normalised after substitution. \\<close>"], ["", "lemma subst_uop [usubst]: \"\\<sigma> \\<dagger> uop f v = uop f (\\<sigma> \\<dagger> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> uop f v = uop f (\\<sigma> \\<dagger> v)", "by (transfer, simp)"], ["", "lemma subst_bop [usubst]: \"\\<sigma> \\<dagger> bop f u v = bop f (\\<sigma> \\<dagger> u) (\\<sigma> \\<dagger> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> bop f u v =\n    bop f (\\<sigma> \\<dagger> u) (\\<sigma> \\<dagger> v)", "by (transfer, simp)"], ["", "lemma subst_trop [usubst]: \"\\<sigma> \\<dagger> trop f u v w = trop f (\\<sigma> \\<dagger> u) (\\<sigma> \\<dagger> v) (\\<sigma> \\<dagger> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> trop f u v w =\n    trop f (\\<sigma> \\<dagger> u) (\\<sigma> \\<dagger> v)\n     (\\<sigma> \\<dagger> w)", "by (transfer, simp)"], ["", "lemma subst_qtop [usubst]: \"\\<sigma> \\<dagger> qtop f u v w x = qtop f (\\<sigma> \\<dagger> u) (\\<sigma> \\<dagger> v) (\\<sigma> \\<dagger> w) (\\<sigma> \\<dagger> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> qtop f u v w x =\n    qtop f (\\<sigma> \\<dagger> u) (\\<sigma> \\<dagger> v)\n     (\\<sigma> \\<dagger> w) (\\<sigma> \\<dagger> x)", "by (transfer, simp)"], ["", "lemma subst_case_prod [usubst]:\n  fixes P :: \"'i \\<Rightarrow> 'j \\<Rightarrow> ('a, '\\<alpha>) uexpr\"  \n  shows \"\\<sigma> \\<dagger> case_prod (\\<lambda> x y. P x y) v = case_prod (\\<lambda> x y. \\<sigma> \\<dagger> P x y) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (case v of (x, y) \\<Rightarrow> P x y) =\n    (case v of (x, y) \\<Rightarrow> \\<sigma> \\<dagger> P x y)", "by (simp add: case_prod_beta')"], ["", "lemma subst_plus [usubst]: \"\\<sigma> \\<dagger> (x + y) = \\<sigma> \\<dagger> x + \\<sigma> \\<dagger> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (x + y) = \\<sigma> \\<dagger> x + \\<sigma> \\<dagger> y", "by (simp add: plus_uexpr_def subst_bop)"], ["", "lemma subst_times [usubst]: \"\\<sigma> \\<dagger> (x * y) = \\<sigma> \\<dagger> x * \\<sigma> \\<dagger> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (x * y) = \\<sigma> \\<dagger> x * \\<sigma> \\<dagger> y", "by (simp add: times_uexpr_def subst_bop)"], ["", "lemma subst_mod [usubst]: \"\\<sigma> \\<dagger> (x mod y) = \\<sigma> \\<dagger> x mod \\<sigma> \\<dagger> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (x mod y) =\n    \\<sigma> \\<dagger> x mod \\<sigma> \\<dagger> y", "by (simp add: mod_uexpr_def usubst)"], ["", "lemma subst_div [usubst]: \"\\<sigma> \\<dagger> (x div y) = \\<sigma> \\<dagger> x div \\<sigma> \\<dagger> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (x div y) =\n    \\<sigma> \\<dagger> x div \\<sigma> \\<dagger> y", "by (simp add: divide_uexpr_def usubst)"], ["", "lemma subst_minus [usubst]: \"\\<sigma> \\<dagger> (x - y) = \\<sigma> \\<dagger> x - \\<sigma> \\<dagger> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (x - y) = \\<sigma> \\<dagger> x - \\<sigma> \\<dagger> y", "by (simp add: minus_uexpr_def subst_bop)"], ["", "lemma subst_uminus [usubst]: \"\\<sigma> \\<dagger> (- x) = - (\\<sigma> \\<dagger> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> - x = - (\\<sigma> \\<dagger> x)", "by (simp add: uminus_uexpr_def subst_uop)"], ["", "lemma usubst_sgn [usubst]: \"\\<sigma> \\<dagger> sgn x = sgn (\\<sigma> \\<dagger> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> sgn x = sgn (\\<sigma> \\<dagger> x)", "by (simp add: sgn_uexpr_def subst_uop)"], ["", "lemma usubst_abs [usubst]: \"\\<sigma> \\<dagger> abs x = abs (\\<sigma> \\<dagger> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> \\<bar>x\\<bar> = \\<bar>\\<sigma> \\<dagger> x\\<bar>", "by (simp add: abs_uexpr_def subst_uop)"], ["", "lemma subst_zero [usubst]: \"\\<sigma> \\<dagger> 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> 0 = 0", "by (simp add: zero_uexpr_def subst_lit)"], ["", "lemma subst_one [usubst]: \"\\<sigma> \\<dagger> 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> 1 = 1", "by (simp add: one_uexpr_def subst_lit)"], ["", "lemma subst_eq_upred [usubst]: \"\\<sigma> \\<dagger> (x =\\<^sub>u y) = (\\<sigma> \\<dagger> x =\\<^sub>u \\<sigma> \\<dagger> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> (x =\\<^sub>u y) =\n    (\\<sigma> \\<dagger> x =\\<^sub>u \\<sigma> \\<dagger> y)", "by (simp add: eq_upred_def usubst)"], ["", "text \\<open> This laws shows the effect of applying one substitution after another -- we simply\n  use function composition to compose them. \\<close>"], ["", "lemma subst_subst [usubst]: \"\\<sigma> \\<dagger> \\<rho> \\<dagger> e = (\\<rho> \\<circ> \\<sigma>) \\<dagger> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<dagger> \\<rho> \\<dagger> e =\n    (\\<rho> \\<circ> \\<sigma>) \\<dagger> e", "by (transfer, simp)"], ["", "text \\<open> The next law is similar, but shows how such a substitution is to be applied to every\n  updated variable additionally. \\<close>"], ["", "lemma subst_upd_comp [usubst]:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  shows \"\\<rho>(x \\<mapsto>\\<^sub>s v) \\<circ> \\<sigma> = (\\<rho> \\<circ> \\<sigma>)(x \\<mapsto>\\<^sub>s \\<sigma> \\<dagger> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho>(x \\<mapsto>\\<^sub>s v) \\<circ> \\<sigma> =\n    (\\<rho> \\<circ> \\<sigma>)(x \\<mapsto>\\<^sub>s \\<sigma> \\<dagger> v)", "by (rule ext, simp add:uexpr_defs subst_upd_uvar_def, transfer, simp)"], ["", "lemma subst_singleton:\n  fixes x :: \"('a \\<Longrightarrow> '\\<alpha>)\"\n  assumes \"x \\<sharp> \\<sigma>\"\n  shows \"\\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> P = (\\<sigma> \\<dagger> P)\\<lbrakk>v/x\\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> P =\n    (\\<sigma> \\<dagger> P)\\<lbrakk>v/x\\<rbrakk>", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s v) \\<dagger> P =\n    (\\<sigma> \\<dagger> P)\\<lbrakk>v/x\\<rbrakk>", "by (simp add: usubst)"], ["", "lemmas subst_to_singleton = subst_singleton id_subst"], ["", "subsection \\<open> Ordering substitutions \\<close>"], ["", "text \\<open> A simplification procedure to reorder substitutions maplets lexicographically by variable syntax \\<close>"], ["", "simproc_setup subst_order (\"subst_upd_uvar (subst_upd_uvar \\<sigma> x u) y v\") =\n  \\<open>(fn _ => fn ctxt => fn ct => \n        case (Thm.term_of ct) of\n          Const (\"utp_subst.subst_upd_uvar\", _) $ (Const (\"utp_subst.subst_upd_uvar\", _) $ s $ x $ u) $ y $ v\n            => if (YXML.content_of (Syntax.string_of_term ctxt x) > YXML.content_of(Syntax.string_of_term ctxt y))\n               then SOME (mk_meta_eq @{thm usubst_upd_comm})\n               else NONE  |\n          _ => NONE) \n\\<close>"], ["", "subsection \\<open> Unrestriction laws \\<close>"], ["", "text \\<open> These are the key unrestriction theorems for substitutions and expressions involving substitutions. \\<close>"], ["", "lemma unrest_usubst_single [unrest]:\n  \"\\<lbrakk> mwb_lens x; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> P\\<lbrakk>v/x\\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens x; x \\<sharp> v\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> P\\<lbrakk>v/x\\<rbrakk>", "by (transfer, auto simp add: subst_upd_uvar_def unrest_uexpr_def)"], ["", "lemma unrest_usubst_id [unrest]:\n  \"mwb_lens x \\<Longrightarrow> x \\<sharp> id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow> x \\<sharp> id", "by (simp add: unrest_usubst_def)"], ["", "lemma unrest_usubst_upd [unrest]:\n  \"\\<lbrakk> x \\<bowtie> y; x \\<sharp> \\<sigma>; x \\<sharp> v \\<rbrakk> \\<Longrightarrow> x \\<sharp> \\<sigma>(y \\<mapsto>\\<^sub>s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<bowtie> y; x \\<sharp> \\<sigma>; x \\<sharp> v\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> \\<sigma>(y \\<mapsto>\\<^sub>s v)", "by (simp add: subst_upd_uvar_def unrest_usubst_def unrest_uexpr.rep_eq lens_indep_comm)"], ["", "lemma unrest_subst [unrest]:\n  \"\\<lbrakk> x \\<sharp> P; x \\<sharp> \\<sigma> \\<rbrakk> \\<Longrightarrow> x \\<sharp> (\\<sigma> \\<dagger> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp> P; x \\<sharp> \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> \\<sigma> \\<dagger> P", "by (transfer, simp add: unrest_usubst_def)"], ["", "subsection \\<open> Conditional Substitution Laws \\<close>"], ["", "lemma usubst_cond_upd_1 [usubst]:\n  \"\\<sigma>(x \\<mapsto>\\<^sub>s u) \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho>(x \\<mapsto>\\<^sub>s v) = (\\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho>)(x \\<mapsto>\\<^sub>s u \\<triangleleft> b \\<triangleright> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>(x \\<mapsto>\\<^sub>s\n       u) \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho>(x \n       \\<mapsto>\\<^sub>s v) =\n    (\\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho>)(x \n    \\<mapsto>\\<^sub>s u \\<triangleleft> b \\<triangleright> v)", "by (simp add: cond_subst_def subst_upd_uvar_def uexpr_defs, transfer, auto)"], ["", "lemma usubst_cond_upd_2 [usubst]:\n  \"\\<lbrakk> vwb_lens x; x \\<sharp> \\<rho> \\<rbrakk> \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s u) \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho> = (\\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho>)(x \\<mapsto>\\<^sub>s u \\<triangleleft> b \\<triangleright> &x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens x; x \\<sharp> \\<rho>\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s\n                         u) \\<triangleleft> b \\<triangleright>\\<^sub>s\n                         \\<rho> =\n                      (\\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s\n                          \\<rho>)\n                      (x \\<mapsto>\\<^sub>s\n                      u \\<triangleleft> b \\<triangleright> &x)", "by (simp add: cond_subst_def subst_upd_uvar_def unrest_usubst_def uexpr_defs, transfer)\n     (metis (full_types, hide_lams) id_apply pr_var_def subst_upd_uvar_def usubst_upd_pr_var_id var.rep_eq)"], ["", "lemma usubst_cond_upd_3 [usubst]:\n  \"\\<lbrakk> vwb_lens x; x \\<sharp> \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho>(x \\<mapsto>\\<^sub>s v) = (\\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s \\<rho>)(x \\<mapsto>\\<^sub>s &x \\<triangleleft> b \\<triangleright> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens x; x \\<sharp> \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s\n                         \\<rho>(x \\<mapsto>\\<^sub>s v) =\n                      (\\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s\n                          \\<rho>)\n                      (x \\<mapsto>\\<^sub>s\n                      &x \\<triangleleft> b \\<triangleright> v)", "by (simp add: cond_subst_def subst_upd_uvar_def unrest_usubst_def uexpr_defs, transfer)\n     (metis (full_types, hide_lams) id_apply pr_var_def subst_upd_uvar_def usubst_upd_pr_var_id var.rep_eq)"], ["", "lemma usubst_cond_id [usubst]:\n  \"\\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s \\<sigma> = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<triangleleft> b \\<triangleright>\\<^sub>s \\<sigma> = \\<sigma>", "by (auto simp add: cond_subst_def)"], ["", "subsection \\<open> Parallel Substitution Laws \\<close>"], ["", "lemma par_subst_id [usubst]:\n  \"\\<lbrakk> vwb_lens A; vwb_lens B \\<rbrakk> \\<Longrightarrow> id [A|B]\\<^sub>s id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens A; vwb_lens B\\<rbrakk>\n    \\<Longrightarrow> id [A|B]\\<^sub>s id = id", "by (simp add: par_subst_def id_def)"], ["", "lemma par_subst_left_empty [usubst]:\n  \"\\<lbrakk> vwb_lens A \\<rbrakk> \\<Longrightarrow> \\<sigma> [\\<emptyset>|A]\\<^sub>s \\<rho> = id [\\<emptyset>|A]\\<^sub>s \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens A \\<Longrightarrow>\n    \\<sigma> [\\<emptyset>|A]\\<^sub>s \\<rho> =\n    id [\\<emptyset>|A]\\<^sub>s \\<rho>", "by (simp add: par_subst_def pr_var_def)"], ["", "lemma par_subst_right_empty [usubst]:\n  \"\\<lbrakk> vwb_lens A \\<rbrakk> \\<Longrightarrow> \\<sigma> [A|\\<emptyset>]\\<^sub>s \\<rho> = \\<sigma> [A|\\<emptyset>]\\<^sub>s id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens A \\<Longrightarrow>\n    \\<sigma> [A|\\<emptyset>]\\<^sub>s \\<rho> =\n    \\<sigma> [A|\\<emptyset>]\\<^sub>s id", "by (simp add: par_subst_def pr_var_def)"], ["", "lemma par_subst_comm:\n  \"\\<lbrakk> A \\<bowtie> B \\<rbrakk> \\<Longrightarrow> \\<sigma> [A|B]\\<^sub>s \\<rho> = \\<rho> [B|A]\\<^sub>s \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bowtie> B \\<Longrightarrow>\n    \\<sigma> [A|B]\\<^sub>s \\<rho> = \\<rho> [B|A]\\<^sub>s \\<sigma>", "by (simp add: par_subst_def lens_override_def lens_indep_comm)"], ["", "lemma par_subst_upd_left_in [usubst]:\n  \"\\<lbrakk> vwb_lens A; A \\<bowtie> B; x \\<subseteq>\\<^sub>L A \\<rbrakk> \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) [A|B]\\<^sub>s \\<rho> = (\\<sigma> [A|B]\\<^sub>s \\<rho>)(x \\<mapsto>\\<^sub>s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens A; A \\<bowtie> B; x \\<subseteq>\\<^sub>L A\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) [A|B]\\<^sub>s \\<rho> =\n                      (\\<sigma> [A|B]\\<^sub>s \\<rho>)(x \\<mapsto>\\<^sub>s v)", "by (simp add: par_subst_def subst_upd_uvar_def lens_override_put_right_in)\n     (simp add: lens_indep_comm lens_override_def sublens_pres_indep)"], ["", "lemma par_subst_upd_left_out [usubst]:\n  \"\\<lbrakk> vwb_lens A; x \\<bowtie> A \\<rbrakk> \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) [A|B]\\<^sub>s \\<rho> = (\\<sigma> [A|B]\\<^sub>s \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens A; x \\<bowtie> A\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>(x \\<mapsto>\\<^sub>s v) [A|B]\\<^sub>s \\<rho> =\n                      \\<sigma> [A|B]\\<^sub>s \\<rho>", "by (simp add: par_subst_def subst_upd_uvar_def lens_override_put_right_out)"], ["", "lemma par_subst_upd_right_in [usubst]:\n  \"\\<lbrakk> vwb_lens B; A \\<bowtie> B; x \\<subseteq>\\<^sub>L B \\<rbrakk> \\<Longrightarrow> \\<sigma> [A|B]\\<^sub>s \\<rho>(x \\<mapsto>\\<^sub>s v) = (\\<sigma> [A|B]\\<^sub>s \\<rho>)(x \\<mapsto>\\<^sub>s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens B; A \\<bowtie> B; x \\<subseteq>\\<^sub>L B\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> [A|B]\\<^sub>s \\<rho>(x \\<mapsto>\\<^sub>s v) =\n                      (\\<sigma> [A|B]\\<^sub>s \\<rho>)(x \\<mapsto>\\<^sub>s v)", "using lens_indep_sym par_subst_comm par_subst_upd_left_in"], ["proof (prove)\nusing this:\n  ?x \\<bowtie> ?y \\<Longrightarrow> ?y \\<bowtie> ?x\n  ?A \\<bowtie> ?B \\<Longrightarrow>\n  ?\\<sigma> [?A|?B]\\<^sub>s ?\\<rho> = ?\\<rho> [?B|?A]\\<^sub>s ?\\<sigma>\n  \\<lbrakk>vwb_lens ?A; ?A \\<bowtie> ?B; ?x \\<subseteq>\\<^sub>L ?A\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>(?x \\<mapsto>\\<^sub>s\n                    ?v) [?A|?B]\\<^sub>s ?\\<rho> =\n                    (?\\<sigma> [?A|?B]\\<^sub>s ?\\<rho>)(?x \\<mapsto>\\<^sub>s\n                    ?v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens B; A \\<bowtie> B; x \\<subseteq>\\<^sub>L B\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> [A|B]\\<^sub>s \\<rho>(x \\<mapsto>\\<^sub>s v) =\n                      (\\<sigma> [A|B]\\<^sub>s \\<rho>)(x \\<mapsto>\\<^sub>s v)", "by fastforce"], ["", "lemma par_subst_upd_right_out [usubst]:\n  \"\\<lbrakk> vwb_lens B; A \\<bowtie> B; x \\<bowtie> B \\<rbrakk> \\<Longrightarrow> \\<sigma> [A|B]\\<^sub>s \\<rho>(x \\<mapsto>\\<^sub>s v) = (\\<sigma> [A|B]\\<^sub>s \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens B; A \\<bowtie> B; x \\<bowtie> B\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> [A|B]\\<^sub>s \\<rho>(x \\<mapsto>\\<^sub>s v) =\n                      \\<sigma> [A|B]\\<^sub>s \\<rho>", "by (simp add: par_subst_comm par_subst_upd_left_out)"], ["", "end"]]}