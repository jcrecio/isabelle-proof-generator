{"file_name": "/home/qj213/afp-2021-10-22/thys/UTP/utp/examples/utp_simple_time.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UTP", "problem_names": ["theorem HT_idem: \"HT(HT(P)) = HT(P)\"", "theorem HT_mono: \"P \\<sqsubseteq> Q \\<Longrightarrow> HT(P) \\<sqsubseteq> HT(Q)\"", "theorem HT_continuous: \"Continuous HT\"", "lemma HT_Wait: \"HT(Wait(n)) = Wait(n)\"", "lemma HT_Wait_closed [closure]: \"Wait(n) is HT\"", "lemma HT_skip_closed [closure]: \"II is HT\"", "lemma HT_seqr_closed [closure]:\n  \"\\<lbrakk> P is HT; Q is HT \\<rbrakk> \\<Longrightarrow> P ;; Q is HT\"", "lemma HT_assign_closed [closure]: \"\\<lbrakk> vwb_lens x; clock \\<bowtie> x \\<rbrakk> \\<Longrightarrow> x := v is HT\"", "lemma HT_assign_closed' [closure]: \"\\<lbrakk> vwb_lens x; x \\<subseteq>\\<^sub>L st \\<rbrakk> \\<Longrightarrow> x := v is HT\"", "theorem Wait_skip: \"Wait(0) = II\"", "theorem Wait_Wait: \"Wait(m) ;; Wait(n) = Wait (m + n)\"", "theorem Wait_cond: \"Wait(m) ;; (P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) = (Wait m ;; P) \\<triangleleft> b\\<lbrakk>&clock+\\<guillemotleft>m\\<guillemotright>/&clock\\<rbrakk> \\<triangleright>\\<^sub>r (Wait m ;; Q)\""], "translations": [["", "theorem HT_idem: \"HT(HT(P)) = HT(P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT (HT P) = HT P", "by rel_auto"], ["", "theorem HT_mono: \"P \\<sqsubseteq> Q \\<Longrightarrow> HT(P) \\<sqsubseteq> HT(Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sqsubseteq> Q \\<Longrightarrow> HT P \\<sqsubseteq> HT Q", "by rel_auto"], ["", "theorem HT_continuous: \"Continuous HT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Continuous HT", "by rel_auto"], ["", "text \\<open> We now create the UTP theory object for timed relations. This is done using a local \n  interpretation @{term \"utp_theory_continuous HT\"}. This raises the proof obligations\n  that @{term HT} is both idempotent and continuous, which we have proved already. \n  The result of this command is a collection of theorems that can be derived from these \n  facts. Notably, we obtain a complete lattice of timed relations via the Knaster-Tarski theorem. \n  We also apply some locale rewrites so that the theorems that are exports have a more intuitive \n  form. \\<close>"], ["", "interpretation time_theory: utp_theory_continuous HT\n  rewrites \"P \\<in> carrier time_theory.thy_order \\<longleftrightarrow> P is HT\"\n  and \"carrier time_theory.thy_order \\<rightarrow> carrier time_theory.thy_order \\<equiv> \\<lbrakk>HT\\<rbrakk>\\<^sub>H \\<rightarrow> \\<lbrakk>HT\\<rbrakk>\\<^sub>H\"\n  and \"le time_theory.thy_order = (\\<sqsubseteq>)\"\n  and \"eq time_theory.thy_order = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (utp_theory_continuous HT &&&\n     (P \\<in> carrier (utp_order HT)) = (P is HT)) &&&\n    (carrier (utp_order HT) \\<rightarrow> carrier (utp_order HT) \\<equiv>\n     \\<lbrakk>HT\\<rbrakk>\\<^sub>H \\<rightarrow>\n     \\<lbrakk>HT\\<rbrakk>\\<^sub>H) &&&\n    le (utp_order HT) = (\\<sqsubseteq>) &&&\n    (.=\\<^bsub>utp_order HT\\<^esub>) = (=)", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. utp_theory_continuous HT\n 2. (P \\<in> carrier (utp_order HT)) = (P is HT)\n 3. carrier (utp_order HT) \\<rightarrow> carrier (utp_order HT) \\<equiv>\n    \\<lbrakk>HT\\<rbrakk>\\<^sub>H \\<rightarrow> \\<lbrakk>HT\\<rbrakk>\\<^sub>H\n 4. le (utp_order HT) = (\\<sqsubseteq>)\n 5. (.=\\<^bsub>utp_order HT\\<^esub>) = (=)", "show \"utp_theory_continuous HT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. utp_theory_continuous HT", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P. HT (HT P) = HT P\n 2. Continuous HT", "show \"\\<And>P. HT (HT P) = HT P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P. HT (HT P) = HT P", "by (simp add: HT_idem)"], ["proof (state)\nthis:\n  HT (HT ?P) = HT ?P\n\ngoal (1 subgoal):\n 1. Continuous HT", "show \"Continuous HT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Continuous HT", "by (simp add: HT_continuous)"], ["proof (state)\nthis:\n  Continuous HT\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  utp_theory_continuous HT\n\ngoal (4 subgoals):\n 1. (P \\<in> carrier (utp_order HT)) = (P is HT)\n 2. carrier (utp_order HT) \\<rightarrow> carrier (utp_order HT) \\<equiv>\n    \\<lbrakk>HT\\<rbrakk>\\<^sub>H \\<rightarrow> \\<lbrakk>HT\\<rbrakk>\\<^sub>H\n 3. le (utp_order HT) = (\\<sqsubseteq>)\n 4. (.=\\<^bsub>utp_order HT\\<^esub>) = (=)", "qed (simp_all)"], ["", "text \\<open> The object \\textit{time-theory} is a new namespace that contains both definitions and theorems.\n  Since the theory forms a complete lattice, we obtain a top element, bottom element, and a\n  least fixed-point constructor. We give all of these some intuitive syntax. \\<close>"], ["", "notation time_theory.utp_top (\"\\<top>\\<^sub>t\")"], ["", "notation time_theory.utp_bottom (\"\\<bottom>\\<^sub>t\")"], ["", "notation time_theory.utp_lfp (\"\\<mu>\\<^sub>t\")"], ["", "text \\<open> Below is a selection of theorems that have been exported by the locale interpretation. \\<close>"], ["", "thm time_theory.bottom_healthy"], ["", "thm time_theory.top_higher"], ["", "thm time_theory.meet_bottom"], ["", "thm time_theory.LFP_unfold"], ["", "subsection \\<open> Closure Laws \\<close>"], ["", "text \\<open> @{term HT} applied to @{term Wait} has no affect, since the latter always advances time. \\<close>"], ["", "lemma HT_Wait: \"HT(Wait(n)) = Wait(n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT (Wait n) = Wait n", "by (rel_auto)"], ["", "lemma HT_Wait_closed [closure]: \"Wait(n) is HT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Wait n is HT", "by (simp add: HT_Wait Healthy_def)"], ["", "text \\<open> Relational identity, @{term II}, is likewise @{term HT}-healthy. \\<close>"], ["", "lemma HT_skip_closed [closure]: \"II is HT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. II is HT", "by (rel_auto)"], ["", "text \\<open> @{term HT} is closed under sequential composition, which can be shown \n  by transitivity of @{term \"(\\<le>)\"}. \\<close>"], ["", "lemma HT_seqr_closed [closure]:\n  \"\\<lbrakk> P is HT; Q is HT \\<rbrakk> \\<Longrightarrow> P ;; Q is HT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P is HT; Q is HT\\<rbrakk> \\<Longrightarrow> P ;; Q is HT", "by (rel_auto, meson dual_order.trans) \\<comment> \\<open> Sledgehammer required \\<close>"], ["", "text \\<open> Assignment is also healthy, provided that the clock variable is not assigned. \\<close>"], ["", "lemma HT_assign_closed [closure]: \"\\<lbrakk> vwb_lens x; clock \\<bowtie> x \\<rbrakk> \\<Longrightarrow> x := v is HT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens x; clock \\<bowtie> x\\<rbrakk>\n    \\<Longrightarrow> x := v is HT", "by (rel_auto, metis (mono_tags, lifting) eq_iff lens.select_convs(1) lens_indep_get st_time.select_convs(1))"], ["", "text \\<open> An alternative characterisation of the above is that @{term x} is within the state space lens. \\<close>"], ["", "lemma HT_assign_closed' [closure]: \"\\<lbrakk> vwb_lens x; x \\<subseteq>\\<^sub>L st \\<rbrakk> \\<Longrightarrow> x := v is HT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens x; x \\<subseteq>\\<^sub>L st\\<rbrakk>\n    \\<Longrightarrow> x := v is HT", "by (rel_auto)"], ["", "subsection \\<open> Algebraic Laws \\<close>"], ["", "text \\<open> Finally, we prove some useful algebraic laws. \\<close>"], ["", "theorem Wait_skip: \"Wait(0) = II\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Wait 0 = II", "by (rel_auto)"], ["", "theorem Wait_Wait: \"Wait(m) ;; Wait(n) = Wait (m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Wait m ;; Wait n = Wait (m + n)", "by (rel_auto)"], ["", "theorem Wait_cond: \"Wait(m) ;; (P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) = (Wait m ;; P) \\<triangleleft> b\\<lbrakk>&clock+\\<guillemotleft>m\\<guillemotright>/&clock\\<rbrakk> \\<triangleright>\\<^sub>r (Wait m ;; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Wait m ;; (P \\<triangleleft> b \\<triangleright>\\<^sub>r Q) =\n    Wait m ;;\n    P \\<triangleleft> b\\<lbrakk>&clock +\n                                \\<guillemotleft>m\\<guillemotright>/&clock\\<rbrakk> \\<triangleright>\\<^sub>r\n       Wait m ;; Q", "by (rel_auto)"], ["", "end"]]}