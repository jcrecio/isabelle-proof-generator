{"file_name": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan/Inverse_IArrays.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan", "problem_names": ["lemma matrix_inv_Gauss_Jordan_iarrays_PA:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes inv_A: \"invertible A\"\nshows \"matrix_to_iarray (matrix_inv A) = fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A))\"", "lemma matrix_to_iarray_invertible[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"invertible A = invertible_iarray (matrix_to_iarray A)\"", "lemma matrix_to_iarray_option_inverse_matrix:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"matrix_to_iarray_option (inverse_matrix A) = (inverse_matrix_iarray (matrix_to_iarray A))\"", "lemma matrix_to_iarray_option_inverse_matrix_code[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"matrix_to_iarray_option (inverse_matrix A) = (let matrix_to_iarray_A = matrix_to_iarray A; GJ = Gauss_Jordan_iarrays_PA matrix_to_iarray_A\n  in if nrows_iarray matrix_to_iarray_A = length [x\\<leftarrow>IArray.list_of (snd GJ) . \\<not> is_zero_iarray x] then Some (fst GJ) else None)\"", "lemma[code_unfold]:\nshows \"inverse_matrix_iarray A = (let A' = (Gauss_Jordan_iarrays_PA A); nrows = IArray.length A in \n                                (if length [x\\<leftarrow>IArray.list_of (snd A') . \\<not> is_zero_iarray x] = nrows \n                                then Some (fst A') else None))\""], "translations": [["", "lemma matrix_inv_Gauss_Jordan_iarrays_PA:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes inv_A: \"invertible A\"\nshows \"matrix_to_iarray (matrix_inv A) = fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (matrix_inv A) =\n    fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A))", "by (metis inv_A matrix_inv_Gauss_Jordan_PA matrix_to_iarray_fst_Gauss_Jordan_PA)"], ["", "lemma matrix_to_iarray_invertible[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"invertible A = invertible_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible A = invertible_iarray (matrix_to_iarray A)", "unfolding invertible_iarray_def invertible_eq_full_rank[of A] matrix_to_iarray_rank matrix_to_iarray_nrows"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rank_iarray (matrix_to_iarray A) = nrows_iarray (matrix_to_iarray A)) =\n    (rank_iarray (matrix_to_iarray A) = nrows_iarray (matrix_to_iarray A))", ".."], ["", "lemma matrix_to_iarray_option_inverse_matrix:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"matrix_to_iarray_option (inverse_matrix A) = (inverse_matrix_iarray (matrix_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray_option (inverse_matrix A) =\n    inverse_matrix_iarray (matrix_to_iarray A)", "proof (unfold inverse_matrix_def, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. invertible A \\<Longrightarrow>\n    matrix_to_iarray_option (Some (matrix_inv A)) =\n    inverse_matrix_iarray (matrix_to_iarray A)\n 2. \\<not> invertible A \\<Longrightarrow>\n    matrix_to_iarray_option None =\n    inverse_matrix_iarray (matrix_to_iarray A)", "assume inv_A: \"invertible A\""], ["proof (state)\nthis:\n  invertible A\n\ngoal (2 subgoals):\n 1. invertible A \\<Longrightarrow>\n    matrix_to_iarray_option (Some (matrix_inv A)) =\n    inverse_matrix_iarray (matrix_to_iarray A)\n 2. \\<not> invertible A \\<Longrightarrow>\n    matrix_to_iarray_option None =\n    inverse_matrix_iarray (matrix_to_iarray A)", "show \"matrix_to_iarray_option (Some (matrix_inv A)) = inverse_matrix_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray_option (Some (matrix_inv A)) =\n    inverse_matrix_iarray (matrix_to_iarray A)", "unfolding matrix_to_iarray_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Some (matrix_inv A) \\<noteq> None\n     then Some (matrix_to_iarray (the (Some (matrix_inv A)))) else None) =\n    inverse_matrix_iarray (matrix_to_iarray A)", "unfolding inverse_matrix_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Some (matrix_inv A) \\<noteq> None\n     then Some (matrix_to_iarray (the (Some (matrix_inv A)))) else None) =\n    (if invertible_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None)", "using inv_A"], ["proof (prove)\nusing this:\n  invertible A\n\ngoal (1 subgoal):\n 1. (if Some (matrix_inv A) \\<noteq> None\n     then Some (matrix_to_iarray (the (Some (matrix_inv A)))) else None) =\n    (if invertible_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None)", "unfolding matrix_to_iarray_invertible"], ["proof (prove)\nusing this:\n  invertible_iarray (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. (if Some (matrix_inv A) \\<noteq> None\n     then Some (matrix_to_iarray (the (Some (matrix_inv A)))) else None) =\n    (if invertible_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None)", "using matrix_inv_Gauss_Jordan_iarrays_PA[OF inv_A]"], ["proof (prove)\nusing this:\n  invertible_iarray (matrix_to_iarray A)\n  matrix_to_iarray (matrix_inv A) =\n  fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. (if Some (matrix_inv A) \\<noteq> None\n     then Some (matrix_to_iarray (the (Some (matrix_inv A)))) else None) =\n    (if invertible_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None)", "by auto"], ["proof (state)\nthis:\n  matrix_to_iarray_option (Some (matrix_inv A)) =\n  inverse_matrix_iarray (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. \\<not> invertible A \\<Longrightarrow>\n    matrix_to_iarray_option None =\n    inverse_matrix_iarray (matrix_to_iarray A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> invertible A \\<Longrightarrow>\n    matrix_to_iarray_option None =\n    inverse_matrix_iarray (matrix_to_iarray A)", "assume not_inv_A: \"\\<not> invertible A\""], ["proof (state)\nthis:\n  \\<not> invertible A\n\ngoal (1 subgoal):\n 1. \\<not> invertible A \\<Longrightarrow>\n    matrix_to_iarray_option None =\n    inverse_matrix_iarray (matrix_to_iarray A)", "show \"matrix_to_iarray_option None = inverse_matrix_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray_option None =\n    inverse_matrix_iarray (matrix_to_iarray A)", "unfolding matrix_to_iarray_option_def inverse_matrix_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if None \\<noteq> None then Some (matrix_to_iarray (the None))\n     else None) =\n    (if invertible_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None)", "using not_inv_A"], ["proof (prove)\nusing this:\n  \\<not> invertible A\n\ngoal (1 subgoal):\n 1. (if None \\<noteq> None then Some (matrix_to_iarray (the None))\n     else None) =\n    (if invertible_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None)", "unfolding matrix_to_iarray_invertible"], ["proof (prove)\nusing this:\n  \\<not> invertible_iarray (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. (if None \\<noteq> None then Some (matrix_to_iarray (the None))\n     else None) =\n    (if invertible_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None)", "by simp"], ["proof (state)\nthis:\n  matrix_to_iarray_option None = inverse_matrix_iarray (matrix_to_iarray A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_option_inverse_matrix_code[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"matrix_to_iarray_option (inverse_matrix A) = (let matrix_to_iarray_A = matrix_to_iarray A; GJ = Gauss_Jordan_iarrays_PA matrix_to_iarray_A\n  in if nrows_iarray matrix_to_iarray_A = length [x\\<leftarrow>IArray.list_of (snd GJ) . \\<not> is_zero_iarray x] then Some (fst GJ) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray_option (inverse_matrix A) =\n    (let matrix_to_iarray_A = matrix_to_iarray A;\n         GJ = Gauss_Jordan_iarrays_PA matrix_to_iarray_A\n     in if nrows_iarray matrix_to_iarray_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)))\n        then Some (fst GJ) else None)", "unfolding matrix_to_iarray_option_inverse_matrix"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_matrix_iarray (matrix_to_iarray A) =\n    (let matrix_to_iarray_A = matrix_to_iarray A;\n         GJ = Gauss_Jordan_iarrays_PA matrix_to_iarray_A\n     in if nrows_iarray matrix_to_iarray_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)))\n        then Some (fst GJ) else None)", "unfolding inverse_matrix_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if invertible_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None) =\n    (let matrix_to_iarray_A = matrix_to_iarray A;\n         GJ = Gauss_Jordan_iarrays_PA matrix_to_iarray_A\n     in if nrows_iarray matrix_to_iarray_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)))\n        then Some (fst GJ) else None)", "unfolding invertible_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if rank_iarray (matrix_to_iarray A) = nrows_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None) =\n    (let matrix_to_iarray_A = matrix_to_iarray A;\n         GJ = Gauss_Jordan_iarrays_PA matrix_to_iarray_A\n     in if nrows_iarray matrix_to_iarray_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)))\n        then Some (fst GJ) else None)", "unfolding rank_iarrays_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of (Gauss_Jordan_iarrays (matrix_to_iarray A)))) =\n        nrows_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None) =\n    (let matrix_to_iarray_A = matrix_to_iarray A;\n         GJ = Gauss_Jordan_iarrays_PA matrix_to_iarray_A\n     in if nrows_iarray matrix_to_iarray_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)))\n        then Some (fst GJ) else None)", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of (Gauss_Jordan_iarrays (matrix_to_iarray A)))) =\n        nrows_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None) =\n    (if nrows_iarray (matrix_to_iarray A) =\n        length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of\n             (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None)", "unfolding matrix_to_iarray_snd_Gauss_Jordan_PA[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of (Gauss_Jordan_iarrays (matrix_to_iarray A)))) =\n        nrows_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None) =\n    (if nrows_iarray (matrix_to_iarray A) =\n        length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of (matrix_to_iarray (snd (Gauss_Jordan_PA A)))))\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None)", "unfolding Gauss_Jordan_PA_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of (Gauss_Jordan_iarrays (matrix_to_iarray A)))) =\n        nrows_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None) =\n    (if nrows_iarray (matrix_to_iarray A) =\n        length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of (matrix_to_iarray (Gauss_Jordan A))))\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None)", "unfolding matrix_to_iarray_Gauss_Jordan"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of (Gauss_Jordan_iarrays (matrix_to_iarray A)))) =\n        nrows_iarray (matrix_to_iarray A)\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None) =\n    (if nrows_iarray (matrix_to_iarray A) =\n        length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of (Gauss_Jordan_iarrays (matrix_to_iarray A))))\n     then Some (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     else None)", "by presburger"], ["", "lemma[code_unfold]:\nshows \"inverse_matrix_iarray A = (let A' = (Gauss_Jordan_iarrays_PA A); nrows = IArray.length A in \n                                (if length [x\\<leftarrow>IArray.list_of (snd A') . \\<not> is_zero_iarray x] = nrows \n                                then Some (fst A') else None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_matrix_iarray A =\n    (let A' = Gauss_Jordan_iarrays_PA A; nrows = IArray.length A\n     in if length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd A'))) =\n           nrows\n        then Some (fst A') else None)", "unfolding inverse_matrix_iarray_def invertible_iarray_def rank_iarrays_code Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of (Gauss_Jordan_iarrays A))) =\n        nrows_iarray A\n     then Some (fst (Gauss_Jordan_iarrays_PA A)) else None) =\n    (if length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of (snd (Gauss_Jordan_iarrays_PA A)))) =\n        IArray.length A\n     then Some (fst (Gauss_Jordan_iarrays_PA A)) else None)", "unfolding nrows_iarray_def snd_Gauss_Jordan_iarrays_PA_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of (Gauss_Jordan_iarrays A))) =\n        IArray.length A\n     then Some (fst (Gauss_Jordan_iarrays_PA A)) else None) =\n    (if length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of (Gauss_Jordan_iarrays A))) =\n        IArray.length A\n     then Some (fst (Gauss_Jordan_iarrays_PA A)) else None)", ".."], ["", "end"]]}