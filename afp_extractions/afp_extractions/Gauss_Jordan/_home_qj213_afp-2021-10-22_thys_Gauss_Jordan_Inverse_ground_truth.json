{"file_name": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan/Inverse.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan", "problem_names": ["lemma rref_id_implies_invertible:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes Gauss_mat_1: \"Gauss_Jordan A = mat 1\"\nshows \"invertible A\"", "lemma full_rank_implies_invertible:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes rank_n: \"rank A = nrows A\"\nshows \"invertible A\"", "lemma invertible_implies_full_rank:\n  fixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\n  assumes inv_A: \"invertible A\"\n  shows \"rank A = nrows A\"", "lemma id_upt_nrows_mat_1:\nassumes \"id_upt_k A (nrows A)\"\nshows \"A = mat 1\"", "lemma id_upt_k_Gauss_Jordan:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes inv_A: \"invertible A\"\nshows \"id_upt_k (Gauss_Jordan A) k\"", "lemma invertible_implies_rref_id:\n  fixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\n  assumes inv_A: \"invertible A\"\n  shows \"Gauss_Jordan A = mat 1\"", "lemma matrix_inv_Gauss:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes inv_A: \"invertible A\" and Gauss_eq: \"Gauss_Jordan A = P ** A\"\nshows \"matrix_inv A = P\"", "lemma matrix_inv_Gauss_Jordan_PA:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes inv_A: \"invertible A\"\nshows \"matrix_inv A = fst (Gauss_Jordan_PA A)\"", "lemma invertible_eq_full_rank[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"invertible A = (rank A = nrows A)\"", "lemma the_inverse_matrix:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes \"invertible A\"\nshows \"the (inverse_matrix A) = P_Gauss_Jordan A\"", "lemma inverse_matrix:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"inverse_matrix A = (if invertible A then Some (P_Gauss_Jordan A) else None)\"", "lemma inverse_matrix_code[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"inverse_matrix A = (let GJ = Gauss_Jordan_PA A;\n                                rank_A = (if A = 0 then 0 else to_nat (GREATEST a. row a (snd GJ) \\<noteq> 0) + 1) in \n                                if nrows A = rank_A then Some (fst(GJ)) else None)\""], "translations": [["", "lemma rref_id_implies_invertible:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes Gauss_mat_1: \"Gauss_Jordan A = mat 1\"\nshows \"invertible A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invertible A", "obtain P where P: \"invertible P\" and PA: \"Gauss_Jordan A = P ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P; Gauss_Jordan A = P ** A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using invertible_Gauss_Jordan[of A]"], ["proof (prove)\nusing this:\n  \\<exists>P. invertible P \\<and> Gauss_Jordan A = P ** A\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P; Gauss_Jordan A = P ** A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  invertible P\n  Gauss_Jordan A = P ** A\n\ngoal (1 subgoal):\n 1. invertible A", "have \"A = mat 1 ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = mat (1::'a) ** A", "unfolding matrix_mul_lid"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A", ".."], ["proof (state)\nthis:\n  A = mat (1::'a) ** A\n\ngoal (1 subgoal):\n 1. invertible A", "also"], ["proof (state)\nthis:\n  A = mat (1::'a) ** A\n\ngoal (1 subgoal):\n 1. invertible A", "have \"... = (matrix_inv P ** P) ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (1::'a) ** A = matrix_inv P ** P ** A", "using P invertible_def matrix_inv_unique"], ["proof (prove)\nusing this:\n  invertible P\n  invertible ?A =\n  (\\<exists>A'. ?A ** A' = mat (1::?'a) \\<and> A' ** ?A = mat (1::?'a))\n  \\<lbrakk>?A ** ?B = mat (1::?'a); ?B ** ?A = mat (1::?'a)\\<rbrakk>\n  \\<Longrightarrow> matrix_inv ?A = ?B\n\ngoal (1 subgoal):\n 1. mat (1::'a) ** A = matrix_inv P ** P ** A", "by metis"], ["proof (state)\nthis:\n  mat (1::'a) ** A = matrix_inv P ** P ** A\n\ngoal (1 subgoal):\n 1. invertible A", "also"], ["proof (state)\nthis:\n  mat (1::'a) ** A = matrix_inv P ** P ** A\n\ngoal (1 subgoal):\n 1. invertible A", "have \"... = (matrix_inv P) ** (P ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_inv P ** P ** A = matrix_inv P ** (P ** A)", "by (metis PA assms calculation matrix_eq matrix_vector_mul_assoc matrix_vector_mul_lid)"], ["proof (state)\nthis:\n  matrix_inv P ** P ** A = matrix_inv P ** (P ** A)\n\ngoal (1 subgoal):\n 1. invertible A", "also"], ["proof (state)\nthis:\n  matrix_inv P ** P ** A = matrix_inv P ** (P ** A)\n\ngoal (1 subgoal):\n 1. invertible A", "have \"... = (matrix_inv P) ** mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_inv P ** (P ** A) = matrix_inv P ** mat (1::'a)", "unfolding PA[symmetric] Gauss_mat_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_inv P ** mat (1::'a) = matrix_inv P ** mat (1::'a)", ".."], ["proof (state)\nthis:\n  matrix_inv P ** (P ** A) = matrix_inv P ** mat (1::'a)\n\ngoal (1 subgoal):\n 1. invertible A", "also"], ["proof (state)\nthis:\n  matrix_inv P ** (P ** A) = matrix_inv P ** mat (1::'a)\n\ngoal (1 subgoal):\n 1. invertible A", "have \"... = (matrix_inv P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_inv P ** mat (1::'a) = matrix_inv P", "unfolding matrix_mul_rid"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_inv P = matrix_inv P", ".."], ["proof (state)\nthis:\n  matrix_inv P ** mat (1::'a) = matrix_inv P\n\ngoal (1 subgoal):\n 1. invertible A", "finally"], ["proof (chain)\npicking this:\n  A = matrix_inv P", "have \"A = (matrix_inv P)\""], ["proof (prove)\nusing this:\n  A = matrix_inv P\n\ngoal (1 subgoal):\n 1. A = matrix_inv P", "."], ["proof (state)\nthis:\n  A = matrix_inv P\n\ngoal (1 subgoal):\n 1. invertible A", "thus ?thesis"], ["proof (prove)\nusing this:\n  A = matrix_inv P\n\ngoal (1 subgoal):\n 1. invertible A", "using P"], ["proof (prove)\nusing this:\n  A = matrix_inv P\n  invertible P\n\ngoal (1 subgoal):\n 1. invertible A", "unfolding invertible_def"], ["proof (prove)\nusing this:\n  A = matrix_inv P\n  \\<exists>A'. P ** A' = mat (1::'a) \\<and> A' ** P = mat (1::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>A'. A ** A' = mat (1::'a) \\<and> A' ** A = mat (1::'a)", "using matrix_inv_unique"], ["proof (prove)\nusing this:\n  A = matrix_inv P\n  \\<exists>A'. P ** A' = mat (1::'a) \\<and> A' ** P = mat (1::'a)\n  \\<lbrakk>?A ** ?B = mat (1::?'a); ?B ** ?A = mat (1::?'a)\\<rbrakk>\n  \\<Longrightarrow> matrix_inv ?A = ?B\n\ngoal (1 subgoal):\n 1. \\<exists>A'. A ** A' = mat (1::'a) \\<and> A' ** A = mat (1::'a)", "by blast"], ["proof (state)\nthis:\n  invertible A\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>In the following case, nrows is equivalent to ncols due to we are working with a square matrix\\<close>"], ["", "lemma full_rank_implies_invertible:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes rank_n: \"rank A = nrows A\"\nshows \"invertible A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible A", "proof (unfold invertible_left_inverse[of A] matrix_left_invertible_ker, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. A *v x = 0 \\<Longrightarrow> x = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. A *v x = 0 \\<Longrightarrow> x = 0", "assume Ax: \"A *v x = 0\""], ["proof (state)\nthis:\n  A *v x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. A *v x = 0 \\<Longrightarrow> x = 0", "have rank_eq_card_n: \"rank A = CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = CARD('n)", "using rank_n"], ["proof (prove)\nusing this:\n  rank A = nrows A\n\ngoal (1 subgoal):\n 1. rank A = CARD('n)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  rank A = CARD('n)\n\ngoal (1 subgoal):\n 1. rank A = CARD('n)", "."], ["proof (state)\nthis:\n  rank A = CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>x. A *v x = 0 \\<Longrightarrow> x = 0", "have \"vec.dim (null_space A)=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (null_space A) = 0", "unfolding dim_null_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis - rank A = 0", "unfolding rank_eq_card_n dimension_vector"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('n) - CARD('n) = 0", "by simp"], ["proof (state)\nthis:\n  vec.dim (null_space A) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. A *v x = 0 \\<Longrightarrow> x = 0", "hence \"null_space A = {0}\""], ["proof (prove)\nusing this:\n  vec.dim (null_space A) = 0\n\ngoal (1 subgoal):\n 1. null_space A = {0}", "using vec.dim_zero_eq"], ["proof (prove)\nusing this:\n  vec.dim (null_space A) = 0\n  vec.dim ?A = 0 \\<Longrightarrow> ?A = {} \\<or> ?A = {0}\n\ngoal (1 subgoal):\n 1. null_space A = {0}", "using Ax null_space_def"], ["proof (prove)\nusing this:\n  vec.dim (null_space A) = 0\n  vec.dim ?A = 0 \\<Longrightarrow> ?A = {} \\<or> ?A = {0}\n  A *v x = 0\n  null_space ?A = {x. ?A *v x = 0}\n\ngoal (1 subgoal):\n 1. null_space A = {0}", "by auto"], ["proof (state)\nthis:\n  null_space A = {0}\n\ngoal (1 subgoal):\n 1. \\<And>x. A *v x = 0 \\<Longrightarrow> x = 0", "thus \"x = 0\""], ["proof (prove)\nusing this:\n  null_space A = {0}\n\ngoal (1 subgoal):\n 1. x = 0", "unfolding null_space_def"], ["proof (prove)\nusing this:\n  {x. A *v x = 0} = {0}\n\ngoal (1 subgoal):\n 1. x = 0", "using Ax"], ["proof (prove)\nusing this:\n  {x. A *v x = 0} = {0}\n  A *v x = 0\n\ngoal (1 subgoal):\n 1. x = 0", "by blast"], ["proof (state)\nthis:\n  x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invertible_implies_full_rank:\n  fixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\n  assumes inv_A: \"invertible A\"\n  shows \"rank A = nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = nrows A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rank A = nrows A", "have \"(\\<forall>x. A *v x = 0 \\<longrightarrow> x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. A *v x = 0 \\<longrightarrow> x = 0", "using inv_A"], ["proof (prove)\nusing this:\n  invertible A\n\ngoal (1 subgoal):\n 1. \\<forall>x. A *v x = 0 \\<longrightarrow> x = 0", "unfolding  invertible_left_inverse[unfolded matrix_left_invertible_ker]"], ["proof (prove)\nusing this:\n  \\<forall>x. A *v x = 0 \\<longrightarrow> x = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x. A *v x = 0 \\<longrightarrow> x = 0", "."], ["proof (state)\nthis:\n  \\<forall>x. A *v x = 0 \\<longrightarrow> x = 0\n\ngoal (1 subgoal):\n 1. rank A = nrows A", "hence null_space_eq_0: \"(null_space A) = {0}\""], ["proof (prove)\nusing this:\n  \\<forall>x. A *v x = 0 \\<longrightarrow> x = 0\n\ngoal (1 subgoal):\n 1. null_space A = {0}", "unfolding null_space_def"], ["proof (prove)\nusing this:\n  \\<forall>x. A *v x = 0 \\<longrightarrow> x = 0\n\ngoal (1 subgoal):\n 1. {x. A *v x = 0} = {0}", "using matrix_vector_mult_0_right"], ["proof (prove)\nusing this:\n  \\<forall>x. A *v x = 0 \\<longrightarrow> x = 0\n  ?A *v 0 = 0\n\ngoal (1 subgoal):\n 1. {x. A *v x = 0} = {0}", "by fast"], ["proof (state)\nthis:\n  null_space A = {0}\n\ngoal (1 subgoal):\n 1. rank A = nrows A", "have dim_null_space: \"vec.dim (null_space A) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (null_space A) = 0", "unfolding vec.dim_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>b.\n           vec.independent b \\<and> vec.span b = vec.span (null_space A)\n     then card\n           (SOME b.\n               vec.independent b \\<and>\n               vec.span b = vec.span (null_space A))\n     else 0) =\n    0", "by (metis (no_types) null_space_eq_0 vec.dim_def vec.dim_zero_eq')"], ["proof (state)\nthis:\n  vec.dim (null_space A) = 0\n\ngoal (1 subgoal):\n 1. rank A = nrows A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = nrows A", "using rank_nullity_theorem_matrices[of A]"], ["proof (prove)\nusing this:\n  ncols A = vec.dim (null_space A) + vec.dim (col_space A)\n\ngoal (1 subgoal):\n 1. rank A = nrows A", "unfolding dim_null_space rank_eq_dim_col_space nrows_def"], ["proof (prove)\nusing this:\n  ncols A = 0 + vec.dim (col_space A)\n\ngoal (1 subgoal):\n 1. vec.dim (col_space A) = CARD('n)", "unfolding col_space_eq"], ["proof (prove)\nusing this:\n  ncols A = 0 + vec.dim {y. \\<exists>x. A *v x = y}\n\ngoal (1 subgoal):\n 1. vec.dim {y. \\<exists>x. A *v x = y} = CARD('n)", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  CARD('n) = 0 + vec.dim {y. \\<exists>x. A *v x = y}\n\ngoal (1 subgoal):\n 1. vec.dim {y. \\<exists>x. A *v x = y} = CARD('n)", "by simp"], ["proof (state)\nthis:\n  rank A = nrows A\n\ngoal:\nNo subgoals!", "qed"], ["", "definition id_upt_k :: \"'a::{zero, one}^'n::{mod_type}^'n::{mod_type} \\<Rightarrow> nat => bool\"\nwhere \"id_upt_k A k = (\\<forall>i j. to_nat i < k \\<and> to_nat j < k \\<longrightarrow> ((i = j \\<longrightarrow> A $ i $ j = 1) \\<and> (i \\<noteq> j \\<longrightarrow> A $ i $ j = 0)))\""], ["", "lemma id_upt_nrows_mat_1:\nassumes \"id_upt_k A (nrows A)\"\nshows \"A = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = mat (1::'a)", "unfolding mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = (\\<chi>i j. if i = j then 1::'a else (0::'a))", "apply vector"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       (i = ia \\<longrightarrow> A $ ia $ ia = (1::'a)) \\<and>\n       (i \\<noteq> ia \\<longrightarrow> A $ i $ ia = (0::'a))", "using assms"], ["proof (prove)\nusing this:\n  id_upt_k A (nrows A)\n\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       (i = ia \\<longrightarrow> A $ ia $ ia = (1::'a)) \\<and>\n       (i \\<noteq> ia \\<longrightarrow> A $ i $ ia = (0::'a))", "unfolding id_upt_k_def nrows_def"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     mod_type_class.to_nat i < CARD('b) \\<and>\n     mod_type_class.to_nat j < CARD('b) \\<longrightarrow>\n     (i = j \\<longrightarrow> A $ i $ j = (1::'a)) \\<and>\n     (i \\<noteq> j \\<longrightarrow> A $ i $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       (i = ia \\<longrightarrow> A $ ia $ ia = (1::'a)) \\<and>\n       (i \\<noteq> ia \\<longrightarrow> A $ i $ ia = (0::'a))", "using to_nat_less_card[where ?'a='b]"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     mod_type_class.to_nat i < CARD('b) \\<and>\n     mod_type_class.to_nat j < CARD('b) \\<longrightarrow>\n     (i = j \\<longrightarrow> A $ i $ j = (1::'a)) \\<and>\n     (i \\<noteq> j \\<longrightarrow> A $ i $ j = (0::'a))\n  mod_type_class.to_nat ?j < CARD('b)\n\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       (i = ia \\<longrightarrow> A $ ia $ ia = (1::'a)) \\<and>\n       (i \\<noteq> ia \\<longrightarrow> A $ i $ ia = (0::'a))", "by presburger"], ["", "subsection\\<open>Computing the inverse of a matrix using the Gauss Jordan algorithm\\<close>"], ["", "text\\<open>This lemma is essential to demonstrate that the Gauss Jordan form of an invertible matrix is the identity. \n  The proof is made by induction and it is explained in \n  @{url \"http://www.unirioja.es/cu/jodivaso/Isabelle/Gauss-Jordan-2013-2-Generalized/Demonstration_invertible.pdf\"}\\<close>"], ["", "lemma id_upt_k_Gauss_Jordan:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes inv_A: \"invertible A\"\nshows \"id_upt_k (Gauss_Jordan A) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id_upt_k (Gauss_Jordan A) k", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. id_upt_k (Gauss_Jordan A) 0\n 2. \\<And>k.\n       id_upt_k (Gauss_Jordan A) k \\<Longrightarrow>\n       id_upt_k (Gauss_Jordan A) (Suc k)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. id_upt_k (Gauss_Jordan A) 0\n 2. \\<And>k.\n       id_upt_k (Gauss_Jordan A) k \\<Longrightarrow>\n       id_upt_k (Gauss_Jordan A) (Suc k)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. id_upt_k (Gauss_Jordan A) 0", "unfolding id_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       mod_type_class.to_nat i < 0 \\<and>\n       mod_type_class.to_nat j < 0 \\<longrightarrow>\n       (i = j \\<longrightarrow> Gauss_Jordan A $ i $ j = (1::'a)) \\<and>\n       (i \\<noteq> j \\<longrightarrow> Gauss_Jordan A $ i $ j = (0::'a))", "by fast"], ["proof (state)\nthis:\n  id_upt_k (Gauss_Jordan A) 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       id_upt_k (Gauss_Jordan A) k \\<Longrightarrow>\n       id_upt_k (Gauss_Jordan A) (Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       id_upt_k (Gauss_Jordan A) k \\<Longrightarrow>\n       id_upt_k (Gauss_Jordan A) (Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  id_upt_k (Gauss_Jordan A) k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       id_upt_k (Gauss_Jordan A) k \\<Longrightarrow>\n       id_upt_k (Gauss_Jordan A) (Suc k)", "note id_k=Suc.hyps"], ["proof (state)\nthis:\n  id_upt_k (Gauss_Jordan A) k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       id_upt_k (Gauss_Jordan A) k \\<Longrightarrow>\n       id_upt_k (Gauss_Jordan A) (Suc k)", "have rref_k: \"reduced_row_echelon_form_upt_k (Gauss_Jordan A) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan A) k", "using rref_implies_rref_upt[OF rref_Gauss_Jordan]"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k (Gauss_Jordan ?A1) ?k\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan A) k", "."], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k (Gauss_Jordan A) k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       id_upt_k (Gauss_Jordan A) k \\<Longrightarrow>\n       id_upt_k (Gauss_Jordan A) (Suc k)", "have rref_suc_k: \"reduced_row_echelon_form_upt_k (Gauss_Jordan A) (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan A) (Suc k)", "using rref_implies_rref_upt[OF rref_Gauss_Jordan]"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k (Gauss_Jordan ?A1) ?k\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan A) (Suc k)", "."], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k (Gauss_Jordan A) (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       id_upt_k (Gauss_Jordan A) k \\<Longrightarrow>\n       id_upt_k (Gauss_Jordan A) (Suc k)", "have inv_gj: \"invertible (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (Gauss_Jordan A)", "by (metis inv_A invertible_Gauss_Jordan invertible_mult)"], ["proof (state)\nthis:\n  invertible (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       id_upt_k (Gauss_Jordan A) k \\<Longrightarrow>\n       id_upt_k (Gauss_Jordan A) (Suc k)", "show \"id_upt_k (Gauss_Jordan A) (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id_upt_k (Gauss_Jordan A) (Suc k)", "proof (unfold id_upt_k_def, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       mod_type_class.to_nat j < Suc k \\<Longrightarrow>\n       Gauss_Jordan A $ j $ j = (1::'a)\n 2. \\<And>i j.\n       \\<lbrakk>mod_type_class.to_nat i < Suc k;\n        mod_type_class.to_nat j < Suc k; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan A $ i $ j = (0::'a)", "fix j::'n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       mod_type_class.to_nat j < Suc k \\<Longrightarrow>\n       Gauss_Jordan A $ j $ j = (1::'a)\n 2. \\<And>i j.\n       \\<lbrakk>mod_type_class.to_nat i < Suc k;\n        mod_type_class.to_nat j < Suc k; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan A $ i $ j = (0::'a)", "assume j_less_suc: \"to_nat j < Suc k\"\n\\<comment> \\<open>First of all we prove a property which will be useful later\\<close>"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < Suc k\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       mod_type_class.to_nat j < Suc k \\<Longrightarrow>\n       Gauss_Jordan A $ j $ j = (1::'a)\n 2. \\<And>i j.\n       \\<lbrakk>mod_type_class.to_nat i < Suc k;\n        mod_type_class.to_nat j < Suc k; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan A $ i $ j = (0::'a)", "have greatest_prop: \"j \\<noteq> 0 \\<Longrightarrow> to_nat j = k \\<Longrightarrow> (GREATEST m. \\<not> is_zero_row_upt_k m k (Gauss_Jordan A)) = j - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<noteq> (0::'n); mod_type_class.to_nat j = k\\<rbrakk>\n    \\<Longrightarrow> (GREATEST m.\n                          \\<not> is_zero_row_upt_k m k (Gauss_Jordan A)) =\n                      j - (1::'n)", "proof (rule Greatest_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>j \\<noteq> (0::'n); mod_type_class.to_nat j = k\\<rbrakk>\n    \\<Longrightarrow> \\<not> is_zero_row_upt_k (j - (1::'n)) k\n                              (Gauss_Jordan A)\n 2. \\<And>y.\n       \\<lbrakk>j \\<noteq> (0::'n); mod_type_class.to_nat j = k;\n        \\<not> is_zero_row_upt_k y k (Gauss_Jordan A)\\<rbrakk>\n       \\<Longrightarrow> y \\<le> j - (1::'n)", "assume j_not_zero: \"j \\<noteq> 0\" and j_eq_k: \"to_nat j = k\""], ["proof (state)\nthis:\n  j \\<noteq> (0::'n)\n  mod_type_class.to_nat j = k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j \\<noteq> (0::'n); mod_type_class.to_nat j = k\\<rbrakk>\n    \\<Longrightarrow> \\<not> is_zero_row_upt_k (j - (1::'n)) k\n                              (Gauss_Jordan A)\n 2. \\<And>y.\n       \\<lbrakk>j \\<noteq> (0::'n); mod_type_class.to_nat j = k;\n        \\<not> is_zero_row_upt_k y k (Gauss_Jordan A)\\<rbrakk>\n       \\<Longrightarrow> y \\<le> j - (1::'n)", "have j_minus_1: \"to_nat (j - 1) < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (j - (1::'n)) < k", "by (metis (full_types) Suc_le' diff_add_cancel j_eq_k j_not_zero to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (j - (1::'n)) < k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j \\<noteq> (0::'n); mod_type_class.to_nat j = k\\<rbrakk>\n    \\<Longrightarrow> \\<not> is_zero_row_upt_k (j - (1::'n)) k\n                              (Gauss_Jordan A)\n 2. \\<And>y.\n       \\<lbrakk>j \\<noteq> (0::'n); mod_type_class.to_nat j = k;\n        \\<not> is_zero_row_upt_k y k (Gauss_Jordan A)\\<rbrakk>\n       \\<Longrightarrow> y \\<le> j - (1::'n)", "show \"\\<not> is_zero_row_upt_k (j - 1) k (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (j - (1::'n)) k (Gauss_Jordan A)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ja.\n               mod_type_class.to_nat ja < k \\<longrightarrow>\n               Gauss_Jordan A $ (j - (1::'n)) $ ja = (0::'a))", "proof (auto, rule exI[of _ \"j - 1\"], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat (j - (1::'n)) < k\n 2. Gauss_Jordan A $ (j - (1::'n)) $ (j - (1::'n)) \\<noteq> (0::'a)", "show \"to_nat (j - 1) < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (j - (1::'n)) < k", "using j_minus_1"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (j - (1::'n)) < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (j - (1::'n)) < k", "."], ["proof (state)\nthis:\n  mod_type_class.to_nat (j - (1::'n)) < k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ (j - (1::'n)) $ (j - (1::'n)) \\<noteq> (0::'a)", "show \"Gauss_Jordan A $ (j - 1) $ (j - 1) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ (j - (1::'n)) $ (j - (1::'n)) \\<noteq> (0::'a)", "using id_k"], ["proof (prove)\nusing this:\n  id_upt_k (Gauss_Jordan A) k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ (j - (1::'n)) $ (j - (1::'n)) \\<noteq> (0::'a)", "unfolding id_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     mod_type_class.to_nat i < k \\<and>\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     (i = j \\<longrightarrow> Gauss_Jordan A $ i $ j = (1::'a)) \\<and>\n     (i \\<noteq> j \\<longrightarrow> Gauss_Jordan A $ i $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ (j - (1::'n)) $ (j - (1::'n)) \\<noteq> (0::'a)", "using j_minus_1"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     mod_type_class.to_nat i < k \\<and>\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     (i = j \\<longrightarrow> Gauss_Jordan A $ i $ j = (1::'a)) \\<and>\n     (i \\<noteq> j \\<longrightarrow> Gauss_Jordan A $ i $ j = (0::'a))\n  mod_type_class.to_nat (j - (1::'n)) < k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ (j - (1::'n)) $ (j - (1::'n)) \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  Gauss_Jordan A $ (j - (1::'n)) $ (j - (1::'n)) \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k (j - (1::'n)) k (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>j \\<noteq> (0::'n); mod_type_class.to_nat j = k;\n        \\<not> is_zero_row_upt_k y k (Gauss_Jordan A)\\<rbrakk>\n       \\<Longrightarrow> y \\<le> j - (1::'n)", "fix a::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>j \\<noteq> (0::'n); mod_type_class.to_nat j = k;\n        \\<not> is_zero_row_upt_k y k (Gauss_Jordan A)\\<rbrakk>\n       \\<Longrightarrow> y \\<le> j - (1::'n)", "assume not_zero_a: \"\\<not> is_zero_row_upt_k a k (Gauss_Jordan A)\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a k (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>j \\<noteq> (0::'n); mod_type_class.to_nat j = k;\n        \\<not> is_zero_row_upt_k y k (Gauss_Jordan A)\\<rbrakk>\n       \\<Longrightarrow> y \\<le> j - (1::'n)", "show \"a \\<le> j - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> j - (1::'n)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<le> j - (1::'n) \\<Longrightarrow> False", "assume \" \\<not> a \\<le> j - 1\""], ["proof (state)\nthis:\n  \\<not> a \\<le> j - (1::'n)\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> j - (1::'n) \\<Longrightarrow> False", "hence a_greater_i_minus_1: \"a > j - 1\""], ["proof (prove)\nusing this:\n  \\<not> a \\<le> j - (1::'n)\n\ngoal (1 subgoal):\n 1. j - (1::'n) < a", "by simp"], ["proof (state)\nthis:\n  j - (1::'n) < a\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> j - (1::'n) \\<Longrightarrow> False", "have \"is_zero_row_upt_k a k (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k (Gauss_Jordan A)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       mod_type_class.to_nat j < k \\<longrightarrow>\n       Gauss_Jordan A $ a $ j = (0::'a)", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan A $ a $ j = (0::'a)", "fix b::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan A $ a $ j = (0::'a)", "assume a: \"to_nat b < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat b < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan A $ a $ j = (0::'a)", "have Least_eq: \"(LEAST n. Gauss_Jordan A $ b $ n \\<noteq> 0) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Gauss_Jordan A $ b $ n \\<noteq> (0::'a)) = b", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan A $ b $ b \\<noteq> (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan A $ b $ y \\<noteq> (0::'a) \\<Longrightarrow> b \\<le> y", "show \"Gauss_Jordan A $ b $ b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ b $ b \\<noteq> (0::'a)", "by (metis a id_k id_upt_k_def zero_neq_one)"], ["proof (state)\nthis:\n  Gauss_Jordan A $ b $ b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan A $ b $ y \\<noteq> (0::'a) \\<Longrightarrow> b \\<le> y", "show \"\\<And>y. Gauss_Jordan A $ b $ y \\<noteq> 0 \\<Longrightarrow> b \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan A $ b $ y \\<noteq> (0::'a) \\<Longrightarrow> b \\<le> y", "by (metis (hide_lams, no_types) a not_less_iff_gr_or_eq id_k id_upt_k_def less_trans not_less to_nat_mono)"], ["proof (state)\nthis:\n  Gauss_Jordan A $ b $ ?y \\<noteq> (0::'a) \\<Longrightarrow> b \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. Gauss_Jordan A $ b $ n \\<noteq> (0::'a)) = b\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan A $ a $ j = (0::'a)", "moreover"], ["proof (state)\nthis:\n  (LEAST n. Gauss_Jordan A $ b $ n \\<noteq> (0::'a)) = b\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan A $ a $ j = (0::'a)", "have \"\\<not> is_zero_row_upt_k b k (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k b k (Gauss_Jordan A)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < k \\<longrightarrow>\n               Gauss_Jordan A $ b $ j = (0::'a))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j.\n       mod_type_class.to_nat j < k \\<and>\n       Gauss_Jordan A $ b $ j \\<noteq> (0::'a)", "apply (rule exI[of _ b])"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat b < k \\<and>\n    Gauss_Jordan A $ b $ b \\<noteq> (0::'a)", "using a id_k"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat b < k\n  id_upt_k (Gauss_Jordan A) k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat b < k \\<and>\n    Gauss_Jordan A $ b $ b \\<noteq> (0::'a)", "unfolding id_upt_k_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat b < k\n  \\<forall>i j.\n     mod_type_class.to_nat i < k \\<and>\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     (i = j \\<longrightarrow> Gauss_Jordan A $ i $ j = (1::'a)) \\<and>\n     (i \\<noteq> j \\<longrightarrow> Gauss_Jordan A $ i $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat b < k \\<and>\n    Gauss_Jordan A $ b $ b \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k b k (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan A $ a $ j = (0::'a)", "moreover"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k b k (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan A $ a $ j = (0::'a)", "have \"a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> b", "have \"b < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < mod_type_class.from_nat k", "by (metis a from_nat_to_nat_id j_eq_k not_less_iff_gr_or_eq to_nat_le)"], ["proof (state)\nthis:\n  b < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "also"], ["proof (state)\nthis:\n  b < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "have \"... = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = j", "using j_eq_k to_nat_from_nat"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j = k\n  mod_type_class.to_nat ?j = ?k \\<Longrightarrow>\n  mod_type_class.from_nat ?k = ?j\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = j", "by auto"], ["proof (state)\nthis:\n  mod_type_class.from_nat k = j\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "also"], ["proof (state)\nthis:\n  mod_type_class.from_nat k = j\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "have \"... \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> a", "using a_greater_i_minus_1"], ["proof (prove)\nusing this:\n  j - (1::'n) < a\n\ngoal (1 subgoal):\n 1. j \\<le> a", "by (metis diff_add_cancel le_Suc)"], ["proof (state)\nthis:\n  j \\<le> a\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "finally"], ["proof (chain)\npicking this:\n  b < a", "show ?thesis"], ["proof (prove)\nusing this:\n  b < a\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by simp"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan A $ a $ j = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  (LEAST n. Gauss_Jordan A $ b $ n \\<noteq> (0::'a)) = b\n  \\<not> is_zero_row_upt_k b k (Gauss_Jordan A)\n  a \\<noteq> b", "show \"Gauss_Jordan A $ a $ b = 0\""], ["proof (prove)\nusing this:\n  (LEAST n. Gauss_Jordan A $ b $ n \\<noteq> (0::'a)) = b\n  \\<not> is_zero_row_upt_k b k (Gauss_Jordan A)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ a $ b = (0::'a)", "using rref_upt_condition4[OF rref_k]"], ["proof (prove)\nusing this:\n  (LEAST n. Gauss_Jordan A $ b $ n \\<noteq> (0::'a)) = b\n  \\<not> is_zero_row_upt_k b k (Gauss_Jordan A)\n  a \\<noteq> b\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k (Gauss_Jordan A) \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         Gauss_Jordan A $ j $\n         (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) =\n         (0::'a))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ a $ b = (0::'a)", "by auto"], ["proof (state)\nthis:\n  Gauss_Jordan A $ a $ b = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k a k (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> j - (1::'n) \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k a k (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. False", "using not_zero_a"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k a k (Gauss_Jordan A)\n  \\<not> is_zero_row_upt_k a k (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<le> j - (1::'n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>j \\<noteq> (0::'n); mod_type_class.to_nat j = k\\<rbrakk>\n  \\<Longrightarrow> (GREATEST m.\n                        \\<not> is_zero_row_upt_k m k (Gauss_Jordan A)) =\n                    j - (1::'n)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       mod_type_class.to_nat j < Suc k \\<Longrightarrow>\n       Gauss_Jordan A $ j $ j = (1::'a)\n 2. \\<And>i j.\n       \\<lbrakk>mod_type_class.to_nat i < Suc k;\n        mod_type_class.to_nat j < Suc k; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan A $ i $ j = (0::'a)", "show Gauss_jj_1: \"Gauss_Jordan A $ j $ j = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $ j = (1::'a)", "proof (cases \"j=0\")\n\\<comment> \\<open>In case that j be zero, the result is trivial\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. j = (0::'n) \\<Longrightarrow> Gauss_Jordan A $ j $ j = (1::'a)\n 2. j \\<noteq> (0::'n) \\<Longrightarrow> Gauss_Jordan A $ j $ j = (1::'a)", "case True"], ["proof (state)\nthis:\n  j = (0::'n)\n\ngoal (2 subgoals):\n 1. j = (0::'n) \\<Longrightarrow> Gauss_Jordan A $ j $ j = (1::'a)\n 2. j \\<noteq> (0::'n) \\<Longrightarrow> Gauss_Jordan A $ j $ j = (1::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $ j = (1::'a)", "proof (unfold True, rule rref_first_element)"], ["proof (state)\ngoal (2 subgoals):\n 1. reduced_row_echelon_form (Gauss_Jordan A)\n 2. column (0::'n) (Gauss_Jordan A) \\<noteq> 0", "show \"reduced_row_echelon_form (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form (Gauss_Jordan A)", "by (rule rref_Gauss_Jordan)"], ["proof (state)\nthis:\n  reduced_row_echelon_form (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. column (0::'n) (Gauss_Jordan A) \\<noteq> 0", "show \"column 0 (Gauss_Jordan A) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (0::'n) (Gauss_Jordan A) \\<noteq> 0", "by (metis det_zero_column inv_gj invertible_det_nz)"], ["proof (state)\nthis:\n  column (0::'n) (Gauss_Jordan A) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ j = (1::'a)\n\ngoal (1 subgoal):\n 1. j \\<noteq> (0::'n) \\<Longrightarrow> Gauss_Jordan A $ j $ j = (1::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> (0::'n) \\<Longrightarrow> Gauss_Jordan A $ j $ j = (1::'a)", "case False"], ["proof (state)\nthis:\n  j \\<noteq> (0::'n)\n\ngoal (1 subgoal):\n 1. j \\<noteq> (0::'n) \\<Longrightarrow> Gauss_Jordan A $ j $ j = (1::'a)", "note j_not_zero = False"], ["proof (state)\nthis:\n  j \\<noteq> (0::'n)\n\ngoal (1 subgoal):\n 1. j \\<noteq> (0::'n) \\<Longrightarrow> Gauss_Jordan A $ j $ j = (1::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $ j = (1::'a)", "proof (cases \"to_nat j < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat j < k \\<Longrightarrow>\n    Gauss_Jordan A $ j $ j = (1::'a)\n 2. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow>\n    Gauss_Jordan A $ j $ j = (1::'a)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat j < k \\<Longrightarrow>\n    Gauss_Jordan A $ j $ j = (1::'a)\n 2. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow>\n    Gauss_Jordan A $ j $ j = (1::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $ j = (1::'a)", "using id_k"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n  id_upt_k (Gauss_Jordan A) k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $ j = (1::'a)", "unfolding id_upt_k_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n  \\<forall>i j.\n     mod_type_class.to_nat i < k \\<and>\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     (i = j \\<longrightarrow> Gauss_Jordan A $ i $ j = (1::'a)) \\<and>\n     (i \\<noteq> j \\<longrightarrow> Gauss_Jordan A $ i $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $ j = (1::'a)", "by presburger  \\<comment> \\<open>Easy due to the inductive hypothesis\\<close>"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ j = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow>\n    Gauss_Jordan A $ j $ j = (1::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow>\n    Gauss_Jordan A $ j $ j = (1::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow>\n    Gauss_Jordan A $ j $ j = (1::'a)", "hence j_eq_k: \"to_nat j = k\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j = k", "using j_less_suc"], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat j < k\n  mod_type_class.to_nat j < Suc k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j = k", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat j = k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow>\n    Gauss_Jordan A $ j $ j = (1::'a)", "have j_minus_1: \"to_nat (j - 1) < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (j - (1::'n)) < k", "by (metis (full_types) Suc_le' diff_add_cancel j_eq_k j_not_zero to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (j - (1::'n)) < k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow>\n    Gauss_Jordan A $ j $ j = (1::'a)", "have \"(GREATEST m. \\<not> is_zero_row_upt_k m k (Gauss_Jordan A)) = j - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k (Gauss_Jordan A)) =\n    j - (1::'n)", "by (rule greatest_prop[OF j_not_zero j_eq_k])"], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k (Gauss_Jordan A)) = j - (1::'n)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow>\n    Gauss_Jordan A $ j $ j = (1::'a)", "hence zero_j_k: \"is_zero_row_upt_k j k (Gauss_Jordan A)\""], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k (Gauss_Jordan A)) = j - (1::'n)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j k (Gauss_Jordan A)", "by (metis not_le greatest_ge_nonzero_row j_eq_k j_minus_1 to_nat_mono')"], ["proof (state)\nthis:\n  is_zero_row_upt_k j k (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow>\n    Gauss_Jordan A $ j $ j = (1::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $ j = (1::'a)", "proof (rule ccontr, cases \"Gauss_Jordan A $ j $ j = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "note gauss_jj_not_0 = False"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "assume gauss_jj_not_1: \"Gauss_Jordan A $ j $ j \\<noteq> 1\""], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ j \\<noteq> (1::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "have \"(LEAST n. Gauss_Jordan A $ j $ n \\<noteq> 0) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow> j \\<le> y", "show \"Gauss_Jordan A $ j $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $ j \\<noteq> (0::'a)", "using gauss_jj_not_0"], ["proof (prove)\nusing this:\n  Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $ j \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow> j \\<le> y", "show \"\\<And>y. Gauss_Jordan A $ j $ y \\<noteq> 0 \\<Longrightarrow> j \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow> j \\<le> y", "by (metis le_less_linear is_zero_row_upt_k_def j_eq_k to_nat_mono zero_j_k)"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ ?y \\<noteq> (0::'a) \\<Longrightarrow> j \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"Gauss_Jordan A $ j $ (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> 0) \\<noteq> 1\""], ["proof (prove)\nusing this:\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $\n    (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) \\<noteq>\n    (1::'a)", "using gauss_jj_not_1"], ["proof (prove)\nusing this:\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j\n  Gauss_Jordan A $ j $ j \\<noteq> (1::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $\n    (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) \\<noteq>\n    (1::'a)", "by auto \\<comment> \\<open>Contradiction with the second condition of rref\\<close>"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) \\<noteq>\n  (1::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Gauss_Jordan A $ j $\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) \\<noteq>\n  (1::'a)\n\ngoal (1 subgoal):\n 1. False", "by (metis gauss_jj_not_0 is_zero_row_upt_k_def j_eq_k lessI rref_suc_k rref_upt_condition2)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "note gauss_jj_0 = True"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "have zero_j_suc_k: \"is_zero_row_upt_k j (Suc k) (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) (Gauss_Jordan A)", "by (rule is_zero_row_upt_k_suc[OF zero_j_k], metis gauss_jj_0 j_eq_k to_nat_from_nat)"], ["proof (state)\nthis:\n  is_zero_row_upt_k j (Suc k) (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<not> (\\<exists>B. B ** (Gauss_Jordan A) = mat 1)\" \\<comment> \\<open>This will be a contradiction\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>B. B ** Gauss_Jordan A = mat (1::'a)", "proof (unfold matrix_left_invertible_independent_columns, simp, \n                        rule exI[of _ \"\\<lambda>i. (if i < j then column j (Gauss_Jordan A) $ i else if i=j then -1 else 0)\"], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Sum>i\\<in>UNIV.\n       (if i < j then column j (Gauss_Jordan A) $ i\n        else if i = j then - (1::'a) else (0::'a)) *s\n       column i (Gauss_Jordan A)) =\n    0\n 2. \\<exists>i.\n       (if i < j then column j (Gauss_Jordan A) $ i\n        else if i = j then - (1::'a) else (0::'a)) \\<noteq>\n       (0::'a)", "show \"(\\<Sum>i\\<in>UNIV. (if i < j then column j (Gauss_Jordan A) $ i else if i=j then -1 else 0) *s column i (Gauss_Jordan A)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV.\n       (if i < j then column j (Gauss_Jordan A) $ i\n        else if i = j then - (1::'a) else (0::'a)) *s\n       column i (Gauss_Jordan A)) =\n    0", "proof (unfold vec_eq_iff sum_component, auto)\n                          \\<comment> \\<open>We write the column j in a linear combination of the previous ones, which is a contradiction (the matrix wouldn't be invertible)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<Sum>x\\<in>UNIV.\n          (if x < j then column j (Gauss_Jordan A) $ x\n           else if x = j then - (1::'a) else (0::'a)) *\n          column x (Gauss_Jordan A) $ i) =\n       (0::'a)", "let ?f=\"\\<lambda>i. (if i < j then column j (Gauss_Jordan A) $ i else if i=j then -1 else 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<Sum>x\\<in>UNIV.\n          (if x < j then column j (Gauss_Jordan A) $ x\n           else if x = j then - (1::'a) else (0::'a)) *\n          column x (Gauss_Jordan A) $ i) =\n       (0::'a)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<Sum>x\\<in>UNIV.\n          (if x < j then column j (Gauss_Jordan A) $ x\n           else if x = j then - (1::'a) else (0::'a)) *\n          column x (Gauss_Jordan A) $ i) =\n       (0::'a)", "let ?g=\"(\\<lambda>x. ?f x * column x (Gauss_Jordan A) $ i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<Sum>x\\<in>UNIV.\n          (if x < j then column j (Gauss_Jordan A) $ x\n           else if x = j then - (1::'a) else (0::'a)) *\n          column x (Gauss_Jordan A) $ i) =\n       (0::'a)", "show \"sum ?g UNIV = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "proof (cases \"i<j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)\n 2. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)\n 2. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "note i_less_j = True"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)\n 2. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "have sum_rw: \"sum ?g (UNIV - {i}) = ?g j + sum ?g ((UNIV - {i}) - {j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>UNIV - {i}.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (if j < j then column j (Gauss_Jordan A) $ j\n     else if j = j then - (1::'a) else (0::'a)) *\n    column j (Gauss_Jordan A) $ i +\n    (\\<Sum>x\\<in>UNIV - {i} - {j}.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i)", "proof (rule sum.remove)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (UNIV - {i})\n 2. j \\<in> UNIV - {i}", "show \"finite (UNIV - {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (UNIV - {i})", "using finite_code"], ["proof (prove)\nusing this:\n  finite ?A = True\n\ngoal (1 subgoal):\n 1. finite (UNIV - {i})", "by simp"], ["proof (state)\nthis:\n  finite (UNIV - {i})\n\ngoal (1 subgoal):\n 1. j \\<in> UNIV - {i}", "show \"j \\<in> UNIV - {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<in> UNIV - {i}", "using True"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. j \\<in> UNIV - {i}", "by blast"], ["proof (state)\nthis:\n  j \\<in> UNIV - {i}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>UNIV - {i}.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i) =\n  (if j < j then column j (Gauss_Jordan A) $ j\n   else if j = j then - (1::'a) else (0::'a)) *\n  column j (Gauss_Jordan A) $ i +\n  (\\<Sum>x\\<in>UNIV - {i} - {j}.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i)\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)\n 2. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "have sum_g0: \"sum ?g (UNIV - {i} - {j}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>UNIV - {i} - {j}.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "proof (rule sum.neutral, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> j; x \\<noteq> i; x < j;\n        column x (Gauss_Jordan A) $ i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> column j (Gauss_Jordan A) $ x = (0::'a)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> j; x \\<noteq> i; x < j;\n        column x (Gauss_Jordan A) $ i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> column j (Gauss_Jordan A) $ x = (0::'a)", "assume a_not_j: \"a \\<noteq> j\" and a_not_i: \"a \\<noteq> i\" and a_less_j: \"a < j\" and column_a_not_zero: \"column a (Gauss_Jordan A) $ i \\<noteq> 0\""], ["proof (state)\nthis:\n  a \\<noteq> j\n  a \\<noteq> i\n  a < j\n  column a (Gauss_Jordan A) $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> j; x \\<noteq> i; x < j;\n        column x (Gauss_Jordan A) $ i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> column j (Gauss_Jordan A) $ x = (0::'a)", "have \"Gauss_Jordan A $ i $ a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ a = (0::'a)", "using id_k"], ["proof (prove)\nusing this:\n  id_upt_k (Gauss_Jordan A) k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ a = (0::'a)", "unfolding id_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     mod_type_class.to_nat i < k \\<and>\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     (i = j \\<longrightarrow> Gauss_Jordan A $ i $ j = (1::'a)) \\<and>\n     (i \\<noteq> j \\<longrightarrow> Gauss_Jordan A $ i $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ a = (0::'a)", "using a_less_j j_eq_k"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     mod_type_class.to_nat i < k \\<and>\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     (i = j \\<longrightarrow> Gauss_Jordan A $ i $ j = (1::'a)) \\<and>\n     (i \\<noteq> j \\<longrightarrow> Gauss_Jordan A $ i $ j = (0::'a))\n  a < j\n  mod_type_class.to_nat j = k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ a = (0::'a)", "using i_less_j a_not_i to_nat_mono"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     mod_type_class.to_nat i < k \\<and>\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     (i = j \\<longrightarrow> Gauss_Jordan A $ i $ j = (1::'a)) \\<and>\n     (i \\<noteq> j \\<longrightarrow> Gauss_Jordan A $ i $ j = (0::'a))\n  a < j\n  mod_type_class.to_nat j = k\n  i < j\n  a \\<noteq> i\n  ?a < ?b \\<Longrightarrow>\n  mod_type_class.to_nat ?a < mod_type_class.to_nat ?b\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ a = (0::'a)", "by blast"], ["proof (state)\nthis:\n  Gauss_Jordan A $ i $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> j; x \\<noteq> i; x < j;\n        column x (Gauss_Jordan A) $ i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> column j (Gauss_Jordan A) $ x = (0::'a)", "thus \"column j (Gauss_Jordan A) $ a = 0\""], ["proof (prove)\nusing this:\n  Gauss_Jordan A $ i $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. column j (Gauss_Jordan A) $ a = (0::'a)", "using column_a_not_zero"], ["proof (prove)\nusing this:\n  Gauss_Jordan A $ i $ a = (0::'a)\n  column a (Gauss_Jordan A) $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. column j (Gauss_Jordan A) $ a = (0::'a)", "unfolding column_def"], ["proof (prove)\nusing this:\n  Gauss_Jordan A $ i $ a = (0::'a)\n  (\\<chi>i. Gauss_Jordan A $ i $ a) $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<chi>i. Gauss_Jordan A $ i $ j) $ a = (0::'a)", "by simp \\<comment> \\<open>Contradiction\\<close>"], ["proof (state)\nthis:\n  column j (Gauss_Jordan A) $ a = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>UNIV - {i} - {j}.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i) =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)\n 2. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "have \"sum ?g UNIV = ?g i + sum ?g (UNIV - {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (if i < j then column j (Gauss_Jordan A) $ i\n     else if i = j then - (1::'a) else (0::'a)) *\n    column i (Gauss_Jordan A) $ i +\n    (\\<Sum>x\\<in>UNIV - {i}.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i)", "by (rule sum.remove, simp_all)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>UNIV.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i) =\n  (if i < j then column j (Gauss_Jordan A) $ i\n   else if i = j then - (1::'a) else (0::'a)) *\n  column i (Gauss_Jordan A) $ i +\n  (\\<Sum>x\\<in>UNIV - {i}.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i)\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)\n 2. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>UNIV.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i) =\n  (if i < j then column j (Gauss_Jordan A) $ i\n   else if i = j then - (1::'a) else (0::'a)) *\n  column i (Gauss_Jordan A) $ i +\n  (\\<Sum>x\\<in>UNIV - {i}.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i)\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)\n 2. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "have \"... = ?g i + ?g j + sum ?g (UNIV - {i} - {j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < j then column j (Gauss_Jordan A) $ i\n     else if i = j then - (1::'a) else (0::'a)) *\n    column i (Gauss_Jordan A) $ i +\n    (\\<Sum>x\\<in>UNIV - {i}.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (if i < j then column j (Gauss_Jordan A) $ i\n     else if i = j then - (1::'a) else (0::'a)) *\n    column i (Gauss_Jordan A) $ i +\n    (if j < j then column j (Gauss_Jordan A) $ j\n     else if j = j then - (1::'a) else (0::'a)) *\n    column j (Gauss_Jordan A) $ i +\n    (\\<Sum>x\\<in>UNIV - {i} - {j}.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i)", "unfolding sum_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < j then column j (Gauss_Jordan A) $ i\n     else if i = j then - (1::'a) else (0::'a)) *\n    column i (Gauss_Jordan A) $ i +\n    ((if j < j then column j (Gauss_Jordan A) $ j\n      else if j = j then - (1::'a) else (0::'a)) *\n     column j (Gauss_Jordan A) $ i +\n     (\\<Sum>x\\<in>UNIV - {i} - {j}.\n        (if x < j then column j (Gauss_Jordan A) $ x\n         else if x = j then - (1::'a) else (0::'a)) *\n        column x (Gauss_Jordan A) $ i)) =\n    (if i < j then column j (Gauss_Jordan A) $ i\n     else if i = j then - (1::'a) else (0::'a)) *\n    column i (Gauss_Jordan A) $ i +\n    (if j < j then column j (Gauss_Jordan A) $ j\n     else if j = j then - (1::'a) else (0::'a)) *\n    column j (Gauss_Jordan A) $ i +\n    (\\<Sum>x\\<in>UNIV - {i} - {j}.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i)", "by auto"], ["proof (state)\nthis:\n  (if i < j then column j (Gauss_Jordan A) $ i\n   else if i = j then - (1::'a) else (0::'a)) *\n  column i (Gauss_Jordan A) $ i +\n  (\\<Sum>x\\<in>UNIV - {i}.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i) =\n  (if i < j then column j (Gauss_Jordan A) $ i\n   else if i = j then - (1::'a) else (0::'a)) *\n  column i (Gauss_Jordan A) $ i +\n  (if j < j then column j (Gauss_Jordan A) $ j\n   else if j = j then - (1::'a) else (0::'a)) *\n  column j (Gauss_Jordan A) $ i +\n  (\\<Sum>x\\<in>UNIV - {i} - {j}.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i)\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)\n 2. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (if i < j then column j (Gauss_Jordan A) $ i\n   else if i = j then - (1::'a) else (0::'a)) *\n  column i (Gauss_Jordan A) $ i +\n  (\\<Sum>x\\<in>UNIV - {i}.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i) =\n  (if i < j then column j (Gauss_Jordan A) $ i\n   else if i = j then - (1::'a) else (0::'a)) *\n  column i (Gauss_Jordan A) $ i +\n  (if j < j then column j (Gauss_Jordan A) $ j\n   else if j = j then - (1::'a) else (0::'a)) *\n  column j (Gauss_Jordan A) $ i +\n  (\\<Sum>x\\<in>UNIV - {i} - {j}.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i)\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)\n 2. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "have \"... = ?g i + ?g j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < j then column j (Gauss_Jordan A) $ i\n     else if i = j then - (1::'a) else (0::'a)) *\n    column i (Gauss_Jordan A) $ i +\n    (if j < j then column j (Gauss_Jordan A) $ j\n     else if j = j then - (1::'a) else (0::'a)) *\n    column j (Gauss_Jordan A) $ i +\n    (\\<Sum>x\\<in>UNIV - {i} - {j}.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (if i < j then column j (Gauss_Jordan A) $ i\n     else if i = j then - (1::'a) else (0::'a)) *\n    column i (Gauss_Jordan A) $ i +\n    (if j < j then column j (Gauss_Jordan A) $ j\n     else if j = j then - (1::'a) else (0::'a)) *\n    column j (Gauss_Jordan A) $ i", "unfolding sum_g0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < j then column j (Gauss_Jordan A) $ i\n     else if i = j then - (1::'a) else (0::'a)) *\n    column i (Gauss_Jordan A) $ i +\n    (if j < j then column j (Gauss_Jordan A) $ j\n     else if j = j then - (1::'a) else (0::'a)) *\n    column j (Gauss_Jordan A) $ i +\n    (0::'a) =\n    (if i < j then column j (Gauss_Jordan A) $ i\n     else if i = j then - (1::'a) else (0::'a)) *\n    column i (Gauss_Jordan A) $ i +\n    (if j < j then column j (Gauss_Jordan A) $ j\n     else if j = j then - (1::'a) else (0::'a)) *\n    column j (Gauss_Jordan A) $ i", "by simp"], ["proof (state)\nthis:\n  (if i < j then column j (Gauss_Jordan A) $ i\n   else if i = j then - (1::'a) else (0::'a)) *\n  column i (Gauss_Jordan A) $ i +\n  (if j < j then column j (Gauss_Jordan A) $ j\n   else if j = j then - (1::'a) else (0::'a)) *\n  column j (Gauss_Jordan A) $ i +\n  (\\<Sum>x\\<in>UNIV - {i} - {j}.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i) =\n  (if i < j then column j (Gauss_Jordan A) $ i\n   else if i = j then - (1::'a) else (0::'a)) *\n  column i (Gauss_Jordan A) $ i +\n  (if j < j then column j (Gauss_Jordan A) $ j\n   else if j = j then - (1::'a) else (0::'a)) *\n  column j (Gauss_Jordan A) $ i\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)\n 2. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (if i < j then column j (Gauss_Jordan A) $ i\n   else if i = j then - (1::'a) else (0::'a)) *\n  column i (Gauss_Jordan A) $ i +\n  (if j < j then column j (Gauss_Jordan A) $ j\n   else if j = j then - (1::'a) else (0::'a)) *\n  column j (Gauss_Jordan A) $ i +\n  (\\<Sum>x\\<in>UNIV - {i} - {j}.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i) =\n  (if i < j then column j (Gauss_Jordan A) $ i\n   else if i = j then - (1::'a) else (0::'a)) *\n  column i (Gauss_Jordan A) $ i +\n  (if j < j then column j (Gauss_Jordan A) $ j\n   else if j = j then - (1::'a) else (0::'a)) *\n  column j (Gauss_Jordan A) $ i\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)\n 2. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < j then column j (Gauss_Jordan A) $ i\n     else if i = j then - (1::'a) else (0::'a)) *\n    column i (Gauss_Jordan A) $ i +\n    (if j < j then column j (Gauss_Jordan A) $ j\n     else if j = j then - (1::'a) else (0::'a)) *\n    column j (Gauss_Jordan A) $ i =\n    (0::'a)", "using True"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. (if i < j then column j (Gauss_Jordan A) $ i\n     else if i = j then - (1::'a) else (0::'a)) *\n    column i (Gauss_Jordan A) $ i +\n    (if j < j then column j (Gauss_Jordan A) $ j\n     else if j = j then - (1::'a) else (0::'a)) *\n    column j (Gauss_Jordan A) $ i =\n    (0::'a)", "unfolding column_def"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. (if i < j then (\\<chi>i. Gauss_Jordan A $ i $ j) $ i\n     else if i = j then - (1::'a) else (0::'a)) *\n    (\\<chi>ia. Gauss_Jordan A $ ia $ i) $ i +\n    (if j < j then (\\<chi>i. Gauss_Jordan A $ i $ j) $ j\n     else if j = j then - (1::'a) else (0::'a)) *\n    (\\<chi>i. Gauss_Jordan A $ i $ j) $ i =\n    (0::'a)", "by (simp, metis id_k id_upt_k_def j_eq_k to_nat_mono)"], ["proof (state)\nthis:\n  (if i < j then column j (Gauss_Jordan A) $ i\n   else if i = j then - (1::'a) else (0::'a)) *\n  column i (Gauss_Jordan A) $ i +\n  (if j < j then column j (Gauss_Jordan A) $ j\n   else if j = j then - (1::'a) else (0::'a)) *\n  column j (Gauss_Jordan A) $ i =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)\n 2. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>UNIV.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i) =\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>UNIV.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>UNIV.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "have zero_i_suc_k: \"is_zero_row_upt_k i (Suc k) (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i (Suc k) (Gauss_Jordan A)", "by (metis False zero_j_suc_k linorder_cases rref_suc_k rref_upt_condition1)"], ["proof (state)\nthis:\n  is_zero_row_upt_k i (Suc k) (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>UNIV.\n       (if x < j then column j (Gauss_Jordan A) $ x\n        else if x = j then - (1::'a) else (0::'a)) *\n       column x (Gauss_Jordan A) $ i) =\n    (0::'a)", "proof (rule sum.neutral, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. column j (Gauss_Jordan A) $ i = (0::'a)\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> j; x < j;\n        column x (Gauss_Jordan A) $ i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> column j (Gauss_Jordan A) $ x = (0::'a)", "show \"column j (Gauss_Jordan A) $ i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column j (Gauss_Jordan A) $ i = (0::'a)", "using zero_i_suc_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. column j (Gauss_Jordan A) $ i = (0::'a)", "unfolding column_def is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < Suc k \\<longrightarrow>\n     Gauss_Jordan A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<chi>i. Gauss_Jordan A $ i $ j) $ i = (0::'a)", "by (metis j_eq_k lessI vec_lambda_beta)"], ["proof (state)\nthis:\n  column j (Gauss_Jordan A) $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> j; x < j;\n        column x (Gauss_Jordan A) $ i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> column j (Gauss_Jordan A) $ x = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> j; x < j;\n        column x (Gauss_Jordan A) $ i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> column j (Gauss_Jordan A) $ x = (0::'a)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> j; x < j;\n        column x (Gauss_Jordan A) $ i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> column j (Gauss_Jordan A) $ x = (0::'a)", "assume a_not_j: \"a \\<noteq> j\" and a_less_j: \"a < j\" and column_a_i: \"column a (Gauss_Jordan A) $ i \\<noteq> 0\""], ["proof (state)\nthis:\n  a \\<noteq> j\n  a < j\n  column a (Gauss_Jordan A) $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> j; x < j;\n        column x (Gauss_Jordan A) $ i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> column j (Gauss_Jordan A) $ x = (0::'a)", "have \"Gauss_Jordan A $ i $ a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ a = (0::'a)", "using zero_i_suc_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ a = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < Suc k \\<longrightarrow>\n     Gauss_Jordan A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ a = (0::'a)", "by (metis (full_types) a_less_j j_eq_k less_SucI to_nat_mono)"], ["proof (state)\nthis:\n  Gauss_Jordan A $ i $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> j; x < j;\n        column x (Gauss_Jordan A) $ i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> column j (Gauss_Jordan A) $ x = (0::'a)", "thus \"column j (Gauss_Jordan A) $ a = 0\""], ["proof (prove)\nusing this:\n  Gauss_Jordan A $ i $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. column j (Gauss_Jordan A) $ a = (0::'a)", "using column_a_i"], ["proof (prove)\nusing this:\n  Gauss_Jordan A $ i $ a = (0::'a)\n  column a (Gauss_Jordan A) $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. column j (Gauss_Jordan A) $ a = (0::'a)", "unfolding column_def"], ["proof (prove)\nusing this:\n  Gauss_Jordan A $ i $ a = (0::'a)\n  (\\<chi>i. Gauss_Jordan A $ i $ a) $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<chi>i. Gauss_Jordan A $ i $ j) $ a = (0::'a)", "by simp"], ["proof (state)\nthis:\n  column j (Gauss_Jordan A) $ a = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>UNIV.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>UNIV.\n     (if x < j then column j (Gauss_Jordan A) $ x\n      else if x = j then - (1::'a) else (0::'a)) *\n     column x (Gauss_Jordan A) $ i) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV.\n     (if i < j then column j (Gauss_Jordan A) $ i\n      else if i = j then - (1::'a) else (0::'a)) *s\n     column i (Gauss_Jordan A)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       (if i < j then column j (Gauss_Jordan A) $ i\n        else if i = j then - (1::'a) else (0::'a)) \\<noteq>\n       (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       (if i < j then column j (Gauss_Jordan A) $ i\n        else if i = j then - (1::'a) else (0::'a)) \\<noteq>\n       (0::'a)", "show \"\\<exists>i. (if i < j then column j (Gauss_Jordan A) $ i else if i = j then -1 else 0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       (if i < j then column j (Gauss_Jordan A) $ i\n        else if i = j then - (1::'a) else (0::'a)) \\<noteq>\n       (0::'a)", "by (metis False j_eq_k neg_equal_0_iff_equal to_nat_mono zero_neq_one)"], ["proof (state)\nthis:\n  \\<exists>i.\n     (if i < j then column j (Gauss_Jordan A) $ i\n      else if i = j then - (1::'a) else (0::'a)) \\<noteq>\n     (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>B. B ** Gauss_Jordan A = mat (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Gauss_Jordan A $ j $ j \\<noteq> (1::'a);\n     Gauss_Jordan A $ j $ j = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<nexists>B. B ** Gauss_Jordan A = mat (1::'a)\n\ngoal (1 subgoal):\n 1. False", "using inv_gj"], ["proof (prove)\nusing this:\n  \\<nexists>B. B ** Gauss_Jordan A = mat (1::'a)\n  invertible (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. False", "unfolding invertible_def"], ["proof (prove)\nusing this:\n  \\<nexists>B. B ** Gauss_Jordan A = mat (1::'a)\n  \\<exists>A'.\n     Gauss_Jordan A ** A' = mat (1::'a) \\<and>\n     A' ** Gauss_Jordan A = mat (1::'a)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ j = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ j = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ j = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>mod_type_class.to_nat i < Suc k;\n        mod_type_class.to_nat j < Suc k; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan A $ i $ j = (0::'a)", "fix i::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>mod_type_class.to_nat i < Suc k;\n        mod_type_class.to_nat j < Suc k; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan A $ i $ j = (0::'a)", "assume i_less_suc: \"to_nat i < Suc k\" and i_not_j: \"i \\<noteq> j\""], ["proof (state)\nthis:\n  mod_type_class.to_nat i < Suc k\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>mod_type_class.to_nat i < Suc k;\n        mod_type_class.to_nat j < Suc k; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan A $ i $ j = (0::'a)", "show \"Gauss_Jordan A $ i $ j = 0\" \\<comment> \\<open>This result is proved making use of the 4th condition of rref\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ j = (0::'a)", "proof (cases \"to_nat i < k \\<and> to_nat j < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < k \\<and>\n    mod_type_class.to_nat j < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)\n 2. \\<not> (mod_type_class.to_nat i < k \\<and>\n            mod_type_class.to_nat j < k) \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < k \\<and> mod_type_class.to_nat j < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < k \\<and>\n    mod_type_class.to_nat j < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)\n 2. \\<not> (mod_type_class.to_nat i < k \\<and>\n            mod_type_class.to_nat j < k) \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k \\<and> mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ j = (0::'a)", "using id_k i_not_j"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k \\<and> mod_type_class.to_nat j < k\n  id_upt_k (Gauss_Jordan A) k\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ j = (0::'a)", "unfolding id_upt_k_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k \\<and> mod_type_class.to_nat j < k\n  \\<forall>i j.\n     mod_type_class.to_nat i < k \\<and>\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     (i = j \\<longrightarrow> Gauss_Jordan A $ i $ j = (1::'a)) \\<and>\n     (i \\<noteq> j \\<longrightarrow> Gauss_Jordan A $ i $ j = (0::'a))\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ j = (0::'a)", "by blast \\<comment> \\<open>Easy due to the inductive hypothesis\\<close>"], ["proof (state)\nthis:\n  Gauss_Jordan A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (mod_type_class.to_nat i < k \\<and>\n            mod_type_class.to_nat j < k) \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (mod_type_class.to_nat i < k \\<and>\n            mod_type_class.to_nat j < k) \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> (mod_type_class.to_nat i < k \\<and> mod_type_class.to_nat j < k)\n\ngoal (1 subgoal):\n 1. \\<not> (mod_type_class.to_nat i < k \\<and>\n            mod_type_class.to_nat j < k) \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "note i_or_j_ge_k = False"], ["proof (state)\nthis:\n  \\<not> (mod_type_class.to_nat i < k \\<and> mod_type_class.to_nat j < k)\n\ngoal (1 subgoal):\n 1. \\<not> (mod_type_class.to_nat i < k \\<and>\n            mod_type_class.to_nat j < k) \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ j = (0::'a)", "proof (cases \"to_nat i < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "hence j_eq_k: \"to_nat j = k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j = k", "using i_or_j_ge_k j_less_suc"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < k\n  \\<not> (mod_type_class.to_nat i < k \\<and> mod_type_class.to_nat j < k)\n  mod_type_class.to_nat j < Suc k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j = k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat j = k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "have j_noteq_0: \"j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<noteq> (0::'n)", "by (metis True j_eq_k less_nat_zero_code to_nat_0)"], ["proof (state)\nthis:\n  j \\<noteq> (0::'n)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "have j_minus_1: \"to_nat (j - 1) < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (j - (1::'n)) < k", "by (metis (full_types) Suc_le' diff_add_cancel j_eq_k j_noteq_0 to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (j - (1::'n)) < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "have \"(GREATEST m. \\<not> is_zero_row_upt_k m k (Gauss_Jordan A)) = j - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k (Gauss_Jordan A)) =\n    j - (1::'n)", "by (rule greatest_prop[OF j_noteq_0 j_eq_k])"], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k (Gauss_Jordan A)) = j - (1::'n)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "hence zero_j_k: \"is_zero_row_upt_k j k (Gauss_Jordan A)\""], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k (Gauss_Jordan A)) = j - (1::'n)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j k (Gauss_Jordan A)", "by (metis (lifting, mono_tags) less_linear less_asym j_eq_k j_minus_1 not_greater_Greatest to_nat_mono)"], ["proof (state)\nthis:\n  is_zero_row_upt_k j k (Gauss_Jordan A)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "have Least_eq_j: \"(LEAST n. Gauss_Jordan A $ j $ n \\<noteq> 0) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow> j \\<le> y", "show \"Gauss_Jordan A $ j $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $ j \\<noteq> (0::'a)", "using Gauss_jj_1"], ["proof (prove)\nusing this:\n  Gauss_Jordan A $ j $ j = (1::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $ j \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow> j \\<le> y", "show \"\\<And>y. Gauss_Jordan A $ j $ y \\<noteq> 0 \\<Longrightarrow> j \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow> j \\<le> y", "by (metis True le_cases from_nat_to_nat_id i_or_j_ge_k is_zero_row_upt_k_def j_less_suc less_Suc_eq_le less_le to_nat_le zero_j_k)"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ ?y \\<noteq> (0::'a) \\<Longrightarrow> j \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "moreover"], ["proof (state)\nthis:\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "have \"\\<not> is_zero_row_upt_k j (Suc k) (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k j (Suc k) (Gauss_Jordan A)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ja.\n               mod_type_class.to_nat ja < Suc k \\<longrightarrow>\n               Gauss_Jordan A $ j $ ja = (0::'a))", "by (metis Gauss_jj_1 j_less_suc zero_neq_one)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k j (Suc k) (Gauss_Jordan A)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j\n  \\<not> is_zero_row_upt_k j (Suc k) (Gauss_Jordan A)", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j\n  \\<not> is_zero_row_upt_k j (Suc k) (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ j = (0::'a)", "using rref_upt_condition4[OF rref_suc_k] i_not_j"], ["proof (prove)\nusing this:\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j\n  \\<not> is_zero_row_upt_k j (Suc k) (Gauss_Jordan A)\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i (Suc k) (Gauss_Jordan A) \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         Gauss_Jordan A $ j $\n         (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) =\n         (0::'a))\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ j = (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  Gauss_Jordan A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "hence i_eq_k: \"to_nat i = k\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat i < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i = k", "by (metis \\<open>to_nat i < Suc k\\<close> less_SucE)"], ["proof (state)\nthis:\n  mod_type_class.to_nat i = k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "hence j_less_k: \"to_nat j < k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i = k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j < k", "by (metis i_not_j j_less_suc less_SucE to_nat_from_nat)"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "have \"(LEAST n. Gauss_Jordan A $ j $ n \\<noteq> 0) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow> j \\<le> y", "show \"Gauss_Jordan A $ j $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ j $ j \\<noteq> (0::'a)", "by (metis Gauss_jj_1 zero_neq_one)"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow> j \\<le> y", "show \"\\<And>y. Gauss_Jordan A $ j $ y \\<noteq> 0 \\<Longrightarrow> j \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan A $ j $ y \\<noteq> (0::'a) \\<Longrightarrow> j \\<le> y", "by (metis le_cases id_k id_upt_k_def j_less_k less_trans not_less to_nat_mono)"], ["proof (state)\nthis:\n  Gauss_Jordan A $ j $ ?y \\<noteq> (0::'a) \\<Longrightarrow> j \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "moreover"], ["proof (state)\nthis:\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "have \"\\<not> is_zero_row_upt_k j k (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k j k (Gauss_Jordan A)", "by (metis (full_types) Gauss_jj_1 is_zero_row_upt_k_def j_less_k zero_neq_one)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k j k (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat i < k \\<Longrightarrow>\n    Gauss_Jordan A $ i $ j = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j\n  \\<not> is_zero_row_upt_k j k (Gauss_Jordan A)", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j\n  \\<not> is_zero_row_upt_k j k (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ j = (0::'a)", "using rref_upt_condition4[OF rref_k] i_not_j"], ["proof (prove)\nusing this:\n  (LEAST n. Gauss_Jordan A $ j $ n \\<noteq> (0::'a)) = j\n  \\<not> is_zero_row_upt_k j k (Gauss_Jordan A)\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k (Gauss_Jordan A) \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         Gauss_Jordan A $ j $\n         (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) =\n         (0::'a))\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ j = (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  Gauss_Jordan A $ i $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan A $ i $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan A $ i $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  id_upt_k (Gauss_Jordan A) (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invertible_implies_rref_id:\n  fixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\n  assumes inv_A: \"invertible A\"\n  shows \"Gauss_Jordan A = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A = mat (1::'a)", "using id_upt_k_Gauss_Jordan[OF inv_A, of \"nrows (Gauss_Jordan A)\"]"], ["proof (prove)\nusing this:\n  id_upt_k (Gauss_Jordan A) (nrows (Gauss_Jordan A))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A = mat (1::'a)", "using id_upt_nrows_mat_1"], ["proof (prove)\nusing this:\n  id_upt_k (Gauss_Jordan A) (nrows (Gauss_Jordan A))\n  id_upt_k ?A (nrows ?A) \\<Longrightarrow> ?A = mat (1::?'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A = mat (1::'a)", "by fast"], ["", "lemma matrix_inv_Gauss:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes inv_A: \"invertible A\" and Gauss_eq: \"Gauss_Jordan A = P ** A\"\nshows \"matrix_inv A = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_inv A = P", "proof (unfold matrix_inv_def, rule some1_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>!A'. A ** A' = mat (1::'a) \\<and> A' ** A = mat (1::'a)\n 2. A ** P = mat (1::'a) \\<and> P ** A = mat (1::'a)", "show \"\\<exists>!A'. A ** A' = mat 1 \\<and> A' ** A = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!A'. A ** A' = mat (1::'a) \\<and> A' ** A = mat (1::'a)", "by (metis inv_A invertible_def matrix_inv_unique matrix_left_right_inverse)"], ["proof (state)\nthis:\n  \\<exists>!A'. A ** A' = mat (1::'a) \\<and> A' ** A = mat (1::'a)\n\ngoal (1 subgoal):\n 1. A ** P = mat (1::'a) \\<and> P ** A = mat (1::'a)", "show \"A ** P = mat 1 \\<and> P ** A = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ** P = mat (1::'a) \\<and> P ** A = mat (1::'a)", "by (metis Gauss_eq inv_A invertible_implies_rref_id matrix_left_right_inverse)"], ["proof (state)\nthis:\n  A ** P = mat (1::'a) \\<and> P ** A = mat (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_inv_Gauss_Jordan_PA:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes inv_A: \"invertible A\"\nshows \"matrix_inv A = fst (Gauss_Jordan_PA A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_inv A = fst (Gauss_Jordan_PA A)", "by (metis Gauss_Jordan_PA_eq fst_Gauss_Jordan_PA inv_A matrix_inv_Gauss)"], ["", "lemma invertible_eq_full_rank[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"invertible A = (rank A = nrows A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible A = (rank A = nrows A)", "by (metis full_rank_implies_invertible invertible_implies_full_rank)"], ["", "definition \"inverse_matrix A = (if invertible A then Some (matrix_inv A) else None)\""], ["", "lemma the_inverse_matrix:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes \"invertible A\"\nshows \"the (inverse_matrix A) = P_Gauss_Jordan A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (inverse_matrix A) = P_Gauss_Jordan A", "by (metis P_Gauss_Jordan_def assms inverse_matrix_def matrix_inv_Gauss_Jordan_PA option.sel)"], ["", "lemma inverse_matrix:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"inverse_matrix A = (if invertible A then Some (P_Gauss_Jordan A) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_matrix A =\n    (if invertible A then Some (P_Gauss_Jordan A) else None)", "by (metis inverse_matrix_def option.sel the_inverse_matrix)"], ["", "lemma inverse_matrix_code[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"inverse_matrix A = (let GJ = Gauss_Jordan_PA A;\n                                rank_A = (if A = 0 then 0 else to_nat (GREATEST a. row a (snd GJ) \\<noteq> 0) + 1) in \n                                if nrows A = rank_A then Some (fst(GJ)) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_matrix A =\n    (let GJ = Gauss_Jordan_PA A;\n         rank_A =\n           if A = 0 then 0\n           else mod_type_class.to_nat\n                 (GREATEST a. row a (snd GJ) \\<noteq> 0) +\n                1\n     in if nrows A = rank_A then Some (fst GJ) else None)", "unfolding inverse_matrix"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if invertible A then Some (P_Gauss_Jordan A) else None) =\n    (let GJ = Gauss_Jordan_PA A;\n         rank_A =\n           if A = 0 then 0\n           else mod_type_class.to_nat\n                 (GREATEST a. row a (snd GJ) \\<noteq> 0) +\n                1\n     in if nrows A = rank_A then Some (fst GJ) else None)", "unfolding invertible_eq_full_rank"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if rank A = nrows A then Some (P_Gauss_Jordan A) else None) =\n    (let GJ = Gauss_Jordan_PA A;\n         rank_A =\n           if A = 0 then 0\n           else mod_type_class.to_nat\n                 (GREATEST a. row a (snd GJ) \\<noteq> 0) +\n                1\n     in if nrows A = rank_A then Some (fst GJ) else None)", "unfolding rank_Gauss_Jordan_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (if A = 0 then 0\n         else let A' = Gauss_Jordan A\n              in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) +\n                 1) =\n        nrows A\n     then Some (P_Gauss_Jordan A) else None) =\n    (let GJ = Gauss_Jordan_PA A;\n         rank_A =\n           if A = 0 then 0\n           else mod_type_class.to_nat\n                 (GREATEST a. row a (snd GJ) \\<noteq> 0) +\n                1\n     in if nrows A = rank_A then Some (fst GJ) else None)", "unfolding P_Gauss_Jordan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (if A = 0 then 0\n         else let A' = Gauss_Jordan A\n              in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) +\n                 1) =\n        nrows A\n     then Some (fst (Gauss_Jordan_PA A)) else None) =\n    (let GJ = Gauss_Jordan_PA A;\n         rank_A =\n           if A = 0 then 0\n           else mod_type_class.to_nat\n                 (GREATEST a. row a (snd GJ) \\<noteq> 0) +\n                1\n     in if nrows A = rank_A then Some (fst GJ) else None)", "unfolding Let_def Gauss_Jordan_PA_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (if A = 0 then 0\n         else mod_type_class.to_nat\n               (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n              1) =\n        nrows A\n     then Some (fst (Gauss_Jordan_PA A)) else None) =\n    (if nrows A =\n        (if A = 0 then 0\n         else mod_type_class.to_nat\n               (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n              1)\n     then Some (fst (Gauss_Jordan_PA A)) else None)", "by presburger"], ["", "end"]]}