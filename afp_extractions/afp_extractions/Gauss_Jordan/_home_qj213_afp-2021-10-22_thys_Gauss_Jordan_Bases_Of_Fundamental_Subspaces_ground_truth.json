{"file_name": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan/Bases_Of_Fundamental_Subspaces.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan", "problem_names": ["lemma basis_null_space_eq_basis_left_null_space_transpose: \n  \"basis_null_space A = basis_left_null_space (transpose A)\"", "lemma basis_null_space_transpose_eq_basis_left_null_space:\nshows \"basis_null_space (transpose A) = basis_left_null_space A\"", "lemma basis_col_space_eq_basis_row_space_transpose:\n  \"basis_col_space A = basis_row_space (transpose A)\"", "lemma basis_null_space_code[code]: \"basis_null_space A = (let GJ = Gauss_Jordan_PA (transpose A); \n                                                               rank_A = (if A = 0 then 0 else to_nat (GREATEST a. row a (snd GJ) \\<noteq> 0) + 1) \n                                                               in {row i (fst GJ) | i. to_nat i \\<ge> rank_A})\"", "lemma basis_row_space_code[code]: \"basis_row_space A = (let A' = Gauss_Jordan A in {row i A' |i. row i A' \\<noteq> 0})\"", "lemma basis_col_space_code[code]: \"basis_col_space A = (let A' = Gauss_Jordan (transpose A) in {row i A' |i. row i A' \\<noteq> 0})\"", "lemma basis_left_null_space_code[code]: \"basis_left_null_space A = (let GJ = Gauss_Jordan_PA A; \n                                                               rank_A = (if A = 0 then 0 else to_nat (GREATEST a. row a (snd GJ) \\<noteq> 0) + 1)\n                                                               in {row i (fst GJ) | i. to_nat i \\<ge> rank_A})\"", "lemma independent_basis_left_null_space:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"vec.independent (basis_left_null_space A)\"", "lemma card_basis_left_null_space_eq_dim:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"card (basis_left_null_space A) = vec.dim (left_null_space A)\"", "lemma basis_left_null_space_in_left_null_space:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"basis_left_null_space A \\<subseteq> left_null_space A\"", "lemma left_null_space_subset_span_basis:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows  \"left_null_space A \\<subseteq> vec.span (basis_left_null_space A)\"", "lemma basis_row_space_subset_row_space:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"basis_row_space A \\<subseteq> row_space A\"", "lemma row_space_subset_span_basis_row_space:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"row_space A \\<subseteq> vec.span (basis_row_space A)\"", "lemma basis_row_space:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"vec.independent (basis_row_space A)\n  \\<and> vec.span (basis_row_space A) = row_space A\""], "translations": [["", "lemma basis_null_space_eq_basis_left_null_space_transpose: \n  \"basis_null_space A = basis_left_null_space (transpose A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_null_space A =\n    basis_left_null_space (Finite_Cartesian_Product.transpose A)", "unfolding basis_null_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (P_Gauss_Jordan (Finite_Cartesian_Product.transpose A)) |i.\n     rank A \\<le> mod_type_class.to_nat i} =\n    basis_left_null_space (Finite_Cartesian_Product.transpose A)", "unfolding basis_left_null_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (P_Gauss_Jordan (Finite_Cartesian_Product.transpose A)) |i.\n     rank A \\<le> mod_type_class.to_nat i} =\n    {row i (P_Gauss_Jordan (Finite_Cartesian_Product.transpose A)) |i.\n     rank (Finite_Cartesian_Product.transpose A)\n     \\<le> mod_type_class.to_nat i}", "unfolding rank_transpose[of A, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (P_Gauss_Jordan (Finite_Cartesian_Product.transpose A)) |i.\n     rank (Finite_Cartesian_Product.transpose A)\n     \\<le> mod_type_class.to_nat i} =\n    {row i (P_Gauss_Jordan (Finite_Cartesian_Product.transpose A)) |i.\n     rank (Finite_Cartesian_Product.transpose A)\n     \\<le> mod_type_class.to_nat i}", ".."], ["", "lemma basis_null_space_transpose_eq_basis_left_null_space:\nshows \"basis_null_space (transpose A) = basis_left_null_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_null_space (Finite_Cartesian_Product.transpose A) =\n    basis_left_null_space A", "by (metis transpose_transpose basis_null_space_eq_basis_left_null_space_transpose)"], ["", "lemma basis_col_space_eq_basis_row_space_transpose:\n  \"basis_col_space A = basis_row_space (transpose A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_col_space A =\n    basis_row_space (Finite_Cartesian_Product.transpose A)", "unfolding basis_col_space_def basis_row_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (Gauss_Jordan (Finite_Cartesian_Product.transpose A)) |i.\n     row i (Gauss_Jordan (Finite_Cartesian_Product.transpose A)) \\<noteq>\n     0} =\n    {row i (Gauss_Jordan (Finite_Cartesian_Product.transpose A)) |i.\n     row i (Gauss_Jordan (Finite_Cartesian_Product.transpose A)) \\<noteq> 0}", ".."], ["", "subsection\\<open>Code equations\\<close>"], ["", "text\\<open>Code equations to make more efficient the computations.\\<close>"], ["", "lemma basis_null_space_code[code]: \"basis_null_space A = (let GJ = Gauss_Jordan_PA (transpose A); \n                                                               rank_A = (if A = 0 then 0 else to_nat (GREATEST a. row a (snd GJ) \\<noteq> 0) + 1) \n                                                               in {row i (fst GJ) | i. to_nat i \\<ge> rank_A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_null_space A =\n    (let GJ = Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A);\n         rank_A =\n           if A = 0 then 0\n           else mod_type_class.to_nat\n                 (GREATEST a. row a (snd GJ) \\<noteq> 0) +\n                1\n     in {row i (fst GJ) |i. rank_A \\<le> mod_type_class.to_nat i})", "unfolding basis_null_space_def Let_def P_Gauss_Jordan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (fst (Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A))) |\n     i. rank A \\<le> mod_type_class.to_nat i} =\n    {row i (fst (Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A))) |\n     i. (if A = 0 then 0\n         else mod_type_class.to_nat\n               (GREATEST a.\n                   row a\n                    (snd (Gauss_Jordan_PA\n                           (Finite_Cartesian_Product.transpose A))) \\<noteq>\n                   0) +\n              1)\n        \\<le> mod_type_class.to_nat i}", "unfolding Gauss_Jordan_PA_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (fst (Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A))) |\n     i. rank A \\<le> mod_type_class.to_nat i} =\n    {row i (fst (Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A))) |\n     i. (if A = 0 then 0\n         else mod_type_class.to_nat\n               (GREATEST a.\n                   row a\n                    (Gauss_Jordan\n                      (Finite_Cartesian_Product.transpose A)) \\<noteq>\n                   0) +\n              1)\n        \\<le> mod_type_class.to_nat i}", "unfolding rank_transpose[symmetric, of A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (fst (Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A))) |\n     i. rank (Finite_Cartesian_Product.transpose A)\n        \\<le> mod_type_class.to_nat i} =\n    {row i (fst (Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A))) |\n     i. (if A = 0 then 0\n         else mod_type_class.to_nat\n               (GREATEST a.\n                   row a\n                    (Gauss_Jordan\n                      (Finite_Cartesian_Product.transpose A)) \\<noteq>\n                   0) +\n              1)\n        \\<le> mod_type_class.to_nat i}", "unfolding rank_Gauss_Jordan_code[of \"transpose A\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (fst (Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A))) |\n     i. (if Finite_Cartesian_Product.transpose A = 0 then 0\n         else let A' = Gauss_Jordan (Finite_Cartesian_Product.transpose A)\n              in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) +\n                 1)\n        \\<le> mod_type_class.to_nat i} =\n    {row i (fst (Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A))) |\n     i. (if A = 0 then 0\n         else mod_type_class.to_nat\n               (GREATEST a.\n                   row a\n                    (Gauss_Jordan\n                      (Finite_Cartesian_Product.transpose A)) \\<noteq>\n                   0) +\n              1)\n        \\<le> mod_type_class.to_nat i}", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (fst (Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A))) |\n     i. (if Finite_Cartesian_Product.transpose A = 0 then 0\n         else mod_type_class.to_nat\n               (GREATEST a.\n                   row a\n                    (Gauss_Jordan\n                      (Finite_Cartesian_Product.transpose A)) \\<noteq>\n                   0) +\n              1)\n        \\<le> mod_type_class.to_nat i} =\n    {row i (fst (Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A))) |\n     i. (if A = 0 then 0\n         else mod_type_class.to_nat\n               (GREATEST a.\n                   row a\n                    (Gauss_Jordan\n                      (Finite_Cartesian_Product.transpose A)) \\<noteq>\n                   0) +\n              1)\n        \\<le> mod_type_class.to_nat i}", "unfolding transpose_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (fst (Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A))) |\n     i. (if A = 0 then 0\n         else mod_type_class.to_nat\n               (GREATEST a.\n                   row a\n                    (Gauss_Jordan\n                      (Finite_Cartesian_Product.transpose A)) \\<noteq>\n                   0) +\n              1)\n        \\<le> mod_type_class.to_nat i} =\n    {row i (fst (Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A))) |\n     i. (if A = 0 then 0\n         else mod_type_class.to_nat\n               (GREATEST a.\n                   row a\n                    (Gauss_Jordan\n                      (Finite_Cartesian_Product.transpose A)) \\<noteq>\n                   0) +\n              1)\n        \\<le> mod_type_class.to_nat i}", ".."], ["", "lemma basis_row_space_code[code]: \"basis_row_space A = (let A' = Gauss_Jordan A in {row i A' |i. row i A' \\<noteq> 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_row_space A =\n    (let A' = Gauss_Jordan A in {row i A' |i. row i A' \\<noteq> 0})", "unfolding basis_row_space_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0} =\n    {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", ".."], ["", "lemma basis_col_space_code[code]: \"basis_col_space A = (let A' = Gauss_Jordan (transpose A) in {row i A' |i. row i A' \\<noteq> 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_col_space A =\n    (let A' = Gauss_Jordan (Finite_Cartesian_Product.transpose A)\n     in {row i A' |i. row i A' \\<noteq> 0})", "unfolding basis_col_space_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (Gauss_Jordan (Finite_Cartesian_Product.transpose A)) |i.\n     row i (Gauss_Jordan (Finite_Cartesian_Product.transpose A)) \\<noteq>\n     0} =\n    {row i (Gauss_Jordan (Finite_Cartesian_Product.transpose A)) |i.\n     row i (Gauss_Jordan (Finite_Cartesian_Product.transpose A)) \\<noteq> 0}", ".."], ["", "lemma basis_left_null_space_code[code]: \"basis_left_null_space A = (let GJ = Gauss_Jordan_PA A; \n                                                               rank_A = (if A = 0 then 0 else to_nat (GREATEST a. row a (snd GJ) \\<noteq> 0) + 1)\n                                                               in {row i (fst GJ) | i. to_nat i \\<ge> rank_A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_left_null_space A =\n    (let GJ = Gauss_Jordan_PA A;\n         rank_A =\n           if A = 0 then 0\n           else mod_type_class.to_nat\n                 (GREATEST a. row a (snd GJ) \\<noteq> 0) +\n                1\n     in {row i (fst GJ) |i. rank_A \\<le> mod_type_class.to_nat i})", "unfolding basis_left_null_space_def Let_def P_Gauss_Jordan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (fst (Gauss_Jordan_PA A)) |i.\n     rank A \\<le> mod_type_class.to_nat i} =\n    {row i (fst (Gauss_Jordan_PA A)) |i.\n     (if A = 0 then 0\n      else mod_type_class.to_nat\n            (GREATEST a. row a (snd (Gauss_Jordan_PA A)) \\<noteq> 0) +\n           1)\n     \\<le> mod_type_class.to_nat i}", "unfolding Gauss_Jordan_PA_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (fst (Gauss_Jordan_PA A)) |i.\n     rank A \\<le> mod_type_class.to_nat i} =\n    {row i (fst (Gauss_Jordan_PA A)) |i.\n     (if A = 0 then 0\n      else mod_type_class.to_nat\n            (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n           1)\n     \\<le> mod_type_class.to_nat i}", "unfolding rank_Gauss_Jordan_code[of \"A\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (fst (Gauss_Jordan_PA A)) |i.\n     (if A = 0 then 0\n      else let A' = Gauss_Jordan A\n           in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)\n     \\<le> mod_type_class.to_nat i} =\n    {row i (fst (Gauss_Jordan_PA A)) |i.\n     (if A = 0 then 0\n      else mod_type_class.to_nat\n            (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n           1)\n     \\<le> mod_type_class.to_nat i}", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (fst (Gauss_Jordan_PA A)) |i.\n     (if A = 0 then 0\n      else mod_type_class.to_nat\n            (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n           1)\n     \\<le> mod_type_class.to_nat i} =\n    {row i (fst (Gauss_Jordan_PA A)) |i.\n     (if A = 0 then 0\n      else mod_type_class.to_nat\n            (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n           1)\n     \\<le> mod_type_class.to_nat i}", "unfolding transpose_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (fst (Gauss_Jordan_PA A)) |i.\n     (if A = 0 then 0\n      else mod_type_class.to_nat\n            (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n           1)\n     \\<le> mod_type_class.to_nat i} =\n    {row i (fst (Gauss_Jordan_PA A)) |i.\n     (if A = 0 then 0\n      else mod_type_class.to_nat\n            (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n           1)\n     \\<le> mod_type_class.to_nat i}", ".."], ["", "subsection\\<open>Demonstrations that they are bases\\<close>"], ["", "text\\<open>We prove that we have obtained a basis for each subspace\\<close>"], ["", "lemma independent_basis_left_null_space:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"vec.independent (basis_left_null_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (basis_left_null_space A)", "proof (unfold basis_left_null_space_def, rule vec.independent_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. vec.independent ?A\n 2. {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i}\n    \\<subseteq> ?A", "show \"vec.independent (rows (P_Gauss_Jordan A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (rows (P_Gauss_Jordan A))", "by (metis P_Gauss_Jordan_def det_dependent_rows invertible_det_nz invertible_fst_Gauss_Jordan_PA)"], ["proof (state)\nthis:\n  vec.independent (rows (P_Gauss_Jordan A))\n\ngoal (1 subgoal):\n 1. {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i}\n    \\<subseteq> rows (P_Gauss_Jordan A)", "show \"{row i (P_Gauss_Jordan A) |i. rank A \\<le> to_nat i} \\<subseteq> (rows (P_Gauss_Jordan A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i}\n    \\<subseteq> rows (P_Gauss_Jordan A)", "unfolding rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i}\n    \\<subseteq> {row i (P_Gauss_Jordan A) |i. i \\<in> UNIV}", "by fast"], ["proof (state)\nthis:\n  {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i}\n  \\<subseteq> rows (P_Gauss_Jordan A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_basis_left_null_space_eq_dim:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"card (basis_left_null_space A) = vec.dim (left_null_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) = vec.dim (left_null_space A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) = vec.dim (left_null_space A)", "let ?f=\"\\<lambda>n. row (from_nat (n + (rank A))) (P_Gauss_Jordan A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) = vec.dim (left_null_space A)", "have \"card (basis_left_null_space A) = card {row i (P_Gauss_Jordan A) | i. to_nat i \\<ge> rank A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) =\n    card {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i}", "unfolding basis_left_null_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i} =\n    card {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i}", ".."], ["proof (state)\nthis:\n  card (basis_left_null_space A) =\n  card {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i}\n\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) = vec.dim (left_null_space A)", "also"], ["proof (state)\nthis:\n  card (basis_left_null_space A) =\n  card {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i}\n\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) = vec.dim (left_null_space A)", "have \"... = card {..<(vec.dimension TYPE('a) TYPE('rows)) - rank A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i} =\n    card {..<finite_dimensional_vector_space.dimension cart_basis - rank A}", "proof (rule bij_betw_same_card[symmetric, of ?f], unfold bij_betw_def, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on\n     (\\<lambda>n.\n         row (mod_type_class.from_nat (n + rank A)) (P_Gauss_Jordan A))\n     {..<finite_dimensional_vector_space.dimension cart_basis - rank A}\n 2. (\\<lambda>n.\n        row (mod_type_class.from_nat (n + rank A)) (P_Gauss_Jordan A)) `\n    {..<finite_dimensional_vector_space.dimension cart_basis - rank A} =\n    {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i}", "show \"inj_on ?f {..<(vec.dimension TYPE('a) TYPE('rows)) - rank A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     (\\<lambda>n.\n         row (mod_type_class.from_nat (n + rank A)) (P_Gauss_Jordan A))\n     {..<finite_dimensional_vector_space.dimension cart_basis - rank A}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{..<finite_dimensional_vector_space.dimension\n                        cart_basis -\n                       rank A}.\n       \\<forall>y\\<in>{..<finite_dimensional_vector_space.dimension\n                           cart_basis -\n                          rank A}.\n          row (mod_type_class.from_nat (x + rank A)) (P_Gauss_Jordan A) =\n          row (mod_type_class.from_nat (y + rank A))\n           (P_Gauss_Jordan A) \\<longrightarrow>\n          x = y", "proof (auto, rule ccontr, unfold dimension_vector)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < CARD('rows) - rank A; y < CARD('rows) - rank A;\n        row (mod_type_class.from_nat (x + rank A)) (P_Gauss_Jordan A) =\n        row (mod_type_class.from_nat (y + rank A)) (P_Gauss_Jordan A);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < CARD('rows) - rank A; y < CARD('rows) - rank A;\n        row (mod_type_class.from_nat (x + rank A)) (P_Gauss_Jordan A) =\n        row (mod_type_class.from_nat (y + rank A)) (P_Gauss_Jordan A);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "assume x: \"x <CARD('rows) - rank A\"\n          and y: \"y < CARD('rows) - rank A\"\n          and eq: \"row (from_nat (x + rank A)) (P_Gauss_Jordan A) = row (from_nat (y + rank A)) (P_Gauss_Jordan A)\"\n          and x_not_y: \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x < CARD('rows) - rank A\n  y < CARD('rows) - rank A\n  row (mod_type_class.from_nat (x + rank A)) (P_Gauss_Jordan A) =\n  row (mod_type_class.from_nat (y + rank A)) (P_Gauss_Jordan A)\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < CARD('rows) - rank A; y < CARD('rows) - rank A;\n        row (mod_type_class.from_nat (x + rank A)) (P_Gauss_Jordan A) =\n        row (mod_type_class.from_nat (y + rank A)) (P_Gauss_Jordan A);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have \"det (P_Gauss_Jordan A) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (P_Gauss_Jordan A) = (0::'a)", "proof (rule det_identical_rows[OF _ eq])"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (x + rank A) \\<noteq>\n    mod_type_class.from_nat (y + rank A)", "have \"(x + rank A) \\<noteq> (y + rank A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + rank A \\<noteq> y + rank A", "using x_not_y x y"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x < CARD('rows) - rank A\n  y < CARD('rows) - rank A\n\ngoal (1 subgoal):\n 1. x + rank A \\<noteq> y + rank A", "by simp"], ["proof (state)\nthis:\n  x + rank A \\<noteq> y + rank A\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (x + rank A) \\<noteq>\n    mod_type_class.from_nat (y + rank A)", "thus \"(from_nat (x + rank A)::'rows) \\<noteq> from_nat (y + rank A)\""], ["proof (prove)\nusing this:\n  x + rank A \\<noteq> y + rank A\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (x + rank A) \\<noteq>\n    mod_type_class.from_nat (y + rank A)", "by (metis (mono_tags) from_nat_eq_imp_eq less_diff_conv x y)"], ["proof (state)\nthis:\n  mod_type_class.from_nat (x + rank A) \\<noteq>\n  mod_type_class.from_nat (y + rank A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (P_Gauss_Jordan A) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < CARD('rows) - rank A; y < CARD('rows) - rank A;\n        row (mod_type_class.from_nat (x + rank A)) (P_Gauss_Jordan A) =\n        row (mod_type_class.from_nat (y + rank A)) (P_Gauss_Jordan A);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  det (P_Gauss_Jordan A) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < CARD('rows) - rank A; y < CARD('rows) - rank A;\n        row (mod_type_class.from_nat (x + rank A)) (P_Gauss_Jordan A) =\n        row (mod_type_class.from_nat (y + rank A)) (P_Gauss_Jordan A);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have \"invertible (P_Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (P_Gauss_Jordan A)", "by (metis P_Gauss_Jordan_def invertible_fst_Gauss_Jordan_PA)"], ["proof (state)\nthis:\n  invertible (P_Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < CARD('rows) - rank A; y < CARD('rows) - rank A;\n        row (mod_type_class.from_nat (x + rank A)) (P_Gauss_Jordan A) =\n        row (mod_type_class.from_nat (y + rank A)) (P_Gauss_Jordan A);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  det (P_Gauss_Jordan A) = (0::'a)\n  invertible (P_Gauss_Jordan A)", "show False"], ["proof (prove)\nusing this:\n  det (P_Gauss_Jordan A) = (0::'a)\n  invertible (P_Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. False", "unfolding invertible_det_nz"], ["proof (prove)\nusing this:\n  det (P_Gauss_Jordan A) = (0::'a)\n  det (P_Gauss_Jordan A) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on\n   (\\<lambda>n.\n       row (mod_type_class.from_nat (n + rank A)) (P_Gauss_Jordan A))\n   {..<finite_dimensional_vector_space.dimension cart_basis - rank A}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        row (mod_type_class.from_nat (n + rank A)) (P_Gauss_Jordan A)) `\n    {..<finite_dimensional_vector_space.dimension cart_basis - rank A} =\n    {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i}", "show \"?f  ` {..<(vec.dimension TYPE('a) TYPE('rows)) - rank A} = {row i (P_Gauss_Jordan A) |i. rank A \\<le> to_nat i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        row (mod_type_class.from_nat (n + rank A)) (P_Gauss_Jordan A)) `\n    {..<finite_dimensional_vector_space.dimension cart_basis - rank A} =\n    {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i}", "proof (unfold image_def dimension_vector, auto, metis le_add2 less_diff_conv to_nat_from_nat_id)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       rank A \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       \\<exists>x\\<in>{..<CARD('rows) - rank A}.\n          row i (P_Gauss_Jordan A) =\n          row (mod_type_class.from_nat (x + rank A)) (P_Gauss_Jordan A)", "fix i::'rows"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       rank A \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       \\<exists>x\\<in>{..<CARD('rows) - rank A}.\n          row i (P_Gauss_Jordan A) =\n          row (mod_type_class.from_nat (x + rank A)) (P_Gauss_Jordan A)", "assume rank_le_i: \"rank A \\<le> to_nat i\""], ["proof (state)\nthis:\n  rank A \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       rank A \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       \\<exists>x\\<in>{..<CARD('rows) - rank A}.\n          row i (P_Gauss_Jordan A) =\n          row (mod_type_class.from_nat (x + rank A)) (P_Gauss_Jordan A)", "show \"\\<exists>x\\<in>{..<CARD('rows) - rank A}. row i (P_Gauss_Jordan A) = row (from_nat (x + rank A)) (P_Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{..<CARD('rows) - rank A}.\n       row i (P_Gauss_Jordan A) =\n       row (mod_type_class.from_nat (x + rank A)) (P_Gauss_Jordan A)", "proof (rule bexI[of _ \"(to_nat i - rank A)\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. row i (P_Gauss_Jordan A) =\n    row (mod_type_class.from_nat\n          (mod_type_class.to_nat i - rank A + rank A))\n     (P_Gauss_Jordan A)\n 2. mod_type_class.to_nat i - rank A \\<in> {..<CARD('rows) - rank A}", "have \"i = (from_nat (to_nat i - rank A + rank A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = mod_type_class.from_nat (mod_type_class.to_nat i - rank A + rank A)", "by (metis rank_le_i from_nat_to_nat_id le_add_diff_inverse2)"], ["proof (state)\nthis:\n  i = mod_type_class.from_nat (mod_type_class.to_nat i - rank A + rank A)\n\ngoal (2 subgoals):\n 1. row i (P_Gauss_Jordan A) =\n    row (mod_type_class.from_nat\n          (mod_type_class.to_nat i - rank A + rank A))\n     (P_Gauss_Jordan A)\n 2. mod_type_class.to_nat i - rank A \\<in> {..<CARD('rows) - rank A}", "thus \"row i (P_Gauss_Jordan A) = row (from_nat (to_nat i - rank A + rank A)) (P_Gauss_Jordan A)\""], ["proof (prove)\nusing this:\n  i = mod_type_class.from_nat (mod_type_class.to_nat i - rank A + rank A)\n\ngoal (1 subgoal):\n 1. row i (P_Gauss_Jordan A) =\n    row (mod_type_class.from_nat\n          (mod_type_class.to_nat i - rank A + rank A))\n     (P_Gauss_Jordan A)", "by presburger"], ["proof (state)\nthis:\n  row i (P_Gauss_Jordan A) =\n  row (mod_type_class.from_nat (mod_type_class.to_nat i - rank A + rank A))\n   (P_Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i - rank A \\<in> {..<CARD('rows) - rank A}", "show \"to_nat i - rank A \\<in> {..<CARD('rows) - rank A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i - rank A \\<in> {..<CARD('rows) - rank A}", "using rank_le_i"], ["proof (prove)\nusing this:\n  rank A \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i - rank A \\<in> {..<CARD('rows) - rank A}", "by (metis diff_less_mono lessThan_def mem_Collect_eq to_nat_less_card)"], ["proof (state)\nthis:\n  mod_type_class.to_nat i - rank A \\<in> {..<CARD('rows) - rank A}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{..<CARD('rows) - rank A}.\n     row i (P_Gauss_Jordan A) =\n     row (mod_type_class.from_nat (x + rank A)) (P_Gauss_Jordan A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      row (mod_type_class.from_nat (n + rank A)) (P_Gauss_Jordan A)) `\n  {..<finite_dimensional_vector_space.dimension cart_basis - rank A} =\n  {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i} =\n  card {..<finite_dimensional_vector_space.dimension cart_basis - rank A}\n\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) = vec.dim (left_null_space A)", "also"], ["proof (state)\nthis:\n  card {row i (P_Gauss_Jordan A) |i. rank A \\<le> mod_type_class.to_nat i} =\n  card {..<finite_dimensional_vector_space.dimension cart_basis - rank A}\n\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) = vec.dim (left_null_space A)", "have \"... = (vec.dimension TYPE('a) TYPE('rows)) - rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {..<finite_dimensional_vector_space.dimension cart_basis - rank A} =\n    finite_dimensional_vector_space.dimension cart_basis - rank A", "unfolding card_lessThan"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis - rank A =\n    finite_dimensional_vector_space.dimension cart_basis - rank A", ".."], ["proof (state)\nthis:\n  card {..<finite_dimensional_vector_space.dimension cart_basis - rank A} =\n  finite_dimensional_vector_space.dimension cart_basis - rank A\n\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) = vec.dim (left_null_space A)", "also"], ["proof (state)\nthis:\n  card {..<finite_dimensional_vector_space.dimension cart_basis - rank A} =\n  finite_dimensional_vector_space.dimension cart_basis - rank A\n\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) = vec.dim (left_null_space A)", "have \"... = vec.dim (null_space (transpose A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis - rank A =\n    vec.dim (null_space (Finite_Cartesian_Product.transpose A))", "unfolding dim_null_space rank_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis - rank A =\n    finite_dimensional_vector_space.dimension cart_basis - rank A", ".."], ["proof (state)\nthis:\n  finite_dimensional_vector_space.dimension cart_basis - rank A =\n  vec.dim (null_space (Finite_Cartesian_Product.transpose A))\n\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) = vec.dim (left_null_space A)", "also"], ["proof (state)\nthis:\n  finite_dimensional_vector_space.dimension cart_basis - rank A =\n  vec.dim (null_space (Finite_Cartesian_Product.transpose A))\n\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) = vec.dim (left_null_space A)", "have \"... = vec.dim (left_null_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (null_space (Finite_Cartesian_Product.transpose A)) =\n    vec.dim (left_null_space A)", "unfolding left_null_space_eq_null_space_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (null_space (Finite_Cartesian_Product.transpose A)) =\n    vec.dim (null_space (Finite_Cartesian_Product.transpose A))", ".."], ["proof (state)\nthis:\n  vec.dim (null_space (Finite_Cartesian_Product.transpose A)) =\n  vec.dim (left_null_space A)\n\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) = vec.dim (left_null_space A)", "finally"], ["proof (chain)\npicking this:\n  card (basis_left_null_space A) = vec.dim (left_null_space A)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (basis_left_null_space A) = vec.dim (left_null_space A)\n\ngoal (1 subgoal):\n 1. card (basis_left_null_space A) = vec.dim (left_null_space A)", "."], ["proof (state)\nthis:\n  card (basis_left_null_space A) = vec.dim (left_null_space A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_left_null_space_in_left_null_space:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"basis_left_null_space A \\<subseteq> left_null_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_left_null_space A \\<subseteq> left_null_space A", "proof (unfold basis_left_null_space_def left_null_space_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       rank A \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       row i (P_Gauss_Jordan A) v* A = 0", "fix i::'rows"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       rank A \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       row i (P_Gauss_Jordan A) v* A = 0", "assume rank_le_i: \" rank A \\<le> to_nat i\""], ["proof (state)\nthis:\n  rank A \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       rank A \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       row i (P_Gauss_Jordan A) v* A = 0", "have \"row i (P_Gauss_Jordan A) v* A = ((P_Gauss_Jordan A) $ i) v* A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row i (P_Gauss_Jordan A) v* A = P_Gauss_Jordan A $ i v* A", "unfolding row_def vec_nth_inverse"], ["proof (prove)\ngoal (1 subgoal):\n 1. P_Gauss_Jordan A $ i v* A = P_Gauss_Jordan A $ i v* A", ".."], ["proof (state)\nthis:\n  row i (P_Gauss_Jordan A) v* A = P_Gauss_Jordan A $ i v* A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       rank A \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       row i (P_Gauss_Jordan A) v* A = 0", "also"], ["proof (state)\nthis:\n  row i (P_Gauss_Jordan A) v* A = P_Gauss_Jordan A $ i v* A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       rank A \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       row i (P_Gauss_Jordan A) v* A = 0", "have \"... = ((P_Gauss_Jordan A) ** A) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P_Gauss_Jordan A $ i v* A = (P_Gauss_Jordan A ** A) $ i", "unfolding row_matrix_matrix_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P_Gauss_Jordan A ** A) $ i = (P_Gauss_Jordan A ** A) $ i", "by simp"], ["proof (state)\nthis:\n  P_Gauss_Jordan A $ i v* A = (P_Gauss_Jordan A ** A) $ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       rank A \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       row i (P_Gauss_Jordan A) v* A = 0", "also"], ["proof (state)\nthis:\n  P_Gauss_Jordan A $ i v* A = (P_Gauss_Jordan A ** A) $ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       rank A \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       row i (P_Gauss_Jordan A) v* A = 0", "have \"... = (Gauss_Jordan A) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P_Gauss_Jordan A ** A) $ i = Gauss_Jordan A $ i", "unfolding P_Gauss_Jordan_def Gauss_Jordan_PA_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (Gauss_Jordan_PA A) ** A) $ i = snd (Gauss_Jordan_PA A) $ i", "using fst_Gauss_Jordan_PA"], ["proof (prove)\nusing this:\n  fst (Gauss_Jordan_PA ?A) ** ?A = snd (Gauss_Jordan_PA ?A)\n\ngoal (1 subgoal):\n 1. (fst (Gauss_Jordan_PA A) ** A) $ i = snd (Gauss_Jordan_PA A) $ i", "by metis"], ["proof (state)\nthis:\n  (P_Gauss_Jordan A ** A) $ i = Gauss_Jordan A $ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       rank A \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       row i (P_Gauss_Jordan A) v* A = 0", "also"], ["proof (state)\nthis:\n  (P_Gauss_Jordan A ** A) $ i = Gauss_Jordan A $ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       rank A \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       row i (P_Gauss_Jordan A) v* A = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i = 0", "by (rule rank_less_row_i_imp_i_is_zero[OF rank_le_i])"], ["proof (state)\nthis:\n  Gauss_Jordan A $ i = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       rank A \\<le> mod_type_class.to_nat i \\<Longrightarrow>\n       row i (P_Gauss_Jordan A) v* A = 0", "finally"], ["proof (chain)\npicking this:\n  row i (P_Gauss_Jordan A) v* A = 0", "show \"row i (P_Gauss_Jordan A) v* A = 0\""], ["proof (prove)\nusing this:\n  row i (P_Gauss_Jordan A) v* A = 0\n\ngoal (1 subgoal):\n 1. row i (P_Gauss_Jordan A) v* A = 0", "."], ["proof (state)\nthis:\n  row i (P_Gauss_Jordan A) v* A = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_null_space_subset_span_basis:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows  \"left_null_space A \\<subseteq> vec.span (basis_left_null_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_null_space A \\<subseteq> vec.span (basis_left_null_space A)", "proof (rule vec.card_ge_dim_independent)"], ["proof (state)\ngoal (3 subgoals):\n 1. basis_left_null_space A \\<subseteq> left_null_space A\n 2. vec.independent (basis_left_null_space A)\n 3. vec.dim (left_null_space A) \\<le> card (basis_left_null_space A)", "show \"basis_left_null_space A \\<subseteq> left_null_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_left_null_space A \\<subseteq> left_null_space A", "by (rule basis_left_null_space_in_left_null_space)"], ["proof (state)\nthis:\n  basis_left_null_space A \\<subseteq> left_null_space A\n\ngoal (2 subgoals):\n 1. vec.independent (basis_left_null_space A)\n 2. vec.dim (left_null_space A) \\<le> card (basis_left_null_space A)", "show \"vec.independent (basis_left_null_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (basis_left_null_space A)", "by (rule independent_basis_left_null_space)"], ["proof (state)\nthis:\n  vec.independent (basis_left_null_space A)\n\ngoal (1 subgoal):\n 1. vec.dim (left_null_space A) \\<le> card (basis_left_null_space A)", "show \"vec.dim (left_null_space A) \\<le> card (basis_left_null_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (left_null_space A) \\<le> card (basis_left_null_space A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec.dim (left_null_space A) \\<le> card (basis_left_null_space A)", "have \"{x. x v* A = 0} = {x. (transpose A) *v x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x v* A = 0} = {x. Finite_Cartesian_Product.transpose A *v x = 0}", "by (metis transpose_vector)"], ["proof (state)\nthis:\n  {x. x v* A = 0} = {x. Finite_Cartesian_Product.transpose A *v x = 0}\n\ngoal (1 subgoal):\n 1. vec.dim (left_null_space A) \\<le> card (basis_left_null_space A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {x. x v* A = 0} = {x. Finite_Cartesian_Product.transpose A *v x = 0}\n\ngoal (1 subgoal):\n 1. vec.dim (left_null_space A) \\<le> card (basis_left_null_space A)", "using card_basis_left_null_space_eq_dim"], ["proof (prove)\nusing this:\n  {x. x v* A = 0} = {x. Finite_Cartesian_Product.transpose A *v x = 0}\n  card (basis_left_null_space ?A) = vec.dim (left_null_space ?A)\n\ngoal (1 subgoal):\n 1. vec.dim (left_null_space A) \\<le> card (basis_left_null_space A)", "by (metis order_refl)"], ["proof (state)\nthis:\n  vec.dim (left_null_space A) \\<le> card (basis_left_null_space A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec.dim (left_null_space A) \\<le> card (basis_left_null_space A)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary basis_left_null_space:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"vec.independent (basis_left_null_space A) \\<and> \n       left_null_space A = vec.span (basis_left_null_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (basis_left_null_space A) \\<and>\n    left_null_space A = vec.span (basis_left_null_space A)", "by (metis basis_left_null_space_in_left_null_space independent_basis_left_null_space \n  left_null_space_subset_span_basis vec.span_subspace subspace_left_null_space)"], ["", "corollary basis_null_space:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"vec.independent (basis_null_space A) \\<and> \n       null_space A = vec.span (basis_null_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (basis_null_space A) \\<and>\n    null_space A = vec.span (basis_null_space A)", "unfolding basis_null_space_eq_basis_left_null_space_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent\n     (basis_left_null_space (Finite_Cartesian_Product.transpose A)) \\<and>\n    null_space A =\n    vec.span (basis_left_null_space (Finite_Cartesian_Product.transpose A))", "unfolding null_space_eq_left_null_space_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent\n     (basis_left_null_space (Finite_Cartesian_Product.transpose A)) \\<and>\n    left_null_space (Finite_Cartesian_Product.transpose A) =\n    vec.span (basis_left_null_space (Finite_Cartesian_Product.transpose A))", "by (rule basis_left_null_space)"], ["", "lemma basis_row_space_subset_row_space:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"basis_row_space A \\<subseteq> row_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_row_space A \\<subseteq> row_space A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. basis_row_space A \\<subseteq> row_space A", "have \"basis_row_space A = {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_row_space A =\n    {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "unfolding basis_row_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0} =\n    {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", ".."], ["proof (state)\nthis:\n  basis_row_space A =\n  {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. basis_row_space A \\<subseteq> row_space A", "also"], ["proof (state)\nthis:\n  basis_row_space A =\n  {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. basis_row_space A \\<subseteq> row_space A", "have \"... \\<subseteq> row_space (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n    \\<subseteq> row_space (Gauss_Jordan A)", "proof (unfold row_space_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       row i (Gauss_Jordan A) \\<in> vec.span (rows (Gauss_Jordan A))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       row i (Gauss_Jordan A) \\<in> vec.span (rows (Gauss_Jordan A))", "assume \"row i (Gauss_Jordan A) \\<noteq> 0\""], ["proof (state)\nthis:\n  row i (Gauss_Jordan A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       row i (Gauss_Jordan A) \\<in> vec.span (rows (Gauss_Jordan A))", "show \"row i (Gauss_Jordan A) \\<in> vec.span (rows (Gauss_Jordan A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row i (Gauss_Jordan A) \\<in> vec.span (rows (Gauss_Jordan A))", "using rows_def vec.span_base"], ["proof (prove)\nusing this:\n  rows ?A = {row i ?A |i. i \\<in> UNIV}\n  ?a \\<in> ?S \\<Longrightarrow> ?a \\<in> vec.span ?S\n\ngoal (1 subgoal):\n 1. row i (Gauss_Jordan A) \\<in> vec.span (rows (Gauss_Jordan A))", "by auto"], ["proof (state)\nthis:\n  row i (Gauss_Jordan A) \\<in> vec.span (rows (Gauss_Jordan A))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n  \\<subseteq> row_space (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. basis_row_space A \\<subseteq> row_space A", "also"], ["proof (state)\nthis:\n  {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n  \\<subseteq> row_space (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. basis_row_space A \\<subseteq> row_space A", "have \"... = row_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_space (Gauss_Jordan A) = row_space A", "unfolding Gauss_Jordan_PA_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_space (snd (Gauss_Jordan_PA A)) = row_space A", "unfolding fst_Gauss_Jordan_PA[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_space (fst (Gauss_Jordan_PA A) ** A) = row_space A", "by (rule row_space_is_preserved[OF invertible_fst_Gauss_Jordan_PA])"], ["proof (state)\nthis:\n  row_space (Gauss_Jordan A) = row_space A\n\ngoal (1 subgoal):\n 1. basis_row_space A \\<subseteq> row_space A", "finally"], ["proof (chain)\npicking this:\n  basis_row_space A \\<subseteq> row_space A", "show ?thesis"], ["proof (prove)\nusing this:\n  basis_row_space A \\<subseteq> row_space A\n\ngoal (1 subgoal):\n 1. basis_row_space A \\<subseteq> row_space A", "."], ["proof (state)\nthis:\n  basis_row_space A \\<subseteq> row_space A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma row_space_subset_span_basis_row_space:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"row_space A \\<subseteq> vec.span (basis_row_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_space A \\<subseteq> vec.span (basis_row_space A)", "proof (rule vec.card_ge_dim_independent)"], ["proof (state)\ngoal (3 subgoals):\n 1. basis_row_space A \\<subseteq> row_space A\n 2. vec.independent (basis_row_space A)\n 3. vec.dim (row_space A) \\<le> card (basis_row_space A)", "show \"basis_row_space A \\<subseteq> row_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_row_space A \\<subseteq> row_space A", "by (rule basis_row_space_subset_row_space)"], ["proof (state)\nthis:\n  basis_row_space A \\<subseteq> row_space A\n\ngoal (2 subgoals):\n 1. vec.independent (basis_row_space A)\n 2. vec.dim (row_space A) \\<le> card (basis_row_space A)", "show \"vec.independent (basis_row_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (basis_row_space A)", "unfolding basis_row_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent\n     {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "by (rule independent_not_zero_rows_rref[OF rref_Gauss_Jordan])"], ["proof (state)\nthis:\n  vec.independent (basis_row_space A)\n\ngoal (1 subgoal):\n 1. vec.dim (row_space A) \\<le> card (basis_row_space A)", "show \"vec.dim (row_space A) \\<le> card (basis_row_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (row_space A) \\<le> card (basis_row_space A)", "unfolding basis_row_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (row_space A)\n    \\<le> card\n           {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "using rref_rank[OF rref_Gauss_Jordan, of A]"], ["proof (prove)\nusing this:\n  rank (Gauss_Jordan A) =\n  card {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. vec.dim (row_space A)\n    \\<le> card\n           {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "unfolding row_rank_def[symmetric] rank_def[symmetric] rank_Gauss_Jordan[symmetric]"], ["proof (prove)\nusing this:\n  rank A =\n  card {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. rank A\n    \\<le> card\n           {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "by fastforce"], ["proof (state)\nthis:\n  vec.dim (row_space A) \\<le> card (basis_row_space A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_row_space:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"vec.independent (basis_row_space A)\n  \\<and> vec.span (basis_row_space A) = row_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (basis_row_space A) \\<and>\n    vec.span (basis_row_space A) = row_space A", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. vec.independent (basis_row_space A)\n 2. vec.span (basis_row_space A) = row_space A", "show \"vec.independent (basis_row_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (basis_row_space A)", "unfolding basis_row_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent\n     {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "using independent_not_zero_rows_rref[OF rref_Gauss_Jordan]"], ["proof (prove)\nusing this:\n  vec.independent\n   {row i (Gauss_Jordan ?A1) |i. row i (Gauss_Jordan ?A1) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. vec.independent\n     {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "."], ["proof (state)\nthis:\n  vec.independent (basis_row_space A)\n\ngoal (1 subgoal):\n 1. vec.span (basis_row_space A) = row_space A", "show \"vec.span (basis_row_space A) = row_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.span (basis_row_space A) = row_space A", "proof (rule vec.span_subspace)"], ["proof (state)\ngoal (3 subgoals):\n 1. basis_row_space A \\<subseteq> row_space A\n 2. row_space A \\<subseteq> vec.span (basis_row_space A)\n 3. vec.subspace (row_space A)", "show \"basis_row_space A \\<subseteq> row_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_row_space A \\<subseteq> row_space A", "by (rule basis_row_space_subset_row_space)"], ["proof (state)\nthis:\n  basis_row_space A \\<subseteq> row_space A\n\ngoal (2 subgoals):\n 1. row_space A \\<subseteq> vec.span (basis_row_space A)\n 2. vec.subspace (row_space A)", "show \"row_space A \\<subseteq> vec.span (basis_row_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_space A \\<subseteq> vec.span (basis_row_space A)", "by (rule row_space_subset_span_basis_row_space)"], ["proof (state)\nthis:\n  row_space A \\<subseteq> vec.span (basis_row_space A)\n\ngoal (1 subgoal):\n 1. vec.subspace (row_space A)", "show \"vec.subspace (row_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.subspace (row_space A)", "by (rule subspace_row_space)"], ["proof (state)\nthis:\n  vec.subspace (row_space A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec.span (basis_row_space A) = row_space A\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary basis_col_space:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"vec.independent (basis_col_space A)\n  \\<and> vec.span (basis_col_space A) = col_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (basis_col_space A) \\<and>\n    vec.span (basis_col_space A) = col_space A", "unfolding col_space_eq_row_space_transpose basis_col_space_eq_basis_row_space_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent\n     (basis_row_space (Finite_Cartesian_Product.transpose A)) \\<and>\n    vec.span (basis_row_space (Finite_Cartesian_Product.transpose A)) =\n    row_space (Finite_Cartesian_Product.transpose A)", "by (rule basis_row_space)"], ["", "end"]]}