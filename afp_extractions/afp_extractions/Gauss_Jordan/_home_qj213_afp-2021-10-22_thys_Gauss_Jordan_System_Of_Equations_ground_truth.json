{"file_name": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan/System_Of_Equations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan", "problem_names": ["lemma is_solution_imp_solve_system:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes xAb:\"is_solution x A b\"\n  shows \"is_solution x (fst (solve_system A b)) (snd (solve_system A b))\"", "lemma solve_system_imp_is_solution:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes xAb: \"is_solution x (fst (solve_system A b)) (snd (solve_system A b))\"\n  shows \"is_solution x A b\"", "lemma is_solution_solve_system:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"is_solution x A b = is_solution x (fst (solve_system A b)) (snd (solve_system A b))\"", "lemma inconsistent: \"inconsistent A b = (\\<not> (\\<exists>x. is_solution x A b))\"", "lemma solve_consistent_rref_code[code abstract]:\n  shows \"vec_nth (solve_consistent_rref A b) = (% j. if (\\<exists>i. A $ i $ j = 1 \\<and> j=(LEAST n. A $ i $ n \\<noteq> 0)) then b $ (THE i. A $ i $ j = 1) else 0)\"", "lemma rank_ge_imp_is_solution:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes con: \"rank A \\<ge> (if (\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) \n                                            then (to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1) else 0)\"\n  shows \"is_solution (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b)) A b\"", "lemma inconsistent_imp_rank_less:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes inc: \"inconsistent A b\"\n  shows \"rank A < (if (\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) then (to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1) else 0)\"", "lemma rank_less_imp_inconsistent:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes inc: \"rank A < (if (\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) then (to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1) else 0)\"\n  shows \"inconsistent A b\"", "lemma inconsistent_eq_rank_less:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"inconsistent A b = (rank A < (if (\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) \n                                            then (to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1) else 0))\"", "lemma consistent_eq_rank_ge:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"consistent A b = (rank A \\<ge> (if (\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) \n                                            then (to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1) else 0))\"", "lemma inconsistent_eq_rank_less_code[code]:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"inconsistent A b = (let GJ_P=Gauss_Jordan_PA A; \n                                P_mult_b = (fst(GJ_P) *v b);\n                                rank_A = (if A = 0 then 0 else to_nat (GREATEST a. row a (snd GJ_P) \\<noteq> 0) + 1)  in (rank_A < (if (\\<exists>a. P_mult_b $ a \\<noteq> 0) \n                                            then (to_nat (GREATEST a. P_mult_b $ a \\<noteq> 0) + 1) else 0)))\"", "lemma consistent_eq_rank_ge_code[code]:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"consistent A b = (let GJ_P=Gauss_Jordan_PA A; \n                              P_mult_b = (fst(GJ_P) *v b);\n                              rank_A = (if A = 0 then 0 else to_nat (GREATEST a. row a (snd GJ_P) \\<noteq> 0) + 1) in (rank_A \\<ge> (if (\\<exists>a. P_mult_b $ a \\<noteq> 0) \n                                            then (to_nat (GREATEST a. P_mult_b $ a \\<noteq> 0) + 1) else 0)))\"", "lemma null_space_eq_solution_set: \nshows \"null_space A = solution_set A 0\"", "lemma zero_is_solution_homogeneous_system:\nshows \"0 \\<in> (solution_set A 0)\"", "lemma homogeneous_solution_set_subspace:\nfixes A::\"'a::{field}^'n^'rows\"\nshows \"vec.subspace (solution_set A 0)\"", "lemma solution_set_rel:\nfixes A::\"'a::{field}^'n^'rows\"\nassumes p: \"is_solution p A b\"\nshows \"solution_set A b = {p} + (solution_set A 0)\"", "lemma independent_and_consistent_imp_uniqueness_solution:\nfixes A::\"'a::{field}^'n::{mod_type}^'rows::{mod_type}\"\nassumes dim_0: \"vec.dim (solution_set A 0) = 0\"\nand con: \"consistent A b\"\nshows \"\\<exists>!x. is_solution x A b\"", "lemma card_1_exists: \"card s = 1 \\<longleftrightarrow> (\\<exists>!x. x \\<in> s)\"", "lemma uniqueness_solution_imp_independent:\nfixes A::\"'a::{field}^'n^'rows\"\nassumes ex1_sol: \"\\<exists>!x. is_solution x A b\"\nshows \"vec.dim (solution_set A 0) = 0\"", "lemma consistent_homogeneous: \nshows \"consistent A 0\"", "lemma dim_solution_set_0:\n  fixes A::\"'a::{field}^'n::{mod_type}^'rows::{mod_type}\"\n  shows \"(vec.dim (solution_set A 0) = 0) = (solution_set A 0 = {0})\"", "lemma dim_solution_set_not_zero_imp_infinite_solutions_homogeneous:\nfixes A::\"'a::{field, semiring_char_0}^'n::{mod_type}^'rows::{mod_type}\"\nassumes dim_not_zero: \"vec.dim (solution_set A 0) > 0\"\nshows \"infinite (solution_set A 0)\"", "lemma infinite_solutions_homogeneous_imp_dim_solution_set_not_zero:\n  fixes A::\"'a::{field}^'n::{mod_type}^'rows::{mod_type}\"\n  assumes i: \"infinite (solution_set A 0)\"\n  shows \"vec.dim (solution_set A 0) > 0\"", "lemma infinite_solution_set_imp_consistent:\n  \"infinite (solution_set A b) \\<Longrightarrow> consistent A b\"", "lemma dim_solution_set_not_zero_imp_infinite_solutions_no_homogeneous:\nfixes A::\"'a::{field, semiring_char_0}^'n::{mod_type}^'rows::{mod_type}\"\nassumes dim_not_0: \"vec.dim (solution_set A 0) > 0\"\nand con: \"consistent A b\"\nshows \"infinite (solution_set A b)\"", "lemma infinite_solutions_no_homogeneous_imp_dim_solution_set_not_zero_imp:\n  fixes A::\"'a::{field}^'n::{mod_type}^'rows::{mod_type}\"\n  assumes i: \"infinite (solution_set A b)\"\n  shows \"vec.dim (solution_set A 0) > 0\"", "lemma solve_code[code]:\n  shows \"solve A b = (let GJ_P=Gauss_Jordan_PA A; \n                        P_times_b=fst(GJ_P) *v b;\n                        rank_A = (if A = 0 then 0 else to_nat (GREATEST a. row a (snd GJ_P) \\<noteq> 0) + 1);\n                        consistent_Ab = (rank_A \\<ge> (if (\\<exists>a. (P_times_b) $ a \\<noteq> 0) then (to_nat (GREATEST a. (P_times_b) $ a \\<noteq> 0) + 1) else 0));\n                        GJ_transpose = Gauss_Jordan_PA (transpose A); \n                        basis = {row i (fst GJ_transpose) | i. to_nat i \\<ge> rank_A}\n                        in (if consistent_Ab then Some (solve_consistent_rref (snd GJ_P) P_times_b,basis) else None))\"", "lemma consistent_imp_is_solution_solve:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes con: \"consistent A b\"\n  shows \"is_solution (fst (the (solve A b))) A b\"", "lemma inconsistent_imp_solve_eq_none:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes con: \"inconsistent A b\"\n  shows \"solve A b = None\"", "lemma solution_set_rel_solve:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes con: \"consistent A b\"\n  shows \"solution_set A b = {fst (the (solve A b))} + vec.span (snd (the (solve A b)))\"", "lemma is_solution_eq_in_span_solve:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes con: \"consistent A b\"\n  shows \"(is_solution x A b) = (x \\<in> {fst (the (solve A b))} + vec.span (snd (the (solve A b))))\""], "translations": [["", "lemma is_solution_imp_solve_system:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes xAb:\"is_solution x A b\"\n  shows \"is_solution x (fst (solve_system A b)) (snd (solve_system A b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution x (fst (solve_system A b)) (snd (solve_system A b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_solution x (fst (solve_system A b)) (snd (solve_system A b))", "have \"(fst (Gauss_Jordan_PA A)*v(A *v x) = fst (Gauss_Jordan_PA A) *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_PA A) *v (A *v x) = fst (Gauss_Jordan_PA A) *v b", "using xAb"], ["proof (prove)\nusing this:\n  is_solution x A b\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_PA A) *v (A *v x) = fst (Gauss_Jordan_PA A) *v b", "unfolding is_solution_def"], ["proof (prove)\nusing this:\n  A *v x = b\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_PA A) *v (A *v x) = fst (Gauss_Jordan_PA A) *v b", "by fast"], ["proof (state)\nthis:\n  fst (Gauss_Jordan_PA A) *v (A *v x) = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. is_solution x (fst (solve_system A b)) (snd (solve_system A b))", "hence \"(snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b)\""], ["proof (prove)\nusing this:\n  fst (Gauss_Jordan_PA A) *v (A *v x) = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b", "unfolding matrix_vector_mul_assoc"], ["proof (prove)\nusing this:\n  fst (Gauss_Jordan_PA A) ** A *v x = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b", "unfolding fst_Gauss_Jordan_PA[of A]"], ["proof (prove)\nusing this:\n  snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b", "."], ["proof (state)\nthis:\n  snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. is_solution x (fst (solve_system A b)) (snd (solve_system A b))", "thus \"is_solution x (fst (solve_system A b)) (snd (solve_system A b))\""], ["proof (prove)\nusing this:\n  snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. is_solution x (fst (solve_system A b)) (snd (solve_system A b))", "unfolding is_solution_def solve_system_def Let_def"], ["proof (prove)\nusing this:\n  snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. fst (snd (Gauss_Jordan_PA A), fst (Gauss_Jordan_PA A) *v b) *v x =\n    snd (snd (Gauss_Jordan_PA A), fst (Gauss_Jordan_PA A) *v b)", "by simp"], ["proof (state)\nthis:\n  is_solution x (fst (solve_system A b)) (snd (solve_system A b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma solve_system_imp_is_solution:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes xAb: \"is_solution x (fst (solve_system A b)) (snd (solve_system A b))\"\n  shows \"is_solution x A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution x A b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_solution x A b", "have \"fst (solve_system A b) *v x = snd (solve_system A b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (solve_system A b) *v x = snd (solve_system A b)", "using xAb"], ["proof (prove)\nusing this:\n  is_solution x (fst (solve_system A b)) (snd (solve_system A b))\n\ngoal (1 subgoal):\n 1. fst (solve_system A b) *v x = snd (solve_system A b)", "unfolding is_solution_def"], ["proof (prove)\nusing this:\n  fst (solve_system A b) *v x = snd (solve_system A b)\n\ngoal (1 subgoal):\n 1. fst (solve_system A b) *v x = snd (solve_system A b)", "."], ["proof (state)\nthis:\n  fst (solve_system A b) *v x = snd (solve_system A b)\n\ngoal (1 subgoal):\n 1. is_solution x A b", "hence \"snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b\""], ["proof (prove)\nusing this:\n  fst (solve_system A b) *v x = snd (solve_system A b)\n\ngoal (1 subgoal):\n 1. snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b", "unfolding solve_system_def Let_def fst_conv snd_conv"], ["proof (prove)\nusing this:\n  snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b", "."], ["proof (state)\nthis:\n  snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. is_solution x A b", "hence \"(fst (Gauss_Jordan_PA A) ** A) *v x = fst (Gauss_Jordan_PA A) *v b\""], ["proof (prove)\nusing this:\n  snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_PA A) ** A *v x = fst (Gauss_Jordan_PA A) *v b", "unfolding fst_Gauss_Jordan_PA"], ["proof (prove)\nusing this:\n  snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. snd (Gauss_Jordan_PA A) *v x = fst (Gauss_Jordan_PA A) *v b", "."], ["proof (state)\nthis:\n  fst (Gauss_Jordan_PA A) ** A *v x = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. is_solution x A b", "hence \"fst (Gauss_Jordan_PA A) *v (A *v x) = fst (Gauss_Jordan_PA A) *v b\""], ["proof (prove)\nusing this:\n  fst (Gauss_Jordan_PA A) ** A *v x = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_PA A) *v (A *v x) = fst (Gauss_Jordan_PA A) *v b", "unfolding matrix_vector_mul_assoc"], ["proof (prove)\nusing this:\n  fst (Gauss_Jordan_PA A) ** A *v x = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_PA A) ** A *v x = fst (Gauss_Jordan_PA A) *v b", "."], ["proof (state)\nthis:\n  fst (Gauss_Jordan_PA A) *v (A *v x) = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. is_solution x A b", "hence \"matrix_inv (fst (Gauss_Jordan_PA A)) *v (fst (Gauss_Jordan_PA A) *v (A *v x)) \n  = matrix_inv (fst (Gauss_Jordan_PA A)) *v (fst (Gauss_Jordan_PA A) *v b)\""], ["proof (prove)\nusing this:\n  fst (Gauss_Jordan_PA A) *v (A *v x) = fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. matrix_inv (fst (Gauss_Jordan_PA A)) *v\n    (fst (Gauss_Jordan_PA A) *v (A *v x)) =\n    matrix_inv (fst (Gauss_Jordan_PA A)) *v (fst (Gauss_Jordan_PA A) *v b)", "by simp"], ["proof (state)\nthis:\n  matrix_inv (fst (Gauss_Jordan_PA A)) *v\n  (fst (Gauss_Jordan_PA A) *v (A *v x)) =\n  matrix_inv (fst (Gauss_Jordan_PA A)) *v (fst (Gauss_Jordan_PA A) *v b)\n\ngoal (1 subgoal):\n 1. is_solution x A b", "hence \"(A *v x) = b\""], ["proof (prove)\nusing this:\n  matrix_inv (fst (Gauss_Jordan_PA A)) *v\n  (fst (Gauss_Jordan_PA A) *v (A *v x)) =\n  matrix_inv (fst (Gauss_Jordan_PA A)) *v (fst (Gauss_Jordan_PA A) *v b)\n\ngoal (1 subgoal):\n 1. A *v x = b", "unfolding matrix_vector_mul_assoc[of \"matrix_inv (fst (Gauss_Jordan_PA A))\"]"], ["proof (prove)\nusing this:\n  matrix_inv (fst (Gauss_Jordan_PA A)) ** fst (Gauss_Jordan_PA A) *v\n  (A *v x) =\n  matrix_inv (fst (Gauss_Jordan_PA A)) ** fst (Gauss_Jordan_PA A) *v b\n\ngoal (1 subgoal):\n 1. A *v x = b", "unfolding matrix_inv_left[OF invertible_fst_Gauss_Jordan_PA]"], ["proof (prove)\nusing this:\n  mat (1::'a) *v (A *v x) = mat (1::'a) *v b\n\ngoal (1 subgoal):\n 1. A *v x = b", "unfolding matrix_vector_mul_lid"], ["proof (prove)\nusing this:\n  A *v x = b\n\ngoal (1 subgoal):\n 1. A *v x = b", "."], ["proof (state)\nthis:\n  A *v x = b\n\ngoal (1 subgoal):\n 1. is_solution x A b", "thus ?thesis"], ["proof (prove)\nusing this:\n  A *v x = b\n\ngoal (1 subgoal):\n 1. is_solution x A b", "unfolding is_solution_def"], ["proof (prove)\nusing this:\n  A *v x = b\n\ngoal (1 subgoal):\n 1. A *v x = b", "."], ["proof (state)\nthis:\n  is_solution x A b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_solution_solve_system:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"is_solution x A b = is_solution x (fst (solve_system A b)) (snd (solve_system A b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution x A b =\n    is_solution x (fst (solve_system A b)) (snd (solve_system A b))", "using solve_system_imp_is_solution is_solution_imp_solve_system"], ["proof (prove)\nusing this:\n  is_solution ?x (fst (solve_system ?A ?b))\n   (snd (solve_system ?A ?b)) \\<Longrightarrow>\n  is_solution ?x ?A ?b\n  is_solution ?x ?A ?b \\<Longrightarrow>\n  is_solution ?x (fst (solve_system ?A ?b)) (snd (solve_system ?A ?b))\n\ngoal (1 subgoal):\n 1. is_solution x A b =\n    is_solution x (fst (solve_system A b)) (snd (solve_system A b))", "by blast"], ["", "subsection\\<open>Consistent and inconsistent systems of equations\\<close>"], ["", "definition consistent :: \"'a::{field}^'cols::{mod_type}^'rows::{mod_type} \\<Rightarrow> 'a::{field}^'rows::{mod_type} \\<Rightarrow> bool\"\n  where \"consistent A b = (\\<exists>x. is_solution x A b)\""], ["", "definition inconsistent where \"inconsistent A b =  (\\<not> (consistent A b))\""], ["", "lemma inconsistent: \"inconsistent A b = (\\<not> (\\<exists>x. is_solution x A b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsistent A b = (\\<nexists>x. is_solution x A b)", "unfolding inconsistent_def consistent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>x. is_solution x A b) = (\\<nexists>x. is_solution x A b)", "by simp"], ["", "text\\<open>The following function will be use to solve consistent systems which are already in the reduced row echelon form.\\<close>"], ["", "definition solve_consistent_rref :: \"'a::{field}^'cols::{mod_type}^'rows::{mod_type} \\<Rightarrow> 'a::{field}^'rows::{mod_type} \\<Rightarrow> 'a::{field}^'cols::{mod_type}\"\n  where \"solve_consistent_rref A b = (\\<chi> j. if (\\<exists>i. A $ i $ j = 1 \\<and> j=(LEAST n. A $ i $ n \\<noteq> 0)) then b $ (THE i. A $ i $ j = 1) else 0)\""], ["", "lemma solve_consistent_rref_code[code abstract]:\n  shows \"vec_nth (solve_consistent_rref A b) = (% j. if (\\<exists>i. A $ i $ j = 1 \\<and> j=(LEAST n. A $ i $ n \\<noteq> 0)) then b $ (THE i. A $ i $ j = 1) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (solve_consistent_rref A b) =\n    (\\<lambda>j.\n        if \\<exists>i.\n              A $ i $ j = (1::'b) \\<and>\n              j = (LEAST n. A $ i $ n \\<noteq> (0::'b))\n        then b $ (THE i. A $ i $ j = (1::'b)) else (0::'b))", "unfolding solve_consistent_rref_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>j.\n            if \\<exists>i.\n                  A $ i $ j = (1::'b) \\<and>\n                  j = (LEAST n. A $ i $ n \\<noteq> (0::'b))\n            then b $ (THE i. A $ i $ j = (1::'b)) else (0::'b)) =\n    (\\<lambda>j.\n        if \\<exists>i.\n              A $ i $ j = (1::'b) \\<and>\n              j = (LEAST n. A $ i $ n \\<noteq> (0::'b))\n        then b $ (THE i. A $ i $ j = (1::'b)) else (0::'b))", "by auto"], ["", "lemma rank_ge_imp_is_solution:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes con: \"rank A \\<ge> (if (\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) \n                                            then (to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1) else 0)\"\n  shows \"is_solution (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b)) A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution\n     (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b)) A b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_solution\n     (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b)) A b", "have \"is_solution (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b)) (Gauss_Jordan A) (P_Gauss_Jordan A *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution\n     (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b))\n     (Gauss_Jordan A) (P_Gauss_Jordan A *v b)", "proof (unfold is_solution_def solve_consistent_rref_def, subst matrix_vector_mult_def, vector, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<Sum>j\\<in>UNIV.\n          Gauss_Jordan A $ i $ j *\n          (if \\<exists>i.\n                 Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n                 j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n           then (P_Gauss_Jordan A *v b) $\n                (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n           else (0::'a))) =\n       (P_Gauss_Jordan A *v b) $ i", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<Sum>j\\<in>UNIV.\n          Gauss_Jordan A $ i $ j *\n          (if \\<exists>i.\n                 Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n                 j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n           then (P_Gauss_Jordan A *v b) $\n                (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n           else (0::'a))) =\n       (P_Gauss_Jordan A *v b) $ i", "let ?f=\"\\<lambda>j. Gauss_Jordan A $ a $ j *\n      (if \\<exists>i. Gauss_Jordan A $ i $ j = 1 \\<and> j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> 0) \n        then (P_Gauss_Jordan A *v b) $ (THE i. Gauss_Jordan A $ i $ j = 1) else 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<Sum>j\\<in>UNIV.\n          Gauss_Jordan A $ i $ j *\n          (if \\<exists>i.\n                 Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n                 j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n           then (P_Gauss_Jordan A *v b) $\n                (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n           else (0::'a))) =\n       (P_Gauss_Jordan A *v b) $ i", "show \"sum ?f UNIV = (P_Gauss_Jordan A *v b) $ a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "proof (cases \"A=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "case True"], ["proof (state)\nthis:\n  A = 0\n\ngoal (2 subgoals):\n 1. A = 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "hence rank_A_eq_0:\"rank A = 0\""], ["proof (prove)\nusing this:\n  A = 0\n\ngoal (1 subgoal):\n 1. rank A = 0", "using rank_0"], ["proof (prove)\nusing this:\n  A = 0\n  rank 0 = 0\n\ngoal (1 subgoal):\n 1. rank A = 0", "by simp"], ["proof (state)\nthis:\n  rank A = 0\n\ngoal (2 subgoals):\n 1. A = 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have \"(P_Gauss_Jordan A *v b) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P_Gauss_Jordan A *v b = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. P_Gauss_Jordan A *v b \\<noteq> 0 \\<Longrightarrow> False", "assume not_zero: \"P_Gauss_Jordan A *v b \\<noteq> 0\""], ["proof (state)\nthis:\n  P_Gauss_Jordan A *v b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. P_Gauss_Jordan A *v b \\<noteq> 0 \\<Longrightarrow> False", "hence ex_a: \"\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  P_Gauss_Jordan A *v b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)", "by (metis vec_eq_iff zero_index)"], ["proof (state)\nthis:\n  \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. P_Gauss_Jordan A *v b \\<noteq> 0 \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using con"], ["proof (prove)\nusing this:\n  (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n   then mod_type_class.to_nat\n         (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n        1\n   else 0)\n  \\<le> rank A\n\ngoal (1 subgoal):\n 1. False", "unfolding if_P[OF ex_a]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat\n   (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n  1\n  \\<le> rank A\n\ngoal (1 subgoal):\n 1. False", "unfolding rank_A_eq_0"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat\n   (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n  1\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P_Gauss_Jordan A *v b = 0\n\ngoal (2 subgoals):\n 1. A = 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "thus ?thesis"], ["proof (prove)\nusing this:\n  P_Gauss_Jordan A *v b = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "unfolding A_0_imp_Gauss_Jordan_0[OF True]"], ["proof (prove)\nusing this:\n  P_Gauss_Jordan A *v b = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV.\n       0 $ a $ j *\n       (if \\<exists>i.\n              0 $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. 0 $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $ (THE i. 0 $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "by force"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (P_Gauss_Jordan A *v b) $ a\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "case False"], ["proof (state)\nthis:\n  A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "note A_not_zero=False"], ["proof (state)\nthis:\n  A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "define not_zero_positions_row_a where \"not_zero_positions_row_a = {j. Gauss_Jordan A $ a $ j \\<noteq> 0}\""], ["proof (state)\nthis:\n  not_zero_positions_row_a = {j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "define zero_positions_row_a where \"zero_positions_row_a = {j. Gauss_Jordan A $ a $ j = 0}\""], ["proof (state)\nthis:\n  zero_positions_row_a = {j. Gauss_Jordan A $ a $ j = (0::'a)}\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have UNIV_rw: \"UNIV = not_zero_positions_row_a \\<union> zero_positions_row_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = not_zero_positions_row_a \\<union> zero_positions_row_a", "unfolding zero_positions_row_a_def not_zero_positions_row_a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV =\n    {j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)} \\<union>\n    {j. Gauss_Jordan A $ a $ j = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  UNIV = not_zero_positions_row_a \\<union> zero_positions_row_a\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have disj: \"not_zero_positions_row_a \\<inter> zero_positions_row_a = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_zero_positions_row_a \\<inter> zero_positions_row_a = {}", "unfolding zero_positions_row_a_def not_zero_positions_row_a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)} \\<inter>\n    {j. Gauss_Jordan A $ a $ j = (0::'a)} =\n    {}", "by fastforce"], ["proof (state)\nthis:\n  not_zero_positions_row_a \\<inter> zero_positions_row_a = {}\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have sum_zero: \"(sum ?f zero_positions_row_a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (0::'a)", "by (unfold zero_positions_row_a_def, rule sum.neutral, fastforce)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have \"sum ?f (UNIV::'cols set)=sum ?f (not_zero_positions_row_a \\<union> zero_positions_row_a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (\\<Sum>j\\<in>not_zero_positions_row_a \\<union> zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a)))", "unfolding UNIV_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>not_zero_positions_row_a \\<union> zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (\\<Sum>j\\<in>not_zero_positions_row_a \\<union> zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a)))", ".."], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (\\<Sum>j\\<in>not_zero_positions_row_a \\<union> zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (\\<Sum>j\\<in>not_zero_positions_row_a \\<union> zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have \"... = sum ?f (not_zero_positions_row_a) + (sum ?f zero_positions_row_a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>not_zero_positions_row_a \\<union> zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) +\n    (\\<Sum>j\\<in>zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a)))", "by (rule sum.union_disjoint[OF _ _ disj], simp+)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>not_zero_positions_row_a \\<union> zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) +\n  (\\<Sum>j\\<in>zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>not_zero_positions_row_a \\<union> zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) +\n  (\\<Sum>j\\<in>zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have \"... = sum ?f (not_zero_positions_row_a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) +\n    (\\<Sum>j\\<in>zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a)))", "unfolding sum_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) +\n    (0::'a) =\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a)))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) +\n  (\\<Sum>j\\<in>zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) +\n  (\\<Sum>j\\<in>zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have \"... = (P_Gauss_Jordan A *v b) $ a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "proof (cases \"not_zero_positions_row_a = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. not_zero_positions_row_a = {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "case True"], ["proof (state)\nthis:\n  not_zero_positions_row_a = {}\n\ngoal (2 subgoals):\n 1. not_zero_positions_row_a = {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "note zero_row_a=True"], ["proof (state)\nthis:\n  not_zero_positions_row_a = {}\n\ngoal (2 subgoals):\n 1. not_zero_positions_row_a = {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "proof (cases \"\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. \\<nexists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "case False"], ["proof (state)\nthis:\n  \\<nexists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. \\<nexists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "hence \"(P_Gauss_Jordan A *v b) $ a = 0\""], ["proof (prove)\nusing this:\n  \\<nexists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (P_Gauss_Jordan A *v b) $ a = (0::'a)", "by simp"], ["proof (state)\nthis:\n  (P_Gauss_Jordan A *v b) $ a = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. \\<nexists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P_Gauss_Jordan A *v b) $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "unfolding True"], ["proof (prove)\nusing this:\n  (P_Gauss_Jordan A *v b) $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{}.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (P_Gauss_Jordan A *v b) $ a\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "case True"], ["proof (state)\nthis:\n  \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have rank_not_0: \"rank A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A \\<noteq> 0", "by (metis A_not_zero less_not_refl3 rank_Gauss_Jordan rank_greater_zero)"], ["proof (state)\nthis:\n  rank A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have greatest_less_a: \"(GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) < a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) < a", "proof (unfold is_zero_row_def, rule greatest_less_zero_row)"], ["proof (state)\ngoal (3 subgoals):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan A) (ncols (Gauss_Jordan A))\n 2. is_zero_row_upt_k a (ncols (Gauss_Jordan A)) (Gauss_Jordan A)\n 3. \\<not> (\\<forall>a.\n               is_zero_row_upt_k a (ncols (Gauss_Jordan A))\n                (Gauss_Jordan A))", "show \" reduced_row_echelon_form_upt_k (Gauss_Jordan A) (ncols (Gauss_Jordan A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan A) (ncols (Gauss_Jordan A))", "using rref_Gauss_Jordan"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form (Gauss_Jordan ?A)\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan A) (ncols (Gauss_Jordan A))", "unfolding reduced_row_echelon_form_def"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k (Gauss_Jordan ?A) (ncols (Gauss_Jordan ?A))\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan A) (ncols (Gauss_Jordan A))", "."], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k (Gauss_Jordan A) (ncols (Gauss_Jordan A))\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k a (ncols (Gauss_Jordan A)) (Gauss_Jordan A)\n 2. \\<not> (\\<forall>a.\n               is_zero_row_upt_k a (ncols (Gauss_Jordan A))\n                (Gauss_Jordan A))", "show \"is_zero_row_upt_k a (ncols (Gauss_Jordan A)) (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a (ncols (Gauss_Jordan A)) (Gauss_Jordan A)", "by (metis (mono_tags) Collect_empty_eq is_zero_row_upt_ncols not_zero_positions_row_a_def zero_row_a)"], ["proof (state)\nthis:\n  is_zero_row_upt_k a (ncols (Gauss_Jordan A)) (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a.\n               is_zero_row_upt_k a (ncols (Gauss_Jordan A))\n                (Gauss_Jordan A))", "show \"\\<not> (\\<forall>a. is_zero_row_upt_k a (ncols (Gauss_Jordan A)) (Gauss_Jordan A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a.\n               is_zero_row_upt_k a (ncols (Gauss_Jordan A))\n                (Gauss_Jordan A))", "by (metis False Gauss_Jordan_not_0 is_zero_row_upt_ncols vec_eq_iff zero_index)"], ["proof (state)\nthis:\n  \\<not> (\\<forall>a.\n             is_zero_row_upt_k a (ncols (Gauss_Jordan A)) (Gauss_Jordan A))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) < a\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "hence \"to_nat (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) < to_nat a\""], ["proof (prove)\nusing this:\n  (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) < a\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n    < mod_type_class.to_nat a", "using to_nat_mono"], ["proof (prove)\nusing this:\n  (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) < a\n  ?a < ?b \\<Longrightarrow>\n  mod_type_class.to_nat ?a < mod_type_class.to_nat ?b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n    < mod_type_class.to_nat a", "by fast"], ["proof (state)\nthis:\n  mod_type_class.to_nat (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n  < mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "hence rank_le_to_nat_a: \"rank A \\<le> to_nat a\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n  < mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. rank A \\<le> mod_type_class.to_nat a", "unfolding rank_eq_suc_to_nat_greatest[OF A_not_zero]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n  < mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1\n    \\<le> mod_type_class.to_nat a", "by simp"], ["proof (state)\nthis:\n  rank A \\<le> mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have \"to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) < to_nat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a))\n    < mod_type_class.to_nat a", "using con"], ["proof (prove)\nusing this:\n  (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n   then mod_type_class.to_nat\n         (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n        1\n   else 0)\n  \\<le> rank A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a))\n    < mod_type_class.to_nat a", "unfolding consistent_def"], ["proof (prove)\nusing this:\n  (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n   then mod_type_class.to_nat\n         (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n        1\n   else 0)\n  \\<le> rank A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a))\n    < mod_type_class.to_nat a", "unfolding if_P[OF True]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat\n   (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n  1\n  \\<le> rank A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a))\n    < mod_type_class.to_nat a", "using rank_le_to_nat_a"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat\n   (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n  1\n  \\<le> rank A\n  rank A \\<le> mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a))\n    < mod_type_class.to_nat a", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a))\n  < mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "hence \"(GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) < a\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat\n   (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a))\n  < mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) < a", "by (metis not_le to_nat_mono')"], ["proof (state)\nthis:\n  (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) < a\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "hence \"(P_Gauss_Jordan A *v b) $ a = 0\""], ["proof (prove)\nusing this:\n  (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) < a\n\ngoal (1 subgoal):\n 1. (P_Gauss_Jordan A *v b) $ a = (0::'a)", "using not_greater_Greatest"], ["proof (prove)\nusing this:\n  (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) < a\n  (GREATEST x. ?P x) < ?k \\<Longrightarrow> \\<not> ?P ?k\n\ngoal (1 subgoal):\n 1. (P_Gauss_Jordan A *v b) $ a = (0::'a)", "by blast"], ["proof (state)\nthis:\n  (P_Gauss_Jordan A *v b) $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P_Gauss_Jordan A *v b) $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "unfolding zero_row_a"], ["proof (prove)\nusing this:\n  (P_Gauss_Jordan A *v b) $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{}.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (P_Gauss_Jordan A *v b) $ a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (P_Gauss_Jordan A *v b) $ a\n\ngoal (1 subgoal):\n 1. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "case False"], ["proof (state)\nthis:\n  not_zero_positions_row_a \\<noteq> {}\n\ngoal (1 subgoal):\n 1. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "note not_empty=False"], ["proof (state)\nthis:\n  not_zero_positions_row_a \\<noteq> {}\n\ngoal (1 subgoal):\n 1. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have not_zero_positions_row_a_rw: \"not_zero_positions_row_a = {LEAST j. (Gauss_Jordan A) $ a $ j \\<noteq> 0} \\<union> (not_zero_positions_row_a - {LEAST j. (Gauss_Jordan A) $ a $ j \\<noteq> 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_zero_positions_row_a =\n    {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)} \\<union>\n    (not_zero_positions_row_a -\n     {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)})", "unfolding not_zero_positions_row_a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)} =\n    {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)} \\<union>\n    ({j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)} -\n     {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)})", "by (metis (mono_tags) Collect_cong False LeastI_ex bot_set_def empty_iff insert_Diff_single insert_absorb insert_is_Un mem_Collect_eq not_zero_positions_row_a_def)"], ["proof (state)\nthis:\n  not_zero_positions_row_a =\n  {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)} \\<union>\n  (not_zero_positions_row_a -\n   {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)})\n\ngoal (1 subgoal):\n 1. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have sum_zero': \"sum ?f (not_zero_positions_row_a - {LEAST j. (Gauss_Jordan A) $ a $ j \\<noteq> 0}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>not_zero_positions_row_a -\n                 {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (0::'a)", "by (rule sum.neutral, auto, metis is_zero_row_def' rref_Gauss_Jordan rref_condition4_explicit zero_neq_one)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>not_zero_positions_row_a -\n               {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have \"sum ?f (not_zero_positions_row_a) = sum ?f {LEAST j. (Gauss_Jordan A) $ a $ j \\<noteq> 0} + sum ?f (not_zero_positions_row_a - {LEAST j. (Gauss_Jordan A) $ a $ j \\<noteq> 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (\\<Sum>j\\<in>{LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) +\n    (\\<Sum>j\\<in>not_zero_positions_row_a -\n                 {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a)))", "by (subst not_zero_positions_row_a_rw, rule sum.union_disjoint[OF _ _ _], simp+)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (\\<Sum>j\\<in>{LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) +\n  (\\<Sum>j\\<in>not_zero_positions_row_a -\n               {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a)))\n\ngoal (1 subgoal):\n 1. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (\\<Sum>j\\<in>{LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) +\n  (\\<Sum>j\\<in>not_zero_positions_row_a -\n               {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a)))\n\ngoal (1 subgoal):\n 1. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have \"... = ?f (LEAST j. (Gauss_Jordan A) $ a $ j \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) +\n    (\\<Sum>j\\<in>not_zero_positions_row_a -\n                 {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a))", "using sum_zero'"], ["proof (prove)\nusing this:\n  (\\<Sum>j\\<in>not_zero_positions_row_a -\n               {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) +\n    (\\<Sum>j\\<in>not_zero_positions_row_a -\n                 {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a))", "by force"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) +\n  (\\<Sum>j\\<in>not_zero_positions_row_a -\n               {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  Gauss_Jordan A $ a $ (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n  (if \\<exists>i.\n         Gauss_Jordan A $ i $\n         (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n         (1::'a) \\<and>\n         (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n         (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n   then (P_Gauss_Jordan A *v b) $\n        (THE i.\n            Gauss_Jordan A $ i $\n            (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n            (1::'a))\n   else (0::'a))\n\ngoal (1 subgoal):\n 1. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) +\n  (\\<Sum>j\\<in>not_zero_positions_row_a -\n               {LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)}.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  Gauss_Jordan A $ a $ (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n  (if \\<exists>i.\n         Gauss_Jordan A $ i $\n         (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n         (1::'a) \\<and>\n         (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n         (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n   then (P_Gauss_Jordan A *v b) $\n        (THE i.\n            Gauss_Jordan A $ i $\n            (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n            (1::'a))\n   else (0::'a))\n\ngoal (1 subgoal):\n 1. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "have \"... = (P_Gauss_Jordan A *v b) $ a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "proof (cases \"\\<exists>i. (Gauss_Jordan A) $ i $ (LEAST j. (Gauss_Jordan A) $ a $ j \\<noteq> 0) = 1 \\<and> (LEAST j. (Gauss_Jordan A) $ a $ j \\<noteq> 0) = (LEAST n. (Gauss_Jordan A) $ i $ n \\<noteq> 0)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. \\<nexists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "case True"], ["proof (state)\nthis:\n  \\<exists>i.\n     Gauss_Jordan A $ i $\n     (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n     (1::'a) \\<and>\n     (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n     (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. \\<exists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. \\<nexists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "have A_least_eq_1: \"(Gauss_Jordan A) $ a $ (LEAST j. (Gauss_Jordan A) $ a $ j \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n    (1::'a)", "by (metis (mono_tags) empty_Collect_eq is_zero_row_def' not_empty not_zero_positions_row_a_def rref_Gauss_Jordan rref_condition2_explicit)"], ["proof (state)\nthis:\n  Gauss_Jordan A $ a $ (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n  (1::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. \\<nexists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "moreover"], ["proof (state)\nthis:\n  Gauss_Jordan A $ a $ (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n  (1::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. \\<nexists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "have \"(THE i. (Gauss_Jordan A) $ i $ (LEAST j. (Gauss_Jordan A) $ a $ j \\<noteq> 0) = 1) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE i.\n        Gauss_Jordan A $ i $\n        (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n        (1::'a)) =\n    a", "proof (rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n    (1::'a)\n 2. \\<And>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<Longrightarrow>\n       i = a", "show \"(Gauss_Jordan A) $ a $ (LEAST j. (Gauss_Jordan A) $ a $ j \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n    (1::'a)", "using A_least_eq_1"], ["proof (prove)\nusing this:\n  Gauss_Jordan A $ a $ (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n    (1::'a)", "."], ["proof (state)\nthis:\n  Gauss_Jordan A $ a $ (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<Longrightarrow>\n       i = a", "show \"\\<And>i. (Gauss_Jordan A) $ i $ (LEAST j. (Gauss_Jordan A) $ a $ j \\<noteq> 0) = 1 \\<Longrightarrow> i = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<Longrightarrow>\n       i = a", "by (metis calculation is_zero_row_def' rref_Gauss_Jordan rref_condition4_explicit zero_neq_one)"], ["proof (state)\nthis:\n  Gauss_Jordan A $ ?i $ (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n  (1::'a) \\<Longrightarrow>\n  ?i = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (THE i.\n      Gauss_Jordan A $ i $\n      (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n      (1::'a)) =\n  a\n\ngoal (2 subgoals):\n 1. \\<exists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a\n 2. \\<nexists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "ultimately"], ["proof (chain)\npicking this:\n  Gauss_Jordan A $ a $ (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n  (1::'a)\n  (THE i.\n      Gauss_Jordan A $ i $\n      (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n      (1::'a)) =\n  a", "show ?thesis"], ["proof (prove)\nusing this:\n  Gauss_Jordan A $ a $ (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n  (1::'a)\n  (THE i.\n      Gauss_Jordan A $ i $\n      (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n      (1::'a)) =\n  a\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "unfolding if_P[OF True]"], ["proof (prove)\nusing this:\n  Gauss_Jordan A $ a $ (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n  (1::'a)\n  (THE i.\n      Gauss_Jordan A $ i $\n      (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n      (1::'a)) =\n  a\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (P_Gauss_Jordan A *v b) $\n    (THE i.\n        Gauss_Jordan A $ i $\n        (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n        (1::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "by simp"], ["proof (state)\nthis:\n  Gauss_Jordan A $ a $ (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n  (if \\<exists>i.\n         Gauss_Jordan A $ i $\n         (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n         (1::'a) \\<and>\n         (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n         (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n   then (P_Gauss_Jordan A *v b) $\n        (THE i.\n            Gauss_Jordan A $ i $\n            (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n            (1::'a))\n   else (0::'a)) =\n  (P_Gauss_Jordan A *v b) $ a\n\ngoal (1 subgoal):\n 1. \\<nexists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "case False"], ["proof (state)\nthis:\n  \\<nexists>i.\n     Gauss_Jordan A $ i $\n     (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n     (1::'a) \\<and>\n     (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n     (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<nexists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "have \"is_zero_row a (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row a (Gauss_Jordan A)", "using False rref_Gauss_Jordan rref_condition2"], ["proof (prove)\nusing this:\n  \\<nexists>i.\n     Gauss_Jordan A $ i $\n     (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n     (1::'a) \\<and>\n     (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n     (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n  reduced_row_echelon_form (Gauss_Jordan ?A)\n  reduced_row_echelon_form ?A \\<Longrightarrow>\n  \\<forall>i.\n     \\<not> is_zero_row i ?A \\<longrightarrow>\n     ?A $ i $ (LEAST k. ?A $ i $ k \\<noteq> (0::?'a)) = (1::?'a)\n\ngoal (1 subgoal):\n 1. is_zero_row a (Gauss_Jordan A)", "by blast"], ["proof (state)\nthis:\n  is_zero_row a (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<nexists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "hence \"(P_Gauss_Jordan A *v b) $ a = 0\""], ["proof (prove)\nusing this:\n  is_zero_row a (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. (P_Gauss_Jordan A *v b) $ a = (0::'a)", "by (metis (mono_tags) IntI disj empty_iff insert_compr insert_is_Un is_zero_row_def' mem_Collect_eq not_zero_positions_row_a_rw zero_positions_row_a_def)"], ["proof (state)\nthis:\n  (P_Gauss_Jordan A *v b) $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<nexists>i.\n       Gauss_Jordan A $ i $\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (1::'a) \\<and>\n       (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n       (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P_Gauss_Jordan A *v b) $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (if \\<exists>i.\n           Gauss_Jordan A $ i $\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (1::'a) \\<and>\n           (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n           (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n     then (P_Gauss_Jordan A *v b) $\n          (THE i.\n              Gauss_Jordan A $ i $\n              (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n              (1::'a))\n     else (0::'a)) =\n    (P_Gauss_Jordan A *v b) $ a", "unfolding if_not_P[OF False]"], ["proof (prove)\nusing this:\n  (P_Gauss_Jordan A *v b) $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ a $\n    (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n    (0::'a) =\n    (P_Gauss_Jordan A *v b) $ a", "by fastforce"], ["proof (state)\nthis:\n  Gauss_Jordan A $ a $ (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n  (if \\<exists>i.\n         Gauss_Jordan A $ i $\n         (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n         (1::'a) \\<and>\n         (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n         (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n   then (P_Gauss_Jordan A *v b) $\n        (THE i.\n            Gauss_Jordan A $ i $\n            (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n            (1::'a))\n   else (0::'a)) =\n  (P_Gauss_Jordan A *v b) $ a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan A $ a $ (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) *\n  (if \\<exists>i.\n         Gauss_Jordan A $ i $\n         (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n         (1::'a) \\<and>\n         (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n         (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n   then (P_Gauss_Jordan A *v b) $\n        (THE i.\n            Gauss_Jordan A $ i $\n            (LEAST j. Gauss_Jordan A $ a $ j \\<noteq> (0::'a)) =\n            (1::'a))\n   else (0::'a)) =\n  (P_Gauss_Jordan A *v b) $ a\n\ngoal (1 subgoal):\n 1. not_zero_positions_row_a \\<noteq> {} \\<Longrightarrow>\n    (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (P_Gauss_Jordan A *v b) $ a", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (P_Gauss_Jordan A *v b) $ a\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>not_zero_positions_row_a.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "."], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (P_Gauss_Jordan A *v b) $ a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>not_zero_positions_row_a.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (P_Gauss_Jordan A *v b) $ a\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j\\<in>UNIV.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (P_Gauss_Jordan A *v b) $ a", "show \"sum ?f UNIV = (P_Gauss_Jordan A *v b) $ a\""], ["proof (prove)\nusing this:\n  (\\<Sum>j\\<in>UNIV.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (P_Gauss_Jordan A *v b) $ a\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV.\n       Gauss_Jordan A $ a $ j *\n       (if \\<exists>i.\n              Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n        then (P_Gauss_Jordan A *v b) $\n             (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n        else (0::'a))) =\n    (P_Gauss_Jordan A *v b) $ a", "."], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (P_Gauss_Jordan A *v b) $ a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV.\n     Gauss_Jordan A $ a $ j *\n     (if \\<exists>i.\n            Gauss_Jordan A $ i $ j = (1::'a) \\<and>\n            j = (LEAST n. Gauss_Jordan A $ i $ n \\<noteq> (0::'a))\n      then (P_Gauss_Jordan A *v b) $\n           (THE i. Gauss_Jordan A $ i $ j = (1::'a))\n      else (0::'a))) =\n  (P_Gauss_Jordan A *v b) $ a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_solution\n   (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b))\n   (Gauss_Jordan A) (P_Gauss_Jordan A *v b)\n\ngoal (1 subgoal):\n 1. is_solution\n     (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b)) A b", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_solution\n   (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b))\n   (Gauss_Jordan A) (P_Gauss_Jordan A *v b)\n\ngoal (1 subgoal):\n 1. is_solution\n     (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b)) A b", "apply (subst is_solution_solve_system)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution\n     (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b))\n     (Gauss_Jordan A) (P_Gauss_Jordan A *v b) \\<Longrightarrow>\n    is_solution\n     (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b))\n     (fst (solve_system A b)) (snd (solve_system A b))", "unfolding solve_system_def Let_def snd_conv fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution\n     (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b))\n     (Gauss_Jordan A) (P_Gauss_Jordan A *v b) \\<Longrightarrow>\n    is_solution\n     (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b))\n     (snd (Gauss_Jordan_PA A)) (fst (Gauss_Jordan_PA A) *v b)", "unfolding Gauss_Jordan_PA_eq P_Gauss_Jordan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution\n     (solve_consistent_rref (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b))\n     (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b) \\<Longrightarrow>\n    is_solution\n     (solve_consistent_rref (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b))\n     (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b)", "."], ["proof (state)\nthis:\n  is_solution\n   (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b)) A b\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary rank_ge_imp_consistent:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nassumes \"rank A \\<ge> (if (\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) then (to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1) else 0)\"\nshows \"consistent A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent A b", "using rank_ge_imp_is_solution assms"], ["proof (prove)\nusing this:\n  (if \\<exists>a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)\n   then mod_type_class.to_nat\n         (GREATEST a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)) +\n        1\n   else 0)\n  \\<le> rank ?A \\<Longrightarrow>\n  is_solution\n   (solve_consistent_rref (Gauss_Jordan ?A) (P_Gauss_Jordan ?A *v ?b)) ?A ?b\n  (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n   then mod_type_class.to_nat\n         (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n        1\n   else 0)\n  \\<le> rank A\n\ngoal (1 subgoal):\n 1. consistent A b", "unfolding consistent_def"], ["proof (prove)\nusing this:\n  (if \\<exists>a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)\n   then mod_type_class.to_nat\n         (GREATEST a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)) +\n        1\n   else 0)\n  \\<le> rank ?A \\<Longrightarrow>\n  is_solution\n   (solve_consistent_rref (Gauss_Jordan ?A) (P_Gauss_Jordan ?A *v ?b)) ?A ?b\n  (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n   then mod_type_class.to_nat\n         (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n        1\n   else 0)\n  \\<le> rank A\n\ngoal (1 subgoal):\n 1. \\<exists>x. is_solution x A b", "by auto"], ["", "lemma inconsistent_imp_rank_less:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes inc: \"inconsistent A b\"\n  shows \"rank A < (if (\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) then (to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A\n    < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n       then mod_type_class.to_nat\n             (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n            1\n       else 0)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> rank A\n           < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n              then mod_type_class.to_nat\n                    (GREATEST a.\n                        (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n                   1\n              else 0) \\<Longrightarrow>\n    False", "assume \"\\<not> rank A < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0 then to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1 else 0)\""], ["proof (state)\nthis:\n  \\<not> rank A\n         < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n            then mod_type_class.to_nat\n                  (GREATEST a.\n                      (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n                 1\n            else 0)\n\ngoal (1 subgoal):\n 1. \\<not> rank A\n           < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n              then mod_type_class.to_nat\n                    (GREATEST a.\n                        (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n                   1\n              else 0) \\<Longrightarrow>\n    False", "hence \"(if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0 then to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1 else 0) \\<le> rank A\""], ["proof (prove)\nusing this:\n  \\<not> rank A\n         < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n            then mod_type_class.to_nat\n                  (GREATEST a.\n                      (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n                 1\n            else 0)\n\ngoal (1 subgoal):\n 1. (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n     then mod_type_class.to_nat\n           (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n          1\n     else 0)\n    \\<le> rank A", "by simp"], ["proof (state)\nthis:\n  (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n   then mod_type_class.to_nat\n         (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n        1\n   else 0)\n  \\<le> rank A\n\ngoal (1 subgoal):\n 1. \\<not> rank A\n           < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n              then mod_type_class.to_nat\n                    (GREATEST a.\n                        (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n                   1\n              else 0) \\<Longrightarrow>\n    False", "hence \"consistent A b\""], ["proof (prove)\nusing this:\n  (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n   then mod_type_class.to_nat\n         (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n        1\n   else 0)\n  \\<le> rank A\n\ngoal (1 subgoal):\n 1. consistent A b", "using rank_ge_imp_consistent"], ["proof (prove)\nusing this:\n  (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n   then mod_type_class.to_nat\n         (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n        1\n   else 0)\n  \\<le> rank A\n  (if \\<exists>a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)\n   then mod_type_class.to_nat\n         (GREATEST a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)) +\n        1\n   else 0)\n  \\<le> rank ?A \\<Longrightarrow>\n  consistent ?A ?b\n\ngoal (1 subgoal):\n 1. consistent A b", "by auto"], ["proof (state)\nthis:\n  consistent A b\n\ngoal (1 subgoal):\n 1. \\<not> rank A\n           < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n              then mod_type_class.to_nat\n                    (GREATEST a.\n                        (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n                   1\n              else 0) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  consistent A b\n\ngoal (1 subgoal):\n 1. False", "using inc"], ["proof (prove)\nusing this:\n  consistent A b\n  inconsistent A b\n\ngoal (1 subgoal):\n 1. False", "unfolding inconsistent_def"], ["proof (prove)\nusing this:\n  consistent A b\n  \\<not> consistent A b\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_less_imp_inconsistent:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes inc: \"rank A < (if (\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) then (to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1) else 0)\"\n  shows \"inconsistent A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsistent A b", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> inconsistent A b \\<Longrightarrow> False", "define i where \"i = (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0)\""], ["proof (state)\nthis:\n  i = (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent A b \\<Longrightarrow> False", "define j where \"j = (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\""], ["proof (state)\nthis:\n  j = (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent A b \\<Longrightarrow> False", "assume \"\\<not> inconsistent A b\""], ["proof (state)\nthis:\n  \\<not> inconsistent A b\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent A b \\<Longrightarrow> False", "hence ex_solution: \"\\<exists>x. is_solution x A b\""], ["proof (prove)\nusing this:\n  \\<not> inconsistent A b\n\ngoal (1 subgoal):\n 1. \\<exists>x. is_solution x A b", "unfolding inconsistent_def consistent_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>x. is_solution x A b)\n\ngoal (1 subgoal):\n 1. \\<exists>x. is_solution x A b", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. is_solution x A b\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent A b \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>x. is_solution x A b", "obtain x where \"is_solution x A b\""], ["proof (prove)\nusing this:\n  \\<exists>x. is_solution x A b\n\ngoal (1 subgoal):\n 1. (\\<And>x. is_solution x A b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_solution x A b\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent A b \\<Longrightarrow> False", "hence is_solution_solve: \"is_solution x (Gauss_Jordan A) (P_Gauss_Jordan A *v b)\""], ["proof (prove)\nusing this:\n  is_solution x A b\n\ngoal (1 subgoal):\n 1. is_solution x (Gauss_Jordan A) (P_Gauss_Jordan A *v b)", "using is_solution_solve_system"], ["proof (prove)\nusing this:\n  is_solution x A b\n  is_solution ?x ?A ?b =\n  is_solution ?x (fst (solve_system ?A ?b)) (snd (solve_system ?A ?b))\n\ngoal (1 subgoal):\n 1. is_solution x (Gauss_Jordan A) (P_Gauss_Jordan A *v b)", "by (metis Gauss_Jordan_PA_eq P_Gauss_Jordan_def fst_conv snd_conv solve_system_def)"], ["proof (state)\nthis:\n  is_solution x (Gauss_Jordan A) (P_Gauss_Jordan A *v b)\n\ngoal (1 subgoal):\n 1. \\<not> inconsistent A b \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"A=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = 0 \\<Longrightarrow> False\n 2. A \\<noteq> 0 \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  A = 0\n\ngoal (2 subgoals):\n 1. A = 0 \\<Longrightarrow> False\n 2. A \\<noteq> 0 \\<Longrightarrow> False", "hence rank_eq_0: \"rank A = 0\""], ["proof (prove)\nusing this:\n  A = 0\n\ngoal (1 subgoal):\n 1. rank A = 0", "using rank_0"], ["proof (prove)\nusing this:\n  A = 0\n  rank 0 = 0\n\ngoal (1 subgoal):\n 1. rank A = 0", "by simp"], ["proof (state)\nthis:\n  rank A = 0\n\ngoal (2 subgoals):\n 1. A = 0 \\<Longrightarrow> False\n 2. A \\<noteq> 0 \\<Longrightarrow> False", "hence exists_not_0:\"(\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  rank A = 0\n\ngoal (1 subgoal):\n 1. \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)", "using inc"], ["proof (prove)\nusing this:\n  rank A = 0\n  rank A\n  < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n     then mod_type_class.to_nat\n           (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n          1\n     else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)", "unfolding inconsistent"], ["proof (prove)\nusing this:\n  rank A = 0\n  rank A\n  < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n     then mod_type_class.to_nat\n           (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n          1\n     else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)", "using to_nat_plus_1_set[of \"(GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0)\"]"], ["proof (prove)\nusing this:\n  rank A = 0\n  rank A\n  < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n     then mod_type_class.to_nat\n           (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n          1\n     else 0)\n  mod_type_class.to_nat\n   (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n  1\n  \\<in> {1..<CARD('rows) + 1}\n\ngoal (1 subgoal):\n 1. \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)", "by presburger"], ["proof (state)\nthis:\n  \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A = 0 \\<Longrightarrow> False\n 2. A \\<noteq> 0 \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using True \\<open>is_solution x A b\\<close> exists_not_0 is_solution_def"], ["proof (prove)\nusing this:\n  A = 0\n  is_solution x A b\n  \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n  is_solution ?x ?A ?b = (?A *v ?x = ?b)\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> False", "have j_less_i: \"j<i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. j < i", "have rank_less_greatest_i: \"rank A < to_nat i + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A < mod_type_class.to_nat i + 1", "using inc"], ["proof (prove)\nusing this:\n  rank A\n  < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n     then mod_type_class.to_nat\n           (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n          1\n     else 0)\n\ngoal (1 subgoal):\n 1. rank A < mod_type_class.to_nat i + 1", "unfolding i_def inconsistent"], ["proof (prove)\nusing this:\n  rank A\n  < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n     then mod_type_class.to_nat\n           (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n          1\n     else 0)\n\ngoal (1 subgoal):\n 1. rank A\n    < mod_type_class.to_nat\n       (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n      1", "by presburger"], ["proof (state)\nthis:\n  rank A < mod_type_class.to_nat i + 1\n\ngoal (1 subgoal):\n 1. j < i", "moreover"], ["proof (state)\nthis:\n  rank A < mod_type_class.to_nat i + 1\n\ngoal (1 subgoal):\n 1. j < i", "have rank_eq_greatest_A: \"rank A = to_nat j + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = mod_type_class.to_nat j + 1", "unfolding j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "by (rule rank_eq_suc_to_nat_greatest[OF False])"], ["proof (state)\nthis:\n  rank A = mod_type_class.to_nat j + 1\n\ngoal (1 subgoal):\n 1. j < i", "ultimately"], ["proof (chain)\npicking this:\n  rank A < mod_type_class.to_nat i + 1\n  rank A = mod_type_class.to_nat j + 1", "have \"to_nat j + 1 < to_nat i + 1\""], ["proof (prove)\nusing this:\n  rank A < mod_type_class.to_nat i + 1\n  rank A = mod_type_class.to_nat j + 1\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j + 1 < mod_type_class.to_nat i + 1", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat j + 1 < mod_type_class.to_nat i + 1\n\ngoal (1 subgoal):\n 1. j < i", "hence \"to_nat j < to_nat i\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j + 1 < mod_type_class.to_nat i + 1\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j < mod_type_class.to_nat i", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. j < i", "thus \"j<i\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. j < i", "by (metis (full_types) not_le to_nat_mono')"], ["proof (state)\nthis:\n  j < i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> False", "have is_zero_i: \"is_zero_row i (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row i (Gauss_Jordan A)", "by (metis (full_types) j_def j_less_i not_greater_Greatest)"], ["proof (state)\nthis:\n  is_zero_row i (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> False", "have \"(Gauss_Jordan A *v x) $ i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Gauss_Jordan A *v x) $ i = (0::'a)", "proof (unfold matrix_vector_mult_def, auto, rule sum.neutral,clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> UNIV \\<Longrightarrow>\n       Gauss_Jordan A $ i $ xa * x $ xa = (0::'a)", "fix a::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> UNIV \\<Longrightarrow>\n       Gauss_Jordan A $ i $ xa * x $ xa = (0::'a)", "show \"Gauss_Jordan A $ i $ a * x $ a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ a * x $ a = (0::'a)", "using is_zero_i"], ["proof (prove)\nusing this:\n  is_zero_row i (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ a * x $ a = (0::'a)", "unfolding is_zero_row_def'"], ["proof (prove)\nusing this:\n  \\<forall>j. Gauss_Jordan A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i $ a * x $ a = (0::'a)", "by simp"], ["proof (state)\nthis:\n  Gauss_Jordan A $ i $ a * x $ a = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Gauss_Jordan A *v x) $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (Gauss_Jordan A *v x) $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> False", "have \"(Gauss_Jordan A *v x) $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Gauss_Jordan A *v x) $ i \\<noteq> (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Gauss_Jordan A *v x) $ i \\<noteq> (0::'a)", "have \"Gauss_Jordan A *v x = P_Gauss_Jordan A *v b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A *v x = P_Gauss_Jordan A *v b", "using is_solution_def is_solution_solve"], ["proof (prove)\nusing this:\n  is_solution ?x ?A ?b = (?A *v ?x = ?b)\n  is_solution x (Gauss_Jordan A) (P_Gauss_Jordan A *v b)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A *v x = P_Gauss_Jordan A *v b", "by blast"], ["proof (state)\nthis:\n  Gauss_Jordan A *v x = P_Gauss_Jordan A *v b\n\ngoal (1 subgoal):\n 1. (Gauss_Jordan A *v x) $ i \\<noteq> (0::'a)", "also"], ["proof (state)\nthis:\n  Gauss_Jordan A *v x = P_Gauss_Jordan A *v b\n\ngoal (1 subgoal):\n 1. (Gauss_Jordan A *v x) $ i \\<noteq> (0::'a)", "have \"... $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P_Gauss_Jordan A *v b) $ i \\<noteq> (0::'a)", "unfolding i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P_Gauss_Jordan A *v b) $\n    (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "proof (rule GreatestI_ex)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. (P_Gauss_Jordan A *v b) $ x \\<noteq> (0::'a)", "show \"\\<exists>x. (P_Gauss_Jordan A *v b) $ x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. (P_Gauss_Jordan A *v b) $ x \\<noteq> (0::'a)", "using inc"], ["proof (prove)\nusing this:\n  rank A\n  < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n     then mod_type_class.to_nat\n           (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n          1\n     else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>x. (P_Gauss_Jordan A *v b) $ x \\<noteq> (0::'a)", "unfolding i_def inconsistent"], ["proof (prove)\nusing this:\n  rank A\n  < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n     then mod_type_class.to_nat\n           (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n          1\n     else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>x. (P_Gauss_Jordan A *v b) $ x \\<noteq> (0::'a)", "by presburger"], ["proof (state)\nthis:\n  \\<exists>x. (P_Gauss_Jordan A *v b) $ x \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (P_Gauss_Jordan A *v b) $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (Gauss_Jordan A *v x) $ i \\<noteq> (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (Gauss_Jordan A *v x) $ i \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Gauss_Jordan A *v x) $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (Gauss_Jordan A *v x) $ i \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  (Gauss_Jordan A *v x) $ i \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Gauss_Jordan A *v x) $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (Gauss_Jordan A *v x) $ i = (0::'a)\n  (Gauss_Jordan A *v x) $ i \\<noteq> (0::'a)", "show \"False\""], ["proof (prove)\nusing this:\n  (Gauss_Jordan A *v x) $ i = (0::'a)\n  (Gauss_Jordan A *v x) $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary consistent_imp_rank_ge:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes \"consistent A b\"\n  shows \"rank A \\<ge> (if (\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) then (to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n     then mod_type_class.to_nat\n           (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n          1\n     else 0)\n    \\<le> rank A", "using rank_less_imp_inconsistent"], ["proof (prove)\nusing this:\n  rank ?A\n  < (if \\<exists>a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)\n     then mod_type_class.to_nat\n           (GREATEST a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)) +\n          1\n     else 0) \\<Longrightarrow>\n  inconsistent ?A ?b\n\ngoal (1 subgoal):\n 1. (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n     then mod_type_class.to_nat\n           (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n          1\n     else 0)\n    \\<le> rank A", "by (metis assms inconsistent_def not_less)"], ["", "lemma inconsistent_eq_rank_less:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"inconsistent A b = (rank A < (if (\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) \n                                            then (to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1) else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsistent A b =\n    (rank A\n     < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n        then mod_type_class.to_nat\n              (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n             1\n        else 0))", "using inconsistent_imp_rank_less rank_less_imp_inconsistent"], ["proof (prove)\nusing this:\n  inconsistent ?A ?b \\<Longrightarrow>\n  rank ?A\n  < (if \\<exists>a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)\n     then mod_type_class.to_nat\n           (GREATEST a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)) +\n          1\n     else 0)\n  rank ?A\n  < (if \\<exists>a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)\n     then mod_type_class.to_nat\n           (GREATEST a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)) +\n          1\n     else 0) \\<Longrightarrow>\n  inconsistent ?A ?b\n\ngoal (1 subgoal):\n 1. inconsistent A b =\n    (rank A\n     < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n        then mod_type_class.to_nat\n              (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n             1\n        else 0))", "by blast"], ["", "lemma consistent_eq_rank_ge:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"consistent A b = (rank A \\<ge> (if (\\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) \n                                            then (to_nat (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> 0) + 1) else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent A b =\n    ((if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> rank A)", "using consistent_imp_rank_ge rank_ge_imp_consistent"], ["proof (prove)\nusing this:\n  consistent ?A ?b \\<Longrightarrow>\n  (if \\<exists>a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)\n   then mod_type_class.to_nat\n         (GREATEST a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)) +\n        1\n   else 0)\n  \\<le> rank ?A\n  (if \\<exists>a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)\n   then mod_type_class.to_nat\n         (GREATEST a. (P_Gauss_Jordan ?A *v ?b) $ a \\<noteq> (0::?'a)) +\n        1\n   else 0)\n  \\<le> rank ?A \\<Longrightarrow>\n  consistent ?A ?b\n\ngoal (1 subgoal):\n 1. consistent A b =\n    ((if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> rank A)", "by blast"], ["", "corollary consistent_imp_is_solution:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes \"consistent A b\"\n  shows \"is_solution (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b)) A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution\n     (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b)) A b", "by (rule rank_ge_imp_is_solution[OF assms[unfolded consistent_eq_rank_ge]])"], ["", "corollary consistent_imp_is_solution':\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes \"consistent A b\"\n  shows \"is_solution (solve_consistent_rref (fst (solve_system A b)) (snd (solve_system A b))) A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution\n     (solve_consistent_rref (fst (solve_system A b))\n       (snd (solve_system A b)))\n     A b", "using consistent_imp_is_solution[OF assms]"], ["proof (prove)\nusing this:\n  is_solution\n   (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b)) A b\n\ngoal (1 subgoal):\n 1. is_solution\n     (solve_consistent_rref (fst (solve_system A b))\n       (snd (solve_system A b)))\n     A b", "unfolding solve_system_def Let_def snd_conv fst_conv"], ["proof (prove)\nusing this:\n  is_solution\n   (solve_consistent_rref (Gauss_Jordan A) (P_Gauss_Jordan A *v b)) A b\n\ngoal (1 subgoal):\n 1. is_solution\n     (solve_consistent_rref (snd (Gauss_Jordan_PA A))\n       (fst (Gauss_Jordan_PA A) *v b))\n     A b", "unfolding Gauss_Jordan_PA_eq P_Gauss_Jordan_def"], ["proof (prove)\nusing this:\n  is_solution\n   (solve_consistent_rref (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b)) A\n   b\n\ngoal (1 subgoal):\n 1. is_solution\n     (solve_consistent_rref (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b))\n     A b", "."], ["", "text\\<open>Code equations optimized using Lets\\<close>"], ["", "lemma inconsistent_eq_rank_less_code[code]:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"inconsistent A b = (let GJ_P=Gauss_Jordan_PA A; \n                                P_mult_b = (fst(GJ_P) *v b);\n                                rank_A = (if A = 0 then 0 else to_nat (GREATEST a. row a (snd GJ_P) \\<noteq> 0) + 1)  in (rank_A < (if (\\<exists>a. P_mult_b $ a \\<noteq> 0) \n                                            then (to_nat (GREATEST a. P_mult_b $ a \\<noteq> 0) + 1) else 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsistent A b =\n    (let GJ_P = Gauss_Jordan_PA A; P_mult_b = fst GJ_P *v b;\n         rank_A =\n           if A = 0 then 0\n           else mod_type_class.to_nat\n                 (GREATEST a. row a (snd GJ_P) \\<noteq> 0) +\n                1\n     in rank_A\n        < (if \\<exists>a. P_mult_b $ a \\<noteq> (0::'a)\n           then mod_type_class.to_nat\n                 (GREATEST a. P_mult_b $ a \\<noteq> (0::'a)) +\n                1\n           else 0))", "unfolding inconsistent_eq_rank_less Let_def rank_Gauss_Jordan_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if A = 0 then 0\n      else mod_type_class.to_nat\n            (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n           1)\n     < (if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n        then mod_type_class.to_nat\n              (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n             1\n        else 0)) =\n    ((if A = 0 then 0\n      else mod_type_class.to_nat\n            (GREATEST a. row a (snd (Gauss_Jordan_PA A)) \\<noteq> 0) +\n           1)\n     < (if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n        then mod_type_class.to_nat\n              (GREATEST a.\n                  (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n             1\n        else 0))", "unfolding Gauss_Jordan_PA_eq P_Gauss_Jordan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if A = 0 then 0\n      else mod_type_class.to_nat\n            (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n           1)\n     < (if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n        then mod_type_class.to_nat\n              (GREATEST a.\n                  (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n             1\n        else 0)) =\n    ((if A = 0 then 0\n      else mod_type_class.to_nat\n            (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n           1)\n     < (if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n        then mod_type_class.to_nat\n              (GREATEST a.\n                  (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n             1\n        else 0))", ".."], ["", "lemma consistent_eq_rank_ge_code[code]:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nshows \"consistent A b = (let GJ_P=Gauss_Jordan_PA A; \n                              P_mult_b = (fst(GJ_P) *v b);\n                              rank_A = (if A = 0 then 0 else to_nat (GREATEST a. row a (snd GJ_P) \\<noteq> 0) + 1) in (rank_A \\<ge> (if (\\<exists>a. P_mult_b $ a \\<noteq> 0) \n                                            then (to_nat (GREATEST a. P_mult_b $ a \\<noteq> 0) + 1) else 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent A b =\n    (let GJ_P = Gauss_Jordan_PA A; P_mult_b = fst GJ_P *v b\n     in Let (if A = 0 then 0\n             else mod_type_class.to_nat\n                   (GREATEST a. row a (snd GJ_P) \\<noteq> 0) +\n                  1)\n         ((\\<le>)\n           (if \\<exists>a. P_mult_b $ a \\<noteq> (0::'a)\n            then mod_type_class.to_nat\n                  (GREATEST a. P_mult_b $ a \\<noteq> (0::'a)) +\n                 1\n            else 0)))", "unfolding consistent_eq_rank_ge Let_def rank_Gauss_Jordan_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if \\<exists>a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a. (P_Gauss_Jordan A *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> (if A = 0 then 0\n            else mod_type_class.to_nat\n                  (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n                 1)) =\n    ((if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a.\n                (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> (if A = 0 then 0\n            else mod_type_class.to_nat\n                  (GREATEST a. row a (snd (Gauss_Jordan_PA A)) \\<noteq> 0) +\n                 1))", "unfolding Gauss_Jordan_PA_eq P_Gauss_Jordan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a.\n                (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> (if A = 0 then 0\n            else mod_type_class.to_nat\n                  (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n                 1)) =\n    ((if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a.\n                (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> (if A = 0 then 0\n            else mod_type_class.to_nat\n                  (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n                 1))", ".."], ["", "subsection\\<open>Solution set of a system of equations. Dependent and independent systems.\\<close>"], ["", "definition solution_set where \"solution_set A b = {x. is_solution x A b}\""], ["", "lemma null_space_eq_solution_set: \nshows \"null_space A = solution_set A 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null_space A = solution_set A 0", "unfolding null_space_def solution_set_def is_solution_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. A *v x = 0} = {x. A *v x = 0}", ".."], ["", "corollary dim_solution_set_homogeneous_eq_dim_null_space[code_unfold]:\nshows \"vec.dim (solution_set A 0) = vec.dim (null_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (solution_set A 0) = vec.dim (null_space A)", "using null_space_eq_solution_set[of A]"], ["proof (prove)\nusing this:\n  null_space A = solution_set A 0\n\ngoal (1 subgoal):\n 1. vec.dim (solution_set A 0) = vec.dim (null_space A)", "by simp"], ["", "lemma zero_is_solution_homogeneous_system:\nshows \"0 \\<in> (solution_set A 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> solution_set A 0", "unfolding solution_set_def is_solution_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {x. A *v x = 0}", "using matrix_vector_mult_0_right"], ["proof (prove)\nusing this:\n  ?A *v 0 = 0\n\ngoal (1 subgoal):\n 1. 0 \\<in> {x. A *v x = 0}", "by fast"], ["", "lemma homogeneous_solution_set_subspace:\nfixes A::\"'a::{field}^'n^'rows\"\nshows \"vec.subspace (solution_set A 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.subspace (solution_set A 0)", "using subspace_null_space[of A]"], ["proof (prove)\nusing this:\n  vec.subspace (null_space A)\n\ngoal (1 subgoal):\n 1. vec.subspace (solution_set A 0)", "unfolding null_space_eq_solution_set"], ["proof (prove)\nusing this:\n  vec.subspace (solution_set A 0)\n\ngoal (1 subgoal):\n 1. vec.subspace (solution_set A 0)", "."], ["", "lemma solution_set_rel:\nfixes A::\"'a::{field}^'n^'rows\"\nassumes p: \"is_solution p A b\"\nshows \"solution_set A b = {p} + (solution_set A 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution_set A b = {p} + solution_set A 0", "proof (unfold set_plus_def, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> solution_set A b \\<Longrightarrow>\n       \\<exists>b\\<in>solution_set A 0. x = p + b\n 2. \\<And>ba.\n       ba \\<in> solution_set A 0 \\<Longrightarrow>\n       p + ba \\<in> solution_set A b", "fix ba"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> solution_set A b \\<Longrightarrow>\n       \\<exists>b\\<in>solution_set A 0. x = p + b\n 2. \\<And>ba.\n       ba \\<in> solution_set A 0 \\<Longrightarrow>\n       p + ba \\<in> solution_set A b", "assume ba: \"ba \\<in> solution_set A 0\""], ["proof (state)\nthis:\n  ba \\<in> solution_set A 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> solution_set A b \\<Longrightarrow>\n       \\<exists>b\\<in>solution_set A 0. x = p + b\n 2. \\<And>ba.\n       ba \\<in> solution_set A 0 \\<Longrightarrow>\n       p + ba \\<in> solution_set A b", "have \"A *v (p + ba) = (A *v p) + (A *v ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v (p + ba) = A *v p + A *v ba", "unfolding matrix_vector_right_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v p + A *v ba = A *v p + A *v ba", ".."], ["proof (state)\nthis:\n  A *v (p + ba) = A *v p + A *v ba\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> solution_set A b \\<Longrightarrow>\n       \\<exists>b\\<in>solution_set A 0. x = p + b\n 2. \\<And>ba.\n       ba \\<in> solution_set A 0 \\<Longrightarrow>\n       p + ba \\<in> solution_set A b", "also"], ["proof (state)\nthis:\n  A *v (p + ba) = A *v p + A *v ba\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> solution_set A b \\<Longrightarrow>\n       \\<exists>b\\<in>solution_set A 0. x = p + b\n 2. \\<And>ba.\n       ba \\<in> solution_set A 0 \\<Longrightarrow>\n       p + ba \\<in> solution_set A b", "have \"... = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v p + A *v ba = b", "using p ba"], ["proof (prove)\nusing this:\n  is_solution p A b\n  ba \\<in> solution_set A 0\n\ngoal (1 subgoal):\n 1. A *v p + A *v ba = b", "unfolding solution_set_def is_solution_def"], ["proof (prove)\nusing this:\n  A *v p = b\n  ba \\<in> {x. A *v x = 0}\n\ngoal (1 subgoal):\n 1. A *v p + A *v ba = b", "by simp"], ["proof (state)\nthis:\n  A *v p + A *v ba = b\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> solution_set A b \\<Longrightarrow>\n       \\<exists>b\\<in>solution_set A 0. x = p + b\n 2. \\<And>ba.\n       ba \\<in> solution_set A 0 \\<Longrightarrow>\n       p + ba \\<in> solution_set A b", "finally"], ["proof (chain)\npicking this:\n  A *v (p + ba) = b", "show \"p + ba \\<in> solution_set A b\""], ["proof (prove)\nusing this:\n  A *v (p + ba) = b\n\ngoal (1 subgoal):\n 1. p + ba \\<in> solution_set A b", "unfolding solution_set_def is_solution_def"], ["proof (prove)\nusing this:\n  A *v (p + ba) = b\n\ngoal (1 subgoal):\n 1. p + ba \\<in> {x. A *v x = b}", "by simp"], ["proof (state)\nthis:\n  p + ba \\<in> solution_set A b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> solution_set A b \\<Longrightarrow>\n       \\<exists>b\\<in>solution_set A 0. x = p + b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> solution_set A b \\<Longrightarrow>\n       \\<exists>b\\<in>solution_set A 0. x = p + b", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> solution_set A b \\<Longrightarrow>\n       \\<exists>b\\<in>solution_set A 0. x = p + b", "assume x: \"x \\<in> solution_set A b\""], ["proof (state)\nthis:\n  x \\<in> solution_set A b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> solution_set A b \\<Longrightarrow>\n       \\<exists>b\\<in>solution_set A 0. x = p + b", "show \"\\<exists>b\\<in>solution_set A 0. x = p + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b\\<in>solution_set A 0. x = p + b", "proof (rule bexI[of _ \"x-p\"], simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. x - p \\<in> solution_set A 0", "have \"A *v (x - p) = (A *v x) - (A *v p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v (x - p) = A *v x - A *v p", "by (metis (no_types) add_diff_cancel diff_add_cancel matrix_vector_right_distrib)"], ["proof (state)\nthis:\n  A *v (x - p) = A *v x - A *v p\n\ngoal (1 subgoal):\n 1. x - p \\<in> solution_set A 0", "also"], ["proof (state)\nthis:\n  A *v (x - p) = A *v x - A *v p\n\ngoal (1 subgoal):\n 1. x - p \\<in> solution_set A 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v x - A *v p = 0", "using x p"], ["proof (prove)\nusing this:\n  x \\<in> solution_set A b\n  is_solution p A b\n\ngoal (1 subgoal):\n 1. A *v x - A *v p = 0", "unfolding solution_set_def is_solution_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. A *v x = b}\n  A *v p = b\n\ngoal (1 subgoal):\n 1. A *v x - A *v p = 0", "by simp"], ["proof (state)\nthis:\n  A *v x - A *v p = 0\n\ngoal (1 subgoal):\n 1. x - p \\<in> solution_set A 0", "finally"], ["proof (chain)\npicking this:\n  A *v (x - p) = 0", "show  \"x - p \\<in> solution_set A 0\""], ["proof (prove)\nusing this:\n  A *v (x - p) = 0\n\ngoal (1 subgoal):\n 1. x - p \\<in> solution_set A 0", "unfolding solution_set_def is_solution_def"], ["proof (prove)\nusing this:\n  A *v (x - p) = 0\n\ngoal (1 subgoal):\n 1. x - p \\<in> {x. A *v x = 0}", "by simp"], ["proof (state)\nthis:\n  x - p \\<in> solution_set A 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>b\\<in>solution_set A 0. x = p + b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma independent_and_consistent_imp_uniqueness_solution:\nfixes A::\"'a::{field}^'n::{mod_type}^'rows::{mod_type}\"\nassumes dim_0: \"vec.dim (solution_set A 0) = 0\"\nand con: \"consistent A b\"\nshows \"\\<exists>!x. is_solution x A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. is_solution x A b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!x. is_solution x A b", "obtain p where p: \"is_solution p A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p. is_solution p A b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using con"], ["proof (prove)\nusing this:\n  consistent A b\n\ngoal (1 subgoal):\n 1. (\\<And>p. is_solution p A b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding consistent_def"], ["proof (prove)\nusing this:\n  \\<exists>x. is_solution x A b\n\ngoal (1 subgoal):\n 1. (\\<And>p. is_solution p A b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_solution p A b\n\ngoal (1 subgoal):\n 1. \\<exists>!x. is_solution x A b", "have solution_set_0: \"solution_set A 0 = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution_set A 0 = {0}", "using vec.dim_zero_eq[OF dim_0] zero_is_solution_homogeneous_system"], ["proof (prove)\nusing this:\n  solution_set A 0 = {} \\<or> solution_set A 0 = {0}\n  0 \\<in> solution_set ?A 0\n\ngoal (1 subgoal):\n 1. solution_set A 0 = {0}", "by blast"], ["proof (state)\nthis:\n  solution_set A 0 = {0}\n\ngoal (1 subgoal):\n 1. \\<exists>!x. is_solution x A b", "show \"\\<exists>!x. is_solution x A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. is_solution x A b", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. is_solution x A b\n 2. \\<And>x y.\n       \\<lbrakk>is_solution x A b; is_solution y A b\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"\\<exists>x. is_solution x A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. is_solution x A b", "using p"], ["proof (prove)\nusing this:\n  is_solution p A b\n\ngoal (1 subgoal):\n 1. \\<exists>x. is_solution x A b", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. is_solution x A b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_solution x A b; is_solution y A b\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_solution x A b; is_solution y A b\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume x: \"is_solution x A b\" and y: \"is_solution y A b\""], ["proof (state)\nthis:\n  is_solution x A b\n  is_solution y A b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_solution x A b; is_solution y A b\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"solution_set A b = {p} + (solution_set A 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution_set A b = {p} + solution_set A 0", "unfolding solution_set_rel[OF p]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p} + solution_set A 0 = {p} + solution_set A 0", ".."], ["proof (state)\nthis:\n  solution_set A b = {p} + solution_set A 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_solution x A b; is_solution y A b\\<rbrakk>\n       \\<Longrightarrow> x = y", "also"], ["proof (state)\nthis:\n  solution_set A b = {p} + solution_set A 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_solution x A b; is_solution y A b\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"... = {p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p} + solution_set A 0 = {p}", "unfolding solution_set_0 set_plus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {c. \\<exists>a\\<in>{p}. \\<exists>b\\<in>{0}. c = a + b} = {p}", "by force"], ["proof (state)\nthis:\n  {p} + solution_set A 0 = {p}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_solution x A b; is_solution y A b\\<rbrakk>\n       \\<Longrightarrow> x = y", "finally"], ["proof (chain)\npicking this:\n  solution_set A b = {p}", "show \"x = y\""], ["proof (prove)\nusing this:\n  solution_set A b = {p}\n\ngoal (1 subgoal):\n 1. x = y", "using x y"], ["proof (prove)\nusing this:\n  solution_set A b = {p}\n  is_solution x A b\n  is_solution y A b\n\ngoal (1 subgoal):\n 1. x = y", "unfolding solution_set_def"], ["proof (prove)\nusing this:\n  {x. is_solution x A b} = {p}\n  is_solution x A b\n  is_solution y A b\n\ngoal (1 subgoal):\n 1. x = y", "by (metis (full_types) mem_Collect_eq singleton_iff)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!x. is_solution x A b\n\ngoal:\nNo subgoals!", "qed"], ["", "(*TODO: Maybe move. Until Isabelle2013-2 this lemma was part of the library.*)"], ["", "lemma card_1_exists: \"card s = 1 \\<longleftrightarrow> (\\<exists>!x. x \\<in> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card s = 1) = (\\<exists>!x. x \\<in> s)", "unfolding One_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (card s = Suc 0) = (\\<exists>!x. x \\<in> s)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. card s = Suc 0 \\<Longrightarrow> \\<exists>!x. x \\<in> s\n 2. \\<exists>!x. x \\<in> s \\<Longrightarrow> card s = Suc 0", "apply(drule card_eq_SucD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>b B.\n       s = insert b B \\<and>\n       b \\<notin> B \\<and>\n       card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {}) \\<Longrightarrow>\n    \\<exists>!x. x \\<in> s\n 2. \\<exists>!x. x \\<in> s \\<Longrightarrow> card s = Suc 0", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>!x. x \\<in> s \\<Longrightarrow> card s = Suc 0\n 2. \\<exists>b B.\n       s = insert b B \\<and>\n       b \\<notin> B \\<and>\n       card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {}) \\<Longrightarrow>\n    \\<exists>!x. x \\<in> s", "apply(erule ex1E)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> s;\n        \\<forall>y. y \\<in> s \\<longrightarrow> y = x\\<rbrakk>\n       \\<Longrightarrow> card s = Suc 0\n 2. \\<exists>b B.\n       s = insert b B \\<and>\n       b \\<notin> B \\<and>\n       card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {}) \\<Longrightarrow>\n    \\<exists>!x. x \\<in> s", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> s;\n        \\<forall>y. y \\<in> s \\<longrightarrow> y = x\\<rbrakk>\n       \\<Longrightarrow> card s = Suc 0\n 2. \\<exists>b B.\n       s = insert b B \\<and>\n       b \\<notin> B \\<and>\n       card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {}) \\<Longrightarrow>\n    \\<exists>!x. x \\<in> s", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> s;\n        \\<forall>y. y \\<in> s \\<longrightarrow> y = x\\<rbrakk>\n       \\<Longrightarrow> card s = Suc 0\n 2. \\<exists>b B.\n       s = insert b B \\<and>\n       b \\<notin> B \\<and>\n       card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {}) \\<Longrightarrow>\n    \\<exists>!x. x \\<in> s", "assume as:\"x \\<in> s\" \"\\<forall>y. y \\<in> s \\<longrightarrow> y = x\""], ["proof (state)\nthis:\n  x \\<in> s\n  \\<forall>y. y \\<in> s \\<longrightarrow> y = x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> s;\n        \\<forall>y. y \\<in> s \\<longrightarrow> y = x\\<rbrakk>\n       \\<Longrightarrow> card s = Suc 0\n 2. \\<exists>b B.\n       s = insert b B \\<and>\n       b \\<notin> B \\<and>\n       card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {}) \\<Longrightarrow>\n    \\<exists>!x. x \\<in> s", "have *:\"s = insert x {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = {x}", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = {x}", "apply(rule,rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> s \\<Longrightarrow> xa \\<in> {x}\n 2. {x} \\<subseteq> s", "unfolding singleton_iff"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> s \\<Longrightarrow> xa = x\n 2. {x} \\<subseteq> s", "apply(rule as(2)[rule_format])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> s \\<Longrightarrow> x \\<in> s\n 2. {x} \\<subseteq> s", "using as(1)"], ["proof (prove)\nusing this:\n  x \\<in> s\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> s \\<Longrightarrow> x \\<in> s\n 2. {x} \\<subseteq> s", "by auto"], ["proof (state)\nthis:\n  s = {x}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> s;\n        \\<forall>y. y \\<in> s \\<longrightarrow> y = x\\<rbrakk>\n       \\<Longrightarrow> card s = Suc 0\n 2. \\<exists>b B.\n       s = insert b B \\<and>\n       b \\<notin> B \\<and>\n       card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {}) \\<Longrightarrow>\n    \\<exists>!x. x \\<in> s", "show \"card s = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card s = Suc 0", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x} = Suc 0", "using card.insert_remove"], ["proof (prove)\nusing this:\n  finite ?A \\<Longrightarrow> card (insert ?x ?A) = Suc (card (?A - {?x}))\n\ngoal (1 subgoal):\n 1. card {x} = Suc 0", "by auto"], ["proof (state)\nthis:\n  card s = Suc 0\n\ngoal (1 subgoal):\n 1. \\<exists>b B.\n       s = insert b B \\<and>\n       b \\<notin> B \\<and>\n       card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {}) \\<Longrightarrow>\n    \\<exists>!x. x \\<in> s", "qed auto"], ["", "corollary independent_and_consistent_imp_card_1:\nfixes A::\"'a::{field}^'n::{mod_type}^'rows::{mod_type}\"\nassumes dim_0: \"vec.dim (solution_set A 0) = 0\"\nand con: \"consistent A b\"\nshows \"card (solution_set A b) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (solution_set A b) = 1", "using independent_and_consistent_imp_uniqueness_solution[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>!x. is_solution x A b\n\ngoal (1 subgoal):\n 1. card (solution_set A b) = 1", "unfolding solution_set_def"], ["proof (prove)\nusing this:\n  \\<exists>!x. is_solution x A b\n\ngoal (1 subgoal):\n 1. card {x. is_solution x A b} = 1", "using card_1_exists"], ["proof (prove)\nusing this:\n  \\<exists>!x. is_solution x A b\n  (card ?s = 1) = (\\<exists>!x. x \\<in> ?s)\n\ngoal (1 subgoal):\n 1. card {x. is_solution x A b} = 1", "by auto"], ["", "lemma uniqueness_solution_imp_independent:\nfixes A::\"'a::{field}^'n^'rows\"\nassumes ex1_sol: \"\\<exists>!x. is_solution x A b\"\nshows \"vec.dim (solution_set A 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (solution_set A 0) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec.dim (solution_set A 0) = 0", "obtain x where x: \"is_solution x A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. is_solution x A b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex1_sol"], ["proof (prove)\nusing this:\n  \\<exists>!x. is_solution x A b\n\ngoal (1 subgoal):\n 1. (\\<And>x. is_solution x A b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_solution x A b\n\ngoal (1 subgoal):\n 1. vec.dim (solution_set A 0) = 0", "have solution_set_homogeneous_zero: \"solution_set A 0 = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution_set A 0 = {0}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. solution_set A 0 \\<noteq> {0} \\<Longrightarrow> False", "assume not_zero_set: \"solution_set A 0 \\<noteq> {0}\""], ["proof (state)\nthis:\n  solution_set A 0 \\<noteq> {0}\n\ngoal (1 subgoal):\n 1. solution_set A 0 \\<noteq> {0} \\<Longrightarrow> False", "have homogeneous_not_empty: \"solution_set A 0 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution_set A 0 \\<noteq> {}", "by (metis empty_iff zero_is_solution_homogeneous_system)"], ["proof (state)\nthis:\n  solution_set A 0 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. solution_set A 0 \\<noteq> {0} \\<Longrightarrow> False", "obtain y where y: \"y \\<in> solution_set A 0\" and y_not_0: \"y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> solution_set A 0; y \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_zero_set homogeneous_not_empty"], ["proof (prove)\nusing this:\n  solution_set A 0 \\<noteq> {0}\n  solution_set A 0 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> solution_set A 0; y \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> solution_set A 0\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. solution_set A 0 \\<noteq> {0} \\<Longrightarrow> False", "have \"{x} = solution_set A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} = solution_set A b", "unfolding solution_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} = {x. is_solution x A b}", "using x ex1_sol"], ["proof (prove)\nusing this:\n  is_solution x A b\n  \\<exists>!x. is_solution x A b\n\ngoal (1 subgoal):\n 1. {x} = {x. is_solution x A b}", "by blast"], ["proof (state)\nthis:\n  {x} = solution_set A b\n\ngoal (1 subgoal):\n 1. solution_set A 0 \\<noteq> {0} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  {x} = solution_set A b\n\ngoal (1 subgoal):\n 1. solution_set A 0 \\<noteq> {0} \\<Longrightarrow> False", "have \"... = {x} + solution_set A 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution_set A b = {x} + solution_set A 0", "unfolding solution_set_rel[OF x]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} + solution_set A 0 = {x} + solution_set A 0", ".."], ["proof (state)\nthis:\n  solution_set A b = {x} + solution_set A 0\n\ngoal (1 subgoal):\n 1. solution_set A 0 \\<noteq> {0} \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  {x} = {x} + solution_set A 0", "show False"], ["proof (prove)\nusing this:\n  {x} = {x} + solution_set A 0\n\ngoal (1 subgoal):\n 1. False", "by (metis (hide_lams, mono_tags) add_left_cancel monoid_add_class.add.right_neutral empty_iff insert_iff set_plus_intro y y_not_0)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  solution_set A 0 = {0}\n\ngoal (1 subgoal):\n 1. vec.dim (solution_set A 0) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  solution_set A 0 = {0}\n\ngoal (1 subgoal):\n 1. vec.dim (solution_set A 0) = 0", "using vec.dim_zero_eq'"], ["proof (prove)\nusing this:\n  solution_set A 0 = {0}\n  ?A = {} \\<or> ?A = {0} \\<Longrightarrow> vec.dim ?A = 0\n\ngoal (1 subgoal):\n 1. vec.dim (solution_set A 0) = 0", "by blast"], ["proof (state)\nthis:\n  vec.dim (solution_set A 0) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary uniqueness_solution_eq_independent_and_consistent:\nfixes A::\"'a::{field}^'n::{mod_type}^'rows::{mod_type}\"\nshows \"(\\<exists>!x. is_solution x A b) = (consistent A b \\<and> vec.dim (solution_set A 0) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!x. is_solution x A b) =\n    (consistent A b \\<and> vec.dim (solution_set A 0) = 0)", "using independent_and_consistent_imp_uniqueness_solution uniqueness_solution_imp_independent consistent_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>vec.dim (solution_set ?A 0) = 0; consistent ?A ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!x. is_solution x ?A ?b\n  \\<exists>!x. is_solution x ?A ?b \\<Longrightarrow>\n  vec.dim (solution_set ?A 0) = 0\n  consistent ?A ?b = (\\<exists>x. is_solution x ?A ?b)\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. is_solution x A b) =\n    (consistent A b \\<and> vec.dim (solution_set A 0) = 0)", "by metis"], ["", "lemma consistent_homogeneous: \nshows \"consistent A 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent A 0", "unfolding consistent_def is_solution_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. A *v x = 0", "using matrix_vector_mult_0_right"], ["proof (prove)\nusing this:\n  ?A *v 0 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x. A *v x = 0", "by fast"], ["", "lemma dim_solution_set_0:\n  fixes A::\"'a::{field}^'n::{mod_type}^'rows::{mod_type}\"\n  shows \"(vec.dim (solution_set A 0) = 0) = (solution_set A 0 = {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec.dim (solution_set A 0) = 0) = (solution_set A 0 = {0})", "using homogeneous_solution_set_subspace vec.dim_zero_subspace_eq"], ["proof (prove)\nusing this:\n  vec.subspace (solution_set ?A 0)\n  vec.subspace ?A \\<Longrightarrow> (vec.dim ?A = 0) = (?A = {0})\n\ngoal (1 subgoal):\n 1. (vec.dim (solution_set A 0) = 0) = (solution_set A 0 = {0})", "by auto"], ["", "text\\<open>We have to impose the restriction \\<open>semiring_char_0\\<close> in the following lemma,\nbecause it may not hold over a general field (for instance, in Z2 there is a finite number of elements, so the solution\nset can't be infinite.\\<close>"], ["", "lemma dim_solution_set_not_zero_imp_infinite_solutions_homogeneous:\nfixes A::\"'a::{field, semiring_char_0}^'n::{mod_type}^'rows::{mod_type}\"\nassumes dim_not_zero: \"vec.dim (solution_set A 0) > 0\"\nshows \"infinite (solution_set A 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (solution_set A 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (solution_set A 0)", "have \"solution_set A 0 \\<noteq> {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution_set A 0 \\<noteq> {0}", "using vec.dim_zero_subspace_eq[of \"solution_set A 0\"] dim_not_zero"], ["proof (prove)\nusing this:\n  vec.subspace (solution_set A 0) \\<Longrightarrow>\n  (vec.dim (solution_set A 0) = 0) = (solution_set A 0 = {0})\n  0 < vec.dim (solution_set A 0)\n\ngoal (1 subgoal):\n 1. solution_set A 0 \\<noteq> {0}", "by (metis less_numeral_extra(3) vec.dim_zero_eq')"], ["proof (state)\nthis:\n  solution_set A 0 \\<noteq> {0}\n\ngoal (1 subgoal):\n 1. infinite (solution_set A 0)", "from this"], ["proof (chain)\npicking this:\n  solution_set A 0 \\<noteq> {0}", "obtain x where x: \"x \\<in> solution_set A 0\" and x_not_0: \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  solution_set A 0 \\<noteq> {0}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> solution_set A 0; x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using vec.subspace_0[OF homogeneous_solution_set_subspace, of A]"], ["proof (prove)\nusing this:\n  solution_set A 0 \\<noteq> {0}\n  0 \\<in> solution_set A 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> solution_set A 0; x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> solution_set A 0\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. infinite (solution_set A 0)", "define f where \"f = (\\<lambda>n::nat. (of_nat n) *s x)\""], ["proof (state)\nthis:\n  f = (\\<lambda>n. of_nat n *s x)\n\ngoal (1 subgoal):\n 1. infinite (solution_set A 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (solution_set A 0)", "proof (unfold infinite_iff_countable_subset, rule exI[of _ f], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj f\n 2. range f \\<subseteq> solution_set A 0", "show \"inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV. f x = f y \\<longrightarrow> x = y", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          of_nat xa *s x = of_nat y *s x \\<longrightarrow> xa = y", "using x_not_0"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          of_nat xa *s x = of_nat y *s x \\<longrightarrow> xa = y", "by (auto simp: vec_eq_iff)"], ["proof (state)\nthis:\n  inj f\n\ngoal (1 subgoal):\n 1. range f \\<subseteq> solution_set A 0", "show \"range f \\<subseteq> solution_set A 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range f \\<subseteq> solution_set A 0", "using homogeneous_solution_set_subspace"], ["proof (prove)\nusing this:\n  vec.subspace (solution_set ?A 0)\n\ngoal (1 subgoal):\n 1. range f \\<subseteq> solution_set A 0", "using x"], ["proof (prove)\nusing this:\n  vec.subspace (solution_set ?A 0)\n  x \\<in> solution_set A 0\n\ngoal (1 subgoal):\n 1. range f \\<subseteq> solution_set A 0", "unfolding vec.subspace_def image_def f_def"], ["proof (prove)\nusing this:\n  0 \\<in> solution_set ?A 0 \\<and>\n  (\\<forall>x\\<in>solution_set ?A 0.\n      \\<forall>y\\<in>solution_set ?A 0.\n         x + y \\<in> solution_set ?A 0) \\<and>\n  (\\<forall>c.\n      \\<forall>x\\<in>solution_set ?A 0. c *s x \\<in> solution_set ?A 0)\n  x \\<in> solution_set A 0\n\ngoal (1 subgoal):\n 1. {y. \\<exists>xa\\<in>UNIV. y = of_nat xa *s x}\n    \\<subseteq> solution_set A 0", "by fast"], ["proof (state)\nthis:\n  range f \\<subseteq> solution_set A 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infinite (solution_set A 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_solutions_homogeneous_imp_dim_solution_set_not_zero:\n  fixes A::\"'a::{field}^'n::{mod_type}^'rows::{mod_type}\"\n  assumes i: \"infinite (solution_set A 0)\"\n  shows \"vec.dim (solution_set A 0) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < vec.dim (solution_set A 0)", "by (metis dim_solution_set_0 finite.simps gr0I i)"], ["", "corollary infinite_solution_set_homogeneous_eq:\nfixes A::\"'a::{field,semiring_char_0}^'n::{mod_type}^'rows::{mod_type}\"\nshows \"infinite (solution_set A 0) = (vec.dim (solution_set A 0) > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (solution_set A 0) = (0 < vec.dim (solution_set A 0))", "using infinite_solutions_homogeneous_imp_dim_solution_set_not_zero"], ["proof (prove)\nusing this:\n  infinite (solution_set ?A 0) \\<Longrightarrow>\n  0 < vec.dim (solution_set ?A 0)\n\ngoal (1 subgoal):\n 1. infinite (solution_set A 0) = (0 < vec.dim (solution_set A 0))", "using dim_solution_set_not_zero_imp_infinite_solutions_homogeneous"], ["proof (prove)\nusing this:\n  infinite (solution_set ?A 0) \\<Longrightarrow>\n  0 < vec.dim (solution_set ?A 0)\n  0 < vec.dim (solution_set ?A 0) \\<Longrightarrow>\n  infinite (solution_set ?A 0)\n\ngoal (1 subgoal):\n 1. infinite (solution_set A 0) = (0 < vec.dim (solution_set A 0))", "by metis"], ["", "corollary infinite_solution_set_homogeneous_eq':\nfixes A::\"'a::{field,semiring_char_0}^'n::{mod_type}^'rows::{mod_type}\"\nshows \"(\\<exists>\\<^sub>\\<infinity>x. is_solution x A 0) = (vec.dim (solution_set A 0) > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>x. is_solution x A 0) =\n    (0 < vec.dim (solution_set A 0))", "unfolding infinite_solution_set_homogeneous_eq[symmetric] INFM_iff_infinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {x. is_solution x A 0} = infinite (solution_set A 0)", "unfolding solution_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {x. is_solution x A 0} = infinite {x. is_solution x A 0}", ".."], ["", "lemma infinite_solution_set_imp_consistent:\n  \"infinite (solution_set A b) \\<Longrightarrow> consistent A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (solution_set A b) \\<Longrightarrow> consistent A b", "by (auto dest!: infinite_imp_nonempty simp: solution_set_def consistent_def)"], ["", "lemma dim_solution_set_not_zero_imp_infinite_solutions_no_homogeneous:\nfixes A::\"'a::{field, semiring_char_0}^'n::{mod_type}^'rows::{mod_type}\"\nassumes dim_not_0: \"vec.dim (solution_set A 0) > 0\"\nand con: \"consistent A b\"\nshows \"infinite (solution_set A b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (solution_set A b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (solution_set A b)", "have \"solution_set A 0 \\<noteq> {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution_set A 0 \\<noteq> {0}", "using vec.dim_zero_subspace_eq[of \"solution_set A 0\"] dim_not_0"], ["proof (prove)\nusing this:\n  vec.subspace (solution_set A 0) \\<Longrightarrow>\n  (vec.dim (solution_set A 0) = 0) = (solution_set A 0 = {0})\n  0 < vec.dim (solution_set A 0)\n\ngoal (1 subgoal):\n 1. solution_set A 0 \\<noteq> {0}", "by (metis less_numeral_extra(3) vec.dim_zero_eq')"], ["proof (state)\nthis:\n  solution_set A 0 \\<noteq> {0}\n\ngoal (1 subgoal):\n 1. infinite (solution_set A b)", "from this"], ["proof (chain)\npicking this:\n  solution_set A 0 \\<noteq> {0}", "obtain x where x: \"x \\<in> solution_set A 0\" and x_not_0: \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  solution_set A 0 \\<noteq> {0}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> solution_set A 0; x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using vec.subspace_0[OF homogeneous_solution_set_subspace, of A]"], ["proof (prove)\nusing this:\n  solution_set A 0 \\<noteq> {0}\n  0 \\<in> solution_set A 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> solution_set A 0; x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> solution_set A 0\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. infinite (solution_set A b)", "obtain y where y: \"is_solution y A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. is_solution y A b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using con"], ["proof (prove)\nusing this:\n  consistent A b\n\ngoal (1 subgoal):\n 1. (\\<And>y. is_solution y A b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding consistent_def"], ["proof (prove)\nusing this:\n  \\<exists>x. is_solution x A b\n\ngoal (1 subgoal):\n 1. (\\<And>y. is_solution y A b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_solution y A b\n\ngoal (1 subgoal):\n 1. infinite (solution_set A b)", "define f where \"f = (\\<lambda>n::nat. y + (of_nat n) *s x)\""], ["proof (state)\nthis:\n  f = (\\<lambda>n. y + of_nat n *s x)\n\ngoal (1 subgoal):\n 1. infinite (solution_set A b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (solution_set A b)", "proof (unfold infinite_iff_countable_subset, rule exI[of _ f], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj f\n 2. range f \\<subseteq> solution_set A b", "show \"inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV. f x = f y \\<longrightarrow> x = y", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>UNIV.\n       \\<forall>ya\\<in>UNIV.\n          y + of_nat xa *s x = y + of_nat ya *s x \\<longrightarrow> xa = ya", "using x_not_0"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>UNIV.\n       \\<forall>ya\\<in>UNIV.\n          y + of_nat xa *s x = y + of_nat ya *s x \\<longrightarrow> xa = ya", "by (auto simp: vec_eq_iff)"], ["proof (state)\nthis:\n  inj f\n\ngoal (1 subgoal):\n 1. range f \\<subseteq> solution_set A b", "show \"range f \\<subseteq> solution_set A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range f \\<subseteq> solution_set A b", "unfolding solution_set_rel[OF y]"], ["proof (prove)\ngoal (1 subgoal):\n 1. range f \\<subseteq> {y} + solution_set A 0", "using homogeneous_solution_set_subspace"], ["proof (prove)\nusing this:\n  vec.subspace (solution_set ?A 0)\n\ngoal (1 subgoal):\n 1. range f \\<subseteq> {y} + solution_set A 0", "using x"], ["proof (prove)\nusing this:\n  vec.subspace (solution_set ?A 0)\n  x \\<in> solution_set A 0\n\ngoal (1 subgoal):\n 1. range f \\<subseteq> {y} + solution_set A 0", "unfolding vec.subspace_def image_def f_def"], ["proof (prove)\nusing this:\n  0 \\<in> solution_set ?A 0 \\<and>\n  (\\<forall>x\\<in>solution_set ?A 0.\n      \\<forall>y\\<in>solution_set ?A 0.\n         x + y \\<in> solution_set ?A 0) \\<and>\n  (\\<forall>c.\n      \\<forall>x\\<in>solution_set ?A 0. c *s x \\<in> solution_set ?A 0)\n  x \\<in> solution_set A 0\n\ngoal (1 subgoal):\n 1. {ya. \\<exists>xa\\<in>UNIV. ya = y + of_nat xa *s x}\n    \\<subseteq> {y} + solution_set A 0", "by fast"], ["proof (state)\nthis:\n  range f \\<subseteq> solution_set A b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infinite (solution_set A b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_solutions_no_homogeneous_imp_dim_solution_set_not_zero_imp:\n  fixes A::\"'a::{field}^'n::{mod_type}^'rows::{mod_type}\"\n  assumes i: \"infinite (solution_set A b)\"\n  shows \"vec.dim (solution_set A 0) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < vec.dim (solution_set A 0)", "using i independent_and_consistent_imp_card_1 infinite_solution_set_imp_consistent"], ["proof (prove)\nusing this:\n  infinite (solution_set A b)\n  \\<lbrakk>vec.dim (solution_set ?A 0) = 0; consistent ?A ?b\\<rbrakk>\n  \\<Longrightarrow> card (solution_set ?A ?b) = 1\n  infinite (solution_set ?A ?b) \\<Longrightarrow> consistent ?A ?b\n\ngoal (1 subgoal):\n 1. 0 < vec.dim (solution_set A 0)", "by fastforce"], ["", "corollary infinite_solution_set_no_homogeneous_eq:\nfixes A::\"'a::{field, semiring_char_0}^'n::{mod_type}^'rows::{mod_type}\"\nshows \"infinite (solution_set A b) = (consistent A b \\<and> vec.dim (solution_set A 0) > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (solution_set A b) =\n    (consistent A b \\<and> 0 < vec.dim (solution_set A 0))", "using dim_solution_set_not_zero_imp_infinite_solutions_no_homogeneous"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < vec.dim (solution_set ?A 0); consistent ?A ?b\\<rbrakk>\n  \\<Longrightarrow> infinite (solution_set ?A ?b)\n\ngoal (1 subgoal):\n 1. infinite (solution_set A b) =\n    (consistent A b \\<and> 0 < vec.dim (solution_set A 0))", "using infinite_solutions_no_homogeneous_imp_dim_solution_set_not_zero_imp"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < vec.dim (solution_set ?A 0); consistent ?A ?b\\<rbrakk>\n  \\<Longrightarrow> infinite (solution_set ?A ?b)\n  infinite (solution_set ?A ?b) \\<Longrightarrow>\n  0 < vec.dim (solution_set ?A 0)\n\ngoal (1 subgoal):\n 1. infinite (solution_set A b) =\n    (consistent A b \\<and> 0 < vec.dim (solution_set A 0))", "using infinite_solution_set_imp_consistent"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < vec.dim (solution_set ?A 0); consistent ?A ?b\\<rbrakk>\n  \\<Longrightarrow> infinite (solution_set ?A ?b)\n  infinite (solution_set ?A ?b) \\<Longrightarrow>\n  0 < vec.dim (solution_set ?A 0)\n  infinite (solution_set ?A ?b) \\<Longrightarrow> consistent ?A ?b\n\ngoal (1 subgoal):\n 1. infinite (solution_set A b) =\n    (consistent A b \\<and> 0 < vec.dim (solution_set A 0))", "by blast"], ["", "corollary infinite_solution_set_no_homogeneous_eq':\nfixes A::\"'a::{field, semiring_char_0}^'n::{mod_type}^'rows::{mod_type}\"\nshows \"(\\<exists>\\<^sub>\\<infinity>x. is_solution x A b) = (consistent A b \\<and> vec.dim (solution_set A 0) > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>\\<infinity>x. is_solution x A b) =\n    (consistent A b \\<and> 0 < vec.dim (solution_set A 0))", "unfolding infinite_solution_set_no_homogeneous_eq[symmetric] INFM_iff_infinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {x. is_solution x A b} = infinite (solution_set A b)", "unfolding solution_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {x. is_solution x A b} = infinite {x. is_solution x A b}", ".."], ["", "definition \"independent_and_consistent A b = (consistent A b \\<and> vec.dim (solution_set A 0) = 0)\""], ["", "definition \"dependent_and_consistent A b = (consistent A b \\<and> vec.dim (solution_set A 0) > 0)\""], ["", "subsection\\<open>Solving systems of linear equations\\<close>"], ["", "text\\<open>The following function will solve any system of linear equations. Given a matrix \\<open>A\\<close> and a vector \\<open>b\\<close>, \nFirstly it makes use of the funcion @{term \"solve_system\"} to transform the original matrix \\<open>A\\<close> and the vector \\<open>b\\<close> \ninto another ones in reduced row echelon form. Then, that system will have the same solution than the original one but it is easier to be solved.\nSo we make use of the function @{term \"solve_consistent_rref\"} to obtain one solution of the system.\n\nWe will prove that any solution of the system can be rewritten as a linear combination of elements of a basis of the null space plus a particular solution of the system.\nSo the function @{term \"solve\"} will return an option type, depending on the consistency of the system:\n\\begin{itemize}\n\\item If the system is consistent (so there exists at least one solution), the function will return the \\<open>Some\\<close> of a pair.\n      In the first component of that pair will be one solution of the system and the second one will be a basis of the null space of the matrix. Hence:\n    \\begin{enumerate}\n        \\item If the system is consistent and independent (so there exists one and only one solution), the pair will consist of the solution and the empty set (this empty set is \n              the basis of the null space).\n        \\item If the system is consistent and dependent (so there exists more than one solution, maybe an infinite number), \n              the pair will consist of one particular solution and a basis of the null space (which will not be the empty set).\n    \\end{enumerate}\n\\item If the system is inconsistent (so there exists no solution), the function will return \\<open>None\\<close>.\n\\end{itemize}\n\\<close>"], ["", "definition \"solve A b = (if consistent A b then \n    Some (solve_consistent_rref (fst (solve_system A b)) (snd (solve_system A b)), basis_null_space A) \n    else None)\""], ["", "lemma solve_code[code]:\n  shows \"solve A b = (let GJ_P=Gauss_Jordan_PA A; \n                        P_times_b=fst(GJ_P) *v b;\n                        rank_A = (if A = 0 then 0 else to_nat (GREATEST a. row a (snd GJ_P) \\<noteq> 0) + 1);\n                        consistent_Ab = (rank_A \\<ge> (if (\\<exists>a. (P_times_b) $ a \\<noteq> 0) then (to_nat (GREATEST a. (P_times_b) $ a \\<noteq> 0) + 1) else 0));\n                        GJ_transpose = Gauss_Jordan_PA (transpose A); \n                        basis = {row i (fst GJ_transpose) | i. to_nat i \\<ge> rank_A}\n                        in (if consistent_Ab then Some (solve_consistent_rref (snd GJ_P) P_times_b,basis) else None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solve A b =\n    (let GJ_P = Gauss_Jordan_PA A; P_times_b = fst GJ_P *v b;\n         rank_A =\n           if A = 0 then 0\n           else mod_type_class.to_nat\n                 (GREATEST a. row a (snd GJ_P) \\<noteq> 0) +\n                1;\n         consistent_Ab =\n           (if \\<exists>a. P_times_b $ a \\<noteq> (0::'a)\n            then mod_type_class.to_nat\n                  (GREATEST a. P_times_b $ a \\<noteq> (0::'a)) +\n                 1\n            else 0)\n           \\<le> rank_A;\n         GJ_transpose =\n           Gauss_Jordan_PA (Finite_Cartesian_Product.transpose A);\n         basis =\n           {row i (fst GJ_transpose) |i.\n            rank_A \\<le> mod_type_class.to_nat i}\n     in if consistent_Ab\n        then Some (solve_consistent_rref (snd GJ_P) P_times_b, basis)\n        else None)", "unfolding Let_def solve_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if consistent A b\n     then Some\n           (solve_consistent_rref (fst (solve_system A b))\n             (snd (solve_system A b)),\n            basis_null_space A)\n     else None) =\n    (if (if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n         then mod_type_class.to_nat\n               (GREATEST a.\n                   (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n              1\n         else 0)\n        \\<le> (if A = 0 then 0\n               else mod_type_class.to_nat\n                     (GREATEST a.\n                         row a (snd (Gauss_Jordan_PA A)) \\<noteq> 0) +\n                    1)\n     then Some\n           (solve_consistent_rref (snd (Gauss_Jordan_PA A))\n             (fst (Gauss_Jordan_PA A) *v b),\n            {row i\n              (fst (Gauss_Jordan_PA\n                     (Finite_Cartesian_Product.transpose A))) |\n             i. (if A = 0 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST a.\n                           row a (snd (Gauss_Jordan_PA A)) \\<noteq> 0) +\n                      1)\n                \\<le> mod_type_class.to_nat i})\n     else None)", "unfolding consistent_eq_rank_ge_code[unfolded Let_def,symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if consistent A b\n     then Some\n           (solve_consistent_rref (fst (solve_system A b))\n             (snd (solve_system A b)),\n            basis_null_space A)\n     else None) =\n    (if consistent A b\n     then Some\n           (solve_consistent_rref (snd (Gauss_Jordan_PA A))\n             (fst (Gauss_Jordan_PA A) *v b),\n            {row i\n              (fst (Gauss_Jordan_PA\n                     (Finite_Cartesian_Product.transpose A))) |\n             i. (if A = 0 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST a.\n                           row a (snd (Gauss_Jordan_PA A)) \\<noteq> 0) +\n                      1)\n                \\<le> mod_type_class.to_nat i})\n     else None)", "unfolding basis_null_space_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if consistent A b\n     then Some\n           (solve_consistent_rref (fst (solve_system A b))\n             (snd (solve_system A b)),\n            {row i (P_Gauss_Jordan (Finite_Cartesian_Product.transpose A)) |\n             i. rank A \\<le> mod_type_class.to_nat i})\n     else None) =\n    (if consistent A b\n     then Some\n           (solve_consistent_rref (snd (Gauss_Jordan_PA A))\n             (fst (Gauss_Jordan_PA A) *v b),\n            {row i\n              (fst (Gauss_Jordan_PA\n                     (Finite_Cartesian_Product.transpose A))) |\n             i. (if A = 0 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST a.\n                           row a (snd (Gauss_Jordan_PA A)) \\<noteq> 0) +\n                      1)\n                \\<le> mod_type_class.to_nat i})\n     else None)", "unfolding P_Gauss_Jordan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if consistent A b\n     then Some\n           (solve_consistent_rref (fst (solve_system A b))\n             (snd (solve_system A b)),\n            {row i\n              (fst (Gauss_Jordan_PA\n                     (Finite_Cartesian_Product.transpose A))) |\n             i. rank A \\<le> mod_type_class.to_nat i})\n     else None) =\n    (if consistent A b\n     then Some\n           (solve_consistent_rref (snd (Gauss_Jordan_PA A))\n             (fst (Gauss_Jordan_PA A) *v b),\n            {row i\n              (fst (Gauss_Jordan_PA\n                     (Finite_Cartesian_Product.transpose A))) |\n             i. (if A = 0 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST a.\n                           row a (snd (Gauss_Jordan_PA A)) \\<noteq> 0) +\n                      1)\n                \\<le> mod_type_class.to_nat i})\n     else None)", "unfolding rank_Gauss_Jordan_code Let_def Gauss_Jordan_PA_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if consistent A b\n     then Some\n           (solve_consistent_rref (fst (solve_system A b))\n             (snd (solve_system A b)),\n            {row i\n              (fst (Gauss_Jordan_PA\n                     (Finite_Cartesian_Product.transpose A))) |\n             i. (if A = 0 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n                      1)\n                \\<le> mod_type_class.to_nat i})\n     else None) =\n    (if consistent A b\n     then Some\n           (solve_consistent_rref (Gauss_Jordan A)\n             (fst (Gauss_Jordan_PA A) *v b),\n            {row i\n              (fst (Gauss_Jordan_PA\n                     (Finite_Cartesian_Product.transpose A))) |\n             i. (if A = 0 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n                      1)\n                \\<le> mod_type_class.to_nat i})\n     else None)", "unfolding solve_system_def Let_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if consistent A b\n     then Some\n           (solve_consistent_rref (snd (Gauss_Jordan_PA A))\n             (fst (Gauss_Jordan_PA A) *v b),\n            {row i\n              (fst (Gauss_Jordan_PA\n                     (Finite_Cartesian_Product.transpose A))) |\n             i. (if A = 0 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n                      1)\n                \\<le> mod_type_class.to_nat i})\n     else None) =\n    (if consistent A b\n     then Some\n           (solve_consistent_rref (Gauss_Jordan A)\n             (fst (Gauss_Jordan_PA A) *v b),\n            {row i\n              (fst (Gauss_Jordan_PA\n                     (Finite_Cartesian_Product.transpose A))) |\n             i. (if A = 0 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n                      1)\n                \\<le> mod_type_class.to_nat i})\n     else None)", "unfolding Gauss_Jordan_PA_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if consistent A b\n     then Some\n           (solve_consistent_rref (Gauss_Jordan A)\n             (fst (Gauss_Jordan_PA A) *v b),\n            {row i\n              (fst (Gauss_Jordan_PA\n                     (Finite_Cartesian_Product.transpose A))) |\n             i. (if A = 0 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n                      1)\n                \\<le> mod_type_class.to_nat i})\n     else None) =\n    (if consistent A b\n     then Some\n           (solve_consistent_rref (Gauss_Jordan A)\n             (fst (Gauss_Jordan_PA A) *v b),\n            {row i\n              (fst (Gauss_Jordan_PA\n                     (Finite_Cartesian_Product.transpose A))) |\n             i. (if A = 0 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n                      1)\n                \\<le> mod_type_class.to_nat i})\n     else None)", ".."], ["", "lemma consistent_imp_is_solution_solve:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes con: \"consistent A b\"\n  shows \"is_solution (fst (the (solve A b))) A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution (fst (the (solve A b))) A b", "unfolding solve_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution\n     (fst (the (if consistent A b\n                then Some\n                      (solve_consistent_rref (fst (solve_system A b))\n                        (snd (solve_system A b)),\n                       basis_null_space A)\n                else None)))\n     A b", "unfolding if_P[OF con] fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution\n     (fst (the (Some\n                 (solve_consistent_rref (fst (solve_system A b))\n                   (snd (solve_system A b)),\n                  basis_null_space A))))\n     A b", "using consistent_imp_is_solution'[OF con]"], ["proof (prove)\nusing this:\n  is_solution\n   (solve_consistent_rref (fst (solve_system A b)) (snd (solve_system A b)))\n   A b\n\ngoal (1 subgoal):\n 1. is_solution\n     (fst (the (Some\n                 (solve_consistent_rref (fst (solve_system A b))\n                   (snd (solve_system A b)),\n                  basis_null_space A))))\n     A b", "by simp"], ["", "corollary consistent_eq_solution_solve:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"consistent A b = is_solution (fst (the (solve A b))) A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent A b = is_solution (fst (the (solve A b))) A b", "by (metis consistent_def consistent_imp_is_solution_solve)"], ["", "lemma inconsistent_imp_solve_eq_none:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes con: \"inconsistent A b\"\n  shows \"solve A b = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solve A b = None", "unfolding solve_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if consistent A b\n     then Some\n           (solve_consistent_rref (fst (solve_system A b))\n             (snd (solve_system A b)),\n            basis_null_space A)\n     else None) =\n    None", "unfolding if_not_P[OF con[unfolded inconsistent_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. None = None", ".."], ["", "corollary inconsistent_eq_solve_eq_none:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"inconsistent A b = (solve A b = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsistent A b = (solve A b = None)", "unfolding solve_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsistent A b =\n    ((if consistent A b\n      then Some\n            (solve_consistent_rref (fst (solve_system A b))\n              (snd (solve_system A b)),\n             basis_null_space A)\n      else None) =\n     None)", "unfolding inconsistent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> consistent A b) =\n    ((if consistent A b\n      then Some\n            (solve_consistent_rref (fst (solve_system A b))\n              (snd (solve_system A b)),\n             basis_null_space A)\n      else None) =\n     None)", "by force"], ["", "text\\<open>We demonstrate that all solutions of a system of linear equations can be expressed as a linear combination of the basis of the null space plus a particular solution\nobtained. The basis and the particular solution are obtained by means of the function @{term \"solve A b\"}\\<close>"], ["", "lemma solution_set_rel_solve:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes con: \"consistent A b\"\n  shows \"solution_set A b = {fst (the (solve A b))} + vec.span (snd (the (solve A b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution_set A b =\n    {fst (the (solve A b))} + vec.span (snd (the (solve A b)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. solution_set A b =\n    {fst (the (solve A b))} + vec.span (snd (the (solve A b)))", "have s: \"is_solution (fst (the (solve A b))) A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution (fst (the (solve A b))) A b", "using consistent_imp_is_solution_solve[OF con]"], ["proof (prove)\nusing this:\n  is_solution (fst (the (solve A b))) A b\n\ngoal (1 subgoal):\n 1. is_solution (fst (the (solve A b))) A b", "by simp"], ["proof (state)\nthis:\n  is_solution (fst (the (solve A b))) A b\n\ngoal (1 subgoal):\n 1. solution_set A b =\n    {fst (the (solve A b))} + vec.span (snd (the (solve A b)))", "have \"solution_set A b = {fst (the (solve A b))} + solution_set A 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution_set A b = {fst (the (solve A b))} + solution_set A 0", "using solution_set_rel[OF s]"], ["proof (prove)\nusing this:\n  solution_set A b = {fst (the (solve A b))} + solution_set A 0\n\ngoal (1 subgoal):\n 1. solution_set A b = {fst (the (solve A b))} + solution_set A 0", "."], ["proof (state)\nthis:\n  solution_set A b = {fst (the (solve A b))} + solution_set A 0\n\ngoal (1 subgoal):\n 1. solution_set A b =\n    {fst (the (solve A b))} + vec.span (snd (the (solve A b)))", "also"], ["proof (state)\nthis:\n  solution_set A b = {fst (the (solve A b))} + solution_set A 0\n\ngoal (1 subgoal):\n 1. solution_set A b =\n    {fst (the (solve A b))} + vec.span (snd (the (solve A b)))", "have \"... = {fst (the (solve A b))} + vec.span (snd (the (solve A b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {fst (the (solve A b))} + solution_set A 0 =\n    {fst (the (solve A b))} + vec.span (snd (the (solve A b)))", "unfolding set_plus_def solve_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {c. \\<exists>a\\<in>{fst (the (if consistent A b\n                                  then Some\n  (solve_consistent_rref (fst (solve_system A b)) (snd (solve_system A b)),\n   basis_null_space A)\n                                  else None))}.\n           \\<exists>b\\<in>solution_set A 0. c = a + b} =\n    {c. \\<exists>a\\<in>{fst (the (if consistent A b\n                                  then Some\n  (solve_consistent_rref (fst (solve_system A b)) (snd (solve_system A b)),\n   basis_null_space A)\n                                  else None))}.\n           \\<exists>b\\<in>vec.span\n                           (snd (the (if consistent A b\nthen Some\n      (solve_consistent_rref (fst (solve_system A b))\n        (snd (solve_system A b)),\n       basis_null_space A)\nelse None))).\n              c = a + b}", "unfolding if_P[OF con] snd_conv fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. {c. \\<exists>a\\<in>{fst (the (Some\n                                   (solve_consistent_rref\n                                     (fst (solve_system A b))\n                                     (snd (solve_system A b)),\n                                    basis_null_space A)))}.\n           \\<exists>b\\<in>solution_set A 0. c = a + b} =\n    {c. \\<exists>a\\<in>{fst (the (Some\n                                   (solve_consistent_rref\n                                     (fst (solve_system A b))\n                                     (snd (solve_system A b)),\n                                    basis_null_space A)))}.\n           \\<exists>b\\<in>vec.span\n                           (snd (the (Some\n (solve_consistent_rref (fst (solve_system A b)) (snd (solve_system A b)),\n  basis_null_space A)))).\n              c = a + b}", "proof (safe, simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       b \\<in> solution_set A 0 \\<Longrightarrow>\n       b \\<in> vec.span (basis_null_space A)\n 2. \\<And>b.\n       b \\<in> vec.span (basis_null_space A) \\<Longrightarrow>\n       b \\<in> solution_set A 0", "fix b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       b \\<in> solution_set A 0 \\<Longrightarrow>\n       b \\<in> vec.span (basis_null_space A)\n 2. \\<And>b.\n       b \\<in> vec.span (basis_null_space A) \\<Longrightarrow>\n       b \\<in> solution_set A 0", "assume \"b \\<in> solution_set A 0\""], ["proof (state)\nthis:\n  b \\<in> solution_set A 0\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       b \\<in> solution_set A 0 \\<Longrightarrow>\n       b \\<in> vec.span (basis_null_space A)\n 2. \\<And>b.\n       b \\<in> vec.span (basis_null_space A) \\<Longrightarrow>\n       b \\<in> solution_set A 0", "thus \"b \\<in> vec.span (basis_null_space A)\""], ["proof (prove)\nusing this:\n  b \\<in> solution_set A 0\n\ngoal (1 subgoal):\n 1. b \\<in> vec.span (basis_null_space A)", "unfolding null_space_eq_solution_set[symmetric]"], ["proof (prove)\nusing this:\n  b \\<in> null_space A\n\ngoal (1 subgoal):\n 1. b \\<in> vec.span (basis_null_space A)", "using basis_null_space[of A]"], ["proof (prove)\nusing this:\n  b \\<in> null_space A\n  vec.independent (basis_null_space A) \\<and>\n  null_space A = vec.span (basis_null_space A)\n\ngoal (1 subgoal):\n 1. b \\<in> vec.span (basis_null_space A)", "by fast"], ["proof (state)\nthis:\n  b \\<in> vec.span (basis_null_space A)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> vec.span (basis_null_space A) \\<Longrightarrow>\n       b \\<in> solution_set A 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> vec.span (basis_null_space A) \\<Longrightarrow>\n       b \\<in> solution_set A 0", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> vec.span (basis_null_space A) \\<Longrightarrow>\n       b \\<in> solution_set A 0", "assume b: \"b \\<in> vec.span (basis_null_space A)\""], ["proof (state)\nthis:\n  b \\<in> vec.span (basis_null_space A)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> vec.span (basis_null_space A) \\<Longrightarrow>\n       b \\<in> solution_set A 0", "thus \"b \\<in> solution_set A 0\""], ["proof (prove)\nusing this:\n  b \\<in> vec.span (basis_null_space A)\n\ngoal (1 subgoal):\n 1. b \\<in> solution_set A 0", "unfolding null_space_eq_solution_set[symmetric]"], ["proof (prove)\nusing this:\n  b \\<in> vec.span (basis_null_space A)\n\ngoal (1 subgoal):\n 1. b \\<in> null_space A", "using basis_null_space"], ["proof (prove)\nusing this:\n  b \\<in> vec.span (basis_null_space A)\n  vec.independent (basis_null_space ?A) \\<and>\n  null_space ?A = vec.span (basis_null_space ?A)\n\ngoal (1 subgoal):\n 1. b \\<in> null_space A", "by blast"], ["proof (state)\nthis:\n  b \\<in> solution_set A 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {fst (the (solve A b))} + solution_set A 0 =\n  {fst (the (solve A b))} + vec.span (snd (the (solve A b)))\n\ngoal (1 subgoal):\n 1. solution_set A b =\n    {fst (the (solve A b))} + vec.span (snd (the (solve A b)))", "finally"], ["proof (chain)\npicking this:\n  solution_set A b =\n  {fst (the (solve A b))} + vec.span (snd (the (solve A b)))", "show \"solution_set A b = {fst (the (solve A b))} + vec.span (snd (the (solve A b)))\""], ["proof (prove)\nusing this:\n  solution_set A b =\n  {fst (the (solve A b))} + vec.span (snd (the (solve A b)))\n\ngoal (1 subgoal):\n 1. solution_set A b =\n    {fst (the (solve A b))} + vec.span (snd (the (solve A b)))", "."], ["proof (state)\nthis:\n  solution_set A b =\n  {fst (the (solve A b))} + vec.span (snd (the (solve A b)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_solution_eq_in_span_solve:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes con: \"consistent A b\"\n  shows \"(is_solution x A b) = (x \\<in> {fst (the (solve A b))} + vec.span (snd (the (solve A b))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_solution x A b =\n    (x \\<in> {fst (the (solve A b))} + vec.span (snd (the (solve A b))))", "using solution_set_rel_solve[OF con]"], ["proof (prove)\nusing this:\n  solution_set A b =\n  {fst (the (solve A b))} + vec.span (snd (the (solve A b)))\n\ngoal (1 subgoal):\n 1. is_solution x A b =\n    (x \\<in> {fst (the (solve A b))} + vec.span (snd (the (solve A b))))", "unfolding solution_set_def"], ["proof (prove)\nusing this:\n  {x. is_solution x A b} =\n  {fst (the (solve A b))} + vec.span (snd (the (solve A b)))\n\ngoal (1 subgoal):\n 1. is_solution x A b =\n    (x \\<in> {fst (the (solve A b))} + vec.span (snd (the (solve A b))))", "by auto"], ["", "end"]]}