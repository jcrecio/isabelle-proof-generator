{"file_name": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan/System_Of_Equations_IArrays.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan", "problem_names": ["lemma vec_to_iarray_exists:\nshows \"(\\<exists>b. A $ b \\<noteq> 0) = IArray.exists (\\<lambda>b. (vec_to_iarray A) !! b \\<noteq> 0) (IArray[0..<IArray.length (vec_to_iarray A)])\"", "lemma not_is_zero_iarray_eq_iff: \"(\\<exists>b. A $ b \\<noteq> 0) = (\\<not> is_zero_iarray (vec_to_iarray A))\"", "lemma vec_to_iarray_greatest_not_zero:\nassumes ex_b: \"(\\<exists>b. A $ b \\<noteq> 0)\"\nshows \"greatest_not_zero (vec_to_iarray A) = to_nat (GREATEST b. A $ b \\<noteq> 0)\"", "lemma matrix_to_iarray_consistent[code]: \"consistent A b = consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\"", "lemma matrix_to_iarray_inconsistent[code]: \"inconsistent A b = inconsistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\"", "lemma exists_solve_consistent_rref:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nassumes rref: \"reduced_row_echelon_form A\"\nshows \"(\\<exists>i. A $ i $ j = 1 \\<and> j = (LEAST n. A $ i $ n \\<noteq> 0)) \n  = (IArray.exists (\\<lambda>i. (matrix_to_iarray A) !! i !! (to_nat j) = 1\n  \\<and> (to_nat j)=least_non_zero_position_of_vector (row_iarray i (matrix_to_iarray A))) (IArray[0..<nrows_iarray (matrix_to_iarray A)]))\"", "lemma to_nat_the_solve_consistent_rref: \nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nassumes rref: \"reduced_row_echelon_form A\"\nand exists: \"(\\<exists>i. A $ i $ j = 1 \\<and> j = (LEAST n. A $ i $ n \\<noteq> 0))\"\nshows \"to_nat (THE i. A $ i $ j = 1) = least_non_zero_position_of_vector (column_iarray (to_nat j) (matrix_to_iarray A))\"", "lemma iarray_exhaust2: \n\"(xs = ys) = (IArray.list_of xs = IArray.list_of ys)\"", "lemma vec_to_iarray_solve_consistent_rref:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nassumes rref: \"reduced_row_echelon_form A\"\nshows \"vec_to_iarray (solve_consistent_rref A b) = solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b)\"", "lemma matrix_to_iarray_independent_and_consistent[code]:\nshows \"independent_and_consistent A b = independent_and_consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\"", "lemma matrix_to_iarray_dependent_and_consistent[code]:\nshows \"dependent_and_consistent A b = dependent_and_consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\"", "lemma matrix_to_iarray_fst_solve_system: \"matrix_to_iarray (fst (solve_system A b)) = fst (solve_system_iarrays (matrix_to_iarray A) (vec_to_iarray b))\"", "lemma vec_to_iarray_snd_solve_system: \"vec_to_iarray (snd (solve_system A b)) = snd (solve_system_iarrays (matrix_to_iarray A) (vec_to_iarray b))\"", "lemma pair_vec_vecset_solve[code_unfold]:\nshows \"pair_vec_vecset (solve A b) = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)\""], "translations": [["", "lemma vec_to_iarray_exists:\nshows \"(\\<exists>b. A $ b \\<noteq> 0) = IArray.exists (\\<lambda>b. (vec_to_iarray A) !! b \\<noteq> 0) (IArray[0..<IArray.length (vec_to_iarray A)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>b. A $ b \\<noteq> (0::'b)) =\n    IArray.exists (\\<lambda>b. vec_to_iarray A !! b \\<noteq> (0::'b))\n     (IArray [0..<IArray.length (vec_to_iarray A)])", "proof (unfold IArray.exists_def length_vec_to_iarray, auto simp del: IArray.sub_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       A $ b \\<noteq> (0::'b) \\<Longrightarrow>\n       \\<exists>b\\<in>{0..<CARD('a)}. vec_to_iarray A !! b \\<noteq> (0::'b)\n 2. \\<And>b.\n       \\<lbrakk>b < CARD('a); vec_to_iarray A !! b \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. A $ b \\<noteq> (0::'b)", "fix b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       A $ b \\<noteq> (0::'b) \\<Longrightarrow>\n       \\<exists>b\\<in>{0..<CARD('a)}. vec_to_iarray A !! b \\<noteq> (0::'b)\n 2. \\<And>b.\n       \\<lbrakk>b < CARD('a); vec_to_iarray A !! b \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. A $ b \\<noteq> (0::'b)", "assume Ab: \"A $ b \\<noteq> 0\""], ["proof (state)\nthis:\n  A $ b \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       A $ b \\<noteq> (0::'b) \\<Longrightarrow>\n       \\<exists>b\\<in>{0..<CARD('a)}. vec_to_iarray A !! b \\<noteq> (0::'b)\n 2. \\<And>b.\n       \\<lbrakk>b < CARD('a); vec_to_iarray A !! b \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. A $ b \\<noteq> (0::'b)", "show \"\\<exists>b\\<in>{0..<CARD('a)}. vec_to_iarray A !! b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b\\<in>{0..<CARD('a)}. vec_to_iarray A !! b \\<noteq> (0::'b)", "by (rule bexI[of _ \"to_nat b\"], unfold vec_to_iarray_nth', auto simp add: Ab to_nat_less_card[of b])"], ["proof (state)\nthis:\n  \\<exists>b\\<in>{0..<CARD('a)}. vec_to_iarray A !! b \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b < CARD('a); vec_to_iarray A !! b \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. A $ b \\<noteq> (0::'b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b < CARD('a); vec_to_iarray A !! b \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. A $ b \\<noteq> (0::'b)", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b < CARD('a); vec_to_iarray A !! b \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. A $ b \\<noteq> (0::'b)", "assume b: \"b < CARD('a)\" and Ab_vec: \"vec_to_iarray A !! b \\<noteq> 0\""], ["proof (state)\nthis:\n  b < CARD('a)\n  vec_to_iarray A !! b \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b < CARD('a); vec_to_iarray A !! b \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. A $ b \\<noteq> (0::'b)", "show \"\\<exists>b. A $ b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b. A $ b \\<noteq> (0::'b)", "by (rule exI[of _ \"from_nat b\"], metis Ab_vec vec_to_iarray_nth[OF b])"], ["proof (state)\nthis:\n  \\<exists>b. A $ b \\<noteq> (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary vec_to_iarray_exists':\nshows \"(\\<exists>b. A $ b \\<noteq> 0) = IArray.exists (\\<lambda>b. (vec_to_iarray A) !! b \\<noteq> 0) (IArray (rev [0..<IArray.length (vec_to_iarray A)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>b. A $ b \\<noteq> (0::'b)) =\n    IArray.exists (\\<lambda>b. vec_to_iarray A !! b \\<noteq> (0::'b))\n     (IArray (rev [0..<IArray.length (vec_to_iarray A)]))", "by (simp add: vec_to_iarray_exists Option.is_none_def find_None_iff)"], ["", "lemma not_is_zero_iarray_eq_iff: \"(\\<exists>b. A $ b \\<noteq> 0) = (\\<not> is_zero_iarray (vec_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>b. A $ b \\<noteq> (0::'b)) =\n    (\\<not> is_zero_iarray (vec_to_iarray A))", "by (metis (full_types) is_zero_iarray_eq_iff vec_eq_iff zero_index)"], ["", "lemma vec_to_iarray_greatest_not_zero:\nassumes ex_b: \"(\\<exists>b. A $ b \\<noteq> 0)\"\nshows \"greatest_not_zero (vec_to_iarray A) = to_nat (GREATEST b. A $ b \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. greatest_not_zero (vec_to_iarray A) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. greatest_not_zero (vec_to_iarray A) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "let ?P=\"(\\<lambda>n. (vec_to_iarray A) !! n \\<noteq> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. greatest_not_zero (vec_to_iarray A) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "let ?xs=\"(rev [0..<IArray.length (vec_to_iarray A)])\""], ["proof (state)\ngoal (1 subgoal):\n 1. greatest_not_zero (vec_to_iarray A) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "have \"\\<exists>a. (List.find ?P ?xs) = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       find (\\<lambda>n. vec_to_iarray A !! n \\<noteq> (0::'b))\n        (rev [0..<IArray.length (vec_to_iarray A)]) =\n       Some a", "proof(rule ccontr, simp, unfold find_None_iff)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       x \\<in> set (rev [0..<\n                         length (IArray.list_of (vec_to_iarray A))]) \\<and>\n       IArray.list_of (vec_to_iarray A) ! x \\<noteq>\n       (0::'b) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>x. x \\<in> set (rev [0..<length (IArray.list_of (vec_to_iarray A))]) \\<and> IArray.list_of (vec_to_iarray A) ! x \\<noteq> 0)\""], ["proof (state)\nthis:\n  \\<nexists>x.\n     x \\<in> set (rev [0..<\n                       length (IArray.list_of (vec_to_iarray A))]) \\<and>\n     IArray.list_of (vec_to_iarray A) ! x \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       x \\<in> set (rev [0..<\n                         length (IArray.list_of (vec_to_iarray A))]) \\<and>\n       IArray.list_of (vec_to_iarray A) ! x \\<noteq>\n       (0::'b) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     x \\<in> set (rev [0..<\n                       length (IArray.list_of (vec_to_iarray A))]) \\<and>\n     IArray.list_of (vec_to_iarray A) ! x \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. False", "using ex_b"], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     x \\<in> set (rev [0..<\n                       length (IArray.list_of (vec_to_iarray A))]) \\<and>\n     IArray.list_of (vec_to_iarray A) ! x \\<noteq> (0::'b)\n  \\<exists>b. A $ b \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. False", "unfolding set_rev"], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     x \\<in> set [0..<length (IArray.list_of (vec_to_iarray A))] \\<and>\n     IArray.list_of (vec_to_iarray A) ! x \\<noteq> (0::'b)\n  \\<exists>b. A $ b \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. False", "by (auto, unfold IArray.length_def[symmetric] IArray.sub_def[symmetric] length_vec_to_iarray,metis to_nat_less_card vec_to_iarray_nth')"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a.\n     find (\\<lambda>n. vec_to_iarray A !! n \\<noteq> (0::'b))\n      (rev [0..<IArray.length (vec_to_iarray A)]) =\n     Some a\n\ngoal (1 subgoal):\n 1. greatest_not_zero (vec_to_iarray A) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "from this"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     find (\\<lambda>n. vec_to_iarray A !! n \\<noteq> (0::'b))\n      (rev [0..<IArray.length (vec_to_iarray A)]) =\n     Some a", "obtain a where a: \"(List.find ?P ?xs) = Some a\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     find (\\<lambda>n. vec_to_iarray A !! n \\<noteq> (0::'b))\n      (rev [0..<IArray.length (vec_to_iarray A)]) =\n     Some a\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        find (\\<lambda>n. vec_to_iarray A !! n \\<noteq> (0::'b))\n         (rev [0..<IArray.length (vec_to_iarray A)]) =\n        Some a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  find (\\<lambda>n. vec_to_iarray A !! n \\<noteq> (0::'b))\n   (rev [0..<IArray.length (vec_to_iarray A)]) =\n  Some a\n\ngoal (1 subgoal):\n 1. greatest_not_zero (vec_to_iarray A) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "from this"], ["proof (chain)\npicking this:\n  find (\\<lambda>n. vec_to_iarray A !! n \\<noteq> (0::'b))\n   (rev [0..<IArray.length (vec_to_iarray A)]) =\n  Some a", "obtain ia where ia_less_length: \"ia<length ?xs\"\nand P_xs_ia: \"?P (?xs!ia)\" and a_eq: \"a = ?xs!ia\" and all_zero: \"(\\<forall>j<ia. \\<not> ?P (?xs!j))\""], ["proof (prove)\nusing this:\n  find (\\<lambda>n. vec_to_iarray A !! n \\<noteq> (0::'b))\n   (rev [0..<IArray.length (vec_to_iarray A)]) =\n  Some a\n\ngoal (1 subgoal):\n 1. (\\<And>ia.\n        \\<lbrakk>ia < length (rev [0..<IArray.length (vec_to_iarray A)]);\n         vec_to_iarray A !!\n         (rev [0..<IArray.length (vec_to_iarray A)] ! ia) \\<noteq>\n         (0::'b);\n         a = rev [0..<IArray.length (vec_to_iarray A)] ! ia;\n         \\<forall>j<ia.\n            \\<not> vec_to_iarray A !!\n                   (rev [0..<IArray.length (vec_to_iarray A)] ! j) \\<noteq>\n                   (0::'b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding find_Some_iff"], ["proof (prove)\nusing this:\n  \\<exists>i<length (rev [0..<IArray.length (vec_to_iarray A)]).\n     vec_to_iarray A !!\n     (rev [0..<IArray.length (vec_to_iarray A)] ! i) \\<noteq>\n     (0::'b) \\<and>\n     a = rev [0..<IArray.length (vec_to_iarray A)] ! i \\<and>\n     (\\<forall>j<i.\n         \\<not> vec_to_iarray A !!\n                (rev [0..<IArray.length (vec_to_iarray A)] ! j) \\<noteq>\n                (0::'b))\n\ngoal (1 subgoal):\n 1. (\\<And>ia.\n        \\<lbrakk>ia < length (rev [0..<IArray.length (vec_to_iarray A)]);\n         vec_to_iarray A !!\n         (rev [0..<IArray.length (vec_to_iarray A)] ! ia) \\<noteq>\n         (0::'b);\n         a = rev [0..<IArray.length (vec_to_iarray A)] ! ia;\n         \\<forall>j<ia.\n            \\<not> vec_to_iarray A !!\n                   (rev [0..<IArray.length (vec_to_iarray A)] ! j) \\<noteq>\n                   (0::'b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ia < length (rev [0..<IArray.length (vec_to_iarray A)])\n  vec_to_iarray A !!\n  (rev [0..<IArray.length (vec_to_iarray A)] ! ia) \\<noteq>\n  (0::'b)\n  a = rev [0..<IArray.length (vec_to_iarray A)] ! ia\n  \\<forall>j<ia.\n     \\<not> vec_to_iarray A !!\n            (rev [0..<IArray.length (vec_to_iarray A)] ! j) \\<noteq>\n            (0::'b)\n\ngoal (1 subgoal):\n 1. greatest_not_zero (vec_to_iarray A) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "have ia_less_card: \"ia < CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia < CARD('a)", "using ia_less_length"], ["proof (prove)\nusing this:\n  ia < length (rev [0..<IArray.length (vec_to_iarray A)])\n\ngoal (1 subgoal):\n 1. ia < CARD('a)", "by (metis diff_zero length_rev length_upt length_vec_to_iarray)"], ["proof (state)\nthis:\n  ia < CARD('a)\n\ngoal (1 subgoal):\n 1. greatest_not_zero (vec_to_iarray A) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "have ia_less_length': \"ia < length ([0..<IArray.length (vec_to_iarray A)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia < length [0..<IArray.length (vec_to_iarray A)]", "using ia_less_length"], ["proof (prove)\nusing this:\n  ia < length (rev [0..<IArray.length (vec_to_iarray A)])\n\ngoal (1 subgoal):\n 1. ia < length [0..<IArray.length (vec_to_iarray A)]", "unfolding length_rev"], ["proof (prove)\nusing this:\n  ia < length [0..<IArray.length (vec_to_iarray A)]\n\ngoal (1 subgoal):\n 1. ia < length [0..<IArray.length (vec_to_iarray A)]", "."], ["proof (state)\nthis:\n  ia < length [0..<IArray.length (vec_to_iarray A)]\n\ngoal (1 subgoal):\n 1. greatest_not_zero (vec_to_iarray A) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "have a_less_card: \"a < CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < CARD('a)", "unfolding a_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev [0..<IArray.length (vec_to_iarray A)] ! ia < CARD('a)", "unfolding rev_nth[OF ia_less_length']"], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<IArray.length (vec_to_iarray A)] !\n    (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\n    < CARD('a)", "using nth_upt[of 0 \"(length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\" \"(length [0..<IArray.length (vec_to_iarray A)])\" ]"], ["proof (prove)\nusing this:\n  0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\n  < length [0..<IArray.length (vec_to_iarray A)] \\<Longrightarrow>\n  [0..<length [0..<IArray.length (vec_to_iarray A)]] !\n  (length [0..<IArray.length (vec_to_iarray A)] - Suc ia) =\n  0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\n\ngoal (1 subgoal):\n 1. [0..<IArray.length (vec_to_iarray A)] !\n    (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\n    < CARD('a)", "by (metis diff_less length_upt length_vec_to_iarray minus_nat.diff_0 plus_nat.add_0 zero_less_Suc zero_less_card_finite)"], ["proof (state)\nthis:\n  a < CARD('a)\n\ngoal (1 subgoal):\n 1. greatest_not_zero (vec_to_iarray A) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "have \"(GREATEST b. A $ b \\<noteq> 0) = from_nat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST b. A $ b \\<noteq> (0::'b)) = mod_type_class.from_nat a", "proof (rule Greatest_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ mod_type_class.from_nat a \\<noteq> (0::'b)\n 2. \\<And>y.\n       A $ y \\<noteq> (0::'b) \\<Longrightarrow>\n       y \\<le> mod_type_class.from_nat a", "have \"A $ from_nat a = (vec_to_iarray A) !! a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat a = vec_to_iarray A !! a", "by (rule vec_to_iarray_nth[symmetric,OF a_less_card])"], ["proof (state)\nthis:\n  A $ mod_type_class.from_nat a = vec_to_iarray A !! a\n\ngoal (2 subgoals):\n 1. A $ mod_type_class.from_nat a \\<noteq> (0::'b)\n 2. \\<And>y.\n       A $ y \\<noteq> (0::'b) \\<Longrightarrow>\n       y \\<le> mod_type_class.from_nat a", "also"], ["proof (state)\nthis:\n  A $ mod_type_class.from_nat a = vec_to_iarray A !! a\n\ngoal (2 subgoals):\n 1. A $ mod_type_class.from_nat a \\<noteq> (0::'b)\n 2. \\<And>y.\n       A $ y \\<noteq> (0::'b) \\<Longrightarrow>\n       y \\<le> mod_type_class.from_nat a", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray A !! a \\<noteq> (0::'b)", "using P_xs_ia"], ["proof (prove)\nusing this:\n  vec_to_iarray A !!\n  (rev [0..<IArray.length (vec_to_iarray A)] ! ia) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. vec_to_iarray A !! a \\<noteq> (0::'b)", "unfolding a_eq[symmetric]"], ["proof (prove)\nusing this:\n  vec_to_iarray A !! a \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. vec_to_iarray A !! a \\<noteq> (0::'b)", "."], ["proof (state)\nthis:\n  vec_to_iarray A !! a \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. A $ mod_type_class.from_nat a \\<noteq> (0::'b)\n 2. \\<And>y.\n       A $ y \\<noteq> (0::'b) \\<Longrightarrow>\n       y \\<le> mod_type_class.from_nat a", "finally"], ["proof (chain)\npicking this:\n  A $ mod_type_class.from_nat a \\<noteq> (0::'b)", "show \"A $ from_nat a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A $ mod_type_class.from_nat a \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat a \\<noteq> (0::'b)", "."], ["proof (state)\nthis:\n  A $ mod_type_class.from_nat a \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ y \\<noteq> (0::'b) \\<Longrightarrow>\n       y \\<le> mod_type_class.from_nat a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ y \\<noteq> (0::'b) \\<Longrightarrow>\n       y \\<le> mod_type_class.from_nat a", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ y \\<noteq> (0::'b) \\<Longrightarrow>\n       y \\<le> mod_type_class.from_nat a", "assume Ay: \"A $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  A $ y \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ y \\<noteq> (0::'b) \\<Longrightarrow>\n       y \\<le> mod_type_class.from_nat a", "show \"y \\<le> from_nat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> mod_type_class.from_nat a", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "assume \"\\<not> y \\<le> from_nat a\""], ["proof (state)\nthis:\n  \\<not> y \\<le> mod_type_class.from_nat a\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "hence y_greater_a: \"y > from_nat a\""], ["proof (prove)\nusing this:\n  \\<not> y \\<le> mod_type_class.from_nat a\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat a < y", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat a < y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "have y_greater_a': \"to_nat y > a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < mod_type_class.to_nat y", "using y_greater_a"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat a < y\n\ngoal (1 subgoal):\n 1. a < mod_type_class.to_nat y", "using to_nat_mono[of \"from_nat a\" y]"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat a < y\n  mod_type_class.from_nat a < y \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat a)\n  < mod_type_class.to_nat y\n\ngoal (1 subgoal):\n 1. a < mod_type_class.to_nat y", "using to_nat_from_nat_id"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat a < y\n  mod_type_class.from_nat a < y \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat a)\n  < mod_type_class.to_nat y\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n\ngoal (1 subgoal):\n 1. a < mod_type_class.to_nat y", "by (metis a_less_card)"], ["proof (state)\nthis:\n  a < mod_type_class.to_nat y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "have \"a = ?xs ! ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = rev [0..<IArray.length (vec_to_iarray A)] ! ia", "using a_eq"], ["proof (prove)\nusing this:\n  a = rev [0..<IArray.length (vec_to_iarray A)] ! ia\n\ngoal (1 subgoal):\n 1. a = rev [0..<IArray.length (vec_to_iarray A)] ! ia", "."], ["proof (state)\nthis:\n  a = rev [0..<IArray.length (vec_to_iarray A)] ! ia\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  a = rev [0..<IArray.length (vec_to_iarray A)] ! ia\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "have \"... = [0..<IArray.length (vec_to_iarray A)] ! (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev [0..<IArray.length (vec_to_iarray A)] ! ia =\n    [0..<IArray.length (vec_to_iarray A)] !\n    (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)", "by (rule rev_nth[OF ia_less_length'])"], ["proof (state)\nthis:\n  rev [0..<IArray.length (vec_to_iarray A)] ! ia =\n  [0..<IArray.length (vec_to_iarray A)] !\n  (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  rev [0..<IArray.length (vec_to_iarray A)] ! ia =\n  [0..<IArray.length (vec_to_iarray A)] !\n  (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "have \"... = 0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<IArray.length (vec_to_iarray A)] !\n    (length [0..<IArray.length (vec_to_iarray A)] - Suc ia) =\n    0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)", "apply (rule nth_upt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\n    < IArray.length (vec_to_iarray A)", "using ia_less_length'"], ["proof (prove)\nusing this:\n  ia < length [0..<IArray.length (vec_to_iarray A)]\n\ngoal (1 subgoal):\n 1. 0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\n    < IArray.length (vec_to_iarray A)", "by fastforce"], ["proof (state)\nthis:\n  [0..<IArray.length (vec_to_iarray A)] !\n  (length [0..<IArray.length (vec_to_iarray A)] - Suc ia) =\n  0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  [0..<IArray.length (vec_to_iarray A)] !\n  (length [0..<IArray.length (vec_to_iarray A)] - Suc ia) =\n  0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "have \"... = (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ia) =\n    length [0..<IArray.length (vec_to_iarray A)] - Suc ia", "by simp"], ["proof (state)\nthis:\n  0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ia) =\n  length [0..<IArray.length (vec_to_iarray A)] - Suc ia\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  a = length [0..<IArray.length (vec_to_iarray A)] - Suc ia", "have \"a = (length [0..<IArray.length (vec_to_iarray A)] - Suc ia)\""], ["proof (prove)\nusing this:\n  a = length [0..<IArray.length (vec_to_iarray A)] - Suc ia\n\ngoal (1 subgoal):\n 1. a = length [0..<IArray.length (vec_to_iarray A)] - Suc ia", "."], ["proof (state)\nthis:\n  a = length [0..<IArray.length (vec_to_iarray A)] - Suc ia\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "hence ia_eq: \"ia = length [0..<IArray.length (vec_to_iarray A)] - (Suc a)\""], ["proof (prove)\nusing this:\n  a = length [0..<IArray.length (vec_to_iarray A)] - Suc ia\n\ngoal (1 subgoal):\n 1. ia = length [0..<IArray.length (vec_to_iarray A)] - Suc a", "by (metis Suc_diff_Suc Suc_eq_plus1_left diff_diff_cancel less_imp_le ia_less_length length_rev)"], ["proof (state)\nthis:\n  ia = length [0..<IArray.length (vec_to_iarray A)] - Suc a\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "define ja where \"ja = length [0..<IArray.length (vec_to_iarray A)] - to_nat y - 1\""], ["proof (state)\nthis:\n  ja =\n  length [0..<IArray.length (vec_to_iarray A)] - mod_type_class.to_nat y - 1\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "have ja_less_length: \"ja < length [0..<IArray.length (vec_to_iarray A)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ja < length [0..<IArray.length (vec_to_iarray A)]", "unfolding ja_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [0..<IArray.length (vec_to_iarray A)] - mod_type_class.to_nat y -\n    1\n    < length [0..<IArray.length (vec_to_iarray A)]", "using ia_eq ia_less_length'"], ["proof (prove)\nusing this:\n  ia = length [0..<IArray.length (vec_to_iarray A)] - Suc a\n  ia < length [0..<IArray.length (vec_to_iarray A)]\n\ngoal (1 subgoal):\n 1. length [0..<IArray.length (vec_to_iarray A)] - mod_type_class.to_nat y -\n    1\n    < length [0..<IArray.length (vec_to_iarray A)]", "by (simp add: algebra_simps )"], ["proof (state)\nthis:\n  ja < length [0..<IArray.length (vec_to_iarray A)]\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "have suc_i_le: \"IArray.length (vec_to_iarray A)\\<ge>Suc (to_nat y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat y) \\<le> IArray.length (vec_to_iarray A)", "unfolding vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat y)\n    \\<le> IArray.length\n           (IArray.of_fun (\\<lambda>i. A $ mod_type_class.from_nat i)\n             CARD('a))", "using to_nat_less_card[of y]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat y < CARD('a)\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat y)\n    \\<le> IArray.length\n           (IArray.of_fun (\\<lambda>i. A $ mod_type_class.from_nat i)\n             CARD('a))", "by auto"], ["proof (state)\nthis:\n  Suc (mod_type_class.to_nat y) \\<le> IArray.length (vec_to_iarray A)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "have \"?xs ! ja = [0..<IArray.length (vec_to_iarray A)] ! (length [0..<IArray.length (vec_to_iarray A)] - Suc ja)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev [0..<IArray.length (vec_to_iarray A)] ! ja =\n    [0..<IArray.length (vec_to_iarray A)] !\n    (length [0..<IArray.length (vec_to_iarray A)] - Suc ja)", "unfolding rev_nth[OF ja_less_length]"], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<IArray.length (vec_to_iarray A)] !\n    (length [0..<IArray.length (vec_to_iarray A)] - Suc ja) =\n    [0..<IArray.length (vec_to_iarray A)] !\n    (length [0..<IArray.length (vec_to_iarray A)] - Suc ja)", ".."], ["proof (state)\nthis:\n  rev [0..<IArray.length (vec_to_iarray A)] ! ja =\n  [0..<IArray.length (vec_to_iarray A)] !\n  (length [0..<IArray.length (vec_to_iarray A)] - Suc ja)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  rev [0..<IArray.length (vec_to_iarray A)] ! ja =\n  [0..<IArray.length (vec_to_iarray A)] !\n  (length [0..<IArray.length (vec_to_iarray A)] - Suc ja)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "have \"... = 0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ja)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<IArray.length (vec_to_iarray A)] !\n    (length [0..<IArray.length (vec_to_iarray A)] - Suc ja) =\n    0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ja)", "apply (rule nth_upt, auto simp del: IArray.length_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (vec_to_iarray A) - Suc ja\n    < IArray.length (vec_to_iarray A)", "unfolding ja_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (vec_to_iarray A) -\n    Suc (length [0..<IArray.length (vec_to_iarray A)] -\n         mod_type_class.to_nat y -\n         1)\n    < IArray.length (vec_to_iarray A)", "by (metis diff_Suc_less ia_less_length' length_upt less_nat_zero_code minus_nat.diff_0 neq0_conv)"], ["proof (state)\nthis:\n  [0..<IArray.length (vec_to_iarray A)] !\n  (length [0..<IArray.length (vec_to_iarray A)] - Suc ja) =\n  0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ja)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  [0..<IArray.length (vec_to_iarray A)] !\n  (length [0..<IArray.length (vec_to_iarray A)] - Suc ja) =\n  0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ja)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "have \"... = (length [0..<IArray.length (vec_to_iarray A)] - Suc ja)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ja) =\n    length [0..<IArray.length (vec_to_iarray A)] - Suc ja", "by simp"], ["proof (state)\nthis:\n  0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ja) =\n  length [0..<IArray.length (vec_to_iarray A)] - Suc ja\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  0 + (length [0..<IArray.length (vec_to_iarray A)] - Suc ja) =\n  length [0..<IArray.length (vec_to_iarray A)] - Suc ja\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "have \"... = to_nat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [0..<IArray.length (vec_to_iarray A)] - Suc ja =\n    mod_type_class.to_nat y", "unfolding ja_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [0..<IArray.length (vec_to_iarray A)] -\n    Suc (length [0..<IArray.length (vec_to_iarray A)] -\n         mod_type_class.to_nat y -\n         1) =\n    mod_type_class.to_nat y", "using suc_i_le"], ["proof (prove)\nusing this:\n  Suc (mod_type_class.to_nat y) \\<le> IArray.length (vec_to_iarray A)\n\ngoal (1 subgoal):\n 1. length [0..<IArray.length (vec_to_iarray A)] -\n    Suc (length [0..<IArray.length (vec_to_iarray A)] -\n         mod_type_class.to_nat y -\n         1) =\n    mod_type_class.to_nat y", "by force"], ["proof (state)\nthis:\n  length [0..<IArray.length (vec_to_iarray A)] - Suc ja =\n  mod_type_class.to_nat y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  rev [0..<IArray.length (vec_to_iarray A)] ! ja = mod_type_class.to_nat y", "have xs_ja_eq_y: \"?xs ! ja = to_nat y\""], ["proof (prove)\nusing this:\n  rev [0..<IArray.length (vec_to_iarray A)] ! ja = mod_type_class.to_nat y\n\ngoal (1 subgoal):\n 1. rev [0..<IArray.length (vec_to_iarray A)] ! ja = mod_type_class.to_nat y", "."], ["proof (state)\nthis:\n  rev [0..<IArray.length (vec_to_iarray A)] ! ja = mod_type_class.to_nat y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "have ja_less_ia: \"ja < ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ja < ia", "unfolding ja_def ia_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [0..<IArray.length (vec_to_iarray A)] - mod_type_class.to_nat y -\n    1\n    < length [0..<IArray.length (vec_to_iarray A)] - Suc a", "by (auto simp del: IArray.length_def, metis Suc_leI suc_i_le diff_less_mono2 le_imp_less_Suc less_le_trans y_greater_a')"], ["proof (state)\nthis:\n  ja < ia\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "hence eq_0: \"vec_to_iarray A !! (?xs ! ja) = 0\""], ["proof (prove)\nusing this:\n  ja < ia\n\ngoal (1 subgoal):\n 1. vec_to_iarray A !! (rev [0..<IArray.length (vec_to_iarray A)] ! ja) =\n    (0::'b)", "using all_zero"], ["proof (prove)\nusing this:\n  ja < ia\n  \\<forall>j<ia.\n     \\<not> vec_to_iarray A !!\n            (rev [0..<IArray.length (vec_to_iarray A)] ! j) \\<noteq>\n            (0::'b)\n\ngoal (1 subgoal):\n 1. vec_to_iarray A !! (rev [0..<IArray.length (vec_to_iarray A)] ! ja) =\n    (0::'b)", "by simp"], ["proof (state)\nthis:\n  vec_to_iarray A !! (rev [0..<IArray.length (vec_to_iarray A)] ! ja) =\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "hence \"A $ y = 0\""], ["proof (prove)\nusing this:\n  vec_to_iarray A !! (rev [0..<IArray.length (vec_to_iarray A)] ! ja) =\n  (0::'b)\n\ngoal (1 subgoal):\n 1. A $ y = (0::'b)", "using vec_to_iarray_nth'[of A y]"], ["proof (prove)\nusing this:\n  vec_to_iarray A !! (rev [0..<IArray.length (vec_to_iarray A)] ! ja) =\n  (0::'b)\n  vec_to_iarray A !! mod_type_class.to_nat y = A $ y\n\ngoal (1 subgoal):\n 1. A $ y = (0::'b)", "unfolding xs_ja_eq_y"], ["proof (prove)\nusing this:\n  vec_to_iarray A !! mod_type_class.to_nat y = (0::'b)\n  vec_to_iarray A !! mod_type_class.to_nat y = A $ y\n\ngoal (1 subgoal):\n 1. A $ y = (0::'b)", "by simp"], ["proof (state)\nthis:\n  A $ y = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> mod_type_class.from_nat a \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  A $ y = (0::'b)\n\ngoal (1 subgoal):\n 1. False", "using Ay"], ["proof (prove)\nusing this:\n  A $ y = (0::'b)\n  A $ y \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<le> mod_type_class.from_nat a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (GREATEST b. A $ b \\<noteq> (0::'b)) = mod_type_class.from_nat a\n\ngoal (1 subgoal):\n 1. greatest_not_zero (vec_to_iarray A) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (GREATEST b. A $ b \\<noteq> (0::'b)) = mod_type_class.from_nat a\n\ngoal (1 subgoal):\n 1. greatest_not_zero (vec_to_iarray A) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "unfolding greatest_not_zero_def a"], ["proof (prove)\nusing this:\n  (GREATEST b. A $ b \\<noteq> (0::'b)) = mod_type_class.from_nat a\n\ngoal (1 subgoal):\n 1. the (Some a) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "unfolding to_nat_eq[symmetric]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b)) =\n  mod_type_class.to_nat (mod_type_class.from_nat a)\n\ngoal (1 subgoal):\n 1. the (Some a) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "unfolding to_nat_from_nat_id[OF a_less_card]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b)) = a\n\ngoal (1 subgoal):\n 1. the (Some a) =\n    mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))", "by simp"], ["proof (state)\nthis:\n  greatest_not_zero (vec_to_iarray A) =\n  mod_type_class.to_nat (GREATEST b. A $ b \\<noteq> (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Consistency and inconsistency\\<close>"], ["", "definition \"consistent_iarrays A b = (let GJ=Gauss_Jordan_iarrays_PA A; \n                                           rank_A = length [x\\<leftarrow>IArray.list_of (snd GJ) . \\<not> is_zero_iarray x];\n                                           P_mult_b = fst(GJ) *iv b\n                                           in (rank_A \\<ge> (if  (\\<not> is_zero_iarray P_mult_b) \n                                           then (greatest_not_zero P_mult_b + 1) else 0)))\""], ["", "definition \"inconsistent_iarrays A b = (\\<not> consistent_iarrays A b)\""], ["", "lemma matrix_to_iarray_consistent[code]: \"consistent A b = consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent A b =\n    consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "unfolding consistent_eq_rank_ge_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let GJ_P = Gauss_Jordan_PA A; P_mult_b = fst GJ_P *v b\n     in Let (if A = 0 then 0\n             else mod_type_class.to_nat\n                   (GREATEST a. row a (snd GJ_P) \\<noteq> 0) +\n                  1)\n         ((\\<le>)\n           (if \\<exists>a. P_mult_b $ a \\<noteq> (0::'a)\n            then mod_type_class.to_nat\n                  (GREATEST a. P_mult_b $ a \\<noteq> (0::'a)) +\n                 1\n            else 0))) =\n    consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "unfolding consistent_iarrays_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a.\n                (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> (if A = 0 then 0\n            else mod_type_class.to_nat\n                  (GREATEST a. row a (snd (Gauss_Jordan_PA A)) \\<noteq> 0) +\n                 1)) =\n    ((if \\<not> is_zero_iarray\n                 (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                  vec_to_iarray b)\n      then greatest_not_zero\n            (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n             vec_to_iarray b) +\n           1\n      else 0)\n     \\<le> length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of\n                (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A))))))", "unfolding Gauss_Jordan_PA_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a.\n                (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> (if A = 0 then 0\n            else mod_type_class.to_nat\n                  (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n                 1)) =\n    ((if \\<not> is_zero_iarray\n                 (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                  vec_to_iarray b)\n      then greatest_not_zero\n            (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n             vec_to_iarray b) +\n           1\n      else 0)\n     \\<le> length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of\n                (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A))))))", "unfolding rank_Gauss_Jordan_code[symmetric, unfolded Let_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a.\n                (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> rank A) =\n    ((if \\<not> is_zero_iarray\n                 (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                  vec_to_iarray b)\n      then greatest_not_zero\n            (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n             vec_to_iarray b) +\n           1\n      else 0)\n     \\<le> length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of\n                (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A))))))", "unfolding snd_Gauss_Jordan_iarrays_PA_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a.\n                (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> rank A) =\n    ((if \\<not> is_zero_iarray\n                 (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                  vec_to_iarray b)\n      then greatest_not_zero\n            (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n             vec_to_iarray b) +\n           1\n      else 0)\n     \\<le> length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (Gauss_Jordan_iarrays (matrix_to_iarray A)))))", "unfolding rank_iarrays_code[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a.\n                (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> rank A) =\n    ((if \\<not> is_zero_iarray\n                 (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                  vec_to_iarray b)\n      then greatest_not_zero\n            (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n             vec_to_iarray b) +\n           1\n      else 0)\n     \\<le> rank_iarray (matrix_to_iarray A))", "unfolding matrix_to_iarray_rank"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a.\n                (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> rank_iarray (matrix_to_iarray A)) =\n    ((if \\<not> is_zero_iarray\n                 (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                  vec_to_iarray b)\n      then greatest_not_zero\n            (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n             vec_to_iarray b) +\n           1\n      else 0)\n     \\<le> rank_iarray (matrix_to_iarray A))", "unfolding matrix_to_iarray_fst_Gauss_Jordan_PA[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a.\n                (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> rank_iarray (matrix_to_iarray A)) =\n    ((if \\<not> is_zero_iarray\n                 (matrix_to_iarray (fst (Gauss_Jordan_PA A)) *iv\n                  vec_to_iarray b)\n      then greatest_not_zero\n            (matrix_to_iarray (fst (Gauss_Jordan_PA A)) *iv\n             vec_to_iarray b) +\n           1\n      else 0)\n     \\<le> rank_iarray (matrix_to_iarray A))", "unfolding vec_to_iarray_matrix_matrix_mult[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if \\<exists>a. (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)\n      then mod_type_class.to_nat\n            (GREATEST a.\n                (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> rank_iarray (matrix_to_iarray A)) =\n    ((if \\<not> is_zero_iarray\n                 (vec_to_iarray (fst (Gauss_Jordan_PA A) *v b))\n      then greatest_not_zero\n            (vec_to_iarray (fst (Gauss_Jordan_PA A) *v b)) +\n           1\n      else 0)\n     \\<le> rank_iarray (matrix_to_iarray A))", "unfolding not_is_zero_iarray_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if \\<not> is_zero_iarray\n                 (vec_to_iarray (fst (Gauss_Jordan_PA A) *v b))\n      then mod_type_class.to_nat\n            (GREATEST a.\n                (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> rank_iarray (matrix_to_iarray A)) =\n    ((if \\<not> is_zero_iarray\n                 (vec_to_iarray (fst (Gauss_Jordan_PA A) *v b))\n      then greatest_not_zero\n            (vec_to_iarray (fst (Gauss_Jordan_PA A) *v b)) +\n           1\n      else 0)\n     \\<le> rank_iarray (matrix_to_iarray A))", "using vec_to_iarray_greatest_not_zero[unfolded not_is_zero_iarray_eq_iff]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_iarray (vec_to_iarray ?A) \\<Longrightarrow>\n  greatest_not_zero (vec_to_iarray ?A) =\n  mod_type_class.to_nat (GREATEST b. ?A $ b \\<noteq> (0::?'b))\n\ngoal (1 subgoal):\n 1. ((if \\<not> is_zero_iarray\n                 (vec_to_iarray (fst (Gauss_Jordan_PA A) *v b))\n      then mod_type_class.to_nat\n            (GREATEST a.\n                (fst (Gauss_Jordan_PA A) *v b) $ a \\<noteq> (0::'a)) +\n           1\n      else 0)\n     \\<le> rank_iarray (matrix_to_iarray A)) =\n    ((if \\<not> is_zero_iarray\n                 (vec_to_iarray (fst (Gauss_Jordan_PA A) *v b))\n      then greatest_not_zero\n            (vec_to_iarray (fst (Gauss_Jordan_PA A) *v b)) +\n           1\n      else 0)\n     \\<le> rank_iarray (matrix_to_iarray A))", "by force"], ["", "lemma matrix_to_iarray_inconsistent[code]: \"inconsistent A b = inconsistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsistent A b =\n    inconsistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "unfolding inconsistent_def inconsistent_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> consistent A b) =\n    (\\<not> consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b))", "unfolding matrix_to_iarray_consistent"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)) =\n    (\\<not> consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b))", ".."], ["", "definition \"solve_consistent_rref_iarrays A b \n  = IArray.of_fun (\\<lambda>j. if (IArray.exists (\\<lambda>i. A !! i !! j = 1 \\<and> j=least_non_zero_position_of_vector (row_iarray i A)) (IArray[0..<nrows_iarray A]))\n  then b !! (least_non_zero_position_of_vector (column_iarray j A)) else 0) (ncols_iarray A)\""], ["", "lemma exists_solve_consistent_rref:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nassumes rref: \"reduced_row_echelon_form A\"\nshows \"(\\<exists>i. A $ i $ j = 1 \\<and> j = (LEAST n. A $ i $ n \\<noteq> 0)) \n  = (IArray.exists (\\<lambda>i. (matrix_to_iarray A) !! i !! (to_nat j) = 1\n  \\<and> (to_nat j)=least_non_zero_position_of_vector (row_iarray i (matrix_to_iarray A))) (IArray[0..<nrows_iarray (matrix_to_iarray A)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i.\n        A $ i $ j = (1::'a) \\<and>\n        j = (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)])", "proof (rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i.\n       A $ i $ j = (1::'a) \\<and>\n       j = (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)])\n 2. IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)]) \\<Longrightarrow>\n    \\<exists>i.\n       A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))", "assume \"\\<exists>i. A $ i $ j = 1 \\<and> j = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (state)\nthis:\n  \\<exists>i.\n     A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. \\<exists>i.\n       A $ i $ j = (1::'a) \\<and>\n       j = (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)])\n 2. IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)]) \\<Longrightarrow>\n    \\<exists>i.\n       A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))", "from this"], ["proof (chain)\npicking this:\n  \\<exists>i.\n     A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))", "obtain i where Aij: \"A $ i $ j = 1\" and j_eq: \"j = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  \\<exists>i.\n     A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>A $ i $ j = (1::'a);\n         j = (LEAST n. A $ i $ n \\<noteq> (0::'a))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A $ i $ j = (1::'a)\n  j = (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. \\<exists>i.\n       A $ i $ j = (1::'a) \\<and>\n       j = (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n    IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)])\n 2. IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)]) \\<Longrightarrow>\n    \\<exists>i.\n       A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))", "show \"IArray.exists (\\<lambda>i. matrix_to_iarray A !! i !! to_nat j = 1 \\<and> to_nat j = least_non_zero_position_of_vector (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)])", "unfolding IArray.exists_def find_Some_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>set (IArray.list_of\n                         (IArray [0..<nrows_iarray (matrix_to_iarray A)])).\n       matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n       mod_type_class.to_nat j =\n       least_non_zero_position_of_vector (row_iarray i (matrix_to_iarray A))", "apply (rule bexI[of _ \"to_nat i\"])+"], ["proof (prove)\ngoal (2 subgoals):\n 1. matrix_to_iarray A !! mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    (1::'a) \\<and>\n    mod_type_class.to_nat j =\n    least_non_zero_position_of_vector\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))\n 2. mod_type_class.to_nat i\n    \\<in> set (IArray.list_of\n                (IArray [0..<nrows_iarray (matrix_to_iarray A)]))", "proof (auto, unfold IArray.sub_def[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. matrix_to_iarray A !! mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    (1::'a)\n 2. mod_type_class.to_nat j =\n    least_non_zero_position_of_vector\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))\n 3. mod_type_class.to_nat i < nrows_iarray (matrix_to_iarray A)", "show \"to_nat i < nrows_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < nrows_iarray (matrix_to_iarray A)", "unfolding matrix_to_iarray_nrows[symmetric] nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('rows)", "using to_nat_less_card"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?j < CARD(?'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('rows)", "by fast"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < nrows_iarray (matrix_to_iarray A)\n\ngoal (2 subgoals):\n 1. matrix_to_iarray A !! mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    (1::'a)\n 2. mod_type_class.to_nat j =\n    least_non_zero_position_of_vector\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))", "have \"to_nat j = to_nat (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j =\n    mod_type_class.to_nat (LEAST n. A $ i $ n \\<noteq> (0::'a))", "unfolding j_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    mod_type_class.to_nat (LEAST n. A $ i $ n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat j =\n  mod_type_class.to_nat (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. matrix_to_iarray A !! mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    (1::'a)\n 2. mod_type_class.to_nat j =\n    least_non_zero_position_of_vector\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))", "also"], ["proof (state)\nthis:\n  mod_type_class.to_nat j =\n  mod_type_class.to_nat (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. matrix_to_iarray A !! mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    (1::'a)\n 2. mod_type_class.to_nat j =\n    least_non_zero_position_of_vector\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))", "have \"... = to_nat (LEAST n. A $ i $ n \\<noteq> 0 \\<and> 0\\<le>n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    mod_type_class.to_nat\n     (LEAST n. A $ i $ n \\<noteq> (0::'a) \\<and> (0::'cols) \\<le> n)", "by (metis least_mod_type)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  mod_type_class.to_nat\n   (LEAST n. A $ i $ n \\<noteq> (0::'a) \\<and> (0::'cols) \\<le> n)\n\ngoal (2 subgoals):\n 1. matrix_to_iarray A !! mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    (1::'a)\n 2. mod_type_class.to_nat j =\n    least_non_zero_position_of_vector\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))", "also"], ["proof (state)\nthis:\n  mod_type_class.to_nat (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  mod_type_class.to_nat\n   (LEAST n. A $ i $ n \\<noteq> (0::'a) \\<and> (0::'cols) \\<le> n)\n\ngoal (2 subgoals):\n 1. matrix_to_iarray A !! mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    (1::'a)\n 2. mod_type_class.to_nat j =\n    least_non_zero_position_of_vector\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))", "have \"...= least_non_zero_position_of_vector_from_index (vec_to_iarray (row i A)) (to_nat (0::'cols))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (LEAST n. A $ i $ n \\<noteq> (0::'a) \\<and> (0::'cols) \\<le> n) =\n    least_non_zero_position_of_vector_from_index (vec_to_iarray (row i A))\n     (mod_type_class.to_nat (0::'cols))", "proof (rule vec_to_iarray_least_non_zero_position_of_vector_from_index''[symmetric, of \"0::'cols\" i A])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> vector_all_zero_from_index\n            (mod_type_class.to_nat (0::'cols), vec_to_iarray (row i A))", "show \"\\<not> vector_all_zero_from_index (to_nat (0::'cols), vec_to_iarray (row i A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> vector_all_zero_from_index\n            (mod_type_class.to_nat (0::'cols), vec_to_iarray (row i A))", "unfolding vector_all_zero_from_index_eq[symmetric, of \"0::'cols\" \"row i A\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<ge>0::'cols. row i A $ m = (0::'a))", "unfolding row_def vec_nth_inverse"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<ge>0::'cols. A $ i $ m = (0::'a))", "using Aij least_mod_type[of j]"], ["proof (prove)\nusing this:\n  A $ i $ j = (1::'a)\n  (0::'cols) \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<ge>0::'cols. A $ i $ m = (0::'a))", "by fastforce"], ["proof (state)\nthis:\n  \\<not> vector_all_zero_from_index\n          (mod_type_class.to_nat (0::'cols), vec_to_iarray (row i A))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (LEAST n. A $ i $ n \\<noteq> (0::'a) \\<and> (0::'cols) \\<le> n) =\n  least_non_zero_position_of_vector_from_index (vec_to_iarray (row i A))\n   (mod_type_class.to_nat (0::'cols))\n\ngoal (2 subgoals):\n 1. matrix_to_iarray A !! mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    (1::'a)\n 2. mod_type_class.to_nat j =\n    least_non_zero_position_of_vector\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))", "also"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (LEAST n. A $ i $ n \\<noteq> (0::'a) \\<and> (0::'cols) \\<le> n) =\n  least_non_zero_position_of_vector_from_index (vec_to_iarray (row i A))\n   (mod_type_class.to_nat (0::'cols))\n\ngoal (2 subgoals):\n 1. matrix_to_iarray A !! mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    (1::'a)\n 2. mod_type_class.to_nat j =\n    least_non_zero_position_of_vector\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))", "have \"... = least_non_zero_position_of_vector (row_iarray (to_nat i) (matrix_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index (vec_to_iarray (row i A))\n     (mod_type_class.to_nat (0::'cols)) =\n    least_non_zero_position_of_vector\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))", "unfolding vec_to_iarray_row least_non_zero_position_of_vector_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))\n     (mod_type_class.to_nat (0::'cols)) =\n    least_non_zero_position_of_vector_from_index\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A)) 0", "unfolding to_nat_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A)) 0 =\n    least_non_zero_position_of_vector_from_index\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A)) 0", ".."], ["proof (state)\nthis:\n  least_non_zero_position_of_vector_from_index (vec_to_iarray (row i A))\n   (mod_type_class.to_nat (0::'cols)) =\n  least_non_zero_position_of_vector\n   (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))\n\ngoal (2 subgoals):\n 1. matrix_to_iarray A !! mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    (1::'a)\n 2. mod_type_class.to_nat j =\n    least_non_zero_position_of_vector\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))", "finally"], ["proof (chain)\npicking this:\n  mod_type_class.to_nat j =\n  least_non_zero_position_of_vector\n   (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))", "show \"to_nat j = least_non_zero_position_of_vector (row_iarray (to_nat i) (matrix_to_iarray A))\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j =\n  least_non_zero_position_of_vector\n   (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j =\n    least_non_zero_position_of_vector\n     (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))", "."], ["proof (state)\nthis:\n  mod_type_class.to_nat j =\n  least_non_zero_position_of_vector\n   (row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. matrix_to_iarray A !! mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    (1::'a)", "show \"matrix_to_iarray A !! mod_type_class.to_nat i !! mod_type_class.to_nat j = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray A !! mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    (1::'a)", "unfolding matrix_to_iarray_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j = (1::'a)", "using Aij"], ["proof (prove)\nusing this:\n  A $ i $ j = (1::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ j = (1::'a)", "."], ["proof (state)\nthis:\n  matrix_to_iarray A !! mod_type_class.to_nat i !! mod_type_class.to_nat j =\n  (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  IArray.exists\n   (\\<lambda>i.\n       matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n       mod_type_class.to_nat j =\n       least_non_zero_position_of_vector\n        (row_iarray i (matrix_to_iarray A)))\n   (IArray [0..<nrows_iarray (matrix_to_iarray A)])\n\ngoal (1 subgoal):\n 1. IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)]) \\<Longrightarrow>\n    \\<exists>i.\n       A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)]) \\<Longrightarrow>\n    \\<exists>i.\n       A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))", "assume ex_eq: \"IArray.exists (\\<lambda>i. matrix_to_iarray A !! i !! to_nat j = 1 \\<and> to_nat j = least_non_zero_position_of_vector (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)])\""], ["proof (state)\nthis:\n  IArray.exists\n   (\\<lambda>i.\n       matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n       mod_type_class.to_nat j =\n       least_non_zero_position_of_vector\n        (row_iarray i (matrix_to_iarray A)))\n   (IArray [0..<nrows_iarray (matrix_to_iarray A)])\n\ngoal (1 subgoal):\n 1. IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)]) \\<Longrightarrow>\n    \\<exists>i.\n       A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))", "have \"\\<exists>y. List.find (\\<lambda>i. matrix_to_iarray A !! i !! to_nat j = 1 \\<and> to_nat j = least_non_zero_position_of_vector (row_iarray i (matrix_to_iarray A)))\n         [0..<nrows_iarray (matrix_to_iarray A)] = Some y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       find\n        (\\<lambda>i.\n            matrix_to_iarray A !! i !! mod_type_class.to_nat j =\n            (1::'a) \\<and>\n            mod_type_class.to_nat j =\n            least_non_zero_position_of_vector\n             (row_iarray i (matrix_to_iarray A)))\n        [0..<nrows_iarray (matrix_to_iarray A)] =\n       Some y", "proof (rule ccontr, simp del: IArray.length_def IArray.sub_def, unfold find_None_iff)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       x \\<in> set [0..<nrows_iarray (matrix_to_iarray A)] \\<and>\n       matrix_to_iarray A !! x !! mod_type_class.to_nat j = (1::'a) \\<and>\n       mod_type_class.to_nat j =\n       least_non_zero_position_of_vector\n        (row_iarray x (matrix_to_iarray A)) \\<Longrightarrow>\n    False", "assume\" \\<not> (\\<exists>x. x \\<in> set [0..<nrows_iarray (matrix_to_iarray A)] \\<and>\n            matrix_to_iarray A !! x !! mod_type_class.to_nat j = 1 \\<and> mod_type_class.to_nat j = least_non_zero_position_of_vector (row_iarray x (matrix_to_iarray A)))\""], ["proof (state)\nthis:\n  \\<nexists>x.\n     x \\<in> set [0..<nrows_iarray (matrix_to_iarray A)] \\<and>\n     matrix_to_iarray A !! x !! mod_type_class.to_nat j = (1::'a) \\<and>\n     mod_type_class.to_nat j =\n     least_non_zero_position_of_vector (row_iarray x (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       x \\<in> set [0..<nrows_iarray (matrix_to_iarray A)] \\<and>\n       matrix_to_iarray A !! x !! mod_type_class.to_nat j = (1::'a) \\<and>\n       mod_type_class.to_nat j =\n       least_non_zero_position_of_vector\n        (row_iarray x (matrix_to_iarray A)) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     x \\<in> set [0..<nrows_iarray (matrix_to_iarray A)] \\<and>\n     matrix_to_iarray A !! x !! mod_type_class.to_nat j = (1::'a) \\<and>\n     mod_type_class.to_nat j =\n     least_non_zero_position_of_vector (row_iarray x (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. False", "using ex_eq"], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     x \\<in> set [0..<nrows_iarray (matrix_to_iarray A)] \\<and>\n     matrix_to_iarray A !! x !! mod_type_class.to_nat j = (1::'a) \\<and>\n     mod_type_class.to_nat j =\n     least_non_zero_position_of_vector (row_iarray x (matrix_to_iarray A))\n  IArray.exists\n   (\\<lambda>i.\n       matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n       mod_type_class.to_nat j =\n       least_non_zero_position_of_vector\n        (row_iarray i (matrix_to_iarray A)))\n   (IArray [0..<nrows_iarray (matrix_to_iarray A)])\n\ngoal (1 subgoal):\n 1. False", "unfolding IArray.exists_def"], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     x \\<in> set [0..<nrows_iarray (matrix_to_iarray A)] \\<and>\n     matrix_to_iarray A !! x !! mod_type_class.to_nat j = (1::'a) \\<and>\n     mod_type_class.to_nat j =\n     least_non_zero_position_of_vector (row_iarray x (matrix_to_iarray A))\n  \\<exists>i\\<in>set (IArray.list_of\n                       (IArray [0..<nrows_iarray (matrix_to_iarray A)])).\n     matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n     mod_type_class.to_nat j =\n     least_non_zero_position_of_vector (row_iarray i (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y.\n     find\n      (\\<lambda>i.\n          matrix_to_iarray A !! i !! mod_type_class.to_nat j =\n          (1::'a) \\<and>\n          mod_type_class.to_nat j =\n          least_non_zero_position_of_vector\n           (row_iarray i (matrix_to_iarray A)))\n      [0..<nrows_iarray (matrix_to_iarray A)] =\n     Some y\n\ngoal (1 subgoal):\n 1. IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)]) \\<Longrightarrow>\n    \\<exists>i.\n       A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))", "from this"], ["proof (chain)\npicking this:\n  \\<exists>y.\n     find\n      (\\<lambda>i.\n          matrix_to_iarray A !! i !! mod_type_class.to_nat j =\n          (1::'a) \\<and>\n          mod_type_class.to_nat j =\n          least_non_zero_position_of_vector\n           (row_iarray i (matrix_to_iarray A)))\n      [0..<nrows_iarray (matrix_to_iarray A)] =\n     Some y", "obtain y where y: \"List.find (\\<lambda>i. matrix_to_iarray A !! i !! to_nat j = 1 \\<and> to_nat j = least_non_zero_position_of_vector (row_iarray i (matrix_to_iarray A)))\n         [0..<nrows_iarray (matrix_to_iarray A)] = Some y\""], ["proof (prove)\nusing this:\n  \\<exists>y.\n     find\n      (\\<lambda>i.\n          matrix_to_iarray A !! i !! mod_type_class.to_nat j =\n          (1::'a) \\<and>\n          mod_type_class.to_nat j =\n          least_non_zero_position_of_vector\n           (row_iarray i (matrix_to_iarray A)))\n      [0..<nrows_iarray (matrix_to_iarray A)] =\n     Some y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        find\n         (\\<lambda>i.\n             matrix_to_iarray A !! i !! mod_type_class.to_nat j =\n             (1::'a) \\<and>\n             mod_type_class.to_nat j =\n             least_non_zero_position_of_vector\n              (row_iarray i (matrix_to_iarray A)))\n         [0..<nrows_iarray (matrix_to_iarray A)] =\n        Some y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  find\n   (\\<lambda>i.\n       matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n       mod_type_class.to_nat j =\n       least_non_zero_position_of_vector\n        (row_iarray i (matrix_to_iarray A)))\n   [0..<nrows_iarray (matrix_to_iarray A)] =\n  Some y\n\ngoal (1 subgoal):\n 1. IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)]) \\<Longrightarrow>\n    \\<exists>i.\n       A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))", "from this"], ["proof (chain)\npicking this:\n  find\n   (\\<lambda>i.\n       matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n       mod_type_class.to_nat j =\n       least_non_zero_position_of_vector\n        (row_iarray i (matrix_to_iarray A)))\n   [0..<nrows_iarray (matrix_to_iarray A)] =\n  Some y", "obtain i where i_less_length: \"i<length [0..<nrows_iarray (matrix_to_iarray A)]\" and\n     Aij_1: \"matrix_to_iarray A !! ([0..<nrows_iarray (matrix_to_iarray A)] ! i) !! to_nat j = 1\"\nand j_eq: \"to_nat j = least_non_zero_position_of_vector (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i) (matrix_to_iarray A))\" and \n  y_eq: \"y = [0..<nrows_iarray (matrix_to_iarray A)] ! i\"\n    and least: \"(\\<forall>ja<i. \\<not> (matrix_to_iarray A !! ([0..<nrows_iarray (matrix_to_iarray A)] ! ja) !! to_nat j = 1 \\<and>\n                to_nat j = least_non_zero_position_of_vector (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! ja) (matrix_to_iarray A))))\""], ["proof (prove)\nusing this:\n  find\n   (\\<lambda>i.\n       matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n       mod_type_class.to_nat j =\n       least_non_zero_position_of_vector\n        (row_iarray i (matrix_to_iarray A)))\n   [0..<nrows_iarray (matrix_to_iarray A)] =\n  Some y\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length [0..<nrows_iarray (matrix_to_iarray A)];\n         matrix_to_iarray A !!\n         ([0..<nrows_iarray (matrix_to_iarray A)] ! i) !!\n         mod_type_class.to_nat j =\n         (1::'a);\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i)\n            (matrix_to_iarray A));\n         y = [0..<nrows_iarray (matrix_to_iarray A)] ! i;\n         \\<forall>ja<i.\n            \\<not> (matrix_to_iarray A !!\n                    ([0..<nrows_iarray (matrix_to_iarray A)] ! ja) !!\n                    mod_type_class.to_nat j =\n                    (1::'a) \\<and>\n                    mod_type_class.to_nat j =\n                    least_non_zero_position_of_vector\n                     (row_iarray\n                       ([0..<nrows_iarray (matrix_to_iarray A)] ! ja)\n                       (matrix_to_iarray A)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding find_Some_iff"], ["proof (prove)\nusing this:\n  \\<exists>i<length [0..<nrows_iarray (matrix_to_iarray A)].\n     (matrix_to_iarray A !! ([0..<nrows_iarray (matrix_to_iarray A)] ! i) !!\n      mod_type_class.to_nat j =\n      (1::'a) \\<and>\n      mod_type_class.to_nat j =\n      least_non_zero_position_of_vector\n       (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i)\n         (matrix_to_iarray A))) \\<and>\n     y = [0..<nrows_iarray (matrix_to_iarray A)] ! i \\<and>\n     (\\<forall>ja<i.\n         \\<not> (matrix_to_iarray A !!\n                 ([0..<nrows_iarray (matrix_to_iarray A)] ! ja) !!\n                 mod_type_class.to_nat j =\n                 (1::'a) \\<and>\n                 mod_type_class.to_nat j =\n                 least_non_zero_position_of_vector\n                  (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! ja)\n                    (matrix_to_iarray A))))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length [0..<nrows_iarray (matrix_to_iarray A)];\n         matrix_to_iarray A !!\n         ([0..<nrows_iarray (matrix_to_iarray A)] ! i) !!\n         mod_type_class.to_nat j =\n         (1::'a);\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i)\n            (matrix_to_iarray A));\n         y = [0..<nrows_iarray (matrix_to_iarray A)] ! i;\n         \\<forall>ja<i.\n            \\<not> (matrix_to_iarray A !!\n                    ([0..<nrows_iarray (matrix_to_iarray A)] ! ja) !!\n                    mod_type_class.to_nat j =\n                    (1::'a) \\<and>\n                    mod_type_class.to_nat j =\n                    least_non_zero_position_of_vector\n                     (row_iarray\n                       ([0..<nrows_iarray (matrix_to_iarray A)] ! ja)\n                       (matrix_to_iarray A)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i < length [0..<nrows_iarray (matrix_to_iarray A)]\n  matrix_to_iarray A !! ([0..<nrows_iarray (matrix_to_iarray A)] ! i) !!\n  mod_type_class.to_nat j =\n  (1::'a)\n  mod_type_class.to_nat j =\n  least_non_zero_position_of_vector\n   (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i)\n     (matrix_to_iarray A))\n  y = [0..<nrows_iarray (matrix_to_iarray A)] ! i\n  \\<forall>ja<i.\n     \\<not> (matrix_to_iarray A !!\n             ([0..<nrows_iarray (matrix_to_iarray A)] ! ja) !!\n             mod_type_class.to_nat j =\n             (1::'a) \\<and>\n             mod_type_class.to_nat j =\n             least_non_zero_position_of_vector\n              (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! ja)\n                (matrix_to_iarray A)))\n\ngoal (1 subgoal):\n 1. IArray.exists\n     (\\<lambda>i.\n         matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a) \\<and>\n         mod_type_class.to_nat j =\n         least_non_zero_position_of_vector\n          (row_iarray i (matrix_to_iarray A)))\n     (IArray [0..<nrows_iarray (matrix_to_iarray A)]) \\<Longrightarrow>\n    \\<exists>i.\n       A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))", "show \"\\<exists>i. A $ i $ j = 1 \\<and> j = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))", "proof (rule exI[of _ \"from_nat i\"], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ mod_type_class.from_nat i $ j = (1::'a)\n 2. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "have i_rw: \"[0..<nrows_iarray (matrix_to_iarray A)] ! i = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<nrows_iarray (matrix_to_iarray A)] ! i = i", "using nth_upt[of 0 i \"nrows_iarray (matrix_to_iarray A)\"]"], ["proof (prove)\nusing this:\n  0 + i < nrows_iarray (matrix_to_iarray A) \\<Longrightarrow>\n  [0..<nrows_iarray (matrix_to_iarray A)] ! i = 0 + i\n\ngoal (1 subgoal):\n 1. [0..<nrows_iarray (matrix_to_iarray A)] ! i = i", "using i_less_length"], ["proof (prove)\nusing this:\n  0 + i < nrows_iarray (matrix_to_iarray A) \\<Longrightarrow>\n  [0..<nrows_iarray (matrix_to_iarray A)] ! i = 0 + i\n  i < length [0..<nrows_iarray (matrix_to_iarray A)]\n\ngoal (1 subgoal):\n 1. [0..<nrows_iarray (matrix_to_iarray A)] ! i = i", "by auto"], ["proof (state)\nthis:\n  [0..<nrows_iarray (matrix_to_iarray A)] ! i = i\n\ngoal (2 subgoals):\n 1. A $ mod_type_class.from_nat i $ j = (1::'a)\n 2. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "have i_less_card: \"i < CARD ('rows)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < CARD('rows)", "using i_less_length"], ["proof (prove)\nusing this:\n  i < length [0..<nrows_iarray (matrix_to_iarray A)]\n\ngoal (1 subgoal):\n 1. i < CARD('rows)", "unfolding nrows_iarray_def matrix_to_iarray_def"], ["proof (prove)\nusing this:\n  i < length\n       [0..<\n        IArray.length\n         (IArray\n           (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                 mod_type_class.from_nat)\n             [0..<CARD('rows)]))]\n\ngoal (1 subgoal):\n 1. i < CARD('rows)", "by auto"], ["proof (state)\nthis:\n  i < CARD('rows)\n\ngoal (2 subgoals):\n 1. A $ mod_type_class.from_nat i $ j = (1::'a)\n 2. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "show A_ij: \"A $ from_nat i $ j = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ j = (1::'a)", "using Aij_1"], ["proof (prove)\nusing this:\n  matrix_to_iarray A !! ([0..<nrows_iarray (matrix_to_iarray A)] ! i) !!\n  mod_type_class.to_nat j =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ j = (1::'a)", "unfolding i_rw"], ["proof (prove)\nusing this:\n  matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a)\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ j = (1::'a)", "using matrix_to_iarray_nth[of A \"from_nat i\" j]"], ["proof (prove)\nusing this:\n  matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a)\n  matrix_to_iarray A !! mod_type_class.to_nat (mod_type_class.from_nat i) !!\n  mod_type_class.to_nat j =\n  A $ mod_type_class.from_nat i $ j\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ j = (1::'a)", "unfolding to_nat_from_nat_id[OF i_less_card]"], ["proof (prove)\nusing this:\n  matrix_to_iarray A !! i !! mod_type_class.to_nat j = (1::'a)\n  matrix_to_iarray A !! i !! mod_type_class.to_nat j =\n  A $ mod_type_class.from_nat i $ j\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i $ j = (1::'a)", "by simp"], ["proof (state)\nthis:\n  A $ mod_type_class.from_nat i $ j = (1::'a)\n\ngoal (1 subgoal):\n 1. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "have \"to_nat j = least_non_zero_position_of_vector (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i) (matrix_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j =\n    least_non_zero_position_of_vector\n     (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i)\n       (matrix_to_iarray A))", "using j_eq"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j =\n  least_non_zero_position_of_vector\n   (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i)\n     (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j =\n    least_non_zero_position_of_vector\n     (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i)\n       (matrix_to_iarray A))", "."], ["proof (state)\nthis:\n  mod_type_class.to_nat j =\n  least_non_zero_position_of_vector\n   (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i)\n     (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "also"], ["proof (state)\nthis:\n  mod_type_class.to_nat j =\n  least_non_zero_position_of_vector\n   (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i)\n     (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "have \"... = least_non_zero_position_of_vector_from_index (row_iarray i (matrix_to_iarray A)) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector\n     (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i)\n       (matrix_to_iarray A)) =\n    least_non_zero_position_of_vector_from_index\n     (row_iarray i (matrix_to_iarray A)) 0", "unfolding least_non_zero_position_of_vector_def i_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index\n     (row_iarray i (matrix_to_iarray A)) 0 =\n    least_non_zero_position_of_vector_from_index\n     (row_iarray i (matrix_to_iarray A)) 0", ".."], ["proof (state)\nthis:\n  least_non_zero_position_of_vector\n   (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i)\n     (matrix_to_iarray A)) =\n  least_non_zero_position_of_vector_from_index\n   (row_iarray i (matrix_to_iarray A)) 0\n\ngoal (1 subgoal):\n 1. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "also"], ["proof (state)\nthis:\n  least_non_zero_position_of_vector\n   (row_iarray ([0..<nrows_iarray (matrix_to_iarray A)] ! i)\n     (matrix_to_iarray A)) =\n  least_non_zero_position_of_vector_from_index\n   (row_iarray i (matrix_to_iarray A)) 0\n\ngoal (1 subgoal):\n 1. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "have \"... = least_non_zero_position_of_vector_from_index (vec_to_iarray (row (from_nat i) A)) (to_nat (0::'cols))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index\n     (row_iarray i (matrix_to_iarray A)) 0 =\n    least_non_zero_position_of_vector_from_index\n     (vec_to_iarray (row (mod_type_class.from_nat i) A))\n     (mod_type_class.to_nat (0::'cols))", "unfolding vec_to_iarray_row"], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index\n     (row_iarray i (matrix_to_iarray A)) 0 =\n    least_non_zero_position_of_vector_from_index\n     (row_iarray (mod_type_class.to_nat (mod_type_class.from_nat i))\n       (matrix_to_iarray A))\n     (mod_type_class.to_nat (0::'cols))", "unfolding to_nat_from_nat_id[OF i_less_card]"], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index\n     (row_iarray i (matrix_to_iarray A)) 0 =\n    least_non_zero_position_of_vector_from_index\n     (row_iarray i (matrix_to_iarray A)) (mod_type_class.to_nat (0::'cols))", "unfolding to_nat_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index\n     (row_iarray i (matrix_to_iarray A)) 0 =\n    least_non_zero_position_of_vector_from_index\n     (row_iarray i (matrix_to_iarray A)) 0", ".."], ["proof (state)\nthis:\n  least_non_zero_position_of_vector_from_index\n   (row_iarray i (matrix_to_iarray A)) 0 =\n  least_non_zero_position_of_vector_from_index\n   (vec_to_iarray (row (mod_type_class.from_nat i) A))\n   (mod_type_class.to_nat (0::'cols))\n\ngoal (1 subgoal):\n 1. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "also"], ["proof (state)\nthis:\n  least_non_zero_position_of_vector_from_index\n   (row_iarray i (matrix_to_iarray A)) 0 =\n  least_non_zero_position_of_vector_from_index\n   (vec_to_iarray (row (mod_type_class.from_nat i) A))\n   (mod_type_class.to_nat (0::'cols))\n\ngoal (1 subgoal):\n 1. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "have \"... = to_nat (LEAST n. A $ (from_nat i) $ n \\<noteq> 0 \\<and> 0 \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index\n     (vec_to_iarray (row (mod_type_class.from_nat i) A))\n     (mod_type_class.to_nat (0::'cols)) =\n    mod_type_class.to_nat\n     (LEAST n.\n         A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a) \\<and>\n         (0::'cols) \\<le> n)", "proof (rule vec_to_iarray_least_non_zero_position_of_vector_from_index'')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> vector_all_zero_from_index\n            (mod_type_class.to_nat (0::'cols),\n             vec_to_iarray (row (mod_type_class.from_nat i) A))", "show \"\\<not> vector_all_zero_from_index (to_nat (0::'cols), vec_to_iarray (row (from_nat i) A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> vector_all_zero_from_index\n            (mod_type_class.to_nat (0::'cols),\n             vec_to_iarray (row (mod_type_class.from_nat i) A))", "unfolding vector_all_zero_from_index_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<ge>0::'cols.\n               row (mod_type_class.from_nat i) A $ m = (0::'a))", "using A_ij"], ["proof (prove)\nusing this:\n  A $ mod_type_class.from_nat i $ j = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<ge>0::'cols.\n               row (mod_type_class.from_nat i) A $ m = (0::'a))", "by (metis iarray_to_vec_vec_to_iarray least_mod_type vec_matrix vec_to_iarray_row' zero_neq_one)"], ["proof (state)\nthis:\n  \\<not> vector_all_zero_from_index\n          (mod_type_class.to_nat (0::'cols),\n           vec_to_iarray (row (mod_type_class.from_nat i) A))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  least_non_zero_position_of_vector_from_index\n   (vec_to_iarray (row (mod_type_class.from_nat i) A))\n   (mod_type_class.to_nat (0::'cols)) =\n  mod_type_class.to_nat\n   (LEAST n.\n       A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a) \\<and>\n       (0::'cols) \\<le> n)\n\ngoal (1 subgoal):\n 1. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "also"], ["proof (state)\nthis:\n  least_non_zero_position_of_vector_from_index\n   (vec_to_iarray (row (mod_type_class.from_nat i) A))\n   (mod_type_class.to_nat (0::'cols)) =\n  mod_type_class.to_nat\n   (LEAST n.\n       A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a) \\<and>\n       (0::'cols) \\<le> n)\n\ngoal (1 subgoal):\n 1. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "have \"... = to_nat (LEAST n. A $ (from_nat i) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (LEAST n.\n         A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a) \\<and>\n         (0::'cols) \\<le> n) =\n    mod_type_class.to_nat\n     (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "using least_mod_type"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (LEAST n.\n         A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a) \\<and>\n         (0::'cols) \\<le> n) =\n    mod_type_class.to_nat\n     (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "by metis"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (LEAST n.\n       A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a) \\<and>\n       (0::'cols) \\<le> n) =\n  mod_type_class.to_nat\n   (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "finally"], ["proof (chain)\npicking this:\n  mod_type_class.to_nat j =\n  mod_type_class.to_nat\n   (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "show \"j = (LEAST n. A $ from_nat i $ n \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j =\n  mod_type_class.to_nat\n   (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "unfolding to_nat_eq"], ["proof (prove)\nusing this:\n  j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))", "."], ["proof (state)\nthis:\n  j = (LEAST n. A $ mod_type_class.from_nat i $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i.\n     A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_nat_the_solve_consistent_rref: \nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nassumes rref: \"reduced_row_echelon_form A\"\nand exists: \"(\\<exists>i. A $ i $ j = 1 \\<and> j = (LEAST n. A $ i $ n \\<noteq> 0))\"\nshows \"to_nat (THE i. A $ i $ j = 1) = least_non_zero_position_of_vector (column_iarray (to_nat j) (matrix_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "obtain i where Aij: \"A $ i $ j = 1\" and j:\"j = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>A $ i $ j = (1::'a);\n         j = (LEAST n. A $ i $ n \\<noteq> (0::'a))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using exists"], ["proof (prove)\nusing this:\n  \\<exists>i.\n     A $ i $ j = (1::'a) \\<and> j = (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>A $ i $ j = (1::'a);\n         j = (LEAST n. A $ i $ n \\<noteq> (0::'a))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A $ i $ j = (1::'a)\n  j = (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "have \"least_non_zero_position_of_vector (column_iarray (to_nat j) (matrix_to_iarray A)) = \n    least_non_zero_position_of_vector (vec_to_iarray (column j A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)) =\n    least_non_zero_position_of_vector (vec_to_iarray (column j A))", "unfolding vec_to_iarray_column"], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", ".."], ["proof (state)\nthis:\n  least_non_zero_position_of_vector\n   (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)) =\n  least_non_zero_position_of_vector (vec_to_iarray (column j A))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "also"], ["proof (state)\nthis:\n  least_non_zero_position_of_vector\n   (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)) =\n  least_non_zero_position_of_vector (vec_to_iarray (column j A))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "have \"... = least_non_zero_position_of_vector_from_index (vec_to_iarray (column j A)) (to_nat (0::'rows))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector (vec_to_iarray (column j A)) =\n    least_non_zero_position_of_vector_from_index\n     (vec_to_iarray (column j A)) (mod_type_class.to_nat (0::'rows))", "unfolding least_non_zero_position_of_vector_def to_nat_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index\n     (vec_to_iarray (column j A)) 0 =\n    least_non_zero_position_of_vector_from_index\n     (vec_to_iarray (column j A)) 0", ".."], ["proof (state)\nthis:\n  least_non_zero_position_of_vector (vec_to_iarray (column j A)) =\n  least_non_zero_position_of_vector_from_index (vec_to_iarray (column j A))\n   (mod_type_class.to_nat (0::'rows))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "also"], ["proof (state)\nthis:\n  least_non_zero_position_of_vector (vec_to_iarray (column j A)) =\n  least_non_zero_position_of_vector_from_index (vec_to_iarray (column j A))\n   (mod_type_class.to_nat (0::'rows))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "have \"... = to_nat (LEAST n. A $ n $ j \\<noteq> 0 \\<and> 0 \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index\n     (vec_to_iarray (column j A)) (mod_type_class.to_nat (0::'rows)) =\n    mod_type_class.to_nat\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> (0::'rows) \\<le> n)", "proof (rule vec_to_iarray_least_non_zero_position_of_vector_from_index')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> vector_all_zero_from_index\n            (mod_type_class.to_nat (0::'rows), vec_to_iarray (column j A))", "show \"\\<not> vector_all_zero_from_index (to_nat (0::'rows), vec_to_iarray (column j A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> vector_all_zero_from_index\n            (mod_type_class.to_nat (0::'rows), vec_to_iarray (column j A))", "unfolding vector_all_zero_from_index_eq[symmetric] column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<ge>0::'rows. (\\<chi>i. A $ i $ j) $ m = (0::'a))", "using Aij least_mod_type[of i]"], ["proof (prove)\nusing this:\n  A $ i $ j = (1::'a)\n  (0::'rows) \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<ge>0::'rows. (\\<chi>i. A $ i $ j) $ m = (0::'a))", "by fastforce"], ["proof (state)\nthis:\n  \\<not> vector_all_zero_from_index\n          (mod_type_class.to_nat (0::'rows), vec_to_iarray (column j A))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  least_non_zero_position_of_vector_from_index (vec_to_iarray (column j A))\n   (mod_type_class.to_nat (0::'rows)) =\n  mod_type_class.to_nat\n   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> (0::'rows) \\<le> n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "also"], ["proof (state)\nthis:\n  least_non_zero_position_of_vector_from_index (vec_to_iarray (column j A))\n   (mod_type_class.to_nat (0::'rows)) =\n  mod_type_class.to_nat\n   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> (0::'rows) \\<le> n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "have \"... = to_nat (LEAST n. A $ n $ j \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> (0::'rows) \\<le> n) =\n    mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a))", "using least_mod_type"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> (0::'rows) \\<le> n) =\n    mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a))", "by metis"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> (0::'rows) \\<le> n) =\n  mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "finally"], ["proof (chain)\npicking this:\n  least_non_zero_position_of_vector\n   (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)) =\n  mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a))", "have least_eq: \"least_non_zero_position_of_vector (column_iarray (to_nat j) (matrix_to_iarray A)) = to_nat (LEAST n. A $ n $ j \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  least_non_zero_position_of_vector\n   (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)) =\n  mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)) =\n    mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a))", "."], ["proof (state)\nthis:\n  least_non_zero_position_of_vector\n   (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)) =\n  mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "have i_eq_least: \"i=(LEAST n. A $ n $ j \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = (LEAST n. A $ n $ j \\<noteq> (0::'a))", "proof (rule Least_equality[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ i $ j \\<noteq> (0::'a)\n 2. \\<And>y. A $ y $ j \\<noteq> (0::'a) \\<Longrightarrow> i \\<le> y", "show \"A $ i $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j \\<noteq> (0::'a)", "by (metis Aij zero_neq_one)"], ["proof (state)\nthis:\n  A $ i $ j \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y. A $ y $ j \\<noteq> (0::'a) \\<Longrightarrow> i \\<le> y", "show \"\\<And>y. A $ y $ j \\<noteq> 0 \\<Longrightarrow> i \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. A $ y $ j \\<noteq> (0::'a) \\<Longrightarrow> i \\<le> y", "by (metis (mono_tags) Aij is_zero_row_def' j order_refl rref rref_condition4 zero_neq_one)"], ["proof (state)\nthis:\n  A $ ?y $ j \\<noteq> (0::'a) \\<Longrightarrow> i \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i = (LEAST n. A $ n $ j \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "have the_eq_least_pos: \"(THE i. A $ i $ j = 1) = from_nat (least_non_zero_position_of_vector (column_iarray (to_nat j) (matrix_to_iarray A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE i. A $ i $ j = (1::'a)) =\n    mod_type_class.from_nat\n     (least_non_zero_position_of_vector\n       (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)))", "proof (rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $\n    mod_type_class.from_nat\n     (least_non_zero_position_of_vector\n       (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))) $\n    j =\n    (1::'a)\n 2. \\<And>i.\n       A $ i $ j = (1::'a) \\<Longrightarrow>\n       i =\n       mod_type_class.from_nat\n        (least_non_zero_position_of_vector\n          (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)))", "show \" A $ from_nat (least_non_zero_position_of_vector (column_iarray (to_nat j) (matrix_to_iarray A))) $ j = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $\n    mod_type_class.from_nat\n     (least_non_zero_position_of_vector\n       (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))) $\n    j =\n    (1::'a)", "unfolding least_eq from_nat_to_nat_id i_eq_least[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j = (1::'a)", "using Aij"], ["proof (prove)\nusing this:\n  A $ i $ j = (1::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ j = (1::'a)", "."], ["proof (state)\nthis:\n  A $\n  mod_type_class.from_nat\n   (least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))) $\n  j =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A $ i $ j = (1::'a) \\<Longrightarrow>\n       i =\n       mod_type_class.from_nat\n        (least_non_zero_position_of_vector\n          (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)))", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       A $ i $ j = (1::'a) \\<Longrightarrow>\n       i =\n       mod_type_class.from_nat\n        (least_non_zero_position_of_vector\n          (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)))", "assume a: \"A $ a $ j = 1\""], ["proof (state)\nthis:\n  A $ a $ j = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A $ i $ j = (1::'a) \\<Longrightarrow>\n       i =\n       mod_type_class.from_nat\n        (least_non_zero_position_of_vector\n          (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)))", "show \"a = from_nat (least_non_zero_position_of_vector (column_iarray (to_nat j) (matrix_to_iarray A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a =\n    mod_type_class.from_nat\n     (least_non_zero_position_of_vector\n       (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)))", "unfolding least_eq from_nat_to_nat_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = (LEAST n. A $ n $ j \\<noteq> (0::'a))", "by (metis Aij a i_eq_least is_zero_row_def' j rref rref_condition4_explicit zero_neq_one)"], ["proof (state)\nthis:\n  a =\n  mod_type_class.from_nat\n   (least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (THE i. A $ i $ j = (1::'a)) =\n  mod_type_class.from_nat\n   (least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "have \"to_nat (THE i. A $ i $ j = 1) = to_nat (from_nat (least_non_zero_position_of_vector (column_iarray (to_nat j) (matrix_to_iarray A)))::'rows)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    mod_type_class.to_nat\n     (mod_type_class.from_nat\n       (least_non_zero_position_of_vector\n         (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))))", "using the_eq_least_pos"], ["proof (prove)\nusing this:\n  (THE i. A $ i $ j = (1::'a)) =\n  mod_type_class.from_nat\n   (least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    mod_type_class.to_nat\n     (mod_type_class.from_nat\n       (least_non_zero_position_of_vector\n         (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))))", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n  mod_type_class.to_nat\n   (mod_type_class.from_nat\n     (least_non_zero_position_of_vector\n       (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "also"], ["proof (state)\nthis:\n  mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n  mod_type_class.to_nat\n   (mod_type_class.from_nat\n     (least_non_zero_position_of_vector\n       (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "have \"... = (least_non_zero_position_of_vector (column_iarray (to_nat j) (matrix_to_iarray A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (mod_type_class.from_nat\n       (least_non_zero_position_of_vector\n         (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)))) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "by (rule to_nat_from_nat_id, unfold least_eq, simp add: to_nat_less_card)"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (mod_type_class.from_nat\n     (least_non_zero_position_of_vector\n       (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)))) =\n  least_non_zero_position_of_vector\n   (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "also"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (mod_type_class.from_nat\n     (least_non_zero_position_of_vector\n       (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)))) =\n  least_non_zero_position_of_vector\n   (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "have \"... = to_nat (LEAST n. A $ n $ j \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)) =\n    mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a))", "unfolding least_eq from_nat_to_nat_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a)) =\n    mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a))", ".."], ["proof (state)\nthis:\n  least_non_zero_position_of_vector\n   (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A)) =\n  mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "finally"], ["proof (chain)\npicking this:\n  mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n  mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a))", "have \"(THE i. A $ i $ j = 1) = (LEAST n. A $ n $ j \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n  mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (THE i. A $ i $ j = (1::'a)) = (LEAST n. A $ n $ j \\<noteq> (0::'a))", "unfolding to_nat_eq"], ["proof (prove)\nusing this:\n  (THE i. A $ i $ j = (1::'a)) = (LEAST n. A $ n $ j \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (THE i. A $ i $ j = (1::'a)) = (LEAST n. A $ n $ j \\<noteq> (0::'a))", "."], ["proof (state)\nthis:\n  (THE i. A $ i $ j = (1::'a)) = (LEAST n. A $ n $ j \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (THE i. A $ i $ j = (1::'a)) = (LEAST n. A $ n $ j \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    least_non_zero_position_of_vector\n     (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))", "unfolding least_eq from_nat_to_nat_id"], ["proof (prove)\nusing this:\n  (THE i. A $ i $ j = (1::'a)) = (LEAST n. A $ n $ j \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n    mod_type_class.to_nat (LEAST n. A $ n $ j \\<noteq> (0::'a))", "unfolding to_nat_eq"], ["proof (prove)\nusing this:\n  (THE i. A $ i $ j = (1::'a)) = (LEAST n. A $ n $ j \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (THE i. A $ i $ j = (1::'a)) = (LEAST n. A $ n $ j \\<noteq> (0::'a))", "."], ["proof (state)\nthis:\n  mod_type_class.to_nat (THE i. A $ i $ j = (1::'a)) =\n  least_non_zero_position_of_vector\n   (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iarray_exhaust2: \n\"(xs = ys) = (IArray.list_of xs = IArray.list_of ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = ys) = (IArray.list_of xs = IArray.list_of ys)", "by (metis iarray.exhaust list_of.simps)"], ["", "lemma vec_to_iarray_solve_consistent_rref:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nassumes rref: \"reduced_row_echelon_form A\"\nshows \"vec_to_iarray (solve_consistent_rref A b) = solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (solve_consistent_rref A b) =\n    solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "proof(unfold iarray_exhaust2 list_eq_iff_nth_eq IArray.length_def[symmetric] IArray.sub_def[symmetric], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. IArray.length (vec_to_iarray (solve_consistent_rref A b)) =\n    IArray.length\n     (solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b))\n 2. \\<forall>i<IArray.length (vec_to_iarray (solve_consistent_rref A b)).\n       vec_to_iarray (solve_consistent_rref A b) !! i =\n       solve_consistent_rref_iarrays (matrix_to_iarray A)\n        (vec_to_iarray b) !!\n       i", "show \"IArray.length (vec_to_iarray (solve_consistent_rref A b)) = IArray.length (solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (vec_to_iarray (solve_consistent_rref A b)) =\n    IArray.length\n     (solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b))", "unfolding solve_consistent_rref_def solve_consistent_rref_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (vec_to_iarray\n       (\\<chi>j.\n           if \\<exists>i.\n                 A $ i $ j = (1::'a) \\<and>\n                 j = (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           then b $ (THE i. A $ i $ j = (1::'a)) else (0::'a))) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>j.\n           if IArray.exists\n               (\\<lambda>i.\n                   matrix_to_iarray A !! i !! j = (1::'a) \\<and>\n                   j =\n                   least_non_zero_position_of_vector\n                    (row_iarray i (matrix_to_iarray A)))\n               (IArray [0..<nrows_iarray (matrix_to_iarray A)])\n           then vec_to_iarray b !!\n                least_non_zero_position_of_vector\n                 (column_iarray j (matrix_to_iarray A))\n           else (0::'a))\n       (ncols_iarray (matrix_to_iarray A)))", "unfolding ncols_iarray_def matrix_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (vec_to_iarray\n       (\\<chi>j.\n           if \\<exists>i.\n                 A $ i $ j = (1::'a) \\<and>\n                 j = (LEAST n. A $ i $ n \\<noteq> (0::'a))\n           then b $ (THE i. A $ i $ j = (1::'a)) else (0::'a))) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>j.\n           if IArray.exists\n               (\\<lambda>i.\n                   IArray\n                    (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                          mod_type_class.from_nat)\n                      [0..<CARD('rows)]) !!\n                   i !!\n                   j =\n                   (1::'a) \\<and>\n                   j =\n                   least_non_zero_position_of_vector\n                    (row_iarray i\n                      (IArray\n                        (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                              mod_type_class.from_nat)\n                          [0..<CARD('rows)]))))\n               (IArray\n                 [0..<\n                  nrows_iarray\n                   (IArray\n                     (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                           mod_type_class.from_nat)\n                       [0..<CARD('rows)]))])\n           then vec_to_iarray b !!\n                least_non_zero_position_of_vector\n                 (column_iarray j\n                   (IArray\n                     (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                           mod_type_class.from_nat)\n                       [0..<CARD('rows)])))\n           else (0::'a))\n       (IArray.length\n         (IArray\n           (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                 mod_type_class.from_nat)\n             [0..<CARD('rows)]) !!\n          0)))", "by (simp add: vec_to_iarray_def)"], ["proof (state)\nthis:\n  IArray.length (vec_to_iarray (solve_consistent_rref A b)) =\n  IArray.length\n   (solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b))\n\ngoal (1 subgoal):\n 1. \\<forall>i<IArray.length (vec_to_iarray (solve_consistent_rref A b)).\n       vec_to_iarray (solve_consistent_rref A b) !! i =\n       solve_consistent_rref_iarrays (matrix_to_iarray A)\n        (vec_to_iarray b) !!\n       i", "show \"\\<forall>i<IArray.length (vec_to_iarray (solve_consistent_rref A b)). vec_to_iarray (solve_consistent_rref A b) !! i = solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b) !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<IArray.length (vec_to_iarray (solve_consistent_rref A b)).\n       vec_to_iarray (solve_consistent_rref A b) !! i =\n       solve_consistent_rref_iarrays (matrix_to_iarray A)\n        (vec_to_iarray b) !!\n       i", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length\n            (vec_to_iarray (solve_consistent_rref A b)) \\<Longrightarrow>\n       vec_to_iarray (solve_consistent_rref A b) !! i =\n       solve_consistent_rref_iarrays (matrix_to_iarray A)\n        (vec_to_iarray b) !!\n       i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length\n            (vec_to_iarray (solve_consistent_rref A b)) \\<Longrightarrow>\n       vec_to_iarray (solve_consistent_rref A b) !! i =\n       solve_consistent_rref_iarrays (matrix_to_iarray A)\n        (vec_to_iarray b) !!\n       i", "assume i: \"i < IArray.length (vec_to_iarray (solve_consistent_rref A b))\""], ["proof (state)\nthis:\n  i < IArray.length (vec_to_iarray (solve_consistent_rref A b))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length\n            (vec_to_iarray (solve_consistent_rref A b)) \\<Longrightarrow>\n       vec_to_iarray (solve_consistent_rref A b) !! i =\n       solve_consistent_rref_iarrays (matrix_to_iarray A)\n        (vec_to_iarray b) !!\n       i", "hence i_less_card: \"i<CARD('cols)\""], ["proof (prove)\nusing this:\n  i < IArray.length (vec_to_iarray (solve_consistent_rref A b))\n\ngoal (1 subgoal):\n 1. i < CARD('cols)", "unfolding vec_to_iarray_def"], ["proof (prove)\nusing this:\n  i < IArray.length\n       (IArray.of_fun\n         (\\<lambda>i. solve_consistent_rref A b $ mod_type_class.from_nat i)\n         CARD('cols))\n\ngoal (1 subgoal):\n 1. i < CARD('cols)", "by auto"], ["proof (state)\nthis:\n  i < CARD('cols)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length\n            (vec_to_iarray (solve_consistent_rref A b)) \\<Longrightarrow>\n       vec_to_iarray (solve_consistent_rref A b) !! i =\n       solve_consistent_rref_iarrays (matrix_to_iarray A)\n        (vec_to_iarray b) !!\n       i", "hence i_less_ncols: \"i<(ncols_iarray (matrix_to_iarray A))\""], ["proof (prove)\nusing this:\n  i < CARD('cols)\n\ngoal (1 subgoal):\n 1. i < ncols_iarray (matrix_to_iarray A)", "unfolding ncols_eq_card_columns"], ["proof (prove)\nusing this:\n  i < CARD('cols)\n\ngoal (1 subgoal):\n 1. i < CARD('cols)", "."], ["proof (state)\nthis:\n  i < ncols_iarray (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length\n            (vec_to_iarray (solve_consistent_rref A b)) \\<Longrightarrow>\n       vec_to_iarray (solve_consistent_rref A b) !! i =\n       solve_consistent_rref_iarrays (matrix_to_iarray A)\n        (vec_to_iarray b) !!\n       i", "show \"vec_to_iarray (solve_consistent_rref A b) !! i = solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b) !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (solve_consistent_rref A b) !! i =\n    solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b) !!\n    i", "unfolding vec_to_iarray_nth[OF i_less_card]"], ["proof (prove)\ngoal (1 subgoal):\n 1. solve_consistent_rref A b $ mod_type_class.from_nat i =\n    solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b) !!\n    i", "unfolding solve_consistent_rref_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>j.\n        if \\<exists>i.\n              A $ i $ j = (1::'a) \\<and>\n              j = (LEAST n. A $ i $ n \\<noteq> (0::'a))\n        then b $ (THE i. A $ i $ j = (1::'a)) else (0::'a)) $\n    mod_type_class.from_nat i =\n    solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b) !!\n    i", "unfolding vec_lambda_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>ia.\n           A $ ia $ mod_type_class.from_nat i = (1::'a) \\<and>\n           mod_type_class.from_nat i =\n           (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n     then b $ (THE ia. A $ ia $ mod_type_class.from_nat i = (1::'a))\n     else (0::'a)) =\n    solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b) !!\n    i", "unfolding solve_consistent_rref_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>ia.\n           A $ ia $ mod_type_class.from_nat i = (1::'a) \\<and>\n           mod_type_class.from_nat i =\n           (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n     then b $ (THE ia. A $ ia $ mod_type_class.from_nat i = (1::'a))\n     else (0::'a)) =\n    IArray.of_fun\n     (\\<lambda>j.\n         if IArray.exists\n             (\\<lambda>i.\n                 matrix_to_iarray A !! i !! j = (1::'a) \\<and>\n                 j =\n                 least_non_zero_position_of_vector\n                  (row_iarray i (matrix_to_iarray A)))\n             (IArray [0..<nrows_iarray (matrix_to_iarray A)])\n         then vec_to_iarray b !!\n              least_non_zero_position_of_vector\n               (column_iarray j (matrix_to_iarray A))\n         else (0::'a))\n     (ncols_iarray (matrix_to_iarray A)) !!\n    i", "unfolding of_fun_nth[OF i_less_ncols]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>ia.\n           A $ ia $ mod_type_class.from_nat i = (1::'a) \\<and>\n           mod_type_class.from_nat i =\n           (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n     then b $ (THE ia. A $ ia $ mod_type_class.from_nat i = (1::'a))\n     else (0::'a)) =\n    (if IArray.exists\n         (\\<lambda>ia.\n             matrix_to_iarray A !! ia !! i = (1::'a) \\<and>\n             i =\n             least_non_zero_position_of_vector\n              (row_iarray ia (matrix_to_iarray A)))\n         (IArray [0..<nrows_iarray (matrix_to_iarray A)])\n     then vec_to_iarray b !!\n          least_non_zero_position_of_vector\n           (column_iarray i (matrix_to_iarray A))\n     else (0::'a))", "unfolding exists_solve_consistent_rref[OF rref, of \"from_nat i\", symmetric, unfolded to_nat_from_nat_id[OF i_less_card]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>ia.\n           A $ ia $ mod_type_class.from_nat i = (1::'a) \\<and>\n           mod_type_class.from_nat i =\n           (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n     then b $ (THE ia. A $ ia $ mod_type_class.from_nat i = (1::'a))\n     else (0::'a)) =\n    (if \\<exists>ia.\n           A $ ia $ mod_type_class.from_nat i = (1::'a) \\<and>\n           mod_type_class.from_nat i =\n           (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n     then vec_to_iarray b !!\n          least_non_zero_position_of_vector\n           (column_iarray i (matrix_to_iarray A))\n     else (0::'a))", "using to_nat_the_solve_consistent_rref[OF rref, of \"from_nat i\", symmetric, unfolded to_nat_from_nat_id[OF i_less_card]]"], ["proof (prove)\nusing this:\n  \\<exists>ia.\n     A $ ia $ mod_type_class.from_nat i = (1::'a) \\<and>\n     mod_type_class.from_nat i =\n     (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n  least_non_zero_position_of_vector (column_iarray i (matrix_to_iarray A)) =\n  mod_type_class.to_nat\n   (THE ia. A $ ia $ mod_type_class.from_nat i = (1::'a))\n\ngoal (1 subgoal):\n 1. (if \\<exists>ia.\n           A $ ia $ mod_type_class.from_nat i = (1::'a) \\<and>\n           mod_type_class.from_nat i =\n           (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n     then b $ (THE ia. A $ ia $ mod_type_class.from_nat i = (1::'a))\n     else (0::'a)) =\n    (if \\<exists>ia.\n           A $ ia $ mod_type_class.from_nat i = (1::'a) \\<and>\n           mod_type_class.from_nat i =\n           (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n     then vec_to_iarray b !!\n          least_non_zero_position_of_vector\n           (column_iarray i (matrix_to_iarray A))\n     else (0::'a))", "using vec_to_iarray_nth'"], ["proof (prove)\nusing this:\n  \\<exists>ia.\n     A $ ia $ mod_type_class.from_nat i = (1::'a) \\<and>\n     mod_type_class.from_nat i =\n     (LEAST n. A $ ia $ n \\<noteq> (0::'a)) \\<Longrightarrow>\n  least_non_zero_position_of_vector (column_iarray i (matrix_to_iarray A)) =\n  mod_type_class.to_nat\n   (THE ia. A $ ia $ mod_type_class.from_nat i = (1::'a))\n  vec_to_iarray ?A !! mod_type_class.to_nat ?i = ?A $ ?i\n\ngoal (1 subgoal):\n 1. (if \\<exists>ia.\n           A $ ia $ mod_type_class.from_nat i = (1::'a) \\<and>\n           mod_type_class.from_nat i =\n           (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n     then b $ (THE ia. A $ ia $ mod_type_class.from_nat i = (1::'a))\n     else (0::'a)) =\n    (if \\<exists>ia.\n           A $ ia $ mod_type_class.from_nat i = (1::'a) \\<and>\n           mod_type_class.from_nat i =\n           (LEAST n. A $ ia $ n \\<noteq> (0::'a))\n     then vec_to_iarray b !!\n          least_non_zero_position_of_vector\n           (column_iarray i (matrix_to_iarray A))\n     else (0::'a))", "by metis"], ["proof (state)\nthis:\n  vec_to_iarray (solve_consistent_rref A b) !! i =\n  solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b) !! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<IArray.length (vec_to_iarray (solve_consistent_rref A b)).\n     vec_to_iarray (solve_consistent_rref A b) !! i =\n     solve_consistent_rref_iarrays (matrix_to_iarray A) (vec_to_iarray b) !!\n     i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Independence and dependence\\<close>"], ["", "definition \"independent_and_consistent_iarrays A b = \n  (let GJ = Gauss_Jordan_iarrays_PA A; \n      rank_A = length [x\\<leftarrow>IArray.list_of (snd GJ) . \\<not> is_zero_iarray x];\n      P_mult_b = fst GJ *iv b;\n      consistent_A = ((if \\<not> is_zero_iarray P_mult_b then greatest_not_zero P_mult_b + 1 else 0) \\<le> rank_A);\n      dim_solution_set = ncols_iarray A - rank_A\n      in consistent_A \\<and> dim_solution_set = 0)\""], ["", "definition \"dependent_and_consistent_iarrays A b = \n  (let GJ = Gauss_Jordan_iarrays_PA A; \n      rank_A = length [x\\<leftarrow>IArray.list_of (snd GJ) . \\<not> is_zero_iarray x];\n      P_mult_b = fst GJ *iv b;\n      consistent_A = ((if \\<not> is_zero_iarray P_mult_b then greatest_not_zero P_mult_b + 1 else 0) \\<le> rank_A);\n      dim_solution_set = ncols_iarray A - rank_A\n      in consistent_A \\<and> dim_solution_set > 0)\""], ["", "lemma matrix_to_iarray_independent_and_consistent[code]:\nshows \"independent_and_consistent A b = independent_and_consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. independent_and_consistent A b =\n    independent_and_consistent_iarrays (matrix_to_iarray A)\n     (vec_to_iarray b)", "unfolding independent_and_consistent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (consistent A b \\<and> vec.dim (solution_set A 0) = 0) =\n    independent_and_consistent_iarrays (matrix_to_iarray A)\n     (vec_to_iarray b)", "unfolding independent_and_consistent_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (consistent A b \\<and> vec.dim (solution_set A 0) = 0) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> dim_solution_set = 0)", "unfolding dim_solution_set_homogeneous_eq_dim_null_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. (consistent A b \\<and> vec.dim (null_space A) = 0) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> dim_solution_set = 0)", "unfolding matrix_to_iarray_consistent"], ["proof (prove)\ngoal (1 subgoal):\n 1. (consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b) \\<and>\n     vec.dim (null_space A) = 0) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> dim_solution_set = 0)", "unfolding consistent_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n          rank_A =\n            length\n             (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n               (IArray.list_of (snd GJ)));\n          P_mult_b = fst GJ *iv vec_to_iarray b\n      in (if \\<not> is_zero_iarray P_mult_b\n          then greatest_not_zero P_mult_b + 1 else 0)\n         \\<le> rank_A) \\<and>\n     vec.dim (null_space A) = 0) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> dim_solution_set = 0)", "unfolding dim_null_space_iarray"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n          rank_A =\n            length\n             (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n               (IArray.list_of (snd GJ)));\n          P_mult_b = fst GJ *iv vec_to_iarray b\n      in (if \\<not> is_zero_iarray P_mult_b\n          then greatest_not_zero P_mult_b + 1 else 0)\n         \\<le> rank_A) \\<and>\n     ncols_iarray (matrix_to_iarray A) - rank_iarray (matrix_to_iarray A) =\n     0) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> dim_solution_set = 0)", "unfolding rank_iarrays_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n          rank_A =\n            length\n             (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n               (IArray.list_of (snd GJ)));\n          P_mult_b = fst GJ *iv vec_to_iarray b\n      in (if \\<not> is_zero_iarray P_mult_b\n          then greatest_not_zero P_mult_b + 1 else 0)\n         \\<le> rank_A) \\<and>\n     ncols_iarray (matrix_to_iarray A) -\n     length\n      (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n        (IArray.list_of (Gauss_Jordan_iarrays (matrix_to_iarray A)))) =\n     0) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> dim_solution_set = 0)", "unfolding snd_Gauss_Jordan_iarrays_PA_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n          rank_A =\n            length\n             (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n               (IArray.list_of (snd GJ)));\n          P_mult_b = fst GJ *iv vec_to_iarray b\n      in (if \\<not> is_zero_iarray P_mult_b\n          then greatest_not_zero P_mult_b + 1 else 0)\n         \\<le> rank_A) \\<and>\n     ncols_iarray (matrix_to_iarray A) -\n     length\n      (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n        (IArray.list_of\n          (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A))))) =\n     0) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> dim_solution_set = 0)", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if \\<not> is_zero_iarray\n                 (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                  vec_to_iarray b)\n      then greatest_not_zero\n            (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n             vec_to_iarray b) +\n           1\n      else 0)\n     \\<le> length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of\n                (snd (Gauss_Jordan_iarrays_PA\n                       (matrix_to_iarray A))))) \\<and>\n     ncols_iarray (matrix_to_iarray A) -\n     length\n      (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n        (IArray.list_of\n          (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A))))) =\n     0) =\n    ((if \\<not> is_zero_iarray\n                 (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                  vec_to_iarray b)\n      then greatest_not_zero\n            (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n             vec_to_iarray b) +\n           1\n      else 0)\n     \\<le> length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of\n                (snd (Gauss_Jordan_iarrays_PA\n                       (matrix_to_iarray A))))) \\<and>\n     ncols_iarray (matrix_to_iarray A) -\n     length\n      (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n        (IArray.list_of\n          (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A))))) =\n     0)", ".."], ["", "lemma matrix_to_iarray_dependent_and_consistent[code]:\nshows \"dependent_and_consistent A b = dependent_and_consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dependent_and_consistent A b =\n    dependent_and_consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "unfolding dependent_and_consistent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (consistent A b \\<and> 0 < vec.dim (solution_set A 0)) =\n    dependent_and_consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "unfolding dependent_and_consistent_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (consistent A b \\<and> 0 < vec.dim (solution_set A 0)) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> 0 < dim_solution_set)", "unfolding dim_solution_set_homogeneous_eq_dim_null_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. (consistent A b \\<and> 0 < vec.dim (null_space A)) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> 0 < dim_solution_set)", "unfolding matrix_to_iarray_consistent"], ["proof (prove)\ngoal (1 subgoal):\n 1. (consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b) \\<and>\n     0 < vec.dim (null_space A)) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> 0 < dim_solution_set)", "unfolding consistent_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n          rank_A =\n            length\n             (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n               (IArray.list_of (snd GJ)));\n          P_mult_b = fst GJ *iv vec_to_iarray b\n      in (if \\<not> is_zero_iarray P_mult_b\n          then greatest_not_zero P_mult_b + 1 else 0)\n         \\<le> rank_A) \\<and>\n     0 < vec.dim (null_space A)) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> 0 < dim_solution_set)", "unfolding dim_null_space_iarray"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n          rank_A =\n            length\n             (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n               (IArray.list_of (snd GJ)));\n          P_mult_b = fst GJ *iv vec_to_iarray b\n      in (if \\<not> is_zero_iarray P_mult_b\n          then greatest_not_zero P_mult_b + 1 else 0)\n         \\<le> rank_A) \\<and>\n     0 < ncols_iarray (matrix_to_iarray A) -\n         rank_iarray (matrix_to_iarray A)) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> 0 < dim_solution_set)", "unfolding rank_iarrays_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n          rank_A =\n            length\n             (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n               (IArray.list_of (snd GJ)));\n          P_mult_b = fst GJ *iv vec_to_iarray b\n      in (if \\<not> is_zero_iarray P_mult_b\n          then greatest_not_zero P_mult_b + 1 else 0)\n         \\<le> rank_A) \\<and>\n     0 < ncols_iarray (matrix_to_iarray A) -\n         length\n          (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n            (IArray.list_of (Gauss_Jordan_iarrays (matrix_to_iarray A))))) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> 0 < dim_solution_set)", "unfolding snd_Gauss_Jordan_iarrays_PA_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n          rank_A =\n            length\n             (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n               (IArray.list_of (snd GJ)));\n          P_mult_b = fst GJ *iv vec_to_iarray b\n      in (if \\<not> is_zero_iarray P_mult_b\n          then greatest_not_zero P_mult_b + 1 else 0)\n         \\<le> rank_A) \\<and>\n     0 < ncols_iarray (matrix_to_iarray A) -\n         length\n          (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n            (IArray.list_of\n              (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))) =\n    (let GJ = Gauss_Jordan_iarrays_PA (matrix_to_iarray A);\n         rank_A =\n           length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of (snd GJ)));\n         P_mult_b = fst GJ *iv vec_to_iarray b;\n         consistent_A =\n           (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A;\n         dim_solution_set = ncols_iarray (matrix_to_iarray A) - rank_A\n     in consistent_A \\<and> 0 < dim_solution_set)", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if \\<not> is_zero_iarray\n                 (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                  vec_to_iarray b)\n      then greatest_not_zero\n            (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n             vec_to_iarray b) +\n           1\n      else 0)\n     \\<le> length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of\n                (snd (Gauss_Jordan_iarrays_PA\n                       (matrix_to_iarray A))))) \\<and>\n     0 < ncols_iarray (matrix_to_iarray A) -\n         length\n          (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n            (IArray.list_of\n              (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))) =\n    ((if \\<not> is_zero_iarray\n                 (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                  vec_to_iarray b)\n      then greatest_not_zero\n            (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n             vec_to_iarray b) +\n           1\n      else 0)\n     \\<le> length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of\n                (snd (Gauss_Jordan_iarrays_PA\n                       (matrix_to_iarray A))))) \\<and>\n     0 < ncols_iarray (matrix_to_iarray A) -\n         length\n          (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n            (IArray.list_of\n              (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A))))))", ".."], ["", "subsection\\<open>Solve a system of equations over nested IArrays\\<close>"], ["", "definition \"solve_system_iarrays A b = (let A' = Gauss_Jordan_iarrays_PA A in (snd A', fst A' *iv b))\""], ["", "lemma matrix_to_iarray_fst_solve_system: \"matrix_to_iarray (fst (solve_system A b)) = fst (solve_system_iarrays (matrix_to_iarray A) (vec_to_iarray b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (fst (solve_system A b)) =\n    fst (solve_system_iarrays (matrix_to_iarray A) (vec_to_iarray b))", "unfolding solve_system_def solve_system_iarrays_def Let_def fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (snd (Gauss_Jordan_PA A)) =\n    snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A))", "by (metis matrix_to_iarray_snd_Gauss_Jordan_PA)"], ["", "lemma vec_to_iarray_snd_solve_system: \"vec_to_iarray (snd (solve_system A b)) = snd (solve_system_iarrays (matrix_to_iarray A) (vec_to_iarray b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (snd (solve_system A b)) =\n    snd (solve_system_iarrays (matrix_to_iarray A) (vec_to_iarray b))", "unfolding solve_system_def solve_system_iarrays_def Let_def snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (fst (Gauss_Jordan_PA A) *v b) =\n    fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv vec_to_iarray b", "by (metis matrix_to_iarray_fst_Gauss_Jordan_PA vec_to_iarray_matrix_matrix_mult)"], ["", "definition \"solve_iarrays A b = (let GJ_P=Gauss_Jordan_iarrays_PA A; \n                        P_mult_b = fst GJ_P *iv b;\n                        rank_A = length [x\\<leftarrow>IArray.list_of (snd GJ_P) . \\<not> is_zero_iarray x];\n                        consistent_Ab = (if \\<not> is_zero_iarray P_mult_b then greatest_not_zero P_mult_b + 1 else 0) \\<le> rank_A;\n                        GJ_transpose = Gauss_Jordan_iarrays_PA (transpose_iarray A);\n                        basis =  set (map (\\<lambda>i. row_iarray i (fst GJ_transpose)) [rank_A..<ncols_iarray A])\n                        in (if consistent_Ab then Some (solve_consistent_rref_iarrays (snd GJ_P) P_mult_b,basis) else None))\""], ["", "definition \"pair_vec_vecset A = (if Option.is_none A then None else Some (vec_to_iarray (fst (the A)), vec_to_iarray` (snd (the A))))\""], ["", "lemma pair_vec_vecset_solve[code_unfold]:\nshows \"pair_vec_vecset (solve A b) = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_vec_vecset (solve A b) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "unfolding pair_vec_vecset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Option.is_none (solve A b) then None\n     else Some\n           (vec_to_iarray (fst (the (solve A b))),\n            vec_to_iarray ` snd (the (solve A b)))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. Option.is_none (solve A b) \\<Longrightarrow>\n    None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n 2. \\<not> Option.is_none (solve A b) \\<Longrightarrow>\n    Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "assume none_solve_Ab: \"Option.is_none (solve A b)\""], ["proof (state)\nthis:\n  Option.is_none (solve A b)\n\ngoal (2 subgoals):\n 1. Option.is_none (solve A b) \\<Longrightarrow>\n    None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n 2. \\<not> Option.is_none (solve A b) \\<Longrightarrow>\n    Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "show \"None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "define GJ_P where \"GJ_P = Gauss_Jordan_iarrays_PA (matrix_to_iarray A)\""], ["proof (state)\nthis:\n  GJ_P = Gauss_Jordan_iarrays_PA (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "define P_mult_b where \"P_mult_b = fst GJ_P *iv vec_to_iarray b\""], ["proof (state)\nthis:\n  P_mult_b = fst GJ_P *iv vec_to_iarray b\n\ngoal (1 subgoal):\n 1. None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "define rank_A where \"rank_A = length [x\\<leftarrow>IArray.list_of (snd GJ_P). \\<not> is_zero_iarray x]\""], ["proof (state)\nthis:\n  rank_A =\n  length\n   (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n     (IArray.list_of (snd GJ_P)))\n\ngoal (1 subgoal):\n 1. None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "have \"\\<not> consistent A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> consistent A b", "using none_solve_Ab"], ["proof (prove)\nusing this:\n  Option.is_none (solve A b)\n\ngoal (1 subgoal):\n 1. \\<not> consistent A b", "unfolding solve_def"], ["proof (prove)\nusing this:\n  Option.is_none\n   (if consistent A b\n    then Some\n          (solve_consistent_rref (fst (solve_system A b))\n            (snd (solve_system A b)),\n           basis_null_space A)\n    else None)\n\ngoal (1 subgoal):\n 1. \\<not> consistent A b", "unfolding Option.is_none_def"], ["proof (prove)\nusing this:\n  (if consistent A b\n   then Some\n         (solve_consistent_rref (fst (solve_system A b))\n           (snd (solve_system A b)),\n          basis_null_space A)\n   else None) =\n  None\n\ngoal (1 subgoal):\n 1. \\<not> consistent A b", "by auto"], ["proof (state)\nthis:\n  \\<not> consistent A b\n\ngoal (1 subgoal):\n 1. None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "hence \"\\<not> consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\""], ["proof (prove)\nusing this:\n  \\<not> consistent A b\n\ngoal (1 subgoal):\n 1. \\<not> consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "using matrix_to_iarray_consistent"], ["proof (prove)\nusing this:\n  \\<not> consistent A b\n  consistent ?A ?b =\n  consistent_iarrays (matrix_to_iarray ?A) (vec_to_iarray ?b)\n\ngoal (1 subgoal):\n 1. \\<not> consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "by auto"], ["proof (state)\nthis:\n  \\<not> consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n\ngoal (1 subgoal):\n 1. None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "hence \"\\<not> (if \\<not> is_zero_iarray P_mult_b then greatest_not_zero P_mult_b + 1 else 0) \\<le> rank_A\""], ["proof (prove)\nusing this:\n  \\<not> consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n\ngoal (1 subgoal):\n 1. \\<not> (if \\<not> is_zero_iarray P_mult_b\n            then greatest_not_zero P_mult_b + 1 else 0)\n           \\<le> rank_A", "unfolding GJ_P_def P_mult_b_def rank_A_def"], ["proof (prove)\nusing this:\n  \\<not> consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n\ngoal (1 subgoal):\n 1. \\<not> (if \\<not> is_zero_iarray\n                       (fst (Gauss_Jordan_iarrays_PA\n                              (matrix_to_iarray A)) *iv\n                        vec_to_iarray b)\n            then greatest_not_zero\n                  (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                   vec_to_iarray b) +\n                 1\n            else 0)\n           \\<le> length\n                  (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n                    (IArray.list_of\n                      (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))", "using consistent_iarrays_def"], ["proof (prove)\nusing this:\n  \\<not> consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n  consistent_iarrays ?A ?b =\n  (let GJ = Gauss_Jordan_iarrays_PA ?A;\n       rank_A =\n         length\n          (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n            (IArray.list_of (snd GJ)));\n       P_mult_b = fst GJ *iv ?b\n   in (if \\<not> is_zero_iarray P_mult_b then greatest_not_zero P_mult_b + 1\n       else 0)\n      \\<le> rank_A)\n\ngoal (1 subgoal):\n 1. \\<not> (if \\<not> is_zero_iarray\n                       (fst (Gauss_Jordan_iarrays_PA\n                              (matrix_to_iarray A)) *iv\n                        vec_to_iarray b)\n            then greatest_not_zero\n                  (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                   vec_to_iarray b) +\n                 1\n            else 0)\n           \\<le> length\n                  (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n                    (IArray.list_of\n                      (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))", "unfolding Let_def"], ["proof (prove)\nusing this:\n  \\<not> consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n  consistent_iarrays ?A ?b =\n  ((if \\<not> is_zero_iarray (fst (Gauss_Jordan_iarrays_PA ?A) *iv ?b)\n    then greatest_not_zero (fst (Gauss_Jordan_iarrays_PA ?A) *iv ?b) + 1\n    else 0)\n   \\<le> length\n          (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n            (IArray.list_of (snd (Gauss_Jordan_iarrays_PA ?A)))))\n\ngoal (1 subgoal):\n 1. \\<not> (if \\<not> is_zero_iarray\n                       (fst (Gauss_Jordan_iarrays_PA\n                              (matrix_to_iarray A)) *iv\n                        vec_to_iarray b)\n            then greatest_not_zero\n                  (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                   vec_to_iarray b) +\n                 1\n            else 0)\n           \\<le> length\n                  (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n                    (IArray.list_of\n                      (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))", "by fast"], ["proof (state)\nthis:\n  \\<not> (if \\<not> is_zero_iarray P_mult_b\n          then greatest_not_zero P_mult_b + 1 else 0)\n         \\<le> rank_A\n\ngoal (1 subgoal):\n 1. None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (if \\<not> is_zero_iarray P_mult_b\n          then greatest_not_zero P_mult_b + 1 else 0)\n         \\<le> rank_A\n\ngoal (1 subgoal):\n 1. None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "unfolding solve_iarrays_def Let_def"], ["proof (prove)\nusing this:\n  \\<not> (if \\<not> is_zero_iarray P_mult_b\n          then greatest_not_zero P_mult_b + 1 else 0)\n         \\<le> rank_A\n\ngoal (1 subgoal):\n 1. None =\n    (if (if \\<not> is_zero_iarray\n                    (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                     vec_to_iarray b)\n         then greatest_not_zero\n               (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                vec_to_iarray b) +\n              1\n         else 0)\n        \\<le> length\n               (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n                 (IArray.list_of\n                   (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))\n     then Some\n           (solve_consistent_rref_iarrays\n             (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n             (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n              vec_to_iarray b),\n            set (map (\\<lambda>i.\n                         row_iarray i\n                          (fst (Gauss_Jordan_iarrays_PA\n                                 (transpose_iarray (matrix_to_iarray A)))))\n                  [length\n                    (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n                      (IArray.list_of\n                        (snd (Gauss_Jordan_iarrays_PA\n                               (matrix_to_iarray A)))))..<\n                   ncols_iarray (matrix_to_iarray A)]))\n     else None)", "unfolding GJ_P_def P_mult_b_def rank_A_def"], ["proof (prove)\nusing this:\n  \\<not> (if \\<not> is_zero_iarray\n                     (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                      vec_to_iarray b)\n          then greatest_not_zero\n                (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                 vec_to_iarray b) +\n               1\n          else 0)\n         \\<le> length\n                (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n                  (IArray.list_of\n                    (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))\n\ngoal (1 subgoal):\n 1. None =\n    (if (if \\<not> is_zero_iarray\n                    (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                     vec_to_iarray b)\n         then greatest_not_zero\n               (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                vec_to_iarray b) +\n              1\n         else 0)\n        \\<le> length\n               (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n                 (IArray.list_of\n                   (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))\n     then Some\n           (solve_consistent_rref_iarrays\n             (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n             (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n              vec_to_iarray b),\n            set (map (\\<lambda>i.\n                         row_iarray i\n                          (fst (Gauss_Jordan_iarrays_PA\n                                 (transpose_iarray (matrix_to_iarray A)))))\n                  [length\n                    (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n                      (IArray.list_of\n                        (snd (Gauss_Jordan_iarrays_PA\n                               (matrix_to_iarray A)))))..<\n                   ncols_iarray (matrix_to_iarray A)]))\n     else None)", "by presburger"], ["proof (state)\nthis:\n  None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  None = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n\ngoal (1 subgoal):\n 1. \\<not> Option.is_none (solve A b) \\<Longrightarrow>\n    Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Option.is_none (solve A b) \\<Longrightarrow>\n    Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "assume not_none: \"\\<not> Option.is_none (solve A b)\""], ["proof (state)\nthis:\n  \\<not> Option.is_none (solve A b)\n\ngoal (1 subgoal):\n 1. \\<not> Option.is_none (solve A b) \\<Longrightarrow>\n    Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "show \"Some (vec_to_iarray (fst (the (solve A b))), vec_to_iarray ` snd (the (solve A b))) = solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "define GJ_P where \"GJ_P = Gauss_Jordan_iarrays_PA (matrix_to_iarray A)\""], ["proof (state)\nthis:\n  GJ_P = Gauss_Jordan_iarrays_PA (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "define P_mult_b where \"P_mult_b = fst GJ_P *iv vec_to_iarray b\""], ["proof (state)\nthis:\n  P_mult_b = fst GJ_P *iv vec_to_iarray b\n\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "define rank_A where \"rank_A = length [x\\<leftarrow>IArray.list_of (snd GJ_P) . \\<not> is_zero_iarray x]\""], ["proof (state)\nthis:\n  rank_A =\n  length\n   (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n     (IArray.list_of (snd GJ_P)))\n\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "define GJ_transpose where \"GJ_transpose = Gauss_Jordan_iarrays_PA (transpose_iarray (matrix_to_iarray A))\""], ["proof (state)\nthis:\n  GJ_transpose =\n  Gauss_Jordan_iarrays_PA (transpose_iarray (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "define basis where \"basis = set (map (\\<lambda>i. row_iarray i (fst GJ_transpose)) [rank_A..<ncols_iarray (matrix_to_iarray A)])\""], ["proof (state)\nthis:\n  basis =\n  set (map (\\<lambda>i. row_iarray i (fst GJ_transpose))\n        [rank_A..<ncols_iarray (matrix_to_iarray A)])\n\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "define P_mult_b where \"P_mult_b = fst GJ_P *iv vec_to_iarray b\""], ["proof (state)\nthis:\n  P_mult_b = fst GJ_P *iv vec_to_iarray b\n\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "have consistent_Ab: \"consistent A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent A b", "using not_none"], ["proof (prove)\nusing this:\n  \\<not> Option.is_none (solve A b)\n\ngoal (1 subgoal):\n 1. consistent A b", "unfolding solve_def"], ["proof (prove)\nusing this:\n  \\<not> Option.is_none\n          (if consistent A b\n           then Some\n                 (solve_consistent_rref (fst (solve_system A b))\n                   (snd (solve_system A b)),\n                  basis_null_space A)\n           else None)\n\ngoal (1 subgoal):\n 1. consistent A b", "unfolding Option.is_none_def"], ["proof (prove)\nusing this:\n  (if consistent A b\n   then Some\n         (solve_consistent_rref (fst (solve_system A b))\n           (snd (solve_system A b)),\n          basis_null_space A)\n   else None) \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. consistent A b", "by metis"], ["proof (state)\nthis:\n  consistent A b\n\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "hence \"consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\""], ["proof (prove)\nusing this:\n  consistent A b\n\ngoal (1 subgoal):\n 1. consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "using matrix_to_iarray_consistent"], ["proof (prove)\nusing this:\n  consistent A b\n  consistent ?A ?b =\n  consistent_iarrays (matrix_to_iarray ?A) (vec_to_iarray ?b)\n\ngoal (1 subgoal):\n 1. consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "by auto"], ["proof (state)\nthis:\n  consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "hence \"(if \\<not> is_zero_iarray P_mult_b then greatest_not_zero P_mult_b + 1 else 0) \\<le> rank_A\""], ["proof (prove)\nusing this:\n  consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n\ngoal (1 subgoal):\n 1. (if \\<not> is_zero_iarray P_mult_b then greatest_not_zero P_mult_b + 1\n     else 0)\n    \\<le> rank_A", "unfolding GJ_P_def P_mult_b_def rank_A_def"], ["proof (prove)\nusing this:\n  consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n\ngoal (1 subgoal):\n 1. (if \\<not> is_zero_iarray\n                (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                 vec_to_iarray b)\n     then greatest_not_zero\n           (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n            vec_to_iarray b) +\n          1\n     else 0)\n    \\<le> length\n           (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n             (IArray.list_of\n               (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))", "using consistent_iarrays_def"], ["proof (prove)\nusing this:\n  consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n  consistent_iarrays ?A ?b =\n  (let GJ = Gauss_Jordan_iarrays_PA ?A;\n       rank_A =\n         length\n          (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n            (IArray.list_of (snd GJ)));\n       P_mult_b = fst GJ *iv ?b\n   in (if \\<not> is_zero_iarray P_mult_b then greatest_not_zero P_mult_b + 1\n       else 0)\n      \\<le> rank_A)\n\ngoal (1 subgoal):\n 1. (if \\<not> is_zero_iarray\n                (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                 vec_to_iarray b)\n     then greatest_not_zero\n           (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n            vec_to_iarray b) +\n          1\n     else 0)\n    \\<le> length\n           (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n             (IArray.list_of\n               (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))", "unfolding Let_def"], ["proof (prove)\nusing this:\n  consistent_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n  consistent_iarrays ?A ?b =\n  ((if \\<not> is_zero_iarray (fst (Gauss_Jordan_iarrays_PA ?A) *iv ?b)\n    then greatest_not_zero (fst (Gauss_Jordan_iarrays_PA ?A) *iv ?b) + 1\n    else 0)\n   \\<le> length\n          (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n            (IArray.list_of (snd (Gauss_Jordan_iarrays_PA ?A)))))\n\ngoal (1 subgoal):\n 1. (if \\<not> is_zero_iarray\n                (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                 vec_to_iarray b)\n     then greatest_not_zero\n           (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n            vec_to_iarray b) +\n          1\n     else 0)\n    \\<le> length\n           (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n             (IArray.list_of\n               (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))", "by fast"], ["proof (state)\nthis:\n  (if \\<not> is_zero_iarray P_mult_b then greatest_not_zero P_mult_b + 1\n   else 0)\n  \\<le> rank_A\n\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "hence solve_iarrays_rw: \"solve_iarrays (matrix_to_iarray A) (vec_to_iarray b) = Some (solve_consistent_rref_iarrays (snd GJ_P) P_mult_b, basis)\""], ["proof (prove)\nusing this:\n  (if \\<not> is_zero_iarray P_mult_b then greatest_not_zero P_mult_b + 1\n   else 0)\n  \\<le> rank_A\n\ngoal (1 subgoal):\n 1. solve_iarrays (matrix_to_iarray A) (vec_to_iarray b) =\n    Some (solve_consistent_rref_iarrays (snd GJ_P) P_mult_b, basis)", "unfolding solve_iarrays_def Let_def P_mult_b_def GJ_P_def rank_A_def basis_def GJ_transpose_def"], ["proof (prove)\nusing this:\n  (if \\<not> is_zero_iarray\n              (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n               vec_to_iarray b)\n   then greatest_not_zero\n         (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n          vec_to_iarray b) +\n        1\n   else 0)\n  \\<le> length\n         (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n           (IArray.list_of\n             (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))\n\ngoal (1 subgoal):\n 1. (if (if \\<not> is_zero_iarray\n                    (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                     vec_to_iarray b)\n         then greatest_not_zero\n               (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n                vec_to_iarray b) +\n              1\n         else 0)\n        \\<le> length\n               (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n                 (IArray.list_of\n                   (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))\n     then Some\n           (solve_consistent_rref_iarrays\n             (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n             (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n              vec_to_iarray b),\n            set (map (\\<lambda>i.\n                         row_iarray i\n                          (fst (Gauss_Jordan_iarrays_PA\n                                 (transpose_iarray (matrix_to_iarray A)))))\n                  [length\n                    (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n                      (IArray.list_of\n                        (snd (Gauss_Jordan_iarrays_PA\n                               (matrix_to_iarray A)))))..<\n                   ncols_iarray (matrix_to_iarray A)]))\n     else None) =\n    Some\n     (solve_consistent_rref_iarrays\n       (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n       (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n        vec_to_iarray b),\n      set (map (\\<lambda>i.\n                   row_iarray i\n                    (fst (Gauss_Jordan_iarrays_PA\n                           (transpose_iarray (matrix_to_iarray A)))))\n            [length\n              (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n                (IArray.list_of\n                  (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))..<\n             ncols_iarray (matrix_to_iarray A)]))", "by auto"], ["proof (state)\nthis:\n  solve_iarrays (matrix_to_iarray A) (vec_to_iarray b) =\n  Some (solve_consistent_rref_iarrays (snd GJ_P) P_mult_b, basis)\n\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "have snd_rw: \"vec_to_iarray ` basis_null_space A = basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray ` basis_null_space A = basis", "unfolding basis_def GJ_transpose_def rank_A_def GJ_P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray ` basis_null_space A =\n    set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (transpose_iarray (matrix_to_iarray A)))))\n          [length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of\n                (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))..<\n           ncols_iarray (matrix_to_iarray A)])", "unfolding vec_to_iarray_basis_null_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_null_space_iarrays (matrix_to_iarray A) =\n    set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (transpose_iarray (matrix_to_iarray A)))))\n          [length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of\n                (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))..<\n           ncols_iarray (matrix_to_iarray A)])", "unfolding basis_null_space_iarrays_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (transpose_iarray (matrix_to_iarray A)))))\n          [length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of\n                (snd (Gauss_Jordan_iarrays_PA\n                       (transpose_iarray (matrix_to_iarray A))))))..<\n           ncols_iarray (matrix_to_iarray A)]) =\n    set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (transpose_iarray (matrix_to_iarray A)))))\n          [length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of\n                (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))))..<\n           ncols_iarray (matrix_to_iarray A)])", "unfolding snd_Gauss_Jordan_iarrays_PA_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (transpose_iarray (matrix_to_iarray A)))))\n          [length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of\n                (Gauss_Jordan_iarrays\n                  (transpose_iarray (matrix_to_iarray A)))))..<\n           ncols_iarray (matrix_to_iarray A)]) =\n    set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (transpose_iarray (matrix_to_iarray A)))))\n          [length\n            (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n              (IArray.list_of\n                (Gauss_Jordan_iarrays (matrix_to_iarray A))))..<\n           ncols_iarray (matrix_to_iarray A)])", "unfolding rank_iarrays_code[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (transpose_iarray (matrix_to_iarray A)))))\n          [rank_iarray (transpose_iarray (matrix_to_iarray A))..<\n           ncols_iarray (matrix_to_iarray A)]) =\n    set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (transpose_iarray (matrix_to_iarray A)))))\n          [rank_iarray (matrix_to_iarray A)..<\n           ncols_iarray (matrix_to_iarray A)])", "unfolding matrix_to_iarray_transpose[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (matrix_to_iarray\n                           (Finite_Cartesian_Product.transpose A)))))\n          [rank_iarray\n            (matrix_to_iarray (Finite_Cartesian_Product.transpose A))..<\n           ncols_iarray (matrix_to_iarray A)]) =\n    set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (matrix_to_iarray\n                           (Finite_Cartesian_Product.transpose A)))))\n          [rank_iarray (matrix_to_iarray A)..<\n           ncols_iarray (matrix_to_iarray A)])", "unfolding matrix_to_iarray_rank[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (matrix_to_iarray\n                           (Finite_Cartesian_Product.transpose A)))))\n          [rank (Finite_Cartesian_Product.transpose A)..<\n           ncols_iarray (matrix_to_iarray A)]) =\n    set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (matrix_to_iarray\n                           (Finite_Cartesian_Product.transpose A)))))\n          [rank A..<ncols_iarray (matrix_to_iarray A)])", "unfolding rank_transpose[symmetric, of A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (matrix_to_iarray\n                           (Finite_Cartesian_Product.transpose A)))))\n          [rank (Finite_Cartesian_Product.transpose A)..<\n           ncols_iarray (matrix_to_iarray A)]) =\n    set (map (\\<lambda>i.\n                 row_iarray i\n                  (fst (Gauss_Jordan_iarrays_PA\n                         (matrix_to_iarray\n                           (Finite_Cartesian_Product.transpose A)))))\n          [rank (Finite_Cartesian_Product.transpose A)..<\n           ncols_iarray (matrix_to_iarray A)])", ".."], ["proof (state)\nthis:\n  vec_to_iarray ` basis_null_space A = basis\n\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "have fst_rw: \"vec_to_iarray (solve_consistent_rref (fst (solve_system A b)) (snd (solve_system A b))) = solve_consistent_rref_iarrays (snd GJ_P) P_mult_b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (solve_consistent_rref (fst (solve_system A b))\n       (snd (solve_system A b))) =\n    solve_consistent_rref_iarrays (snd GJ_P) P_mult_b", "using vec_to_iarray_solve_consistent_rref[OF rref_Gauss_Jordan, of A \"fst (Gauss_Jordan_PA A) *v b\"]"], ["proof (prove)\nusing this:\n  vec_to_iarray\n   (solve_consistent_rref (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b)) =\n  solve_consistent_rref_iarrays (matrix_to_iarray (Gauss_Jordan A))\n   (vec_to_iarray (fst (Gauss_Jordan_PA A) *v b))\n\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (solve_consistent_rref (fst (solve_system A b))\n       (snd (solve_system A b))) =\n    solve_consistent_rref_iarrays (snd GJ_P) P_mult_b", "unfolding solve_system_def Let_def fst_conv"], ["proof (prove)\nusing this:\n  vec_to_iarray\n   (solve_consistent_rref (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b)) =\n  solve_consistent_rref_iarrays (matrix_to_iarray (Gauss_Jordan A))\n   (vec_to_iarray (fst (Gauss_Jordan_PA A) *v b))\n\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (solve_consistent_rref (snd (Gauss_Jordan_PA A))\n       (snd (snd (Gauss_Jordan_PA A), fst (Gauss_Jordan_PA A) *v b))) =\n    solve_consistent_rref_iarrays (snd GJ_P) P_mult_b", "unfolding Gauss_Jordan_PA_eq snd_conv"], ["proof (prove)\nusing this:\n  vec_to_iarray\n   (solve_consistent_rref (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b)) =\n  solve_consistent_rref_iarrays (matrix_to_iarray (Gauss_Jordan A))\n   (vec_to_iarray (fst (Gauss_Jordan_PA A) *v b))\n\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (solve_consistent_rref (Gauss_Jordan A)\n       (fst (Gauss_Jordan_PA A) *v b)) =\n    solve_consistent_rref_iarrays (snd GJ_P) P_mult_b", "unfolding GJ_P_def P_mult_b_def"], ["proof (prove)\nusing this:\n  vec_to_iarray\n   (solve_consistent_rref (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b)) =\n  solve_consistent_rref_iarrays (matrix_to_iarray (Gauss_Jordan A))\n   (vec_to_iarray (fst (Gauss_Jordan_PA A) *v b))\n\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (solve_consistent_rref (Gauss_Jordan A)\n       (fst (Gauss_Jordan_PA A) *v b)) =\n    solve_consistent_rref_iarrays\n     (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n      vec_to_iarray b)", "unfolding vec_to_iarray_matrix_matrix_mult"], ["proof (prove)\nusing this:\n  vec_to_iarray\n   (solve_consistent_rref (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b)) =\n  solve_consistent_rref_iarrays (matrix_to_iarray (Gauss_Jordan A))\n   (matrix_to_iarray (fst (Gauss_Jordan_PA A)) *iv vec_to_iarray b)\n\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (solve_consistent_rref (Gauss_Jordan A)\n       (fst (Gauss_Jordan_PA A) *v b)) =\n    solve_consistent_rref_iarrays\n     (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     (fst (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)) *iv\n      vec_to_iarray b)", "unfolding matrix_to_iarray_fst_Gauss_Jordan_PA[symmetric]"], ["proof (prove)\nusing this:\n  vec_to_iarray\n   (solve_consistent_rref (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b)) =\n  solve_consistent_rref_iarrays (matrix_to_iarray (Gauss_Jordan A))\n   (matrix_to_iarray (fst (Gauss_Jordan_PA A)) *iv vec_to_iarray b)\n\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (solve_consistent_rref (Gauss_Jordan A)\n       (fst (Gauss_Jordan_PA A) *v b)) =\n    solve_consistent_rref_iarrays\n     (snd (Gauss_Jordan_iarrays_PA (matrix_to_iarray A)))\n     (matrix_to_iarray (fst (Gauss_Jordan_PA A)) *iv vec_to_iarray b)", "unfolding matrix_to_iarray_snd_Gauss_Jordan_PA[symmetric]"], ["proof (prove)\nusing this:\n  vec_to_iarray\n   (solve_consistent_rref (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b)) =\n  solve_consistent_rref_iarrays (matrix_to_iarray (Gauss_Jordan A))\n   (matrix_to_iarray (fst (Gauss_Jordan_PA A)) *iv vec_to_iarray b)\n\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (solve_consistent_rref (Gauss_Jordan A)\n       (fst (Gauss_Jordan_PA A) *v b)) =\n    solve_consistent_rref_iarrays\n     (matrix_to_iarray (snd (Gauss_Jordan_PA A)))\n     (matrix_to_iarray (fst (Gauss_Jordan_PA A)) *iv vec_to_iarray b)", "unfolding Gauss_Jordan_PA_eq"], ["proof (prove)\nusing this:\n  vec_to_iarray\n   (solve_consistent_rref (Gauss_Jordan A) (fst (Gauss_Jordan_PA A) *v b)) =\n  solve_consistent_rref_iarrays (matrix_to_iarray (Gauss_Jordan A))\n   (matrix_to_iarray (fst (Gauss_Jordan_PA A)) *iv vec_to_iarray b)\n\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (solve_consistent_rref (Gauss_Jordan A)\n       (fst (Gauss_Jordan_PA A) *v b)) =\n    solve_consistent_rref_iarrays (matrix_to_iarray (Gauss_Jordan A))\n     (matrix_to_iarray (fst (Gauss_Jordan_PA A)) *iv vec_to_iarray b)", "."], ["proof (state)\nthis:\n  vec_to_iarray\n   (solve_consistent_rref (fst (solve_system A b))\n     (snd (solve_system A b))) =\n  solve_consistent_rref_iarrays (snd GJ_P) P_mult_b\n\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)", "unfolding solve_iarrays_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray (fst (the (solve A b))),\n      vec_to_iarray ` snd (the (solve A b))) =\n    Some (solve_consistent_rref_iarrays (snd GJ_P) P_mult_b, basis)", "unfolding solve_def if_P[OF consistent_Ab] option.sel fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some\n     (vec_to_iarray\n       (solve_consistent_rref (fst (solve_system A b))\n         (snd (solve_system A b))),\n      vec_to_iarray ` basis_null_space A) =\n    Some (solve_consistent_rref_iarrays (snd GJ_P) P_mult_b, basis)", "unfolding fst_rw snd_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some (solve_consistent_rref_iarrays (snd GJ_P) P_mult_b, basis) =\n    Some (solve_consistent_rref_iarrays (snd GJ_P) P_mult_b, basis)", ".."], ["proof (state)\nthis:\n  Some\n   (vec_to_iarray (fst (the (solve A b))),\n    vec_to_iarray ` snd (the (solve A b))) =\n  solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Some\n   (vec_to_iarray (fst (the (solve A b))),\n    vec_to_iarray ` snd (the (solve A b))) =\n  solve_iarrays (matrix_to_iarray A) (vec_to_iarray b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}